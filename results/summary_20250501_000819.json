[
  {
    "cve_id": "ASB-A-363248394",
    "downstream_version": "12",
    "file_name": "src/com/android/settings/notification/NotificationAccessConfirmationActivity.java",
    "upstream_codebase": "/*\n * Copyright (C) 2017 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\npackage com.android.settings.notification;\n\nimport static android.app.admin.DevicePolicyResources.Strings.Settings.WORK_APPS_CANNOT_ACCESS_NOTIFICATION_SETTINGS;\nimport static android.view.WindowManager.LayoutParams.SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS;\n\nimport static com.android.internal.notification.NotificationAccessConfirmationActivityContract.EXTRA_COMPONENT_NAME;\nimport static com.android.internal.notification.NotificationAccessConfirmationActivityContract.EXTRA_USER_ID;\n\nimport android.Manifest;\nimport android.app.Activity;\nimport android.app.NotificationManager;\nimport android.app.admin.DevicePolicyManager;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.PackageItemInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.ResolveInfo;\nimport android.os.Bundle;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.service.notification.NotificationListenerService;\nimport android.text.TextUtils;\nimport android.util.Slog;\nimport android.view.WindowManager;\nimport android.view.accessibility.AccessibilityEvent;\nimport android.widget.Toast;\n\nimport androidx.annotation.Nullable;\n\nimport com.android.internal.app.AlertActivity;\nimport com.android.internal.app.AlertController;\nimport com.android.settings.R;\n\nimport java.util.List;\n\n/** @hide */\npublic class NotificationAccessConfirmationActivity extends Activity\n        implements DialogInterface {\n\n    private static final boolean DEBUG = false;\n    private static final String LOG_TAG = \"NotificationAccessConfirmationActivity\";\n\n    private int mUserId;\n    private ComponentName mComponentName;\n    private NotificationManager mNm;\n\n    private DevicePolicyManager mDpm;\n    private UserManager mUm;\n\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        getWindow().addSystemFlags(SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);\n\n        mUm = getSystemService(UserManager.class);\n        mDpm = getSystemService(DevicePolicyManager.class);\n\n        if (mUm.isManagedProfile()) {\n            Slog.w(LOG_TAG, \"Apps in the work profile do not support notification listeners\");\n            Toast.makeText(this,\n                    mDpm.getResources().getString(WORK_APPS_CANNOT_ACCESS_NOTIFICATION_SETTINGS,\n                            () -> getString(R.string.notification_settings_work_profile)),\n                    Toast.LENGTH_SHORT).show();\n            finish();\n            return;\n        }\n\n        mNm = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);\n\n        mComponentName = getIntent().getParcelableExtra(EXTRA_COMPONENT_NAME);\n        mUserId = getIntent().getIntExtra(EXTRA_USER_ID, UserHandle.USER_NULL);\n        CharSequence mAppLabel;\n\n        if (mComponentName == null || mComponentName.getPackageName() == null\n                || mComponentName.flattenToString().length()\n                > NotificationManager.MAX_SERVICE_COMPONENT_NAME_LENGTH) {\n            finish();\n            return;\n        }\n\n        try {\n            ApplicationInfo applicationInfo = getPackageManager().getApplicationInfo(\n                    mComponentName.getPackageName(), 0);\n            mAppLabel = applicationInfo.loadSafeLabel(getPackageManager(),\n                    PackageItemInfo.DEFAULT_MAX_LABEL_SIZE_PX,\n                    PackageItemInfo.SAFE_LABEL_FLAG_TRIM\n                            | PackageItemInfo.SAFE_LABEL_FLAG_FIRST_LINE);\n        } catch (PackageManager.NameNotFoundException e) {\n            Slog.e(LOG_TAG, \"Couldn't find app with package name for \" + mComponentName, e);\n            finish();\n            return;\n        }\n\n        if (TextUtils.isEmpty(mAppLabel)) {\n            finish();\n            return;\n        }\n\n        // Check NLS service info.\n        String requiredPermission = Manifest.permission.BIND_NOTIFICATION_LISTENER_SERVICE;\n        Intent NLSIntent = new Intent(NotificationListenerService.SERVICE_INTERFACE);\n        List<ResolveInfo> matchedServiceList = getPackageManager().queryIntentServicesAsUser(\n                NLSIntent, /* flags */ 0, mUserId);\n        boolean hasNLSIntentFilter = false;\n        for (ResolveInfo service : matchedServiceList) {\n            if (service.serviceInfo.packageName.equals(mComponentName.getPackageName())) {\n                if (!requiredPermission.equals(service.serviceInfo.permission)) {\n                    Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks permission \"\n                            + requiredPermission);\n                    finish();\n                    return;\n                }\n                hasNLSIntentFilter = true;\n                break;\n            }\n        }\n        if (!hasNLSIntentFilter) {\n            Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks an intent-filter action \"\n                    + \"for android.service.notification.NotificationListenerService.\");\n            finish();\n            return;\n        }\n\n        AlertController.AlertParams p = new AlertController.AlertParams(this);\n        p.mTitle = getString(\n                R.string.notification_listener_security_warning_title,\n                mAppLabel);\n        p.mMessage = getString(\n                R.string.notification_listener_security_warning_summary,\n                mAppLabel);\n        p.mPositiveButtonText = getString(R.string.allow);\n        p.mPositiveButtonListener = (a, b) -> onAllow();\n        p.mNegativeButtonText = getString(R.string.deny);\n        p.mNegativeButtonListener = (a, b) -> cancel();\n        AlertController\n                .create(this, this, getWindow())\n                .installContent(p);\n        // Consistent with the permission dialog\n        // Used instead of p.mCancelable as that is only honored for AlertDialog\n        getWindow().setCloseOnTouchOutside(false); \n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n        getWindow().addFlags(\n                WindowManager.LayoutParams.SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);\n    }\n\n    @Override\n    public void onPause() {\n        getWindow().clearFlags(\n                WindowManager.LayoutParams.SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);\n        super.onPause();\n    }\n\n    private void onAllow() {\n        mNm.setNotificationListenerAccessGranted(mComponentName, true);\n\n        finish();\n    }\n\n    @Override\n    public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {\n        return AlertActivity.dispatchPopulateAccessibilityEvent(this, event);\n    }\n\n    @Override\n    public void cancel() {\n        finish();\n    }\n\n    @Override\n    public void dismiss() {\n        // This is called after the click, since we finish when handling the\n        // click, don't do that again here.\n        if (!isFinishing()) {\n            finish();\n        }\n    }\n}",
    "downstream_codebase": "/*\n * Copyright (C) 2017 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\npackage com.android.settings.notification;\n\nimport static android.view.WindowManager.LayoutParams.SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS;\n\nimport static com.android.internal.notification.NotificationAccessConfirmationActivityContract.EXTRA_COMPONENT_NAME;\nimport static com.android.internal.notification.NotificationAccessConfirmationActivityContract.EXTRA_USER_ID;\n\nimport android.Manifest;\nimport android.annotation.Nullable;\nimport android.app.Activity;\nimport android.app.NotificationManager;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.PackageItemInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.ServiceInfo;\nimport android.os.Bundle;\nimport android.os.UserHandle;\nimport android.text.TextUtils;\nimport android.util.Slog;\nimport android.view.WindowManager;\nimport android.view.accessibility.AccessibilityEvent;\n\nimport com.android.internal.app.AlertActivity;\nimport com.android.internal.app.AlertController;\nimport com.android.settings.R;\n\nimport java.util.List;\n\n/** @hide */\npublic class NotificationAccessConfirmationActivity extends Activity\n        implements DialogInterface {\n\n    private static final boolean DEBUG = false;\n    private static final String LOG_TAG = \"NotificationAccessConfirmationActivity\";\n\n    private int mUserId;\n    private ComponentName mComponentName;\n    private NotificationManager mNm;\n\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        getWindow().addSystemFlags(SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);\n\n        mNm = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);\n\n        mComponentName = getIntent().getParcelableExtra(EXTRA_COMPONENT_NAME);\n        mUserId = getIntent().getIntExtra(EXTRA_USER_ID, UserHandle.USER_NULL);\n        CharSequence mAppLabel;\n\n        if (mComponentName == null || mComponentName.getPackageName() == null\n                || mComponentName.flattenToString().length()\n                > NotificationManager.MAX_SERVICE_COMPONENT_NAME_LENGTH) {\n            finish();\n            return;\n        }\n\n        try {\n            ApplicationInfo applicationInfo = getPackageManager().getApplicationInfo(\n                    mComponentName.getPackageName(), 0);\n            mAppLabel = applicationInfo.loadSafeLabel(getPackageManager(),\n                    PackageItemInfo.DEFAULT_MAX_LABEL_SIZE_PX,\n                    PackageItemInfo.SAFE_LABEL_FLAG_TRIM\n                            | PackageItemInfo.SAFE_LABEL_FLAG_FIRST_LINE);\n        } catch (PackageManager.NameNotFoundException e) {\n            Slog.e(LOG_TAG, \"Couldn't find app with package name for \" + mComponentName, e);\n            finish();\n            return;\n        }\n\n        if (TextUtils.isEmpty(mAppLabel)) {\n            finish();\n            return;\n        }\n\n        // Check NLS service info.\n        String requiredPermission = Manifest.permission.BIND_NOTIFICATION_LISTENER_SERVICE;\n        Intent NLSIntent = new Intent(NotificationListenerService.SERVICE_INTERFACE);\n        List<ResolveInfo> matchedServiceList = getPackageManager().queryIntentServicesAsUser(\n                NLSIntent, /* flags */ 0, mUserId);\n        boolean hasNLSIntentFilter = false;\n        for (ResolveInfo service : matchedServiceList) {\n            if (service.serviceInfo.packageName.equals(mComponentName.getPackageName())) {\n                if (!requiredPermission.equals(service.serviceInfo.permission)) {\n                    Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks permission \"\n                            + requiredPermission);\n                    finish();\n                    return;\n                }\n                hasNLSIntentFilter = true;\n                break;\n            }\n        }\n        if (!hasNLSIntentFilter) {\n            Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks an intent-filter action \"\n                    + \"for android.service.notification.NotificationListenerService.\");\n            finish();\n            return;\n        }\n\n        AlertController.AlertParams p = new AlertController.AlertParams(this);\n        p.mTitle = getString(\n                R.string.notification_listener_security_warning_title,\n                mAppLabel);\n        p.mMessage = getString(\n                R.string.notification_listener_security_warning_summary,\n                mAppLabel);\n        p.mPositiveButtonText = getString(R.string.allow);\n        p.mPositiveButtonListener = (a, b) -> onAllow();\n        p.mNegativeButtonText = getString(R.string.deny);\n        p.mNegativeButtonListener = (a, b) -> cancel();\n        AlertController\n                .create(this, this, getWindow())\n                .installContent(p);\n        // Consistent with the permission dialog\n        // Used instead of p.mCancelable as that is only honored for AlertDialog\n        getWindow().setCloseOnTouchOutside(false); \n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n        getWindow().addFlags(\n                WindowManager.LayoutParams.SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);\n    }\n\n    @Override\n    public void onPause() {\n        getWindow().clearFlags(\n                WindowManager.LayoutParams.SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);\n        super.onPause();\n    }\n\n    private void onAllow() {\n        mNm.setNotificationListenerAccessGranted(mComponentName, true);\n\n        finish();\n    }\n\n    @Override\n    public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {\n        return AlertActivity.dispatchPopulateAccessibilityEvent(this, event);\n    }\n\n    @Override\n    public void cancel() {\n        finish();\n    }\n\n    @Override\n    public void dismiss() {\n        // This is called after the click, since we finish when handling the\n        // click, don't do that again here.\n        if (!isFinishing()) {\n            finish();\n        }\n    }\n}",
    "metrics": {
      "relative_line_count_similarity": 0.8895,
      "token_level_edit_similarity": 0.8717,
      "normalized_edit_similarity": 0.1283,
      "token_level_edit_distance": 0.1283,
      "codebert_score": {
        "precision": 0.9308,
        "recall": 0.9112,
        "f1": 0.9209,
        "f3": 0.9131
      },
      "token_count_upstream": 530,
      "token_count_downstream": 482,
      "token_count_total": 1012,
      "cosine_similarity_openai": 0.9686
    }
  },
  {
    "cve_id": "ASB-A-363248394",
    "downstream_version": "12L",
    "file_name": "src/com/android/settings/notification/NotificationAccessConfirmationActivity.java",
    "upstream_codebase": "/*\n * Copyright (C) 2017 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\npackage com.android.settings.notification;\n\nimport static android.app.admin.DevicePolicyResources.Strings.Settings.WORK_APPS_CANNOT_ACCESS_NOTIFICATION_SETTINGS;\nimport static android.view.WindowManager.LayoutParams.SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS;\n\nimport static com.android.internal.notification.NotificationAccessConfirmationActivityContract.EXTRA_COMPONENT_NAME;\nimport static com.android.internal.notification.NotificationAccessConfirmationActivityContract.EXTRA_USER_ID;\n\nimport android.Manifest;\nimport android.app.Activity;\nimport android.app.NotificationManager;\nimport android.app.admin.DevicePolicyManager;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.PackageItemInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.ResolveInfo;\nimport android.os.Bundle;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.service.notification.NotificationListenerService;\nimport android.text.TextUtils;\nimport android.util.Slog;\nimport android.view.WindowManager;\nimport android.view.accessibility.AccessibilityEvent;\nimport android.widget.Toast;\n\nimport androidx.annotation.Nullable;\n\nimport com.android.internal.app.AlertActivity;\nimport com.android.internal.app.AlertController;\nimport com.android.settings.R;\n\nimport java.util.List;\n\n/** @hide */\npublic class NotificationAccessConfirmationActivity extends Activity\n        implements DialogInterface {\n\n    private static final boolean DEBUG = false;\n    private static final String LOG_TAG = \"NotificationAccessConfirmationActivity\";\n\n    private int mUserId;\n    private ComponentName mComponentName;\n    private NotificationManager mNm;\n\n    private DevicePolicyManager mDpm;\n    private UserManager mUm;\n\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        getWindow().addSystemFlags(SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);\n\n        mUm = getSystemService(UserManager.class);\n        mDpm = getSystemService(DevicePolicyManager.class);\n\n        if (mUm.isManagedProfile()) {\n            Slog.w(LOG_TAG, \"Apps in the work profile do not support notification listeners\");\n            Toast.makeText(this,\n                    mDpm.getResources().getString(WORK_APPS_CANNOT_ACCESS_NOTIFICATION_SETTINGS,\n                            () -> getString(R.string.notification_settings_work_profile)),\n                    Toast.LENGTH_SHORT).show();\n            finish();\n            return;\n        }\n\n        mNm = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);\n\n        mComponentName = getIntent().getParcelableExtra(EXTRA_COMPONENT_NAME);\n        mUserId = getIntent().getIntExtra(EXTRA_USER_ID, UserHandle.USER_NULL);\n        CharSequence mAppLabel;\n\n        if (mComponentName == null || mComponentName.getPackageName() == null\n                || mComponentName.flattenToString().length()\n                > NotificationManager.MAX_SERVICE_COMPONENT_NAME_LENGTH) {\n            finish();\n            return;\n        }\n\n        try {\n            ApplicationInfo applicationInfo = getPackageManager().getApplicationInfo(\n                    mComponentName.getPackageName(), 0);\n            mAppLabel = applicationInfo.loadSafeLabel(getPackageManager(),\n                    PackageItemInfo.DEFAULT_MAX_LABEL_SIZE_PX,\n                    PackageItemInfo.SAFE_LABEL_FLAG_TRIM\n                            | PackageItemInfo.SAFE_LABEL_FLAG_FIRST_LINE);\n        } catch (PackageManager.NameNotFoundException e) {\n            Slog.e(LOG_TAG, \"Couldn't find app with package name for \" + mComponentName, e);\n            finish();\n            return;\n        }\n\n        if (TextUtils.isEmpty(mAppLabel)) {\n            finish();\n            return;\n        }\n\n        // Check NLS service info.\n        String requiredPermission = Manifest.permission.BIND_NOTIFICATION_LISTENER_SERVICE;\n        Intent NLSIntent = new Intent(NotificationListenerService.SERVICE_INTERFACE);\n        List<ResolveInfo> matchedServiceList = getPackageManager().queryIntentServicesAsUser(\n                NLSIntent, /* flags */ 0, mUserId);\n        boolean hasNLSIntentFilter = false;\n        for (ResolveInfo service : matchedServiceList) {\n            if (service.serviceInfo.packageName.equals(mComponentName.getPackageName())) {\n                if (!requiredPermission.equals(service.serviceInfo.permission)) {\n                    Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks permission \"\n                            + requiredPermission);\n                    finish();\n                    return;\n                }\n                hasNLSIntentFilter = true;\n                break;\n            }\n        }\n        if (!hasNLSIntentFilter) {\n            Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks an intent-filter action \"\n                    + \"for android.service.notification.NotificationListenerService.\");\n            finish();\n            return;\n        }\n\n        AlertController.AlertParams p = new AlertController.AlertParams(this);\n        p.mTitle = getString(\n                R.string.notification_listener_security_warning_title,\n                mAppLabel);\n        p.mMessage = getString(\n                R.string.notification_listener_security_warning_summary,\n                mAppLabel);\n        p.mPositiveButtonText = getString(R.string.allow);\n        p.mPositiveButtonListener = (a, b) -> onAllow();\n        p.mNegativeButtonText = getString(R.string.deny);\n        p.mNegativeButtonListener = (a, b) -> cancel();\n        AlertController\n                .create(this, this, getWindow())\n                .installContent(p);\n        // Consistent with the permission dialog\n        // Used instead of p.mCancelable as that is only honored for AlertDialog\n        getWindow().setCloseOnTouchOutside(false); \n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n        getWindow().addFlags(\n                WindowManager.LayoutParams.SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);\n    }\n\n    @Override\n    public void onPause() {\n        getWindow().clearFlags(\n                WindowManager.LayoutParams.SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);\n        super.onPause();\n    }\n\n    private void onAllow() {\n        mNm.setNotificationListenerAccessGranted(mComponentName, true);\n\n        finish();\n    }\n\n    @Override\n    public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {\n        return AlertActivity.dispatchPopulateAccessibilityEvent(this, event);\n    }\n\n    @Override\n    public void cancel() {\n        finish();\n    }\n\n    @Override\n    public void dismiss() {\n        // This is called after the click, since we finish when handling the\n        // click, don't do that again here.\n        if (!isFinishing()) {\n            finish();\n        }\n    }\n}",
    "downstream_codebase": "/*\n * Copyright (C) 2017 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\npackage com.android.settings.notification;\n\nimport static android.view.WindowManager.LayoutParams.SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS;\n\nimport static com.android.internal.notification.NotificationAccessConfirmationActivityContract.EXTRA_COMPONENT_NAME;\nimport static com.android.internal.notification.NotificationAccessConfirmationActivityContract.EXTRA_USER_ID;\n\nimport android.Manifest;\nimport android.annotation.Nullable;\nimport android.app.Activity;\nimport android.app.NotificationManager;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.PackageItemInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.ServiceInfo;\nimport android.os.Bundle;\nimport android.os.UserHandle;\nimport android.text.TextUtils;\nimport android.util.Slog;\nimport android.view.WindowManager;\nimport android.view.accessibility.AccessibilityEvent;\n\nimport com.android.internal.app.AlertActivity;\nimport com.android.internal.app.AlertController;\nimport com.android.settings.R;\n\nimport java.util.List;\n\n/** @hide */\npublic class NotificationAccessConfirmationActivity extends Activity\n        implements DialogInterface {\n\n    private static final boolean DEBUG = false;\n    private static final String LOG_TAG = \"NotificationAccessConfirmationActivity\";\n\n    private int mUserId;\n    private ComponentName mComponentName;\n    private NotificationManager mNm;\n\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        getWindow().addSystemFlags(SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);\n\n        mNm = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);\n\n        mComponentName = getIntent().getParcelableExtra(EXTRA_COMPONENT_NAME);\n        mUserId = getIntent().getIntExtra(EXTRA_USER_ID, UserHandle.USER_NULL);\n        CharSequence mAppLabel;\n\n        if (mComponentName == null || mComponentName.getPackageName() == null\n                || mComponentName.flattenToString().length()\n                > NotificationManager.MAX_SERVICE_COMPONENT_NAME_LENGTH) {\n            finish();\n            return;\n        }\n\n        try {\n            ApplicationInfo applicationInfo = getPackageManager().getApplicationInfo(\n                    mComponentName.getPackageName(), 0);\n            mAppLabel = applicationInfo.loadSafeLabel(getPackageManager(),\n                    PackageItemInfo.DEFAULT_MAX_LABEL_SIZE_PX,\n                    PackageItemInfo.SAFE_LABEL_FLAG_TRIM\n                            | PackageItemInfo.SAFE_LABEL_FLAG_FIRST_LINE);\n        } catch (PackageManager.NameNotFoundException e) {\n            Slog.e(LOG_TAG, \"Couldn't find app with package name for \" + mComponentName, e);\n            finish();\n            return;\n        }\n\n        if (TextUtils.isEmpty(mAppLabel)) {\n            finish();\n            return;\n        }\n\n        // Check NLS service info.\n        String requiredPermission = Manifest.permission.BIND_NOTIFICATION_LISTENER_SERVICE;\n        Intent NLSIntent = new Intent(NotificationListenerService.SERVICE_INTERFACE);\n        List<ResolveInfo> matchedServiceList = getPackageManager().queryIntentServicesAsUser(\n                NLSIntent, /* flags */ 0, mUserId);\n        boolean hasNLSIntentFilter = false;\n        for (ResolveInfo service : matchedServiceList) {\n            if (service.serviceInfo.packageName.equals(mComponentName.getPackageName())) {\n                if (!requiredPermission.equals(service.serviceInfo.permission)) {\n                    Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks permission \"\n                            + requiredPermission);\n                    finish();\n                    return;\n                }\n                hasNLSIntentFilter = true;\n                break;\n            }\n        }\n        if (!hasNLSIntentFilter) {\n            Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks an intent-filter action \"\n                    + \"for android.service.notification.NotificationListenerService.\");\n            finish();\n            return;\n        }\n\n        AlertController.AlertParams p = new AlertController.AlertParams(this);\n        p.mTitle = getString(\n                R.string.notification_listener_security_warning_title,\n                mAppLabel);\n        p.mMessage = getString(\n                R.string.notification_listener_security_warning_summary,\n                mAppLabel);\n        p.mPositiveButtonText = getString(R.string.allow);\n        p.mPositiveButtonListener = (a, b) -> onAllow();\n        p.mNegativeButtonText = getString(R.string.deny);\n        p.mNegativeButtonListener = (a, b) -> cancel();\n        AlertController\n                .create(this, this, getWindow())\n                .installContent(p);\n        // Consistent with the permission dialog\n        // Used instead of p.mCancelable as that is only honored for AlertDialog\n        getWindow().setCloseOnTouchOutside(false); \n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n        getWindow().addFlags(\n                WindowManager.LayoutParams.SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);\n    }\n\n    @Override\n    public void onPause() {\n        getWindow().clearFlags(\n                WindowManager.LayoutParams.SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);\n        super.onPause();\n    }\n\n    private void onAllow() {\n        mNm.setNotificationListenerAccessGranted(mComponentName, true);\n\n        finish();\n    }\n\n    @Override\n    public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {\n        return AlertActivity.dispatchPopulateAccessibilityEvent(this, event);\n    }\n\n    @Override\n    public void cancel() {\n        finish();\n    }\n\n    @Override\n    public void dismiss() {\n        // This is called after the click, since we finish when handling the\n        // click, don't do that again here.\n        if (!isFinishing()) {\n            finish();\n        }\n    }\n}",
    "metrics": {
      "relative_line_count_similarity": 0.8895,
      "token_level_edit_similarity": 0.8717,
      "normalized_edit_similarity": 0.1283,
      "token_level_edit_distance": 0.1283,
      "codebert_score": {
        "precision": 0.9308,
        "recall": 0.9112,
        "f1": 0.9209,
        "f3": 0.9131
      },
      "token_count_upstream": 530,
      "token_count_downstream": 482,
      "token_count_total": 1012,
      "cosine_similarity_openai": 0.9686
    }
  },
  {
    "cve_id": "ASB-A-277207798",
    "downstream_version": "13",
    "file_name": "core/java/com/android/internal/app/ChooserActivity.java",
    "upstream_codebase": "/*\n * Copyright (C) 2008 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.internal.app;\n\nimport static android.app.admin.DevicePolicyResources.Strings.Core.RESOLVER_CANT_ACCESS_PERSONAL;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.RESOLVER_CANT_ACCESS_WORK;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.RESOLVER_CANT_SHARE_WITH_PERSONAL;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.RESOLVER_CANT_SHARE_WITH_WORK;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.RESOLVER_CROSS_PROFILE_BLOCKED_TITLE;\nimport static android.content.ContentProvider.getUriWithoutUserId;\nimport static android.content.ContentProvider.getUserIdFromUri;\nimport static android.stats.devicepolicy.DevicePolicyEnums.RESOLVER_EMPTY_STATE_NO_SHARING_TO_PERSONAL;\nimport static android.stats.devicepolicy.DevicePolicyEnums.RESOLVER_EMPTY_STATE_NO_SHARING_TO_WORK;\n\nimport static com.android.internal.util.LatencyTracker.ACTION_LOAD_SHARE_SHEET;\n\nimport static java.lang.annotation.RetentionPolicy.SOURCE;\n\nimport android.animation.Animator;\nimport android.animation.AnimatorListenerAdapter;\nimport android.animation.AnimatorSet;\nimport android.animation.ObjectAnimator;\nimport android.animation.ValueAnimator;\nimport android.annotation.IntDef;\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.app.Activity;\nimport android.app.ActivityManager;\nimport android.app.ActivityOptions;\nimport android.app.IUriGrantsManager;\nimport android.app.SharedElementCallback;\nimport android.app.UriGrantsManager;\nimport android.app.prediction.AppPredictionContext;\nimport android.app.prediction.AppPredictionManager;\nimport android.app.prediction.AppPredictor;\nimport android.app.prediction.AppTarget;\nimport android.app.prediction.AppTargetEvent;\nimport android.app.prediction.AppTargetId;\nimport android.compat.annotation.UnsupportedAppUsage;\nimport android.content.ClipData;\nimport android.content.ClipboardManager;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.IntentSender;\nimport android.content.IntentSender.SendIntentException;\nimport android.content.SharedPreferences;\nimport android.content.pm.ActivityInfo;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManager.NameNotFoundException;\nimport android.content.pm.ResolveInfo;\nimport android.content.pm.ShortcutInfo;\nimport android.content.pm.ShortcutManager;\nimport android.content.res.Configuration;\nimport android.content.res.Resources;\nimport android.database.Cursor;\nimport android.database.DataSetObserver;\nimport android.graphics.Bitmap;\nimport android.graphics.Canvas;\nimport android.graphics.Color;\nimport android.graphics.Insets;\nimport android.graphics.Paint;\nimport android.graphics.Path;\nimport android.graphics.drawable.AnimatedVectorDrawable;\nimport android.graphics.drawable.Drawable;\nimport android.graphics.drawable.Icon;\nimport android.metrics.LogMaker;\nimport android.net.Uri;\nimport android.os.AsyncTask;\nimport android.os.Bundle;\nimport android.os.Environment;\nimport android.os.Handler;\nimport android.os.Message;\nimport android.os.Parcelable;\nimport android.os.PatternMatcher;\nimport android.os.RemoteException;\nimport android.os.ResultReceiver;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.os.storage.StorageManager;\nimport android.provider.DeviceConfig;\nimport android.provider.DocumentsContract;\nimport android.provider.Downloads;\nimport android.provider.OpenableColumns;\nimport android.provider.Settings;\nimport android.service.chooser.ChooserTarget;\nimport android.text.TextUtils;\nimport android.util.AttributeSet;\nimport android.util.HashedStringCache;\nimport android.util.Log;\nimport android.util.PluralsMessageFormatter;\nimport android.util.Size;\nimport android.util.Slog;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.View.MeasureSpec;\nimport android.view.View.OnClickListener;\nimport android.view.ViewGroup;\nimport android.view.ViewGroup.LayoutParams;\nimport android.view.ViewTreeObserver;\nimport android.view.WindowInsets;\nimport android.view.animation.AccelerateInterpolator;\nimport android.view.animation.AlphaAnimation;\nimport android.view.animation.Animation;\nimport android.view.animation.DecelerateInterpolator;\nimport android.view.animation.LinearInterpolator;\nimport android.widget.Button;\nimport android.widget.ImageView;\nimport android.widget.Space;\nimport android.widget.TextView;\n\nimport com.android.internal.R;\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.app.AbstractMultiProfilePagerAdapter.EmptyState;\nimport com.android.internal.app.AbstractMultiProfilePagerAdapter.EmptyStateProvider;\nimport com.android.internal.app.NoCrossProfileEmptyStateProvider.DevicePolicyBlockerEmptyState;\nimport com.android.internal.app.ResolverListAdapter.ActivityInfoPresentationGetter;\nimport com.android.internal.app.ResolverListAdapter.ViewHolder;\nimport com.android.internal.app.chooser.ChooserTargetInfo;\nimport com.android.internal.app.chooser.DisplayResolveInfo;\nimport com.android.internal.app.chooser.MultiDisplayResolveInfo;\nimport com.android.internal.app.chooser.NotSelectableTargetInfo;\nimport com.android.internal.app.chooser.SelectableTargetInfo;\nimport com.android.internal.app.chooser.SelectableTargetInfo.SelectableTargetInfoCommunicator;\nimport com.android.internal.app.chooser.TargetInfo;\nimport com.android.internal.config.sysui.SystemUiDeviceConfigFlags;\nimport com.android.internal.content.PackageMonitor;\nimport com.android.internal.logging.MetricsLogger;\nimport com.android.internal.logging.nano.MetricsProto.MetricsEvent;\nimport com.android.internal.util.FrameworkStatsLog;\nimport com.android.internal.widget.GridLayoutManager;\nimport com.android.internal.widget.RecyclerView;\nimport com.android.internal.widget.ResolverDrawerLayout;\nimport com.android.internal.widget.ViewPager;\n\nimport com.google.android.collect.Lists;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.net.URISyntaxException;\nimport java.text.Collator;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.function.Supplier;\nimport java.util.stream.Collectors;\n\n/**\n * This is the legacy ChooserActivity and is not expected to be invoked, it's only here because\n * MediaAppSelectorActivity is still depending on it. The actual chooser used by the system is\n * at packages/modules/IntentResolver/java/src/com/android/intentresolver/ChooserActivity.java\n *\n * The migration to the new package will be completed in a later release.\n */\npublic class ChooserActivity extends ResolverActivity implements\n        ChooserListAdapter.ChooserListCommunicator,\n        SelectableTargetInfoCommunicator {\n    private static final String TAG = \"ChooserActivity\";\n\n    private AppPredictor mPersonalAppPredictor;\n    private AppPredictor mWorkAppPredictor;\n    private boolean mShouldDisplayLandscape;\n\n    @UnsupportedAppUsage\n    public ChooserActivity() {\n    }\n    /**\n     * Boolean extra to change the following behavior: Normally, ChooserActivity finishes itself\n     * in onStop when launched in a new task. If this extra is set to true, we do not finish\n     * ourselves when onStop gets called.\n     */\n    public static final String EXTRA_PRIVATE_RETAIN_IN_ON_STOP\n            = \"com.android.internal.app.ChooserActivity.EXTRA_PRIVATE_RETAIN_IN_ON_STOP\";\n\n\n    /**\n     * Transition name for the first image preview.\n     * To be used for shared element transition into this activity.\n     * @hide\n     */\n    public static final String FIRST_IMAGE_PREVIEW_TRANSITION_NAME = \"screenshot_preview_image\";\n\n    private static final String PREF_NUM_SHEET_EXPANSIONS = \"pref_num_sheet_expansions\";\n\n    private static final String CHIP_LABEL_METADATA_KEY = \"android.service.chooser.chip_label\";\n    private static final String CHIP_ICON_METADATA_KEY = \"android.service.chooser.chip_icon\";\n\n    private static final boolean DEBUG = true;\n\n    private static final boolean USE_PREDICTION_MANAGER_FOR_SHARE_ACTIVITIES = true;\n    // TODO(b/123088566) Share these in a better way.\n    private static final String APP_PREDICTION_SHARE_UI_SURFACE = \"share\";\n    public static final String LAUNCH_LOCATION_DIRECT_SHARE = \"direct_share\";\n    public static final String CHOOSER_TARGET = \"chooser_target\";\n    private static final String SHORTCUT_TARGET = \"shortcut_target\";\n    private static final int APP_PREDICTION_SHARE_TARGET_QUERY_PACKAGE_LIMIT = 20;\n    public static final String APP_PREDICTION_INTENT_FILTER_KEY = \"intent_filter\";\n    private static final String SHARED_TEXT_KEY = \"shared_text\";\n\n    private static final String PLURALS_COUNT = \"count\";\n    private static final String PLURALS_FILE_NAME = \"file_name\";\n\n    private static final String IMAGE_EDITOR_SHARED_ELEMENT = \"screenshot_preview_image\";\n\n    private boolean mIsAppPredictorComponentAvailable;\n    private Map<ChooserTarget, AppTarget> mDirectShareAppTargetCache;\n    private Map<ChooserTarget, ShortcutInfo> mDirectShareShortcutInfoCache;\n\n    public static final int TARGET_TYPE_DEFAULT = 0;\n    public static final int TARGET_TYPE_CHOOSER_TARGET = 1;\n    public static final int TARGET_TYPE_SHORTCUTS_FROM_SHORTCUT_MANAGER = 2;\n    public static final int TARGET_TYPE_SHORTCUTS_FROM_PREDICTION_SERVICE = 3;\n\n    public static final int SELECTION_TYPE_SERVICE = 1;\n    public static final int SELECTION_TYPE_APP = 2;\n    public static final int SELECTION_TYPE_STANDARD = 3;\n    public static final int SELECTION_TYPE_COPY = 4;\n    public static final int SELECTION_TYPE_NEARBY = 5;\n    public static final int SELECTION_TYPE_EDIT = 6;\n\n    private static final int SCROLL_STATUS_IDLE = 0;\n    private static final int SCROLL_STATUS_SCROLLING_VERTICAL = 1;\n    private static final int SCROLL_STATUS_SCROLLING_HORIZONTAL = 2;\n\n    // statsd logger wrapper\n    protected ChooserActivityLogger mChooserActivityLogger;\n\n    @IntDef(flag = false, prefix = { \"TARGET_TYPE_\" }, value = {\n            TARGET_TYPE_DEFAULT,\n            TARGET_TYPE_CHOOSER_TARGET,\n            TARGET_TYPE_SHORTCUTS_FROM_SHORTCUT_MANAGER,\n            TARGET_TYPE_SHORTCUTS_FROM_PREDICTION_SERVICE\n    })\n    @Retention(RetentionPolicy.SOURCE)\n    public @interface ShareTargetType {}\n\n    /**\n     * The transition time between placeholders for direct share to a message\n     * indicating that non are available.\n     */\n    private static final int NO_DIRECT_SHARE_ANIM_IN_MILLIS = 200;\n\n    private static final float DIRECT_SHARE_EXPANSION_RATE = 0.78f;\n\n    private static final int DEFAULT_SALT_EXPIRATION_DAYS = 7;\n    private int mMaxHashSaltDays = DeviceConfig.getInt(DeviceConfig.NAMESPACE_SYSTEMUI,\n            SystemUiDeviceConfigFlags.HASH_SALT_MAX_DAYS,\n            DEFAULT_SALT_EXPIRATION_DAYS);\n\n    private static final boolean DEFAULT_IS_NEARBY_SHARE_FIRST_TARGET_IN_RANKED_APP = false;\n    private boolean mIsNearbyShareFirstTargetInRankedApp =\n            DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_SYSTEMUI,\n                    SystemUiDeviceConfigFlags.IS_NEARBY_SHARE_FIRST_TARGET_IN_RANKED_APP,\n                    DEFAULT_IS_NEARBY_SHARE_FIRST_TARGET_IN_RANKED_APP);\n\n    private static final int DEFAULT_LIST_VIEW_UPDATE_DELAY_MS = 0;\n\n    private static final int URI_PERMISSION_INTENT_FLAGS = Intent.FLAG_GRANT_READ_URI_PERMISSION\n            | Intent.FLAG_GRANT_WRITE_URI_PERMISSION\n            | Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION\n            | Intent.FLAG_GRANT_PREFIX_URI_PERMISSION;\n\n    @VisibleForTesting\n    int mListViewUpdateDelayMs = DeviceConfig.getInt(DeviceConfig.NAMESPACE_SYSTEMUI,\n            SystemUiDeviceConfigFlags.SHARESHEET_LIST_VIEW_UPDATE_DELAY,\n            DEFAULT_LIST_VIEW_UPDATE_DELAY_MS);\n\n    private Bundle mReplacementExtras;\n    private IntentSender mChosenComponentSender;\n    private IntentSender mRefinementIntentSender;\n    private RefinementResultReceiver mRefinementResultReceiver;\n    private ChooserTarget[] mCallerChooserTargets;\n    private ComponentName[] mFilteredComponentNames;\n\n    private Intent mReferrerFillInIntent;\n\n    private long mChooserShownTime;\n    protected boolean mIsSuccessfullySelected;\n\n    private long mQueriedSharingShortcutsTimeMs;\n\n    private int mCurrAvailableWidth = 0;\n    private Insets mLastAppliedInsets = null;\n    private int mLastNumberOfChildren = -1;\n    private int mMaxTargetsPerRow = 1;\n\n    private static final String TARGET_DETAILS_FRAGMENT_TAG = \"targetDetailsFragment\";\n\n    private static final int MAX_LOG_RANK_POSITION = 12;\n\n    private static final int MAX_EXTRA_INITIAL_INTENTS = 2;\n    private static final int MAX_EXTRA_CHOOSER_TARGETS = 2;\n\n    private SharedPreferences mPinnedSharedPrefs;\n    private static final String PINNED_SHARED_PREFS_NAME = \"chooser_pin_settings\";\n\n    @Retention(SOURCE)\n    @IntDef({CONTENT_PREVIEW_FILE, CONTENT_PREVIEW_IMAGE, CONTENT_PREVIEW_TEXT})\n    private @interface ContentPreviewType {\n    }\n\n    // Starting at 1 since 0 is considered \"undefined\" for some of the database transformations\n    // of tron logs.\n    protected static final int CONTENT_PREVIEW_IMAGE = 1;\n    protected static final int CONTENT_PREVIEW_FILE = 2;\n    protected static final int CONTENT_PREVIEW_TEXT = 3;\n    protected MetricsLogger mMetricsLogger;\n\n    private ContentPreviewCoordinator mPreviewCoord;\n    private int mScrollStatus = SCROLL_STATUS_IDLE;\n\n    @VisibleForTesting\n    protected ChooserMultiProfilePagerAdapter mChooserMultiProfilePagerAdapter;\n    private final EnterTransitionAnimationDelegate mEnterTransitionAnimationDelegate =\n            new EnterTransitionAnimationDelegate();\n\n    private boolean mRemoveSharedElements = false;\n\n    private View mContentView = null;\n\n    private class ContentPreviewCoordinator {\n        private static final int IMAGE_FADE_IN_MILLIS = 150;\n        private static final int IMAGE_LOAD_TIMEOUT = 1;\n        private static final int IMAGE_LOAD_INTO_VIEW = 2;\n\n        private final int mImageLoadTimeoutMillis =\n                getResources().getInteger(R.integer.config_shortAnimTime);\n\n        private final View mParentView;\n        private boolean mHideParentOnFail;\n        private boolean mAtLeastOneLoaded = false;\n\n        class LoadUriTask {\n            public final Uri mUri;\n            public final int mImageResourceId;\n            public final int mExtraCount;\n            public final Bitmap mBmp;\n\n            LoadUriTask(int imageResourceId, Uri uri, int extraCount, Bitmap bmp) {\n                this.mImageResourceId = imageResourceId;\n                this.mUri = uri;\n                this.mExtraCount = extraCount;\n                this.mBmp = bmp;\n            }\n        }\n\n        // If at least one image loads within the timeout period, allow other\n        // loads to continue. Otherwise terminate and optionally hide\n        // the parent area\n        private final Handler mHandler = new Handler() {\n            @Override\n            public void handleMessage(Message msg) {\n                switch (msg.what) {\n                    case IMAGE_LOAD_TIMEOUT:\n                        maybeHideContentPreview();\n                        break;\n\n                    case IMAGE_LOAD_INTO_VIEW:\n                        if (isFinishing()) break;\n\n                        LoadUriTask task = (LoadUriTask) msg.obj;\n                        RoundedRectImageView imageView = mParentView.findViewById(\n                                task.mImageResourceId);\n                        if (task.mBmp == null) {\n                            imageView.setVisibility(View.GONE);\n                            maybeHideContentPreview();\n                            return;\n                        }\n\n                        mAtLeastOneLoaded = true;\n                        imageView.setVisibility(View.VISIBLE);\n                        imageView.setAlpha(0.0f);\n                        imageView.setImageBitmap(task.mBmp);\n\n                        ValueAnimator fadeAnim = ObjectAnimator.ofFloat(imageView, \"alpha\", 0.0f,\n                                1.0f);\n                        fadeAnim.setInterpolator(new DecelerateInterpolator(1.0f));\n                        fadeAnim.setDuration(IMAGE_FADE_IN_MILLIS);\n                        fadeAnim.start();\n\n                        if (task.mExtraCount > 0) {\n                            imageView.setExtraImageCount(task.mExtraCount);\n                        }\n\n                        setupPreDrawForSharedElementTransition(imageView);\n                }\n            }\n        };\n\n        private void setupPreDrawForSharedElementTransition(View v) {\n            v.getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {\n                @Override\n                public boolean onPreDraw() {\n                    v.getViewTreeObserver().removeOnPreDrawListener(this);\n\n                    if (!mRemoveSharedElements && isActivityTransitionRunning()) {\n                        // Disable the window animations as it interferes with the\n                        // transition animation.\n                        getWindow().setWindowAnimations(0);\n                    }\n                    mEnterTransitionAnimationDelegate.markImagePreviewReady();\n                    return true;\n                }\n            });\n        }\n\n        ContentPreviewCoordinator(View parentView, boolean hideParentOnFail) {\n            super();\n\n            this.mParentView = parentView;\n            this.mHideParentOnFail = hideParentOnFail;\n        }\n\n        private void loadUriIntoView(final int imageResourceId, final Uri uri,\n                final int extraImages) {\n            mHandler.sendEmptyMessageDelayed(IMAGE_LOAD_TIMEOUT, mImageLoadTimeoutMillis);\n\n            AsyncTask.THREAD_POOL_EXECUTOR.execute(() -> {\n                int size = getResources().getDimensionPixelSize(\n                        R.dimen.chooser_preview_image_max_dimen);\n                final Bitmap bmp = loadThumbnail(uri, new Size(size, size));\n                final Message msg = Message.obtain();\n                msg.what = IMAGE_LOAD_INTO_VIEW;\n                msg.obj = new LoadUriTask(imageResourceId, uri, extraImages, bmp);\n                mHandler.sendMessage(msg);\n            });\n        }\n\n        private void cancelLoads() {\n            mHandler.removeMessages(IMAGE_LOAD_INTO_VIEW);\n            mHandler.removeMessages(IMAGE_LOAD_TIMEOUT);\n        }\n\n        private void maybeHideContentPreview() {\n            if (!mAtLeastOneLoaded) {\n                if (mHideParentOnFail) {\n                    Log.i(TAG, \"Hiding image preview area. Timed out waiting for preview to load\"\n                            + \" within \" + mImageLoadTimeoutMillis + \"ms.\");\n                    collapseParentView();\n                    if (shouldShowTabs()) {\n                        hideStickyContentPreview();\n                    } else if (mChooserMultiProfilePagerAdapter.getCurrentRootAdapter() != null) {\n                        mChooserMultiProfilePagerAdapter.getCurrentRootAdapter()\n                                .hideContentPreview();\n                    }\n                    mHideParentOnFail = false;\n                }\n                mRemoveSharedElements = true;\n                mEnterTransitionAnimationDelegate.markImagePreviewReady();\n            }\n        }\n\n        private void collapseParentView() {\n            // This will effectively hide the content preview row by forcing the height\n            // to zero. It is faster than forcing a relayout of the listview\n            final View v = mParentView;\n            int widthSpec = MeasureSpec.makeMeasureSpec(v.getWidth(), MeasureSpec.EXACTLY);\n            int heightSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.EXACTLY);\n            v.measure(widthSpec, heightSpec);\n            v.getLayoutParams().height = 0;\n            v.layout(v.getLeft(), v.getTop(), v.getRight(), v.getTop());\n            v.invalidate();\n        }\n    }\n\n    private final ChooserHandler mChooserHandler = new ChooserHandler();\n\n    private class ChooserHandler extends Handler {\n        private static final int LIST_VIEW_UPDATE_MESSAGE = 6;\n        private static final int SHORTCUT_MANAGER_ALL_SHARE_TARGET_RESULTS = 7;\n\n        private void removeAllMessages() {\n            removeMessages(LIST_VIEW_UPDATE_MESSAGE);\n            removeMessages(SHORTCUT_MANAGER_ALL_SHARE_TARGET_RESULTS);\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            if (mChooserMultiProfilePagerAdapter.getActiveListAdapter() == null || isDestroyed()) {\n                return;\n            }\n\n            switch (msg.what) {\n                case LIST_VIEW_UPDATE_MESSAGE:\n                    if (DEBUG) {\n                        Log.d(TAG, \"LIST_VIEW_UPDATE_MESSAGE; \");\n                    }\n\n                    UserHandle userHandle = (UserHandle) msg.obj;\n                    mChooserMultiProfilePagerAdapter.getListAdapterForUserHandle(userHandle)\n                            .refreshListView();\n                    break;\n\n                case SHORTCUT_MANAGER_ALL_SHARE_TARGET_RESULTS:\n                    if (DEBUG) Log.d(TAG, \"SHORTCUT_MANAGER_ALL_SHARE_TARGET_RESULTS\");\n                    final ServiceResultInfo[] resultInfos = (ServiceResultInfo[]) msg.obj;\n                    for (ServiceResultInfo resultInfo : resultInfos) {\n                        if (resultInfo.resultTargets != null) {\n                            ChooserListAdapter adapterForUserHandle =\n                                    mChooserMultiProfilePagerAdapter.getListAdapterForUserHandle(\n                                            resultInfo.userHandle);\n                            if (adapterForUserHandle != null) {\n                                adapterForUserHandle.addServiceResults(\n                                        resultInfo.originalTarget,\n                                        resultInfo.resultTargets, msg.arg1,\n                                        mDirectShareShortcutInfoCache);\n                            }\n                        }\n                    }\n\n                    logDirectShareTargetReceived(\n                            MetricsEvent.ACTION_DIRECT_SHARE_TARGETS_LOADED_SHORTCUT_MANAGER);\n                    sendVoiceChoicesIfNeeded();\n                    getChooserActivityLogger().logSharesheetDirectLoadComplete();\n\n                    mChooserMultiProfilePagerAdapter.getActiveListAdapter()\n                            .completeServiceTargetLoading();\n                    break;\n\n                default:\n                    super.handleMessage(msg);\n            }\n        }\n    };\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        if (Settings.Secure.getIntForUser(getContentResolver(),\n                Settings.Secure.SECURE_FRP_MODE, 0,\n                getUserId()) == 1) {\n            Log.e(TAG, \"Sharing disabled due to active FRP lock.\");\n            super.onCreate(savedInstanceState);\n            finish();\n            return;\n        }\n        final long intentReceivedTime = System.currentTimeMillis();\n        mLatencyTracker.onActionStart(ACTION_LOAD_SHARE_SHEET);\n\n        getChooserActivityLogger().logSharesheetTriggered();\n        // This is the only place this value is being set. Effectively final.\n        mIsAppPredictorComponentAvailable = isAppPredictionServiceAvailable();\n\n        mIsSuccessfullySelected = false;\n        Intent intent = getIntent();\n        Parcelable targetParcelable = intent.getParcelableExtra(Intent.EXTRA_INTENT);\n        if (targetParcelable instanceof Uri) {\n            try {\n                targetParcelable = Intent.parseUri(targetParcelable.toString(),\n                        Intent.URI_INTENT_SCHEME);\n            } catch (URISyntaxException ex) {\n                // doesn't parse as an intent; let the next test fail and error out\n            }\n        }\n\n        if (!(targetParcelable instanceof Intent)) {\n            Log.w(\"ChooserActivity\", \"Target is not an intent: \" + targetParcelable);\n            finish();\n            super.onCreate(null);\n            return;\n        }\n        Intent target = (Intent) targetParcelable;\n        if (target != null) {\n            modifyTargetIntent(target);\n        }\n        Parcelable[] targetsParcelable\n                = intent.getParcelableArrayExtra(Intent.EXTRA_ALTERNATE_INTENTS);\n        if (targetsParcelable != null) {\n            final boolean offset = target == null;\n            Intent[] additionalTargets =\n                    new Intent[offset ? targetsParcelable.length - 1 : targetsParcelable.length];\n            for (int i = 0; i < targetsParcelable.length; i++) {\n                if (!(targetsParcelable[i] instanceof Intent)) {\n                    Log.w(TAG, \"EXTRA_ALTERNATE_INTENTS array entry #\" + i + \" is not an Intent: \"\n                            + targetsParcelable[i]);\n                    finish();\n                    super.onCreate(null);\n                    return;\n                }\n                final Intent additionalTarget = (Intent) targetsParcelable[i];\n                if (i == 0 && target == null) {\n                    target = additionalTarget;\n                    modifyTargetIntent(target);\n                } else {\n                    additionalTargets[offset ? i - 1 : i] = additionalTarget;\n                    modifyTargetIntent(additionalTarget);\n                }\n            }\n            setAdditionalTargets(additionalTargets);\n        }\n\n        mReplacementExtras = intent.getBundleExtra(Intent.EXTRA_REPLACEMENT_EXTRAS);\n\n        // Do not allow the title to be changed when sharing content\n        CharSequence title = null;\n        if (target != null) {\n            if (!isSendAction(target)) {\n                title = intent.getCharSequenceExtra(Intent.EXTRA_TITLE);\n            } else {\n                Log.w(TAG, \"Ignoring intent's EXTRA_TITLE, deprecated in P. You may wish to set a\"\n                        + \" preview title by using EXTRA_TITLE property of the wrapped\"\n                        + \" EXTRA_INTENT.\");\n            }\n        }\n\n        int defaultTitleRes = 0;\n        if (title == null) {\n            defaultTitleRes = com.android.internal.R.string.chooseActivity;\n        }\n\n        Parcelable[] pa = intent.getParcelableArrayExtra(Intent.EXTRA_INITIAL_INTENTS);\n        Intent[] initialIntents = null;\n        if (pa != null) {\n            int count = Math.min(pa.length, MAX_EXTRA_INITIAL_INTENTS);\n            initialIntents = new Intent[count];\n            for (int i = 0; i < count; i++) {\n                if (!(pa[i] instanceof Intent)) {\n                    Log.w(TAG, \"Initial intent #\" + i + \" not an Intent: \" + pa[i]);\n                    finish();\n                    super.onCreate(null);\n                    return;\n                }\n                final Intent in = (Intent) pa[i];\n                modifyTargetIntent(in);\n                initialIntents[i] = in;\n            }\n        }\n\n        mReferrerFillInIntent = new Intent().putExtra(Intent.EXTRA_REFERRER, getReferrer());\n\n        mChosenComponentSender = intent.getParcelableExtra(\n                Intent.EXTRA_CHOSEN_COMPONENT_INTENT_SENDER, android.content.IntentSender.class);\n        mRefinementIntentSender = intent.getParcelableExtra(\n                Intent.EXTRA_CHOOSER_REFINEMENT_INTENT_SENDER, android.content.IntentSender.class);\n        setSafeForwardingMode(true);\n\n        mPinnedSharedPrefs = getPinnedSharedPrefs(this);\n\n        pa = intent.getParcelableArrayExtra(Intent.EXTRA_EXCLUDE_COMPONENTS);\n\n\n        // Exclude out Nearby from main list if chip is present, to avoid duplication\n        ComponentName nearbySharingComponent = getNearbySharingComponent();\n        boolean shouldFilterNearby = !shouldNearbyShareBeFirstInRankedRow()\n                && nearbySharingComponent != null;\n\n        if (pa != null) {\n            ComponentName[] names = new ComponentName[pa.length + (shouldFilterNearby ? 1 : 0)];\n            for (int i = 0; i < pa.length; i++) {\n                if (!(pa[i] instanceof ComponentName)) {\n                    Log.w(TAG, \"Filtered component #\" + i + \" not a ComponentName: \" + pa[i]);\n                    names = null;\n                    break;\n                }\n                names[i] = (ComponentName) pa[i];\n            }\n            if (shouldFilterNearby) {\n                names[names.length - 1] = nearbySharingComponent;\n            }\n\n            mFilteredComponentNames = names;\n        } else if (shouldFilterNearby) {\n            mFilteredComponentNames = new ComponentName[1];\n            mFilteredComponentNames[0] = nearbySharingComponent;\n        }\n\n        pa = intent.getParcelableArrayExtra(Intent.EXTRA_CHOOSER_TARGETS);\n        if (pa != null) {\n            int count = Math.min(pa.length, MAX_EXTRA_CHOOSER_TARGETS);\n            ChooserTarget[] targets = new ChooserTarget[count];\n            for (int i = 0; i < count; i++) {\n                if (!(pa[i] instanceof ChooserTarget)) {\n                    Log.w(TAG, \"Chooser target #\" + i + \" not a ChooserTarget: \" + pa[i]);\n                    targets = null;\n                    break;\n                }\n                ChooserTarget chooserTarget = (ChooserTarget) pa[i];\n                if (!hasValidIcon(chooserTarget)) {\n                    chooserTarget = removeIcon(chooserTarget);\n                }\n                targets[i] = chooserTarget;\n            }\n            mCallerChooserTargets = targets;\n        }\n\n        mMaxTargetsPerRow = getResources().getInteger(R.integer.config_chooser_max_targets_per_row);\n        mShouldDisplayLandscape =\n                shouldDisplayLandscape(getResources().getConfiguration().orientation);\n        setRetainInOnStop(intent.getBooleanExtra(EXTRA_PRIVATE_RETAIN_IN_ON_STOP, false));\n        super.onCreate(savedInstanceState, target, title, defaultTitleRes, initialIntents,\n                null, false);\n\n        mChooserShownTime = System.currentTimeMillis();\n        final long systemCost = mChooserShownTime - intentReceivedTime;\n\n        getMetricsLogger().write(new LogMaker(MetricsEvent.ACTION_ACTIVITY_CHOOSER_SHOWN)\n                .setSubtype(isWorkProfile() ? MetricsEvent.MANAGED_PROFILE :\n                        MetricsEvent.PARENT_PROFILE)\n                .addTaggedData(MetricsEvent.FIELD_SHARESHEET_MIMETYPE, target.getType())\n                .addTaggedData(MetricsEvent.FIELD_TIME_TO_APP_TARGETS, systemCost));\n\n        if (mResolverDrawerLayout != null) {\n            mResolverDrawerLayout.addOnLayoutChangeListener(this::handleLayoutChange);\n\n            // expand/shrink direct share 4 -> 8 viewgroup\n            if (isSendAction(target)) {\n                mResolverDrawerLayout.setOnScrollChangeListener(this::handleScroll);\n            }\n\n            mResolverDrawerLayout.setOnCollapsedChangedListener(\n                    new ResolverDrawerLayout.OnCollapsedChangedListener() {\n\n                        // Only consider one expansion per activity creation\n                        private boolean mWrittenOnce = false;\n\n                        @Override\n                        public void onCollapsedChanged(boolean isCollapsed) {\n                            if (!isCollapsed && !mWrittenOnce) {\n                                incrementNumSheetExpansions();\n                                mWrittenOnce = true;\n                            }\n                            getChooserActivityLogger()\n                                    .logSharesheetExpansionChanged(isCollapsed);\n                        }\n                    });\n        }\n\n        if (DEBUG) {\n            Log.d(TAG, \"System Time Cost is \" + systemCost);\n        }\n\n        getChooserActivityLogger().logShareStarted(\n                FrameworkStatsLog.SHARESHEET_STARTED,\n                getReferrerPackageName(),\n                target.getType(),\n                mCallerChooserTargets == null ? 0 : mCallerChooserTargets.length,\n                initialIntents == null ? 0 : initialIntents.length,\n                isWorkProfile(),\n                findPreferredContentPreview(getTargetIntent(), getContentResolver()),\n                target.getAction()\n        );\n        mDirectShareShortcutInfoCache = new HashMap<>();\n\n        setEnterSharedElementCallback(new SharedElementCallback() {\n            @Override\n            public void onMapSharedElements(List<String> names, Map<String, View> sharedElements) {\n                if (mRemoveSharedElements) {\n                    names.remove(FIRST_IMAGE_PREVIEW_TRANSITION_NAME);\n                    sharedElements.remove(FIRST_IMAGE_PREVIEW_TRANSITION_NAME);\n                }\n                super.onMapSharedElements(names, sharedElements);\n                mRemoveSharedElements = false;\n            }\n        });\n        mEnterTransitionAnimationDelegate.postponeTransition();\n    }\n\n    @Override\n    protected int appliedThemeResId() {\n        return R.style.Theme_DeviceDefault_Chooser;\n    }\n\n    private AppPredictor setupAppPredictorForUser(UserHandle userHandle,\n            AppPredictor.Callback appPredictorCallback) {\n        AppPredictor appPredictor = getAppPredictorForDirectShareIfEnabled(userHandle);\n        if (appPredictor == null) {\n            return null;\n        }\n        mDirectShareAppTargetCache = new HashMap<>();\n        appPredictor.registerPredictionUpdates(this.getMainExecutor(), appPredictorCallback);\n        return appPredictor;\n    }\n\n    private AppPredictor.Callback createAppPredictorCallback(\n            ChooserListAdapter chooserListAdapter) {\n        return resultList -> {\n            if (isFinishing() || isDestroyed()) {\n                return;\n            }\n            if (chooserListAdapter.getCount() == 0) {\n                return;\n            }\n            if (resultList.isEmpty()\n                    && shouldQueryShortcutManager(chooserListAdapter.getUserHandle())) {\n                // APS may be disabled, so try querying targets ourselves.\n                queryDirectShareTargets(chooserListAdapter, true);\n                return;\n            }\n            final List<ShortcutManager.ShareShortcutInfo> shareShortcutInfos =\n                    new ArrayList<>();\n\n            List<AppTarget> shortcutResults = new ArrayList<>();\n            for (AppTarget appTarget : resultList) {\n                if (appTarget.getShortcutInfo() == null) {\n                    continue;\n                }\n                shortcutResults.add(appTarget);\n            }\n            resultList = shortcutResults;\n            for (AppTarget appTarget : resultList) {\n                shareShortcutInfos.add(new ShortcutManager.ShareShortcutInfo(\n                        appTarget.getShortcutInfo(),\n                        new ComponentName(\n                                appTarget.getPackageName(), appTarget.getClassName())));\n            }\n            sendShareShortcutInfoList(shareShortcutInfos, chooserListAdapter, resultList,\n                    chooserListAdapter.getUserHandle());\n        };\n    }\n\n    static SharedPreferences getPinnedSharedPrefs(Context context) {\n        // The code below is because in the android:ui process, no one can hear you scream.\n        // The package info in the context isn't initialized in the way it is for normal apps,\n        // so the standard, name-based context.getSharedPreferences doesn't work. Instead, we\n        // build the path manually below using the same policy that appears in ContextImpl.\n        // This fails silently under the hood if there's a problem, so if we find ourselves in\n        // the case where we don't have access to credential encrypted storage we just won't\n        // have our pinned target info.\n        final File prefsFile = new File(new File(\n                Environment.getDataUserCePackageDirectory(StorageManager.UUID_PRIVATE_INTERNAL,\n                        context.getUserId(), context.getPackageName()),\n                \"shared_prefs\"),\n                PINNED_SHARED_PREFS_NAME + \".xml\");\n        return context.getSharedPreferences(prefsFile, MODE_PRIVATE);\n    }\n\n    @Override\n    protected AbstractMultiProfilePagerAdapter createMultiProfilePagerAdapter(\n            Intent[] initialIntents,\n            List<ResolveInfo> rList,\n            boolean filterLastUsed) {\n        if (shouldShowTabs()) {\n            mChooserMultiProfilePagerAdapter = createChooserMultiProfilePagerAdapterForTwoProfiles(\n                    initialIntents, rList, filterLastUsed);\n        } else {\n            mChooserMultiProfilePagerAdapter = createChooserMultiProfilePagerAdapterForOneProfile(\n                    initialIntents, rList, filterLastUsed);\n        }\n        return mChooserMultiProfilePagerAdapter;\n    }\n\n    @Override\n    protected EmptyStateProvider createBlockerEmptyStateProvider() {\n        final boolean isSendAction = isSendAction(getTargetIntent());\n\n        final EmptyState noWorkToPersonalEmptyState =\n                new DevicePolicyBlockerEmptyState(\n                /* context= */ this,\n                /* devicePolicyStringTitleId= */ RESOLVER_CROSS_PROFILE_BLOCKED_TITLE,\n                /* defaultTitleResource= */ R.string.resolver_cross_profile_blocked,\n                /* devicePolicyStringSubtitleId= */\n                isSendAction ? RESOLVER_CANT_SHARE_WITH_PERSONAL : RESOLVER_CANT_ACCESS_PERSONAL,\n                /* defaultSubtitleResource= */\n                isSendAction ? R.string.resolver_cant_share_with_personal_apps_explanation\n                        : R.string.resolver_cant_access_personal_apps_explanation,\n                /* devicePolicyEventId= */ RESOLVER_EMPTY_STATE_NO_SHARING_TO_PERSONAL,\n                /* devicePolicyEventCategory= */ ResolverActivity.METRICS_CATEGORY_CHOOSER);\n\n        final EmptyState noPersonalToWorkEmptyState =\n                new DevicePolicyBlockerEmptyState(\n                /* context= */ this,\n                /* devicePolicyStringTitleId= */ RESOLVER_CROSS_PROFILE_BLOCKED_TITLE,\n                /* defaultTitleResource= */ R.string.resolver_cross_profile_blocked,\n                /* devicePolicyStringSubtitleId= */\n                isSendAction ? RESOLVER_CANT_SHARE_WITH_WORK : RESOLVER_CANT_ACCESS_WORK,\n                /* defaultSubtitleResource= */\n                isSendAction ? R.string.resolver_cant_share_with_work_apps_explanation\n                        : R.string.resolver_cant_access_work_apps_explanation,\n                /* devicePolicyEventId= */ RESOLVER_EMPTY_STATE_NO_SHARING_TO_WORK,\n                /* devicePolicyEventCategory= */ ResolverActivity.METRICS_CATEGORY_CHOOSER);\n\n        return new NoCrossProfileEmptyStateProvider(getPersonalProfileUserHandle(),\n                noWorkToPersonalEmptyState, noPersonalToWorkEmptyState,\n                createCrossProfileIntentsChecker(), getTabOwnerUserHandleForLaunch());\n    }\n\n    private ChooserMultiProfilePagerAdapter createChooserMultiProfilePagerAdapterForOneProfile(\n            Intent[] initialIntents,\n            List<ResolveInfo> rList,\n            boolean filterLastUsed) {\n        ChooserGridAdapter adapter = createChooserGridAdapter(\n                /* context */ this,\n                /* payloadIntents */ mIntents,\n                initialIntents,\n                rList,\n                filterLastUsed,\n                /* userHandle */ getPersonalProfileUserHandle());\n        return new ChooserMultiProfilePagerAdapter(\n                /* context */ this,\n                adapter,\n                createEmptyStateProvider(/* workProfileUserHandle= */ null),\n                mQuietModeManager,\n                /* workProfileUserHandle= */ null,\n                getCloneProfileUserHandle(),\n                mMaxTargetsPerRow);\n    }\n\n    private ChooserMultiProfilePagerAdapter createChooserMultiProfilePagerAdapterForTwoProfiles(\n            Intent[] initialIntents,\n            List<ResolveInfo> rList,\n            boolean filterLastUsed) {\n        int selectedProfile = findSelectedProfile();\n        ChooserGridAdapter personalAdapter = createChooserGridAdapter(\n                /* context */ this,\n                /* payloadIntents */ mIntents,\n                selectedProfile == PROFILE_PERSONAL ? initialIntents : null,\n                rList,\n                filterLastUsed,\n                /* userHandle */ getPersonalProfileUserHandle());\n        ChooserGridAdapter workAdapter = createChooserGridAdapter(\n                /* context */ this,\n                /* payloadIntents */ mIntents,\n                selectedProfile == PROFILE_WORK ? initialIntents : null,\n                rList,\n                filterLastUsed,\n                /* userHandle */ getWorkProfileUserHandle());\n        return new ChooserMultiProfilePagerAdapter(\n                /* context */ this,\n                personalAdapter,\n                workAdapter,\n                createEmptyStateProvider(/* workProfileUserHandle= */ getWorkProfileUserHandle()),\n                mQuietModeManager,\n                selectedProfile,\n                getWorkProfileUserHandle(),\n                getCloneProfileUserHandle(),\n                mMaxTargetsPerRow);\n    }\n\n    private int findSelectedProfile() {\n        int selectedProfile = getSelectedProfileExtra();\n        if (selectedProfile == -1) {\n            selectedProfile = getProfileForUser(getTabOwnerUserHandleForLaunch());\n        }\n        return selectedProfile;\n    }\n\n    @Override\n    protected boolean postRebuildList(boolean rebuildCompleted) {\n        updateStickyContentPreview();\n        if (shouldShowStickyContentPreview()\n                || mChooserMultiProfilePagerAdapter\n                        .getCurrentRootAdapter().getSystemRowCount() != 0) {\n            logActionShareWithPreview();\n        }\n        return postRebuildListInternal(rebuildCompleted);\n    }\n\n    /**\n     * Returns true if app prediction service is defined and the component exists on device.\n     */\n    private boolean isAppPredictionServiceAvailable() {\n        return getPackageManager().getAppPredictionServicePackageName() != null;\n    }\n\n    /**\n     * Check if the profile currently used is a work profile.\n     * @return true if it is work profile, false if it is parent profile (or no work profile is\n     * set up)\n     */\n    protected boolean isWorkProfile() {\n        return getSystemService(UserManager.class)\n                .getUserInfo(UserHandle.myUserId()).isManagedProfile();\n    }\n\n    @Override\n    protected PackageMonitor createPackageMonitor(ResolverListAdapter listAdapter) {\n        return new PackageMonitor() {\n            @Override\n            public void onSomePackagesChanged() {\n                handlePackagesChanged(listAdapter);\n            }\n        };\n    }\n\n    /**\n     * Update UI to reflect changes in data.\n     */\n    public void handlePackagesChanged() {\n        handlePackagesChanged(/* listAdapter */ null);\n    }\n\n    /**\n     * Update UI to reflect changes in data.\n     * <p>If {@code listAdapter} is {@code null}, both profile list adapters are updated if\n     * available.\n     */\n    private void handlePackagesChanged(@Nullable ResolverListAdapter listAdapter) {\n        // Refresh pinned items\n        mPinnedSharedPrefs = getPinnedSharedPrefs(this);\n        if (listAdapter == null) {\n            mChooserMultiProfilePagerAdapter.getActiveListAdapter().handlePackagesChanged();\n            if (mChooserMultiProfilePagerAdapter.getCount() > 1) {\n                mChooserMultiProfilePagerAdapter.getInactiveListAdapter().handlePackagesChanged();\n            }\n        } else {\n            listAdapter.handlePackagesChanged();\n        }\n        updateProfileViewButton();\n    }\n\n    private void onCopyButtonClicked(View v) {\n        Intent targetIntent = getTargetIntent();\n        if (targetIntent == null) {\n            finish();\n        } else {\n            final String action = targetIntent.getAction();\n\n            ClipData clipData = null;\n            if (Intent.ACTION_SEND.equals(action)) {\n                String extraText = targetIntent.getStringExtra(Intent.EXTRA_TEXT);\n                Uri extraStream = targetIntent.getParcelableExtra(Intent.EXTRA_STREAM, android.net.Uri.class);\n\n                if (extraText != null) {\n                    clipData = ClipData.newPlainText(null, extraText);\n                } else if (extraStream != null) {\n                    clipData = ClipData.newUri(getContentResolver(), null, extraStream);\n                } else {\n                    Log.w(TAG, \"No data available to copy to clipboard\");\n                    return;\n                }\n            } else if (Intent.ACTION_SEND_MULTIPLE.equals(action)) {\n                final ArrayList<Uri> streams = targetIntent.getParcelableArrayListExtra(\n                        Intent.EXTRA_STREAM, android.net.Uri.class);\n                clipData = ClipData.newUri(getContentResolver(), null, streams.get(0));\n                for (int i = 1; i < streams.size(); i++) {\n                    clipData.addItem(getContentResolver(), new ClipData.Item(streams.get(i)));\n                }\n            } else {\n                // expected to only be visible with ACTION_SEND or ACTION_SEND_MULTIPLE\n                // so warn about unexpected action\n                Log.w(TAG, \"Action (\" + action + \") not supported for copying to clipboard\");\n                return;\n            }\n\n            ClipboardManager clipboardManager = (ClipboardManager) getSystemService(\n                    Context.CLIPBOARD_SERVICE);\n            clipboardManager.setPrimaryClipAsPackage(clipData, getReferrerPackageName());\n\n            // Log share completion via copy\n            LogMaker targetLogMaker = new LogMaker(\n                    MetricsEvent.ACTION_ACTIVITY_CHOOSER_PICKED_SYSTEM_TARGET).setSubtype(1);\n            getMetricsLogger().write(targetLogMaker);\n            getChooserActivityLogger().logShareTargetSelected(\n                    SELECTION_TYPE_COPY,\n                    \"\",\n                    -1,\n                    false);\n\n            setResult(RESULT_OK);\n            finish();\n        }\n    }\n\n    @Override\n    protected void onResume() {\n        super.onResume();\n        Log.d(TAG, \"onResume: \" + getComponentName().flattenToShortString());\n        maybeCancelFinishAnimation();\n    }\n\n    @Override\n    public void onConfigurationChanged(Configuration newConfig) {\n        super.onConfigurationChanged(newConfig);\n        ViewPager viewPager = findViewById(R.id.profile_pager);\n        if (viewPager.isLayoutRtl()) {\n            mMultiProfilePagerAdapter.setupViewPager(viewPager);\n        }\n\n        mShouldDisplayLandscape = shouldDisplayLandscape(newConfig.orientation);\n        mMaxTargetsPerRow = getResources().getInteger(R.integer.config_chooser_max_targets_per_row);\n        mChooserMultiProfilePagerAdapter.setMaxTargetsPerRow(mMaxTargetsPerRow);\n        adjustPreviewWidth(newConfig.orientation, null);\n        updateStickyContentPreview();\n        updateTabPadding();\n    }\n\n    private boolean shouldDisplayLandscape(int orientation) {\n        // Sharesheet fixes the # of items per row and therefore can not correctly lay out\n        // when in the restricted size of multi-window mode. In the future, would be nice\n        // to use minimum dp size requirements instead\n        return orientation == Configuration.ORIENTATION_LANDSCAPE && !isInMultiWindowMode();\n    }\n\n    private void adjustPreviewWidth(int orientation, View parent) {\n        int width = -1;\n        if (mShouldDisplayLandscape) {\n            width = getResources().getDimensionPixelSize(R.dimen.chooser_preview_width);\n        }\n\n        parent = parent == null ? getWindow().getDecorView() : parent;\n\n        updateLayoutWidth(R.id.content_preview_text_layout, width, parent);\n        updateLayoutWidth(R.id.content_preview_title_layout, width, parent);\n        updateLayoutWidth(R.id.content_preview_file_layout, width, parent);\n    }\n\n    private void updateTabPadding() {\n        if (shouldShowTabs()) {\n            View tabs = findViewById(R.id.tabs);\n            float iconSize = getResources().getDimension(R.dimen.chooser_icon_size);\n            // The entire width consists of icons or padding. Divide the item padding in half to get\n            // paddingHorizontal.\n            float padding = (tabs.getWidth() - mMaxTargetsPerRow * iconSize)\n                    / mMaxTargetsPerRow / 2;\n            // Subtract the margin the buttons already have.\n            padding -= getResources().getDimension(R.dimen.resolver_profile_tab_margin);\n            tabs.setPadding((int) padding, 0, (int) padding, 0);\n        }\n    }\n\n    private void updateLayoutWidth(int layoutResourceId, int width, View parent) {\n        View view = parent.findViewById(layoutResourceId);\n        if (view != null && view.getLayoutParams() != null) {\n            LayoutParams params = view.getLayoutParams();\n            params.width = width;\n            view.setLayoutParams(params);\n        }\n    }\n\n    /**\n     * Create a view that will be shown in the content preview area\n     * @param parent reference to the parent container where the view should be attached to\n     * @return content preview view\n     */\n    protected ViewGroup createContentPreviewView(ViewGroup parent) {\n        Intent targetIntent = getTargetIntent();\n        int previewType = findPreferredContentPreview(targetIntent, getContentResolver());\n        return displayContentPreview(previewType, targetIntent, getLayoutInflater(), parent);\n    }\n\n    @VisibleForTesting\n    protected ComponentName getNearbySharingComponent() {\n        String nearbyComponent = Settings.Secure.getString(\n                getContentResolver(),\n                Settings.Secure.NEARBY_SHARING_COMPONENT);\n        if (TextUtils.isEmpty(nearbyComponent)) {\n            nearbyComponent = getString(R.string.config_defaultNearbySharingComponent);\n        }\n        if (TextUtils.isEmpty(nearbyComponent)) {\n            return null;\n        }\n        return ComponentName.unflattenFromString(nearbyComponent);\n    }\n\n    @VisibleForTesting\n    protected @Nullable ComponentName getEditSharingComponent() {\n        String editorPackage = getApplicationContext().getString(R.string.config_systemImageEditor);\n        if (editorPackage == null || TextUtils.isEmpty(editorPackage)) {\n            return null;\n        }\n        return ComponentName.unflattenFromString(editorPackage);\n    }\n\n    @VisibleForTesting\n    protected TargetInfo getEditSharingTarget(Intent originalIntent) {\n        final ComponentName cn = getEditSharingComponent();\n\n        final Intent resolveIntent = new Intent(originalIntent);\n        // Retain only URI permission grant flags if present. Other flags may prevent the scene\n        // transition animation from running (i.e FLAG_ACTIVITY_NO_ANIMATION,\n        // FLAG_ACTIVITY_NEW_TASK, FLAG_ACTIVITY_NEW_DOCUMENT) but also not needed.\n        resolveIntent.setFlags(originalIntent.getFlags() & URI_PERMISSION_INTENT_FLAGS);\n        resolveIntent.setComponent(cn);\n        resolveIntent.setAction(Intent.ACTION_EDIT);\n        String originalAction = originalIntent.getAction();\n        if (Intent.ACTION_SEND.equals(originalAction)) {\n            if (resolveIntent.getData() == null) {\n                Uri uri = resolveIntent.getParcelableExtra(Intent.EXTRA_STREAM, android.net.Uri.class);\n                if (uri != null) {\n                    String mimeType = getContentResolver().getType(uri);\n                    resolveIntent.setDataAndType(uri, mimeType);\n                }\n            }\n        } else {\n            Log.e(TAG, originalAction + \" is not supported.\");\n            return null;\n        }\n        final ResolveInfo ri = getPackageManager().resolveActivity(\n                resolveIntent, PackageManager.GET_META_DATA);\n        if (ri == null || ri.activityInfo == null) {\n            Log.e(TAG, \"Device-specified image edit component (\" + cn\n                    + \") not available\");\n            return null;\n        }\n\n        final DisplayResolveInfo dri = new DisplayResolveInfo(\n                originalIntent, ri, getString(R.string.screenshot_edit), \"\", resolveIntent, null);\n        dri.setDisplayIcon(getDrawable(R.drawable.ic_screenshot_edit));\n        return dri;\n    }\n\n    @VisibleForTesting\n    protected TargetInfo getNearbySharingTarget(Intent originalIntent) {\n        final ComponentName cn = getNearbySharingComponent();\n        if (cn == null) return null;\n\n        final Intent resolveIntent = new Intent(originalIntent);\n        resolveIntent.setComponent(cn);\n        final ResolveInfo ri = getPackageManager().resolveActivity(\n                resolveIntent, PackageManager.GET_META_DATA);\n        if (ri == null || ri.activityInfo == null) {\n            Log.e(TAG, \"Device-specified nearby sharing component (\" + cn\n                    + \") not available\");\n            return null;\n        }\n\n        // Allow the nearby sharing component to provide a more appropriate icon and label\n        // for the chip.\n        CharSequence name = null;\n        Drawable icon = null;\n        final Bundle metaData = ri.activityInfo.metaData;\n        if (metaData != null) {\n            try {\n                final Resources pkgRes = getPackageManager().getResourcesForActivity(cn);\n                final int nameResId = metaData.getInt(CHIP_LABEL_METADATA_KEY);\n                name = pkgRes.getString(nameResId);\n                final int resId = metaData.getInt(CHIP_ICON_METADATA_KEY);\n                icon = pkgRes.getDrawable(resId);\n            } catch (Resources.NotFoundException ex) {\n            } catch (NameNotFoundException ex) {\n            }\n        }\n        if (TextUtils.isEmpty(name)) {\n            name = ri.loadLabel(getPackageManager());\n        }\n        if (icon == null) {\n            icon = ri.loadIcon(getPackageManager());\n        }\n\n        final DisplayResolveInfo dri = new DisplayResolveInfo(\n                originalIntent, ri, name, \"\", resolveIntent, null);\n        dri.setDisplayIcon(icon);\n        return dri;\n    }\n\n    private Button createActionButton(Drawable icon, CharSequence title, View.OnClickListener r) {\n        Button b = (Button) LayoutInflater.from(this).inflate(R.layout.chooser_action_button, null);\n        if (icon != null) {\n            final int size = getResources()\n                    .getDimensionPixelSize(R.dimen.chooser_action_button_icon_size);\n            icon.setBounds(0, 0, size, size);\n            b.setCompoundDrawablesRelative(icon, null, null, null);\n        }\n        b.setText(title);\n        b.setOnClickListener(r);\n        return b;\n    }\n\n    private Button createCopyButton() {\n        final Button b = createActionButton(\n                getDrawable(R.drawable.ic_menu_copy_material),\n                getString(R.string.copy), this::onCopyButtonClicked);\n        b.setId(R.id.chooser_copy_button);\n        return b;\n    }\n\n    private @Nullable Button createNearbyButton(Intent originalIntent) {\n        final TargetInfo ti = getNearbySharingTarget(originalIntent);\n        if (ti == null) return null;\n\n        final Button b = createActionButton(\n                ti.getDisplayIcon(this),\n                ti.getDisplayLabel(),\n                (View unused) -> {\n                    // Log share completion via nearby\n                    getChooserActivityLogger().logShareTargetSelected(\n                            SELECTION_TYPE_NEARBY,\n                            \"\",\n                            -1,\n                            false);\n                    // Action bar is user-independent, always start as primary\n                    safelyStartActivityAsUser(ti, getPersonalProfileUserHandle());\n                    finish();\n                }\n        );\n        b.setId(R.id.chooser_nearby_button);\n        return b;\n    }\n\n    private @Nullable Button createEditButton(Intent originalIntent) {\n        final TargetInfo ti = getEditSharingTarget(originalIntent);\n        if (ti == null) return null;\n\n        final Button b = createActionButton(\n                ti.getDisplayIcon(this),\n                ti.getDisplayLabel(),\n                (View unused) -> {\n                    // Log share completion via edit\n                    getChooserActivityLogger().logShareTargetSelected(\n                            SELECTION_TYPE_EDIT,\n                            \"\",\n                            -1,\n                            false);\n                    View firstImgView = getFirstVisibleImgPreviewView();\n                    // Action bar is user-independent, always start as primary\n                    if (firstImgView == null) {\n                        safelyStartActivityAsUser(ti, getPersonalProfileUserHandle());\n                        finish();\n                    } else {\n                        ActivityOptions options = ActivityOptions.makeSceneTransitionAnimation(\n                                this, firstImgView, IMAGE_EDITOR_SHARED_ELEMENT);\n                        safelyStartActivityAsUser(\n                                ti, getPersonalProfileUserHandle(), options.toBundle());\n                        startFinishAnimation();\n                    }\n                }\n        );\n        b.setId(R.id.chooser_edit_button);\n        return b;\n    }\n\n    @Nullable\n    private View getFirstVisibleImgPreviewView() {\n        View firstImage = findViewById(R.id.content_preview_image_1_large);\n        return firstImage != null && firstImage.isVisibleToUser() ? firstImage : null;\n    }\n\n    private void addActionButton(ViewGroup parent, Button b) {\n        if (b == null) return;\n        final ViewGroup.MarginLayoutParams lp = new ViewGroup.MarginLayoutParams(\n                        LayoutParams.WRAP_CONTENT,\n                        LayoutParams.WRAP_CONTENT\n                );\n        final int gap = getResources().getDimensionPixelSize(R.dimen.resolver_icon_margin) / 2;\n        lp.setMarginsRelative(gap, 0, gap, 0);\n        parent.addView(b, lp);\n    }\n\n    private ViewGroup displayContentPreview(@ContentPreviewType int previewType,\n            Intent targetIntent, LayoutInflater layoutInflater, ViewGroup parent) {\n        ViewGroup layout = null;\n\n        switch (previewType) {\n            case CONTENT_PREVIEW_TEXT:\n                layout = displayTextContentPreview(targetIntent, layoutInflater, parent);\n                break;\n            case CONTENT_PREVIEW_IMAGE:\n                layout = displayImageContentPreview(targetIntent, layoutInflater, parent);\n                break;\n            case CONTENT_PREVIEW_FILE:\n                layout = displayFileContentPreview(targetIntent, layoutInflater, parent);\n                break;\n            default:\n                Log.e(TAG, \"Unexpected content preview type: \" + previewType);\n        }\n\n        if (layout != null) {\n            adjustPreviewWidth(getResources().getConfiguration().orientation, layout);\n        }\n        if (previewType != CONTENT_PREVIEW_IMAGE) {\n            mEnterTransitionAnimationDelegate.markImagePreviewReady();\n        }\n\n        return layout;\n    }\n\n    private ViewGroup displayTextContentPreview(Intent targetIntent, LayoutInflater layoutInflater,\n            ViewGroup parent) {\n        ViewGroup contentPreviewLayout = (ViewGroup) layoutInflater.inflate(\n                R.layout.chooser_grid_preview_text, parent, false);\n\n        final ViewGroup actionRow =\n                (ViewGroup) contentPreviewLayout.findViewById(R.id.chooser_action_row);\n        addActionButton(actionRow, createCopyButton());\n        if (shouldNearbyShareBeIncludedAsActionButton()) {\n            addActionButton(actionRow, createNearbyButton(targetIntent));\n        }\n\n        CharSequence sharingText = targetIntent.getCharSequenceExtra(Intent.EXTRA_TEXT);\n        if (sharingText == null) {\n            contentPreviewLayout.findViewById(R.id.content_preview_text_layout).setVisibility(\n                    View.GONE);\n        } else {\n            TextView textView = contentPreviewLayout.findViewById(R.id.content_preview_text);\n            textView.setText(sharingText);\n        }\n\n        String previewTitle = targetIntent.getStringExtra(Intent.EXTRA_TITLE);\n        if (TextUtils.isEmpty(previewTitle)) {\n            contentPreviewLayout.findViewById(R.id.content_preview_title_layout).setVisibility(\n                    View.GONE);\n        } else {\n            TextView previewTitleView = contentPreviewLayout.findViewById(\n                    R.id.content_preview_title);\n            previewTitleView.setText(previewTitle);\n\n            ClipData previewData = targetIntent.getClipData();\n            Uri previewThumbnail = null;\n            if (previewData != null) {\n                if (previewData.getItemCount() > 0) {\n                    ClipData.Item previewDataItem = previewData.getItemAt(0);\n                    previewThumbnail = previewDataItem.getUri();\n                }\n            }\n\n            ImageView previewThumbnailView = contentPreviewLayout.findViewById(\n                    R.id.content_preview_thumbnail);\n            if (!validForContentPreview(previewThumbnail)) {\n                previewThumbnailView.setVisibility(View.GONE);\n            } else {\n                mPreviewCoord = new ContentPreviewCoordinator(contentPreviewLayout, false);\n                mPreviewCoord.loadUriIntoView(R.id.content_preview_thumbnail, previewThumbnail, 0);\n            }\n        }\n\n        return contentPreviewLayout;\n    }\n\n    private ViewGroup displayImageContentPreview(Intent targetIntent, LayoutInflater layoutInflater,\n            ViewGroup parent) {\n        ViewGroup contentPreviewLayout = (ViewGroup) layoutInflater.inflate(\n                R.layout.chooser_grid_preview_image, parent, false);\n        ViewGroup imagePreview = contentPreviewLayout.findViewById(R.id.content_preview_image_area);\n\n        final ViewGroup actionRow =\n                (ViewGroup) contentPreviewLayout.findViewById(R.id.chooser_action_row);\n        //TODO: addActionButton(actionRow, createCopyButton());\n        if (shouldNearbyShareBeIncludedAsActionButton()) {\n            addActionButton(actionRow, createNearbyButton(targetIntent));\n        }\n        addActionButton(actionRow, createEditButton(targetIntent));\n\n        mPreviewCoord = new ContentPreviewCoordinator(contentPreviewLayout, false);\n\n        String action = targetIntent.getAction();\n        if (Intent.ACTION_SEND.equals(action)) {\n            Uri uri = targetIntent.getParcelableExtra(Intent.EXTRA_STREAM, android.net.Uri.class);\n            if (!validForContentPreview(uri)) {\n                imagePreview.setVisibility(View.GONE);\n                return contentPreviewLayout;\n            }\n            imagePreview.findViewById(R.id.content_preview_image_1_large)\n                    .setTransitionName(ChooserActivity.FIRST_IMAGE_PREVIEW_TRANSITION_NAME);\n            mPreviewCoord.loadUriIntoView(R.id.content_preview_image_1_large, uri, 0);\n        } else {\n            ContentResolver resolver = getContentResolver();\n\n            List<Uri> uris = targetIntent.getParcelableArrayListExtra(Intent.EXTRA_STREAM, android.net.Uri.class);\n            List<Uri> imageUris = new ArrayList<>();\n            for (Uri uri : uris) {\n                if (validForContentPreview(uri) && isImageType(resolver.getType(uri))) {\n                    imageUris.add(uri);\n                }\n            }\n\n            if (imageUris.size() == 0) {\n                Log.i(TAG, \"Attempted to display image preview area with zero\"\n                        + \" available images detected in EXTRA_STREAM list\");\n                imagePreview.setVisibility(View.GONE);\n                return contentPreviewLayout;\n            }\n\n            imagePreview.findViewById(R.id.content_preview_image_1_large)\n                    .setTransitionName(ChooserActivity.FIRST_IMAGE_PREVIEW_TRANSITION_NAME);\n            mPreviewCoord.loadUriIntoView(R.id.content_preview_image_1_large, imageUris.get(0), 0);\n\n            if (imageUris.size() == 2) {\n                mPreviewCoord.loadUriIntoView(R.id.content_preview_image_2_large,\n                        imageUris.get(1), 0);\n            } else if (imageUris.size() > 2) {\n                mPreviewCoord.loadUriIntoView(R.id.content_preview_image_2_small,\n                        imageUris.get(1), 0);\n                mPreviewCoord.loadUriIntoView(R.id.content_preview_image_3_small,\n                        imageUris.get(2), imageUris.size() - 3);\n            }\n        }\n\n        return contentPreviewLayout;\n    }\n\n    private static class FileInfo {\n        public final String name;\n        public final boolean hasThumbnail;\n\n        FileInfo(String name, boolean hasThumbnail) {\n            this.name = name;\n            this.hasThumbnail = hasThumbnail;\n        }\n    }\n\n    /**\n     * Wrapping the ContentResolver call to expose for easier mocking,\n     * and to avoid mocking Android core classes.\n     */\n    @VisibleForTesting\n    public Cursor queryResolver(ContentResolver resolver, Uri uri) {\n        return resolver.query(uri, null, null, null, null);\n    }\n\n    private FileInfo extractFileInfo(Uri uri, ContentResolver resolver) {\n        String fileName = null;\n        boolean hasThumbnail = false;\n\n        try (Cursor cursor = queryResolver(resolver, uri)) {\n            if (cursor != null && cursor.getCount() > 0) {\n                int nameIndex = cursor.getColumnIndex(OpenableColumns.DISPLAY_NAME);\n                int titleIndex = cursor.getColumnIndex(Downloads.Impl.COLUMN_TITLE);\n                int flagsIndex = cursor.getColumnIndex(DocumentsContract.Document.COLUMN_FLAGS);\n\n                cursor.moveToFirst();\n                if (nameIndex != -1) {\n                    fileName = cursor.getString(nameIndex);\n                } else if (titleIndex != -1) {\n                    fileName = cursor.getString(titleIndex);\n                }\n\n                if (flagsIndex != -1) {\n                    hasThumbnail = (cursor.getInt(flagsIndex)\n                            & DocumentsContract.Document.FLAG_SUPPORTS_THUMBNAIL) != 0;\n                }\n            }\n        } catch (SecurityException | NullPointerException e) {\n            logContentPreviewWarning(uri);\n        }\n\n        if (TextUtils.isEmpty(fileName)) {\n            fileName = uri.getPath();\n            int index = fileName.lastIndexOf('/');\n            if (index != -1) {\n                fileName = fileName.substring(index + 1);\n            }\n        }\n\n        return new FileInfo(fileName, hasThumbnail);\n    }\n\n    private void logContentPreviewWarning(Uri uri) {\n        // The ContentResolver already logs the exception. Log something more informative.\n        Log.w(TAG, \"Could not load (\" + uri.toString() + \") thumbnail/name for preview. If \"\n                + \"desired, consider using Intent#createChooser to launch the ChooserActivity, \"\n                + \"and set your Intent's clipData and flags in accordance with that method's \"\n                + \"documentation\");\n    }\n\n    private ViewGroup displayFileContentPreview(Intent targetIntent, LayoutInflater layoutInflater,\n            ViewGroup parent) {\n\n        ViewGroup contentPreviewLayout = (ViewGroup) layoutInflater.inflate(\n                R.layout.chooser_grid_preview_file, parent, false);\n\n        final ViewGroup actionRow =\n                (ViewGroup) contentPreviewLayout.findViewById(R.id.chooser_action_row);\n        //TODO(b/120417119): addActionButton(actionRow, createCopyButton());\n        if (shouldNearbyShareBeIncludedAsActionButton()) {\n            addActionButton(actionRow, createNearbyButton(targetIntent));\n        }\n\n        String action = targetIntent.getAction();\n        if (Intent.ACTION_SEND.equals(action)) {\n            Uri uri = targetIntent.getParcelableExtra(Intent.EXTRA_STREAM, android.net.Uri.class);\n            if (!validForContentPreview(uri)) {\n                contentPreviewLayout.setVisibility(View.GONE);\n                return contentPreviewLayout;\n            }\n            loadFileUriIntoView(uri, contentPreviewLayout);\n        } else {\n            List<Uri> uris = targetIntent.getParcelableArrayListExtra(Intent.EXTRA_STREAM, android.net.Uri.class);\n            uris = uris.stream()\n                    .filter(ChooserActivity::validForContentPreview)\n                    .collect(Collectors.toList());\n            int uriCount = uris.size();\n\n            if (uriCount == 0) {\n                contentPreviewLayout.setVisibility(View.GONE);\n                Log.i(TAG,\n                        \"Appears to be no uris available in EXTRA_STREAM, removing \"\n                                + \"preview area\");\n                return contentPreviewLayout;\n            } else if (uriCount == 1) {\n                loadFileUriIntoView(uris.get(0), contentPreviewLayout);\n            } else {\n                FileInfo fileInfo = extractFileInfo(uris.get(0), getContentResolver());\n                int remUriCount = uriCount - 1;\n                Map<String, Object> arguments = new HashMap<>();\n                arguments.put(PLURALS_COUNT, remUriCount);\n                arguments.put(PLURALS_FILE_NAME, fileInfo.name);\n                String fileName = PluralsMessageFormatter.format(\n                        getResources(),\n                        arguments,\n                        R.string.file_count);\n\n                TextView fileNameView = contentPreviewLayout.findViewById(\n                        R.id.content_preview_filename);\n                fileNameView.setText(fileName);\n\n                View thumbnailView = contentPreviewLayout.findViewById(\n                        R.id.content_preview_file_thumbnail);\n                thumbnailView.setVisibility(View.GONE);\n\n                ImageView fileIconView = contentPreviewLayout.findViewById(\n                        R.id.content_preview_file_icon);\n                fileIconView.setVisibility(View.VISIBLE);\n                fileIconView.setImageResource(R.drawable.ic_file_copy);\n            }\n        }\n\n        return contentPreviewLayout;\n    }\n\n    private void loadFileUriIntoView(final Uri uri, final View parent) {\n        FileInfo fileInfo = extractFileInfo(uri, getContentResolver());\n\n        TextView fileNameView = parent.findViewById(R.id.content_preview_filename);\n        fileNameView.setText(fileInfo.name);\n\n        if (fileInfo.hasThumbnail) {\n            mPreviewCoord = new ContentPreviewCoordinator(parent, false);\n            mPreviewCoord.loadUriIntoView(R.id.content_preview_file_thumbnail, uri, 0);\n        } else {\n            View thumbnailView = parent.findViewById(R.id.content_preview_file_thumbnail);\n            thumbnailView.setVisibility(View.GONE);\n\n            ImageView fileIconView = parent.findViewById(R.id.content_preview_file_icon);\n            fileIconView.setVisibility(View.VISIBLE);\n            fileIconView.setImageResource(R.drawable.chooser_file_generic);\n        }\n    }\n\n    /**\n     * Indicate if the incoming content URI should be allowed.\n     *\n     * @param uri the uri to test\n     * @return true if the URI is allowed for content preview\n     */\n    private static boolean validForContentPreview(Uri uri) throws SecurityException {\n        if (uri == null) {\n            return false;\n        }\n        int userId = getUserIdFromUri(uri, UserHandle.USER_CURRENT);\n        if (userId != UserHandle.USER_CURRENT && userId != UserHandle.myUserId()) {\n            Log.e(TAG, \"dropped invalid content URI belonging to user \" + userId);\n            return false;\n        }\n        return true;\n    }\n\n    @VisibleForTesting\n    protected boolean isImageType(String mimeType) {\n        return mimeType != null && mimeType.startsWith(\"image/\");\n    }\n\n    @ContentPreviewType\n    private int findPreferredContentPreview(Uri uri, ContentResolver resolver) {\n        if (uri == null) {\n            return CONTENT_PREVIEW_TEXT;\n        }\n\n        String mimeType = resolver.getType(uri);\n        return isImageType(mimeType) ? CONTENT_PREVIEW_IMAGE : CONTENT_PREVIEW_FILE;\n    }\n\n    /**\n     * In {@link android.content.Intent#getType}, the app may specify a very general\n     * mime-type that broadly covers all data being shared, such as {@literal *}/*\n     * when sending an image and text. We therefore should inspect each item for the\n     * the preferred type, in order of IMAGE, FILE, TEXT.\n     */\n    @ContentPreviewType\n    private int findPreferredContentPreview(Intent targetIntent, ContentResolver resolver) {\n        String action = targetIntent.getAction();\n        if (Intent.ACTION_SEND.equals(action)) {\n            Uri uri = targetIntent.getParcelableExtra(Intent.EXTRA_STREAM, android.net.Uri.class);\n            return findPreferredContentPreview(uri, resolver);\n        } else if (Intent.ACTION_SEND_MULTIPLE.equals(action)) {\n            List<Uri> uris = targetIntent.getParcelableArrayListExtra(Intent.EXTRA_STREAM, android.net.Uri.class);\n            if (uris == null || uris.isEmpty()) {\n                return CONTENT_PREVIEW_TEXT;\n            }\n\n            for (Uri uri : uris) {\n                // Defaulting to file preview when there are mixed image/file types is\n                // preferable, as it shows the user the correct number of items being shared\n                if (findPreferredContentPreview(uri, resolver) == CONTENT_PREVIEW_FILE) {\n                    return CONTENT_PREVIEW_FILE;\n                }\n            }\n\n            return CONTENT_PREVIEW_IMAGE;\n        }\n\n        return CONTENT_PREVIEW_TEXT;\n    }\n\n    private int getNumSheetExpansions() {\n        return getPreferences(Context.MODE_PRIVATE).getInt(PREF_NUM_SHEET_EXPANSIONS, 0);\n    }\n\n    private void incrementNumSheetExpansions() {\n        getPreferences(Context.MODE_PRIVATE).edit().putInt(PREF_NUM_SHEET_EXPANSIONS,\n                getNumSheetExpansions() + 1).apply();\n    }\n\n    @Override\n    protected void onStop() {\n        super.onStop();\n        if (maybeCancelFinishAnimation()) {\n            finish();\n        }\n    }\n\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n\n        if (isFinishing()) {\n            mLatencyTracker.onActionCancel(ACTION_LOAD_SHARE_SHEET);\n        }\n\n        if (mRefinementResultReceiver != null) {\n            mRefinementResultReceiver.destroy();\n            mRefinementResultReceiver = null;\n        }\n        mChooserHandler.removeAllMessages();\n\n        if (mPreviewCoord != null) mPreviewCoord.cancelLoads();\n\n        mChooserMultiProfilePagerAdapter.getActiveListAdapter().destroyAppPredictor();\n        if (mChooserMultiProfilePagerAdapter.getInactiveListAdapter() != null) {\n            mChooserMultiProfilePagerAdapter.getInactiveListAdapter().destroyAppPredictor();\n        }\n        mPersonalAppPredictor = null;\n        mWorkAppPredictor = null;\n    }\n\n    @Override // ResolverListCommunicator\n    public Intent getReplacementIntent(ActivityInfo aInfo, Intent defIntent) {\n        Intent result = defIntent;\n        if (mReplacementExtras != null) {\n            final Bundle replExtras = mReplacementExtras.getBundle(aInfo.packageName);\n            if (replExtras != null) {\n                result = new Intent(defIntent);\n                result.putExtras(replExtras);\n            }\n        }\n        if (aInfo.name.equals(IntentForwarderActivity.FORWARD_INTENT_TO_PARENT)\n                || aInfo.name.equals(IntentForwarderActivity.FORWARD_INTENT_TO_MANAGED_PROFILE)) {\n            result = Intent.createChooser(result,\n                    getIntent().getCharSequenceExtra(Intent.EXTRA_TITLE));\n\n            // Don't auto-launch single intents if the intent is being forwarded. This is done\n            // because automatically launching a resolving application as a response to the user\n            // action of switching accounts is pretty unexpected.\n            result.putExtra(Intent.EXTRA_AUTO_LAUNCH_SINGLE_CHOICE, false);\n        }\n        return result;\n    }\n\n    @Override\n    public void onActivityStarted(TargetInfo cti) {\n        if (mChosenComponentSender != null) {\n            final ComponentName target = cti.getResolvedComponentName();\n            if (target != null) {\n                final Intent fillIn = new Intent().putExtra(Intent.EXTRA_CHOSEN_COMPONENT, target);\n                try {\n                    mChosenComponentSender.sendIntent(this, Activity.RESULT_OK, fillIn, null, null);\n                } catch (IntentSender.SendIntentException e) {\n                    Slog.e(TAG, \"Unable to launch supplied IntentSender to report \"\n                            + \"the chosen component: \" + e);\n                }\n            }\n        }\n    }\n\n    @Override\n    public void addUseDifferentAppLabelIfNecessary(ResolverListAdapter adapter) {\n        if (mCallerChooserTargets != null && mCallerChooserTargets.length > 0) {\n            mChooserMultiProfilePagerAdapter.getActiveListAdapter().addServiceResults(\n                    /* origTarget */ null,\n                    Lists.newArrayList(mCallerChooserTargets),\n                    TARGET_TYPE_DEFAULT,\n                    /* directShareShortcutInfoCache */ null);\n        }\n    }\n\n    @Override\n    public int getLayoutResource() {\n        return R.layout.chooser_grid;\n    }\n\n    @Override // ResolverListCommunicator\n    public boolean shouldGetActivityMetadata() {\n        return true;\n    }\n\n    @Override\n    public boolean shouldAutoLaunchSingleChoice(TargetInfo target) {\n        // Note that this is only safe because the Intent handled by the ChooserActivity is\n        // guaranteed to contain no extras unknown to the local ClassLoader. That is why this\n        // method can not be replaced in the ResolverActivity whole hog.\n        if (!super.shouldAutoLaunchSingleChoice(target)) {\n            return false;\n        }\n\n        return getIntent().getBooleanExtra(Intent.EXTRA_AUTO_LAUNCH_SINGLE_CHOICE, true);\n    }\n\n    private void showTargetDetails(TargetInfo targetInfo) {\n        if (targetInfo == null) return;\n\n        ArrayList<DisplayResolveInfo> targetList;\n        ChooserTargetActionsDialogFragment fragment = new ChooserTargetActionsDialogFragment();\n        Bundle bundle = new Bundle();\n\n        if (targetInfo instanceof SelectableTargetInfo) {\n            SelectableTargetInfo selectableTargetInfo = (SelectableTargetInfo) targetInfo;\n            if (selectableTargetInfo.getDisplayResolveInfo() == null\n                    || selectableTargetInfo.getChooserTarget() == null) {\n                Log.e(TAG, \"displayResolveInfo or chooserTarget in selectableTargetInfo are null\");\n                return;\n            }\n            targetList = new ArrayList<>();\n            targetList.add(selectableTargetInfo.getDisplayResolveInfo());\n            bundle.putString(ChooserTargetActionsDialogFragment.SHORTCUT_ID_KEY,\n                    selectableTargetInfo.getChooserTarget().getIntentExtras().getString(\n                            Intent.EXTRA_SHORTCUT_ID));\n            bundle.putBoolean(ChooserTargetActionsDialogFragment.IS_SHORTCUT_PINNED_KEY,\n                    selectableTargetInfo.isPinned());\n            bundle.putParcelable(ChooserTargetActionsDialogFragment.INTENT_FILTER_KEY,\n                    getTargetIntentFilter());\n            if (selectableTargetInfo.getDisplayLabel() != null) {\n                bundle.putString(ChooserTargetActionsDialogFragment.SHORTCUT_TITLE_KEY,\n                        selectableTargetInfo.getDisplayLabel().toString());\n            }\n        } else if (targetInfo instanceof MultiDisplayResolveInfo) {\n            // For multiple targets, include info on all targets\n            MultiDisplayResolveInfo mti = (MultiDisplayResolveInfo) targetInfo;\n            targetList = mti.getTargets();\n        } else {\n            targetList = new ArrayList<DisplayResolveInfo>();\n            targetList.add((DisplayResolveInfo) targetInfo);\n        }\n        // Adding userHandle from ResolveInfo allows the app icon in Dialog Box to be\n        // resolved correctly.\n        bundle.putParcelable(ChooserTargetActionsDialogFragment.USER_HANDLE_KEY,\n                getResolveInfoUserHandle(\n                        targetInfo.getResolveInfo(),\n                        mChooserMultiProfilePagerAdapter.getCurrentUserHandle()));\n        bundle.putParcelableArrayList(ChooserTargetActionsDialogFragment.TARGET_INFOS_KEY,\n                targetList);\n        fragment.setArguments(bundle);\n\n        fragment.show(getFragmentManager(), TARGET_DETAILS_FRAGMENT_TAG);\n    }\n\n    private void modifyTargetIntent(Intent in) {\n        if (isSendAction(in)) {\n            in.addFlags(Intent.FLAG_ACTIVITY_NEW_DOCUMENT |\n                    Intent.FLAG_ACTIVITY_MULTIPLE_TASK);\n        }\n    }\n\n    @Override\n    protected boolean onTargetSelected(TargetInfo target, boolean alwaysCheck) {\n        if (mRefinementIntentSender != null) {\n            final Intent fillIn = new Intent();\n            final List<Intent> sourceIntents = target.getAllSourceIntents();\n            if (!sourceIntents.isEmpty()) {\n                fillIn.putExtra(Intent.EXTRA_INTENT, sourceIntents.get(0));\n                if (sourceIntents.size() > 1) {\n                    final Intent[] alts = new Intent[sourceIntents.size() - 1];\n                    for (int i = 1, N = sourceIntents.size(); i < N; i++) {\n                        alts[i - 1] = sourceIntents.get(i);\n                    }\n                    fillIn.putExtra(Intent.EXTRA_ALTERNATE_INTENTS, alts);\n                }\n                if (mRefinementResultReceiver != null) {\n                    mRefinementResultReceiver.destroy();\n                }\n                mRefinementResultReceiver = new RefinementResultReceiver(this, target, null);\n                fillIn.putExtra(Intent.EXTRA_RESULT_RECEIVER,\n                        mRefinementResultReceiver);\n                try {\n                    mRefinementIntentSender.sendIntent(this, 0, fillIn, null, null);\n                    return false;\n                } catch (SendIntentException e) {\n                    Log.e(TAG, \"Refinement IntentSender failed to send\", e);\n                }\n            }\n        }\n        updateModelAndChooserCounts(target);\n        return super.onTargetSelected(target, alwaysCheck);\n    }\n\n    @Override\n    public void startSelected(int which, boolean always, boolean filtered) {\n        ChooserListAdapter currentListAdapter =\n                mChooserMultiProfilePagerAdapter.getActiveListAdapter();\n        TargetInfo targetInfo = currentListAdapter\n                .targetInfoForPosition(which, filtered);\n        if (targetInfo != null && targetInfo instanceof NotSelectableTargetInfo) {\n            return;\n        }\n\n        final long selectionCost = System.currentTimeMillis() - mChooserShownTime;\n\n        if (targetInfo instanceof MultiDisplayResolveInfo) {\n            MultiDisplayResolveInfo mti = (MultiDisplayResolveInfo) targetInfo;\n            if (!mti.hasSelected()) {\n                ChooserStackedAppDialogFragment f = new ChooserStackedAppDialogFragment();\n                Bundle b = new Bundle();\n                // Add userHandle based badge to the stackedAppDialogBox.\n                b.putParcelable(ChooserTargetActionsDialogFragment.USER_HANDLE_KEY,\n                        getResolveInfoUserHandle(\n                                targetInfo.getResolveInfo(),\n                                mChooserMultiProfilePagerAdapter.getCurrentUserHandle()));\n                b.putObject(ChooserStackedAppDialogFragment.MULTI_DRI_KEY,\n                        mti);\n                b.putInt(ChooserStackedAppDialogFragment.WHICH_KEY, which);\n                f.setArguments(b);\n\n                f.show(getFragmentManager(), TARGET_DETAILS_FRAGMENT_TAG);\n                return;\n            }\n        }\n\n        super.startSelected(which, always, filtered);\n\n        if (currentListAdapter.getCount() > 0) {\n            // Log the index of which type of target the user picked.\n            // Lower values mean the ranking was better.\n            int cat = 0;\n            int value = which;\n            int directTargetAlsoRanked = -1;\n            int numCallerProvided = 0;\n            HashedStringCache.HashResult directTargetHashed = null;\n            switch (currentListAdapter.getPositionTargetType(which)) {\n                case ChooserListAdapter.TARGET_SERVICE:\n                    cat = MetricsEvent.ACTION_ACTIVITY_CHOOSER_PICKED_SERVICE_TARGET;\n                    // Log the package name + target name to answer the question if most users\n                    // share to mostly the same person or to a bunch of different people.\n                    ChooserTarget target = currentListAdapter.getChooserTargetForValue(value);\n                    directTargetHashed = HashedStringCache.getInstance().hashString(\n                            this,\n                            TAG,\n                            target.getComponentName().getPackageName()\n                                    + target.getTitle().toString(),\n                            mMaxHashSaltDays);\n                    SelectableTargetInfo selectableTargetInfo = (SelectableTargetInfo) targetInfo;\n                    directTargetAlsoRanked = getRankedPosition(selectableTargetInfo);\n\n                    if (mCallerChooserTargets != null) {\n                        numCallerProvided = mCallerChooserTargets.length;\n                    }\n                    getChooserActivityLogger().logShareTargetSelected(\n                            SELECTION_TYPE_SERVICE,\n                            targetInfo.getResolveInfo().activityInfo.processName,\n                            value,\n                            selectableTargetInfo.isPinned()\n                    );\n                    break;\n                case ChooserListAdapter.TARGET_CALLER:\n                case ChooserListAdapter.TARGET_STANDARD:\n                    cat = MetricsEvent.ACTION_ACTIVITY_CHOOSER_PICKED_APP_TARGET;\n                    value -= currentListAdapter.getSurfacedTargetInfo().size();\n                    numCallerProvided = currentListAdapter.getCallerTargetCount();\n                    getChooserActivityLogger().logShareTargetSelected(\n                            SELECTION_TYPE_APP,\n                            targetInfo.getResolveInfo().activityInfo.processName,\n                            value,\n                            targetInfo.isPinned()\n                    );\n                    break;\n                case ChooserListAdapter.TARGET_STANDARD_AZ:\n                    // A-Z targets are unranked standard targets; we use -1 to mark that they\n                    // are from the alphabetical pool.\n                    value = -1;\n                    cat = MetricsEvent.ACTION_ACTIVITY_CHOOSER_PICKED_STANDARD_TARGET;\n                    getChooserActivityLogger().logShareTargetSelected(\n                            SELECTION_TYPE_STANDARD,\n                            targetInfo.getResolveInfo().activityInfo.processName,\n                            value,\n                            false\n                    );\n                    break;\n            }\n\n            if (cat != 0) {\n                LogMaker targetLogMaker = new LogMaker(cat).setSubtype(value);\n                if (directTargetHashed != null) {\n                    targetLogMaker.addTaggedData(\n                            MetricsEvent.FIELD_HASHED_TARGET_NAME, directTargetHashed.hashedString);\n                    targetLogMaker.addTaggedData(\n                                    MetricsEvent.FIELD_HASHED_TARGET_SALT_GEN,\n                                    directTargetHashed.saltGeneration);\n                    targetLogMaker.addTaggedData(MetricsEvent.FIELD_RANKED_POSITION,\n                                    directTargetAlsoRanked);\n                }\n                targetLogMaker.addTaggedData(MetricsEvent.FIELD_IS_CATEGORY_USED,\n                        numCallerProvided);\n                getMetricsLogger().write(targetLogMaker);\n            }\n\n            if (mIsSuccessfullySelected) {\n                if (DEBUG) {\n                    Log.d(TAG, \"User Selection Time Cost is \" + selectionCost);\n                    Log.d(TAG, \"position of selected app/service/caller is \" +\n                            Integer.toString(value));\n                }\n                MetricsLogger.histogram(null, \"user_selection_cost_for_smart_sharing\",\n                        (int) selectionCost);\n                MetricsLogger.histogram(null, \"app_position_for_smart_sharing\", value);\n            }\n        }\n    }\n\n    private int getRankedPosition(SelectableTargetInfo targetInfo) {\n        String targetPackageName =\n                targetInfo.getChooserTarget().getComponentName().getPackageName();\n        ChooserListAdapter currentListAdapter =\n                mChooserMultiProfilePagerAdapter.getActiveListAdapter();\n        int maxRankedResults = Math.min(currentListAdapter.mDisplayList.size(),\n                MAX_LOG_RANK_POSITION);\n\n        for (int i = 0; i < maxRankedResults; i++) {\n            if (currentListAdapter.mDisplayList.get(i)\n                    .getResolveInfo().activityInfo.packageName.equals(targetPackageName)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    @Override\n    protected boolean shouldAddFooterView() {\n        // To accommodate for window insets\n        return true;\n    }\n\n    @Override\n    protected void applyFooterView(int height) {\n        int count = mChooserMultiProfilePagerAdapter.getItemCount();\n\n        for (int i = 0; i < count; i++) {\n            mChooserMultiProfilePagerAdapter.getAdapterForIndex(i).setFooterHeight(height);\n        }\n    }\n\n    private IntentFilter getTargetIntentFilter() {\n        try {\n            final Intent intent = getTargetIntent();\n            String dataString = intent.getDataString();\n            if (intent.getType() == null) {\n                if (!TextUtils.isEmpty(dataString)) {\n                    return new IntentFilter(intent.getAction(), dataString);\n                }\n                Log.e(TAG, \"Failed to get target intent filter: intent data and type are null\");\n                return null;\n            }\n            IntentFilter intentFilter = new IntentFilter(intent.getAction(), intent.getType());\n            List<Uri> contentUris = new ArrayList<>();\n            if (Intent.ACTION_SEND.equals(intent.getAction())) {\n                Uri uri = (Uri) intent.getParcelableExtra(Intent.EXTRA_STREAM, android.net.Uri.class);\n                if (uri != null) {\n                    contentUris.add(uri);\n                }\n            } else {\n                List<Uri> uris = intent.getParcelableArrayListExtra(Intent.EXTRA_STREAM, android.net.Uri.class);\n                if (uris != null) {\n                    contentUris.addAll(uris);\n                }\n            }\n            for (Uri uri : contentUris) {\n                intentFilter.addDataScheme(uri.getScheme());\n                intentFilter.addDataAuthority(uri.getAuthority(), null);\n                intentFilter.addDataPath(uri.getPath(), PatternMatcher.PATTERN_LITERAL);\n            }\n            return intentFilter;\n        } catch (Exception e) {\n            Log.e(TAG, \"Failed to get target intent filter\", e);\n            return null;\n        }\n    }\n\n    @VisibleForTesting\n    protected void queryDirectShareTargets(\n                ChooserListAdapter adapter, boolean skipAppPredictionService) {\n        mQueriedSharingShortcutsTimeMs = System.currentTimeMillis();\n        UserHandle userHandle = adapter.getUserHandle();\n        if (!skipAppPredictionService) {\n            AppPredictor appPredictor = getAppPredictorForDirectShareIfEnabled(userHandle);\n            if (appPredictor != null) {\n                appPredictor.requestPredictionUpdate();\n                return;\n            }\n        }\n        // Default to just querying ShortcutManager if AppPredictor not present.\n        final IntentFilter filter = getTargetIntentFilter();\n        if (filter == null) {\n            return;\n        }\n\n        AsyncTask.execute(() -> {\n            Context selectedProfileContext = createContextAsUser(userHandle, 0 /* flags */);\n            ShortcutManager sm = (ShortcutManager) selectedProfileContext\n                    .getSystemService(Context.SHORTCUT_SERVICE);\n            List<ShortcutManager.ShareShortcutInfo> resultList = sm.getShareTargets(filter);\n            sendShareShortcutInfoList(resultList, adapter, null, userHandle);\n        });\n    }\n\n    /**\n     * Returns {@code false} if {@code userHandle} is the work profile and it's either\n     * in quiet mode or not running.\n     */\n    private boolean shouldQueryShortcutManager(UserHandle userHandle) {\n        if (!shouldShowTabs()) {\n            return true;\n        }\n        if (!getWorkProfileUserHandle().equals(userHandle)) {\n            return true;\n        }\n        if (!isUserRunning(userHandle)) {\n            return false;\n        }\n        if (!isUserUnlocked(userHandle)) {\n            return false;\n        }\n        if (isQuietModeEnabled(userHandle)) {\n            return false;\n        }\n        return true;\n    }\n\n    private void sendShareShortcutInfoList(\n                List<ShortcutManager.ShareShortcutInfo> resultList,\n                ChooserListAdapter chooserListAdapter,\n                @Nullable List<AppTarget> appTargets, UserHandle userHandle) {\n        if (appTargets != null && appTargets.size() != resultList.size()) {\n            throw new RuntimeException(\"resultList and appTargets must have the same size.\"\n                    + \" resultList.size()=\" + resultList.size()\n                    + \" appTargets.size()=\" + appTargets.size());\n        }\n        Context selectedProfileContext = createContextAsUser(userHandle, 0 /* flags */);\n        for (int i = resultList.size() - 1; i >= 0; i--) {\n            final String packageName = resultList.get(i).getTargetComponent().getPackageName();\n            if (!isPackageEnabled(selectedProfileContext, packageName)) {\n                resultList.remove(i);\n                if (appTargets != null) {\n                    appTargets.remove(i);\n                }\n            }\n        }\n\n        // If |appTargets| is not null, results are from AppPredictionService and already sorted.\n        final int shortcutType = (appTargets == null ? TARGET_TYPE_SHORTCUTS_FROM_SHORTCUT_MANAGER :\n                TARGET_TYPE_SHORTCUTS_FROM_PREDICTION_SERVICE);\n\n        // Match ShareShortcutInfos with DisplayResolveInfos to be able to use the old code path\n        // for direct share targets. After ShareSheet is refactored we should use the\n        // ShareShortcutInfos directly.\n        List<ServiceResultInfo> resultRecords = new ArrayList<>();\n        for (int i = 0; i < chooserListAdapter.getDisplayResolveInfoCount(); i++) {\n            DisplayResolveInfo displayResolveInfo = chooserListAdapter.getDisplayResolveInfo(i);\n            List<ShortcutManager.ShareShortcutInfo> matchingShortcuts =\n                    filterShortcutsByTargetComponentName(\n                            resultList, displayResolveInfo.getResolvedComponentName());\n            if (matchingShortcuts.isEmpty()) {\n                continue;\n            }\n            List<ChooserTarget> chooserTargets = convertToChooserTarget(\n                    matchingShortcuts, resultList, appTargets, shortcutType);\n\n            ServiceResultInfo resultRecord = new ServiceResultInfo(\n                    displayResolveInfo, chooserTargets, userHandle);\n            resultRecords.add(resultRecord);\n        }\n\n        sendShortcutManagerShareTargetResults(\n                shortcutType, resultRecords.toArray(new ServiceResultInfo[0]));\n    }\n\n    private List<ShortcutManager.ShareShortcutInfo> filterShortcutsByTargetComponentName(\n            List<ShortcutManager.ShareShortcutInfo> allShortcuts, ComponentName requiredTarget) {\n        List<ShortcutManager.ShareShortcutInfo> matchingShortcuts = new ArrayList<>();\n        for (ShortcutManager.ShareShortcutInfo shortcut : allShortcuts) {\n            if (requiredTarget.equals(shortcut.getTargetComponent())) {\n                matchingShortcuts.add(shortcut);\n            }\n        }\n        return matchingShortcuts;\n    }\n\n    @VisibleForTesting\n    protected void sendShortcutManagerShareTargetResults(\n            int shortcutType, ServiceResultInfo[] results) {\n        final Message msg = Message.obtain();\n        msg.what = ChooserHandler.SHORTCUT_MANAGER_ALL_SHARE_TARGET_RESULTS;\n        msg.obj = results;\n        msg.arg1 = shortcutType;\n        mChooserHandler.sendMessage(msg);\n    }\n\n    private boolean isPackageEnabled(Context context, String packageName) {\n        if (TextUtils.isEmpty(packageName)) {\n            return false;\n        }\n        ApplicationInfo appInfo;\n        try {\n            appInfo = context.getPackageManager().getApplicationInfo(packageName, 0);\n        } catch (NameNotFoundException e) {\n            return false;\n        }\n\n        if (appInfo != null && appInfo.enabled\n                && (appInfo.flags & ApplicationInfo.FLAG_SUSPENDED) == 0) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Converts a list of ShareShortcutInfos to ChooserTargets.\n     * @param matchingShortcuts List of shortcuts, all from the same package, that match the current\n     *                         share intent filter.\n     * @param allShortcuts List of all the shortcuts from all the packages on the device that are\n     *                    returned for the current sharing action.\n     * @param allAppTargets List of AppTargets. Null if the results are not from prediction service.\n     * @param shortcutType One of the values TARGET_TYPE_SHORTCUTS_FROM_SHORTCUT_MANAGER or\n     *                    TARGET_TYPE_SHORTCUTS_FROM_PREDICTION_SERVICE\n     * @return A list of ChooserTargets sorted by score in descending order.\n     */\n    @VisibleForTesting\n    @NonNull\n    public List<ChooserTarget> convertToChooserTarget(\n            @NonNull List<ShortcutManager.ShareShortcutInfo> matchingShortcuts,\n            @NonNull List<ShortcutManager.ShareShortcutInfo> allShortcuts,\n            @Nullable List<AppTarget> allAppTargets, @ShareTargetType int shortcutType) {\n        // A set of distinct scores for the matched shortcuts. We use index of a rank in the sorted\n        // list instead of the actual rank value when converting a rank to a score.\n        List<Integer> scoreList = new ArrayList<>();\n        if (shortcutType == TARGET_TYPE_SHORTCUTS_FROM_SHORTCUT_MANAGER) {\n            for (int i = 0; i < matchingShortcuts.size(); i++) {\n                int shortcutRank = matchingShortcuts.get(i).getShortcutInfo().getRank();\n                if (!scoreList.contains(shortcutRank)) {\n                    scoreList.add(shortcutRank);\n                }\n            }\n            Collections.sort(scoreList);\n        }\n\n        List<ChooserTarget> chooserTargetList = new ArrayList<>(matchingShortcuts.size());\n        for (int i = 0; i < matchingShortcuts.size(); i++) {\n            ShortcutInfo shortcutInfo = matchingShortcuts.get(i).getShortcutInfo();\n            int indexInAllShortcuts = allShortcuts.indexOf(matchingShortcuts.get(i));\n\n            float score;\n            if (shortcutType == TARGET_TYPE_SHORTCUTS_FROM_PREDICTION_SERVICE) {\n                // Incoming results are ordered. Create a score based on index in the original list.\n                score = Math.max(1.0f - (0.01f * indexInAllShortcuts), 0.0f);\n            } else {\n                // Create a score based on the rank of the shortcut.\n                int rankIndex = scoreList.indexOf(shortcutInfo.getRank());\n                score = Math.max(1.0f - (0.01f * rankIndex), 0.0f);\n            }\n\n            Bundle extras = new Bundle();\n            extras.putString(Intent.EXTRA_SHORTCUT_ID, shortcutInfo.getId());\n\n            ChooserTarget chooserTarget = new ChooserTarget(\n                    shortcutInfo.getLabel(),\n                    null, // Icon will be loaded later if this target is selected to be shown.\n                    score, matchingShortcuts.get(i).getTargetComponent().clone(), extras);\n\n            chooserTargetList.add(chooserTarget);\n            if (mDirectShareAppTargetCache != null && allAppTargets != null) {\n                mDirectShareAppTargetCache.put(chooserTarget,\n                        allAppTargets.get(indexInAllShortcuts));\n            }\n            if (mDirectShareShortcutInfoCache != null) {\n                mDirectShareShortcutInfoCache.put(chooserTarget, shortcutInfo);\n            }\n        }\n        // Sort ChooserTargets by score in descending order\n        Comparator<ChooserTarget> byScore =\n                (ChooserTarget a, ChooserTarget b) -> -Float.compare(a.getScore(), b.getScore());\n        Collections.sort(chooserTargetList, byScore);\n        return chooserTargetList;\n    }\n\n    private void logDirectShareTargetReceived(int logCategory) {\n        final int apiLatency = (int) (System.currentTimeMillis() - mQueriedSharingShortcutsTimeMs);\n        getMetricsLogger().write(new LogMaker(logCategory).setSubtype(apiLatency));\n    }\n\n    void updateModelAndChooserCounts(TargetInfo info) {\n        if (info != null && info instanceof MultiDisplayResolveInfo) {\n            info = ((MultiDisplayResolveInfo) info).getSelectedTarget();\n        }\n        if (info != null) {\n            sendClickToAppPredictor(info);\n            final ResolveInfo ri = info.getResolveInfo();\n            Intent targetIntent = getTargetIntent();\n            if (ri != null && ri.activityInfo != null && targetIntent != null) {\n                ChooserListAdapter currentListAdapter =\n                        mChooserMultiProfilePagerAdapter.getActiveListAdapter();\n                if (currentListAdapter != null) {\n                    sendImpressionToAppPredictor(info, currentListAdapter);\n                    currentListAdapter.updateModel(info);\n                    currentListAdapter.updateChooserCounts(\n                            ri.activityInfo.packageName,\n                            targetIntent.getAction(),\n                            ri.userHandle);\n                }\n                if (DEBUG) {\n                    Log.d(TAG, \"ResolveInfo Package is \" + ri.activityInfo.packageName);\n                    Log.d(TAG, \"Action to be updated is \" + targetIntent.getAction());\n                }\n            } else if (DEBUG) {\n                Log.d(TAG, \"Can not log Chooser Counts of null ResovleInfo\");\n            }\n        }\n        mIsSuccessfullySelected = true;\n    }\n\n    private void sendImpressionToAppPredictor(TargetInfo targetInfo, ChooserListAdapter adapter) {\n        AppPredictor directShareAppPredictor = getAppPredictorForDirectShareIfEnabled(\n                mChooserMultiProfilePagerAdapter.getCurrentUserHandle());\n        if (directShareAppPredictor == null) {\n            return;\n        }\n        // Send DS target impression info to AppPredictor, only when user chooses app share.\n        if (targetInfo instanceof ChooserTargetInfo) {\n            return;\n        }\n        List<ChooserTargetInfo> surfacedTargetInfo = adapter.getSurfacedTargetInfo();\n        List<AppTargetId> targetIds = new ArrayList<>();\n        for (ChooserTargetInfo chooserTargetInfo : surfacedTargetInfo) {\n            ChooserTarget chooserTarget = chooserTargetInfo.getChooserTarget();\n            ComponentName componentName = chooserTarget.getComponentName();\n            if (mDirectShareShortcutInfoCache.containsKey(chooserTarget)) {\n                String shortcutId = mDirectShareShortcutInfoCache.get(chooserTarget).getId();\n                targetIds.add(new AppTargetId(\n                        String.format(\"%s/%s/%s\", shortcutId, componentName.flattenToString(),\n                                SHORTCUT_TARGET)));\n            }\n        }\n        directShareAppPredictor.notifyLaunchLocationShown(LAUNCH_LOCATION_DIRECT_SHARE, targetIds);\n    }\n\n    private void sendClickToAppPredictor(TargetInfo targetInfo) {\n        AppPredictor directShareAppPredictor = getAppPredictorForDirectShareIfEnabled(\n                mChooserMultiProfilePagerAdapter.getCurrentUserHandle());\n        if (directShareAppPredictor == null) {\n            return;\n        }\n        if (!(targetInfo instanceof ChooserTargetInfo)) {\n            return;\n        }\n        ChooserTarget chooserTarget = ((ChooserTargetInfo) targetInfo).getChooserTarget();\n        AppTarget appTarget = null;\n        if (mDirectShareAppTargetCache != null) {\n            appTarget = mDirectShareAppTargetCache.get(chooserTarget);\n        }\n        // This is a direct share click that was provided by the APS\n        if (appTarget != null) {\n            directShareAppPredictor.notifyAppTargetEvent(\n                    new AppTargetEvent.Builder(appTarget, AppTargetEvent.ACTION_LAUNCH)\n                        .setLaunchLocation(LAUNCH_LOCATION_DIRECT_SHARE)\n                        .build());\n        }\n    }\n\n    @Nullable\n    private AppPredictor createAppPredictor(UserHandle userHandle) {\n        if (!mIsAppPredictorComponentAvailable) {\n            return null;\n        }\n\n        if (getPersonalProfileUserHandle().equals(userHandle)) {\n            if (mPersonalAppPredictor != null) {\n                return mPersonalAppPredictor;\n            }\n        } else {\n            if (mWorkAppPredictor != null) {\n                return mWorkAppPredictor;\n            }\n        }\n\n        // TODO(b/148230574): Currently AppPredictor fetches only the same-profile app targets.\n        // Make AppPredictor work cross-profile.\n        Context contextAsUser = createContextAsUser(userHandle, 0 /* flags */);\n        final IntentFilter filter = getTargetIntentFilter();\n        Bundle extras = new Bundle();\n        extras.putParcelable(APP_PREDICTION_INTENT_FILTER_KEY, filter);\n        populateTextContent(extras);\n        AppPredictionContext appPredictionContext = new AppPredictionContext.Builder(contextAsUser)\n            .setUiSurface(APP_PREDICTION_SHARE_UI_SURFACE)\n            .setPredictedTargetCount(APP_PREDICTION_SHARE_TARGET_QUERY_PACKAGE_LIMIT)\n            .setExtras(extras)\n            .build();\n        AppPredictionManager appPredictionManager =\n                contextAsUser\n                        .getSystemService(AppPredictionManager.class);\n        AppPredictor appPredictionSession = appPredictionManager.createAppPredictionSession(\n                appPredictionContext);\n        if (getPersonalProfileUserHandle().equals(userHandle)) {\n            mPersonalAppPredictor = appPredictionSession;\n        } else {\n            mWorkAppPredictor = appPredictionSession;\n        }\n        return appPredictionSession;\n    }\n\n    private void populateTextContent(Bundle extras) {\n        final Intent intent = getTargetIntent();\n        String sharedText = intent.getStringExtra(Intent.EXTRA_TEXT);\n        extras.putString(SHARED_TEXT_KEY, sharedText);\n    }\n\n    /**\n     * This will return an app predictor if it is enabled for direct share sorting\n     * and if one exists. Otherwise, it returns null.\n     * @param userHandle\n     */\n    @Nullable\n    private AppPredictor getAppPredictorForDirectShareIfEnabled(UserHandle userHandle) {\n        return ChooserFlags.USE_PREDICTION_MANAGER_FOR_DIRECT_TARGETS\n                && !ActivityManager.isLowRamDeviceStatic() ? createAppPredictor(userHandle) : null;\n    }\n\n    /**\n     * This will return an app predictor if it is enabled for share activity sorting\n     * and if one exists. Otherwise, it returns null.\n     */\n    @Nullable\n    private AppPredictor getAppPredictorForShareActivitiesIfEnabled(UserHandle userHandle) {\n        // We cannot use APS service when clone profile is present as APS service cannot sort\n        // cross profile targets as of now.\n        return USE_PREDICTION_MANAGER_FOR_SHARE_ACTIVITIES && getCloneProfileUserHandle() == null\n                ? createAppPredictor(userHandle) : null;\n    }\n\n    void onRefinementResult(TargetInfo selectedTarget, Intent matchingIntent) {\n        if (mRefinementResultReceiver != null) {\n            mRefinementResultReceiver.destroy();\n            mRefinementResultReceiver = null;\n        }\n        if (selectedTarget == null) {\n            Log.e(TAG, \"Refinement result intent did not match any known targets; canceling\");\n        } else if (!checkTargetSourceIntent(selectedTarget, matchingIntent)) {\n            Log.e(TAG, \"onRefinementResult: Selected target \" + selectedTarget\n                    + \" cannot match refined source intent \" + matchingIntent);\n        } else {\n            TargetInfo clonedTarget = selectedTarget.cloneFilledIn(matchingIntent, 0);\n            if (super.onTargetSelected(clonedTarget, false)) {\n                updateModelAndChooserCounts(clonedTarget);\n                finish();\n                return;\n            }\n        }\n        onRefinementCanceled();\n    }\n\n    void onRefinementCanceled() {\n        if (mRefinementResultReceiver != null) {\n            mRefinementResultReceiver.destroy();\n            mRefinementResultReceiver = null;\n        }\n        finish();\n    }\n\n    boolean checkTargetSourceIntent(TargetInfo target, Intent matchingIntent) {\n        final List<Intent> targetIntents = target.getAllSourceIntents();\n        for (int i = 0, N = targetIntents.size(); i < N; i++) {\n            final Intent targetIntent = targetIntents.get(i);\n            if (targetIntent.filterEquals(matchingIntent)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Sort intents alphabetically based on display label.\n     */\n    static class AzInfoComparator implements Comparator<DisplayResolveInfo> {\n        Comparator<DisplayResolveInfo> mComparator;\n        AzInfoComparator(Context context) {\n            Collator collator = Collator\n                    .getInstance(context.getResources().getConfiguration().locale);\n            // Adding two stage comparator, first stage compares using displayLabel, next stage\n            //  compares using resolveInfo.userHandle\n            mComparator = Comparator.comparing(DisplayResolveInfo::getDisplayLabel, collator)\n                    .thenComparingInt(displayResolveInfo ->\n                            getResolveInfoUserHandle(\n                                    displayResolveInfo.getResolveInfo(),\n                                    // TODO: User resolveInfo.userHandle, once its available.\n                                    UserHandle.SYSTEM).getIdentifier());\n        }\n\n        @Override\n        public int compare(\n                DisplayResolveInfo lhsp, DisplayResolveInfo rhsp) {\n            return mComparator.compare(lhsp, rhsp);\n        }\n    }\n\n    protected MetricsLogger getMetricsLogger() {\n        if (mMetricsLogger == null) {\n            mMetricsLogger = new MetricsLogger();\n        }\n        return mMetricsLogger;\n    }\n\n    protected ChooserActivityLogger getChooserActivityLogger() {\n        if (mChooserActivityLogger == null) {\n            mChooserActivityLogger = new ChooserActivityLoggerImpl();\n        }\n        return mChooserActivityLogger;\n    }\n\n    public class ChooserListController extends ResolverListController {\n        public ChooserListController(Context context,\n                PackageManager pm,\n                Intent targetIntent,\n                String referrerPackageName,\n                int launchedFromUid,\n                UserHandle userId,\n                AbstractResolverComparator resolverComparator,\n                UserHandle queryIntentsAsUser) {\n            super(context, pm, targetIntent, referrerPackageName, launchedFromUid, userId,\n                    resolverComparator, queryIntentsAsUser);\n        }\n\n        @Override\n        boolean isComponentFiltered(ComponentName name) {\n            if (mFilteredComponentNames == null) {\n                return false;\n            }\n            for (ComponentName filteredComponentName : mFilteredComponentNames) {\n                if (name.equals(filteredComponentName)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        @Override\n        public boolean isComponentPinned(ComponentName name) {\n            return mPinnedSharedPrefs.getBoolean(name.flattenToString(), false);\n        }\n\n        @Override\n        public boolean isFixedAtTop(ComponentName name) {\n            return name != null && name.equals(getNearbySharingComponent())\n                    && shouldNearbyShareBeFirstInRankedRow();\n        }\n    }\n\n    @VisibleForTesting\n    public ChooserGridAdapter createChooserGridAdapter(Context context,\n            List<Intent> payloadIntents, Intent[] initialIntents, List<ResolveInfo> rList,\n            boolean filterLastUsed, UserHandle userHandle) {\n        ChooserListAdapter chooserListAdapter = createChooserListAdapter(context, payloadIntents,\n                initialIntents, rList, filterLastUsed, userHandle);\n        AppPredictor.Callback appPredictorCallback = createAppPredictorCallback(chooserListAdapter);\n        AppPredictor appPredictor = setupAppPredictorForUser(userHandle, appPredictorCallback);\n        chooserListAdapter.setAppPredictor(appPredictor);\n        chooserListAdapter.setAppPredictorCallback(appPredictorCallback);\n        return new ChooserGridAdapter(chooserListAdapter);\n    }\n\n    @VisibleForTesting\n    public ChooserListAdapter createChooserListAdapter(Context context,\n            List<Intent> payloadIntents,\n            Intent[] initialIntents,\n            List<ResolveInfo> rList,\n            boolean filterLastUsed,\n            UserHandle userHandle) {\n        UserHandle initialIntentsUserSpace = isLaunchedAsCloneProfile()\n                && userHandle.equals(getPersonalProfileUserHandle())\n                ? getCloneProfileUserHandle() : userHandle;\n        return new ChooserListAdapter(context, payloadIntents, initialIntents, rList,\n                filterLastUsed, createListController(userHandle), this,\n                this, context.getPackageManager(),\n                getChooserActivityLogger(), initialIntentsUserSpace);\n    }\n\n    @VisibleForTesting\n    protected ResolverListController createListController(UserHandle userHandle) {\n        AppPredictor appPredictor = getAppPredictorForShareActivitiesIfEnabled(userHandle);\n        AbstractResolverComparator resolverComparator;\n        if (appPredictor != null) {\n            resolverComparator = new AppPredictionServiceResolverComparator(this, getTargetIntent(),\n                    getReferrerPackageName(), appPredictor, userHandle, getChooserActivityLogger());\n        } else {\n            resolverComparator =\n                    new ResolverRankerServiceResolverComparator(\n                            this,\n                            getTargetIntent(),\n                            getReferrerPackageName(),\n                            null,\n                            getChooserActivityLogger(),\n                            getResolverRankerServiceUserHandleList(userHandle));\n        }\n\n        UserHandle queryIntentsUser = getQueryIntentsUser(userHandle);\n        return new ChooserListController(\n                this,\n                mPm,\n                getTargetIntent(),\n                getReferrerPackageName(),\n                mLaunchedFromUid,\n                userHandle,\n                resolverComparator,\n                queryIntentsUser == null ? userHandle : queryIntentsUser);\n    }\n\n    @VisibleForTesting\n    protected Bitmap loadThumbnail(Uri uri, Size size) {\n        if (uri == null || size == null) {\n            return null;\n        }\n\n        try {\n            return getContentResolver().loadThumbnail(uri, size, null);\n        } catch (IOException | NullPointerException | SecurityException ex) {\n            logContentPreviewWarning(uri);\n        }\n        return null;\n    }\n\n    static final class PlaceHolderTargetInfo extends NotSelectableTargetInfo {\n        public Drawable getDisplayIcon(Context context) {\n            AnimatedVectorDrawable avd = (AnimatedVectorDrawable)\n                    context.getDrawable(R.drawable.chooser_direct_share_icon_placeholder);\n            avd.start(); // Start animation after generation\n            return avd;\n        }\n    }\n\n    protected static final class EmptyTargetInfo extends NotSelectableTargetInfo {\n        public EmptyTargetInfo() {}\n\n        public Drawable getDisplayIcon(Context context) {\n            return null;\n        }\n    }\n\n    private void handleScroll(View view, int x, int y, int oldx, int oldy) {\n        if (mChooserMultiProfilePagerAdapter.getCurrentRootAdapter() != null) {\n            mChooserMultiProfilePagerAdapter.getCurrentRootAdapter().handleScroll(view, y, oldy);\n        }\n    }\n\n    /*\n     * Need to dynamically adjust how many icons can fit per row before we add them,\n     * which also means setting the correct offset to initially show the content\n     * preview area + 2 rows of targets\n     */\n    private void handleLayoutChange(View v, int left, int top, int right, int bottom, int oldLeft,\n            int oldTop, int oldRight, int oldBottom) {\n        if (mChooserMultiProfilePagerAdapter == null) {\n            return;\n        }\n        RecyclerView recyclerView = mChooserMultiProfilePagerAdapter.getActiveAdapterView();\n        ChooserGridAdapter gridAdapter = mChooserMultiProfilePagerAdapter.getCurrentRootAdapter();\n        // Skip height calculation if recycler view was scrolled to prevent it inaccurately\n        // calculating the height, as the logic below does not account for the scrolled offset.\n        if (gridAdapter == null || recyclerView == null\n                || recyclerView.computeVerticalScrollOffset() != 0) {\n            return;\n        }\n\n        final int availableWidth = right - left - v.getPaddingLeft() - v.getPaddingRight();\n        boolean isLayoutUpdated = gridAdapter.consumeLayoutRequest()\n                || gridAdapter.calculateChooserTargetWidth(availableWidth)\n                || recyclerView.getAdapter() == null\n                || availableWidth != mCurrAvailableWidth;\n\n        boolean insetsChanged = !Objects.equals(mLastAppliedInsets, mSystemWindowInsets);\n\n        if (isLayoutUpdated\n                || insetsChanged\n                || mLastNumberOfChildren != recyclerView.getChildCount()) {\n            mCurrAvailableWidth = availableWidth;\n            if (isLayoutUpdated) {\n                // It is very important we call setAdapter from here. Otherwise in some cases\n                // the resolver list doesn't get populated, such as b/150922090, b/150918223\n                // and b/150936654\n                recyclerView.setAdapter(gridAdapter);\n                ((GridLayoutManager) recyclerView.getLayoutManager()).setSpanCount(\n                        mMaxTargetsPerRow);\n\n                updateTabPadding();\n            }\n\n            UserHandle currentUserHandle = mChooserMultiProfilePagerAdapter.getCurrentUserHandle();\n            int currentProfile = getProfileForUser(currentUserHandle);\n            int initialProfile = findSelectedProfile();\n            if (currentProfile != initialProfile) {\n                return;\n            }\n\n            if (mLastNumberOfChildren == recyclerView.getChildCount() && !insetsChanged) {\n                return;\n            }\n\n            getMainThreadHandler().post(() -> {\n                if (mResolverDrawerLayout == null || gridAdapter == null) {\n                    return;\n                }\n                int offset = calculateDrawerOffset(top, bottom, recyclerView, gridAdapter);\n                mResolverDrawerLayout.setCollapsibleHeightReserved(offset);\n                mEnterTransitionAnimationDelegate.markOffsetCalculated();\n                mLastAppliedInsets = mSystemWindowInsets;\n            });\n        }\n    }\n\n    private int calculateDrawerOffset(\n            int top, int bottom, RecyclerView recyclerView, ChooserGridAdapter gridAdapter) {\n\n        final int bottomInset = mSystemWindowInsets != null\n                ? mSystemWindowInsets.bottom : 0;\n        int offset = bottomInset;\n        int rowsToShow = gridAdapter.getSystemRowCount()\n                + gridAdapter.getProfileRowCount()\n                + gridAdapter.getServiceTargetRowCount()\n                + gridAdapter.getCallerAndRankedTargetRowCount();\n\n        // then this is most likely not a SEND_* action, so check\n        // the app target count\n        if (rowsToShow == 0) {\n            rowsToShow = gridAdapter.getRowCount();\n        }\n\n        // still zero? then use a default height and leave, which\n        // can happen when there are no targets to show\n        if (rowsToShow == 0 && !shouldShowStickyContentPreview()) {\n            offset += getResources().getDimensionPixelSize(\n                    R.dimen.chooser_max_collapsed_height);\n            return offset;\n        }\n\n        View stickyContentPreview = findViewById(R.id.content_preview_container);\n        if (shouldShowStickyContentPreview() && isStickyContentPreviewShowing()) {\n            offset += stickyContentPreview.getHeight();\n        }\n\n        if (shouldShowTabs()) {\n            offset += findViewById(R.id.tabs).getHeight();\n        }\n\n        if (recyclerView.getVisibility() == View.VISIBLE) {\n            int directShareHeight = 0;\n            rowsToShow = Math.min(4, rowsToShow);\n            boolean shouldShowExtraRow = shouldShowExtraRow(rowsToShow);\n            mLastNumberOfChildren = recyclerView.getChildCount();\n            for (int i = 0, childCount = recyclerView.getChildCount();\n                    i < childCount && rowsToShow > 0; i++) {\n                View child = recyclerView.getChildAt(i);\n                if (((GridLayoutManager.LayoutParams)\n                        child.getLayoutParams()).getSpanIndex() != 0) {\n                    continue;\n                }\n                int height = child.getHeight();\n                offset += height;\n                if (shouldShowExtraRow) {\n                    offset += height;\n                }\n\n                if (gridAdapter.getTargetType(\n                        recyclerView.getChildAdapterPosition(child))\n                        == ChooserListAdapter.TARGET_SERVICE) {\n                    directShareHeight = height;\n                }\n                rowsToShow--;\n            }\n\n            boolean isExpandable = getResources().getConfiguration().orientation\n                    == Configuration.ORIENTATION_PORTRAIT && !isInMultiWindowMode();\n            if (directShareHeight != 0 && shouldShowContentPreview()\n                    && isExpandable) {\n                // make sure to leave room for direct share 4->8 expansion\n                int requiredExpansionHeight =\n                        (int) (directShareHeight / DIRECT_SHARE_EXPANSION_RATE);\n                int topInset = mSystemWindowInsets != null ? mSystemWindowInsets.top : 0;\n                int minHeight = bottom - top - mResolverDrawerLayout.getAlwaysShowHeight()\n                        - requiredExpansionHeight - topInset - bottomInset;\n\n                offset = Math.min(offset, minHeight);\n            }\n        } else {\n            ViewGroup currentEmptyStateView = getActiveEmptyStateView();\n            if (currentEmptyStateView.getVisibility() == View.VISIBLE) {\n                offset += currentEmptyStateView.getHeight();\n            }\n        }\n\n        return Math.min(offset, bottom - top);\n    }\n\n    /**\n     * If we have a tabbed view and are showing 1 row in the current profile and an empty\n     * state screen in the other profile, to prevent cropping of the empty state screen we show\n     * a second row in the current profile.\n     */\n    private boolean shouldShowExtraRow(int rowsToShow) {\n        return shouldShowTabs()\n                && rowsToShow == 1\n                && mChooserMultiProfilePagerAdapter.shouldShowEmptyStateScreen(\n                        mChooserMultiProfilePagerAdapter.getInactiveListAdapter());\n    }\n\n    /**\n     * Returns {@link #PROFILE_WORK}, if the given user handle matches work user handle.\n     * Returns {@link #PROFILE_PERSONAL}, otherwise.\n     **/\n    private int getProfileForUser(UserHandle currentUserHandle) {\n        if (currentUserHandle.equals(getWorkProfileUserHandle())) {\n            return PROFILE_WORK;\n        }\n        // We return personal profile, as it is the default when there is no work profile, personal\n        // profile represents rootUser, clonedUser & secondaryUser, covering all use cases.\n        return PROFILE_PERSONAL;\n    }\n\n    private ViewGroup getActiveEmptyStateView() {\n        int currentPage = mChooserMultiProfilePagerAdapter.getCurrentPage();\n        return mChooserMultiProfilePagerAdapter.getItem(currentPage).getEmptyStateView();\n    }\n\n    static class BaseChooserTargetComparator implements Comparator<ChooserTarget> {\n        @Override\n        public int compare(ChooserTarget lhs, ChooserTarget rhs) {\n            // Descending order\n            return (int) Math.signum(rhs.getScore() - lhs.getScore());\n        }\n    }\n\n    @Override // ResolverListCommunicator\n    public void onHandlePackagesChanged(ResolverListAdapter listAdapter) {\n        mChooserMultiProfilePagerAdapter.getActiveListAdapter().notifyDataSetChanged();\n        super.onHandlePackagesChanged(listAdapter);\n    }\n\n    @Override // SelectableTargetInfoCommunicator\n    public ActivityInfoPresentationGetter makePresentationGetter(ActivityInfo info) {\n        return mChooserMultiProfilePagerAdapter.getActiveListAdapter().makePresentationGetter(info);\n    }\n\n    @Override // SelectableTargetInfoCommunicator\n    public Intent getReferrerFillInIntent() {\n        return mReferrerFillInIntent;\n    }\n\n    @Override // ChooserListCommunicator\n    public int getMaxRankedTargets() {\n        return mMaxTargetsPerRow;\n    }\n\n    @Override // ChooserListCommunicator\n    public void sendListViewUpdateMessage(UserHandle userHandle) {\n        Message msg = Message.obtain();\n        msg.what = ChooserHandler.LIST_VIEW_UPDATE_MESSAGE;\n        msg.obj = userHandle;\n        mChooserHandler.sendMessageDelayed(msg, mListViewUpdateDelayMs);\n    }\n\n    @Override\n    public void onListRebuilt(ResolverListAdapter listAdapter, boolean rebuildComplete) {\n        setupScrollListener();\n        maybeSetupGlobalLayoutListener();\n\n        ChooserListAdapter chooserListAdapter = (ChooserListAdapter) listAdapter;\n        if (chooserListAdapter.getUserHandle()\n                .equals(mChooserMultiProfilePagerAdapter.getCurrentUserHandle())) {\n            mChooserMultiProfilePagerAdapter.getActiveAdapterView()\n                    .setAdapter(mChooserMultiProfilePagerAdapter.getCurrentRootAdapter());\n            mChooserMultiProfilePagerAdapter\n                    .setupListAdapter(mChooserMultiProfilePagerAdapter.getCurrentPage());\n        }\n\n        if (chooserListAdapter.mDisplayList == null\n                || chooserListAdapter.mDisplayList.isEmpty()) {\n            chooserListAdapter.notifyDataSetChanged();\n        } else {\n            chooserListAdapter.updateAlphabeticalList();\n        }\n\n        if (rebuildComplete) {\n            getChooserActivityLogger().logSharesheetAppLoadComplete();\n            maybeQueryAdditionalPostProcessingTargets(chooserListAdapter);\n            mLatencyTracker.onActionEnd(ACTION_LOAD_SHARE_SHEET);\n        }\n    }\n\n    private void maybeQueryAdditionalPostProcessingTargets(ChooserListAdapter chooserListAdapter) {\n        // don't support direct share on low ram devices\n        if (ActivityManager.isLowRamDeviceStatic()) {\n            return;\n        }\n\n        // no need to query direct share for work profile when its locked or disabled\n        if (!shouldQueryShortcutManager(chooserListAdapter.getUserHandle())) {\n            return;\n        }\n\n        if (ChooserFlags.USE_PREDICTION_MANAGER_FOR_DIRECT_TARGETS) {\n            if (DEBUG) {\n                Log.d(TAG, \"querying direct share targets from ShortcutManager\");\n            }\n\n            queryDirectShareTargets(chooserListAdapter, false);\n        }\n    }\n\n    @VisibleForTesting\n    protected boolean isUserRunning(UserHandle userHandle) {\n        UserManager userManager = getSystemService(UserManager.class);\n        return userManager.isUserRunning(userHandle);\n    }\n\n    @VisibleForTesting\n    protected boolean isUserUnlocked(UserHandle userHandle) {\n        UserManager userManager = getSystemService(UserManager.class);\n        return userManager.isUserUnlocked(userHandle);\n    }\n\n    @VisibleForTesting\n    protected boolean isQuietModeEnabled(UserHandle userHandle) {\n        UserManager userManager = getSystemService(UserManager.class);\n        return userManager.isQuietModeEnabled(userHandle);\n    }\n\n    private void setupScrollListener() {\n        if (mResolverDrawerLayout == null) {\n            return;\n        }\n        int elevatedViewResId = shouldShowTabs() ? R.id.tabs : R.id.chooser_header;\n        final View elevatedView = mResolverDrawerLayout.findViewById(elevatedViewResId);\n        final float defaultElevation = elevatedView.getElevation();\n        final float chooserHeaderScrollElevation =\n                getResources().getDimensionPixelSize(R.dimen.chooser_header_scroll_elevation);\n        mChooserMultiProfilePagerAdapter.getActiveAdapterView().addOnScrollListener(\n                new RecyclerView.OnScrollListener() {\n                    public void onScrollStateChanged(RecyclerView view, int scrollState) {\n                        if (scrollState == RecyclerView.SCROLL_STATE_IDLE) {\n                            if (mScrollStatus == SCROLL_STATUS_SCROLLING_VERTICAL) {\n                                mScrollStatus = SCROLL_STATUS_IDLE;\n                                setHorizontalScrollingEnabled(true);\n                            }\n                        } else if (scrollState == RecyclerView.SCROLL_STATE_DRAGGING) {\n                            if (mScrollStatus == SCROLL_STATUS_IDLE) {\n                                mScrollStatus = SCROLL_STATUS_SCROLLING_VERTICAL;\n                                setHorizontalScrollingEnabled(false);\n                            }\n                        }\n                    }\n\n                    public void onScrolled(RecyclerView view, int dx, int dy) {\n                        if (view.getChildCount() > 0) {\n                            View child = view.getLayoutManager().findViewByPosition(0);\n                            if (child == null || child.getTop() < 0) {\n                                elevatedView.setElevation(chooserHeaderScrollElevation);\n                                return;\n                            }\n                        }\n\n                        elevatedView.setElevation(defaultElevation);\n                    }\n                });\n    }\n\n    private void maybeSetupGlobalLayoutListener() {\n        if (shouldShowTabs()) {\n            return;\n        }\n        final View recyclerView = mChooserMultiProfilePagerAdapter.getActiveAdapterView();\n        recyclerView.getViewTreeObserver()\n                .addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {\n                    @Override\n                    public void onGlobalLayout() {\n                        // Fixes an issue were the accessibility border disappears on list creation.\n                        recyclerView.getViewTreeObserver().removeOnGlobalLayoutListener(this);\n                        final TextView titleView = findViewById(R.id.title);\n                        if (titleView != null) {\n                            titleView.setFocusable(true);\n                            titleView.setFocusableInTouchMode(true);\n                            titleView.requestFocus();\n                            titleView.requestAccessibilityFocus();\n                        }\n                    }\n                });\n    }\n\n    @Override // ChooserListCommunicator\n    public boolean isSendAction(Intent targetIntent) {\n        if (targetIntent == null) {\n            return false;\n        }\n\n        String action = targetIntent.getAction();\n        if (action == null) {\n            return false;\n        }\n\n        if (Intent.ACTION_SEND.equals(action) || Intent.ACTION_SEND_MULTIPLE.equals(action)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * The sticky content preview is shown only when we have a tabbed view. It's shown above\n     * the tabs so it is not part of the scrollable list. If we are not in tabbed view,\n     * we instead show the content preview as a regular list item.\n     */\n    private boolean shouldShowStickyContentPreview() {\n        return shouldShowStickyContentPreviewNoOrientationCheck()\n                && !getResources().getBoolean(R.bool.resolver_landscape_phone);\n    }\n\n    private boolean shouldShowStickyContentPreviewNoOrientationCheck() {\n        return shouldShowTabs()\n                && (mMultiProfilePagerAdapter.getListAdapterForUserHandle(\n                        UserHandle.of(UserHandle.myUserId())).getCount() > 0\n                    || shouldShowContentPreviewWhenEmpty())\n                && shouldShowContentPreview();\n    }\n\n    /**\n     * This method could be used to override the default behavior when we hide the preview area\n     * when the current tab doesn't have any items.\n     *\n     * @return true if we want to show the content preview area even if the tab for the current\n     *         user is empty\n     */\n    protected boolean shouldShowContentPreviewWhenEmpty() {\n        return false;\n    }\n\n    /**\n     * @return true if we want to show the content preview area\n     */\n    protected boolean shouldShowContentPreview() {\n        return isSendAction(getTargetIntent());\n    }\n\n    private void updateStickyContentPreview() {\n        if (shouldShowStickyContentPreviewNoOrientationCheck()) {\n            // The sticky content preview is only shown when we show the work and personal tabs.\n            // We don't show it in landscape as otherwise there is no room for scrolling.\n            // If the sticky content preview will be shown at some point with orientation change,\n            // then always preload it to avoid subsequent resizing of the share sheet.\n            ViewGroup contentPreviewContainer = findViewById(R.id.content_preview_container);\n            if (contentPreviewContainer.getChildCount() == 0) {\n                ViewGroup contentPreviewView = createContentPreviewView(contentPreviewContainer);\n                contentPreviewContainer.addView(contentPreviewView);\n            }\n        }\n        if (shouldShowStickyContentPreview()) {\n            showStickyContentPreview();\n        } else {\n            hideStickyContentPreview();\n        }\n    }\n\n    private void showStickyContentPreview() {\n        if (isStickyContentPreviewShowing()) {\n            return;\n        }\n        ViewGroup contentPreviewContainer = findViewById(R.id.content_preview_container);\n        contentPreviewContainer.setVisibility(View.VISIBLE);\n    }\n\n    private boolean isStickyContentPreviewShowing() {\n        ViewGroup contentPreviewContainer = findViewById(R.id.content_preview_container);\n        return contentPreviewContainer.getVisibility() == View.VISIBLE;\n    }\n\n    private void hideStickyContentPreview() {\n        if (!isStickyContentPreviewShowing()) {\n            return;\n        }\n        ViewGroup contentPreviewContainer = findViewById(R.id.content_preview_container);\n        contentPreviewContainer.setVisibility(View.GONE);\n    }\n\n    private void logActionShareWithPreview() {\n        Intent targetIntent = getTargetIntent();\n        int previewType = findPreferredContentPreview(targetIntent, getContentResolver());\n        getMetricsLogger().write(new LogMaker(MetricsEvent.ACTION_SHARE_WITH_PREVIEW)\n                .setSubtype(previewType));\n    }\n\n    private void startFinishAnimation() {\n        View rootView = findRootView();\n        if (rootView != null) {\n            rootView.startAnimation(new FinishAnimation(this, rootView));\n        }\n    }\n\n    private boolean maybeCancelFinishAnimation() {\n        View rootView = findRootView();\n        Animation animation = rootView == null ? null : rootView.getAnimation();\n        if (animation instanceof FinishAnimation) {\n            boolean hasEnded = animation.hasEnded();\n            animation.cancel();\n            rootView.clearAnimation();\n            return !hasEnded;\n        }\n        return false;\n    }\n\n    private View findRootView() {\n        if (mContentView == null) {\n            mContentView = findViewById(android.R.id.content);\n        }\n        return mContentView;\n    }\n\n    abstract static class ViewHolderBase extends RecyclerView.ViewHolder {\n        private int mViewType;\n\n        ViewHolderBase(View itemView, int viewType) {\n            super(itemView);\n            this.mViewType = viewType;\n        }\n\n        int getViewType() {\n            return mViewType;\n        }\n    }\n\n    /**\n     * Used to bind types of individual item including\n     * {@link ChooserGridAdapter#VIEW_TYPE_NORMAL},\n     * {@link ChooserGridAdapter#VIEW_TYPE_CONTENT_PREVIEW},\n     * {@link ChooserGridAdapter#VIEW_TYPE_PROFILE},\n     * and {@link ChooserGridAdapter#VIEW_TYPE_AZ_LABEL}.\n     */\n    final class ItemViewHolder extends ViewHolderBase {\n        ResolverListAdapter.ViewHolder mWrappedViewHolder;\n        int mListPosition = ChooserListAdapter.NO_POSITION;\n\n        ItemViewHolder(View itemView, boolean isClickable, int viewType) {\n            super(itemView, viewType);\n            mWrappedViewHolder = new ResolverListAdapter.ViewHolder(itemView);\n            if (isClickable) {\n                itemView.setOnClickListener(v -> startSelected(mListPosition,\n                        false/* always */, true/* filterd */));\n\n                itemView.setOnLongClickListener(v -> {\n                    final TargetInfo ti = mChooserMultiProfilePagerAdapter.getActiveListAdapter()\n                            .targetInfoForPosition(mListPosition, /* filtered */ true);\n\n                    // This should always be the case for ItemViewHolder, check for validity\n                    if (ti instanceof DisplayResolveInfo && shouldShowTargetDetails(ti)) {\n                        showTargetDetails((DisplayResolveInfo) ti);\n                    }\n                    return true;\n                });\n            }\n        }\n    }\n\n    private boolean shouldShowTargetDetails(TargetInfo ti) {\n        ComponentName nearbyShare = getNearbySharingComponent();\n        //  Suppress target details for nearby share to hide pin/unpin action\n        boolean isNearbyShare = nearbyShare != null && nearbyShare.equals(\n                ti.getResolvedComponentName()) && shouldNearbyShareBeFirstInRankedRow();\n        return ti instanceof SelectableTargetInfo\n                || (ti instanceof DisplayResolveInfo && !isNearbyShare);\n    }\n\n    /**\n     * Add a footer to the list, to support scrolling behavior below the navbar.\n     */\n    static final class FooterViewHolder extends ViewHolderBase {\n        FooterViewHolder(View itemView, int viewType) {\n            super(itemView, viewType);\n        }\n    }\n\n    /**\n     * Intentionally override the {@link ResolverActivity} implementation as we only need that\n     * implementation for the intent resolver case.\n     */\n    @Override\n    public void onButtonClick(View v) {}\n\n    /**\n     * Intentionally override the {@link ResolverActivity} implementation as we only need that\n     * implementation for the intent resolver case.\n     */\n    @Override\n    protected void resetButtonBar() {}\n\n    @Override\n    protected String getMetricsCategory() {\n        return METRICS_CATEGORY_CHOOSER;\n    }\n\n    @Override\n    protected void onProfileTabSelected() {\n        ChooserGridAdapter currentRootAdapter =\n                mChooserMultiProfilePagerAdapter.getCurrentRootAdapter();\n        currentRootAdapter.updateDirectShareExpansion();\n        // This fixes an edge case where after performing a variety of gestures, vertical scrolling\n        // ends up disabled. That's because at some point the old tab's vertical scrolling is\n        // disabled and the new tab's is enabled. For context, see b/159997845\n        setVerticalScrollEnabled(true);\n        if (mResolverDrawerLayout != null) {\n            mResolverDrawerLayout.scrollNestedScrollableChildBackToTop();\n        }\n    }\n\n    @Override\n    protected WindowInsets onApplyWindowInsets(View v, WindowInsets insets) {\n        if (shouldShowTabs()) {\n            mChooserMultiProfilePagerAdapter\n                    .setEmptyStateBottomOffset(insets.getSystemWindowInsetBottom());\n            mChooserMultiProfilePagerAdapter.setupContainerPadding(\n                    getActiveEmptyStateView().findViewById(R.id.resolver_empty_state_container));\n        }\n\n        WindowInsets result = super.onApplyWindowInsets(v, insets);\n        if (mResolverDrawerLayout != null) {\n            mResolverDrawerLayout.requestLayout();\n        }\n        return result;\n    }\n\n    private void setHorizontalScrollingEnabled(boolean enabled) {\n        ResolverViewPager viewPager = findViewById(R.id.profile_pager);\n        viewPager.setSwipingEnabled(enabled);\n    }\n\n    private void setVerticalScrollEnabled(boolean enabled) {\n        ChooserGridLayoutManager layoutManager =\n                (ChooserGridLayoutManager) mChooserMultiProfilePagerAdapter.getActiveAdapterView()\n                        .getLayoutManager();\n        layoutManager.setVerticalScrollEnabled(enabled);\n    }\n\n    @Override\n    void onHorizontalSwipeStateChanged(int state) {\n        if (state == ViewPager.SCROLL_STATE_DRAGGING) {\n            if (mScrollStatus == SCROLL_STATUS_IDLE) {\n                mScrollStatus = SCROLL_STATUS_SCROLLING_HORIZONTAL;\n                setVerticalScrollEnabled(false);\n            }\n        } else if (state == ViewPager.SCROLL_STATE_IDLE) {\n            if (mScrollStatus == SCROLL_STATUS_SCROLLING_HORIZONTAL) {\n                mScrollStatus = SCROLL_STATUS_IDLE;\n                setVerticalScrollEnabled(true);\n            }\n        }\n    }\n\n    /**\n     * Adapter for all types of items and targets in ShareSheet.\n     * Note that ranked sections like Direct Share - while appearing grid-like - are handled on the\n     * row level by this adapter but not on the item level. Individual targets within the row are\n     * handled by {@link ChooserListAdapter}\n     */\n    @VisibleForTesting\n    public final class ChooserGridAdapter extends RecyclerView.Adapter<RecyclerView.ViewHolder> {\n        private ChooserListAdapter mChooserListAdapter;\n        private final LayoutInflater mLayoutInflater;\n\n        private DirectShareViewHolder mDirectShareViewHolder;\n        private int mChooserTargetWidth = 0;\n        private boolean mShowAzLabelIfPoss;\n        private boolean mLayoutRequested = false;\n\n        private int mFooterHeight = 0;\n\n        private static final int VIEW_TYPE_DIRECT_SHARE = 0;\n        private static final int VIEW_TYPE_NORMAL = 1;\n        private static final int VIEW_TYPE_CONTENT_PREVIEW = 2;\n        private static final int VIEW_TYPE_PROFILE = 3;\n        private static final int VIEW_TYPE_AZ_LABEL = 4;\n        private static final int VIEW_TYPE_CALLER_AND_RANK = 5;\n        private static final int VIEW_TYPE_FOOTER = 6;\n\n        private static final int NUM_EXPANSIONS_TO_HIDE_AZ_LABEL = 20;\n\n        ChooserGridAdapter(ChooserListAdapter wrappedAdapter) {\n            super();\n            mChooserListAdapter = wrappedAdapter;\n            mLayoutInflater = LayoutInflater.from(ChooserActivity.this);\n\n            mShowAzLabelIfPoss = getNumSheetExpansions() < NUM_EXPANSIONS_TO_HIDE_AZ_LABEL;\n\n            wrappedAdapter.registerDataSetObserver(new DataSetObserver() {\n                @Override\n                public void onChanged() {\n                    super.onChanged();\n                    notifyDataSetChanged();\n                }\n\n                @Override\n                public void onInvalidated() {\n                    super.onInvalidated();\n                    notifyDataSetChanged();\n                }\n            });\n        }\n\n        public void setFooterHeight(int height) {\n            mFooterHeight = height;\n        }\n\n        /**\n         * Calculate the chooser target width to maximize space per item\n         *\n         * @param width The new row width to use for recalculation\n         * @return true if the view width has changed\n         */\n        public boolean calculateChooserTargetWidth(int width) {\n            if (width == 0) {\n                return false;\n            }\n\n            // Limit width to the maximum width of the chooser activity\n            int maxWidth = getResources().getDimensionPixelSize(R.dimen.chooser_width);\n            width = Math.min(maxWidth, width);\n\n            int newWidth = width / mMaxTargetsPerRow;\n            if (newWidth != mChooserTargetWidth) {\n                mChooserTargetWidth = newWidth;\n                return true;\n            }\n\n            return false;\n        }\n\n        /**\n         * Hides the list item content preview.\n         * <p>Not to be confused with the sticky content preview which is above the\n         * personal and work tabs.\n         */\n        public void hideContentPreview() {\n            mLayoutRequested = true;\n            notifyDataSetChanged();\n        }\n\n        public boolean consumeLayoutRequest() {\n            boolean oldValue = mLayoutRequested;\n            mLayoutRequested = false;\n            return oldValue;\n        }\n\n        public int getRowCount() {\n            return (int) (\n                    getSystemRowCount()\n                            + getProfileRowCount()\n                            + getServiceTargetRowCount()\n                            + getCallerAndRankedTargetRowCount()\n                            + getAzLabelRowCount()\n                            + Math.ceil(\n                            (float) mChooserListAdapter.getAlphaTargetCount()\n                                    / mMaxTargetsPerRow)\n            );\n        }\n\n        /**\n         * Whether the \"system\" row of targets is displayed.\n         * This area includes the content preview (if present) and action row.\n         */\n        public int getSystemRowCount() {\n            // For the tabbed case we show the sticky content preview above the tabs,\n            // please refer to shouldShowStickyContentPreview\n            if (shouldShowTabs()) {\n                return 0;\n            }\n\n            if (!shouldShowContentPreview()) {\n                return 0;\n            }\n\n            if (mChooserListAdapter == null || mChooserListAdapter.getCount() == 0) {\n                return 0;\n            }\n\n            return 1;\n        }\n\n        public int getProfileRowCount() {\n            if (shouldShowTabs()) {\n                return 0;\n            }\n            return mChooserListAdapter.getOtherProfile() == null ? 0 : 1;\n        }\n\n        public int getFooterRowCount() {\n            return 1;\n        }\n\n        public int getCallerAndRankedTargetRowCount() {\n            return (int) Math.ceil(\n                    ((float) mChooserListAdapter.getCallerTargetCount()\n                            + mChooserListAdapter.getRankedTargetCount()) / mMaxTargetsPerRow);\n        }\n\n        // There can be at most one row in the listview, that is internally\n        // a ViewGroup with 2 rows\n        public int getServiceTargetRowCount() {\n            if (shouldShowContentPreview()\n                    && !ActivityManager.isLowRamDeviceStatic()) {\n                return 1;\n            }\n            return 0;\n        }\n\n        public int getAzLabelRowCount() {\n            // Only show a label if the a-z list is showing\n            return (mShowAzLabelIfPoss && mChooserListAdapter.getAlphaTargetCount() > 0) ? 1 : 0;\n        }\n\n        @Override\n        public int getItemCount() {\n            return (int) (\n                    getSystemRowCount()\n                            + getProfileRowCount()\n                            + getServiceTargetRowCount()\n                            + getCallerAndRankedTargetRowCount()\n                            + getAzLabelRowCount()\n                            + mChooserListAdapter.getAlphaTargetCount()\n                            + getFooterRowCount()\n            );\n        }\n\n        @Override\n        public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n            switch (viewType) {\n                case VIEW_TYPE_CONTENT_PREVIEW:\n                    return new ItemViewHolder(createContentPreviewView(parent), false, viewType);\n                case VIEW_TYPE_PROFILE:\n                    return new ItemViewHolder(createProfileView(parent), false, viewType);\n                case VIEW_TYPE_AZ_LABEL:\n                    return new ItemViewHolder(createAzLabelView(parent), false, viewType);\n                case VIEW_TYPE_NORMAL:\n                    return new ItemViewHolder(\n                            mChooserListAdapter.createView(parent), true, viewType);\n                case VIEW_TYPE_DIRECT_SHARE:\n                case VIEW_TYPE_CALLER_AND_RANK:\n                    return createItemGroupViewHolder(viewType, parent);\n                case VIEW_TYPE_FOOTER:\n                    Space sp = new Space(parent.getContext());\n                    sp.setLayoutParams(new RecyclerView.LayoutParams(\n                            LayoutParams.MATCH_PARENT, mFooterHeight));\n                    return new FooterViewHolder(sp, viewType);\n                default:\n                    // Since we catch all possible viewTypes above, no chance this is being called.\n                    return null;\n            }\n        }\n\n        @Override\n        public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) {\n            int viewType = ((ViewHolderBase) holder).getViewType();\n            switch (viewType) {\n                case VIEW_TYPE_DIRECT_SHARE:\n                case VIEW_TYPE_CALLER_AND_RANK:\n                    bindItemGroupViewHolder(position, (ItemGroupViewHolder) holder);\n                    break;\n                case VIEW_TYPE_NORMAL:\n                    bindItemViewHolder(position, (ItemViewHolder) holder);\n                    break;\n                default:\n            }\n        }\n\n        @Override\n        public int getItemViewType(int position) {\n            int count;\n\n            int countSum = (count = getSystemRowCount());\n            if (count > 0 && position < countSum) return VIEW_TYPE_CONTENT_PREVIEW;\n\n            countSum += (count = getProfileRowCount());\n            if (count > 0 && position < countSum) return VIEW_TYPE_PROFILE;\n\n            countSum += (count = getServiceTargetRowCount());\n            if (count > 0 && position < countSum) return VIEW_TYPE_DIRECT_SHARE;\n\n            countSum += (count = getCallerAndRankedTargetRowCount());\n            if (count > 0 && position < countSum) return VIEW_TYPE_CALLER_AND_RANK;\n\n            countSum += (count = getAzLabelRowCount());\n            if (count > 0 && position < countSum) return VIEW_TYPE_AZ_LABEL;\n\n            if (position == getItemCount() - 1) return VIEW_TYPE_FOOTER;\n\n            return VIEW_TYPE_NORMAL;\n        }\n\n        public int getTargetType(int position) {\n            return mChooserListAdapter.getPositionTargetType(getListPosition(position));\n        }\n\n        private View createProfileView(ViewGroup parent) {\n            View profileRow = mLayoutInflater.inflate(R.layout.chooser_profile_row, parent, false);\n            mProfileView = profileRow.findViewById(R.id.profile_button);\n            mProfileView.setOnClickListener(ChooserActivity.this::onProfileClick);\n            updateProfileViewButton();\n            return profileRow;\n        }\n\n        private View createAzLabelView(ViewGroup parent) {\n            return mLayoutInflater.inflate(R.layout.chooser_az_label_row, parent, false);\n        }\n\n        private ItemGroupViewHolder loadViewsIntoGroup(ItemGroupViewHolder holder) {\n            final int spec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);\n            final int exactSpec = MeasureSpec.makeMeasureSpec(mChooserTargetWidth,\n                    MeasureSpec.EXACTLY);\n            int columnCount = holder.getColumnCount();\n\n            final boolean isDirectShare = holder instanceof DirectShareViewHolder;\n\n            for (int i = 0; i < columnCount; i++) {\n                final View v = mChooserListAdapter.createView(holder.getRowByIndex(i));\n                final int column = i;\n                v.setOnClickListener(new OnClickListener() {\n                    @Override\n                    public void onClick(View v) {\n                        startSelected(holder.getItemIndex(column), false, true);\n                    }\n                });\n\n                // Show menu for both direct share and app share targets after long click.\n                v.setOnLongClickListener(v1 -> {\n                    TargetInfo ti = mChooserListAdapter.targetInfoForPosition(\n                            holder.getItemIndex(column), true);\n                    if (shouldShowTargetDetails(ti)) {\n                        showTargetDetails(ti);\n                    }\n                    return true;\n                });\n\n                holder.addView(i, v);\n\n                // Force Direct Share to be 2 lines and auto-wrap to second line via hoz scroll =\n                // false. TextView#setHorizontallyScrolling must be reset after #setLines. Must be\n                // done before measuring.\n                if (isDirectShare) {\n                    final ViewHolder vh = (ViewHolder) v.getTag();\n                    vh.text.setLines(2);\n                    vh.text.setHorizontallyScrolling(false);\n                    vh.text2.setVisibility(View.GONE);\n                }\n\n                // Force height to be a given so we don't have visual disruption during scaling.\n                v.measure(exactSpec, spec);\n                setViewBounds(v, v.getMeasuredWidth(), v.getMeasuredHeight());\n            }\n\n            final ViewGroup viewGroup = holder.getViewGroup();\n\n            // Pre-measure and fix height so we can scale later.\n            holder.measure();\n            setViewBounds(viewGroup, LayoutParams.MATCH_PARENT, holder.getMeasuredRowHeight());\n\n            if (isDirectShare) {\n                DirectShareViewHolder dsvh = (DirectShareViewHolder) holder;\n                setViewBounds(dsvh.getRow(0), LayoutParams.MATCH_PARENT, dsvh.getMinRowHeight());\n                setViewBounds(dsvh.getRow(1), LayoutParams.MATCH_PARENT, dsvh.getMinRowHeight());\n            }\n\n            viewGroup.setTag(holder);\n            return holder;\n        }\n\n        private void setViewBounds(View view, int widthPx, int heightPx) {\n            LayoutParams lp = view.getLayoutParams();\n            if (lp == null) {\n                lp = new LayoutParams(widthPx, heightPx);\n                view.setLayoutParams(lp);\n            } else {\n                lp.height = heightPx;\n                lp.width = widthPx;\n            }\n        }\n\n        ItemGroupViewHolder createItemGroupViewHolder(int viewType, ViewGroup parent) {\n            if (viewType == VIEW_TYPE_DIRECT_SHARE) {\n                ViewGroup parentGroup = (ViewGroup) mLayoutInflater.inflate(\n                        R.layout.chooser_row_direct_share, parent, false);\n                ViewGroup row1 = (ViewGroup) mLayoutInflater.inflate(R.layout.chooser_row,\n                        parentGroup, false);\n                ViewGroup row2 = (ViewGroup) mLayoutInflater.inflate(R.layout.chooser_row,\n                        parentGroup, false);\n                parentGroup.addView(row1);\n                parentGroup.addView(row2);\n\n                mDirectShareViewHolder = new DirectShareViewHolder(parentGroup,\n                        Lists.newArrayList(row1, row2), mMaxTargetsPerRow, viewType,\n                        mChooserMultiProfilePagerAdapter::getActiveListAdapter);\n                loadViewsIntoGroup(mDirectShareViewHolder);\n\n                return mDirectShareViewHolder;\n            } else {\n                ViewGroup row = (ViewGroup) mLayoutInflater.inflate(R.layout.chooser_row, parent,\n                        false);\n                ItemGroupViewHolder holder =\n                        new SingleRowViewHolder(row, mMaxTargetsPerRow, viewType);\n                loadViewsIntoGroup(holder);\n\n                return holder;\n            }\n        }\n\n        /**\n         * Need to merge CALLER + ranked STANDARD into a single row and prevent a separator from\n         * showing on top of the AZ list if the AZ label is visible. All other types are placed into\n         * their own row as determined by their target type, and dividers are added in the list to\n         * separate each type.\n         */\n        int getRowType(int rowPosition) {\n            // Merge caller and ranked standard into a single row\n            int positionType = mChooserListAdapter.getPositionTargetType(rowPosition);\n            if (positionType == ChooserListAdapter.TARGET_CALLER) {\n                return ChooserListAdapter.TARGET_STANDARD;\n            }\n\n            // If an the A-Z label is shown, prevent a separator from appearing by making the A-Z\n            // row type the same as the suggestion row type\n            if (getAzLabelRowCount() > 0 && positionType == ChooserListAdapter.TARGET_STANDARD_AZ) {\n                return ChooserListAdapter.TARGET_STANDARD;\n            }\n\n            return positionType;\n        }\n\n        void bindItemViewHolder(int position, ItemViewHolder holder) {\n            View v = holder.itemView;\n            int listPosition = getListPosition(position);\n            holder.mListPosition = listPosition;\n            mChooserListAdapter.bindView(listPosition, v);\n        }\n\n        void bindItemGroupViewHolder(int position, ItemGroupViewHolder holder) {\n            final ViewGroup viewGroup = (ViewGroup) holder.itemView;\n            int start = getListPosition(position);\n            int startType = getRowType(start);\n\n            int columnCount = holder.getColumnCount();\n            int end = start + columnCount - 1;\n            while (getRowType(end) != startType && end >= start) {\n                end--;\n            }\n\n            if (end == start && mChooserListAdapter.getItem(start) instanceof EmptyTargetInfo) {\n                final TextView textView = viewGroup.findViewById(R.id.chooser_row_text_option);\n\n                if (textView.getVisibility() != View.VISIBLE) {\n                    textView.setAlpha(0.0f);\n                    textView.setVisibility(View.VISIBLE);\n                    textView.setText(R.string.chooser_no_direct_share_targets);\n\n                    ValueAnimator fadeAnim = ObjectAnimator.ofFloat(textView, \"alpha\", 0.0f, 1.0f);\n                    fadeAnim.setInterpolator(new DecelerateInterpolator(1.0f));\n\n                    float translationInPx = getResources().getDimensionPixelSize(\n                            R.dimen.chooser_row_text_option_translate);\n                    textView.setTranslationY(translationInPx);\n                    ValueAnimator translateAnim = ObjectAnimator.ofFloat(textView, \"translationY\",\n                            0.0f);\n                    translateAnim.setInterpolator(new DecelerateInterpolator(1.0f));\n\n                    AnimatorSet animSet = new AnimatorSet();\n                    animSet.setDuration(NO_DIRECT_SHARE_ANIM_IN_MILLIS);\n                    animSet.setStartDelay(NO_DIRECT_SHARE_ANIM_IN_MILLIS);\n                    animSet.playTogether(fadeAnim, translateAnim);\n                    animSet.start();\n                }\n            }\n\n            for (int i = 0; i < columnCount; i++) {\n                final View v = holder.getView(i);\n\n                if (start + i <= end) {\n                    holder.setViewVisibility(i, View.VISIBLE);\n                    holder.setItemIndex(i, start + i);\n                    mChooserListAdapter.bindView(holder.getItemIndex(i), v);\n                } else {\n                    holder.setViewVisibility(i, View.INVISIBLE);\n                }\n            }\n        }\n\n        int getListPosition(int position) {\n            position -= getSystemRowCount() + getProfileRowCount();\n\n            final int serviceCount = mChooserListAdapter.getServiceTargetCount();\n            final int serviceRows = (int) Math.ceil((float) serviceCount / getMaxRankedTargets());\n            if (position < serviceRows) {\n                return position * mMaxTargetsPerRow;\n            }\n\n            position -= serviceRows;\n\n            final int callerAndRankedCount = mChooserListAdapter.getCallerTargetCount()\n                                                 + mChooserListAdapter.getRankedTargetCount();\n            final int callerAndRankedRows = getCallerAndRankedTargetRowCount();\n            if (position < callerAndRankedRows) {\n                return serviceCount + position * mMaxTargetsPerRow;\n            }\n\n            position -= getAzLabelRowCount() + callerAndRankedRows;\n\n            return callerAndRankedCount + serviceCount + position;\n        }\n\n        public void handleScroll(View v, int y, int oldy) {\n            boolean canExpandDirectShare = canExpandDirectShare();\n            if (mDirectShareViewHolder != null && canExpandDirectShare) {\n                mDirectShareViewHolder.handleScroll(\n                        mChooserMultiProfilePagerAdapter.getActiveAdapterView(), y, oldy,\n                        mMaxTargetsPerRow);\n            }\n        }\n\n        /**\n         * Only expand direct share area if there is a minimum number of targets.\n         */\n        private boolean canExpandDirectShare() {\n            // Do not enable until we have confirmed more apps are using sharing shortcuts\n            // Check git history for enablement logic\n            return false;\n        }\n\n        public ChooserListAdapter getListAdapter() {\n            return mChooserListAdapter;\n        }\n\n        boolean shouldCellSpan(int position) {\n            return getItemViewType(position) == VIEW_TYPE_NORMAL;\n        }\n\n        void updateDirectShareExpansion() {\n            if (mDirectShareViewHolder == null || !canExpandDirectShare()) {\n                return;\n            }\n            RecyclerView activeAdapterView =\n                    mChooserMultiProfilePagerAdapter.getActiveAdapterView();\n            if (mResolverDrawerLayout.isCollapsed()) {\n                mDirectShareViewHolder.collapse(activeAdapterView);\n            } else {\n                mDirectShareViewHolder.expand(activeAdapterView);\n            }\n        }\n    }\n\n    /**\n     * Used to bind types for group of items including:\n     * {@link ChooserGridAdapter#VIEW_TYPE_DIRECT_SHARE},\n     * and {@link ChooserGridAdapter#VIEW_TYPE_CALLER_AND_RANK}.\n     */\n    abstract static class ItemGroupViewHolder extends ViewHolderBase {\n        protected int mMeasuredRowHeight;\n        private int[] mItemIndices;\n        protected final View[] mCells;\n        private final int mColumnCount;\n\n        ItemGroupViewHolder(int cellCount, View itemView, int viewType) {\n            super(itemView, viewType);\n            this.mCells = new View[cellCount];\n            this.mItemIndices = new int[cellCount];\n            this.mColumnCount = cellCount;\n        }\n\n        abstract ViewGroup addView(int index, View v);\n\n        abstract ViewGroup getViewGroup();\n\n        abstract ViewGroup getRowByIndex(int index);\n\n        abstract ViewGroup getRow(int rowNumber);\n\n        abstract void setViewVisibility(int i, int visibility);\n\n        public int getColumnCount() {\n            return mColumnCount;\n        }\n\n        public void measure() {\n            final int spec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);\n            getViewGroup().measure(spec, spec);\n            mMeasuredRowHeight = getViewGroup().getMeasuredHeight();\n        }\n\n        public int getMeasuredRowHeight() {\n            return mMeasuredRowHeight;\n        }\n\n        public void setItemIndex(int itemIndex, int listIndex) {\n            mItemIndices[itemIndex] = listIndex;\n        }\n\n        public int getItemIndex(int itemIndex) {\n            return mItemIndices[itemIndex];\n        }\n\n        public View getView(int index) {\n            return mCells[index];\n        }\n    }\n\n    static class SingleRowViewHolder extends ItemGroupViewHolder {\n        private final ViewGroup mRow;\n\n        SingleRowViewHolder(ViewGroup row, int cellCount, int viewType) {\n            super(cellCount, row, viewType);\n\n            this.mRow = row;\n        }\n\n        public ViewGroup getViewGroup() {\n            return mRow;\n        }\n\n        public ViewGroup getRowByIndex(int index) {\n            return mRow;\n        }\n\n        public ViewGroup getRow(int rowNumber) {\n            if (rowNumber == 0) return mRow;\n            return null;\n        }\n\n        public ViewGroup addView(int index, View v) {\n            mRow.addView(v);\n            mCells[index] = v;\n\n            return mRow;\n        }\n\n        public void setViewVisibility(int i, int visibility) {\n            getView(i).setVisibility(visibility);\n        }\n    }\n\n    static class DirectShareViewHolder extends ItemGroupViewHolder {\n        private final ViewGroup mParent;\n        private final List<ViewGroup> mRows;\n        private int mCellCountPerRow;\n\n        private boolean mHideDirectShareExpansion = false;\n        private int mDirectShareMinHeight = 0;\n        private int mDirectShareCurrHeight = 0;\n        private int mDirectShareMaxHeight = 0;\n\n        private final boolean[] mCellVisibility;\n\n        private final Supplier<ChooserListAdapter> mListAdapterSupplier;\n\n        DirectShareViewHolder(ViewGroup parent, List<ViewGroup> rows, int cellCountPerRow,\n                int viewType, Supplier<ChooserListAdapter> listAdapterSupplier) {\n            super(rows.size() * cellCountPerRow, parent, viewType);\n\n            this.mParent = parent;\n            this.mRows = rows;\n            this.mCellCountPerRow = cellCountPerRow;\n            this.mCellVisibility = new boolean[rows.size() * cellCountPerRow];\n            Arrays.fill(mCellVisibility, true);\n            this.mListAdapterSupplier = listAdapterSupplier;\n        }\n\n        public ViewGroup addView(int index, View v) {\n            ViewGroup row = getRowByIndex(index);\n            row.addView(v);\n            mCells[index] = v;\n\n            return row;\n        }\n\n        public ViewGroup getViewGroup() {\n            return mParent;\n        }\n\n        public ViewGroup getRowByIndex(int index) {\n            return mRows.get(index / mCellCountPerRow);\n        }\n\n        public ViewGroup getRow(int rowNumber) {\n            return mRows.get(rowNumber);\n        }\n\n        public void measure() {\n            final int spec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);\n            getRow(0).measure(spec, spec);\n            getRow(1).measure(spec, spec);\n\n            mDirectShareMinHeight = getRow(0).getMeasuredHeight();\n            mDirectShareCurrHeight = mDirectShareCurrHeight > 0\n                    ? mDirectShareCurrHeight : mDirectShareMinHeight;\n            mDirectShareMaxHeight = 2 * mDirectShareMinHeight;\n        }\n\n        public int getMeasuredRowHeight() {\n            return mDirectShareCurrHeight;\n        }\n\n        public int getMinRowHeight() {\n            return mDirectShareMinHeight;\n        }\n\n        public void setViewVisibility(int i, int visibility) {\n            final View v = getView(i);\n            if (visibility == View.VISIBLE) {\n                mCellVisibility[i] = true;\n                v.setVisibility(visibility);\n                v.setAlpha(1.0f);\n            } else if (visibility == View.INVISIBLE && mCellVisibility[i]) {\n                mCellVisibility[i] = false;\n\n                ValueAnimator fadeAnim = ObjectAnimator.ofFloat(v, \"alpha\", 1.0f, 0f);\n                fadeAnim.setDuration(NO_DIRECT_SHARE_ANIM_IN_MILLIS);\n                fadeAnim.setInterpolator(new AccelerateInterpolator(1.0f));\n                fadeAnim.addListener(new AnimatorListenerAdapter() {\n                    public void onAnimationEnd(Animator animation) {\n                        v.setVisibility(View.INVISIBLE);\n                    }\n                });\n                fadeAnim.start();\n            }\n        }\n\n        public void handleScroll(RecyclerView view, int y, int oldy, int maxTargetsPerRow) {\n            // only exit early if fully collapsed, otherwise onListRebuilt() with shifting\n            // targets can lock us into an expanded mode\n            boolean notExpanded = mDirectShareCurrHeight == mDirectShareMinHeight;\n            if (notExpanded) {\n                if (mHideDirectShareExpansion) {\n                    return;\n                }\n\n                // only expand if we have more than maxTargetsPerRow, and delay that decision\n                // until they start to scroll\n                ChooserListAdapter adapter = mListAdapterSupplier.get();\n                int validTargets = adapter.getSelectableServiceTargetCount();\n                if (validTargets <= maxTargetsPerRow) {\n                    mHideDirectShareExpansion = true;\n                    return;\n                }\n            }\n\n            int yDiff = (int) ((oldy - y) * DIRECT_SHARE_EXPANSION_RATE);\n\n            int prevHeight = mDirectShareCurrHeight;\n            int newHeight = Math.min(prevHeight + yDiff, mDirectShareMaxHeight);\n            newHeight = Math.max(newHeight, mDirectShareMinHeight);\n            yDiff = newHeight - prevHeight;\n\n            updateDirectShareRowHeight(view, yDiff, newHeight);\n        }\n\n        void expand(RecyclerView view) {\n            updateDirectShareRowHeight(view, mDirectShareMaxHeight - mDirectShareCurrHeight,\n                    mDirectShareMaxHeight);\n        }\n\n        void collapse(RecyclerView view) {\n            updateDirectShareRowHeight(view, mDirectShareMinHeight - mDirectShareCurrHeight,\n                    mDirectShareMinHeight);\n        }\n\n        private void updateDirectShareRowHeight(RecyclerView view, int yDiff, int newHeight) {\n            if (view == null || view.getChildCount() == 0 || yDiff == 0) {\n                return;\n            }\n\n            // locate the item to expand, and offset the rows below that one\n            boolean foundExpansion = false;\n            for (int i = 0; i < view.getChildCount(); i++) {\n                View child = view.getChildAt(i);\n\n                if (foundExpansion) {\n                    child.offsetTopAndBottom(yDiff);\n                } else {\n                    if (child.getTag() != null && child.getTag() instanceof DirectShareViewHolder) {\n                        int widthSpec = MeasureSpec.makeMeasureSpec(child.getWidth(),\n                                MeasureSpec.EXACTLY);\n                        int heightSpec = MeasureSpec.makeMeasureSpec(newHeight,\n                                MeasureSpec.EXACTLY);\n                        child.measure(widthSpec, heightSpec);\n                        child.getLayoutParams().height = child.getMeasuredHeight();\n                        child.layout(child.getLeft(), child.getTop(), child.getRight(),\n                                child.getTop() + child.getMeasuredHeight());\n\n                        foundExpansion = true;\n                    }\n                }\n            }\n\n            if (foundExpansion) {\n                mDirectShareCurrHeight = newHeight;\n            }\n        }\n    }\n\n    /**\n     * Shortcuts grouped by application.\n     */\n    @VisibleForTesting\n    public static class ServiceResultInfo {\n        public final DisplayResolveInfo originalTarget;\n        public final List<ChooserTarget> resultTargets;\n        public final UserHandle userHandle;\n\n        public ServiceResultInfo(DisplayResolveInfo ot, List<ChooserTarget> rt,\n                UserHandle userHandle) {\n            originalTarget = ot;\n            resultTargets = rt;\n            this.userHandle = userHandle;\n        }\n    }\n\n    static class ChooserTargetRankingInfo {\n        public final List<AppTarget> scores;\n        public final UserHandle userHandle;\n\n        ChooserTargetRankingInfo(List<AppTarget> chooserTargetScores,\n                UserHandle userHandle) {\n            this.scores = chooserTargetScores;\n            this.userHandle = userHandle;\n        }\n    }\n\n    static class RefinementResultReceiver extends ResultReceiver {\n        private ChooserActivity mChooserActivity;\n        private TargetInfo mSelectedTarget;\n\n        public RefinementResultReceiver(ChooserActivity host, TargetInfo target,\n                Handler handler) {\n            super(handler);\n            mChooserActivity = host;\n            mSelectedTarget = target;\n        }\n\n        @Override\n        protected void onReceiveResult(int resultCode, Bundle resultData) {\n            if (mChooserActivity == null) {\n                Log.e(TAG, \"Destroyed RefinementResultReceiver received a result\");\n                return;\n            }\n            if (resultData == null) {\n                Log.e(TAG, \"RefinementResultReceiver received null resultData\");\n                return;\n            }\n\n            switch (resultCode) {\n                case RESULT_CANCELED:\n                    mChooserActivity.onRefinementCanceled();\n                    break;\n                case RESULT_OK:\n                    Parcelable intentParcelable = resultData.getParcelable(Intent.EXTRA_INTENT);\n                    if (intentParcelable instanceof Intent) {\n                        mChooserActivity.onRefinementResult(mSelectedTarget,\n                                (Intent) intentParcelable);\n                    } else {\n                        Log.e(TAG, \"RefinementResultReceiver received RESULT_OK but no Intent\"\n                                + \" in resultData with key Intent.EXTRA_INTENT\");\n                    }\n                    break;\n                default:\n                    Log.w(TAG, \"Unknown result code \" + resultCode\n                            + \" sent to RefinementResultReceiver\");\n                    break;\n            }\n        }\n\n        public void destroy() {\n            mChooserActivity = null;\n            mSelectedTarget = null;\n        }\n    }\n\n    /**\n     * Used internally to round image corners while obeying view padding.\n     */\n    public static class RoundedRectImageView extends ImageView {\n        private int mRadius = 0;\n        private Path mPath = new Path();\n        private Paint mOverlayPaint = new Paint(0);\n        private Paint mRoundRectPaint = new Paint(0);\n        private Paint mTextPaint = new Paint(Paint.ANTI_ALIAS_FLAG);\n        private String mExtraImageCount = null;\n\n        public RoundedRectImageView(Context context) {\n            super(context);\n        }\n\n        public RoundedRectImageView(Context context, AttributeSet attrs) {\n            this(context, attrs, 0);\n        }\n\n        public RoundedRectImageView(Context context, AttributeSet attrs, int defStyleAttr) {\n            this(context, attrs, defStyleAttr, 0);\n        }\n\n        public RoundedRectImageView(Context context, AttributeSet attrs, int defStyleAttr,\n                int defStyleRes) {\n            super(context, attrs, defStyleAttr, defStyleRes);\n            mRadius = context.getResources().getDimensionPixelSize(R.dimen.chooser_corner_radius);\n\n            mOverlayPaint.setColor(0x99000000);\n            mOverlayPaint.setStyle(Paint.Style.FILL);\n\n            mRoundRectPaint.setColor(context.getResources().getColor(R.color.chooser_row_divider));\n            mRoundRectPaint.setStyle(Paint.Style.STROKE);\n            mRoundRectPaint.setStrokeWidth(context.getResources()\n                    .getDimensionPixelSize(R.dimen.chooser_preview_image_border));\n\n            mTextPaint.setColor(Color.WHITE);\n            mTextPaint.setTextSize(context.getResources()\n                    .getDimensionPixelSize(R.dimen.chooser_preview_image_font_size));\n            mTextPaint.setTextAlign(Paint.Align.CENTER);\n        }\n\n        private void updatePath(int width, int height) {\n            mPath.reset();\n\n            int imageWidth = width - getPaddingRight() - getPaddingLeft();\n            int imageHeight = height - getPaddingBottom() - getPaddingTop();\n            mPath.addRoundRect(getPaddingLeft(), getPaddingTop(), imageWidth, imageHeight, mRadius,\n                    mRadius, Path.Direction.CW);\n        }\n\n        /**\n          * Sets the corner radius on all corners\n          *\n          * param radius 0 for no radius, &gt; 0 for a visible corner radius\n          */\n        public void setRadius(int radius) {\n            mRadius = radius;\n            updatePath(getWidth(), getHeight());\n        }\n\n        /**\n          * Display an overlay with extra image count on 3rd image\n          */\n        public void setExtraImageCount(int count) {\n            if (count > 0) {\n                this.mExtraImageCount = \"+\" + count;\n            } else {\n                this.mExtraImageCount = null;\n            }\n        }\n\n        @Override\n        protected void onSizeChanged(int width, int height, int oldWidth, int oldHeight) {\n            super.onSizeChanged(width, height, oldWidth, oldHeight);\n            updatePath(width, height);\n        }\n\n        @Override\n        protected void onDraw(Canvas canvas) {\n            if (mRadius != 0) {\n                canvas.clipPath(mPath);\n            }\n\n            super.onDraw(canvas);\n\n            int x = getPaddingLeft();\n            int y = getPaddingRight();\n            int width = getWidth() - getPaddingRight() - getPaddingLeft();\n            int height = getHeight() - getPaddingBottom() - getPaddingTop();\n            if (mExtraImageCount != null) {\n                canvas.drawRect(x, y, width, height, mOverlayPaint);\n\n                int xPos = canvas.getWidth() / 2;\n                int yPos = (int) ((canvas.getHeight() / 2.0f)\n                        - ((mTextPaint.descent() + mTextPaint.ascent()) / 2.0f));\n\n                canvas.drawText(mExtraImageCount, xPos, yPos, mTextPaint);\n            }\n\n            canvas.drawRoundRect(x, y, width, height, mRadius, mRadius, mRoundRectPaint);\n        }\n    }\n\n    /**\n     * A helper class to track app's readiness for the scene transition animation.\n     * The app is ready when both the image is laid out and the drawer offset is calculated.\n     */\n    private class EnterTransitionAnimationDelegate implements View.OnLayoutChangeListener {\n        private boolean mPreviewReady = false;\n        private boolean mOffsetCalculated = false;\n\n        void postponeTransition() {\n            postponeEnterTransition();\n        }\n\n        void markImagePreviewReady() {\n            if (!mPreviewReady) {\n                mPreviewReady = true;\n                maybeStartListenForLayout();\n            }\n        }\n\n        void markOffsetCalculated() {\n            if (!mOffsetCalculated) {\n                mOffsetCalculated = true;\n                maybeStartListenForLayout();\n            }\n        }\n\n        private void maybeStartListenForLayout() {\n            if (mPreviewReady && mOffsetCalculated && mResolverDrawerLayout != null) {\n                if (mResolverDrawerLayout.isInLayout()) {\n                    startPostponedEnterTransition();\n                } else {\n                    mResolverDrawerLayout.addOnLayoutChangeListener(this);\n                    mResolverDrawerLayout.requestLayout();\n                }\n            }\n        }\n\n        @Override\n        public void onLayoutChange(View v, int left, int top, int right, int bottom, int oldLeft,\n                int oldTop, int oldRight, int oldBottom) {\n            v.removeOnLayoutChangeListener(this);\n            startPostponedEnterTransition();\n        }\n    }\n\n    /**\n     * Used in combination with the scene transition when launching the image editor\n     */\n    private static class FinishAnimation extends AlphaAnimation implements\n            Animation.AnimationListener {\n        @Nullable\n        private Activity mActivity;\n        @Nullable\n        private View mRootView;\n        private final float mFromAlpha;\n\n        FinishAnimation(@NonNull Activity activity, @NonNull View rootView) {\n            super(rootView.getAlpha(), 0.0f);\n            mActivity = activity;\n            mRootView = rootView;\n            mFromAlpha = rootView.getAlpha();\n            setInterpolator(new LinearInterpolator());\n            long duration = activity.getWindow().getTransitionBackgroundFadeDuration();\n            setDuration(duration);\n            // The scene transition animation looks better when it's not overlapped with this\n            // fade-out animation thus the delay.\n            // It is most likely that the image editor will cause this activity to stop and this\n            // animation will be cancelled in the background without running (i.e. we'll animate\n            // only when this activity remains partially visible after the image editor launch).\n            setStartOffset(duration);\n            super.setAnimationListener(this);\n        }\n\n        @Override\n        public void setAnimationListener(AnimationListener listener) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public void cancel() {\n            if (mRootView != null) {\n                mRootView.setAlpha(mFromAlpha);\n            }\n            cleanup();\n            super.cancel();\n        }\n\n        @Override\n        public void onAnimationStart(Animation animation) {\n        }\n\n        @Override\n        public void onAnimationEnd(Animation animation) {\n            Activity activity = mActivity;\n            cleanup();\n            if (activity != null) {\n                activity.finish();\n            }\n        }\n\n        @Override\n        public void onAnimationRepeat(Animation animation) {\n        }\n\n        private void cleanup() {\n            mActivity = null;\n            mRootView = null;\n        }\n    }\n\n    @Override\n    protected void maybeLogProfileChange() {\n        getChooserActivityLogger().logShareheetProfileChanged();\n    }\n\n    private boolean shouldNearbyShareBeFirstInRankedRow() {\n        return ActivityManager.isLowRamDeviceStatic() && mIsNearbyShareFirstTargetInRankedApp;\n    }\n\n    private boolean shouldNearbyShareBeIncludedAsActionButton() {\n        return !shouldNearbyShareBeFirstInRankedRow();\n    }\n\n    private boolean hasValidIcon(ChooserTarget target) {\n        Icon icon = target.getIcon();\n        if (icon == null) {\n            return true;\n        }\n        if (icon.getType() == Icon.TYPE_URI || icon.getType() == Icon.TYPE_URI_ADAPTIVE_BITMAP) {\n            Uri uri = icon.getUri();\n            try {\n                getUriGrantsManager().checkGrantUriPermission_ignoreNonSystem(\n                        getLaunchedFromUid(),\n                        getPackageName(),\n                        getUriWithoutUserId(uri),\n                        Intent.FLAG_GRANT_READ_URI_PERMISSION,\n                        getUserIdFromUri(uri)\n                );\n            } catch (SecurityException | RemoteException e) {\n                Log.e(TAG, \"Failed to get URI permission for: \" + uri, e);\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private IUriGrantsManager getUriGrantsManager() {\n        return UriGrantsManager.getService();\n    }\n\n    private static ChooserTarget removeIcon(ChooserTarget target) {\n        if (target == null) {\n            return null;\n        }\n        return new ChooserTarget(\n                target.getTitle(),\n                null,\n                target.getScore(),\n                target.getComponentName(),\n                target.getIntentExtras());\n    }\n}",
    "downstream_codebase": "/*\n * Copyright (C) 2008 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.internal.app;\n\nimport static android.content.ContentProvider.getUserIdFromUri;\n\nimport static com.android.internal.util.LatencyTracker.ACTION_LOAD_SHARE_SHEET;\n\nimport static java.lang.annotation.RetentionPolicy.SOURCE;\n\nimport android.animation.Animator;\nimport android.animation.AnimatorListenerAdapter;\nimport android.animation.AnimatorSet;\nimport android.animation.ObjectAnimator;\nimport android.animation.ValueAnimator;\nimport android.annotation.IntDef;\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.app.Activity;\nimport android.app.ActivityManager;\nimport android.app.SharedElementCallback;\nimport android.app.prediction.AppPredictionContext;\nimport android.app.prediction.AppPredictionManager;\nimport android.app.prediction.AppPredictor;\nimport android.app.prediction.AppTarget;\nimport android.app.prediction.AppTargetEvent;\nimport android.app.prediction.AppTargetId;\nimport android.compat.annotation.UnsupportedAppUsage;\nimport android.content.ClipData;\nimport android.content.ClipboardManager;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.IntentSender;\nimport android.content.IntentSender.SendIntentException;\nimport android.content.SharedPreferences;\nimport android.content.pm.ActivityInfo;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManager.NameNotFoundException;\nimport android.content.pm.ResolveInfo;\nimport android.content.pm.ShortcutInfo;\nimport android.content.pm.ShortcutManager;\nimport android.content.res.Configuration;\nimport android.content.res.Resources;\nimport android.database.Cursor;\nimport android.database.DataSetObserver;\nimport android.graphics.Bitmap;\nimport android.graphics.Canvas;\nimport android.graphics.Color;\nimport android.graphics.Paint;\nimport android.graphics.Path;\nimport android.graphics.drawable.AnimatedVectorDrawable;\nimport android.graphics.drawable.Drawable;\nimport android.graphics.drawable.Icon;\nimport android.metrics.LogMaker;\nimport android.net.Uri;\nimport android.os.AsyncTask;\nimport android.os.Bundle;\nimport android.os.Environment;\nimport android.os.Handler;\nimport android.os.Message;\nimport android.os.Parcelable;\nimport android.os.PatternMatcher;\nimport android.os.RemoteException;\nimport android.os.ResultReceiver;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.os.storage.StorageManager;\nimport android.provider.DeviceConfig;\nimport android.provider.DocumentsContract;\nimport android.provider.Downloads;\nimport android.provider.OpenableColumns;\nimport android.provider.Settings;\nimport android.service.chooser.ChooserTarget;\nimport android.text.TextUtils;\nimport android.util.AttributeSet;\nimport android.util.HashedStringCache;\nimport android.util.Log;\nimport android.util.PluralsMessageFormatter;\nimport android.util.Size;\nimport android.util.Slog;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.View.MeasureSpec;\nimport android.view.View.OnClickListener;\nimport android.view.ViewGroup;\nimport android.view.ViewGroup.LayoutParams;\nimport android.view.ViewTreeObserver;\nimport android.view.WindowInsets;\nimport android.view.animation.AccelerateInterpolator;\nimport android.view.animation.DecelerateInterpolator;\nimport android.widget.Button;\nimport android.widget.ImageView;\nimport android.widget.Space;\nimport android.widget.TextView;\n\nimport com.android.internal.R;\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.app.ResolverListAdapter.ActivityInfoPresentationGetter;\nimport com.android.internal.app.ResolverListAdapter.ViewHolder;\nimport com.android.internal.app.chooser.ChooserTargetInfo;\nimport com.android.internal.app.chooser.DisplayResolveInfo;\nimport com.android.internal.app.chooser.MultiDisplayResolveInfo;\nimport com.android.internal.app.chooser.NotSelectableTargetInfo;\nimport com.android.internal.app.chooser.SelectableTargetInfo;\nimport com.android.internal.app.chooser.SelectableTargetInfo.SelectableTargetInfoCommunicator;\nimport com.android.internal.app.chooser.TargetInfo;\nimport com.android.internal.config.sysui.SystemUiDeviceConfigFlags;\nimport com.android.internal.content.PackageMonitor;\nimport com.android.internal.logging.MetricsLogger;\nimport com.android.internal.logging.nano.MetricsProto.MetricsEvent;\nimport com.android.internal.util.FrameworkStatsLog;\nimport com.android.internal.widget.GridLayoutManager;\nimport com.android.internal.widget.RecyclerView;\nimport com.android.internal.widget.ResolverDrawerLayout;\nimport com.android.internal.widget.ViewPager;\n\nimport com.google.android.collect.Lists;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.net.URISyntaxException;\nimport java.text.Collator;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.function.Supplier;\nimport java.util.stream.Collectors;\n\n/**\n * The Chooser Activity handles intent resolution specifically for sharing intents -\n * for example, those generated by @see android.content.Intent#createChooser(Intent, CharSequence).\n *\n */\npublic class ChooserActivity extends ResolverActivity implements\n        ChooserListAdapter.ChooserListCommunicator,\n        SelectableTargetInfoCommunicator {\n    private static final String TAG = \"ChooserActivity\";\n\n    private AppPredictor mPersonalAppPredictor;\n    private AppPredictor mWorkAppPredictor;\n    private boolean mShouldDisplayLandscape;\n\n    @UnsupportedAppUsage\n    public ChooserActivity() {\n    }\n    /**\n     * Boolean extra to change the following behavior: Normally, ChooserActivity finishes itself\n     * in onStop when launched in a new task. If this extra is set to true, we do not finish\n     * ourselves when onStop gets called.\n     */\n    public static final String EXTRA_PRIVATE_RETAIN_IN_ON_STOP\n            = \"com.android.internal.app.ChooserActivity.EXTRA_PRIVATE_RETAIN_IN_ON_STOP\";\n\n\n    /**\n     * Transition name for the first image preview.\n     * To be used for shared element transition into this activity.\n     * @hide\n     */\n    public static final String FIRST_IMAGE_PREVIEW_TRANSITION_NAME = \"screenshot_preview_image\";\n\n    private static final String PREF_NUM_SHEET_EXPANSIONS = \"pref_num_sheet_expansions\";\n\n    private static final String CHIP_LABEL_METADATA_KEY = \"android.service.chooser.chip_label\";\n    private static final String CHIP_ICON_METADATA_KEY = \"android.service.chooser.chip_icon\";\n\n    private static final boolean DEBUG = true;\n\n    private static final boolean USE_PREDICTION_MANAGER_FOR_SHARE_ACTIVITIES = true;\n    // TODO(b/123088566) Share these in a better way.\n    private static final String APP_PREDICTION_SHARE_UI_SURFACE = \"share\";\n    public static final String LAUNCH_LOCATION_DIRECT_SHARE = \"direct_share\";\n    public static final String CHOOSER_TARGET = \"chooser_target\";\n    private static final String SHORTCUT_TARGET = \"shortcut_target\";\n    private static final int APP_PREDICTION_SHARE_TARGET_QUERY_PACKAGE_LIMIT = 20;\n    public static final String APP_PREDICTION_INTENT_FILTER_KEY = \"intent_filter\";\n    private static final String SHARED_TEXT_KEY = \"shared_text\";\n\n    private static final String PLURALS_COUNT = \"count\";\n    private static final String PLURALS_FILE_NAME = \"file_name\";\n\n    private boolean mIsAppPredictorComponentAvailable;\n    private Map<ChooserTarget, AppTarget> mDirectShareAppTargetCache;\n    private Map<ChooserTarget, ShortcutInfo> mDirectShareShortcutInfoCache;\n\n    public static final int TARGET_TYPE_DEFAULT = 0;\n    public static final int TARGET_TYPE_CHOOSER_TARGET = 1;\n    public static final int TARGET_TYPE_SHORTCUTS_FROM_SHORTCUT_MANAGER = 2;\n    public static final int TARGET_TYPE_SHORTCUTS_FROM_PREDICTION_SERVICE = 3;\n\n    public static final int SELECTION_TYPE_SERVICE = 1;\n    public static final int SELECTION_TYPE_APP = 2;\n    public static final int SELECTION_TYPE_STANDARD = 3;\n    public static final int SELECTION_TYPE_COPY = 4;\n    public static final int SELECTION_TYPE_NEARBY = 5;\n    public static final int SELECTION_TYPE_EDIT = 6;\n\n    private static final int SCROLL_STATUS_IDLE = 0;\n    private static final int SCROLL_STATUS_SCROLLING_VERTICAL = 1;\n    private static final int SCROLL_STATUS_SCROLLING_HORIZONTAL = 2;\n\n    // statsd logger wrapper\n    protected ChooserActivityLogger mChooserActivityLogger;\n\n    @IntDef(flag = false, prefix = { \"TARGET_TYPE_\" }, value = {\n            TARGET_TYPE_DEFAULT,\n            TARGET_TYPE_CHOOSER_TARGET,\n            TARGET_TYPE_SHORTCUTS_FROM_SHORTCUT_MANAGER,\n            TARGET_TYPE_SHORTCUTS_FROM_PREDICTION_SERVICE\n    })\n    @Retention(RetentionPolicy.SOURCE)\n    public @interface ShareTargetType {}\n\n    /**\n     * The transition time between placeholders for direct share to a message\n     * indicating that non are available.\n     */\n    private static final int NO_DIRECT_SHARE_ANIM_IN_MILLIS = 200;\n\n    private static final float DIRECT_SHARE_EXPANSION_RATE = 0.78f;\n\n    private static final int DEFAULT_SALT_EXPIRATION_DAYS = 7;\n    private int mMaxHashSaltDays = DeviceConfig.getInt(DeviceConfig.NAMESPACE_SYSTEMUI,\n            SystemUiDeviceConfigFlags.HASH_SALT_MAX_DAYS,\n            DEFAULT_SALT_EXPIRATION_DAYS);\n\n    private static final boolean DEFAULT_IS_NEARBY_SHARE_FIRST_TARGET_IN_RANKED_APP = false;\n    private boolean mIsNearbyShareFirstTargetInRankedApp =\n            DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_SYSTEMUI,\n                    SystemUiDeviceConfigFlags.IS_NEARBY_SHARE_FIRST_TARGET_IN_RANKED_APP,\n                    DEFAULT_IS_NEARBY_SHARE_FIRST_TARGET_IN_RANKED_APP);\n\n    private static final int DEFAULT_LIST_VIEW_UPDATE_DELAY_MS = 125;\n\n    @VisibleForTesting\n    int mListViewUpdateDelayMs = DeviceConfig.getInt(DeviceConfig.NAMESPACE_SYSTEMUI,\n            SystemUiDeviceConfigFlags.SHARESHEET_LIST_VIEW_UPDATE_DELAY,\n            DEFAULT_LIST_VIEW_UPDATE_DELAY_MS);\n\n    private Bundle mReplacementExtras;\n    private IntentSender mChosenComponentSender;\n    private IntentSender mRefinementIntentSender;\n    private RefinementResultReceiver mRefinementResultReceiver;\n    private ChooserTarget[] mCallerChooserTargets;\n    private ComponentName[] mFilteredComponentNames;\n\n    private Intent mReferrerFillInIntent;\n\n    private long mChooserShownTime;\n    protected boolean mIsSuccessfullySelected;\n\n    private long mQueriedSharingShortcutsTimeMs;\n\n    private int mCurrAvailableWidth = 0;\n    private int mLastNumberOfChildren = -1;\n    private int mMaxTargetsPerRow = 1;\n\n    private static final String TARGET_DETAILS_FRAGMENT_TAG = \"targetDetailsFragment\";\n\n    private static final int MAX_LOG_RANK_POSITION = 12;\n\n    private static final int MAX_EXTRA_INITIAL_INTENTS = 2;\n    private static final int MAX_EXTRA_CHOOSER_TARGETS = 2;\n\n    private SharedPreferences mPinnedSharedPrefs;\n    private static final String PINNED_SHARED_PREFS_NAME = \"chooser_pin_settings\";\n\n    @Retention(SOURCE)\n    @IntDef({CONTENT_PREVIEW_FILE, CONTENT_PREVIEW_IMAGE, CONTENT_PREVIEW_TEXT})\n    private @interface ContentPreviewType {\n    }\n\n    // Starting at 1 since 0 is considered \"undefined\" for some of the database transformations\n    // of tron logs.\n    protected static final int CONTENT_PREVIEW_IMAGE = 1;\n    protected static final int CONTENT_PREVIEW_FILE = 2;\n    protected static final int CONTENT_PREVIEW_TEXT = 3;\n    protected MetricsLogger mMetricsLogger;\n\n    private ContentPreviewCoordinator mPreviewCoord;\n    private int mScrollStatus = SCROLL_STATUS_IDLE;\n\n    @VisibleForTesting\n    protected ChooserMultiProfilePagerAdapter mChooserMultiProfilePagerAdapter;\n    private final EnterTransitionAnimationDelegate mEnterTransitionAnimationDelegate =\n            new EnterTransitionAnimationDelegate();\n\n    private boolean mRemoveSharedElements = false;\n\n    private class ContentPreviewCoordinator {\n        private static final int IMAGE_FADE_IN_MILLIS = 150;\n        private static final int IMAGE_LOAD_TIMEOUT = 1;\n        private static final int IMAGE_LOAD_INTO_VIEW = 2;\n\n        private final int mImageLoadTimeoutMillis =\n                getResources().getInteger(R.integer.config_shortAnimTime);\n\n        private final View mParentView;\n        private boolean mHideParentOnFail;\n        private boolean mAtLeastOneLoaded = false;\n\n        class LoadUriTask {\n            public final Uri mUri;\n            public final int mImageResourceId;\n            public final int mExtraCount;\n            public final Bitmap mBmp;\n\n            LoadUriTask(int imageResourceId, Uri uri, int extraCount, Bitmap bmp) {\n                this.mImageResourceId = imageResourceId;\n                this.mUri = uri;\n                this.mExtraCount = extraCount;\n                this.mBmp = bmp;\n            }\n        }\n\n        // If at least one image loads within the timeout period, allow other\n        // loads to continue. Otherwise terminate and optionally hide\n        // the parent area\n        private final Handler mHandler = new Handler() {\n            @Override\n            public void handleMessage(Message msg) {\n                switch (msg.what) {\n                    case IMAGE_LOAD_TIMEOUT:\n                        maybeHideContentPreview();\n                        break;\n\n                    case IMAGE_LOAD_INTO_VIEW:\n                        if (isFinishing()) break;\n\n                        LoadUriTask task = (LoadUriTask) msg.obj;\n                        RoundedRectImageView imageView = mParentView.findViewById(\n                                task.mImageResourceId);\n                        if (task.mBmp == null) {\n                            imageView.setVisibility(View.GONE);\n                            maybeHideContentPreview();\n                            return;\n                        }\n\n                        mAtLeastOneLoaded = true;\n                        imageView.setVisibility(View.VISIBLE);\n                        imageView.setAlpha(0.0f);\n                        imageView.setImageBitmap(task.mBmp);\n\n                        ValueAnimator fadeAnim = ObjectAnimator.ofFloat(imageView, \"alpha\", 0.0f,\n                                1.0f);\n                        fadeAnim.setInterpolator(new DecelerateInterpolator(1.0f));\n                        fadeAnim.setDuration(IMAGE_FADE_IN_MILLIS);\n                        fadeAnim.start();\n\n                        if (task.mExtraCount > 0) {\n                            imageView.setExtraImageCount(task.mExtraCount);\n                        }\n\n                        setupPreDrawForSharedElementTransition(imageView);\n                }\n            }\n        };\n\n        private void setupPreDrawForSharedElementTransition(View v) {\n            v.getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {\n                @Override\n                public boolean onPreDraw() {\n                    v.getViewTreeObserver().removeOnPreDrawListener(this);\n\n                    if (!mRemoveSharedElements && isActivityTransitionRunning()) {\n                        // Disable the window animations as it interferes with the\n                        // transition animation.\n                        getWindow().setWindowAnimations(0);\n                    }\n                    mEnterTransitionAnimationDelegate.markImagePreviewReady();\n                    return true;\n                }\n            });\n        }\n\n        ContentPreviewCoordinator(View parentView, boolean hideParentOnFail) {\n            super();\n\n            this.mParentView = parentView;\n            this.mHideParentOnFail = hideParentOnFail;\n        }\n\n        private void loadUriIntoView(final int imageResourceId, final Uri uri,\n                final int extraImages) {\n            mHandler.sendEmptyMessageDelayed(IMAGE_LOAD_TIMEOUT, mImageLoadTimeoutMillis);\n\n            AsyncTask.THREAD_POOL_EXECUTOR.execute(() -> {\n                int size = getResources().getDimensionPixelSize(\n                        R.dimen.chooser_preview_image_max_dimen);\n                final Bitmap bmp = loadThumbnail(uri, new Size(size, size));\n                final Message msg = Message.obtain();\n                msg.what = IMAGE_LOAD_INTO_VIEW;\n                msg.obj = new LoadUriTask(imageResourceId, uri, extraImages, bmp);\n                mHandler.sendMessage(msg);\n            });\n        }\n\n        private void cancelLoads() {\n            mHandler.removeMessages(IMAGE_LOAD_INTO_VIEW);\n            mHandler.removeMessages(IMAGE_LOAD_TIMEOUT);\n        }\n\n        private void maybeHideContentPreview() {\n            if (!mAtLeastOneLoaded) {\n                if (mHideParentOnFail) {\n                    Log.i(TAG, \"Hiding image preview area. Timed out waiting for preview to load\"\n                            + \" within \" + mImageLoadTimeoutMillis + \"ms.\");\n                    collapseParentView();\n                    if (shouldShowTabs()) {\n                        hideStickyContentPreview();\n                    } else if (mChooserMultiProfilePagerAdapter.getCurrentRootAdapter() != null) {\n                        mChooserMultiProfilePagerAdapter.getCurrentRootAdapter()\n                                .hideContentPreview();\n                    }\n                    mHideParentOnFail = false;\n                }\n                mRemoveSharedElements = true;\n                mEnterTransitionAnimationDelegate.markImagePreviewReady();\n            }\n        }\n\n        private void collapseParentView() {\n            // This will effectively hide the content preview row by forcing the height\n            // to zero. It is faster than forcing a relayout of the listview\n            final View v = mParentView;\n            int widthSpec = MeasureSpec.makeMeasureSpec(v.getWidth(), MeasureSpec.EXACTLY);\n            int heightSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.EXACTLY);\n            v.measure(widthSpec, heightSpec);\n            v.getLayoutParams().height = 0;\n            v.layout(v.getLeft(), v.getTop(), v.getRight(), v.getTop());\n            v.invalidate();\n        }\n    }\n\n    private final ChooserHandler mChooserHandler = new ChooserHandler();\n\n    private class ChooserHandler extends Handler {\n        private static final int LIST_VIEW_UPDATE_MESSAGE = 6;\n        private static final int SHORTCUT_MANAGER_ALL_SHARE_TARGET_RESULTS = 7;\n\n        private void removeAllMessages() {\n            removeMessages(LIST_VIEW_UPDATE_MESSAGE);\n            removeMessages(SHORTCUT_MANAGER_ALL_SHARE_TARGET_RESULTS);\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            if (mChooserMultiProfilePagerAdapter.getActiveListAdapter() == null || isDestroyed()) {\n                return;\n            }\n\n            switch (msg.what) {\n                case LIST_VIEW_UPDATE_MESSAGE:\n                    if (DEBUG) {\n                        Log.d(TAG, \"LIST_VIEW_UPDATE_MESSAGE; \");\n                    }\n\n                    UserHandle userHandle = (UserHandle) msg.obj;\n                    mChooserMultiProfilePagerAdapter.getListAdapterForUserHandle(userHandle)\n                            .refreshListView();\n                    break;\n\n                case SHORTCUT_MANAGER_ALL_SHARE_TARGET_RESULTS:\n                    if (DEBUG) Log.d(TAG, \"SHORTCUT_MANAGER_ALL_SHARE_TARGET_RESULTS\");\n                    final ServiceResultInfo[] resultInfos = (ServiceResultInfo[]) msg.obj;\n                    for (ServiceResultInfo resultInfo : resultInfos) {\n                        if (resultInfo.resultTargets != null) {\n                            ChooserListAdapter adapterForUserHandle =\n                                    mChooserMultiProfilePagerAdapter.getListAdapterForUserHandle(\n                                            resultInfo.userHandle);\n                            if (adapterForUserHandle != null) {\n                                adapterForUserHandle.addServiceResults(\n                                        resultInfo.originalTarget,\n                                        resultInfo.resultTargets, msg.arg1,\n                                        mDirectShareShortcutInfoCache);\n                            }\n                        }\n                    }\n\n                    logDirectShareTargetReceived(\n                            MetricsEvent.ACTION_DIRECT_SHARE_TARGETS_LOADED_SHORTCUT_MANAGER);\n                    sendVoiceChoicesIfNeeded();\n                    getChooserActivityLogger().logSharesheetDirectLoadComplete();\n\n                    mChooserMultiProfilePagerAdapter.getActiveListAdapter()\n                            .completeServiceTargetLoading();\n                    break;\n\n                default:\n                    super.handleMessage(msg);\n            }\n        }\n    };\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        if (Settings.Secure.getIntForUser(getContentResolver(),\n                Settings.Secure.SECURE_FRP_MODE, 0,\n                getUserId()) == 1) {\n            Log.e(TAG, \"Sharing disabled due to active FRP lock.\");\n            super.onCreate(savedInstanceState);\n            finish();\n            return;\n        }\n        final long intentReceivedTime = System.currentTimeMillis();\n        mLatencyTracker.onActionStart(ACTION_LOAD_SHARE_SHEET);\n\n        getChooserActivityLogger().logSharesheetTriggered();\n        // This is the only place this value is being set. Effectively final.\n        mIsAppPredictorComponentAvailable = isAppPredictionServiceAvailable();\n\n        mIsSuccessfullySelected = false;\n        Intent intent = getIntent();\n        Parcelable targetParcelable = intent.getParcelableExtra(Intent.EXTRA_INTENT);\n        if (targetParcelable instanceof Uri) {\n            try {\n                targetParcelable = Intent.parseUri(targetParcelable.toString(),\n                        Intent.URI_INTENT_SCHEME);\n            } catch (URISyntaxException ex) {\n                // doesn't parse as an intent; let the next test fail and error out\n            }\n        }\n\n        if (!(targetParcelable instanceof Intent)) {\n            Log.w(\"ChooserActivity\", \"Target is not an intent: \" + targetParcelable);\n            finish();\n            super.onCreate(null);\n            return;\n        }\n        Intent target = (Intent) targetParcelable;\n        if (target != null) {\n            modifyTargetIntent(target);\n        }\n        Parcelable[] targetsParcelable\n                = intent.getParcelableArrayExtra(Intent.EXTRA_ALTERNATE_INTENTS);\n        if (targetsParcelable != null) {\n            final boolean offset = target == null;\n            Intent[] additionalTargets =\n                    new Intent[offset ? targetsParcelable.length - 1 : targetsParcelable.length];\n            for (int i = 0; i < targetsParcelable.length; i++) {\n                if (!(targetsParcelable[i] instanceof Intent)) {\n                    Log.w(TAG, \"EXTRA_ALTERNATE_INTENTS array entry #\" + i + \" is not an Intent: \"\n                            + targetsParcelable[i]);\n                    finish();\n                    super.onCreate(null);\n                    return;\n                }\n                final Intent additionalTarget = (Intent) targetsParcelable[i];\n                if (i == 0 && target == null) {\n                    target = additionalTarget;\n                    modifyTargetIntent(target);\n                } else {\n                    additionalTargets[offset ? i - 1 : i] = additionalTarget;\n                    modifyTargetIntent(additionalTarget);\n                }\n            }\n            setAdditionalTargets(additionalTargets);\n        }\n\n        mReplacementExtras = intent.getBundleExtra(Intent.EXTRA_REPLACEMENT_EXTRAS);\n\n        // Do not allow the title to be changed when sharing content\n        CharSequence title = null;\n        if (target != null) {\n            if (!isSendAction(target)) {\n                title = intent.getCharSequenceExtra(Intent.EXTRA_TITLE);\n            } else {\n                Log.w(TAG, \"Ignoring intent's EXTRA_TITLE, deprecated in P. You may wish to set a\"\n                        + \" preview title by using EXTRA_TITLE property of the wrapped\"\n                        + \" EXTRA_INTENT.\");\n            }\n        }\n\n        int defaultTitleRes = 0;\n        if (title == null) {\n            defaultTitleRes = com.android.internal.R.string.chooseActivity;\n        }\n\n        Parcelable[] pa = intent.getParcelableArrayExtra(Intent.EXTRA_INITIAL_INTENTS);\n        Intent[] initialIntents = null;\n        if (pa != null) {\n            int count = Math.min(pa.length, MAX_EXTRA_INITIAL_INTENTS);\n            initialIntents = new Intent[count];\n            for (int i = 0; i < count; i++) {\n                if (!(pa[i] instanceof Intent)) {\n                    Log.w(TAG, \"Initial intent #\" + i + \" not an Intent: \" + pa[i]);\n                    finish();\n                    super.onCreate(null);\n                    return;\n                }\n                final Intent in = (Intent) pa[i];\n                modifyTargetIntent(in);\n                initialIntents[i] = in;\n            }\n        }\n\n        mReferrerFillInIntent = new Intent().putExtra(Intent.EXTRA_REFERRER, getReferrer());\n\n        mChosenComponentSender = intent.getParcelableExtra(\n                Intent.EXTRA_CHOSEN_COMPONENT_INTENT_SENDER);\n        mRefinementIntentSender = intent.getParcelableExtra(\n                Intent.EXTRA_CHOOSER_REFINEMENT_INTENT_SENDER);\n        setSafeForwardingMode(true);\n\n        mPinnedSharedPrefs = getPinnedSharedPrefs(this);\n\n        pa = intent.getParcelableArrayExtra(Intent.EXTRA_EXCLUDE_COMPONENTS);\n\n\n        // Exclude out Nearby from main list if chip is present, to avoid duplication\n        ComponentName nearbySharingComponent = getNearbySharingComponent();\n        boolean shouldFilterNearby = !shouldNearbyShareBeFirstInRankedRow()\n                && nearbySharingComponent != null;\n\n        if (pa != null) {\n            ComponentName[] names = new ComponentName[pa.length + (shouldFilterNearby ? 1 : 0)];\n            for (int i = 0; i < pa.length; i++) {\n                if (!(pa[i] instanceof ComponentName)) {\n                    Log.w(TAG, \"Filtered component #\" + i + \" not a ComponentName: \" + pa[i]);\n                    names = null;\n                    break;\n                }\n                names[i] = (ComponentName) pa[i];\n            }\n            if (shouldFilterNearby) {\n                names[names.length - 1] = nearbySharingComponent;\n            }\n\n            mFilteredComponentNames = names;\n        } else if (shouldFilterNearby) {\n            mFilteredComponentNames = new ComponentName[1];\n            mFilteredComponentNames[0] = nearbySharingComponent;\n        }\n\n        pa = intent.getParcelableArrayExtra(Intent.EXTRA_CHOOSER_TARGETS);\n        if (pa != null) {\n            int count = Math.min(pa.length, MAX_EXTRA_CHOOSER_TARGETS);\n            ChooserTarget[] targets = new ChooserTarget[count];\n            for (int i = 0; i < count; i++) {\n                if (!(pa[i] instanceof ChooserTarget)) {\n                    Log.w(TAG, \"Chooser target #\" + i + \" not a ChooserTarget: \" + pa[i]);\n                    targets = null;\n                    break;\n                }\n                ChooserTarget chooserTarget = (ChooserTarget) pa[i];\n                if (!hasValidIcon(chooserTarget)) {\n                    chooserTarget = removeIcon(chooserTarget);\n                }\n                targets[i] = chooserTarget;\n            }\n            mCallerChooserTargets = targets;\n        }\n\n        mMaxTargetsPerRow = getResources().getInteger(R.integer.config_chooser_max_targets_per_row);\n        mShouldDisplayLandscape =\n                shouldDisplayLandscape(getResources().getConfiguration().orientation);\n        setRetainInOnStop(intent.getBooleanExtra(EXTRA_PRIVATE_RETAIN_IN_ON_STOP, false));\n        super.onCreate(savedInstanceState, target, title, defaultTitleRes, initialIntents,\n                null, false);\n\n        mChooserShownTime = System.currentTimeMillis();\n        final long systemCost = mChooserShownTime - intentReceivedTime;\n\n        getMetricsLogger().write(new LogMaker(MetricsEvent.ACTION_ACTIVITY_CHOOSER_SHOWN)\n                .setSubtype(isWorkProfile() ? MetricsEvent.MANAGED_PROFILE :\n                        MetricsEvent.PARENT_PROFILE)\n                .addTaggedData(MetricsEvent.FIELD_SHARESHEET_MIMETYPE, target.getType())\n                .addTaggedData(MetricsEvent.FIELD_TIME_TO_APP_TARGETS, systemCost));\n\n        if (mResolverDrawerLayout != null) {\n            mResolverDrawerLayout.addOnLayoutChangeListener(this::handleLayoutChange);\n\n            // expand/shrink direct share 4 -> 8 viewgroup\n            if (isSendAction(target)) {\n                mResolverDrawerLayout.setOnScrollChangeListener(this::handleScroll);\n            }\n\n            mResolverDrawerLayout.setOnCollapsedChangedListener(\n                    new ResolverDrawerLayout.OnCollapsedChangedListener() {\n\n                        // Only consider one expansion per activity creation\n                        private boolean mWrittenOnce = false;\n\n                        @Override\n                        public void onCollapsedChanged(boolean isCollapsed) {\n                            if (!isCollapsed && !mWrittenOnce) {\n                                incrementNumSheetExpansions();\n                                mWrittenOnce = true;\n                            }\n                            getChooserActivityLogger()\n                                    .logSharesheetExpansionChanged(isCollapsed);\n                        }\n                    });\n        }\n\n        if (DEBUG) {\n            Log.d(TAG, \"System Time Cost is \" + systemCost);\n        }\n\n        getChooserActivityLogger().logShareStarted(\n                FrameworkStatsLog.SHARESHEET_STARTED,\n                getReferrerPackageName(),\n                target.getType(),\n                mCallerChooserTargets == null ? 0 : mCallerChooserTargets.length,\n                initialIntents == null ? 0 : initialIntents.length,\n                isWorkProfile(),\n                findPreferredContentPreview(getTargetIntent(), getContentResolver()),\n                target.getAction()\n        );\n        mDirectShareShortcutInfoCache = new HashMap<>();\n\n        setEnterSharedElementCallback(new SharedElementCallback() {\n            @Override\n            public void onMapSharedElements(List<String> names, Map<String, View> sharedElements) {\n                if (mRemoveSharedElements) {\n                    names.remove(FIRST_IMAGE_PREVIEW_TRANSITION_NAME);\n                    sharedElements.remove(FIRST_IMAGE_PREVIEW_TRANSITION_NAME);\n                }\n                super.onMapSharedElements(names, sharedElements);\n                mRemoveSharedElements = false;\n            }\n        });\n        mEnterTransitionAnimationDelegate.postponeTransition();\n    }\n\n    @Override\n    protected int appliedThemeResId() {\n        return R.style.Theme_DeviceDefault_Chooser;\n    }\n\n    private AppPredictor setupAppPredictorForUser(UserHandle userHandle,\n            AppPredictor.Callback appPredictorCallback) {\n        AppPredictor appPredictor = getAppPredictorForDirectShareIfEnabled(userHandle);\n        if (appPredictor == null) {\n            return null;\n        }\n        mDirectShareAppTargetCache = new HashMap<>();\n        appPredictor.registerPredictionUpdates(this.getMainExecutor(), appPredictorCallback);\n        return appPredictor;\n    }\n\n    private AppPredictor.Callback createAppPredictorCallback(\n            ChooserListAdapter chooserListAdapter) {\n        return resultList -> {\n            if (isFinishing() || isDestroyed()) {\n                return;\n            }\n            if (chooserListAdapter.getCount() == 0) {\n                return;\n            }\n            if (resultList.isEmpty()\n                    && shouldQueryShortcutManager(chooserListAdapter.getUserHandle())) {\n                // APS may be disabled, so try querying targets ourselves.\n                queryDirectShareTargets(chooserListAdapter, true);\n                return;\n            }\n            final List<ShortcutManager.ShareShortcutInfo> shareShortcutInfos =\n                    new ArrayList<>();\n\n            List<AppTarget> shortcutResults = new ArrayList<>();\n            for (AppTarget appTarget : resultList) {\n                if (appTarget.getShortcutInfo() == null) {\n                    continue;\n                }\n                shortcutResults.add(appTarget);\n            }\n            resultList = shortcutResults;\n            for (AppTarget appTarget : resultList) {\n                shareShortcutInfos.add(new ShortcutManager.ShareShortcutInfo(\n                        appTarget.getShortcutInfo(),\n                        new ComponentName(\n                                appTarget.getPackageName(), appTarget.getClassName())));\n            }\n            sendShareShortcutInfoList(shareShortcutInfos, chooserListAdapter, resultList,\n                    chooserListAdapter.getUserHandle());\n        };\n    }\n\n    static SharedPreferences getPinnedSharedPrefs(Context context) {\n        // The code below is because in the android:ui process, no one can hear you scream.\n        // The package info in the context isn't initialized in the way it is for normal apps,\n        // so the standard, name-based context.getSharedPreferences doesn't work. Instead, we\n        // build the path manually below using the same policy that appears in ContextImpl.\n        // This fails silently under the hood if there's a problem, so if we find ourselves in\n        // the case where we don't have access to credential encrypted storage we just won't\n        // have our pinned target info.\n        final File prefsFile = new File(new File(\n                Environment.getDataUserCePackageDirectory(StorageManager.UUID_PRIVATE_INTERNAL,\n                        context.getUserId(), context.getPackageName()),\n                \"shared_prefs\"),\n                PINNED_SHARED_PREFS_NAME + \".xml\");\n        return context.getSharedPreferences(prefsFile, MODE_PRIVATE);\n    }\n\n    @Override\n    protected AbstractMultiProfilePagerAdapter createMultiProfilePagerAdapter(\n            Intent[] initialIntents,\n            List<ResolveInfo> rList,\n            boolean filterLastUsed) {\n        if (shouldShowTabs()) {\n            mChooserMultiProfilePagerAdapter = createChooserMultiProfilePagerAdapterForTwoProfiles(\n                    initialIntents, rList, filterLastUsed);\n        } else {\n            mChooserMultiProfilePagerAdapter = createChooserMultiProfilePagerAdapterForOneProfile(\n                    initialIntents, rList, filterLastUsed);\n        }\n        return mChooserMultiProfilePagerAdapter;\n    }\n\n    private ChooserMultiProfilePagerAdapter createChooserMultiProfilePagerAdapterForOneProfile(\n            Intent[] initialIntents,\n            List<ResolveInfo> rList,\n            boolean filterLastUsed) {\n        ChooserGridAdapter adapter = createChooserGridAdapter(\n                /* context */ this,\n                /* payloadIntents */ mIntents,\n                initialIntents,\n                rList,\n                filterLastUsed,\n                /* userHandle */ UserHandle.of(UserHandle.myUserId()));\n        return new ChooserMultiProfilePagerAdapter(\n                /* context */ this,\n                adapter,\n                getPersonalProfileUserHandle(),\n                /* workProfileUserHandle= */ null,\n                isSendAction(getTargetIntent()), mMaxTargetsPerRow);\n    }\n\n    private ChooserMultiProfilePagerAdapter createChooserMultiProfilePagerAdapterForTwoProfiles(\n            Intent[] initialIntents,\n            List<ResolveInfo> rList,\n            boolean filterLastUsed) {\n        int selectedProfile = findSelectedProfile();\n        ChooserGridAdapter personalAdapter = createChooserGridAdapter(\n                /* context */ this,\n                /* payloadIntents */ mIntents,\n                selectedProfile == PROFILE_PERSONAL ? initialIntents : null,\n                rList,\n                filterLastUsed,\n                /* userHandle */ getPersonalProfileUserHandle());\n        ChooserGridAdapter workAdapter = createChooserGridAdapter(\n                /* context */ this,\n                /* payloadIntents */ mIntents,\n                selectedProfile == PROFILE_WORK ? initialIntents : null,\n                rList,\n                filterLastUsed,\n                /* userHandle */ getWorkProfileUserHandle());\n        return new ChooserMultiProfilePagerAdapter(\n                /* context */ this,\n                personalAdapter,\n                workAdapter,\n                selectedProfile,\n                getPersonalProfileUserHandle(),\n                getWorkProfileUserHandle(),\n                isSendAction(getTargetIntent()), mMaxTargetsPerRow);\n    }\n\n    private int findSelectedProfile() {\n        int selectedProfile = getSelectedProfileExtra();\n        if (selectedProfile == -1) {\n            selectedProfile = getProfileForUser(getUser());\n        }\n        return selectedProfile;\n    }\n\n    @Override\n    protected boolean postRebuildList(boolean rebuildCompleted) {\n        updateStickyContentPreview();\n        if (shouldShowStickyContentPreview()\n                || mChooserMultiProfilePagerAdapter\n                        .getCurrentRootAdapter().getSystemRowCount() != 0) {\n            logActionShareWithPreview();\n        }\n        return postRebuildListInternal(rebuildCompleted);\n    }\n\n    /**\n     * Returns true if app prediction service is defined and the component exists on device.\n     */\n    private boolean isAppPredictionServiceAvailable() {\n        return getPackageManager().getAppPredictionServicePackageName() != null;\n    }\n\n    /**\n     * Check if the profile currently used is a work profile.\n     * @return true if it is work profile, false if it is parent profile (or no work profile is\n     * set up)\n     */\n    protected boolean isWorkProfile() {\n        return getSystemService(UserManager.class)\n                .getUserInfo(UserHandle.myUserId()).isManagedProfile();\n    }\n\n    @Override\n    protected PackageMonitor createPackageMonitor(ResolverListAdapter listAdapter) {\n        return new PackageMonitor() {\n            @Override\n            public void onSomePackagesChanged() {\n                handlePackagesChanged(listAdapter);\n            }\n        };\n    }\n\n    /**\n     * Update UI to reflect changes in data.\n     */\n    public void handlePackagesChanged() {\n        handlePackagesChanged(/* listAdapter */ null);\n    }\n\n    /**\n     * Update UI to reflect changes in data.\n     * <p>If {@code listAdapter} is {@code null}, both profile list adapters are updated if\n     * available.\n     */\n    private void handlePackagesChanged(@Nullable ResolverListAdapter listAdapter) {\n        // Refresh pinned items\n        mPinnedSharedPrefs = getPinnedSharedPrefs(this);\n        if (listAdapter == null) {\n            mChooserMultiProfilePagerAdapter.getActiveListAdapter().handlePackagesChanged();\n            if (mChooserMultiProfilePagerAdapter.getCount() > 1) {\n                mChooserMultiProfilePagerAdapter.getInactiveListAdapter().handlePackagesChanged();\n            }\n        } else {\n            listAdapter.handlePackagesChanged();\n        }\n        updateProfileViewButton();\n    }\n\n    private void onCopyButtonClicked(View v) {\n        Intent targetIntent = getTargetIntent();\n        if (targetIntent == null) {\n            finish();\n        } else {\n            final String action = targetIntent.getAction();\n\n            ClipData clipData = null;\n            if (Intent.ACTION_SEND.equals(action)) {\n                String extraText = targetIntent.getStringExtra(Intent.EXTRA_TEXT);\n                Uri extraStream = targetIntent.getParcelableExtra(Intent.EXTRA_STREAM);\n\n                if (extraText != null) {\n                    clipData = ClipData.newPlainText(null, extraText);\n                } else if (extraStream != null) {\n                    clipData = ClipData.newUri(getContentResolver(), null, extraStream);\n                } else {\n                    Log.w(TAG, \"No data available to copy to clipboard\");\n                    return;\n                }\n            } else if (Intent.ACTION_SEND_MULTIPLE.equals(action)) {\n                final ArrayList<Uri> streams = targetIntent.getParcelableArrayListExtra(\n                        Intent.EXTRA_STREAM);\n                clipData = ClipData.newUri(getContentResolver(), null, streams.get(0));\n                for (int i = 1; i < streams.size(); i++) {\n                    clipData.addItem(getContentResolver(), new ClipData.Item(streams.get(i)));\n                }\n            } else {\n                // expected to only be visible with ACTION_SEND or ACTION_SEND_MULTIPLE\n                // so warn about unexpected action\n                Log.w(TAG, \"Action (\" + action + \") not supported for copying to clipboard\");\n                return;\n            }\n\n            ClipboardManager clipboardManager = (ClipboardManager) getSystemService(\n                    Context.CLIPBOARD_SERVICE);\n            clipboardManager.setPrimaryClipAsPackage(clipData, getReferrerPackageName());\n\n            // Log share completion via copy\n            LogMaker targetLogMaker = new LogMaker(\n                    MetricsEvent.ACTION_ACTIVITY_CHOOSER_PICKED_SYSTEM_TARGET).setSubtype(1);\n            getMetricsLogger().write(targetLogMaker);\n            getChooserActivityLogger().logShareTargetSelected(\n                    SELECTION_TYPE_COPY,\n                    \"\",\n                    -1,\n                    false);\n\n            setResult(RESULT_OK);\n            finish();\n        }\n    }\n\n    @Override\n    protected void onResume() {\n        super.onResume();\n        Log.d(TAG, \"onResume: \" + getComponentName().flattenToShortString());\n    }\n\n    @Override\n    public void onConfigurationChanged(Configuration newConfig) {\n        super.onConfigurationChanged(newConfig);\n        ViewPager viewPager = findViewById(R.id.profile_pager);\n        if (viewPager.isLayoutRtl()) {\n            mMultiProfilePagerAdapter.setupViewPager(viewPager);\n        }\n\n        mShouldDisplayLandscape = shouldDisplayLandscape(newConfig.orientation);\n        mMaxTargetsPerRow = getResources().getInteger(R.integer.config_chooser_max_targets_per_row);\n        adjustPreviewWidth(newConfig.orientation, null);\n        updateStickyContentPreview();\n        updateTabPadding();\n    }\n\n    private boolean shouldDisplayLandscape(int orientation) {\n        // Sharesheet fixes the # of items per row and therefore can not correctly lay out\n        // when in the restricted size of multi-window mode. In the future, would be nice\n        // to use minimum dp size requirements instead\n        return orientation == Configuration.ORIENTATION_LANDSCAPE && !isInMultiWindowMode();\n    }\n\n    private void adjustPreviewWidth(int orientation, View parent) {\n        int width = -1;\n        if (mShouldDisplayLandscape) {\n            width = getResources().getDimensionPixelSize(R.dimen.chooser_preview_width);\n        }\n\n        parent = parent == null ? getWindow().getDecorView() : parent;\n\n        updateLayoutWidth(R.id.content_preview_text_layout, width, parent);\n        updateLayoutWidth(R.id.content_preview_title_layout, width, parent);\n        updateLayoutWidth(R.id.content_preview_file_layout, width, parent);\n    }\n\n    private void updateTabPadding() {\n        if (shouldShowTabs()) {\n            View tabs = findViewById(R.id.tabs);\n            float iconSize = getResources().getDimension(R.dimen.chooser_icon_size);\n            // The entire width consists of icons or padding. Divide the item padding in half to get\n            // paddingHorizontal.\n            float padding = (tabs.getWidth() - mMaxTargetsPerRow * iconSize)\n                    / mMaxTargetsPerRow / 2;\n            // Subtract the margin the buttons already have.\n            padding -= getResources().getDimension(R.dimen.resolver_profile_tab_margin);\n            tabs.setPadding((int) padding, 0, (int) padding, 0);\n        }\n    }\n\n    private void updateLayoutWidth(int layoutResourceId, int width, View parent) {\n        View view = parent.findViewById(layoutResourceId);\n        if (view != null && view.getLayoutParams() != null) {\n            LayoutParams params = view.getLayoutParams();\n            params.width = width;\n            view.setLayoutParams(params);\n        }\n    }\n\n    private ViewGroup createContentPreviewView(ViewGroup parent) {\n        Intent targetIntent = getTargetIntent();\n        int previewType = findPreferredContentPreview(targetIntent, getContentResolver());\n        return displayContentPreview(previewType, targetIntent, getLayoutInflater(), parent);\n    }\n\n    @VisibleForTesting\n    protected ComponentName getNearbySharingComponent() {\n        String nearbyComponent = Settings.Secure.getString(\n                getContentResolver(),\n                Settings.Secure.NEARBY_SHARING_COMPONENT);\n        if (TextUtils.isEmpty(nearbyComponent)) {\n            nearbyComponent = getString(R.string.config_defaultNearbySharingComponent);\n        }\n        if (TextUtils.isEmpty(nearbyComponent)) {\n            return null;\n        }\n        return ComponentName.unflattenFromString(nearbyComponent);\n    }\n\n    @VisibleForTesting\n    protected @Nullable ComponentName getEditSharingComponent() {\n        String editorPackage = getApplicationContext().getString(R.string.config_systemImageEditor);\n        if (editorPackage == null || TextUtils.isEmpty(editorPackage)) {\n            return null;\n        }\n        return ComponentName.unflattenFromString(editorPackage);\n    }\n\n    @VisibleForTesting\n    protected TargetInfo getEditSharingTarget(Intent originalIntent) {\n        final ComponentName cn = getEditSharingComponent();\n\n        final Intent resolveIntent = new Intent(originalIntent);\n        resolveIntent.setComponent(cn);\n        resolveIntent.setAction(Intent.ACTION_EDIT);\n        final ResolveInfo ri = getPackageManager().resolveActivity(\n                resolveIntent, PackageManager.GET_META_DATA);\n        if (ri == null || ri.activityInfo == null) {\n            Log.e(TAG, \"Device-specified image edit component (\" + cn\n                    + \") not available\");\n            return null;\n        }\n\n        final DisplayResolveInfo dri = new DisplayResolveInfo(\n                originalIntent, ri, getString(R.string.screenshot_edit), \"\", resolveIntent, null);\n        dri.setDisplayIcon(getDrawable(R.drawable.ic_screenshot_edit));\n        return dri;\n    }\n\n\n    @VisibleForTesting\n    protected TargetInfo getNearbySharingTarget(Intent originalIntent) {\n        final ComponentName cn = getNearbySharingComponent();\n        if (cn == null) return null;\n\n        final Intent resolveIntent = new Intent(originalIntent);\n        resolveIntent.setComponent(cn);\n        final ResolveInfo ri = getPackageManager().resolveActivity(\n                resolveIntent, PackageManager.GET_META_DATA);\n        if (ri == null || ri.activityInfo == null) {\n            Log.e(TAG, \"Device-specified nearby sharing component (\" + cn\n                    + \") not available\");\n            return null;\n        }\n\n        // Allow the nearby sharing component to provide a more appropriate icon and label\n        // for the chip.\n        CharSequence name = null;\n        Drawable icon = null;\n        final Bundle metaData = ri.activityInfo.metaData;\n        if (metaData != null) {\n            try {\n                final Resources pkgRes = getPackageManager().getResourcesForActivity(cn);\n                final int nameResId = metaData.getInt(CHIP_LABEL_METADATA_KEY);\n                name = pkgRes.getString(nameResId);\n                final int resId = metaData.getInt(CHIP_ICON_METADATA_KEY);\n                icon = pkgRes.getDrawable(resId);\n            } catch (Resources.NotFoundException ex) {\n            } catch (NameNotFoundException ex) {\n            }\n        }\n        if (TextUtils.isEmpty(name)) {\n            name = ri.loadLabel(getPackageManager());\n        }\n        if (icon == null) {\n            icon = ri.loadIcon(getPackageManager());\n        }\n\n        final DisplayResolveInfo dri = new DisplayResolveInfo(\n                originalIntent, ri, name, \"\", resolveIntent, null);\n        dri.setDisplayIcon(icon);\n        return dri;\n    }\n\n    private Button createActionButton(Drawable icon, CharSequence title, View.OnClickListener r) {\n        Button b = (Button) LayoutInflater.from(this).inflate(R.layout.chooser_action_button, null);\n        if (icon != null) {\n            final int size = getResources()\n                    .getDimensionPixelSize(R.dimen.chooser_action_button_icon_size);\n            icon.setBounds(0, 0, size, size);\n            b.setCompoundDrawablesRelative(icon, null, null, null);\n        }\n        b.setText(title);\n        b.setOnClickListener(r);\n        return b;\n    }\n\n    private Button createCopyButton() {\n        final Button b = createActionButton(\n                getDrawable(R.drawable.ic_menu_copy_material),\n                getString(R.string.copy), this::onCopyButtonClicked);\n        b.setId(R.id.chooser_copy_button);\n        return b;\n    }\n\n    private @Nullable Button createNearbyButton(Intent originalIntent) {\n        final TargetInfo ti = getNearbySharingTarget(originalIntent);\n        if (ti == null) return null;\n\n        final Button b = createActionButton(\n                ti.getDisplayIcon(this),\n                ti.getDisplayLabel(),\n                (View unused) -> {\n                    // Log share completion via nearby\n                    getChooserActivityLogger().logShareTargetSelected(\n                            SELECTION_TYPE_NEARBY,\n                            \"\",\n                            -1,\n                            false);\n                    // Action bar is user-independent, always start as primary\n                    safelyStartActivityAsUser(ti, getPersonalProfileUserHandle());\n                    finish();\n                }\n        );\n        b.setId(R.id.chooser_nearby_button);\n        return b;\n    }\n\n    private @Nullable Button createEditButton(Intent originalIntent) {\n        final TargetInfo ti = getEditSharingTarget(originalIntent);\n        if (ti == null) return null;\n\n        final Button b = createActionButton(\n                ti.getDisplayIcon(this),\n                ti.getDisplayLabel(),\n                (View unused) -> {\n                    // Log share completion via edit\n                    getChooserActivityLogger().logShareTargetSelected(\n                            SELECTION_TYPE_EDIT,\n                            \"\",\n                            -1,\n                            false);\n                    // Action bar is user-independent, always start as primary\n                    safelyStartActivityAsUser(ti, getPersonalProfileUserHandle());\n                    finish();\n                }\n        );\n        b.setId(R.id.chooser_edit_button);\n        return b;\n    }\n\n    private void addActionButton(ViewGroup parent, Button b) {\n        if (b == null) return;\n        final ViewGroup.MarginLayoutParams lp = new ViewGroup.MarginLayoutParams(\n                        LayoutParams.WRAP_CONTENT,\n                        LayoutParams.WRAP_CONTENT\n                );\n        final int gap = getResources().getDimensionPixelSize(R.dimen.resolver_icon_margin) / 2;\n        lp.setMarginsRelative(gap, 0, gap, 0);\n        parent.addView(b, lp);\n    }\n\n    private ViewGroup displayContentPreview(@ContentPreviewType int previewType,\n            Intent targetIntent, LayoutInflater layoutInflater, ViewGroup parent) {\n        ViewGroup layout = null;\n\n        switch (previewType) {\n            case CONTENT_PREVIEW_TEXT:\n                layout = displayTextContentPreview(targetIntent, layoutInflater, parent);\n                break;\n            case CONTENT_PREVIEW_IMAGE:\n                layout = displayImageContentPreview(targetIntent, layoutInflater, parent);\n                break;\n            case CONTENT_PREVIEW_FILE:\n                layout = displayFileContentPreview(targetIntent, layoutInflater, parent);\n                break;\n            default:\n                Log.e(TAG, \"Unexpected content preview type: \" + previewType);\n        }\n\n        if (layout != null) {\n            adjustPreviewWidth(getResources().getConfiguration().orientation, layout);\n        }\n        if (previewType != CONTENT_PREVIEW_IMAGE) {\n            mEnterTransitionAnimationDelegate.markImagePreviewReady();\n        }\n\n        return layout;\n    }\n\n    private ViewGroup displayTextContentPreview(Intent targetIntent, LayoutInflater layoutInflater,\n            ViewGroup parent) {\n        ViewGroup contentPreviewLayout = (ViewGroup) layoutInflater.inflate(\n                R.layout.chooser_grid_preview_text, parent, false);\n\n        final ViewGroup actionRow =\n                (ViewGroup) contentPreviewLayout.findViewById(R.id.chooser_action_row);\n        addActionButton(actionRow, createCopyButton());\n        if (shouldNearbyShareBeIncludedAsActionButton()) {\n            addActionButton(actionRow, createNearbyButton(targetIntent));\n        }\n\n        CharSequence sharingText = targetIntent.getCharSequenceExtra(Intent.EXTRA_TEXT);\n        if (sharingText == null) {\n            contentPreviewLayout.findViewById(R.id.content_preview_text_layout).setVisibility(\n                    View.GONE);\n        } else {\n            TextView textView = contentPreviewLayout.findViewById(R.id.content_preview_text);\n            textView.setText(sharingText);\n        }\n\n        String previewTitle = targetIntent.getStringExtra(Intent.EXTRA_TITLE);\n        if (TextUtils.isEmpty(previewTitle)) {\n            contentPreviewLayout.findViewById(R.id.content_preview_title_layout).setVisibility(\n                    View.GONE);\n        } else {\n            TextView previewTitleView = contentPreviewLayout.findViewById(\n                    R.id.content_preview_title);\n            previewTitleView.setText(previewTitle);\n\n            ClipData previewData = targetIntent.getClipData();\n            Uri previewThumbnail = null;\n            if (previewData != null) {\n                if (previewData.getItemCount() > 0) {\n                    ClipData.Item previewDataItem = previewData.getItemAt(0);\n                    previewThumbnail = previewDataItem.getUri();\n                }\n            }\n\n            ImageView previewThumbnailView = contentPreviewLayout.findViewById(\n                    R.id.content_preview_thumbnail);\n            if (!validForContentPreview(previewThumbnail)) {\n                previewThumbnailView.setVisibility(View.GONE);\n            } else {\n                mPreviewCoord = new ContentPreviewCoordinator(contentPreviewLayout, false);\n                mPreviewCoord.loadUriIntoView(R.id.content_preview_thumbnail, previewThumbnail, 0);\n            }\n        }\n\n        return contentPreviewLayout;\n    }\n\n    private ViewGroup displayImageContentPreview(Intent targetIntent, LayoutInflater layoutInflater,\n            ViewGroup parent) {\n        ViewGroup contentPreviewLayout = (ViewGroup) layoutInflater.inflate(\n                R.layout.chooser_grid_preview_image, parent, false);\n        ViewGroup imagePreview = contentPreviewLayout.findViewById(R.id.content_preview_image_area);\n\n        final ViewGroup actionRow =\n                (ViewGroup) contentPreviewLayout.findViewById(R.id.chooser_action_row);\n        //TODO: addActionButton(actionRow, createCopyButton());\n        if (shouldNearbyShareBeIncludedAsActionButton()) {\n            addActionButton(actionRow, createNearbyButton(targetIntent));\n        }\n        addActionButton(actionRow, createEditButton(targetIntent));\n\n        mPreviewCoord = new ContentPreviewCoordinator(contentPreviewLayout, false);\n\n        String action = targetIntent.getAction();\n        if (Intent.ACTION_SEND.equals(action)) {\n            Uri uri = targetIntent.getParcelableExtra(Intent.EXTRA_STREAM);\n            if (!validForContentPreview(uri)) {\n                contentPreviewLayout.setVisibility(View.GONE);\n                return contentPreviewLayout;\n            }\n            imagePreview.findViewById(R.id.content_preview_image_1_large)\n                    .setTransitionName(ChooserActivity.FIRST_IMAGE_PREVIEW_TRANSITION_NAME);\n            mPreviewCoord.loadUriIntoView(R.id.content_preview_image_1_large, uri, 0);\n        } else {\n            ContentResolver resolver = getContentResolver();\n\n            List<Uri> uris = targetIntent.getParcelableArrayListExtra(Intent.EXTRA_STREAM);\n            List<Uri> imageUris = new ArrayList<>();\n            for (Uri uri : uris) {\n                if (validForContentPreview(uri) && isImageType(resolver.getType(uri))) {\n                    imageUris.add(uri);\n                }\n            }\n\n            if (imageUris.size() == 0) {\n                Log.i(TAG, \"Attempted to display image preview area with zero\"\n                        + \" available images detected in EXTRA_STREAM list\");\n                imagePreview.setVisibility(View.GONE);\n                return contentPreviewLayout;\n            }\n\n            imagePreview.findViewById(R.id.content_preview_image_1_large)\n                    .setTransitionName(ChooserActivity.FIRST_IMAGE_PREVIEW_TRANSITION_NAME);\n            mPreviewCoord.loadUriIntoView(R.id.content_preview_image_1_large, imageUris.get(0), 0);\n\n            if (imageUris.size() == 2) {\n                mPreviewCoord.loadUriIntoView(R.id.content_preview_image_2_large,\n                        imageUris.get(1), 0);\n            } else if (imageUris.size() > 2) {\n                mPreviewCoord.loadUriIntoView(R.id.content_preview_image_2_small,\n                        imageUris.get(1), 0);\n                mPreviewCoord.loadUriIntoView(R.id.content_preview_image_3_small,\n                        imageUris.get(2), imageUris.size() - 3);\n            }\n        }\n\n        return contentPreviewLayout;\n    }\n\n    private static class FileInfo {\n        public final String name;\n        public final boolean hasThumbnail;\n\n        FileInfo(String name, boolean hasThumbnail) {\n            this.name = name;\n            this.hasThumbnail = hasThumbnail;\n        }\n    }\n\n    /**\n     * Wrapping the ContentResolver call to expose for easier mocking,\n     * and to avoid mocking Android core classes.\n     */\n    @VisibleForTesting\n    public Cursor queryResolver(ContentResolver resolver, Uri uri) {\n        return resolver.query(uri, null, null, null, null);\n    }\n\n    private FileInfo extractFileInfo(Uri uri, ContentResolver resolver) {\n        String fileName = null;\n        boolean hasThumbnail = false;\n\n        try (Cursor cursor = queryResolver(resolver, uri)) {\n            if (cursor != null && cursor.getCount() > 0) {\n                int nameIndex = cursor.getColumnIndex(OpenableColumns.DISPLAY_NAME);\n                int titleIndex = cursor.getColumnIndex(Downloads.Impl.COLUMN_TITLE);\n                int flagsIndex = cursor.getColumnIndex(DocumentsContract.Document.COLUMN_FLAGS);\n\n                cursor.moveToFirst();\n                if (nameIndex != -1) {\n                    fileName = cursor.getString(nameIndex);\n                } else if (titleIndex != -1) {\n                    fileName = cursor.getString(titleIndex);\n                }\n\n                if (flagsIndex != -1) {\n                    hasThumbnail = (cursor.getInt(flagsIndex)\n                            & DocumentsContract.Document.FLAG_SUPPORTS_THUMBNAIL) != 0;\n                }\n            }\n        } catch (SecurityException | NullPointerException e) {\n            logContentPreviewWarning(uri);\n        }\n\n        if (TextUtils.isEmpty(fileName)) {\n            fileName = uri.getPath();\n            int index = fileName.lastIndexOf('/');\n            if (index != -1) {\n                fileName = fileName.substring(index + 1);\n            }\n        }\n\n        return new FileInfo(fileName, hasThumbnail);\n    }\n\n    private void logContentPreviewWarning(Uri uri) {\n        // The ContentResolver already logs the exception. Log something more informative.\n        Log.w(TAG, \"Could not load (\" + uri.toString() + \") thumbnail/name for preview. If \"\n                + \"desired, consider using Intent#createChooser to launch the ChooserActivity, \"\n                + \"and set your Intent's clipData and flags in accordance with that method's \"\n                + \"documentation\");\n    }\n\n    private ViewGroup displayFileContentPreview(Intent targetIntent, LayoutInflater layoutInflater,\n            ViewGroup parent) {\n\n        ViewGroup contentPreviewLayout = (ViewGroup) layoutInflater.inflate(\n                R.layout.chooser_grid_preview_file, parent, false);\n\n        final ViewGroup actionRow =\n                (ViewGroup) contentPreviewLayout.findViewById(R.id.chooser_action_row);\n        //TODO(b/120417119): addActionButton(actionRow, createCopyButton());\n        if (shouldNearbyShareBeIncludedAsActionButton()) {\n            addActionButton(actionRow, createNearbyButton(targetIntent));\n        }\n\n        String action = targetIntent.getAction();\n        if (Intent.ACTION_SEND.equals(action)) {\n            Uri uri = targetIntent.getParcelableExtra(Intent.EXTRA_STREAM);\n            if (!validForContentPreview(uri)) {\n                contentPreviewLayout.setVisibility(View.GONE);\n                return contentPreviewLayout;\n            }\n            loadFileUriIntoView(uri, contentPreviewLayout);\n        } else {\n            List<Uri> uris = targetIntent.getParcelableArrayListExtra(Intent.EXTRA_STREAM);\n            uris = uris.stream()\n                    .filter(ChooserActivity::validForContentPreview)\n                    .collect(Collectors.toList());\n            int uriCount = uris.size();\n\n            if (uriCount == 0) {\n                contentPreviewLayout.setVisibility(View.GONE);\n                Log.i(TAG,\n                        \"Appears to be no uris available in EXTRA_STREAM, removing \"\n                                + \"preview area\");\n                return contentPreviewLayout;\n            } else if (uriCount == 1) {\n                loadFileUriIntoView(uris.get(0), contentPreviewLayout);\n            } else {\n                FileInfo fileInfo = extractFileInfo(uris.get(0), getContentResolver());\n                int remUriCount = uriCount - 1;\n                Map<String, Object> arguments = new HashMap<>();\n                arguments.put(PLURALS_COUNT, remUriCount);\n                arguments.put(PLURALS_FILE_NAME, fileInfo.name);\n                String fileName = PluralsMessageFormatter.format(\n                        getResources(),\n                        arguments,\n                        R.string.file_count);\n\n                TextView fileNameView = contentPreviewLayout.findViewById(\n                        R.id.content_preview_filename);\n                fileNameView.setText(fileName);\n\n                View thumbnailView = contentPreviewLayout.findViewById(\n                        R.id.content_preview_file_thumbnail);\n                thumbnailView.setVisibility(View.GONE);\n\n                ImageView fileIconView = contentPreviewLayout.findViewById(\n                        R.id.content_preview_file_icon);\n                fileIconView.setVisibility(View.VISIBLE);\n                fileIconView.setImageResource(R.drawable.ic_file_copy);\n            }\n        }\n\n        return contentPreviewLayout;\n    }\n\n    private void loadFileUriIntoView(final Uri uri, final View parent) {\n        FileInfo fileInfo = extractFileInfo(uri, getContentResolver());\n\n        TextView fileNameView = parent.findViewById(R.id.content_preview_filename);\n        fileNameView.setText(fileInfo.name);\n\n        if (fileInfo.hasThumbnail) {\n            mPreviewCoord = new ContentPreviewCoordinator(parent, false);\n            mPreviewCoord.loadUriIntoView(R.id.content_preview_file_thumbnail, uri, 0);\n        } else {\n            View thumbnailView = parent.findViewById(R.id.content_preview_file_thumbnail);\n            thumbnailView.setVisibility(View.GONE);\n\n            ImageView fileIconView = parent.findViewById(R.id.content_preview_file_icon);\n            fileIconView.setVisibility(View.VISIBLE);\n            fileIconView.setImageResource(R.drawable.chooser_file_generic);\n        }\n    }\n\n    /**\n     * Indicate if the incoming content URI should be allowed.\n     *\n     * @param uri the uri to test\n     * @return true if the URI is allowed for content preview\n     */\n    private static boolean validForContentPreview(Uri uri) throws SecurityException {\n        if (uri == null) {\n            return false;\n        }\n        int userId = getUserIdFromUri(uri, UserHandle.USER_CURRENT);\n        if (userId != UserHandle.USER_CURRENT && userId != UserHandle.myUserId()) {\n            Log.e(TAG, \"dropped invalid content URI belonging to user \" + userId);\n            return false;\n        }\n        return true;\n    }\n\n    @VisibleForTesting\n    protected boolean isImageType(String mimeType) {\n        return mimeType != null && mimeType.startsWith(\"image/\");\n    }\n\n    @ContentPreviewType\n    private int findPreferredContentPreview(Uri uri, ContentResolver resolver) {\n        if (uri == null) {\n            return CONTENT_PREVIEW_TEXT;\n        }\n\n        String mimeType = resolver.getType(uri);\n        return isImageType(mimeType) ? CONTENT_PREVIEW_IMAGE : CONTENT_PREVIEW_FILE;\n    }\n\n    /**\n     * In {@link android.content.Intent#getType}, the app may specify a very general\n     * mime-type that broadly covers all data being shared, such as {@literal *}/*\n     * when sending an image and text. We therefore should inspect each item for the\n     * the preferred type, in order of IMAGE, FILE, TEXT.\n     */\n    @ContentPreviewType\n    private int findPreferredContentPreview(Intent targetIntent, ContentResolver resolver) {\n        String action = targetIntent.getAction();\n        if (Intent.ACTION_SEND.equals(action)) {\n            Uri uri = targetIntent.getParcelableExtra(Intent.EXTRA_STREAM);\n            return findPreferredContentPreview(uri, resolver);\n        } else if (Intent.ACTION_SEND_MULTIPLE.equals(action)) {\n            List<Uri> uris = targetIntent.getParcelableArrayListExtra(Intent.EXTRA_STREAM);\n            if (uris == null || uris.isEmpty()) {\n                return CONTENT_PREVIEW_TEXT;\n            }\n\n            for (Uri uri : uris) {\n                // Defaulting to file preview when there are mixed image/file types is\n                // preferable, as it shows the user the correct number of items being shared\n                if (findPreferredContentPreview(uri, resolver) == CONTENT_PREVIEW_FILE) {\n                    return CONTENT_PREVIEW_FILE;\n                }\n            }\n\n            return CONTENT_PREVIEW_IMAGE;\n        }\n\n        return CONTENT_PREVIEW_TEXT;\n    }\n\n    private int getNumSheetExpansions() {\n        return getPreferences(Context.MODE_PRIVATE).getInt(PREF_NUM_SHEET_EXPANSIONS, 0);\n    }\n\n    private void incrementNumSheetExpansions() {\n        getPreferences(Context.MODE_PRIVATE).edit().putInt(PREF_NUM_SHEET_EXPANSIONS,\n                getNumSheetExpansions() + 1).apply();\n    }\n\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n\n        if (isFinishing()) {\n            mLatencyTracker.onActionCancel(ACTION_LOAD_SHARE_SHEET);\n        }\n\n        if (mRefinementResultReceiver != null) {\n            mRefinementResultReceiver.destroy();\n            mRefinementResultReceiver = null;\n        }\n        mChooserHandler.removeAllMessages();\n\n        if (mPreviewCoord != null) mPreviewCoord.cancelLoads();\n\n        mChooserMultiProfilePagerAdapter.getActiveListAdapter().destroyAppPredictor();\n        if (mChooserMultiProfilePagerAdapter.getInactiveListAdapter() != null) {\n            mChooserMultiProfilePagerAdapter.getInactiveListAdapter().destroyAppPredictor();\n        }\n    }\n\n    @Override // ResolverListCommunicator\n    public Intent getReplacementIntent(ActivityInfo aInfo, Intent defIntent) {\n        Intent result = defIntent;\n        if (mReplacementExtras != null) {\n            final Bundle replExtras = mReplacementExtras.getBundle(aInfo.packageName);\n            if (replExtras != null) {\n                result = new Intent(defIntent);\n                result.putExtras(replExtras);\n            }\n        }\n        if (aInfo.name.equals(IntentForwarderActivity.FORWARD_INTENT_TO_PARENT)\n                || aInfo.name.equals(IntentForwarderActivity.FORWARD_INTENT_TO_MANAGED_PROFILE)) {\n            result = Intent.createChooser(result,\n                    getIntent().getCharSequenceExtra(Intent.EXTRA_TITLE));\n\n            // Don't auto-launch single intents if the intent is being forwarded. This is done\n            // because automatically launching a resolving application as a response to the user\n            // action of switching accounts is pretty unexpected.\n            result.putExtra(Intent.EXTRA_AUTO_LAUNCH_SINGLE_CHOICE, false);\n        }\n        return result;\n    }\n\n    @Override\n    public void onActivityStarted(TargetInfo cti) {\n        if (mChosenComponentSender != null) {\n            final ComponentName target = cti.getResolvedComponentName();\n            if (target != null) {\n                final Intent fillIn = new Intent().putExtra(Intent.EXTRA_CHOSEN_COMPONENT, target);\n                try {\n                    mChosenComponentSender.sendIntent(this, Activity.RESULT_OK, fillIn, null, null);\n                } catch (IntentSender.SendIntentException e) {\n                    Slog.e(TAG, \"Unable to launch supplied IntentSender to report \"\n                            + \"the chosen component: \" + e);\n                }\n            }\n        }\n    }\n\n    @Override\n    public void addUseDifferentAppLabelIfNecessary(ResolverListAdapter adapter) {\n        if (mCallerChooserTargets != null && mCallerChooserTargets.length > 0) {\n            mChooserMultiProfilePagerAdapter.getActiveListAdapter().addServiceResults(\n                    /* origTarget */ null,\n                    Lists.newArrayList(mCallerChooserTargets),\n                    TARGET_TYPE_DEFAULT,\n                    /* directShareShortcutInfoCache */ null);\n        }\n    }\n\n    @Override\n    public int getLayoutResource() {\n        return R.layout.chooser_grid;\n    }\n\n    @Override // ResolverListCommunicator\n    public boolean shouldGetActivityMetadata() {\n        return true;\n    }\n\n    @Override\n    public boolean shouldAutoLaunchSingleChoice(TargetInfo target) {\n        // Note that this is only safe because the Intent handled by the ChooserActivity is\n        // guaranteed to contain no extras unknown to the local ClassLoader. That is why this\n        // method can not be replaced in the ResolverActivity whole hog.\n        if (!super.shouldAutoLaunchSingleChoice(target)) {\n            return false;\n        }\n\n        return getIntent().getBooleanExtra(Intent.EXTRA_AUTO_LAUNCH_SINGLE_CHOICE, true);\n    }\n\n    private void showTargetDetails(TargetInfo targetInfo) {\n        if (targetInfo == null) return;\n\n        ArrayList<DisplayResolveInfo> targetList;\n        ChooserTargetActionsDialogFragment fragment = new ChooserTargetActionsDialogFragment();\n        Bundle bundle = new Bundle();\n\n        if (targetInfo instanceof SelectableTargetInfo) {\n            SelectableTargetInfo selectableTargetInfo = (SelectableTargetInfo) targetInfo;\n            if (selectableTargetInfo.getDisplayResolveInfo() == null\n                    || selectableTargetInfo.getChooserTarget() == null) {\n                Log.e(TAG, \"displayResolveInfo or chooserTarget in selectableTargetInfo are null\");\n                return;\n            }\n            targetList = new ArrayList<>();\n            targetList.add(selectableTargetInfo.getDisplayResolveInfo());\n            bundle.putString(ChooserTargetActionsDialogFragment.SHORTCUT_ID_KEY,\n                    selectableTargetInfo.getChooserTarget().getIntentExtras().getString(\n                            Intent.EXTRA_SHORTCUT_ID));\n            bundle.putBoolean(ChooserTargetActionsDialogFragment.IS_SHORTCUT_PINNED_KEY,\n                    selectableTargetInfo.isPinned());\n            bundle.putParcelable(ChooserTargetActionsDialogFragment.INTENT_FILTER_KEY,\n                    getTargetIntentFilter());\n            if (selectableTargetInfo.getDisplayLabel() != null) {\n                bundle.putString(ChooserTargetActionsDialogFragment.SHORTCUT_TITLE_KEY,\n                        selectableTargetInfo.getDisplayLabel().toString());\n            }\n        } else if (targetInfo instanceof MultiDisplayResolveInfo) {\n            // For multiple targets, include info on all targets\n            MultiDisplayResolveInfo mti = (MultiDisplayResolveInfo) targetInfo;\n            targetList = mti.getTargets();\n        } else {\n            targetList = new ArrayList<DisplayResolveInfo>();\n            targetList.add((DisplayResolveInfo) targetInfo);\n        }\n        bundle.putParcelable(ChooserTargetActionsDialogFragment.USER_HANDLE_KEY,\n                mChooserMultiProfilePagerAdapter.getCurrentUserHandle());\n        bundle.putParcelableArrayList(ChooserTargetActionsDialogFragment.TARGET_INFOS_KEY,\n                targetList);\n        fragment.setArguments(bundle);\n\n        fragment.show(getFragmentManager(), TARGET_DETAILS_FRAGMENT_TAG);\n    }\n\n    private void modifyTargetIntent(Intent in) {\n        if (isSendAction(in)) {\n            in.addFlags(Intent.FLAG_ACTIVITY_NEW_DOCUMENT |\n                    Intent.FLAG_ACTIVITY_MULTIPLE_TASK);\n        }\n    }\n\n    @Override\n    protected boolean onTargetSelected(TargetInfo target, boolean alwaysCheck) {\n        if (mRefinementIntentSender != null) {\n            final Intent fillIn = new Intent();\n            final List<Intent> sourceIntents = target.getAllSourceIntents();\n            if (!sourceIntents.isEmpty()) {\n                fillIn.putExtra(Intent.EXTRA_INTENT, sourceIntents.get(0));\n                if (sourceIntents.size() > 1) {\n                    final Intent[] alts = new Intent[sourceIntents.size() - 1];\n                    for (int i = 1, N = sourceIntents.size(); i < N; i++) {\n                        alts[i - 1] = sourceIntents.get(i);\n                    }\n                    fillIn.putExtra(Intent.EXTRA_ALTERNATE_INTENTS, alts);\n                }\n                if (mRefinementResultReceiver != null) {\n                    mRefinementResultReceiver.destroy();\n                }\n                mRefinementResultReceiver = new RefinementResultReceiver(this, target, null);\n                fillIn.putExtra(Intent.EXTRA_RESULT_RECEIVER,\n                        mRefinementResultReceiver);\n                try {\n                    mRefinementIntentSender.sendIntent(this, 0, fillIn, null, null);\n                    return false;\n                } catch (SendIntentException e) {\n                    Log.e(TAG, \"Refinement IntentSender failed to send\", e);\n                }\n            }\n        }\n        updateModelAndChooserCounts(target);\n        return super.onTargetSelected(target, alwaysCheck);\n    }\n\n    @Override\n    public void startSelected(int which, boolean always, boolean filtered) {\n        ChooserListAdapter currentListAdapter =\n                mChooserMultiProfilePagerAdapter.getActiveListAdapter();\n        TargetInfo targetInfo = currentListAdapter\n                .targetInfoForPosition(which, filtered);\n        if (targetInfo != null && targetInfo instanceof NotSelectableTargetInfo) {\n            return;\n        }\n\n        final long selectionCost = System.currentTimeMillis() - mChooserShownTime;\n\n        if (targetInfo instanceof MultiDisplayResolveInfo) {\n            MultiDisplayResolveInfo mti = (MultiDisplayResolveInfo) targetInfo;\n            if (!mti.hasSelected()) {\n                ChooserStackedAppDialogFragment f = new ChooserStackedAppDialogFragment();\n                Bundle b = new Bundle();\n                b.putParcelable(ChooserTargetActionsDialogFragment.USER_HANDLE_KEY,\n                        mChooserMultiProfilePagerAdapter.getCurrentUserHandle());\n                b.putObject(ChooserStackedAppDialogFragment.MULTI_DRI_KEY,\n                        mti);\n                b.putInt(ChooserStackedAppDialogFragment.WHICH_KEY, which);\n                f.setArguments(b);\n\n                f.show(getFragmentManager(), TARGET_DETAILS_FRAGMENT_TAG);\n                return;\n            }\n        }\n\n        super.startSelected(which, always, filtered);\n\n        if (currentListAdapter.getCount() > 0) {\n            // Log the index of which type of target the user picked.\n            // Lower values mean the ranking was better.\n            int cat = 0;\n            int value = which;\n            int directTargetAlsoRanked = -1;\n            int numCallerProvided = 0;\n            HashedStringCache.HashResult directTargetHashed = null;\n            switch (currentListAdapter.getPositionTargetType(which)) {\n                case ChooserListAdapter.TARGET_SERVICE:\n                    cat = MetricsEvent.ACTION_ACTIVITY_CHOOSER_PICKED_SERVICE_TARGET;\n                    // Log the package name + target name to answer the question if most users\n                    // share to mostly the same person or to a bunch of different people.\n                    ChooserTarget target = currentListAdapter.getChooserTargetForValue(value);\n                    directTargetHashed = HashedStringCache.getInstance().hashString(\n                            this,\n                            TAG,\n                            target.getComponentName().getPackageName()\n                                    + target.getTitle().toString(),\n                            mMaxHashSaltDays);\n                    SelectableTargetInfo selectableTargetInfo = (SelectableTargetInfo) targetInfo;\n                    directTargetAlsoRanked = getRankedPosition(selectableTargetInfo);\n\n                    if (mCallerChooserTargets != null) {\n                        numCallerProvided = mCallerChooserTargets.length;\n                    }\n                    getChooserActivityLogger().logShareTargetSelected(\n                            SELECTION_TYPE_SERVICE,\n                            targetInfo.getResolveInfo().activityInfo.processName,\n                            value,\n                            selectableTargetInfo.isPinned()\n                    );\n                    break;\n                case ChooserListAdapter.TARGET_CALLER:\n                case ChooserListAdapter.TARGET_STANDARD:\n                    cat = MetricsEvent.ACTION_ACTIVITY_CHOOSER_PICKED_APP_TARGET;\n                    value -= currentListAdapter.getSurfacedTargetInfo().size();\n                    numCallerProvided = currentListAdapter.getCallerTargetCount();\n                    getChooserActivityLogger().logShareTargetSelected(\n                            SELECTION_TYPE_APP,\n                            targetInfo.getResolveInfo().activityInfo.processName,\n                            value,\n                            targetInfo.isPinned()\n                    );\n                    break;\n                case ChooserListAdapter.TARGET_STANDARD_AZ:\n                    // A-Z targets are unranked standard targets; we use -1 to mark that they\n                    // are from the alphabetical pool.\n                    value = -1;\n                    cat = MetricsEvent.ACTION_ACTIVITY_CHOOSER_PICKED_STANDARD_TARGET;\n                    getChooserActivityLogger().logShareTargetSelected(\n                            SELECTION_TYPE_STANDARD,\n                            targetInfo.getResolveInfo().activityInfo.processName,\n                            value,\n                            false\n                    );\n                    break;\n            }\n\n            if (cat != 0) {\n                LogMaker targetLogMaker = new LogMaker(cat).setSubtype(value);\n                if (directTargetHashed != null) {\n                    targetLogMaker.addTaggedData(\n                            MetricsEvent.FIELD_HASHED_TARGET_NAME, directTargetHashed.hashedString);\n                    targetLogMaker.addTaggedData(\n                                    MetricsEvent.FIELD_HASHED_TARGET_SALT_GEN,\n                                    directTargetHashed.saltGeneration);\n                    targetLogMaker.addTaggedData(MetricsEvent.FIELD_RANKED_POSITION,\n                                    directTargetAlsoRanked);\n                }\n                targetLogMaker.addTaggedData(MetricsEvent.FIELD_IS_CATEGORY_USED,\n                        numCallerProvided);\n                getMetricsLogger().write(targetLogMaker);\n            }\n\n            if (mIsSuccessfullySelected) {\n                if (DEBUG) {\n                    Log.d(TAG, \"User Selection Time Cost is \" + selectionCost);\n                    Log.d(TAG, \"position of selected app/service/caller is \" +\n                            Integer.toString(value));\n                }\n                MetricsLogger.histogram(null, \"user_selection_cost_for_smart_sharing\",\n                        (int) selectionCost);\n                MetricsLogger.histogram(null, \"app_position_for_smart_sharing\", value);\n            }\n        }\n    }\n\n    private int getRankedPosition(SelectableTargetInfo targetInfo) {\n        String targetPackageName =\n                targetInfo.getChooserTarget().getComponentName().getPackageName();\n        ChooserListAdapter currentListAdapter =\n                mChooserMultiProfilePagerAdapter.getActiveListAdapter();\n        int maxRankedResults = Math.min(currentListAdapter.mDisplayList.size(),\n                MAX_LOG_RANK_POSITION);\n\n        for (int i = 0; i < maxRankedResults; i++) {\n            if (currentListAdapter.mDisplayList.get(i)\n                    .getResolveInfo().activityInfo.packageName.equals(targetPackageName)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    @Override\n    protected boolean shouldAddFooterView() {\n        // To accommodate for window insets\n        return true;\n    }\n\n    @Override\n    protected void applyFooterView(int height) {\n        int count = mChooserMultiProfilePagerAdapter.getItemCount();\n\n        for (int i = 0; i < count; i++) {\n            mChooserMultiProfilePagerAdapter.getAdapterForIndex(i).setFooterHeight(height);\n        }\n    }\n\n    private IntentFilter getTargetIntentFilter() {\n        try {\n            final Intent intent = getTargetIntent();\n            String dataString = intent.getDataString();\n            if (intent.getType() == null) {\n                if (!TextUtils.isEmpty(dataString)) {\n                    return new IntentFilter(intent.getAction(), dataString);\n                }\n                Log.e(TAG, \"Failed to get target intent filter: intent data and type are null\");\n                return null;\n            }\n            IntentFilter intentFilter = new IntentFilter(intent.getAction(), intent.getType());\n            List<Uri> contentUris = new ArrayList<>();\n            if (Intent.ACTION_SEND.equals(intent.getAction())) {\n                Uri uri = (Uri) intent.getParcelableExtra(Intent.EXTRA_STREAM);\n                if (uri != null) {\n                    contentUris.add(uri);\n                }\n            } else {\n                List<Uri> uris = intent.getParcelableArrayListExtra(Intent.EXTRA_STREAM);\n                if (uris != null) {\n                    contentUris.addAll(uris);\n                }\n            }\n            for (Uri uri : contentUris) {\n                intentFilter.addDataScheme(uri.getScheme());\n                intentFilter.addDataAuthority(uri.getAuthority(), null);\n                intentFilter.addDataPath(uri.getPath(), PatternMatcher.PATTERN_LITERAL);\n            }\n            return intentFilter;\n        } catch (Exception e) {\n            Log.e(TAG, \"Failed to get target intent filter\", e);\n            return null;\n        }\n    }\n\n    @VisibleForTesting\n    protected void queryDirectShareTargets(\n                ChooserListAdapter adapter, boolean skipAppPredictionService) {\n        mQueriedSharingShortcutsTimeMs = System.currentTimeMillis();\n        UserHandle userHandle = adapter.getUserHandle();\n        if (!skipAppPredictionService) {\n            AppPredictor appPredictor = getAppPredictorForDirectShareIfEnabled(userHandle);\n            if (appPredictor != null) {\n                appPredictor.requestPredictionUpdate();\n                return;\n            }\n        }\n        // Default to just querying ShortcutManager if AppPredictor not present.\n        final IntentFilter filter = getTargetIntentFilter();\n        if (filter == null) {\n            return;\n        }\n\n        AsyncTask.execute(() -> {\n            Context selectedProfileContext = createContextAsUser(userHandle, 0 /* flags */);\n            ShortcutManager sm = (ShortcutManager) selectedProfileContext\n                    .getSystemService(Context.SHORTCUT_SERVICE);\n            List<ShortcutManager.ShareShortcutInfo> resultList = sm.getShareTargets(filter);\n            sendShareShortcutInfoList(resultList, adapter, null, userHandle);\n        });\n    }\n\n    /**\n     * Returns {@code false} if {@code userHandle} is the work profile and it's either\n     * in quiet mode or not running.\n     */\n    private boolean shouldQueryShortcutManager(UserHandle userHandle) {\n        if (!shouldShowTabs()) {\n            return true;\n        }\n        if (!getWorkProfileUserHandle().equals(userHandle)) {\n            return true;\n        }\n        if (!isUserRunning(userHandle)) {\n            return false;\n        }\n        if (!isUserUnlocked(userHandle)) {\n            return false;\n        }\n        if (isQuietModeEnabled(userHandle)) {\n            return false;\n        }\n        return true;\n    }\n\n    private void sendShareShortcutInfoList(\n                List<ShortcutManager.ShareShortcutInfo> resultList,\n                ChooserListAdapter chooserListAdapter,\n                @Nullable List<AppTarget> appTargets, UserHandle userHandle) {\n        if (appTargets != null && appTargets.size() != resultList.size()) {\n            throw new RuntimeException(\"resultList and appTargets must have the same size.\"\n                    + \" resultList.size()=\" + resultList.size()\n                    + \" appTargets.size()=\" + appTargets.size());\n        }\n        Context selectedProfileContext = createContextAsUser(userHandle, 0 /* flags */);\n        for (int i = resultList.size() - 1; i >= 0; i--) {\n            final String packageName = resultList.get(i).getTargetComponent().getPackageName();\n            if (!isPackageEnabled(selectedProfileContext, packageName)) {\n                resultList.remove(i);\n                if (appTargets != null) {\n                    appTargets.remove(i);\n                }\n            }\n        }\n\n        // If |appTargets| is not null, results are from AppPredictionService and already sorted.\n        final int shortcutType = (appTargets == null ? TARGET_TYPE_SHORTCUTS_FROM_SHORTCUT_MANAGER :\n                TARGET_TYPE_SHORTCUTS_FROM_PREDICTION_SERVICE);\n\n        // Match ShareShortcutInfos with DisplayResolveInfos to be able to use the old code path\n        // for direct share targets. After ShareSheet is refactored we should use the\n        // ShareShortcutInfos directly.\n        List<ServiceResultInfo> resultRecords = new ArrayList<>();\n        for (int i = 0; i < chooserListAdapter.getDisplayResolveInfoCount(); i++) {\n            DisplayResolveInfo displayResolveInfo = chooserListAdapter.getDisplayResolveInfo(i);\n            List<ShortcutManager.ShareShortcutInfo> matchingShortcuts =\n                    filterShortcutsByTargetComponentName(\n                            resultList, displayResolveInfo.getResolvedComponentName());\n            if (matchingShortcuts.isEmpty()) {\n                continue;\n            }\n            List<ChooserTarget> chooserTargets = convertToChooserTarget(\n                    matchingShortcuts, resultList, appTargets, shortcutType);\n\n            ServiceResultInfo resultRecord = new ServiceResultInfo(\n                    displayResolveInfo, chooserTargets, userHandle);\n            resultRecords.add(resultRecord);\n        }\n\n        sendShortcutManagerShareTargetResults(\n                shortcutType, resultRecords.toArray(new ServiceResultInfo[0]));\n    }\n\n    private List<ShortcutManager.ShareShortcutInfo> filterShortcutsByTargetComponentName(\n            List<ShortcutManager.ShareShortcutInfo> allShortcuts, ComponentName requiredTarget) {\n        List<ShortcutManager.ShareShortcutInfo> matchingShortcuts = new ArrayList<>();\n        for (ShortcutManager.ShareShortcutInfo shortcut : allShortcuts) {\n            if (requiredTarget.equals(shortcut.getTargetComponent())) {\n                matchingShortcuts.add(shortcut);\n            }\n        }\n        return matchingShortcuts;\n    }\n\n    private void sendShortcutManagerShareTargetResults(\n            int shortcutType, ServiceResultInfo[] results) {\n        final Message msg = Message.obtain();\n        msg.what = ChooserHandler.SHORTCUT_MANAGER_ALL_SHARE_TARGET_RESULTS;\n        msg.obj = results;\n        msg.arg1 = shortcutType;\n        mChooserHandler.sendMessage(msg);\n    }\n\n    private boolean isPackageEnabled(Context context, String packageName) {\n        if (TextUtils.isEmpty(packageName)) {\n            return false;\n        }\n        ApplicationInfo appInfo;\n        try {\n            appInfo = context.getPackageManager().getApplicationInfo(packageName, 0);\n        } catch (NameNotFoundException e) {\n            return false;\n        }\n\n        if (appInfo != null && appInfo.enabled\n                && (appInfo.flags & ApplicationInfo.FLAG_SUSPENDED) == 0) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Converts a list of ShareShortcutInfos to ChooserTargets.\n     * @param matchingShortcuts List of shortcuts, all from the same package, that match the current\n     *                         share intent filter.\n     * @param allShortcuts List of all the shortcuts from all the packages on the device that are\n     *                    returned for the current sharing action.\n     * @param allAppTargets List of AppTargets. Null if the results are not from prediction service.\n     * @param shortcutType One of the values TARGET_TYPE_SHORTCUTS_FROM_SHORTCUT_MANAGER or\n     *                    TARGET_TYPE_SHORTCUTS_FROM_PREDICTION_SERVICE\n     * @return A list of ChooserTargets sorted by score in descending order.\n     */\n    @VisibleForTesting\n    @NonNull\n    public List<ChooserTarget> convertToChooserTarget(\n            @NonNull List<ShortcutManager.ShareShortcutInfo> matchingShortcuts,\n            @NonNull List<ShortcutManager.ShareShortcutInfo> allShortcuts,\n            @Nullable List<AppTarget> allAppTargets, @ShareTargetType int shortcutType) {\n        // A set of distinct scores for the matched shortcuts. We use index of a rank in the sorted\n        // list instead of the actual rank value when converting a rank to a score.\n        List<Integer> scoreList = new ArrayList<>();\n        if (shortcutType == TARGET_TYPE_SHORTCUTS_FROM_SHORTCUT_MANAGER) {\n            for (int i = 0; i < matchingShortcuts.size(); i++) {\n                int shortcutRank = matchingShortcuts.get(i).getShortcutInfo().getRank();\n                if (!scoreList.contains(shortcutRank)) {\n                    scoreList.add(shortcutRank);\n                }\n            }\n            Collections.sort(scoreList);\n        }\n\n        List<ChooserTarget> chooserTargetList = new ArrayList<>(matchingShortcuts.size());\n        for (int i = 0; i < matchingShortcuts.size(); i++) {\n            ShortcutInfo shortcutInfo = matchingShortcuts.get(i).getShortcutInfo();\n            int indexInAllShortcuts = allShortcuts.indexOf(matchingShortcuts.get(i));\n\n            float score;\n            if (shortcutType == TARGET_TYPE_SHORTCUTS_FROM_PREDICTION_SERVICE) {\n                // Incoming results are ordered. Create a score based on index in the original list.\n                score = Math.max(1.0f - (0.01f * indexInAllShortcuts), 0.0f);\n            } else {\n                // Create a score based on the rank of the shortcut.\n                int rankIndex = scoreList.indexOf(shortcutInfo.getRank());\n                score = Math.max(1.0f - (0.01f * rankIndex), 0.0f);\n            }\n\n            Bundle extras = new Bundle();\n            extras.putString(Intent.EXTRA_SHORTCUT_ID, shortcutInfo.getId());\n\n            ChooserTarget chooserTarget = new ChooserTarget(\n                    shortcutInfo.getLabel(),\n                    null, // Icon will be loaded later if this target is selected to be shown.\n                    score, matchingShortcuts.get(i).getTargetComponent().clone(), extras);\n\n            chooserTargetList.add(chooserTarget);\n            if (mDirectShareAppTargetCache != null && allAppTargets != null) {\n                mDirectShareAppTargetCache.put(chooserTarget,\n                        allAppTargets.get(indexInAllShortcuts));\n            }\n            if (mDirectShareShortcutInfoCache != null) {\n                mDirectShareShortcutInfoCache.put(chooserTarget, shortcutInfo);\n            }\n        }\n        // Sort ChooserTargets by score in descending order\n        Comparator<ChooserTarget> byScore =\n                (ChooserTarget a, ChooserTarget b) -> -Float.compare(a.getScore(), b.getScore());\n        Collections.sort(chooserTargetList, byScore);\n        return chooserTargetList;\n    }\n\n    private void logDirectShareTargetReceived(int logCategory) {\n        final int apiLatency = (int) (System.currentTimeMillis() - mQueriedSharingShortcutsTimeMs);\n        getMetricsLogger().write(new LogMaker(logCategory).setSubtype(apiLatency));\n    }\n\n    void updateModelAndChooserCounts(TargetInfo info) {\n        if (info != null && info instanceof MultiDisplayResolveInfo) {\n            info = ((MultiDisplayResolveInfo) info).getSelectedTarget();\n        }\n        if (info != null) {\n            sendClickToAppPredictor(info);\n            final ResolveInfo ri = info.getResolveInfo();\n            Intent targetIntent = getTargetIntent();\n            if (ri != null && ri.activityInfo != null && targetIntent != null) {\n                ChooserListAdapter currentListAdapter =\n                        mChooserMultiProfilePagerAdapter.getActiveListAdapter();\n                if (currentListAdapter != null) {\n                    sendImpressionToAppPredictor(info, currentListAdapter);\n                    currentListAdapter.updateModel(info.getResolvedComponentName());\n                    currentListAdapter.updateChooserCounts(ri.activityInfo.packageName,\n                            targetIntent.getAction());\n                }\n                if (DEBUG) {\n                    Log.d(TAG, \"ResolveInfo Package is \" + ri.activityInfo.packageName);\n                    Log.d(TAG, \"Action to be updated is \" + targetIntent.getAction());\n                }\n            } else if (DEBUG) {\n                Log.d(TAG, \"Can not log Chooser Counts of null ResovleInfo\");\n            }\n        }\n        mIsSuccessfullySelected = true;\n    }\n\n    private void sendImpressionToAppPredictor(TargetInfo targetInfo, ChooserListAdapter adapter) {\n        AppPredictor directShareAppPredictor = getAppPredictorForDirectShareIfEnabled(\n                mChooserMultiProfilePagerAdapter.getCurrentUserHandle());\n        if (directShareAppPredictor == null) {\n            return;\n        }\n        // Send DS target impression info to AppPredictor, only when user chooses app share.\n        if (targetInfo instanceof ChooserTargetInfo) {\n            return;\n        }\n        List<ChooserTargetInfo> surfacedTargetInfo = adapter.getSurfacedTargetInfo();\n        List<AppTargetId> targetIds = new ArrayList<>();\n        for (ChooserTargetInfo chooserTargetInfo : surfacedTargetInfo) {\n            ChooserTarget chooserTarget = chooserTargetInfo.getChooserTarget();\n            ComponentName componentName = chooserTarget.getComponentName();\n            if (mDirectShareShortcutInfoCache.containsKey(chooserTarget)) {\n                String shortcutId = mDirectShareShortcutInfoCache.get(chooserTarget).getId();\n                targetIds.add(new AppTargetId(\n                        String.format(\"%s/%s/%s\", shortcutId, componentName.flattenToString(),\n                                SHORTCUT_TARGET)));\n            }\n        }\n        directShareAppPredictor.notifyLaunchLocationShown(LAUNCH_LOCATION_DIRECT_SHARE, targetIds);\n    }\n\n    private void sendClickToAppPredictor(TargetInfo targetInfo) {\n        AppPredictor directShareAppPredictor = getAppPredictorForDirectShareIfEnabled(\n                mChooserMultiProfilePagerAdapter.getCurrentUserHandle());\n        if (directShareAppPredictor == null) {\n            return;\n        }\n        if (!(targetInfo instanceof ChooserTargetInfo)) {\n            return;\n        }\n        ChooserTarget chooserTarget = ((ChooserTargetInfo) targetInfo).getChooserTarget();\n        AppTarget appTarget = null;\n        if (mDirectShareAppTargetCache != null) {\n            appTarget = mDirectShareAppTargetCache.get(chooserTarget);\n        }\n        // This is a direct share click that was provided by the APS\n        if (appTarget != null) {\n            directShareAppPredictor.notifyAppTargetEvent(\n                    new AppTargetEvent.Builder(appTarget, AppTargetEvent.ACTION_LAUNCH)\n                        .setLaunchLocation(LAUNCH_LOCATION_DIRECT_SHARE)\n                        .build());\n        }\n    }\n\n    @Nullable\n    private AppPredictor createAppPredictor(UserHandle userHandle) {\n        if (!mIsAppPredictorComponentAvailable) {\n            return null;\n        }\n\n        if (getPersonalProfileUserHandle().equals(userHandle)) {\n            if (mPersonalAppPredictor != null) {\n                return mPersonalAppPredictor;\n            }\n        } else {\n            if (mWorkAppPredictor != null) {\n                return mWorkAppPredictor;\n            }\n        }\n\n        // TODO(b/148230574): Currently AppPredictor fetches only the same-profile app targets.\n        // Make AppPredictor work cross-profile.\n        Context contextAsUser = createContextAsUser(userHandle, 0 /* flags */);\n        final IntentFilter filter = getTargetIntentFilter();\n        Bundle extras = new Bundle();\n        extras.putParcelable(APP_PREDICTION_INTENT_FILTER_KEY, filter);\n        populateTextContent(extras);\n        AppPredictionContext appPredictionContext = new AppPredictionContext.Builder(contextAsUser)\n            .setUiSurface(APP_PREDICTION_SHARE_UI_SURFACE)\n            .setPredictedTargetCount(APP_PREDICTION_SHARE_TARGET_QUERY_PACKAGE_LIMIT)\n            .setExtras(extras)\n            .build();\n        AppPredictionManager appPredictionManager =\n                contextAsUser\n                        .getSystemService(AppPredictionManager.class);\n        AppPredictor appPredictionSession = appPredictionManager.createAppPredictionSession(\n                appPredictionContext);\n        if (getPersonalProfileUserHandle().equals(userHandle)) {\n            mPersonalAppPredictor = appPredictionSession;\n        } else {\n            mWorkAppPredictor = appPredictionSession;\n        }\n        return appPredictionSession;\n    }\n\n    private void populateTextContent(Bundle extras) {\n        final Intent intent = getTargetIntent();\n        String sharedText = intent.getStringExtra(Intent.EXTRA_TEXT);\n        extras.putString(SHARED_TEXT_KEY, sharedText);\n    }\n\n    /**\n     * This will return an app predictor if it is enabled for direct share sorting\n     * and if one exists. Otherwise, it returns null.\n     * @param userHandle\n     */\n    @Nullable\n    private AppPredictor getAppPredictorForDirectShareIfEnabled(UserHandle userHandle) {\n        return ChooserFlags.USE_PREDICTION_MANAGER_FOR_DIRECT_TARGETS\n                && !ActivityManager.isLowRamDeviceStatic() ? createAppPredictor(userHandle) : null;\n    }\n\n    /**\n     * This will return an app predictor if it is enabled for share activity sorting\n     * and if one exists. Otherwise, it returns null.\n     */\n    @Nullable\n    private AppPredictor getAppPredictorForShareActivitiesIfEnabled(UserHandle userHandle) {\n        return USE_PREDICTION_MANAGER_FOR_SHARE_ACTIVITIES ? createAppPredictor(userHandle) : null;\n    }\n\n    void onRefinementResult(TargetInfo selectedTarget, Intent matchingIntent) {\n        if (mRefinementResultReceiver != null) {\n            mRefinementResultReceiver.destroy();\n            mRefinementResultReceiver = null;\n        }\n        if (selectedTarget == null) {\n            Log.e(TAG, \"Refinement result intent did not match any known targets; canceling\");\n        } else if (!checkTargetSourceIntent(selectedTarget, matchingIntent)) {\n            Log.e(TAG, \"onRefinementResult: Selected target \" + selectedTarget\n                    + \" cannot match refined source intent \" + matchingIntent);\n        } else {\n            TargetInfo clonedTarget = selectedTarget.cloneFilledIn(matchingIntent, 0);\n            if (super.onTargetSelected(clonedTarget, false)) {\n                updateModelAndChooserCounts(clonedTarget);\n                finish();\n                return;\n            }\n        }\n        onRefinementCanceled();\n    }\n\n    void onRefinementCanceled() {\n        if (mRefinementResultReceiver != null) {\n            mRefinementResultReceiver.destroy();\n            mRefinementResultReceiver = null;\n        }\n        finish();\n    }\n\n    boolean checkTargetSourceIntent(TargetInfo target, Intent matchingIntent) {\n        final List<Intent> targetIntents = target.getAllSourceIntents();\n        for (int i = 0, N = targetIntents.size(); i < N; i++) {\n            final Intent targetIntent = targetIntents.get(i);\n            if (targetIntent.filterEquals(matchingIntent)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Sort intents alphabetically based on display label.\n     */\n    static class AzInfoComparator implements Comparator<DisplayResolveInfo> {\n        Collator mCollator;\n        AzInfoComparator(Context context) {\n            mCollator = Collator.getInstance(context.getResources().getConfiguration().locale);\n        }\n\n        @Override\n        public int compare(\n                DisplayResolveInfo lhsp, DisplayResolveInfo rhsp) {\n            return mCollator.compare(lhsp.getDisplayLabel(), rhsp.getDisplayLabel());\n        }\n    }\n\n    protected MetricsLogger getMetricsLogger() {\n        if (mMetricsLogger == null) {\n            mMetricsLogger = new MetricsLogger();\n        }\n        return mMetricsLogger;\n    }\n\n    protected ChooserActivityLogger getChooserActivityLogger() {\n        if (mChooserActivityLogger == null) {\n            mChooserActivityLogger = new ChooserActivityLoggerImpl();\n        }\n        return mChooserActivityLogger;\n    }\n\n    public class ChooserListController extends ResolverListController {\n        public ChooserListController(Context context,\n                PackageManager pm,\n                Intent targetIntent,\n                String referrerPackageName,\n                int launchedFromUid,\n                UserHandle userId,\n                AbstractResolverComparator resolverComparator) {\n            super(context, pm, targetIntent, referrerPackageName, launchedFromUid, userId,\n                    resolverComparator);\n        }\n\n        @Override\n        boolean isComponentFiltered(ComponentName name) {\n            if (mFilteredComponentNames == null) {\n                return false;\n            }\n            for (ComponentName filteredComponentName : mFilteredComponentNames) {\n                if (name.equals(filteredComponentName)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        @Override\n        public boolean isComponentPinned(ComponentName name) {\n            return mPinnedSharedPrefs.getBoolean(name.flattenToString(), false);\n        }\n\n        @Override\n        public boolean isFixedAtTop(ComponentName name) {\n            return name != null && name.equals(getNearbySharingComponent())\n                    && shouldNearbyShareBeFirstInRankedRow();\n        }\n    }\n\n    @VisibleForTesting\n    public ChooserGridAdapter createChooserGridAdapter(Context context,\n            List<Intent> payloadIntents, Intent[] initialIntents, List<ResolveInfo> rList,\n            boolean filterLastUsed, UserHandle userHandle) {\n        ChooserListAdapter chooserListAdapter = createChooserListAdapter(context, payloadIntents,\n                initialIntents, rList, filterLastUsed,\n                createListController(userHandle));\n        AppPredictor.Callback appPredictorCallback = createAppPredictorCallback(chooserListAdapter);\n        AppPredictor appPredictor = setupAppPredictorForUser(userHandle, appPredictorCallback);\n        chooserListAdapter.setAppPredictor(appPredictor);\n        chooserListAdapter.setAppPredictorCallback(appPredictorCallback);\n        return new ChooserGridAdapter(chooserListAdapter);\n    }\n\n    @VisibleForTesting\n    public ChooserListAdapter createChooserListAdapter(Context context,\n            List<Intent> payloadIntents, Intent[] initialIntents, List<ResolveInfo> rList,\n            boolean filterLastUsed, ResolverListController resolverListController) {\n        return new ChooserListAdapter(context, payloadIntents, initialIntents, rList,\n                filterLastUsed, resolverListController, this,\n                this, context.getPackageManager(),\n                getChooserActivityLogger());\n    }\n\n    @VisibleForTesting\n    protected ResolverListController createListController(UserHandle userHandle) {\n        AppPredictor appPredictor = getAppPredictorForShareActivitiesIfEnabled(userHandle);\n        AbstractResolverComparator resolverComparator;\n        if (appPredictor != null) {\n            resolverComparator = new AppPredictionServiceResolverComparator(this, getTargetIntent(),\n                    getReferrerPackageName(), appPredictor, userHandle, getChooserActivityLogger());\n        } else {\n            resolverComparator =\n                    new ResolverRankerServiceResolverComparator(this, getTargetIntent(),\n                        getReferrerPackageName(), null, getChooserActivityLogger());\n        }\n\n        return new ChooserListController(\n                this,\n                mPm,\n                getTargetIntent(),\n                getReferrerPackageName(),\n                mLaunchedFromUid,\n                userHandle,\n                resolverComparator);\n    }\n\n    @VisibleForTesting\n    protected Bitmap loadThumbnail(Uri uri, Size size) {\n        if (uri == null || size == null) {\n            return null;\n        }\n\n        try {\n            return getContentResolver().loadThumbnail(uri, size, null);\n        } catch (IOException | NullPointerException | SecurityException ex) {\n            logContentPreviewWarning(uri);\n        }\n        return null;\n    }\n\n    static final class PlaceHolderTargetInfo extends NotSelectableTargetInfo {\n        public Drawable getDisplayIcon(Context context) {\n            AnimatedVectorDrawable avd = (AnimatedVectorDrawable)\n                    context.getDrawable(R.drawable.chooser_direct_share_icon_placeholder);\n            avd.start(); // Start animation after generation\n            return avd;\n        }\n    }\n\n    protected static final class EmptyTargetInfo extends NotSelectableTargetInfo {\n        public EmptyTargetInfo() {}\n\n        public Drawable getDisplayIcon(Context context) {\n            return null;\n        }\n    }\n\n    private void handleScroll(View view, int x, int y, int oldx, int oldy) {\n        if (mChooserMultiProfilePagerAdapter.getCurrentRootAdapter() != null) {\n            mChooserMultiProfilePagerAdapter.getCurrentRootAdapter().handleScroll(view, y, oldy);\n        }\n    }\n\n    /*\n     * Need to dynamically adjust how many icons can fit per row before we add them,\n     * which also means setting the correct offset to initially show the content\n     * preview area + 2 rows of targets\n     */\n    private void handleLayoutChange(View v, int left, int top, int right, int bottom, int oldLeft,\n            int oldTop, int oldRight, int oldBottom) {\n        if (mChooserMultiProfilePagerAdapter == null) {\n            return;\n        }\n        RecyclerView recyclerView = mChooserMultiProfilePagerAdapter.getActiveAdapterView();\n        ChooserGridAdapter gridAdapter = mChooserMultiProfilePagerAdapter.getCurrentRootAdapter();\n        // Skip height calculation if recycler view was scrolled to prevent it inaccurately\n        // calculating the height, as the logic below does not account for the scrolled offset.\n        if (gridAdapter == null || recyclerView == null\n                || recyclerView.computeVerticalScrollOffset() != 0) {\n            return;\n        }\n\n        final int availableWidth = right - left - v.getPaddingLeft() - v.getPaddingRight();\n        boolean isLayoutUpdated = gridAdapter.consumeLayoutRequest()\n                || gridAdapter.calculateChooserTargetWidth(availableWidth)\n                || recyclerView.getAdapter() == null\n                || availableWidth != mCurrAvailableWidth;\n        if (isLayoutUpdated\n                || mLastNumberOfChildren != recyclerView.getChildCount()) {\n            mCurrAvailableWidth = availableWidth;\n            if (isLayoutUpdated) {\n                // It is very important we call setAdapter from here. Otherwise in some cases\n                // the resolver list doesn't get populated, such as b/150922090, b/150918223\n                // and b/150936654\n                recyclerView.setAdapter(gridAdapter);\n                ((GridLayoutManager) recyclerView.getLayoutManager()).setSpanCount(\n                        mMaxTargetsPerRow);\n\n                updateTabPadding();\n            }\n\n            UserHandle currentUserHandle = mChooserMultiProfilePagerAdapter.getCurrentUserHandle();\n            int currentProfile = getProfileForUser(currentUserHandle);\n            int initialProfile = findSelectedProfile();\n            if (currentProfile != initialProfile) {\n                return;\n            }\n\n            if (mLastNumberOfChildren == recyclerView.getChildCount()) {\n                return;\n            }\n\n            getMainThreadHandler().post(() -> {\n                if (mResolverDrawerLayout == null || gridAdapter == null) {\n                    return;\n                }\n                int offset = calculateDrawerOffset(top, bottom, recyclerView, gridAdapter);\n                mResolverDrawerLayout.setCollapsibleHeightReserved(offset);\n                mEnterTransitionAnimationDelegate.markOffsetCalculated();\n            });\n        }\n    }\n\n    private int calculateDrawerOffset(\n            int top, int bottom, RecyclerView recyclerView, ChooserGridAdapter gridAdapter) {\n\n        final int bottomInset = mSystemWindowInsets != null\n                ? mSystemWindowInsets.bottom : 0;\n        int offset = bottomInset;\n        int rowsToShow = gridAdapter.getSystemRowCount()\n                + gridAdapter.getProfileRowCount()\n                + gridAdapter.getServiceTargetRowCount()\n                + gridAdapter.getCallerAndRankedTargetRowCount();\n\n        // then this is most likely not a SEND_* action, so check\n        // the app target count\n        if (rowsToShow == 0) {\n            rowsToShow = gridAdapter.getRowCount();\n        }\n\n        // still zero? then use a default height and leave, which\n        // can happen when there are no targets to show\n        if (rowsToShow == 0 && !shouldShowStickyContentPreview()) {\n            offset += getResources().getDimensionPixelSize(\n                    R.dimen.chooser_max_collapsed_height);\n            return offset;\n        }\n\n        View stickyContentPreview = findViewById(R.id.content_preview_container);\n        if (shouldShowStickyContentPreview() && isStickyContentPreviewShowing()) {\n            offset += stickyContentPreview.getHeight();\n        }\n\n        if (shouldShowTabs()) {\n            offset += findViewById(R.id.tabs).getHeight();\n        }\n\n        if (recyclerView.getVisibility() == View.VISIBLE) {\n            int directShareHeight = 0;\n            rowsToShow = Math.min(4, rowsToShow);\n            boolean shouldShowExtraRow = shouldShowExtraRow(rowsToShow);\n            mLastNumberOfChildren = recyclerView.getChildCount();\n            for (int i = 0, childCount = recyclerView.getChildCount();\n                    i < childCount && rowsToShow > 0; i++) {\n                View child = recyclerView.getChildAt(i);\n                if (((GridLayoutManager.LayoutParams)\n                        child.getLayoutParams()).getSpanIndex() != 0) {\n                    continue;\n                }\n                int height = child.getHeight();\n                offset += height;\n                if (shouldShowExtraRow) {\n                    offset += height;\n                }\n\n                if (gridAdapter.getTargetType(\n                        recyclerView.getChildAdapterPosition(child))\n                        == ChooserListAdapter.TARGET_SERVICE) {\n                    directShareHeight = height;\n                }\n                rowsToShow--;\n            }\n\n            boolean isExpandable = getResources().getConfiguration().orientation\n                    == Configuration.ORIENTATION_PORTRAIT && !isInMultiWindowMode();\n            if (directShareHeight != 0 && isSendAction(getTargetIntent())\n                    && isExpandable) {\n                // make sure to leave room for direct share 4->8 expansion\n                int requiredExpansionHeight =\n                        (int) (directShareHeight / DIRECT_SHARE_EXPANSION_RATE);\n                int topInset = mSystemWindowInsets != null ? mSystemWindowInsets.top : 0;\n                int minHeight = bottom - top - mResolverDrawerLayout.getAlwaysShowHeight()\n                        - requiredExpansionHeight - topInset - bottomInset;\n\n                offset = Math.min(offset, minHeight);\n            }\n        } else {\n            ViewGroup currentEmptyStateView = getActiveEmptyStateView();\n            if (currentEmptyStateView.getVisibility() == View.VISIBLE) {\n                offset += currentEmptyStateView.getHeight();\n            }\n        }\n\n        return Math.min(offset, bottom - top);\n    }\n\n    /**\n     * If we have a tabbed view and are showing 1 row in the current profile and an empty\n     * state screen in the other profile, to prevent cropping of the empty state screen we show\n     * a second row in the current profile.\n     */\n    private boolean shouldShowExtraRow(int rowsToShow) {\n        return shouldShowTabs()\n                && rowsToShow == 1\n                && mChooserMultiProfilePagerAdapter.shouldShowEmptyStateScreen(\n                        mChooserMultiProfilePagerAdapter.getInactiveListAdapter());\n    }\n\n    /**\n     * Returns {@link #PROFILE_PERSONAL}, {@link #PROFILE_WORK}, or -1 if the given user handle\n     * does not match either the personal or work user handle.\n     **/\n    private int getProfileForUser(UserHandle currentUserHandle) {\n        if (currentUserHandle.equals(getPersonalProfileUserHandle())) {\n            return PROFILE_PERSONAL;\n        } else if (currentUserHandle.equals(getWorkProfileUserHandle())) {\n            return PROFILE_WORK;\n        }\n        Log.e(TAG, \"User \" + currentUserHandle + \" does not belong to a personal or work profile.\");\n        return -1;\n    }\n\n    private ViewGroup getActiveEmptyStateView() {\n        int currentPage = mChooserMultiProfilePagerAdapter.getCurrentPage();\n        return mChooserMultiProfilePagerAdapter.getItem(currentPage).getEmptyStateView();\n    }\n\n    static class BaseChooserTargetComparator implements Comparator<ChooserTarget> {\n        @Override\n        public int compare(ChooserTarget lhs, ChooserTarget rhs) {\n            // Descending order\n            return (int) Math.signum(rhs.getScore() - lhs.getScore());\n        }\n    }\n\n    @Override // ResolverListCommunicator\n    public void onHandlePackagesChanged(ResolverListAdapter listAdapter) {\n        mChooserMultiProfilePagerAdapter.getActiveListAdapter().notifyDataSetChanged();\n        super.onHandlePackagesChanged(listAdapter);\n    }\n\n    @Override // SelectableTargetInfoCommunicator\n    public ActivityInfoPresentationGetter makePresentationGetter(ActivityInfo info) {\n        return mChooserMultiProfilePagerAdapter.getActiveListAdapter().makePresentationGetter(info);\n    }\n\n    @Override // SelectableTargetInfoCommunicator\n    public Intent getReferrerFillInIntent() {\n        return mReferrerFillInIntent;\n    }\n\n    @Override // ChooserListCommunicator\n    public int getMaxRankedTargets() {\n        return mMaxTargetsPerRow;\n    }\n\n    @Override // ChooserListCommunicator\n    public void sendListViewUpdateMessage(UserHandle userHandle) {\n        Message msg = Message.obtain();\n        msg.what = ChooserHandler.LIST_VIEW_UPDATE_MESSAGE;\n        msg.obj = userHandle;\n        mChooserHandler.sendMessageDelayed(msg, mListViewUpdateDelayMs);\n    }\n\n    @Override\n    public void onListRebuilt(ResolverListAdapter listAdapter, boolean rebuildComplete) {\n        setupScrollListener();\n        maybeSetupGlobalLayoutListener();\n\n        ChooserListAdapter chooserListAdapter = (ChooserListAdapter) listAdapter;\n        if (chooserListAdapter.getUserHandle()\n                .equals(mChooserMultiProfilePagerAdapter.getCurrentUserHandle())) {\n            mChooserMultiProfilePagerAdapter.getActiveAdapterView()\n                    .setAdapter(mChooserMultiProfilePagerAdapter.getCurrentRootAdapter());\n            mChooserMultiProfilePagerAdapter\n                    .setupListAdapter(mChooserMultiProfilePagerAdapter.getCurrentPage());\n        }\n\n        if (chooserListAdapter.mDisplayList == null\n                || chooserListAdapter.mDisplayList.isEmpty()) {\n            chooserListAdapter.notifyDataSetChanged();\n        } else {\n            chooserListAdapter.updateAlphabeticalList();\n        }\n\n        if (rebuildComplete) {\n            getChooserActivityLogger().logSharesheetAppLoadComplete();\n            maybeQueryAdditionalPostProcessingTargets(chooserListAdapter);\n            mLatencyTracker.onActionEnd(ACTION_LOAD_SHARE_SHEET);\n        }\n    }\n\n    private void maybeQueryAdditionalPostProcessingTargets(ChooserListAdapter chooserListAdapter) {\n        // don't support direct share on low ram devices\n        if (ActivityManager.isLowRamDeviceStatic()) {\n            return;\n        }\n\n        // no need to query direct share for work profile when its locked or disabled\n        if (!shouldQueryShortcutManager(chooserListAdapter.getUserHandle())) {\n            return;\n        }\n\n        if (ChooserFlags.USE_PREDICTION_MANAGER_FOR_DIRECT_TARGETS) {\n            if (DEBUG) {\n                Log.d(TAG, \"querying direct share targets from ShortcutManager\");\n            }\n\n            queryDirectShareTargets(chooserListAdapter, false);\n        }\n    }\n\n    @VisibleForTesting\n    protected boolean isUserRunning(UserHandle userHandle) {\n        UserManager userManager = getSystemService(UserManager.class);\n        return userManager.isUserRunning(userHandle);\n    }\n\n    @VisibleForTesting\n    protected boolean isUserUnlocked(UserHandle userHandle) {\n        UserManager userManager = getSystemService(UserManager.class);\n        return userManager.isUserUnlocked(userHandle);\n    }\n\n    @VisibleForTesting\n    protected boolean isQuietModeEnabled(UserHandle userHandle) {\n        UserManager userManager = getSystemService(UserManager.class);\n        return userManager.isQuietModeEnabled(userHandle);\n    }\n\n    private void setupScrollListener() {\n        if (mResolverDrawerLayout == null) {\n            return;\n        }\n        int elevatedViewResId = shouldShowTabs() ? R.id.tabs : R.id.chooser_header;\n        final View elevatedView = mResolverDrawerLayout.findViewById(elevatedViewResId);\n        final float defaultElevation = elevatedView.getElevation();\n        final float chooserHeaderScrollElevation =\n                getResources().getDimensionPixelSize(R.dimen.chooser_header_scroll_elevation);\n        mChooserMultiProfilePagerAdapter.getActiveAdapterView().addOnScrollListener(\n                new RecyclerView.OnScrollListener() {\n                    public void onScrollStateChanged(RecyclerView view, int scrollState) {\n                        if (scrollState == RecyclerView.SCROLL_STATE_IDLE) {\n                            if (mScrollStatus == SCROLL_STATUS_SCROLLING_VERTICAL) {\n                                mScrollStatus = SCROLL_STATUS_IDLE;\n                                setHorizontalScrollingEnabled(true);\n                            }\n                        } else if (scrollState == RecyclerView.SCROLL_STATE_DRAGGING) {\n                            if (mScrollStatus == SCROLL_STATUS_IDLE) {\n                                mScrollStatus = SCROLL_STATUS_SCROLLING_VERTICAL;\n                                setHorizontalScrollingEnabled(false);\n                            }\n                        }\n                    }\n\n                    public void onScrolled(RecyclerView view, int dx, int dy) {\n                        if (view.getChildCount() > 0) {\n                            View child = view.getLayoutManager().findViewByPosition(0);\n                            if (child == null || child.getTop() < 0) {\n                                elevatedView.setElevation(chooserHeaderScrollElevation);\n                                return;\n                            }\n                        }\n\n                        elevatedView.setElevation(defaultElevation);\n                    }\n                });\n    }\n\n    private void maybeSetupGlobalLayoutListener() {\n        if (shouldShowTabs()) {\n            return;\n        }\n        final View recyclerView = mChooserMultiProfilePagerAdapter.getActiveAdapterView();\n        recyclerView.getViewTreeObserver()\n                .addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {\n                    @Override\n                    public void onGlobalLayout() {\n                        // Fixes an issue were the accessibility border disappears on list creation.\n                        recyclerView.getViewTreeObserver().removeOnGlobalLayoutListener(this);\n                        final TextView titleView = findViewById(R.id.title);\n                        if (titleView != null) {\n                            titleView.setFocusable(true);\n                            titleView.setFocusableInTouchMode(true);\n                            titleView.requestFocus();\n                            titleView.requestAccessibilityFocus();\n                        }\n                    }\n                });\n    }\n\n    @Override // ChooserListCommunicator\n    public boolean isSendAction(Intent targetIntent) {\n        if (targetIntent == null) {\n            return false;\n        }\n\n        String action = targetIntent.getAction();\n        if (action == null) {\n            return false;\n        }\n\n        if (Intent.ACTION_SEND.equals(action) || Intent.ACTION_SEND_MULTIPLE.equals(action)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * The sticky content preview is shown only when we have a tabbed view. It's shown above\n     * the tabs so it is not part of the scrollable list. If we are not in tabbed view,\n     * we instead show the content preview as a regular list item.\n     */\n    private boolean shouldShowStickyContentPreview() {\n        return shouldShowStickyContentPreviewNoOrientationCheck()\n                && !getResources().getBoolean(R.bool.resolver_landscape_phone);\n    }\n\n    private boolean shouldShowStickyContentPreviewNoOrientationCheck() {\n        return shouldShowTabs()\n                && mMultiProfilePagerAdapter.getListAdapterForUserHandle(\n                UserHandle.of(UserHandle.myUserId())).getCount() > 0\n                && isSendAction(getTargetIntent());\n    }\n\n    private void updateStickyContentPreview() {\n        if (shouldShowStickyContentPreviewNoOrientationCheck()) {\n            // The sticky content preview is only shown when we show the work and personal tabs.\n            // We don't show it in landscape as otherwise there is no room for scrolling.\n            // If the sticky content preview will be shown at some point with orientation change,\n            // then always preload it to avoid subsequent resizing of the share sheet.\n            ViewGroup contentPreviewContainer = findViewById(R.id.content_preview_container);\n            if (contentPreviewContainer.getChildCount() == 0) {\n                ViewGroup contentPreviewView = createContentPreviewView(contentPreviewContainer);\n                contentPreviewContainer.addView(contentPreviewView);\n            }\n        }\n        if (shouldShowStickyContentPreview()) {\n            showStickyContentPreview();\n        } else {\n            hideStickyContentPreview();\n        }\n    }\n\n    private void showStickyContentPreview() {\n        if (isStickyContentPreviewShowing()) {\n            return;\n        }\n        ViewGroup contentPreviewContainer = findViewById(R.id.content_preview_container);\n        contentPreviewContainer.setVisibility(View.VISIBLE);\n    }\n\n    private boolean isStickyContentPreviewShowing() {\n        ViewGroup contentPreviewContainer = findViewById(R.id.content_preview_container);\n        return contentPreviewContainer.getVisibility() == View.VISIBLE;\n    }\n\n    private void hideStickyContentPreview() {\n        if (!isStickyContentPreviewShowing()) {\n            return;\n        }\n        ViewGroup contentPreviewContainer = findViewById(R.id.content_preview_container);\n        contentPreviewContainer.setVisibility(View.GONE);\n    }\n\n    private void logActionShareWithPreview() {\n        Intent targetIntent = getTargetIntent();\n        int previewType = findPreferredContentPreview(targetIntent, getContentResolver());\n        getMetricsLogger().write(new LogMaker(MetricsEvent.ACTION_SHARE_WITH_PREVIEW)\n                .setSubtype(previewType));\n    }\n\n    abstract static class ViewHolderBase extends RecyclerView.ViewHolder {\n        private int mViewType;\n\n        ViewHolderBase(View itemView, int viewType) {\n            super(itemView);\n            this.mViewType = viewType;\n        }\n\n        int getViewType() {\n            return mViewType;\n        }\n    }\n\n    /**\n     * Used to bind types of individual item including\n     * {@link ChooserGridAdapter#VIEW_TYPE_NORMAL},\n     * {@link ChooserGridAdapter#VIEW_TYPE_CONTENT_PREVIEW},\n     * {@link ChooserGridAdapter#VIEW_TYPE_PROFILE},\n     * and {@link ChooserGridAdapter#VIEW_TYPE_AZ_LABEL}.\n     */\n    final class ItemViewHolder extends ViewHolderBase {\n        ResolverListAdapter.ViewHolder mWrappedViewHolder;\n        int mListPosition = ChooserListAdapter.NO_POSITION;\n\n        ItemViewHolder(View itemView, boolean isClickable, int viewType) {\n            super(itemView, viewType);\n            mWrappedViewHolder = new ResolverListAdapter.ViewHolder(itemView);\n            if (isClickable) {\n                itemView.setOnClickListener(v -> startSelected(mListPosition,\n                        false/* always */, true/* filterd */));\n\n                itemView.setOnLongClickListener(v -> {\n                    final TargetInfo ti = mChooserMultiProfilePagerAdapter.getActiveListAdapter()\n                            .targetInfoForPosition(mListPosition, /* filtered */ true);\n\n                    // This should always be the case for ItemViewHolder, check for validity\n                    if (ti instanceof DisplayResolveInfo && shouldShowTargetDetails(ti)) {\n                        showTargetDetails((DisplayResolveInfo) ti);\n                    }\n                    return true;\n                });\n            }\n        }\n    }\n\n    private boolean shouldShowTargetDetails(TargetInfo ti) {\n        ComponentName nearbyShare = getNearbySharingComponent();\n        //  Suppress target details for nearby share to hide pin/unpin action\n        boolean isNearbyShare = nearbyShare != null && nearbyShare.equals(\n                ti.getResolvedComponentName()) && shouldNearbyShareBeFirstInRankedRow();\n        return ti instanceof SelectableTargetInfo\n                || (ti instanceof DisplayResolveInfo && !isNearbyShare);\n    }\n\n    /**\n     * Add a footer to the list, to support scrolling behavior below the navbar.\n     */\n    static final class FooterViewHolder extends ViewHolderBase {\n        FooterViewHolder(View itemView, int viewType) {\n            super(itemView, viewType);\n        }\n    }\n\n    /**\n     * Intentionally override the {@link ResolverActivity} implementation as we only need that\n     * implementation for the intent resolver case.\n     */\n    @Override\n    public void onButtonClick(View v) {}\n\n    /**\n     * Intentionally override the {@link ResolverActivity} implementation as we only need that\n     * implementation for the intent resolver case.\n     */\n    @Override\n    protected void resetButtonBar() {}\n\n    @Override\n    protected String getMetricsCategory() {\n        return METRICS_CATEGORY_CHOOSER;\n    }\n\n    @Override\n    protected void onProfileTabSelected() {\n        ChooserGridAdapter currentRootAdapter =\n                mChooserMultiProfilePagerAdapter.getCurrentRootAdapter();\n        currentRootAdapter.updateDirectShareExpansion();\n        // This fixes an edge case where after performing a variety of gestures, vertical scrolling\n        // ends up disabled. That's because at some point the old tab's vertical scrolling is\n        // disabled and the new tab's is enabled. For context, see b/159997845\n        setVerticalScrollEnabled(true);\n        if (mResolverDrawerLayout != null) {\n            mResolverDrawerLayout.scrollNestedScrollableChildBackToTop();\n        }\n    }\n\n    @Override\n    protected WindowInsets onApplyWindowInsets(View v, WindowInsets insets) {\n        if (shouldShowTabs()) {\n            mChooserMultiProfilePagerAdapter\n                    .setEmptyStateBottomOffset(insets.getSystemWindowInsetBottom());\n            mChooserMultiProfilePagerAdapter.setupContainerPadding(\n                    getActiveEmptyStateView().findViewById(R.id.resolver_empty_state_container));\n        }\n        return super.onApplyWindowInsets(v, insets);\n    }\n\n    private void setHorizontalScrollingEnabled(boolean enabled) {\n        ResolverViewPager viewPager = findViewById(R.id.profile_pager);\n        viewPager.setSwipingEnabled(enabled);\n    }\n\n    private void setVerticalScrollEnabled(boolean enabled) {\n        ChooserGridLayoutManager layoutManager =\n                (ChooserGridLayoutManager) mChooserMultiProfilePagerAdapter.getActiveAdapterView()\n                        .getLayoutManager();\n        layoutManager.setVerticalScrollEnabled(enabled);\n    }\n\n    @Override\n    void onHorizontalSwipeStateChanged(int state) {\n        if (state == ViewPager.SCROLL_STATE_DRAGGING) {\n            if (mScrollStatus == SCROLL_STATUS_IDLE) {\n                mScrollStatus = SCROLL_STATUS_SCROLLING_HORIZONTAL;\n                setVerticalScrollEnabled(false);\n            }\n        } else if (state == ViewPager.SCROLL_STATE_IDLE) {\n            if (mScrollStatus == SCROLL_STATUS_SCROLLING_HORIZONTAL) {\n                mScrollStatus = SCROLL_STATUS_IDLE;\n                setVerticalScrollEnabled(true);\n            }\n        }\n    }\n\n    /**\n     * Adapter for all types of items and targets in ShareSheet.\n     * Note that ranked sections like Direct Share - while appearing grid-like - are handled on the\n     * row level by this adapter but not on the item level. Individual targets within the row are\n     * handled by {@link ChooserListAdapter}\n     */\n    @VisibleForTesting\n    public final class ChooserGridAdapter extends RecyclerView.Adapter<RecyclerView.ViewHolder> {\n        private ChooserListAdapter mChooserListAdapter;\n        private final LayoutInflater mLayoutInflater;\n\n        private DirectShareViewHolder mDirectShareViewHolder;\n        private int mChooserTargetWidth = 0;\n        private boolean mShowAzLabelIfPoss;\n        private boolean mLayoutRequested = false;\n\n        private int mFooterHeight = 0;\n\n        private static final int VIEW_TYPE_DIRECT_SHARE = 0;\n        private static final int VIEW_TYPE_NORMAL = 1;\n        private static final int VIEW_TYPE_CONTENT_PREVIEW = 2;\n        private static final int VIEW_TYPE_PROFILE = 3;\n        private static final int VIEW_TYPE_AZ_LABEL = 4;\n        private static final int VIEW_TYPE_CALLER_AND_RANK = 5;\n        private static final int VIEW_TYPE_FOOTER = 6;\n\n        private static final int NUM_EXPANSIONS_TO_HIDE_AZ_LABEL = 20;\n\n        ChooserGridAdapter(ChooserListAdapter wrappedAdapter) {\n            super();\n            mChooserListAdapter = wrappedAdapter;\n            mLayoutInflater = LayoutInflater.from(ChooserActivity.this);\n\n            mShowAzLabelIfPoss = getNumSheetExpansions() < NUM_EXPANSIONS_TO_HIDE_AZ_LABEL;\n\n            wrappedAdapter.registerDataSetObserver(new DataSetObserver() {\n                @Override\n                public void onChanged() {\n                    super.onChanged();\n                    notifyDataSetChanged();\n                }\n\n                @Override\n                public void onInvalidated() {\n                    super.onInvalidated();\n                    notifyDataSetChanged();\n                }\n            });\n        }\n\n        public void setFooterHeight(int height) {\n            mFooterHeight = height;\n        }\n\n        /**\n         * Calculate the chooser target width to maximize space per item\n         *\n         * @param width The new row width to use for recalculation\n         * @return true if the view width has changed\n         */\n        public boolean calculateChooserTargetWidth(int width) {\n            if (width == 0) {\n                return false;\n            }\n\n            // Limit width to the maximum width of the chooser activity\n            int maxWidth = getResources().getDimensionPixelSize(R.dimen.chooser_width);\n            width = Math.min(maxWidth, width);\n\n            int newWidth = width / mMaxTargetsPerRow;\n            if (newWidth != mChooserTargetWidth) {\n                mChooserTargetWidth = newWidth;\n                return true;\n            }\n\n            return false;\n        }\n\n        /**\n         * Hides the list item content preview.\n         * <p>Not to be confused with the sticky content preview which is above the\n         * personal and work tabs.\n         */\n        public void hideContentPreview() {\n            mLayoutRequested = true;\n            notifyDataSetChanged();\n        }\n\n        public boolean consumeLayoutRequest() {\n            boolean oldValue = mLayoutRequested;\n            mLayoutRequested = false;\n            return oldValue;\n        }\n\n        public int getRowCount() {\n            return (int) (\n                    getSystemRowCount()\n                            + getProfileRowCount()\n                            + getServiceTargetRowCount()\n                            + getCallerAndRankedTargetRowCount()\n                            + getAzLabelRowCount()\n                            + Math.ceil(\n                            (float) mChooserListAdapter.getAlphaTargetCount()\n                                    / mMaxTargetsPerRow)\n            );\n        }\n\n        /**\n         * Whether the \"system\" row of targets is displayed.\n         * This area includes the content preview (if present) and action row.\n         */\n        public int getSystemRowCount() {\n            // For the tabbed case we show the sticky content preview above the tabs,\n            // please refer to shouldShowStickyContentPreview\n            if (shouldShowTabs()) {\n                return 0;\n            }\n\n            if (!isSendAction(getTargetIntent())) {\n                return 0;\n            }\n\n            if (mChooserListAdapter == null || mChooserListAdapter.getCount() == 0) {\n                return 0;\n            }\n\n            return 1;\n        }\n\n        public int getProfileRowCount() {\n            if (shouldShowTabs()) {\n                return 0;\n            }\n            return mChooserListAdapter.getOtherProfile() == null ? 0 : 1;\n        }\n\n        public int getFooterRowCount() {\n            return 1;\n        }\n\n        public int getCallerAndRankedTargetRowCount() {\n            return (int) Math.ceil(\n                    ((float) mChooserListAdapter.getCallerTargetCount()\n                            + mChooserListAdapter.getRankedTargetCount()) / mMaxTargetsPerRow);\n        }\n\n        // There can be at most one row in the listview, that is internally\n        // a ViewGroup with 2 rows\n        public int getServiceTargetRowCount() {\n            if (isSendAction(getTargetIntent())\n                    && !ActivityManager.isLowRamDeviceStatic()) {\n                return 1;\n            }\n            return 0;\n        }\n\n        public int getAzLabelRowCount() {\n            // Only show a label if the a-z list is showing\n            return (mShowAzLabelIfPoss && mChooserListAdapter.getAlphaTargetCount() > 0) ? 1 : 0;\n        }\n\n        @Override\n        public int getItemCount() {\n            return (int) (\n                    getSystemRowCount()\n                            + getProfileRowCount()\n                            + getServiceTargetRowCount()\n                            + getCallerAndRankedTargetRowCount()\n                            + getAzLabelRowCount()\n                            + mChooserListAdapter.getAlphaTargetCount()\n                            + getFooterRowCount()\n            );\n        }\n\n        @Override\n        public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n            switch (viewType) {\n                case VIEW_TYPE_CONTENT_PREVIEW:\n                    return new ItemViewHolder(createContentPreviewView(parent), false, viewType);\n                case VIEW_TYPE_PROFILE:\n                    return new ItemViewHolder(createProfileView(parent), false, viewType);\n                case VIEW_TYPE_AZ_LABEL:\n                    return new ItemViewHolder(createAzLabelView(parent), false, viewType);\n                case VIEW_TYPE_NORMAL:\n                    return new ItemViewHolder(\n                            mChooserListAdapter.createView(parent), true, viewType);\n                case VIEW_TYPE_DIRECT_SHARE:\n                case VIEW_TYPE_CALLER_AND_RANK:\n                    return createItemGroupViewHolder(viewType, parent);\n                case VIEW_TYPE_FOOTER:\n                    Space sp = new Space(parent.getContext());\n                    sp.setLayoutParams(new RecyclerView.LayoutParams(\n                            LayoutParams.MATCH_PARENT, mFooterHeight));\n                    return new FooterViewHolder(sp, viewType);\n                default:\n                    // Since we catch all possible viewTypes above, no chance this is being called.\n                    return null;\n            }\n        }\n\n        @Override\n        public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) {\n            int viewType = ((ViewHolderBase) holder).getViewType();\n            switch (viewType) {\n                case VIEW_TYPE_DIRECT_SHARE:\n                case VIEW_TYPE_CALLER_AND_RANK:\n                    bindItemGroupViewHolder(position, (ItemGroupViewHolder) holder);\n                    break;\n                case VIEW_TYPE_NORMAL:\n                    bindItemViewHolder(position, (ItemViewHolder) holder);\n                    break;\n                default:\n            }\n        }\n\n        @Override\n        public int getItemViewType(int position) {\n            int count;\n\n            int countSum = (count = getSystemRowCount());\n            if (count > 0 && position < countSum) return VIEW_TYPE_CONTENT_PREVIEW;\n\n            countSum += (count = getProfileRowCount());\n            if (count > 0 && position < countSum) return VIEW_TYPE_PROFILE;\n\n            countSum += (count = getServiceTargetRowCount());\n            if (count > 0 && position < countSum) return VIEW_TYPE_DIRECT_SHARE;\n\n            countSum += (count = getCallerAndRankedTargetRowCount());\n            if (count > 0 && position < countSum) return VIEW_TYPE_CALLER_AND_RANK;\n\n            countSum += (count = getAzLabelRowCount());\n            if (count > 0 && position < countSum) return VIEW_TYPE_AZ_LABEL;\n\n            if (position == getItemCount() - 1) return VIEW_TYPE_FOOTER;\n\n            return VIEW_TYPE_NORMAL;\n        }\n\n        public int getTargetType(int position) {\n            return mChooserListAdapter.getPositionTargetType(getListPosition(position));\n        }\n\n        private View createProfileView(ViewGroup parent) {\n            View profileRow = mLayoutInflater.inflate(R.layout.chooser_profile_row, parent, false);\n            mProfileView = profileRow.findViewById(R.id.profile_button);\n            mProfileView.setOnClickListener(ChooserActivity.this::onProfileClick);\n            updateProfileViewButton();\n            return profileRow;\n        }\n\n        private View createAzLabelView(ViewGroup parent) {\n            return mLayoutInflater.inflate(R.layout.chooser_az_label_row, parent, false);\n        }\n\n        private ItemGroupViewHolder loadViewsIntoGroup(ItemGroupViewHolder holder) {\n            final int spec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);\n            final int exactSpec = MeasureSpec.makeMeasureSpec(mChooserTargetWidth,\n                    MeasureSpec.EXACTLY);\n            int columnCount = holder.getColumnCount();\n\n            final boolean isDirectShare = holder instanceof DirectShareViewHolder;\n\n            for (int i = 0; i < columnCount; i++) {\n                final View v = mChooserListAdapter.createView(holder.getRowByIndex(i));\n                final int column = i;\n                v.setOnClickListener(new OnClickListener() {\n                    @Override\n                    public void onClick(View v) {\n                        startSelected(holder.getItemIndex(column), false, true);\n                    }\n                });\n\n                // Show menu for both direct share and app share targets after long click.\n                v.setOnLongClickListener(v1 -> {\n                    TargetInfo ti = mChooserListAdapter.targetInfoForPosition(\n                            holder.getItemIndex(column), true);\n                    if (shouldShowTargetDetails(ti)) {\n                        showTargetDetails(ti);\n                    }\n                    return true;\n                });\n\n                holder.addView(i, v);\n\n                // Force Direct Share to be 2 lines and auto-wrap to second line via hoz scroll =\n                // false. TextView#setHorizontallyScrolling must be reset after #setLines. Must be\n                // done before measuring.\n                if (isDirectShare) {\n                    final ViewHolder vh = (ViewHolder) v.getTag();\n                    vh.text.setLines(2);\n                    vh.text.setHorizontallyScrolling(false);\n                    vh.text2.setVisibility(View.GONE);\n                }\n\n                // Force height to be a given so we don't have visual disruption during scaling.\n                v.measure(exactSpec, spec);\n                setViewBounds(v, v.getMeasuredWidth(), v.getMeasuredHeight());\n            }\n\n            final ViewGroup viewGroup = holder.getViewGroup();\n\n            // Pre-measure and fix height so we can scale later.\n            holder.measure();\n            setViewBounds(viewGroup, LayoutParams.MATCH_PARENT, holder.getMeasuredRowHeight());\n\n            if (isDirectShare) {\n                DirectShareViewHolder dsvh = (DirectShareViewHolder) holder;\n                setViewBounds(dsvh.getRow(0), LayoutParams.MATCH_PARENT, dsvh.getMinRowHeight());\n                setViewBounds(dsvh.getRow(1), LayoutParams.MATCH_PARENT, dsvh.getMinRowHeight());\n            }\n\n            viewGroup.setTag(holder);\n            return holder;\n        }\n\n        private void setViewBounds(View view, int widthPx, int heightPx) {\n            LayoutParams lp = view.getLayoutParams();\n            if (lp == null) {\n                lp = new LayoutParams(widthPx, heightPx);\n                view.setLayoutParams(lp);\n            } else {\n                lp.height = heightPx;\n                lp.width = widthPx;\n            }\n        }\n\n        ItemGroupViewHolder createItemGroupViewHolder(int viewType, ViewGroup parent) {\n            if (viewType == VIEW_TYPE_DIRECT_SHARE) {\n                ViewGroup parentGroup = (ViewGroup) mLayoutInflater.inflate(\n                        R.layout.chooser_row_direct_share, parent, false);\n                ViewGroup row1 = (ViewGroup) mLayoutInflater.inflate(R.layout.chooser_row,\n                        parentGroup, false);\n                ViewGroup row2 = (ViewGroup) mLayoutInflater.inflate(R.layout.chooser_row,\n                        parentGroup, false);\n                parentGroup.addView(row1);\n                parentGroup.addView(row2);\n\n                mDirectShareViewHolder = new DirectShareViewHolder(parentGroup,\n                        Lists.newArrayList(row1, row2), mMaxTargetsPerRow, viewType,\n                        mChooserMultiProfilePagerAdapter::getActiveListAdapter);\n                loadViewsIntoGroup(mDirectShareViewHolder);\n\n                return mDirectShareViewHolder;\n            } else {\n                ViewGroup row = (ViewGroup) mLayoutInflater.inflate(R.layout.chooser_row, parent,\n                        false);\n                ItemGroupViewHolder holder =\n                        new SingleRowViewHolder(row, mMaxTargetsPerRow, viewType);\n                loadViewsIntoGroup(holder);\n\n                return holder;\n            }\n        }\n\n        /**\n         * Need to merge CALLER + ranked STANDARD into a single row and prevent a separator from\n         * showing on top of the AZ list if the AZ label is visible. All other types are placed into\n         * their own row as determined by their target type, and dividers are added in the list to\n         * separate each type.\n         */\n        int getRowType(int rowPosition) {\n            // Merge caller and ranked standard into a single row\n            int positionType = mChooserListAdapter.getPositionTargetType(rowPosition);\n            if (positionType == ChooserListAdapter.TARGET_CALLER) {\n                return ChooserListAdapter.TARGET_STANDARD;\n            }\n\n            // If an the A-Z label is shown, prevent a separator from appearing by making the A-Z\n            // row type the same as the suggestion row type\n            if (getAzLabelRowCount() > 0 && positionType == ChooserListAdapter.TARGET_STANDARD_AZ) {\n                return ChooserListAdapter.TARGET_STANDARD;\n            }\n\n            return positionType;\n        }\n\n        void bindItemViewHolder(int position, ItemViewHolder holder) {\n            View v = holder.itemView;\n            int listPosition = getListPosition(position);\n            holder.mListPosition = listPosition;\n            mChooserListAdapter.bindView(listPosition, v);\n        }\n\n        void bindItemGroupViewHolder(int position, ItemGroupViewHolder holder) {\n            final ViewGroup viewGroup = (ViewGroup) holder.itemView;\n            int start = getListPosition(position);\n            int startType = getRowType(start);\n\n            int columnCount = holder.getColumnCount();\n            int end = start + columnCount - 1;\n            while (getRowType(end) != startType && end >= start) {\n                end--;\n            }\n\n            if (end == start && mChooserListAdapter.getItem(start) instanceof EmptyTargetInfo) {\n                final TextView textView = viewGroup.findViewById(R.id.chooser_row_text_option);\n\n                if (textView.getVisibility() != View.VISIBLE) {\n                    textView.setAlpha(0.0f);\n                    textView.setVisibility(View.VISIBLE);\n                    textView.setText(R.string.chooser_no_direct_share_targets);\n\n                    ValueAnimator fadeAnim = ObjectAnimator.ofFloat(textView, \"alpha\", 0.0f, 1.0f);\n                    fadeAnim.setInterpolator(new DecelerateInterpolator(1.0f));\n\n                    float translationInPx = getResources().getDimensionPixelSize(\n                            R.dimen.chooser_row_text_option_translate);\n                    textView.setTranslationY(translationInPx);\n                    ValueAnimator translateAnim = ObjectAnimator.ofFloat(textView, \"translationY\",\n                            0.0f);\n                    translateAnim.setInterpolator(new DecelerateInterpolator(1.0f));\n\n                    AnimatorSet animSet = new AnimatorSet();\n                    animSet.setDuration(NO_DIRECT_SHARE_ANIM_IN_MILLIS);\n                    animSet.setStartDelay(NO_DIRECT_SHARE_ANIM_IN_MILLIS);\n                    animSet.playTogether(fadeAnim, translateAnim);\n                    animSet.start();\n                }\n            }\n\n            for (int i = 0; i < columnCount; i++) {\n                final View v = holder.getView(i);\n\n                if (start + i <= end) {\n                    holder.setViewVisibility(i, View.VISIBLE);\n                    holder.setItemIndex(i, start + i);\n                    mChooserListAdapter.bindView(holder.getItemIndex(i), v);\n                } else {\n                    holder.setViewVisibility(i, View.INVISIBLE);\n                }\n            }\n        }\n\n        int getListPosition(int position) {\n            position -= getSystemRowCount() + getProfileRowCount();\n\n            final int serviceCount = mChooserListAdapter.getServiceTargetCount();\n            final int serviceRows = (int) Math.ceil((float) serviceCount / getMaxRankedTargets());\n            if (position < serviceRows) {\n                return position * mMaxTargetsPerRow;\n            }\n\n            position -= serviceRows;\n\n            final int callerAndRankedCount = mChooserListAdapter.getCallerTargetCount()\n                                                 + mChooserListAdapter.getRankedTargetCount();\n            final int callerAndRankedRows = getCallerAndRankedTargetRowCount();\n            if (position < callerAndRankedRows) {\n                return serviceCount + position * mMaxTargetsPerRow;\n            }\n\n            position -= getAzLabelRowCount() + callerAndRankedRows;\n\n            return callerAndRankedCount + serviceCount + position;\n        }\n\n        public void handleScroll(View v, int y, int oldy) {\n            boolean canExpandDirectShare = canExpandDirectShare();\n            if (mDirectShareViewHolder != null && canExpandDirectShare) {\n                mDirectShareViewHolder.handleScroll(\n                        mChooserMultiProfilePagerAdapter.getActiveAdapterView(), y, oldy,\n                        mMaxTargetsPerRow);\n            }\n        }\n\n        /**\n         * Only expand direct share area if there is a minimum number of targets.\n         */\n        private boolean canExpandDirectShare() {\n            // Do not enable until we have confirmed more apps are using sharing shortcuts\n            // Check git history for enablement logic\n            return false;\n        }\n\n        public ChooserListAdapter getListAdapter() {\n            return mChooserListAdapter;\n        }\n\n        boolean shouldCellSpan(int position) {\n            return getItemViewType(position) == VIEW_TYPE_NORMAL;\n        }\n\n        void updateDirectShareExpansion() {\n            if (mDirectShareViewHolder == null || !canExpandDirectShare()) {\n                return;\n            }\n            RecyclerView activeAdapterView =\n                    mChooserMultiProfilePagerAdapter.getActiveAdapterView();\n            if (mResolverDrawerLayout.isCollapsed()) {\n                mDirectShareViewHolder.collapse(activeAdapterView);\n            } else {\n                mDirectShareViewHolder.expand(activeAdapterView);\n            }\n        }\n    }\n\n    /**\n     * Used to bind types for group of items including:\n     * {@link ChooserGridAdapter#VIEW_TYPE_DIRECT_SHARE},\n     * and {@link ChooserGridAdapter#VIEW_TYPE_CALLER_AND_RANK}.\n     */\n    abstract static class ItemGroupViewHolder extends ViewHolderBase {\n        protected int mMeasuredRowHeight;\n        private int[] mItemIndices;\n        protected final View[] mCells;\n        private final int mColumnCount;\n\n        ItemGroupViewHolder(int cellCount, View itemView, int viewType) {\n            super(itemView, viewType);\n            this.mCells = new View[cellCount];\n            this.mItemIndices = new int[cellCount];\n            this.mColumnCount = cellCount;\n        }\n\n        abstract ViewGroup addView(int index, View v);\n\n        abstract ViewGroup getViewGroup();\n\n        abstract ViewGroup getRowByIndex(int index);\n\n        abstract ViewGroup getRow(int rowNumber);\n\n        abstract void setViewVisibility(int i, int visibility);\n\n        public int getColumnCount() {\n            return mColumnCount;\n        }\n\n        public void measure() {\n            final int spec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);\n            getViewGroup().measure(spec, spec);\n            mMeasuredRowHeight = getViewGroup().getMeasuredHeight();\n        }\n\n        public int getMeasuredRowHeight() {\n            return mMeasuredRowHeight;\n        }\n\n        public void setItemIndex(int itemIndex, int listIndex) {\n            mItemIndices[itemIndex] = listIndex;\n        }\n\n        public int getItemIndex(int itemIndex) {\n            return mItemIndices[itemIndex];\n        }\n\n        public View getView(int index) {\n            return mCells[index];\n        }\n    }\n\n    static class SingleRowViewHolder extends ItemGroupViewHolder {\n        private final ViewGroup mRow;\n\n        SingleRowViewHolder(ViewGroup row, int cellCount, int viewType) {\n            super(cellCount, row, viewType);\n\n            this.mRow = row;\n        }\n\n        public ViewGroup getViewGroup() {\n            return mRow;\n        }\n\n        public ViewGroup getRowByIndex(int index) {\n            return mRow;\n        }\n\n        public ViewGroup getRow(int rowNumber) {\n            if (rowNumber == 0) return mRow;\n            return null;\n        }\n\n        public ViewGroup addView(int index, View v) {\n            mRow.addView(v);\n            mCells[index] = v;\n\n            return mRow;\n        }\n\n        public void setViewVisibility(int i, int visibility) {\n            getView(i).setVisibility(visibility);\n        }\n    }\n\n    static class DirectShareViewHolder extends ItemGroupViewHolder {\n        private final ViewGroup mParent;\n        private final List<ViewGroup> mRows;\n        private int mCellCountPerRow;\n\n        private boolean mHideDirectShareExpansion = false;\n        private int mDirectShareMinHeight = 0;\n        private int mDirectShareCurrHeight = 0;\n        private int mDirectShareMaxHeight = 0;\n\n        private final boolean[] mCellVisibility;\n\n        private final Supplier<ChooserListAdapter> mListAdapterSupplier;\n\n        DirectShareViewHolder(ViewGroup parent, List<ViewGroup> rows, int cellCountPerRow,\n                int viewType, Supplier<ChooserListAdapter> listAdapterSupplier) {\n            super(rows.size() * cellCountPerRow, parent, viewType);\n\n            this.mParent = parent;\n            this.mRows = rows;\n            this.mCellCountPerRow = cellCountPerRow;\n            this.mCellVisibility = new boolean[rows.size() * cellCountPerRow];\n            this.mListAdapterSupplier = listAdapterSupplier;\n        }\n\n        public ViewGroup addView(int index, View v) {\n            ViewGroup row = getRowByIndex(index);\n            row.addView(v);\n            mCells[index] = v;\n\n            return row;\n        }\n\n        public ViewGroup getViewGroup() {\n            return mParent;\n        }\n\n        public ViewGroup getRowByIndex(int index) {\n            return mRows.get(index / mCellCountPerRow);\n        }\n\n        public ViewGroup getRow(int rowNumber) {\n            return mRows.get(rowNumber);\n        }\n\n        public void measure() {\n            final int spec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);\n            getRow(0).measure(spec, spec);\n            getRow(1).measure(spec, spec);\n\n            mDirectShareMinHeight = getRow(0).getMeasuredHeight();\n            mDirectShareCurrHeight = mDirectShareCurrHeight > 0\n                    ? mDirectShareCurrHeight : mDirectShareMinHeight;\n            mDirectShareMaxHeight = 2 * mDirectShareMinHeight;\n        }\n\n        public int getMeasuredRowHeight() {\n            return mDirectShareCurrHeight;\n        }\n\n        public int getMinRowHeight() {\n            return mDirectShareMinHeight;\n        }\n\n        public void setViewVisibility(int i, int visibility) {\n            final View v = getView(i);\n            if (visibility == View.VISIBLE) {\n                mCellVisibility[i] = true;\n                v.setVisibility(visibility);\n                v.setAlpha(1.0f);\n            } else if (visibility == View.INVISIBLE && mCellVisibility[i]) {\n                mCellVisibility[i] = false;\n\n                ValueAnimator fadeAnim = ObjectAnimator.ofFloat(v, \"alpha\", 1.0f, 0f);\n                fadeAnim.setDuration(NO_DIRECT_SHARE_ANIM_IN_MILLIS);\n                fadeAnim.setInterpolator(new AccelerateInterpolator(1.0f));\n                fadeAnim.addListener(new AnimatorListenerAdapter() {\n                    public void onAnimationEnd(Animator animation) {\n                        v.setVisibility(View.INVISIBLE);\n                    }\n                });\n                fadeAnim.start();\n            }\n        }\n\n        public void handleScroll(RecyclerView view, int y, int oldy, int maxTargetsPerRow) {\n            // only exit early if fully collapsed, otherwise onListRebuilt() with shifting\n            // targets can lock us into an expanded mode\n            boolean notExpanded = mDirectShareCurrHeight == mDirectShareMinHeight;\n            if (notExpanded) {\n                if (mHideDirectShareExpansion) {\n                    return;\n                }\n\n                // only expand if we have more than maxTargetsPerRow, and delay that decision\n                // until they start to scroll\n                ChooserListAdapter adapter = mListAdapterSupplier.get();\n                int validTargets = adapter.getSelectableServiceTargetCount();\n                if (validTargets <= maxTargetsPerRow) {\n                    mHideDirectShareExpansion = true;\n                    return;\n                }\n            }\n\n            int yDiff = (int) ((oldy - y) * DIRECT_SHARE_EXPANSION_RATE);\n\n            int prevHeight = mDirectShareCurrHeight;\n            int newHeight = Math.min(prevHeight + yDiff, mDirectShareMaxHeight);\n            newHeight = Math.max(newHeight, mDirectShareMinHeight);\n            yDiff = newHeight - prevHeight;\n\n            updateDirectShareRowHeight(view, yDiff, newHeight);\n        }\n\n        void expand(RecyclerView view) {\n            updateDirectShareRowHeight(view, mDirectShareMaxHeight - mDirectShareCurrHeight,\n                    mDirectShareMaxHeight);\n        }\n\n        void collapse(RecyclerView view) {\n            updateDirectShareRowHeight(view, mDirectShareMinHeight - mDirectShareCurrHeight,\n                    mDirectShareMinHeight);\n        }\n\n        private void updateDirectShareRowHeight(RecyclerView view, int yDiff, int newHeight) {\n            if (view == null || view.getChildCount() == 0 || yDiff == 0) {\n                return;\n            }\n\n            // locate the item to expand, and offset the rows below that one\n            boolean foundExpansion = false;\n            for (int i = 0; i < view.getChildCount(); i++) {\n                View child = view.getChildAt(i);\n\n                if (foundExpansion) {\n                    child.offsetTopAndBottom(yDiff);\n                } else {\n                    if (child.getTag() != null && child.getTag() instanceof DirectShareViewHolder) {\n                        int widthSpec = MeasureSpec.makeMeasureSpec(child.getWidth(),\n                                MeasureSpec.EXACTLY);\n                        int heightSpec = MeasureSpec.makeMeasureSpec(newHeight,\n                                MeasureSpec.EXACTLY);\n                        child.measure(widthSpec, heightSpec);\n                        child.getLayoutParams().height = child.getMeasuredHeight();\n                        child.layout(child.getLeft(), child.getTop(), child.getRight(),\n                                child.getTop() + child.getMeasuredHeight());\n\n                        foundExpansion = true;\n                    }\n                }\n            }\n\n            if (foundExpansion) {\n                mDirectShareCurrHeight = newHeight;\n            }\n        }\n    }\n\n    static class ServiceResultInfo {\n        public final DisplayResolveInfo originalTarget;\n        public final List<ChooserTarget> resultTargets;\n        public final UserHandle userHandle;\n\n        public ServiceResultInfo(DisplayResolveInfo ot, List<ChooserTarget> rt,\n                UserHandle userHandle) {\n            originalTarget = ot;\n            resultTargets = rt;\n            this.userHandle = userHandle;\n        }\n    }\n\n    static class ChooserTargetRankingInfo {\n        public final List<AppTarget> scores;\n        public final UserHandle userHandle;\n\n        ChooserTargetRankingInfo(List<AppTarget> chooserTargetScores,\n                UserHandle userHandle) {\n            this.scores = chooserTargetScores;\n            this.userHandle = userHandle;\n        }\n    }\n\n    static class RefinementResultReceiver extends ResultReceiver {\n        private ChooserActivity mChooserActivity;\n        private TargetInfo mSelectedTarget;\n\n        public RefinementResultReceiver(ChooserActivity host, TargetInfo target,\n                Handler handler) {\n            super(handler);\n            mChooserActivity = host;\n            mSelectedTarget = target;\n        }\n\n        @Override\n        protected void onReceiveResult(int resultCode, Bundle resultData) {\n            if (mChooserActivity == null) {\n                Log.e(TAG, \"Destroyed RefinementResultReceiver received a result\");\n                return;\n            }\n            if (resultData == null) {\n                Log.e(TAG, \"RefinementResultReceiver received null resultData\");\n                return;\n            }\n\n            switch (resultCode) {\n                case RESULT_CANCELED:\n                    mChooserActivity.onRefinementCanceled();\n                    break;\n                case RESULT_OK:\n                    Parcelable intentParcelable = resultData.getParcelable(Intent.EXTRA_INTENT);\n                    if (intentParcelable instanceof Intent) {\n                        mChooserActivity.onRefinementResult(mSelectedTarget,\n                                (Intent) intentParcelable);\n                    } else {\n                        Log.e(TAG, \"RefinementResultReceiver received RESULT_OK but no Intent\"\n                                + \" in resultData with key Intent.EXTRA_INTENT\");\n                    }\n                    break;\n                default:\n                    Log.w(TAG, \"Unknown result code \" + resultCode\n                            + \" sent to RefinementResultReceiver\");\n                    break;\n            }\n        }\n\n        public void destroy() {\n            mChooserActivity = null;\n            mSelectedTarget = null;\n        }\n    }\n\n    /**\n     * Used internally to round image corners while obeying view padding.\n     */\n    public static class RoundedRectImageView extends ImageView {\n        private int mRadius = 0;\n        private Path mPath = new Path();\n        private Paint mOverlayPaint = new Paint(0);\n        private Paint mRoundRectPaint = new Paint(0);\n        private Paint mTextPaint = new Paint(Paint.ANTI_ALIAS_FLAG);\n        private String mExtraImageCount = null;\n\n        public RoundedRectImageView(Context context) {\n            super(context);\n        }\n\n        public RoundedRectImageView(Context context, AttributeSet attrs) {\n            this(context, attrs, 0);\n        }\n\n        public RoundedRectImageView(Context context, AttributeSet attrs, int defStyleAttr) {\n            this(context, attrs, defStyleAttr, 0);\n        }\n\n        public RoundedRectImageView(Context context, AttributeSet attrs, int defStyleAttr,\n                int defStyleRes) {\n            super(context, attrs, defStyleAttr, defStyleRes);\n            mRadius = context.getResources().getDimensionPixelSize(R.dimen.chooser_corner_radius);\n\n            mOverlayPaint.setColor(0x99000000);\n            mOverlayPaint.setStyle(Paint.Style.FILL);\n\n            mRoundRectPaint.setColor(context.getResources().getColor(R.color.chooser_row_divider));\n            mRoundRectPaint.setStyle(Paint.Style.STROKE);\n            mRoundRectPaint.setStrokeWidth(context.getResources()\n                    .getDimensionPixelSize(R.dimen.chooser_preview_image_border));\n\n            mTextPaint.setColor(Color.WHITE);\n            mTextPaint.setTextSize(context.getResources()\n                    .getDimensionPixelSize(R.dimen.chooser_preview_image_font_size));\n            mTextPaint.setTextAlign(Paint.Align.CENTER);\n        }\n\n        private void updatePath(int width, int height) {\n            mPath.reset();\n\n            int imageWidth = width - getPaddingRight() - getPaddingLeft();\n            int imageHeight = height - getPaddingBottom() - getPaddingTop();\n            mPath.addRoundRect(getPaddingLeft(), getPaddingTop(), imageWidth, imageHeight, mRadius,\n                    mRadius, Path.Direction.CW);\n        }\n\n        /**\n          * Sets the corner radius on all corners\n          *\n          * param radius 0 for no radius, &gt; 0 for a visible corner radius\n          */\n        public void setRadius(int radius) {\n            mRadius = radius;\n            updatePath(getWidth(), getHeight());\n        }\n\n        /**\n          * Display an overlay with extra image count on 3rd image\n          */\n        public void setExtraImageCount(int count) {\n            if (count > 0) {\n                this.mExtraImageCount = \"+\" + count;\n            } else {\n                this.mExtraImageCount = null;\n            }\n        }\n\n        @Override\n        protected void onSizeChanged(int width, int height, int oldWidth, int oldHeight) {\n            super.onSizeChanged(width, height, oldWidth, oldHeight);\n            updatePath(width, height);\n        }\n\n        @Override\n        protected void onDraw(Canvas canvas) {\n            if (mRadius != 0) {\n                canvas.clipPath(mPath);\n            }\n\n            super.onDraw(canvas);\n\n            int x = getPaddingLeft();\n            int y = getPaddingRight();\n            int width = getWidth() - getPaddingRight() - getPaddingLeft();\n            int height = getHeight() - getPaddingBottom() - getPaddingTop();\n            if (mExtraImageCount != null) {\n                canvas.drawRect(x, y, width, height, mOverlayPaint);\n\n                int xPos = canvas.getWidth() / 2;\n                int yPos = (int) ((canvas.getHeight() / 2.0f)\n                        - ((mTextPaint.descent() + mTextPaint.ascent()) / 2.0f));\n\n                canvas.drawText(mExtraImageCount, xPos, yPos, mTextPaint);\n            }\n\n            canvas.drawRoundRect(x, y, width, height, mRadius, mRadius, mRoundRectPaint);\n        }\n    }\n\n    /**\n     * A helper class to track app's readiness for the scene transition animation.\n     * The app is ready when both the image is laid out and the drawer offset is calculated.\n     */\n    private class EnterTransitionAnimationDelegate implements View.OnLayoutChangeListener {\n        private boolean mPreviewReady = false;\n        private boolean mOffsetCalculated = false;\n\n        void postponeTransition() {\n            postponeEnterTransition();\n        }\n\n        void markImagePreviewReady() {\n            if (!mPreviewReady) {\n                mPreviewReady = true;\n                maybeStartListenForLayout();\n            }\n        }\n\n        void markOffsetCalculated() {\n            if (!mOffsetCalculated) {\n                mOffsetCalculated = true;\n                maybeStartListenForLayout();\n            }\n        }\n\n        private void maybeStartListenForLayout() {\n            if (mPreviewReady && mOffsetCalculated && mResolverDrawerLayout != null) {\n                if (mResolverDrawerLayout.isInLayout()) {\n                    startPostponedEnterTransition();\n                } else {\n                    mResolverDrawerLayout.addOnLayoutChangeListener(this);\n                    mResolverDrawerLayout.requestLayout();\n                }\n            }\n        }\n\n        @Override\n        public void onLayoutChange(View v, int left, int top, int right, int bottom, int oldLeft,\n                int oldTop, int oldRight, int oldBottom) {\n            v.removeOnLayoutChangeListener(this);\n            startPostponedEnterTransition();\n        }\n    }\n\n    @Override\n    protected void maybeLogProfileChange() {\n        getChooserActivityLogger().logShareheetProfileChanged();\n    }\n\n    private boolean shouldNearbyShareBeFirstInRankedRow() {\n        return ActivityManager.isLowRamDeviceStatic() && mIsNearbyShareFirstTargetInRankedApp;\n    }\n\n    private boolean shouldNearbyShareBeIncludedAsActionButton() {\n        return !shouldNearbyShareBeFirstInRankedRow();\n    }\n\n    private boolean hasValidIcon(ChooserTarget target) {\n        Icon icon = target.getIcon();\n        if (icon == null) {\n            return true;\n        }\n        if (icon.getType() == Icon.TYPE_URI || icon.getType() == Icon.TYPE_URI_ADAPTIVE_BITMAP) {\n            Uri uri = icon.getUri();\n            try {\n                getUriGrantsManager().checkGrantUriPermission_ignoreNonSystem(\n                        getLaunchedFromUid(),\n                        getPackageName(),\n                        getUriWithoutUserId(uri),\n                        Intent.FLAG_GRANT_READ_URI_PERMISSION,\n                        getUserIdFromUri(uri)\n                );\n            } catch (SecurityException | RemoteException e) {\n                Log.e(TAG, \"Failed to get URI permission for: \" + uri, e);\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private IUriGrantsManager getUriGrantsManager() {\n        return UriGrantsManager.getService();\n    }\n\n    private static ChooserTarget removeIcon(ChooserTarget target) {\n        if (target == null) {\n            return null;\n        }\n        return new ChooserTarget(\n                target.getTitle(),\n                null,\n                target.getScore(),\n                target.getComponentName(),\n                target.getIntentExtras());\n    }\n}",
    "metrics": {
      "relative_line_count_similarity": 0.9334,
      "token_level_edit_similarity": 0.1926,
      "normalized_edit_similarity": 0.8074,
      "token_level_edit_distance": 0.8074,
      "codebert_score": {
        "precision": 0.9389,
        "recall": 0.9322,
        "f1": 0.9355,
        "f3": 0.9329
      },
      "token_count_upstream": 13166,
      "token_count_downstream": 12263,
      "token_count_total": 25429,
      "cosine_similarity_openai": "skipped"
    }
  }
]