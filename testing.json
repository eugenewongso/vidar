[
    {
        "id": "ASB-A-363248394",
        "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-363248394",
        "severity": "High",
        "failures": [
            {
                "downstream_version": "12",
                "branch_used": "android12-release",
                "downstream_patch": "59cdc3e20ca4ac198b1c27e6a5372ececd155b16",
                "repo_path": "android_repos/Settings",
                "result": "failure",
                "downstream_patch_content": "commit 59cdc3e20ca4ac198b1c27e6a5372ececd155b16\nAuthor: Guojing Yuan <guojing@google.com>\nDate:   Tue Oct 1 21:59:31 2024 +0000\n\n    [CDM][NLS] Check if the NLS service has an intent-filter\n    \n    Bug: 363248394\n    Test: CTS\n    Flag: EXEMPT bugfix\n    Change-Id: Ib79c219cde8d73a218ceb7911f4552d43e384d8e\n    Merged-In: Ib79c219cde8d73a218ceb7911f4552d43e384d8e\n    (cherry picked from commit 7ae59a42eb13f643d842525208619037c074371a)\n\ndiff --git a/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java b/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\nindex a6b565ae6ba..f01e23a5e8f 100644\n--- a/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\n+++ b/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\n@@ -29,12 +29,14 @@ import android.app.NotificationManager;\n import android.content.ComponentName;\n import android.content.Context;\n import android.content.DialogInterface;\n+import android.content.Intent;\n import android.content.pm.ApplicationInfo;\n import android.content.pm.PackageItemInfo;\n import android.content.pm.PackageManager;\n-import android.content.pm.ServiceInfo;\n+import android.content.pm.ResolveInfo;\n import android.os.Bundle;\n import android.os.UserHandle;\n+import android.service.notification.NotificationListenerService;\n import android.text.TextUtils;\n import android.util.Slog;\n import android.view.WindowManager;\n@@ -44,6 +46,8 @@ import com.android.internal.app.AlertActivity;\n import com.android.internal.app.AlertController;\n import com.android.settings.R;\n \n+import java.util.List;\n+\n /** @hide */\n public class NotificationAccessConfirmationActivity extends Activity\n         implements DialogInterface {\n@@ -92,6 +96,31 @@ public class NotificationAccessConfirmationActivity extends Activity\n             return;\n         }\n \n+        // Check NLS service info.\n+        String requiredPermission = Manifest.permission.BIND_NOTIFICATION_LISTENER_SERVICE;\n+        Intent NLSIntent = new Intent(NotificationListenerService.SERVICE_INTERFACE);\n+        List<ResolveInfo> matchedServiceList = getPackageManager().queryIntentServicesAsUser(\n+                NLSIntent, /* flags */ 0, mUserId);\n+        boolean hasNLSIntentFilter = false;\n+        for (ResolveInfo service : matchedServiceList) {\n+            if (service.serviceInfo.packageName.equals(mComponentName.getPackageName())) {\n+                if (!requiredPermission.equals(service.serviceInfo.permission)) {\n+                    Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks permission \"\n+                            + requiredPermission);\n+                    finish();\n+                    return;\n+                }\n+                hasNLSIntentFilter = true;\n+                break;\n+            }\n+        }\n+        if (!hasNLSIntentFilter) {\n+            Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks an intent-filter action \"\n+                    + \"for android.service.notification.NotificationListenerService.\");\n+            finish();\n+            return;\n+        }\n+\n         AlertController.AlertParams p = new AlertController.AlertParams(this);\n         p.mTitle = getString(\n                 R.string.notification_listener_security_warning_title,\n@@ -126,19 +155,6 @@ public class NotificationAccessConfirmationActivity extends Activity\n     }\n \n     private void onAllow() {\n-        String requiredPermission = Manifest.permission.BIND_NOTIFICATION_LISTENER_SERVICE;\n-        try {\n-            ServiceInfo serviceInfo = getPackageManager().getServiceInfo(mComponentName, 0);\n-            if (!requiredPermission.equals(serviceInfo.permission)) {\n-                Slog.e(LOG_TAG,\n-                        \"Service \" + mComponentName + \" lacks permission \" + requiredPermission);\n-                return;\n-            }\n-        } catch (PackageManager.NameNotFoundException e) {\n-            Slog.e(LOG_TAG, \"Failed to get service info for \" + mComponentName, e);\n-            return;\n-        }\n-\n         mNm.setNotificationListenerAccessGranted(mComponentName, true);\n \n         finish();\n@@ -149,12 +165,6 @@ public class NotificationAccessConfirmationActivity extends Activity\n         return AlertActivity.dispatchPopulateAccessibilityEvent(this, event);\n     }\n \n-    @Override\n-    public void onBackPressed() {\n-        // Suppress finishing the activity on back button press,\n-        // consistently with the permission dialog behavior\n-    }\n-\n     @Override\n     public void cancel() {\n         finish();\n",
                "file_conflicts": [
                    {
                        "file_name": "src/com/android/settings/notification/NotificationAccessConfirmationActivity.java",
                        "total_hunks": 5,
                        "failed_hunks": [
                            1
                        ],
                        "inline_merge_conflicts": [
                            {
                                "hunk_number": 1,
                                "merge_conflict": "<<<<<<< DOWNSTREAM (version 12)\n\n=======\n    }\n\n    private void onAllow() {\n        mNm.setNotificationListenerAccessGranted(mComponentName, true);\n\n        finish();\n>>>>>>> UPSTREAM PATCH (commit 7ae59a42eb13f643d842525208619037c074371a)"
                            },
                            {
                                "hunk_number": 2,
                                "merge_conflict": "<<<<<<< DOWNSTREAM (version 12)\n    @Override\n    public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {\n        return AlertActivity.dispatchPopulateAccessibilityEvent(this, event);\n    }\n\n=======\n\n>>>>>>> UPSTREAM PATCH (commit 7ae59a42eb13f643d842525208619037c074371a)"
                            }
                        ],
                        "rej_file_content": "```diff\n--- src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\n+++ src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\n@@ -30,13 +30,15 @@ import android.app.admin.DevicePolicyManager;\n import android.content.ComponentName;\n import android.content.Context;\n import android.content.DialogInterface;\n+import android.content.Intent;\n import android.content.pm.ApplicationInfo;\n import android.content.pm.PackageItemInfo;\n import android.content.pm.PackageManager;\n-import android.content.pm.ServiceInfo;\n+import android.content.pm.ResolveInfo;\n import android.os.Bundle;\n import android.os.UserHandle;\n import android.os.UserManager;\n+import android.service.notification.NotificationListenerService;\n import android.text.TextUtils;\n import android.util.Slog;\n import android.view.WindowManager;\n```",
                        "patch_apply_output": "patching file src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\nHunk #1 FAILED at 30.\nHunk #2 succeeded at 44 (offset -5 lines).\nHunk #3 succeeded at 94 (offset -21 lines).\nHunk #4 succeeded at 153 (offset -21 lines).\nHunk #5 succeeded at 163 (offset -21 lines).\n1 out of 5 hunks FAILED -- saving rejects to file src/com/android/settings/notification/NotificationAccessConfirmationActivity.java.rej",
                        "inline_merge_output": "patching file src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\nHunk #1 already applied at 33,37,41.\nHunk #2 merged at 56-57.\nHunk #4 NOT MERGED at 203-211.\nHunk #5 NOT MERGED at 220-227.",
                        "upstream_file_content": "```java\n/*\n * Copyright (C) 2017 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\npackage com.android.settings.notification;\n\nimport static android.app.admin.DevicePolicyResources.Strings.Settings.WORK_APPS_CANNOT_ACCESS_NOTIFICATION_SETTINGS;\nimport static android.view.WindowManager.LayoutParams.SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS;\n\nimport static com.android.internal.notification.NotificationAccessConfirmationActivityContract.EXTRA_COMPONENT_NAME;\nimport static com.android.internal.notification.NotificationAccessConfirmationActivityContract.EXTRA_USER_ID;\n\nimport android.Manifest;\nimport android.app.Activity;\nimport android.app.NotificationManager;\nimport android.app.admin.DevicePolicyManager;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.PackageItemInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.ResolveInfo;\nimport android.os.Bundle;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.service.notification.NotificationListenerService;\nimport android.text.TextUtils;\nimport android.util.Slog;\nimport android.view.WindowManager;\nimport android.view.accessibility.AccessibilityEvent;\nimport android.widget.Toast;\n\nimport androidx.annotation.Nullable;\n\nimport com.android.internal.app.AlertActivity;\nimport com.android.internal.app.AlertController;\nimport com.android.settings.R;\n\nimport java.util.List;\n\n/** @hide */\npublic class NotificationAccessConfirmationActivity extends Activity\n        implements DialogInterface {\n\n    private static final boolean DEBUG = false;\n    private static final String LOG_TAG = \"NotificationAccessConfirmationActivity\";\n\n    private int mUserId;\n    private ComponentName mComponentName;\n    private NotificationManager mNm;\n\n    private DevicePolicyManager mDpm;\n    private UserManager mUm;\n\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        getWindow().addSystemFlags(SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);\n\n        mUm = getSystemService(UserManager.class);\n        mDpm = getSystemService(DevicePolicyManager.class);\n\n        if (mUm.isManagedProfile()) {\n            Slog.w(LOG_TAG, \"Apps in the work profile do not support notification listeners\");\n            Toast.makeText(this,\n                    mDpm.getResources().getString(WORK_APPS_CANNOT_ACCESS_NOTIFICATION_SETTINGS,\n                            () -> getString(R.string.notification_settings_work_profile)),\n                    Toast.LENGTH_SHORT).show();\n            finish();\n            return;\n        }\n\n        mNm = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);\n\n        mComponentName = getIntent().getParcelableExtra(EXTRA_COMPONENT_NAME);\n        mUserId = getIntent().getIntExtra(EXTRA_USER_ID, UserHandle.USER_NULL);\n        CharSequence mAppLabel;\n\n        if (mComponentName == null || mComponentName.getPackageName() == null\n                || mComponentName.flattenToString().length()\n                > NotificationManager.MAX_SERVICE_COMPONENT_NAME_LENGTH) {\n            finish();\n            return;\n        }\n\n        try {\n            ApplicationInfo applicationInfo = getPackageManager().getApplicationInfo(\n                    mComponentName.getPackageName(), 0);\n            mAppLabel = applicationInfo.loadSafeLabel(getPackageManager(),\n                    PackageItemInfo.DEFAULT_MAX_LABEL_SIZE_PX,\n                    PackageItemInfo.SAFE_LABEL_FLAG_TRIM\n                            | PackageItemInfo.SAFE_LABEL_FLAG_FIRST_LINE);\n        } catch (PackageManager.NameNotFoundException e) {\n            Slog.e(LOG_TAG, \"Couldn't find app with package name for \" + mComponentName, e);\n            finish();\n            return;\n        }\n\n        if (TextUtils.isEmpty(mAppLabel)) {\n            finish();\n            return;\n        }\n\n        // Check NLS service info.\n        String requiredPermission = Manifest.permission.BIND_NOTIFICATION_LISTENER_SERVICE;\n        Intent NLSIntent = new Intent(NotificationListenerService.SERVICE_INTERFACE);\n        List<ResolveInfo> matchedServiceList = getPackageManager().queryIntentServicesAsUser(\n                NLSIntent, /* flags */ 0, mUserId);\n        boolean hasNLSIntentFilter = false;\n        for (ResolveInfo service : matchedServiceList) {\n            if (service.serviceInfo.packageName.equals(mComponentName.getPackageName())) {\n                if (!requiredPermission.equals(service.serviceInfo.permission)) {\n                    Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks permission \"\n                            + requiredPermission);\n                    finish();\n                    return;\n                }\n                hasNLSIntentFilter = true;\n                break;\n            }\n        }\n        if (!hasNLSIntentFilter) {\n            Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks an intent-filter action \"\n                    + \"for android.service.notification.NotificationListenerService.\");\n            finish();\n            return;\n        }\n\n        AlertController.AlertParams p = new AlertController.AlertParams(this);\n        p.mTitle = getString(\n                R.string.notification_listener_security_warning_title,\n                mAppLabel);\n        p.mMessage = getString(\n                R.string.notification_listener_security_warning_summary,\n                mAppLabel);\n        p.mPositiveButtonText = getString(R.string.allow);\n        p.mPositiveButtonListener = (a, b) -> onAllow();\n        p.mNegativeButtonText = getString(R.string.deny);\n        p.mNegativeButtonListener = (a, b) -> cancel();\n        AlertController\n                .create(this, this, getWindow())\n                .installContent(p);\n        // Consistent with the permission dialog\n        // Used instead of p.mCancelable as that is only honored for AlertDialog\n        getWindow().setCloseOnTouchOutside(false); \n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n        getWindow().addFlags(\n                WindowManager.LayoutParams.SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);\n    }\n\n    @Override\n    public void onPause() {\n        getWindow().clearFlags(\n                WindowManager.LayoutParams.SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);\n        super.onPause();\n    }\n\n    private void onAllow() {\n        mNm.setNotificationListenerAccessGranted(mComponentName, true);\n\n        finish();\n    }\n\n    @Override\n    public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {\n        return AlertActivity.dispatchPopulateAccessibilityEvent(this, event);\n    }\n\n    @Override\n    public void cancel() {\n        finish();\n    }\n\n    @Override\n    public void dismiss() {\n        // This is called after the click, since we finish when handling the\n        // click, don't do that again here.\n        if (!isFinishing()) {\n            finish();\n        }\n    }\n}\n```",
                        "downstream_file_content": "```java\n/*\n * Copyright (C) 2017 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\npackage com.android.settings.notification;\n\nimport static android.view.WindowManager.LayoutParams.SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS;\n\nimport static com.android.internal.notification.NotificationAccessConfirmationActivityContract.EXTRA_COMPONENT_NAME;\nimport static com.android.internal.notification.NotificationAccessConfirmationActivityContract.EXTRA_USER_ID;\n\nimport android.Manifest;\nimport android.annotation.Nullable;\nimport android.app.Activity;\nimport android.app.NotificationManager;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.PackageItemInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.ServiceInfo;\nimport android.os.Bundle;\nimport android.os.UserHandle;\nimport android.text.TextUtils;\nimport android.util.Slog;\nimport android.view.WindowManager;\nimport android.view.accessibility.AccessibilityEvent;\n\nimport com.android.internal.app.AlertActivity;\nimport com.android.internal.app.AlertController;\nimport com.android.settings.R;\n\nimport java.util.List;\n\n/** @hide */\npublic class NotificationAccessConfirmationActivity extends Activity\n        implements DialogInterface {\n\n    private static final boolean DEBUG = false;\n    private static final String LOG_TAG = \"NotificationAccessConfirmationActivity\";\n\n    private int mUserId;\n    private ComponentName mComponentName;\n    private NotificationManager mNm;\n\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        getWindow().addSystemFlags(SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);\n\n        mNm = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);\n\n        mComponentName = getIntent().getParcelableExtra(EXTRA_COMPONENT_NAME);\n        mUserId = getIntent().getIntExtra(EXTRA_USER_ID, UserHandle.USER_NULL);\n        CharSequence mAppLabel;\n\n        if (mComponentName == null || mComponentName.getPackageName() == null\n                || mComponentName.flattenToString().length()\n                > NotificationManager.MAX_SERVICE_COMPONENT_NAME_LENGTH) {\n            finish();\n            return;\n        }\n\n        try {\n            ApplicationInfo applicationInfo = getPackageManager().getApplicationInfo(\n                    mComponentName.getPackageName(), 0);\n            mAppLabel = applicationInfo.loadSafeLabel(getPackageManager(),\n                    PackageItemInfo.DEFAULT_MAX_LABEL_SIZE_PX,\n                    PackageItemInfo.SAFE_LABEL_FLAG_TRIM\n                            | PackageItemInfo.SAFE_LABEL_FLAG_FIRST_LINE);\n        } catch (PackageManager.NameNotFoundException e) {\n            Slog.e(LOG_TAG, \"Couldn't find app with package name for \" + mComponentName, e);\n            finish();\n            return;\n        }\n\n        if (TextUtils.isEmpty(mAppLabel)) {\n            finish();\n            return;\n        }\n\n        // Check NLS service info.\n        String requiredPermission = Manifest.permission.BIND_NOTIFICATION_LISTENER_SERVICE;\n        Intent NLSIntent = new Intent(NotificationListenerService.SERVICE_INTERFACE);\n        List<ResolveInfo> matchedServiceList = getPackageManager().queryIntentServicesAsUser(\n                NLSIntent, /* flags */ 0, mUserId);\n        boolean hasNLSIntentFilter = false;\n        for (ResolveInfo service : matchedServiceList) {\n            if (service.serviceInfo.packageName.equals(mComponentName.getPackageName())) {\n                if (!requiredPermission.equals(service.serviceInfo.permission)) {\n                    Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks permission \"\n                            + requiredPermission);\n                    finish();\n                    return;\n                }\n                hasNLSIntentFilter = true;\n                break;\n            }\n        }\n        if (!hasNLSIntentFilter) {\n            Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks an intent-filter action \"\n                    + \"for android.service.notification.NotificationListenerService.\");\n            finish();\n            return;\n        }\n\n        AlertController.AlertParams p = new AlertController.AlertParams(this);\n        p.mTitle = getString(\n                R.string.notification_listener_security_warning_title,\n                mAppLabel);\n        p.mMessage = getString(\n                R.string.notification_listener_security_warning_summary,\n                mAppLabel);\n        p.mPositiveButtonText = getString(R.string.allow);\n        p.mPositiveButtonListener = (a, b) -> onAllow();\n        p.mNegativeButtonText = getString(R.string.deny);\n        p.mNegativeButtonListener = (a, b) -> cancel();\n        AlertController\n                .create(this, this, getWindow())\n                .installContent(p);\n        // Consistent with the permission dialog\n        // Used instead of p.mCancelable as that is only honored for AlertDialog\n        getWindow().setCloseOnTouchOutside(false); \n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n        getWindow().addFlags(\n                WindowManager.LayoutParams.SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);\n    }\n\n    @Override\n    public void onPause() {\n        getWindow().clearFlags(\n                WindowManager.LayoutParams.SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);\n        super.onPause();\n    }\n\n    private void onAllow() {\n        mNm.setNotificationListenerAccessGranted(mComponentName, true);\n\n        finish();\n    }\n\n    @Override\n    public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {\n        return AlertActivity.dispatchPopulateAccessibilityEvent(this, event);\n    }\n\n    @Override\n    public void cancel() {\n        finish();\n    }\n\n    @Override\n    public void dismiss() {\n        // This is called after the click, since we finish when handling the\n        // click, don't do that again here.\n        if (!isFinishing()) {\n            finish();\n        }\n    }\n}\n```"
                    }
                ]
            },
            {
                "downstream_version": "12L",
                "branch_used": "android12L-release",
                "downstream_patch": "59cdc3e20ca4ac198b1c27e6a5372ececd155b16",
                "repo_path": "android_repos/Settings",
                "result": "failure",
                "downstream_patch_content": "commit 59cdc3e20ca4ac198b1c27e6a5372ececd155b16\nAuthor: Guojing Yuan <guojing@google.com>\nDate:   Tue Oct 1 21:59:31 2024 +0000\n\n    [CDM][NLS] Check if the NLS service has an intent-filter\n    \n    Bug: 363248394\n    Test: CTS\n    Flag: EXEMPT bugfix\n    Change-Id: Ib79c219cde8d73a218ceb7911f4552d43e384d8e\n    Merged-In: Ib79c219cde8d73a218ceb7911f4552d43e384d8e\n    (cherry picked from commit 7ae59a42eb13f643d842525208619037c074371a)\n\ndiff --git a/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java b/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\nindex a6b565ae6ba..f01e23a5e8f 100644\n--- a/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\n+++ b/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\n@@ -29,12 +29,14 @@ import android.app.NotificationManager;\n import android.content.ComponentName;\n import android.content.Context;\n import android.content.DialogInterface;\n+import android.content.Intent;\n import android.content.pm.ApplicationInfo;\n import android.content.pm.PackageItemInfo;\n import android.content.pm.PackageManager;\n-import android.content.pm.ServiceInfo;\n+import android.content.pm.ResolveInfo;\n import android.os.Bundle;\n import android.os.UserHandle;\n+import android.service.notification.NotificationListenerService;\n import android.text.TextUtils;\n import android.util.Slog;\n import android.view.WindowManager;\n@@ -44,6 +46,8 @@ import com.android.internal.app.AlertActivity;\n import com.android.internal.app.AlertController;\n import com.android.settings.R;\n \n+import java.util.List;\n+\n /** @hide */\n public class NotificationAccessConfirmationActivity extends Activity\n         implements DialogInterface {\n@@ -92,6 +96,31 @@ public class NotificationAccessConfirmationActivity extends Activity\n             return;\n         }\n \n+        // Check NLS service info.\n+        String requiredPermission = Manifest.permission.BIND_NOTIFICATION_LISTENER_SERVICE;\n+        Intent NLSIntent = new Intent(NotificationListenerService.SERVICE_INTERFACE);\n+        List<ResolveInfo> matchedServiceList = getPackageManager().queryIntentServicesAsUser(\n+                NLSIntent, /* flags */ 0, mUserId);\n+        boolean hasNLSIntentFilter = false;\n+        for (ResolveInfo service : matchedServiceList) {\n+            if (service.serviceInfo.packageName.equals(mComponentName.getPackageName())) {\n+                if (!requiredPermission.equals(service.serviceInfo.permission)) {\n+                    Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks permission \"\n+                            + requiredPermission);\n+                    finish();\n+                    return;\n+                }\n+                hasNLSIntentFilter = true;\n+                break;\n+            }\n+        }\n+        if (!hasNLSIntentFilter) {\n+            Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks an intent-filter action \"\n+                    + \"for android.service.notification.NotificationListenerService.\");\n+            finish();\n+            return;\n+        }\n+\n         AlertController.AlertParams p = new AlertController.AlertParams(this);\n         p.mTitle = getString(\n                 R.string.notification_listener_security_warning_title,\n@@ -126,19 +155,6 @@ public class NotificationAccessConfirmationActivity extends Activity\n     }\n \n     private void onAllow() {\n-        String requiredPermission = Manifest.permission.BIND_NOTIFICATION_LISTENER_SERVICE;\n-        try {\n-            ServiceInfo serviceInfo = getPackageManager().getServiceInfo(mComponentName, 0);\n-            if (!requiredPermission.equals(serviceInfo.permission)) {\n-                Slog.e(LOG_TAG,\n-                        \"Service \" + mComponentName + \" lacks permission \" + requiredPermission);\n-                return;\n-            }\n-        } catch (PackageManager.NameNotFoundException e) {\n-            Slog.e(LOG_TAG, \"Failed to get service info for \" + mComponentName, e);\n-            return;\n-        }\n-\n         mNm.setNotificationListenerAccessGranted(mComponentName, true);\n \n         finish();\n@@ -149,12 +165,6 @@ public class NotificationAccessConfirmationActivity extends Activity\n         return AlertActivity.dispatchPopulateAccessibilityEvent(this, event);\n     }\n \n-    @Override\n-    public void onBackPressed() {\n-        // Suppress finishing the activity on back button press,\n-        // consistently with the permission dialog behavior\n-    }\n-\n     @Override\n     public void cancel() {\n         finish();\n",
                "file_conflicts": [
                    {
                        "file_name": "src/com/android/settings/notification/NotificationAccessConfirmationActivity.java",
                        "total_hunks": 5,
                        "failed_hunks": [
                            1
                        ],
                        "inline_merge_conflicts": [
                            {
                                "hunk_number": 1,
                                "merge_conflict": "<<<<<<< DOWNSTREAM (version 12L)\n\n=======\n    }\n\n    private void onAllow() {\n        mNm.setNotificationListenerAccessGranted(mComponentName, true);\n\n        finish();\n>>>>>>> UPSTREAM PATCH (commit 7ae59a42eb13f643d842525208619037c074371a)"
                            },
                            {
                                "hunk_number": 2,
                                "merge_conflict": "<<<<<<< DOWNSTREAM (version 12L)\n    @Override\n    public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {\n        return AlertActivity.dispatchPopulateAccessibilityEvent(this, event);\n    }\n\n=======\n\n>>>>>>> UPSTREAM PATCH (commit 7ae59a42eb13f643d842525208619037c074371a)"
                            }
                        ],
                        "rej_file_content": "```diff\n--- src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\n+++ src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\n@@ -30,13 +30,15 @@ import android.app.admin.DevicePolicyManager;\n import android.content.ComponentName;\n import android.content.Context;\n import android.content.DialogInterface;\n+import android.content.Intent;\n import android.content.pm.ApplicationInfo;\n import android.content.pm.PackageItemInfo;\n import android.content.pm.PackageManager;\n-import android.content.pm.ServiceInfo;\n+import android.content.pm.ResolveInfo;\n import android.os.Bundle;\n import android.os.UserHandle;\n import android.os.UserManager;\n+import android.service.notification.NotificationListenerService;\n import android.text.TextUtils;\n import android.util.Slog;\n import android.view.WindowManager;\n```",
                        "patch_apply_output": "patching file src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\nHunk #1 FAILED at 30.\nHunk #2 succeeded at 44 (offset -5 lines).\nHunk #3 succeeded at 94 (offset -21 lines).\nHunk #4 succeeded at 153 (offset -21 lines).\nHunk #5 succeeded at 163 (offset -21 lines).\n1 out of 5 hunks FAILED -- saving rejects to file src/com/android/settings/notification/NotificationAccessConfirmationActivity.java.rej",
                        "inline_merge_output": "patching file src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\nHunk #1 already applied at 33,37,41.\nHunk #2 merged at 56-57.\nHunk #4 NOT MERGED at 203-211.\nHunk #5 NOT MERGED at 220-227.",
                        "upstream_file_content": "```java\n/*\n * Copyright (C) 2017 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\npackage com.android.settings.notification;\n\nimport static android.app.admin.DevicePolicyResources.Strings.Settings.WORK_APPS_CANNOT_ACCESS_NOTIFICATION_SETTINGS;\nimport static android.view.WindowManager.LayoutParams.SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS;\n\nimport static com.android.internal.notification.NotificationAccessConfirmationActivityContract.EXTRA_COMPONENT_NAME;\nimport static com.android.internal.notification.NotificationAccessConfirmationActivityContract.EXTRA_USER_ID;\n\nimport android.Manifest;\nimport android.app.Activity;\nimport android.app.NotificationManager;\nimport android.app.admin.DevicePolicyManager;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.PackageItemInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.ResolveInfo;\nimport android.os.Bundle;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.service.notification.NotificationListenerService;\nimport android.text.TextUtils;\nimport android.util.Slog;\nimport android.view.WindowManager;\nimport android.view.accessibility.AccessibilityEvent;\nimport android.widget.Toast;\n\nimport androidx.annotation.Nullable;\n\nimport com.android.internal.app.AlertActivity;\nimport com.android.internal.app.AlertController;\nimport com.android.settings.R;\n\nimport java.util.List;\n\n/** @hide */\npublic class NotificationAccessConfirmationActivity extends Activity\n        implements DialogInterface {\n\n    private static final boolean DEBUG = false;\n    private static final String LOG_TAG = \"NotificationAccessConfirmationActivity\";\n\n    private int mUserId;\n    private ComponentName mComponentName;\n    private NotificationManager mNm;\n\n    private DevicePolicyManager mDpm;\n    private UserManager mUm;\n\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        getWindow().addSystemFlags(SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);\n\n        mUm = getSystemService(UserManager.class);\n        mDpm = getSystemService(DevicePolicyManager.class);\n\n        if (mUm.isManagedProfile()) {\n            Slog.w(LOG_TAG, \"Apps in the work profile do not support notification listeners\");\n            Toast.makeText(this,\n                    mDpm.getResources().getString(WORK_APPS_CANNOT_ACCESS_NOTIFICATION_SETTINGS,\n                            () -> getString(R.string.notification_settings_work_profile)),\n                    Toast.LENGTH_SHORT).show();\n            finish();\n            return;\n        }\n\n        mNm = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);\n\n        mComponentName = getIntent().getParcelableExtra(EXTRA_COMPONENT_NAME);\n        mUserId = getIntent().getIntExtra(EXTRA_USER_ID, UserHandle.USER_NULL);\n        CharSequence mAppLabel;\n\n        if (mComponentName == null || mComponentName.getPackageName() == null\n                || mComponentName.flattenToString().length()\n                > NotificationManager.MAX_SERVICE_COMPONENT_NAME_LENGTH) {\n            finish();\n            return;\n        }\n\n        try {\n            ApplicationInfo applicationInfo = getPackageManager().getApplicationInfo(\n                    mComponentName.getPackageName(), 0);\n            mAppLabel = applicationInfo.loadSafeLabel(getPackageManager(),\n                    PackageItemInfo.DEFAULT_MAX_LABEL_SIZE_PX,\n                    PackageItemInfo.SAFE_LABEL_FLAG_TRIM\n                            | PackageItemInfo.SAFE_LABEL_FLAG_FIRST_LINE);\n        } catch (PackageManager.NameNotFoundException e) {\n            Slog.e(LOG_TAG, \"Couldn't find app with package name for \" + mComponentName, e);\n            finish();\n            return;\n        }\n\n        if (TextUtils.isEmpty(mAppLabel)) {\n            finish();\n            return;\n        }\n\n        // Check NLS service info.\n        String requiredPermission = Manifest.permission.BIND_NOTIFICATION_LISTENER_SERVICE;\n        Intent NLSIntent = new Intent(NotificationListenerService.SERVICE_INTERFACE);\n        List<ResolveInfo> matchedServiceList = getPackageManager().queryIntentServicesAsUser(\n                NLSIntent, /* flags */ 0, mUserId);\n        boolean hasNLSIntentFilter = false;\n        for (ResolveInfo service : matchedServiceList) {\n            if (service.serviceInfo.packageName.equals(mComponentName.getPackageName())) {\n                if (!requiredPermission.equals(service.serviceInfo.permission)) {\n                    Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks permission \"\n                            + requiredPermission);\n                    finish();\n                    return;\n                }\n                hasNLSIntentFilter = true;\n                break;\n            }\n        }\n        if (!hasNLSIntentFilter) {\n            Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks an intent-filter action \"\n                    + \"for android.service.notification.NotificationListenerService.\");\n            finish();\n            return;\n        }\n\n        AlertController.AlertParams p = new AlertController.AlertParams(this);\n        p.mTitle = getString(\n                R.string.notification_listener_security_warning_title,\n                mAppLabel);\n        p.mMessage = getString(\n                R.string.notification_listener_security_warning_summary,\n                mAppLabel);\n        p.mPositiveButtonText = getString(R.string.allow);\n        p.mPositiveButtonListener = (a, b) -> onAllow();\n        p.mNegativeButtonText = getString(R.string.deny);\n        p.mNegativeButtonListener = (a, b) -> cancel();\n        AlertController\n                .create(this, this, getWindow())\n                .installContent(p);\n        // Consistent with the permission dialog\n        // Used instead of p.mCancelable as that is only honored for AlertDialog\n        getWindow().setCloseOnTouchOutside(false); \n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n        getWindow().addFlags(\n                WindowManager.LayoutParams.SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);\n    }\n\n    @Override\n    public void onPause() {\n        getWindow().clearFlags(\n                WindowManager.LayoutParams.SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);\n        super.onPause();\n    }\n\n    private void onAllow() {\n        mNm.setNotificationListenerAccessGranted(mComponentName, true);\n\n        finish();\n    }\n\n    @Override\n    public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {\n        return AlertActivity.dispatchPopulateAccessibilityEvent(this, event);\n    }\n\n    @Override\n    public void cancel() {\n        finish();\n    }\n\n    @Override\n    public void dismiss() {\n        // This is called after the click, since we finish when handling the\n        // click, don't do that again here.\n        if (!isFinishing()) {\n            finish();\n        }\n    }\n}\n```",
                        "downstream_file_content": "```java\n/*\n * Copyright (C) 2017 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\npackage com.android.settings.notification;\n\nimport static android.view.WindowManager.LayoutParams.SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS;\n\nimport static com.android.internal.notification.NotificationAccessConfirmationActivityContract.EXTRA_COMPONENT_NAME;\nimport static com.android.internal.notification.NotificationAccessConfirmationActivityContract.EXTRA_USER_ID;\n\nimport android.Manifest;\nimport android.annotation.Nullable;\nimport android.app.Activity;\nimport android.app.NotificationManager;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.PackageItemInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.ServiceInfo;\nimport android.os.Bundle;\nimport android.os.UserHandle;\nimport android.text.TextUtils;\nimport android.util.Slog;\nimport android.view.WindowManager;\nimport android.view.accessibility.AccessibilityEvent;\n\nimport com.android.internal.app.AlertActivity;\nimport com.android.internal.app.AlertController;\nimport com.android.settings.R;\n\nimport java.util.List;\n\n/** @hide */\npublic class NotificationAccessConfirmationActivity extends Activity\n        implements DialogInterface {\n\n    private static final boolean DEBUG = false;\n    private static final String LOG_TAG = \"NotificationAccessConfirmationActivity\";\n\n    private int mUserId;\n    private ComponentName mComponentName;\n    private NotificationManager mNm;\n\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        getWindow().addSystemFlags(SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);\n\n        mNm = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);\n\n        mComponentName = getIntent().getParcelableExtra(EXTRA_COMPONENT_NAME);\n        mUserId = getIntent().getIntExtra(EXTRA_USER_ID, UserHandle.USER_NULL);\n        CharSequence mAppLabel;\n\n        if (mComponentName == null || mComponentName.getPackageName() == null\n                || mComponentName.flattenToString().length()\n                > NotificationManager.MAX_SERVICE_COMPONENT_NAME_LENGTH) {\n            finish();\n            return;\n        }\n\n        try {\n            ApplicationInfo applicationInfo = getPackageManager().getApplicationInfo(\n                    mComponentName.getPackageName(), 0);\n            mAppLabel = applicationInfo.loadSafeLabel(getPackageManager(),\n                    PackageItemInfo.DEFAULT_MAX_LABEL_SIZE_PX,\n                    PackageItemInfo.SAFE_LABEL_FLAG_TRIM\n                            | PackageItemInfo.SAFE_LABEL_FLAG_FIRST_LINE);\n        } catch (PackageManager.NameNotFoundException e) {\n            Slog.e(LOG_TAG, \"Couldn't find app with package name for \" + mComponentName, e);\n            finish();\n            return;\n        }\n\n        if (TextUtils.isEmpty(mAppLabel)) {\n            finish();\n            return;\n        }\n\n        // Check NLS service info.\n        String requiredPermission = Manifest.permission.BIND_NOTIFICATION_LISTENER_SERVICE;\n        Intent NLSIntent = new Intent(NotificationListenerService.SERVICE_INTERFACE);\n        List<ResolveInfo> matchedServiceList = getPackageManager().queryIntentServicesAsUser(\n                NLSIntent, /* flags */ 0, mUserId);\n        boolean hasNLSIntentFilter = false;\n        for (ResolveInfo service : matchedServiceList) {\n            if (service.serviceInfo.packageName.equals(mComponentName.getPackageName())) {\n                if (!requiredPermission.equals(service.serviceInfo.permission)) {\n                    Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks permission \"\n                            + requiredPermission);\n                    finish();\n                    return;\n                }\n                hasNLSIntentFilter = true;\n                break;\n            }\n        }\n        if (!hasNLSIntentFilter) {\n            Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks an intent-filter action \"\n                    + \"for android.service.notification.NotificationListenerService.\");\n            finish();\n            return;\n        }\n\n        AlertController.AlertParams p = new AlertController.AlertParams(this);\n        p.mTitle = getString(\n                R.string.notification_listener_security_warning_title,\n                mAppLabel);\n        p.mMessage = getString(\n                R.string.notification_listener_security_warning_summary,\n                mAppLabel);\n        p.mPositiveButtonText = getString(R.string.allow);\n        p.mPositiveButtonListener = (a, b) -> onAllow();\n        p.mNegativeButtonText = getString(R.string.deny);\n        p.mNegativeButtonListener = (a, b) -> cancel();\n        AlertController\n                .create(this, this, getWindow())\n                .installContent(p);\n        // Consistent with the permission dialog\n        // Used instead of p.mCancelable as that is only honored for AlertDialog\n        getWindow().setCloseOnTouchOutside(false); \n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n        getWindow().addFlags(\n                WindowManager.LayoutParams.SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);\n    }\n\n    @Override\n    public void onPause() {\n        getWindow().clearFlags(\n                WindowManager.LayoutParams.SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);\n        super.onPause();\n    }\n\n    private void onAllow() {\n        mNm.setNotificationListenerAccessGranted(mComponentName, true);\n\n        finish();\n    }\n\n    @Override\n    public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {\n        return AlertActivity.dispatchPopulateAccessibilityEvent(this, event);\n    }\n\n    @Override\n    public void cancel() {\n        finish();\n    }\n\n    @Override\n    public void dismiss() {\n        // This is called after the click, since we finish when handling the\n        // click, don't do that again here.\n        if (!isFinishing()) {\n            finish();\n        }\n    }\n}\n```"
                    }
                ]
            }
        ],
        "upstream_patch_content": "From 7ae59a42eb13f643d842525208619037c074371a Mon Sep 17 00:00:00 2001\nFrom: Guojing Yuan <guojing@google.com>\nDate: Tue, 1 Oct 2024 21:59:31 +0000\nSubject: [PATCH] [CDM][NLS] Check if the NLS service has an intent-filter\n\nBug: 363248394\nTest: CTS\nFlag: EXEMPT bugfix\nChange-Id: Ib79c219cde8d73a218ceb7911f4552d43e384d8e\n---\n ...otificationAccessConfirmationActivity.java | 50 +++++++++++--------\n ...icationAccessConfirmationActivityTest.java |  9 ++--\n 2 files changed, 33 insertions(+), 26 deletions(-)\n\ndiff --git a/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java b/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\nindex 3f300c0fce3..1adeb644155 100644\n--- a/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\n+++ b/src/com/android/settings/notification/NotificationAccessConfirmationActivity.java\n@@ -30,13 +30,15 @@ import android.app.admin.DevicePolicyManager;\n import android.content.ComponentName;\n import android.content.Context;\n import android.content.DialogInterface;\n+import android.content.Intent;\n import android.content.pm.ApplicationInfo;\n import android.content.pm.PackageItemInfo;\n import android.content.pm.PackageManager;\n-import android.content.pm.ServiceInfo;\n+import android.content.pm.ResolveInfo;\n import android.os.Bundle;\n import android.os.UserHandle;\n import android.os.UserManager;\n+import android.service.notification.NotificationListenerService;\n import android.text.TextUtils;\n import android.util.Slog;\n import android.view.WindowManager;\n@@ -49,6 +51,8 @@ import com.android.internal.app.AlertActivity;\n import com.android.internal.app.AlertController;\n import com.android.settings.R;\n \n+import java.util.List;\n+\n /** @hide */\n public class NotificationAccessConfirmationActivity extends Activity\n         implements DialogInterface {\n@@ -113,6 +117,31 @@ public class NotificationAccessConfirmationActivity extends Activity\n             return;\n         }\n \n+        // Check NLS service info.\n+        String requiredPermission = Manifest.permission.BIND_NOTIFICATION_LISTENER_SERVICE;\n+        Intent NLSIntent = new Intent(NotificationListenerService.SERVICE_INTERFACE);\n+        List<ResolveInfo> matchedServiceList = getPackageManager().queryIntentServicesAsUser(\n+                NLSIntent, /* flags */ 0, mUserId);\n+        boolean hasNLSIntentFilter = false;\n+        for (ResolveInfo service : matchedServiceList) {\n+            if (service.serviceInfo.packageName.equals(mComponentName.getPackageName())) {\n+                if (!requiredPermission.equals(service.serviceInfo.permission)) {\n+                    Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks permission \"\n+                            + requiredPermission);\n+                    finish();\n+                    return;\n+                }\n+                hasNLSIntentFilter = true;\n+                break;\n+            }\n+        }\n+        if (!hasNLSIntentFilter) {\n+            Slog.e(LOG_TAG, \"Service \" + mComponentName + \" lacks an intent-filter action \"\n+                    + \"for android.service.notification.NotificationListenerService.\");\n+            finish();\n+            return;\n+        }\n+\n         AlertController.AlertParams p = new AlertController.AlertParams(this);\n         p.mTitle = getString(\n                 R.string.notification_listener_security_warning_title,\n@@ -147,19 +176,6 @@ public class NotificationAccessConfirmationActivity extends Activity\n     }\n \n     private void onAllow() {\n-        String requiredPermission = Manifest.permission.BIND_NOTIFICATION_LISTENER_SERVICE;\n-        try {\n-            ServiceInfo serviceInfo = getPackageManager().getServiceInfo(mComponentName, 0);\n-            if (!requiredPermission.equals(serviceInfo.permission)) {\n-                Slog.e(LOG_TAG,\n-                        \"Service \" + mComponentName + \" lacks permission \" + requiredPermission);\n-                return;\n-            }\n-        } catch (PackageManager.NameNotFoundException e) {\n-            Slog.e(LOG_TAG, \"Failed to get service info for \" + mComponentName, e);\n-            return;\n-        }\n-\n         mNm.setNotificationListenerAccessGranted(mComponentName, true);\n \n         finish();\n@@ -170,12 +186,6 @@ public class NotificationAccessConfirmationActivity extends Activity\n         return AlertActivity.dispatchPopulateAccessibilityEvent(this, event);\n     }\n \n-    @Override\n-    public void onBackPressed() {\n-        // Suppress finishing the activity on back button press,\n-        // consistently with the permission dialog behavior\n-    }\n-\n     @Override\n     public void cancel() {\n         finish();\ndiff --git a/tests/robotests/src/com/android/settings/notification/NotificationAccessConfirmationActivityTest.java b/tests/robotests/src/com/android/settings/notification/NotificationAccessConfirmationActivityTest.java\nindex 9b510fb43e3..0a953615abf 100644\n--- a/tests/robotests/src/com/android/settings/notification/NotificationAccessConfirmationActivityTest.java\n+++ b/tests/robotests/src/com/android/settings/notification/NotificationAccessConfirmationActivityTest.java\n@@ -31,8 +31,6 @@ import android.widget.TextView;\n \n import androidx.annotation.Nullable;\n \n-import com.android.settings.R;\n-\n import com.google.common.base.Strings;\n \n import org.junit.Test;\n@@ -45,15 +43,14 @@ import org.robolectric.RuntimeEnvironment;\n public class NotificationAccessConfirmationActivityTest {\n \n     @Test\n-    public void start_showsDialog() {\n+    public void start_withMissingIntentFilter_finishes() {\n         ComponentName cn = new ComponentName(\"com.example\", \"com.example.SomeService\");\n         installPackage(cn.getPackageName(), \"X\");\n \n         NotificationAccessConfirmationActivity activity = startActivityWithIntent(cn);\n \n-        assertThat(activity.isFinishing()).isFalse();\n-        assertThat(getDialogText(activity)).isEqualTo(\n-                activity.getString(R.string.notification_listener_security_warning_summary, \"X\"));\n+        assertThat(getDialogText(activity)).isNull();\n+        assertThat(activity.isFinishing()).isTrue();\n     }\n \n     @Test\n-- \n2.39.5 (Apple Git-154)\n\n",
        "upstream_commits": [
            "7ae59a42eb13f643d842525208619037c074371a"
        ]
    },
    {
        "id": "ASB-A-277207798",
        "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-277207798",
        "severity": "High",
        "failures": [
            {
                "downstream_version": "13",
                "branch_used": "android13-release",
                "downstream_patch": "e73bb60fed12daa78ddad8308b31b0c78f1c3c66",
                "repo_path": "android_repos/base",
                "result": "failure",
                "downstream_patch_content": "commit e73bb60fed12daa78ddad8308b31b0c78f1c3c66\nAuthor: Andrey Yepin <ayepin@google.com>\nDate:   Mon Dec 9 17:12:10 2024 -0800\n\n    Verify that the caller has permissions for the icons it provided.\n    \n    Bug: 277207798\n    Test: manual testing: first reroduce the issue as described in the\n     ticket then check that it is not reproduceable after the fix.\n    Merged-In: I08992550507572a4878c501184360a58adef53ad\n    Change-Id: Ic8cb75ed586e94c5895065f772bfb21013396dd0\n\ndiff --git a/core/java/com/android/internal/app/ChooserActivity.java b/core/java/com/android/internal/app/ChooserActivity.java\nindex 919c176b5841..4e4305aa73b1 100644\n--- a/core/java/com/android/internal/app/ChooserActivity.java\n+++ b/core/java/com/android/internal/app/ChooserActivity.java\n@@ -16,6 +16,7 @@\n \n package com.android.internal.app;\n \n+import static android.content.ContentProvider.getUriWithoutUserId;\n import static android.content.ContentProvider.getUserIdFromUri;\n \n import static com.android.internal.util.LatencyTracker.ACTION_LOAD_SHARE_SHEET;\n@@ -32,7 +33,9 @@ import android.annotation.NonNull;\n import android.annotation.Nullable;\n import android.app.Activity;\n import android.app.ActivityManager;\n+import android.app.IUriGrantsManager;\n import android.app.SharedElementCallback;\n+import android.app.UriGrantsManager;\n import android.app.prediction.AppPredictionContext;\n import android.app.prediction.AppPredictionManager;\n import android.app.prediction.AppPredictor;\n@@ -68,6 +71,7 @@ import android.graphics.Paint;\n import android.graphics.Path;\n import android.graphics.drawable.AnimatedVectorDrawable;\n import android.graphics.drawable.Drawable;\n+import android.graphics.drawable.Icon;\n import android.metrics.LogMaker;\n import android.net.Uri;\n import android.os.AsyncTask;\n@@ -77,6 +81,7 @@ import android.os.Handler;\n import android.os.Message;\n import android.os.Parcelable;\n import android.os.PatternMatcher;\n+import android.os.RemoteException;\n import android.os.ResultReceiver;\n import android.os.UserHandle;\n import android.os.UserManager;\n@@ -663,7 +668,11 @@ public class ChooserActivity extends ResolverActivity implements\n                     targets = null;\n                     break;\n                 }\n-                targets[i] = (ChooserTarget) pa[i];\n+                ChooserTarget chooserTarget = (ChooserTarget) pa[i];\n+                if (!hasValidIcon(chooserTarget)) {\n+                    chooserTarget = removeIcon(chooserTarget);\n+                }\n+                targets[i] = chooserTarget;\n             }\n             mCallerChooserTargets = targets;\n         }\n@@ -4038,4 +4047,43 @@ public class ChooserActivity extends ResolverActivity implements\n     private boolean shouldNearbyShareBeIncludedAsActionButton() {\n         return !shouldNearbyShareBeFirstInRankedRow();\n     }\n+\n+    private boolean hasValidIcon(ChooserTarget target) {\n+        Icon icon = target.getIcon();\n+        if (icon == null) {\n+            return true;\n+        }\n+        if (icon.getType() == Icon.TYPE_URI || icon.getType() == Icon.TYPE_URI_ADAPTIVE_BITMAP) {\n+            Uri uri = icon.getUri();\n+            try {\n+                getUriGrantsManager().checkGrantUriPermission_ignoreNonSystem(\n+                        getLaunchedFromUid(),\n+                        getPackageName(),\n+                        getUriWithoutUserId(uri),\n+                        Intent.FLAG_GRANT_READ_URI_PERMISSION,\n+                        getUserIdFromUri(uri)\n+                );\n+            } catch (SecurityException | RemoteException e) {\n+                Log.e(TAG, \"Failed to get URI permission for: \" + uri, e);\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private IUriGrantsManager getUriGrantsManager() {\n+        return UriGrantsManager.getService();\n+    }\n+\n+    private static ChooserTarget removeIcon(ChooserTarget target) {\n+        if (target == null) {\n+            return null;\n+        }\n+        return new ChooserTarget(\n+                target.getTitle(),\n+                null,\n+                target.getScore(),\n+                target.getComponentName(),\n+                target.getIntentExtras());\n+    }\n }\n",
                "file_conflicts": [
                    {
                        "file_name": "core/java/com/android/internal/app/ChooserActivity.java",
                        "total_hunks": 6,
                        "failed_hunks": [
                            1,
                            2
                        ],
                        "inline_merge_conflicts": [],
                        "rej_file_content": "```diff\n--- core/java/com/android/internal/app/ChooserActivity.java\n+++ core/java/com/android/internal/app/ChooserActivity.java\n@@ -21,6 +21,7 @@ import static android.app.admin.DevicePolicyResources.Strings.Core.RESOLVER_CANT\n import static android.app.admin.DevicePolicyResources.Strings.Core.RESOLVER_CANT_SHARE_WITH_PERSONAL;\n import static android.app.admin.DevicePolicyResources.Strings.Core.RESOLVER_CANT_SHARE_WITH_WORK;\n import static android.app.admin.DevicePolicyResources.Strings.Core.RESOLVER_CROSS_PROFILE_BLOCKED_TITLE;\n+import static android.content.ContentProvider.getUriWithoutUserId;\n import static android.content.ContentProvider.getUserIdFromUri;\n import static android.stats.devicepolicy.DevicePolicyEnums.RESOLVER_EMPTY_STATE_NO_SHARING_TO_PERSONAL;\n import static android.stats.devicepolicy.DevicePolicyEnums.RESOLVER_EMPTY_STATE_NO_SHARING_TO_WORK;\n@@ -40,7 +41,9 @@ import android.annotation.Nullable;\n import android.app.Activity;\n import android.app.ActivityManager;\n import android.app.ActivityOptions;\n+import android.app.IUriGrantsManager;\n import android.app.SharedElementCallback;\n+import android.app.UriGrantsManager;\n import android.app.prediction.AppPredictionContext;\n import android.app.prediction.AppPredictionManager;\n import android.app.prediction.AppPredictor;\n```",
                        "patch_apply_output": "patching file core/java/com/android/internal/app/ChooserActivity.java\nHunk #1 FAILED at 21.\nHunk #2 FAILED at 40.\nHunk #3 succeeded at 68 (offset -9 lines).\nHunk #4 succeeded at 78 (offset -9 lines).\nHunk #5 succeeded at 665 (offset -29 lines).\nHunk #6 succeeded at 4044 (offset -275 lines).\n2 out of 6 hunks FAILED -- saving rejects to file core/java/com/android/internal/app/ChooserActivity.java.rej",
                        "inline_merge_output": "patching file core/java/com/android/internal/app/ChooserActivity.java\nHunk #1 already applied at 24.\nHunk #2 already applied at 44,46.\nHunk #3 already applied at 83.\nHunk #4 already applied at 93.\nHunk #5 already applied at 700-704.\nHunk #6 merged at 4364-4402.",
                        "upstream_file_content": "```java\n/*\n * Copyright (C) 2008 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.internal.app;\n\nimport static android.app.admin.DevicePolicyResources.Strings.Core.RESOLVER_CANT_ACCESS_PERSONAL;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.RESOLVER_CANT_ACCESS_WORK;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.RESOLVER_CANT_SHARE_WITH_PERSONAL;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.RESOLVER_CANT_SHARE_WITH_WORK;\nimport static android.app.admin.DevicePolicyResources.Strings.Core.RESOLVER_CROSS_PROFILE_BLOCKED_TITLE;\nimport static android.content.ContentProvider.getUriWithoutUserId;\nimport static android.content.ContentProvider.getUserIdFromUri;\nimport static android.stats.devicepolicy.DevicePolicyEnums.RESOLVER_EMPTY_STATE_NO_SHARING_TO_PERSONAL;\nimport static android.stats.devicepolicy.DevicePolicyEnums.RESOLVER_EMPTY_STATE_NO_SHARING_TO_WORK;\n\nimport static com.android.internal.util.LatencyTracker.ACTION_LOAD_SHARE_SHEET;\n\nimport static java.lang.annotation.RetentionPolicy.SOURCE;\n\nimport android.animation.Animator;\nimport android.animation.AnimatorListenerAdapter;\nimport android.animation.AnimatorSet;\nimport android.animation.ObjectAnimator;\nimport android.animation.ValueAnimator;\nimport android.annotation.IntDef;\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.app.Activity;\nimport android.app.ActivityManager;\nimport android.app.ActivityOptions;\nimport android.app.IUriGrantsManager;\nimport android.app.SharedElementCallback;\nimport android.app.UriGrantsManager;\nimport android.app.prediction.AppPredictionContext;\nimport android.app.prediction.AppPredictionManager;\nimport android.app.prediction.AppPredictor;\nimport android.app.prediction.AppTarget;\nimport android.app.prediction.AppTargetEvent;\nimport android.app.prediction.AppTargetId;\nimport android.compat.annotation.UnsupportedAppUsage;\nimport android.content.ClipData;\nimport android.content.ClipboardManager;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.IntentSender;\nimport android.content.IntentSender.SendIntentException;\nimport android.content.SharedPreferences;\nimport android.content.pm.ActivityInfo;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManager.NameNotFoundException;\nimport android.content.pm.ResolveInfo;\nimport android.content.pm.ShortcutInfo;\nimport android.content.pm.ShortcutManager;\nimport android.content.res.Configuration;\nimport android.content.res.Resources;\nimport android.database.Cursor;\nimport android.database.DataSetObserver;\nimport android.graphics.Bitmap;\nimport android.graphics.Canvas;\nimport android.graphics.Color;\nimport android.graphics.Insets;\nimport android.graphics.Paint;\nimport android.graphics.Path;\nimport android.graphics.drawable.AnimatedVectorDrawable;\nimport android.graphics.drawable.Drawable;\nimport android.graphics.drawable.Icon;\nimport android.metrics.LogMaker;\nimport android.net.Uri;\nimport android.os.AsyncTask;\nimport android.os.Bundle;\nimport android.os.Environment;\nimport android.os.Handler;\nimport android.os.Message;\nimport android.os.Parcelable;\nimport android.os.PatternMatcher;\nimport android.os.RemoteException;\nimport android.os.ResultReceiver;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.os.storage.StorageManager;\nimport android.provider.DeviceConfig;\nimport android.provider.DocumentsContract;\nimport android.provider.Downloads;\nimport android.provider.OpenableColumns;\nimport android.provider.Settings;\nimport android.service.chooser.ChooserTarget;\nimport android.text.TextUtils;\nimport android.util.AttributeSet;\nimport android.util.HashedStringCache;\nimport android.util.Log;\nimport android.util.PluralsMessageFormatter;\nimport android.util.Size;\nimport android.util.Slog;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.View.MeasureSpec;\nimport android.view.View.OnClickListener;\nimport android.view.ViewGroup;\nimport android.view.ViewGroup.LayoutParams;\nimport android.view.ViewTreeObserver;\nimport android.view.WindowInsets;\nimport android.view.animation.AccelerateInterpolator;\nimport android.view.animation.AlphaAnimation;\nimport android.view.animation.Animation;\nimport android.view.animation.DecelerateInterpolator;\nimport android.view.animation.LinearInterpolator;\nimport android.widget.Button;\nimport android.widget.ImageView;\nimport android.widget.Space;\nimport android.widget.TextView;\n\nimport com.android.internal.R;\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.app.AbstractMultiProfilePagerAdapter.EmptyState;\nimport com.android.internal.app.AbstractMultiProfilePagerAdapter.EmptyStateProvider;\nimport com.android.internal.app.NoCrossProfileEmptyStateProvider.DevicePolicyBlockerEmptyState;\nimport com.android.internal.app.ResolverListAdapter.ActivityInfoPresentationGetter;\nimport com.android.internal.app.ResolverListAdapter.ViewHolder;\nimport com.android.internal.app.chooser.ChooserTargetInfo;\nimport com.android.internal.app.chooser.DisplayResolveInfo;\nimport com.android.internal.app.chooser.MultiDisplayResolveInfo;\nimport com.android.internal.app.chooser.NotSelectableTargetInfo;\nimport com.android.internal.app.chooser.SelectableTargetInfo;\nimport com.android.internal.app.chooser.SelectableTargetInfo.SelectableTargetInfoCommunicator;\nimport com.android.internal.app.chooser.TargetInfo;\nimport com.android.internal.config.sysui.SystemUiDeviceConfigFlags;\nimport com.android.internal.content.PackageMonitor;\nimport com.android.internal.logging.MetricsLogger;\nimport com.android.internal.logging.nano.MetricsProto.MetricsEvent;\nimport com.android.internal.util.FrameworkStatsLog;\nimport com.android.internal.widget.GridLayoutManager;\nimport com.android.internal.widget.RecyclerView;\nimport com.android.internal.widget.ResolverDrawerLayout;\nimport com.android.internal.widget.ViewPager;\n\nimport com.google.android.collect.Lists;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.net.URISyntaxException;\nimport java.text.Collator;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.function.Supplier;\nimport java.util.stream.Collectors;\n\n/**\n * This is the legacy ChooserActivity and is not expected to be invoked, it's only here because\n * MediaAppSelectorActivity is still depending on it. The actual chooser used by the system is\n * at packages/modules/IntentResolver/java/src/com/android/intentresolver/ChooserActivity.java\n *\n * The migration to the new package will be completed in a later release.\n */\npublic class ChooserActivity extends ResolverActivity implements\n        ChooserListAdapter.ChooserListCommunicator,\n        SelectableTargetInfoCommunicator {\n    private static final String TAG = \"ChooserActivity\";\n\n    private AppPredictor mPersonalAppPredictor;\n    private AppPredictor mWorkAppPredictor;\n    private boolean mShouldDisplayLandscape;\n\n    @UnsupportedAppUsage\n    public ChooserActivity() {\n    }\n    /**\n     * Boolean extra to change the following behavior: Normally, ChooserActivity finishes itself\n     * in onStop when launched in a new task. If this extra is set to true, we do not finish\n     * ourselves when onStop gets called.\n     */\n    public static final String EXTRA_PRIVATE_RETAIN_IN_ON_STOP\n            = \"com.android.internal.app.ChooserActivity.EXTRA_PRIVATE_RETAIN_IN_ON_STOP\";\n\n\n    /**\n     * Transition name for the first image preview.\n     * To be used for shared element transition into this activity.\n     * @hide\n     */\n    public static final String FIRST_IMAGE_PREVIEW_TRANSITION_NAME = \"screenshot_preview_image\";\n\n    private static final String PREF_NUM_SHEET_EXPANSIONS = \"pref_num_sheet_expansions\";\n\n    private static final String CHIP_LABEL_METADATA_KEY = \"android.service.chooser.chip_label\";\n    private static final String CHIP_ICON_METADATA_KEY = \"android.service.chooser.chip_icon\";\n\n    private static final boolean DEBUG = true;\n\n    private static final boolean USE_PREDICTION_MANAGER_FOR_SHARE_ACTIVITIES = true;\n    // TODO(b/123088566) Share these in a better way.\n    private static final String APP_PREDICTION_SHARE_UI_SURFACE = \"share\";\n    public static final String LAUNCH_LOCATION_DIRECT_SHARE = \"direct_share\";\n    public static final String CHOOSER_TARGET = \"chooser_target\";\n    private static final String SHORTCUT_TARGET = \"shortcut_target\";\n    private static final int APP_PREDICTION_SHARE_TARGET_QUERY_PACKAGE_LIMIT = 20;\n    public static final String APP_PREDICTION_INTENT_FILTER_KEY = \"intent_filter\";\n    private static final String SHARED_TEXT_KEY = \"shared_text\";\n\n    private static final String PLURALS_COUNT = \"count\";\n    private static final String PLURALS_FILE_NAME = \"file_name\";\n\n    private static final String IMAGE_EDITOR_SHARED_ELEMENT = \"screenshot_preview_image\";\n\n    private boolean mIsAppPredictorComponentAvailable;\n    private Map<ChooserTarget, AppTarget> mDirectShareAppTargetCache;\n    private Map<ChooserTarget, ShortcutInfo> mDirectShareShortcutInfoCache;\n\n    public static final int TARGET_TYPE_DEFAULT = 0;\n    public static final int TARGET_TYPE_CHOOSER_TARGET = 1;\n    public static final int TARGET_TYPE_SHORTCUTS_FROM_SHORTCUT_MANAGER = 2;\n    public static final int TARGET_TYPE_SHORTCUTS_FROM_PREDICTION_SERVICE = 3;\n\n    public static final int SELECTION_TYPE_SERVICE = 1;\n    public static final int SELECTION_TYPE_APP = 2;\n    public static final int SELECTION_TYPE_STANDARD = 3;\n    public static final int SELECTION_TYPE_COPY = 4;\n    public static final int SELECTION_TYPE_NEARBY = 5;\n    public static final int SELECTION_TYPE_EDIT = 6;\n\n    private static final int SCROLL_STATUS_IDLE = 0;\n    private static final int SCROLL_STATUS_SCROLLING_VERTICAL = 1;\n    private static final int SCROLL_STATUS_SCROLLING_HORIZONTAL = 2;\n\n    // statsd logger wrapper\n    protected ChooserActivityLogger mChooserActivityLogger;\n\n    @IntDef(flag = false, prefix = { \"TARGET_TYPE_\" }, value = {\n            TARGET_TYPE_DEFAULT,\n            TARGET_TYPE_CHOOSER_TARGET,\n            TARGET_TYPE_SHORTCUTS_FROM_SHORTCUT_MANAGER,\n            TARGET_TYPE_SHORTCUTS_FROM_PREDICTION_SERVICE\n    })\n    @Retention(RetentionPolicy.SOURCE)\n    public @interface ShareTargetType {}\n\n    /**\n     * The transition time between placeholders for direct share to a message\n     * indicating that non are available.\n     */\n    private static final int NO_DIRECT_SHARE_ANIM_IN_MILLIS = 200;\n\n    private static final float DIRECT_SHARE_EXPANSION_RATE = 0.78f;\n\n    private static final int DEFAULT_SALT_EXPIRATION_DAYS = 7;\n    private int mMaxHashSaltDays = DeviceConfig.getInt(DeviceConfig.NAMESPACE_SYSTEMUI,\n            SystemUiDeviceConfigFlags.HASH_SALT_MAX_DAYS,\n            DEFAULT_SALT_EXPIRATION_DAYS);\n\n    private static final boolean DEFAULT_IS_NEARBY_SHARE_FIRST_TARGET_IN_RANKED_APP = false;\n    private boolean mIsNearbyShareFirstTargetInRankedApp =\n            DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_SYSTEMUI,\n                    SystemUiDeviceConfigFlags.IS_NEARBY_SHARE_FIRST_TARGET_IN_RANKED_APP,\n                    DEFAULT_IS_NEARBY_SHARE_FIRST_TARGET_IN_RANKED_APP);\n\n    private static final int DEFAULT_LIST_VIEW_UPDATE_DELAY_MS = 0;\n\n    private static final int URI_PERMISSION_INTENT_FLAGS = Intent.FLAG_GRANT_READ_URI_PERMISSION\n            | Intent.FLAG_GRANT_WRITE_URI_PERMISSION\n            | Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION\n            | Intent.FLAG_GRANT_PREFIX_URI_PERMISSION;\n\n    @VisibleForTesting\n    int mListViewUpdateDelayMs = DeviceConfig.getInt(DeviceConfig.NAMESPACE_SYSTEMUI,\n            SystemUiDeviceConfigFlags.SHARESHEET_LIST_VIEW_UPDATE_DELAY,\n            DEFAULT_LIST_VIEW_UPDATE_DELAY_MS);\n\n    private Bundle mReplacementExtras;\n    private IntentSender mChosenComponentSender;\n    private IntentSender mRefinementIntentSender;\n    private RefinementResultReceiver mRefinementResultReceiver;\n    private ChooserTarget[] mCallerChooserTargets;\n    private ComponentName[] mFilteredComponentNames;\n\n    private Intent mReferrerFillInIntent;\n\n    private long mChooserShownTime;\n    protected boolean mIsSuccessfullySelected;\n\n    private long mQueriedSharingShortcutsTimeMs;\n\n    private int mCurrAvailableWidth = 0;\n    private Insets mLastAppliedInsets = null;\n    private int mLastNumberOfChildren = -1;\n    private int mMaxTargetsPerRow = 1;\n\n    private static final String TARGET_DETAILS_FRAGMENT_TAG = \"targetDetailsFragment\";\n\n    private static final int MAX_LOG_RANK_POSITION = 12;\n\n    private static final int MAX_EXTRA_INITIAL_INTENTS = 2;\n    private static final int MAX_EXTRA_CHOOSER_TARGETS = 2;\n\n    private SharedPreferences mPinnedSharedPrefs;\n    private static final String PINNED_SHARED_PREFS_NAME = \"chooser_pin_settings\";\n\n    @Retention(SOURCE)\n    @IntDef({CONTENT_PREVIEW_FILE, CONTENT_PREVIEW_IMAGE, CONTENT_PREVIEW_TEXT})\n    private @interface ContentPreviewType {\n    }\n\n    // Starting at 1 since 0 is considered \"undefined\" for some of the database transformations\n    // of tron logs.\n    protected static final int CONTENT_PREVIEW_IMAGE = 1;\n    protected static final int CONTENT_PREVIEW_FILE = 2;\n    protected static final int CONTENT_PREVIEW_TEXT = 3;\n    protected MetricsLogger mMetricsLogger;\n\n    private ContentPreviewCoordinator mPreviewCoord;\n    private int mScrollStatus = SCROLL_STATUS_IDLE;\n\n    @VisibleForTesting\n    protected ChooserMultiProfilePagerAdapter mChooserMultiProfilePagerAdapter;\n    private final EnterTransitionAnimationDelegate mEnterTransitionAnimationDelegate =\n            new EnterTransitionAnimationDelegate();\n\n    private boolean mRemoveSharedElements = false;\n\n    private View mContentView = null;\n\n    private class ContentPreviewCoordinator {\n        private static final int IMAGE_FADE_IN_MILLIS = 150;\n        private static final int IMAGE_LOAD_TIMEOUT = 1;\n        private static final int IMAGE_LOAD_INTO_VIEW = 2;\n\n        private final int mImageLoadTimeoutMillis =\n                getResources().getInteger(R.integer.config_shortAnimTime);\n\n        private final View mParentView;\n        private boolean mHideParentOnFail;\n        private boolean mAtLeastOneLoaded = false;\n\n        class LoadUriTask {\n            public final Uri mUri;\n            public final int mImageResourceId;\n            public final int mExtraCount;\n            public final Bitmap mBmp;\n\n            LoadUriTask(int imageResourceId, Uri uri, int extraCount, Bitmap bmp) {\n                this.mImageResourceId = imageResourceId;\n                this.mUri = uri;\n                this.mExtraCount = extraCount;\n                this.mBmp = bmp;\n            }\n        }\n\n        // If at least one image loads within the timeout period, allow other\n        // loads to continue. Otherwise terminate and optionally hide\n        // the parent area\n        private final Handler mHandler = new Handler() {\n            @Override\n            public void handleMessage(Message msg) {\n                switch (msg.what) {\n                    case IMAGE_LOAD_TIMEOUT:\n                        maybeHideContentPreview();\n                        break;\n\n                    case IMAGE_LOAD_INTO_VIEW:\n                        if (isFinishing()) break;\n\n                        LoadUriTask task = (LoadUriTask) msg.obj;\n                        RoundedRectImageView imageView = mParentView.findViewById(\n                                task.mImageResourceId);\n                        if (task.mBmp == null) {\n                            imageView.setVisibility(View.GONE);\n                            maybeHideContentPreview();\n                            return;\n                        }\n\n                        mAtLeastOneLoaded = true;\n                        imageView.setVisibility(View.VISIBLE);\n                        imageView.setAlpha(0.0f);\n                        imageView.setImageBitmap(task.mBmp);\n\n                        ValueAnimator fadeAnim = ObjectAnimator.ofFloat(imageView, \"alpha\", 0.0f,\n                                1.0f);\n                        fadeAnim.setInterpolator(new DecelerateInterpolator(1.0f));\n                        fadeAnim.setDuration(IMAGE_FADE_IN_MILLIS);\n                        fadeAnim.start();\n\n                        if (task.mExtraCount > 0) {\n                            imageView.setExtraImageCount(task.mExtraCount);\n                        }\n\n                        setupPreDrawForSharedElementTransition(imageView);\n                }\n            }\n        };\n\n        private void setupPreDrawForSharedElementTransition(View v) {\n            v.getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {\n                @Override\n                public boolean onPreDraw() {\n                    v.getViewTreeObserver().removeOnPreDrawListener(this);\n\n                    if (!mRemoveSharedElements && isActivityTransitionRunning()) {\n                        // Disable the window animations as it interferes with the\n                        // transition animation.\n                        getWindow().setWindowAnimations(0);\n                    }\n                    mEnterTransitionAnimationDelegate.markImagePreviewReady();\n                    return true;\n                }\n            });\n        }\n\n        ContentPreviewCoordinator(View parentView, boolean hideParentOnFail) {\n            super();\n\n            this.mParentView = parentView;\n            this.mHideParentOnFail = hideParentOnFail;\n        }\n\n        private void loadUriIntoView(final int imageResourceId, final Uri uri,\n                final int extraImages) {\n            mHandler.sendEmptyMessageDelayed(IMAGE_LOAD_TIMEOUT, mImageLoadTimeoutMillis);\n\n            AsyncTask.THREAD_POOL_EXECUTOR.execute(() -> {\n                int size = getResources().getDimensionPixelSize(\n                        R.dimen.chooser_preview_image_max_dimen);\n                final Bitmap bmp = loadThumbnail(uri, new Size(size, size));\n                final Message msg = Message.obtain();\n                msg.what = IMAGE_LOAD_INTO_VIEW;\n                msg.obj = new LoadUriTask(imageResourceId, uri, extraImages, bmp);\n                mHandler.sendMessage(msg);\n            });\n        }\n\n        private void cancelLoads() {\n            mHandler.removeMessages(IMAGE_LOAD_INTO_VIEW);\n            mHandler.removeMessages(IMAGE_LOAD_TIMEOUT);\n        }\n\n        private void maybeHideContentPreview() {\n            if (!mAtLeastOneLoaded) {\n                if (mHideParentOnFail) {\n                    Log.i(TAG, \"Hiding image preview area. Timed out waiting for preview to load\"\n                            + \" within \" + mImageLoadTimeoutMillis + \"ms.\");\n                    collapseParentView();\n                    if (shouldShowTabs()) {\n                        hideStickyContentPreview();\n                    } else if (mChooserMultiProfilePagerAdapter.getCurrentRootAdapter() != null) {\n                        mChooserMultiProfilePagerAdapter.getCurrentRootAdapter()\n                                .hideContentPreview();\n                    }\n                    mHideParentOnFail = false;\n                }\n                mRemoveSharedElements = true;\n                mEnterTransitionAnimationDelegate.markImagePreviewReady();\n            }\n        }\n\n        private void collapseParentView() {\n            // This will effectively hide the content preview row by forcing the height\n            // to zero. It is faster than forcing a relayout of the listview\n            final View v = mParentView;\n            int widthSpec = MeasureSpec.makeMeasureSpec(v.getWidth(), MeasureSpec.EXACTLY);\n            int heightSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.EXACTLY);\n            v.measure(widthSpec, heightSpec);\n            v.getLayoutParams().height = 0;\n            v.layout(v.getLeft(), v.getTop(), v.getRight(), v.getTop());\n            v.invalidate();\n        }\n    }\n\n    private final ChooserHandler mChooserHandler = new ChooserHandler();\n\n    private class ChooserHandler extends Handler {\n        private static final int LIST_VIEW_UPDATE_MESSAGE = 6;\n        private static final int SHORTCUT_MANAGER_ALL_SHARE_TARGET_RESULTS = 7;\n\n        private void removeAllMessages() {\n            removeMessages(LIST_VIEW_UPDATE_MESSAGE);\n            removeMessages(SHORTCUT_MANAGER_ALL_SHARE_TARGET_RESULTS);\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            if (mChooserMultiProfilePagerAdapter.getActiveListAdapter() == null || isDestroyed()) {\n                return;\n            }\n\n            switch (msg.what) {\n                case LIST_VIEW_UPDATE_MESSAGE:\n                    if (DEBUG) {\n                        Log.d(TAG, \"LIST_VIEW_UPDATE_MESSAGE; \");\n                    }\n\n                    UserHandle userHandle = (UserHandle) msg.obj;\n                    mChooserMultiProfilePagerAdapter.getListAdapterForUserHandle(userHandle)\n                            .refreshListView();\n                    break;\n\n                case SHORTCUT_MANAGER_ALL_SHARE_TARGET_RESULTS:\n                    if (DEBUG) Log.d(TAG, \"SHORTCUT_MANAGER_ALL_SHARE_TARGET_RESULTS\");\n                    final ServiceResultInfo[] resultInfos = (ServiceResultInfo[]) msg.obj;\n                    for (ServiceResultInfo resultInfo : resultInfos) {\n                        if (resultInfo.resultTargets != null) {\n                            ChooserListAdapter adapterForUserHandle =\n                                    mChooserMultiProfilePagerAdapter.getListAdapterForUserHandle(\n                                            resultInfo.userHandle);\n                            if (adapterForUserHandle != null) {\n                                adapterForUserHandle.addServiceResults(\n                                        resultInfo.originalTarget,\n                                        resultInfo.resultTargets, msg.arg1,\n                                        mDirectShareShortcutInfoCache);\n                            }\n                        }\n                    }\n\n                    logDirectShareTargetReceived(\n                            MetricsEvent.ACTION_DIRECT_SHARE_TARGETS_LOADED_SHORTCUT_MANAGER);\n                    sendVoiceChoicesIfNeeded();\n                    getChooserActivityLogger().logSharesheetDirectLoadComplete();\n\n                    mChooserMultiProfilePagerAdapter.getActiveListAdapter()\n                            .completeServiceTargetLoading();\n                    break;\n\n                default:\n                    super.handleMessage(msg);\n            }\n        }\n    };\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        if (Settings.Secure.getIntForUser(getContentResolver(),\n                Settings.Secure.SECURE_FRP_MODE, 0,\n                getUserId()) == 1) {\n            Log.e(TAG, \"Sharing disabled due to active FRP lock.\");\n            super.onCreate(savedInstanceState);\n            finish();\n            return;\n        }\n        final long intentReceivedTime = System.currentTimeMillis();\n        mLatencyTracker.onActionStart(ACTION_LOAD_SHARE_SHEET);\n\n        getChooserActivityLogger().logSharesheetTriggered();\n        // This is the only place this value is being set. Effectively final.\n        mIsAppPredictorComponentAvailable = isAppPredictionServiceAvailable();\n\n        mIsSuccessfullySelected = false;\n        Intent intent = getIntent();\n        Parcelable targetParcelable = intent.getParcelableExtra(Intent.EXTRA_INTENT);\n        if (targetParcelable instanceof Uri) {\n            try {\n                targetParcelable = Intent.parseUri(targetParcelable.toString(),\n                        Intent.URI_INTENT_SCHEME);\n            } catch (URISyntaxException ex) {\n                // doesn't parse as an intent; let the next test fail and error out\n            }\n        }\n\n        if (!(targetParcelable instanceof Intent)) {\n            Log.w(\"ChooserActivity\", \"Target is not an intent: \" + targetParcelable);\n            finish();\n            super.onCreate(null);\n            return;\n        }\n        Intent target = (Intent) targetParcelable;\n        if (target != null) {\n            modifyTargetIntent(target);\n        }\n        Parcelable[] targetsParcelable\n                = intent.getParcelableArrayExtra(Intent.EXTRA_ALTERNATE_INTENTS);\n        if (targetsParcelable != null) {\n            final boolean offset = target == null;\n            Intent[] additionalTargets =\n                    new Intent[offset ? targetsParcelable.length - 1 : targetsParcelable.length];\n            for (int i = 0; i < targetsParcelable.length; i++) {\n                if (!(targetsParcelable[i] instanceof Intent)) {\n                    Log.w(TAG, \"EXTRA_ALTERNATE_INTENTS array entry #\" + i + \" is not an Intent: \"\n                            + targetsParcelable[i]);\n                    finish();\n                    super.onCreate(null);\n                    return;\n                }\n                final Intent additionalTarget = (Intent) targetsParcelable[i];\n                if (i == 0 && target == null) {\n                    target = additionalTarget;\n                    modifyTargetIntent(target);\n                } else {\n                    additionalTargets[offset ? i - 1 : i] = additionalTarget;\n                    modifyTargetIntent(additionalTarget);\n                }\n            }\n            setAdditionalTargets(additionalTargets);\n        }\n\n        mReplacementExtras = intent.getBundleExtra(Intent.EXTRA_REPLACEMENT_EXTRAS);\n\n        // Do not allow the title to be changed when sharing content\n        CharSequence title = null;\n        if (target != null) {\n            if (!isSendAction(target)) {\n                title = intent.getCharSequenceExtra(Intent.EXTRA_TITLE);\n            } else {\n                Log.w(TAG, \"Ignoring intent's EXTRA_TITLE, deprecated in P. You may wish to set a\"\n                        + \" preview title by using EXTRA_TITLE property of the wrapped\"\n                        + \" EXTRA_INTENT.\");\n            }\n        }\n\n        int defaultTitleRes = 0;\n        if (title == null) {\n            defaultTitleRes = com.android.internal.R.string.chooseActivity;\n        }\n\n        Parcelable[] pa = intent.getParcelableArrayExtra(Intent.EXTRA_INITIAL_INTENTS);\n        Intent[] initialIntents = null;\n        if (pa != null) {\n            int count = Math.min(pa.length, MAX_EXTRA_INITIAL_INTENTS);\n            initialIntents = new Intent[count];\n            for (int i = 0; i < count; i++) {\n                if (!(pa[i] instanceof Intent)) {\n                    Log.w(TAG, \"Initial intent #\" + i + \" not an Intent: \" + pa[i]);\n                    finish();\n                    super.onCreate(null);\n                    return;\n                }\n                final Intent in = (Intent) pa[i];\n                modifyTargetIntent(in);\n                initialIntents[i] = in;\n            }\n        }\n\n        mReferrerFillInIntent = new Intent().putExtra(Intent.EXTRA_REFERRER, getReferrer());\n\n        mChosenComponentSender = intent.getParcelableExtra(\n                Intent.EXTRA_CHOSEN_COMPONENT_INTENT_SENDER, android.content.IntentSender.class);\n        mRefinementIntentSender = intent.getParcelableExtra(\n                Intent.EXTRA_CHOOSER_REFINEMENT_INTENT_SENDER, android.content.IntentSender.class);\n        setSafeForwardingMode(true);\n\n        mPinnedSharedPrefs = getPinnedSharedPrefs(this);\n\n        pa = intent.getParcelableArrayExtra(Intent.EXTRA_EXCLUDE_COMPONENTS);\n\n\n        // Exclude out Nearby from main list if chip is present, to avoid duplication\n        ComponentName nearbySharingComponent = getNearbySharingComponent();\n        boolean shouldFilterNearby = !shouldNearbyShareBeFirstInRankedRow()\n                && nearbySharingComponent != null;\n\n        if (pa != null) {\n            ComponentName[] names = new ComponentName[pa.length + (shouldFilterNearby ? 1 : 0)];\n            for (int i = 0; i < pa.length; i++) {\n                if (!(pa[i] instanceof ComponentName)) {\n                    Log.w(TAG, \"Filtered component #\" + i + \" not a ComponentName: \" + pa[i]);\n                    names = null;\n                    break;\n                }\n                names[i] = (ComponentName) pa[i];\n            }\n            if (shouldFilterNearby) {\n                names[names.length - 1] = nearbySharingComponent;\n            }\n\n            mFilteredComponentNames = names;\n        } else if (shouldFilterNearby) {\n            mFilteredComponentNames = new ComponentName[1];\n            mFilteredComponentNames[0] = nearbySharingComponent;\n        }\n\n        pa = intent.getParcelableArrayExtra(Intent.EXTRA_CHOOSER_TARGETS);\n        if (pa != null) {\n            int count = Math.min(pa.length, MAX_EXTRA_CHOOSER_TARGETS);\n            ChooserTarget[] targets = new ChooserTarget[count];\n            for (int i = 0; i < count; i++) {\n                if (!(pa[i] instanceof ChooserTarget)) {\n                    Log.w(TAG, \"Chooser target #\" + i + \" not a ChooserTarget: \" + pa[i]);\n                    targets = null;\n                    break;\n                }\n                ChooserTarget chooserTarget = (ChooserTarget) pa[i];\n                if (!hasValidIcon(chooserTarget)) {\n                    chooserTarget = removeIcon(chooserTarget);\n                }\n                targets[i] = chooserTarget;\n            }\n            mCallerChooserTargets = targets;\n        }\n\n        mMaxTargetsPerRow = getResources().getInteger(R.integer.config_chooser_max_targets_per_row);\n        mShouldDisplayLandscape =\n                shouldDisplayLandscape(getResources().getConfiguration().orientation);\n        setRetainInOnStop(intent.getBooleanExtra(EXTRA_PRIVATE_RETAIN_IN_ON_STOP, false));\n        super.onCreate(savedInstanceState, target, title, defaultTitleRes, initialIntents,\n                null, false);\n\n        mChooserShownTime = System.currentTimeMillis();\n        final long systemCost = mChooserShownTime - intentReceivedTime;\n\n        getMetricsLogger().write(new LogMaker(MetricsEvent.ACTION_ACTIVITY_CHOOSER_SHOWN)\n                .setSubtype(isWorkProfile() ? MetricsEvent.MANAGED_PROFILE :\n                        MetricsEvent.PARENT_PROFILE)\n                .addTaggedData(MetricsEvent.FIELD_SHARESHEET_MIMETYPE, target.getType())\n                .addTaggedData(MetricsEvent.FIELD_TIME_TO_APP_TARGETS, systemCost));\n\n        if (mResolverDrawerLayout != null) {\n            mResolverDrawerLayout.addOnLayoutChangeListener(this::handleLayoutChange);\n\n            // expand/shrink direct share 4 -> 8 viewgroup\n            if (isSendAction(target)) {\n                mResolverDrawerLayout.setOnScrollChangeListener(this::handleScroll);\n            }\n\n            mResolverDrawerLayout.setOnCollapsedChangedListener(\n                    new ResolverDrawerLayout.OnCollapsedChangedListener() {\n\n                        // Only consider one expansion per activity creation\n                        private boolean mWrittenOnce = false;\n\n                        @Override\n                        public void onCollapsedChanged(boolean isCollapsed) {\n                            if (!isCollapsed && !mWrittenOnce) {\n                                incrementNumSheetExpansions();\n                                mWrittenOnce = true;\n                            }\n                            getChooserActivityLogger()\n                                    .logSharesheetExpansionChanged(isCollapsed);\n                        }\n                    });\n        }\n\n        if (DEBUG) {\n            Log.d(TAG, \"System Time Cost is \" + systemCost);\n        }\n\n        getChooserActivityLogger().logShareStarted(\n                FrameworkStatsLog.SHARESHEET_STARTED,\n                getReferrerPackageName(),\n                target.getType(),\n                mCallerChooserTargets == null ? 0 : mCallerChooserTargets.length,\n                initialIntents == null ? 0 : initialIntents.length,\n                isWorkProfile(),\n                findPreferredContentPreview(getTargetIntent(), getContentResolver()),\n                target.getAction()\n        );\n        mDirectShareShortcutInfoCache = new HashMap<>();\n\n        setEnterSharedElementCallback(new SharedElementCallback() {\n            @Override\n            public void onMapSharedElements(List<String> names, Map<String, View> sharedElements) {\n                if (mRemoveSharedElements) {\n                    names.remove(FIRST_IMAGE_PREVIEW_TRANSITION_NAME);\n                    sharedElements.remove(FIRST_IMAGE_PREVIEW_TRANSITION_NAME);\n                }\n                super.onMapSharedElements(names, sharedElements);\n                mRemoveSharedElements = false;\n            }\n        });\n        mEnterTransitionAnimationDelegate.postponeTransition();\n    }\n\n    @Override\n    protected int appliedThemeResId() {\n        return R.style.Theme_DeviceDefault_Chooser;\n    }\n\n    private AppPredictor setupAppPredictorForUser(UserHandle userHandle,\n            AppPredictor.Callback appPredictorCallback) {\n        AppPredictor appPredictor = getAppPredictorForDirectShareIfEnabled(userHandle);\n        if (appPredictor == null) {\n            return null;\n        }\n        mDirectShareAppTargetCache = new HashMap<>();\n        appPredictor.registerPredictionUpdates(this.getMainExecutor(), appPredictorCallback);\n        return appPredictor;\n    }\n\n    private AppPredictor.Callback createAppPredictorCallback(\n            ChooserListAdapter chooserListAdapter) {\n        return resultList -> {\n            if (isFinishing() || isDestroyed()) {\n                return;\n            }\n            if (chooserListAdapter.getCount() == 0) {\n                return;\n            }\n            if (resultList.isEmpty()\n                    && shouldQueryShortcutManager(chooserListAdapter.getUserHandle())) {\n                // APS may be disabled, so try querying targets ourselves.\n                queryDirectShareTargets(chooserListAdapter, true);\n                return;\n            }\n            final List<ShortcutManager.ShareShortcutInfo> shareShortcutInfos =\n                    new ArrayList<>();\n\n            List<AppTarget> shortcutResults = new ArrayList<>();\n            for (AppTarget appTarget : resultList) {\n                if (appTarget.getShortcutInfo() == null) {\n                    continue;\n                }\n                shortcutResults.add(appTarget);\n            }\n            resultList = shortcutResults;\n            for (AppTarget appTarget : resultList) {\n                shareShortcutInfos.add(new ShortcutManager.ShareShortcutInfo(\n                        appTarget.getShortcutInfo(),\n                        new ComponentName(\n                                appTarget.getPackageName(), appTarget.getClassName())));\n            }\n            sendShareShortcutInfoList(shareShortcutInfos, chooserListAdapter, resultList,\n                    chooserListAdapter.getUserHandle());\n        };\n    }\n\n    static SharedPreferences getPinnedSharedPrefs(Context context) {\n        // The code below is because in the android:ui process, no one can hear you scream.\n        // The package info in the context isn't initialized in the way it is for normal apps,\n        // so the standard, name-based context.getSharedPreferences doesn't work. Instead, we\n        // build the path manually below using the same policy that appears in ContextImpl.\n        // This fails silently under the hood if there's a problem, so if we find ourselves in\n        // the case where we don't have access to credential encrypted storage we just won't\n        // have our pinned target info.\n        final File prefsFile = new File(new File(\n                Environment.getDataUserCePackageDirectory(StorageManager.UUID_PRIVATE_INTERNAL,\n                        context.getUserId(), context.getPackageName()),\n                \"shared_prefs\"),\n                PINNED_SHARED_PREFS_NAME + \".xml\");\n        return context.getSharedPreferences(prefsFile, MODE_PRIVATE);\n    }\n\n    @Override\n    protected AbstractMultiProfilePagerAdapter createMultiProfilePagerAdapter(\n            Intent[] initialIntents,\n            List<ResolveInfo> rList,\n            boolean filterLastUsed) {\n        if (shouldShowTabs()) {\n            mChooserMultiProfilePagerAdapter = createChooserMultiProfilePagerAdapterForTwoProfiles(\n                    initialIntents, rList, filterLastUsed);\n        } else {\n            mChooserMultiProfilePagerAdapter = createChooserMultiProfilePagerAdapterForOneProfile(\n                    initialIntents, rList, filterLastUsed);\n        }\n        return mChooserMultiProfilePagerAdapter;\n    }\n\n    @Override\n    protected EmptyStateProvider createBlockerEmptyStateProvider() {\n        final boolean isSendAction = isSendAction(getTargetIntent());\n\n        final EmptyState noWorkToPersonalEmptyState =\n                new DevicePolicyBlockerEmptyState(\n                /* context= */ this,\n                /* devicePolicyStringTitleId= */ RESOLVER_CROSS_PROFILE_BLOCKED_TITLE,\n                /* defaultTitleResource= */ R.string.resolver_cross_profile_blocked,\n                /* devicePolicyStringSubtitleId= */\n                isSendAction ? RESOLVER_CANT_SHARE_WITH_PERSONAL : RESOLVER_CANT_ACCESS_PERSONAL,\n                /* defaultSubtitleResource= */\n                isSendAction ? R.string.resolver_cant_share_with_personal_apps_explanation\n                        : R.string.resolver_cant_access_personal_apps_explanation,\n                /* devicePolicyEventId= */ RESOLVER_EMPTY_STATE_NO_SHARING_TO_PERSONAL,\n                /* devicePolicyEventCategory= */ ResolverActivity.METRICS_CATEGORY_CHOOSER);\n\n        final EmptyState noPersonalToWorkEmptyState =\n                new DevicePolicyBlockerEmptyState(\n                /* context= */ this,\n                /* devicePolicyStringTitleId= */ RESOLVER_CROSS_PROFILE_BLOCKED_TITLE,\n                /* defaultTitleResource= */ R.string.resolver_cross_profile_blocked,\n                /* devicePolicyStringSubtitleId= */\n                isSendAction ? RESOLVER_CANT_SHARE_WITH_WORK : RESOLVER_CANT_ACCESS_WORK,\n                /* defaultSubtitleResource= */\n                isSendAction ? R.string.resolver_cant_share_with_work_apps_explanation\n                        : R.string.resolver_cant_access_work_apps_explanation,\n                /* devicePolicyEventId= */ RESOLVER_EMPTY_STATE_NO_SHARING_TO_WORK,\n                /* devicePolicyEventCategory= */ ResolverActivity.METRICS_CATEGORY_CHOOSER);\n\n        return new NoCrossProfileEmptyStateProvider(getPersonalProfileUserHandle(),\n                noWorkToPersonalEmptyState, noPersonalToWorkEmptyState,\n                createCrossProfileIntentsChecker(), getTabOwnerUserHandleForLaunch());\n    }\n\n    private ChooserMultiProfilePagerAdapter createChooserMultiProfilePagerAdapterForOneProfile(\n            Intent[] initialIntents,\n            List<ResolveInfo> rList,\n            boolean filterLastUsed) {\n        ChooserGridAdapter adapter = createChooserGridAdapter(\n                /* context */ this,\n                /* payloadIntents */ mIntents,\n                initialIntents,\n                rList,\n                filterLastUsed,\n                /* userHandle */ getPersonalProfileUserHandle());\n        return new ChooserMultiProfilePagerAdapter(\n                /* context */ this,\n                adapter,\n                createEmptyStateProvider(/* workProfileUserHandle= */ null),\n                mQuietModeManager,\n                /* workProfileUserHandle= */ null,\n                getCloneProfileUserHandle(),\n                mMaxTargetsPerRow);\n    }\n\n    private ChooserMultiProfilePagerAdapter createChooserMultiProfilePagerAdapterForTwoProfiles(\n            Intent[] initialIntents,\n            List<ResolveInfo> rList,\n            boolean filterLastUsed) {\n        int selectedProfile = findSelectedProfile();\n        ChooserGridAdapter personalAdapter = createChooserGridAdapter(\n                /* context */ this,\n                /* payloadIntents */ mIntents,\n                selectedProfile == PROFILE_PERSONAL ? initialIntents : null,\n                rList,\n                filterLastUsed,\n                /* userHandle */ getPersonalProfileUserHandle());\n        ChooserGridAdapter workAdapter = createChooserGridAdapter(\n                /* context */ this,\n                /* payloadIntents */ mIntents,\n                selectedProfile == PROFILE_WORK ? initialIntents : null,\n                rList,\n                filterLastUsed,\n                /* userHandle */ getWorkProfileUserHandle());\n        return new ChooserMultiProfilePagerAdapter(\n                /* context */ this,\n                personalAdapter,\n                workAdapter,\n                createEmptyStateProvider(/* workProfileUserHandle= */ getWorkProfileUserHandle()),\n                mQuietModeManager,\n                selectedProfile,\n                getWorkProfileUserHandle(),\n                getCloneProfileUserHandle(),\n                mMaxTargetsPerRow);\n    }\n\n    private int findSelectedProfile() {\n        int selectedProfile = getSelectedProfileExtra();\n        if (selectedProfile == -1) {\n            selectedProfile = getProfileForUser(getTabOwnerUserHandleForLaunch());\n        }\n        return selectedProfile;\n    }\n\n    @Override\n    protected boolean postRebuildList(boolean rebuildCompleted) {\n        updateStickyContentPreview();\n        if (shouldShowStickyContentPreview()\n                || mChooserMultiProfilePagerAdapter\n                        .getCurrentRootAdapter().getSystemRowCount() != 0) {\n            logActionShareWithPreview();\n        }\n        return postRebuildListInternal(rebuildCompleted);\n    }\n\n    /**\n     * Returns true if app prediction service is defined and the component exists on device.\n     */\n    private boolean isAppPredictionServiceAvailable() {\n        return getPackageManager().getAppPredictionServicePackageName() != null;\n    }\n\n    /**\n     * Check if the profile currently used is a work profile.\n     * @return true if it is work profile, false if it is parent profile (or no work profile is\n     * set up)\n     */\n    protected boolean isWorkProfile() {\n        return getSystemService(UserManager.class)\n                .getUserInfo(UserHandle.myUserId()).isManagedProfile();\n    }\n\n    @Override\n    protected PackageMonitor createPackageMonitor(ResolverListAdapter listAdapter) {\n        return new PackageMonitor() {\n            @Override\n            public void onSomePackagesChanged() {\n                handlePackagesChanged(listAdapter);\n            }\n        };\n    }\n\n    /**\n     * Update UI to reflect changes in data.\n     */\n    public void handlePackagesChanged() {\n        handlePackagesChanged(/* listAdapter */ null);\n    }\n\n    /**\n     * Update UI to reflect changes in data.\n     * <p>If {@code listAdapter} is {@code null}, both profile list adapters are updated if\n     * available.\n     */\n    private void handlePackagesChanged(@Nullable ResolverListAdapter listAdapter) {\n        // Refresh pinned items\n        mPinnedSharedPrefs = getPinnedSharedPrefs(this);\n        if (listAdapter == null) {\n            mChooserMultiProfilePagerAdapter.getActiveListAdapter().handlePackagesChanged();\n            if (mChooserMultiProfilePagerAdapter.getCount() > 1) {\n                mChooserMultiProfilePagerAdapter.getInactiveListAdapter().handlePackagesChanged();\n            }\n        } else {\n            listAdapter.handlePackagesChanged();\n        }\n        updateProfileViewButton();\n    }\n\n    private void onCopyButtonClicked(View v) {\n        Intent targetIntent = getTargetIntent();\n        if (targetIntent == null) {\n            finish();\n        } else {\n            final String action = targetIntent.getAction();\n\n            ClipData clipData = null;\n            if (Intent.ACTION_SEND.equals(action)) {\n                String extraText = targetIntent.getStringExtra(Intent.EXTRA_TEXT);\n                Uri extraStream = targetIntent.getParcelableExtra(Intent.EXTRA_STREAM, android.net.Uri.class);\n\n                if (extraText != null) {\n                    clipData = ClipData.newPlainText(null, extraText);\n                } else if (extraStream != null) {\n                    clipData = ClipData.newUri(getContentResolver(), null, extraStream);\n                } else {\n                    Log.w(TAG, \"No data available to copy to clipboard\");\n                    return;\n                }\n            } else if (Intent.ACTION_SEND_MULTIPLE.equals(action)) {\n                final ArrayList<Uri> streams = targetIntent.getParcelableArrayListExtra(\n                        Intent.EXTRA_STREAM, android.net.Uri.class);\n                clipData = ClipData.newUri(getContentResolver(), null, streams.get(0));\n                for (int i = 1; i < streams.size(); i++) {\n                    clipData.addItem(getContentResolver(), new ClipData.Item(streams.get(i)));\n                }\n            } else {\n                // expected to only be visible with ACTION_SEND or ACTION_SEND_MULTIPLE\n                // so warn about unexpected action\n                Log.w(TAG, \"Action (\" + action + \") not supported for copying to clipboard\");\n                return;\n            }\n\n            ClipboardManager clipboardManager = (ClipboardManager) getSystemService(\n                    Context.CLIPBOARD_SERVICE);\n            clipboardManager.setPrimaryClipAsPackage(clipData, getReferrerPackageName());\n\n            // Log share completion via copy\n            LogMaker targetLogMaker = new LogMaker(\n                    MetricsEvent.ACTION_ACTIVITY_CHOOSER_PICKED_SYSTEM_TARGET).setSubtype(1);\n            getMetricsLogger().write(targetLogMaker);\n            getChooserActivityLogger().logShareTargetSelected(\n                    SELECTION_TYPE_COPY,\n                    \"\",\n                    -1,\n                    false);\n\n            setResult(RESULT_OK);\n            finish();\n        }\n    }\n\n    @Override\n    protected void onResume() {\n        super.onResume();\n        Log.d(TAG, \"onResume: \" + getComponentName().flattenToShortString());\n        maybeCancelFinishAnimation();\n    }\n\n    @Override\n    public void onConfigurationChanged(Configuration newConfig) {\n        super.onConfigurationChanged(newConfig);\n        ViewPager viewPager = findViewById(R.id.profile_pager);\n        if (viewPager.isLayoutRtl()) {\n            mMultiProfilePagerAdapter.setupViewPager(viewPager);\n        }\n\n        mShouldDisplayLandscape = shouldDisplayLandscape(newConfig.orientation);\n        mMaxTargetsPerRow = getResources().getInteger(R.integer.config_chooser_max_targets_per_row);\n        mChooserMultiProfilePagerAdapter.setMaxTargetsPerRow(mMaxTargetsPerRow);\n        adjustPreviewWidth(newConfig.orientation, null);\n        updateStickyContentPreview();\n        updateTabPadding();\n    }\n\n    private boolean shouldDisplayLandscape(int orientation) {\n        // Sharesheet fixes the # of items per row and therefore can not correctly lay out\n        // when in the restricted size of multi-window mode. In the future, would be nice\n        // to use minimum dp size requirements instead\n        return orientation == Configuration.ORIENTATION_LANDSCAPE && !isInMultiWindowMode();\n    }\n\n    private void adjustPreviewWidth(int orientation, View parent) {\n        int width = -1;\n        if (mShouldDisplayLandscape) {\n            width = getResources().getDimensionPixelSize(R.dimen.chooser_preview_width);\n        }\n\n        parent = parent == null ? getWindow().getDecorView() : parent;\n\n        updateLayoutWidth(R.id.content_preview_text_layout, width, parent);\n        updateLayoutWidth(R.id.content_preview_title_layout, width, parent);\n        updateLayoutWidth(R.id.content_preview_file_layout, width, parent);\n    }\n\n    private void updateTabPadding() {\n        if (shouldShowTabs()) {\n            View tabs = findViewById(R.id.tabs);\n            float iconSize = getResources().getDimension(R.dimen.chooser_icon_size);\n            // The entire width consists of icons or padding. Divide the item padding in half to get\n            // paddingHorizontal.\n            float padding = (tabs.getWidth() - mMaxTargetsPerRow * iconSize)\n                    / mMaxTargetsPerRow / 2;\n            // Subtract the margin the buttons already have.\n            padding -= getResources().getDimension(R.dimen.resolver_profile_tab_margin);\n            tabs.setPadding((int) padding, 0, (int) padding, 0);\n        }\n    }\n\n    private void updateLayoutWidth(int layoutResourceId, int width, View parent) {\n        View view = parent.findViewById(layoutResourceId);\n        if (view != null && view.getLayoutParams() != null) {\n            LayoutParams params = view.getLayoutParams();\n            params.width = width;\n            view.setLayoutParams(params);\n        }\n    }\n\n    /**\n     * Create a view that will be shown in the content preview area\n     * @param parent reference to the parent container where the view should be attached to\n     * @return content preview view\n     */\n    protected ViewGroup createContentPreviewView(ViewGroup parent) {\n        Intent targetIntent = getTargetIntent();\n        int previewType = findPreferredContentPreview(targetIntent, getContentResolver());\n        return displayContentPreview(previewType, targetIntent, getLayoutInflater(), parent);\n    }\n\n    @VisibleForTesting\n    protected ComponentName getNearbySharingComponent() {\n        String nearbyComponent = Settings.Secure.getString(\n                getContentResolver(),\n                Settings.Secure.NEARBY_SHARING_COMPONENT);\n        if (TextUtils.isEmpty(nearbyComponent)) {\n            nearbyComponent = getString(R.string.config_defaultNearbySharingComponent);\n        }\n        if (TextUtils.isEmpty(nearbyComponent)) {\n            return null;\n        }\n        return ComponentName.unflattenFromString(nearbyComponent);\n    }\n\n    @VisibleForTesting\n    protected @Nullable ComponentName getEditSharingComponent() {\n        String editorPackage = getApplicationContext().getString(R.string.config_systemImageEditor);\n        if (editorPackage == null || TextUtils.isEmpty(editorPackage)) {\n            return null;\n        }\n        return ComponentName.unflattenFromString(editorPackage);\n    }\n\n    @VisibleForTesting\n    protected TargetInfo getEditSharingTarget(Intent originalIntent) {\n        final ComponentName cn = getEditSharingComponent();\n\n        final Intent resolveIntent = new Intent(originalIntent);\n        // Retain only URI permission grant flags if present. Other flags may prevent the scene\n        // transition animation from running (i.e FLAG_ACTIVITY_NO_ANIMATION,\n        // FLAG_ACTIVITY_NEW_TASK, FLAG_ACTIVITY_NEW_DOCUMENT) but also not needed.\n        resolveIntent.setFlags(originalIntent.getFlags() & URI_PERMISSION_INTENT_FLAGS);\n        resolveIntent.setComponent(cn);\n        resolveIntent.setAction(Intent.ACTION_EDIT);\n        String originalAction = originalIntent.getAction();\n        if (Intent.ACTION_SEND.equals(originalAction)) {\n            if (resolveIntent.getData() == null) {\n                Uri uri = resolveIntent.getParcelableExtra(Intent.EXTRA_STREAM, android.net.Uri.class);\n                if (uri != null) {\n                    String mimeType = getContentResolver().getType(uri);\n                    resolveIntent.setDataAndType(uri, mimeType);\n                }\n            }\n        } else {\n            Log.e(TAG, originalAction + \" is not supported.\");\n            return null;\n        }\n        final ResolveInfo ri = getPackageManager().resolveActivity(\n                resolveIntent, PackageManager.GET_META_DATA);\n        if (ri == null || ri.activityInfo == null) {\n            Log.e(TAG, \"Device-specified image edit component (\" + cn\n                    + \") not available\");\n            return null;\n        }\n\n        final DisplayResolveInfo dri = new DisplayResolveInfo(\n                originalIntent, ri, getString(R.string.screenshot_edit), \"\", resolveIntent, null);\n        dri.setDisplayIcon(getDrawable(R.drawable.ic_screenshot_edit));\n        return dri;\n    }\n\n    @VisibleForTesting\n    protected TargetInfo getNearbySharingTarget(Intent originalIntent) {\n        final ComponentName cn = getNearbySharingComponent();\n        if (cn == null) return null;\n\n        final Intent resolveIntent = new Intent(originalIntent);\n        resolveIntent.setComponent(cn);\n        final ResolveInfo ri = getPackageManager().resolveActivity(\n                resolveIntent, PackageManager.GET_META_DATA);\n        if (ri == null || ri.activityInfo == null) {\n            Log.e(TAG, \"Device-specified nearby sharing component (\" + cn\n                    + \") not available\");\n            return null;\n        }\n\n        // Allow the nearby sharing component to provide a more appropriate icon and label\n        // for the chip.\n        CharSequence name = null;\n        Drawable icon = null;\n        final Bundle metaData = ri.activityInfo.metaData;\n        if (metaData != null) {\n            try {\n                final Resources pkgRes = getPackageManager().getResourcesForActivity(cn);\n                final int nameResId = metaData.getInt(CHIP_LABEL_METADATA_KEY);\n                name = pkgRes.getString(nameResId);\n                final int resId = metaData.getInt(CHIP_ICON_METADATA_KEY);\n                icon = pkgRes.getDrawable(resId);\n            } catch (Resources.NotFoundException ex) {\n            } catch (NameNotFoundException ex) {\n            }\n        }\n        if (TextUtils.isEmpty(name)) {\n            name = ri.loadLabel(getPackageManager());\n        }\n        if (icon == null) {\n            icon = ri.loadIcon(getPackageManager());\n        }\n\n        final DisplayResolveInfo dri = new DisplayResolveInfo(\n                originalIntent, ri, name, \"\", resolveIntent, null);\n        dri.setDisplayIcon(icon);\n        return dri;\n    }\n\n    private Button createActionButton(Drawable icon, CharSequence title, View.OnClickListener r) {\n        Button b = (Button) LayoutInflater.from(this).inflate(R.layout.chooser_action_button, null);\n        if (icon != null) {\n            final int size = getResources()\n                    .getDimensionPixelSize(R.dimen.chooser_action_button_icon_size);\n            icon.setBounds(0, 0, size, size);\n            b.setCompoundDrawablesRelative(icon, null, null, null);\n        }\n        b.setText(title);\n        b.setOnClickListener(r);\n        return b;\n    }\n\n    private Button createCopyButton() {\n        final Button b = createActionButton(\n                getDrawable(R.drawable.ic_menu_copy_material),\n                getString(R.string.copy), this::onCopyButtonClicked);\n        b.setId(R.id.chooser_copy_button);\n        return b;\n    }\n\n    private @Nullable Button createNearbyButton(Intent originalIntent) {\n        final TargetInfo ti = getNearbySharingTarget(originalIntent);\n        if (ti == null) return null;\n\n        final Button b = createActionButton(\n                ti.getDisplayIcon(this),\n                ti.getDisplayLabel(),\n                (View unused) -> {\n                    // Log share completion via nearby\n                    getChooserActivityLogger().logShareTargetSelected(\n                            SELECTION_TYPE_NEARBY,\n                            \"\",\n                            -1,\n                            false);\n                    // Action bar is user-independent, always start as primary\n                    safelyStartActivityAsUser(ti, getPersonalProfileUserHandle());\n                    finish();\n                }\n        );\n        b.setId(R.id.chooser_nearby_button);\n        return b;\n    }\n\n    private @Nullable Button createEditButton(Intent originalIntent) {\n        final TargetInfo ti = getEditSharingTarget(originalIntent);\n        if (ti == null) return null;\n\n        final Button b = createActionButton(\n                ti.getDisplayIcon(this),\n                ti.getDisplayLabel(),\n                (View unused) -> {\n                    // Log share completion via edit\n                    getChooserActivityLogger().logShareTargetSelected(\n                            SELECTION_TYPE_EDIT,\n                            \"\",\n                            -1,\n                            false);\n                    View firstImgView = getFirstVisibleImgPreviewView();\n                    // Action bar is user-independent, always start as primary\n                    if (firstImgView == null) {\n                        safelyStartActivityAsUser(ti, getPersonalProfileUserHandle());\n                        finish();\n                    } else {\n                        ActivityOptions options = ActivityOptions.makeSceneTransitionAnimation(\n                                this, firstImgView, IMAGE_EDITOR_SHARED_ELEMENT);\n                        safelyStartActivityAsUser(\n                                ti, getPersonalProfileUserHandle(), options.toBundle());\n                        startFinishAnimation();\n                    }\n                }\n        );\n        b.setId(R.id.chooser_edit_button);\n        return b;\n    }\n\n    @Nullable\n    private View getFirstVisibleImgPreviewView() {\n        View firstImage = findViewById(R.id.content_preview_image_1_large);\n        return firstImage != null && firstImage.isVisibleToUser() ? firstImage : null;\n    }\n\n    private void addActionButton(ViewGroup parent, Button b) {\n        if (b == null) return;\n        final ViewGroup.MarginLayoutParams lp = new ViewGroup.MarginLayoutParams(\n                        LayoutParams.WRAP_CONTENT,\n                        LayoutParams.WRAP_CONTENT\n                );\n        final int gap = getResources().getDimensionPixelSize(R.dimen.resolver_icon_margin) / 2;\n        lp.setMarginsRelative(gap, 0, gap, 0);\n        parent.addView(b, lp);\n    }\n\n    private ViewGroup displayContentPreview(@ContentPreviewType int previewType,\n            Intent targetIntent, LayoutInflater layoutInflater, ViewGroup parent) {\n        ViewGroup layout = null;\n\n        switch (previewType) {\n            case CONTENT_PREVIEW_TEXT:\n                layout = displayTextContentPreview(targetIntent, layoutInflater, parent);\n                break;\n            case CONTENT_PREVIEW_IMAGE:\n                layout = displayImageContentPreview(targetIntent, layoutInflater, parent);\n                break;\n            case CONTENT_PREVIEW_FILE:\n                layout = displayFileContentPreview(targetIntent, layoutInflater, parent);\n                break;\n            default:\n                Log.e(TAG, \"Unexpected content preview type: \" + previewType);\n        }\n\n        if (layout != null) {\n            adjustPreviewWidth(getResources().getConfiguration().orientation, layout);\n        }\n        if (previewType != CONTENT_PREVIEW_IMAGE) {\n            mEnterTransitionAnimationDelegate.markImagePreviewReady();\n        }\n\n        return layout;\n    }\n\n    private ViewGroup displayTextContentPreview(Intent targetIntent, LayoutInflater layoutInflater,\n            ViewGroup parent) {\n        ViewGroup contentPreviewLayout = (ViewGroup) layoutInflater.inflate(\n                R.layout.chooser_grid_preview_text, parent, false);\n\n        final ViewGroup actionRow =\n                (ViewGroup) contentPreviewLayout.findViewById(R.id.chooser_action_row);\n        addActionButton(actionRow, createCopyButton());\n        if (shouldNearbyShareBeIncludedAsActionButton()) {\n            addActionButton(actionRow, createNearbyButton(targetIntent));\n        }\n\n        CharSequence sharingText = targetIntent.getCharSequenceExtra(Intent.EXTRA_TEXT);\n        if (sharingText == null) {\n            contentPreviewLayout.findViewById(R.id.content_preview_text_layout).setVisibility(\n                    View.GONE);\n        } else {\n            TextView textView = contentPreviewLayout.findViewById(R.id.content_preview_text);\n            textView.setText(sharingText);\n        }\n\n        String previewTitle = targetIntent.getStringExtra(Intent.EXTRA_TITLE);\n        if (TextUtils.isEmpty(previewTitle)) {\n            contentPreviewLayout.findViewById(R.id.content_preview_title_layout).setVisibility(\n                    View.GONE);\n        } else {\n            TextView previewTitleView = contentPreviewLayout.findViewById(\n                    R.id.content_preview_title);\n            previewTitleView.setText(previewTitle);\n\n            ClipData previewData = targetIntent.getClipData();\n            Uri previewThumbnail = null;\n            if (previewData != null) {\n                if (previewData.getItemCount() > 0) {\n                    ClipData.Item previewDataItem = previewData.getItemAt(0);\n                    previewThumbnail = previewDataItem.getUri();\n                }\n            }\n\n            ImageView previewThumbnailView = contentPreviewLayout.findViewById(\n                    R.id.content_preview_thumbnail);\n            if (!validForContentPreview(previewThumbnail)) {\n                previewThumbnailView.setVisibility(View.GONE);\n            } else {\n                mPreviewCoord = new ContentPreviewCoordinator(contentPreviewLayout, false);\n                mPreviewCoord.loadUriIntoView(R.id.content_preview_thumbnail, previewThumbnail, 0);\n            }\n        }\n\n        return contentPreviewLayout;\n    }\n\n    private ViewGroup displayImageContentPreview(Intent targetIntent, LayoutInflater layoutInflater,\n            ViewGroup parent) {\n        ViewGroup contentPreviewLayout = (ViewGroup) layoutInflater.inflate(\n                R.layout.chooser_grid_preview_image, parent, false);\n        ViewGroup imagePreview = contentPreviewLayout.findViewById(R.id.content_preview_image_area);\n\n        final ViewGroup actionRow =\n                (ViewGroup) contentPreviewLayout.findViewById(R.id.chooser_action_row);\n        //TODO: addActionButton(actionRow, createCopyButton());\n        if (shouldNearbyShareBeIncludedAsActionButton()) {\n            addActionButton(actionRow, createNearbyButton(targetIntent));\n        }\n        addActionButton(actionRow, createEditButton(targetIntent));\n\n        mPreviewCoord = new ContentPreviewCoordinator(contentPreviewLayout, false);\n\n        String action = targetIntent.getAction();\n        if (Intent.ACTION_SEND.equals(action)) {\n            Uri uri = targetIntent.getParcelableExtra(Intent.EXTRA_STREAM, android.net.Uri.class);\n            if (!validForContentPreview(uri)) {\n                imagePreview.setVisibility(View.GONE);\n                return contentPreviewLayout;\n            }\n            imagePreview.findViewById(R.id.content_preview_image_1_large)\n                    .setTransitionName(ChooserActivity.FIRST_IMAGE_PREVIEW_TRANSITION_NAME);\n            mPreviewCoord.loadUriIntoView(R.id.content_preview_image_1_large, uri, 0);\n        } else {\n            ContentResolver resolver = getContentResolver();\n\n            List<Uri> uris = targetIntent.getParcelableArrayListExtra(Intent.EXTRA_STREAM, android.net.Uri.class);\n            List<Uri> imageUris = new ArrayList<>();\n            for (Uri uri : uris) {\n                if (validForContentPreview(uri) && isImageType(resolver.getType(uri))) {\n                    imageUris.add(uri);\n                }\n            }\n\n            if (imageUris.size() == 0) {\n                Log.i(TAG, \"Attempted to display image preview area with zero\"\n                        + \" available images detected in EXTRA_STREAM list\");\n                imagePreview.setVisibility(View.GONE);\n                return contentPreviewLayout;\n            }\n\n            imagePreview.findViewById(R.id.content_preview_image_1_large)\n                    .setTransitionName(ChooserActivity.FIRST_IMAGE_PREVIEW_TRANSITION_NAME);\n            mPreviewCoord.loadUriIntoView(R.id.content_preview_image_1_large, imageUris.get(0), 0);\n\n            if (imageUris.size() == 2) {\n                mPreviewCoord.loadUriIntoView(R.id.content_preview_image_2_large,\n                        imageUris.get(1), 0);\n            } else if (imageUris.size() > 2) {\n                mPreviewCoord.loadUriIntoView(R.id.content_preview_image_2_small,\n                        imageUris.get(1), 0);\n                mPreviewCoord.loadUriIntoView(R.id.content_preview_image_3_small,\n                        imageUris.get(2), imageUris.size() - 3);\n            }\n        }\n\n        return contentPreviewLayout;\n    }\n\n    private static class FileInfo {\n        public final String name;\n        public final boolean hasThumbnail;\n\n        FileInfo(String name, boolean hasThumbnail) {\n            this.name = name;\n            this.hasThumbnail = hasThumbnail;\n        }\n    }\n\n    /**\n     * Wrapping the ContentResolver call to expose for easier mocking,\n     * and to avoid mocking Android core classes.\n     */\n    @VisibleForTesting\n    public Cursor queryResolver(ContentResolver resolver, Uri uri) {\n        return resolver.query(uri, null, null, null, null);\n    }\n\n    private FileInfo extractFileInfo(Uri uri, ContentResolver resolver) {\n        String fileName = null;\n        boolean hasThumbnail = false;\n\n        try (Cursor cursor = queryResolver(resolver, uri)) {\n            if (cursor != null && cursor.getCount() > 0) {\n                int nameIndex = cursor.getColumnIndex(OpenableColumns.DISPLAY_NAME);\n                int titleIndex = cursor.getColumnIndex(Downloads.Impl.COLUMN_TITLE);\n                int flagsIndex = cursor.getColumnIndex(DocumentsContract.Document.COLUMN_FLAGS);\n\n                cursor.moveToFirst();\n                if (nameIndex != -1) {\n                    fileName = cursor.getString(nameIndex);\n                } else if (titleIndex != -1) {\n                    fileName = cursor.getString(titleIndex);\n                }\n\n                if (flagsIndex != -1) {\n                    hasThumbnail = (cursor.getInt(flagsIndex)\n                            & DocumentsContract.Document.FLAG_SUPPORTS_THUMBNAIL) != 0;\n                }\n            }\n        } catch (SecurityException | NullPointerException e) {\n            logContentPreviewWarning(uri);\n        }\n\n        if (TextUtils.isEmpty(fileName)) {\n            fileName = uri.getPath();\n            int index = fileName.lastIndexOf('/');\n            if (index != -1) {\n                fileName = fileName.substring(index + 1);\n            }\n        }\n\n        return new FileInfo(fileName, hasThumbnail);\n    }\n\n    private void logContentPreviewWarning(Uri uri) {\n        // The ContentResolver already logs the exception. Log something more informative.\n        Log.w(TAG, \"Could not load (\" + uri.toString() + \") thumbnail/name for preview. If \"\n                + \"desired, consider using Intent#createChooser to launch the ChooserActivity, \"\n                + \"and set your Intent's clipData and flags in accordance with that method's \"\n                + \"documentation\");\n    }\n\n    private ViewGroup displayFileContentPreview(Intent targetIntent, LayoutInflater layoutInflater,\n            ViewGroup parent) {\n\n        ViewGroup contentPreviewLayout = (ViewGroup) layoutInflater.inflate(\n                R.layout.chooser_grid_preview_file, parent, false);\n\n        final ViewGroup actionRow =\n                (ViewGroup) contentPreviewLayout.findViewById(R.id.chooser_action_row);\n        //TODO(b/120417119): addActionButton(actionRow, createCopyButton());\n        if (shouldNearbyShareBeIncludedAsActionButton()) {\n            addActionButton(actionRow, createNearbyButton(targetIntent));\n        }\n\n        String action = targetIntent.getAction();\n        if (Intent.ACTION_SEND.equals(action)) {\n            Uri uri = targetIntent.getParcelableExtra(Intent.EXTRA_STREAM, android.net.Uri.class);\n            if (!validForContentPreview(uri)) {\n                contentPreviewLayout.setVisibility(View.GONE);\n                return contentPreviewLayout;\n            }\n            loadFileUriIntoView(uri, contentPreviewLayout);\n        } else {\n            List<Uri> uris = targetIntent.getParcelableArrayListExtra(Intent.EXTRA_STREAM, android.net.Uri.class);\n            uris = uris.stream()\n                    .filter(ChooserActivity::validForContentPreview)\n                    .collect(Collectors.toList());\n            int uriCount = uris.size();\n\n            if (uriCount == 0) {\n                contentPreviewLayout.setVisibility(View.GONE);\n                Log.i(TAG,\n                        \"Appears to be no uris available in EXTRA_STREAM, removing \"\n                                + \"preview area\");\n                return contentPreviewLayout;\n            } else if (uriCount == 1) {\n                loadFileUriIntoView(uris.get(0), contentPreviewLayout);\n            } else {\n                FileInfo fileInfo = extractFileInfo(uris.get(0), getContentResolver());\n                int remUriCount = uriCount - 1;\n                Map<String, Object> arguments = new HashMap<>();\n                arguments.put(PLURALS_COUNT, remUriCount);\n                arguments.put(PLURALS_FILE_NAME, fileInfo.name);\n                String fileName = PluralsMessageFormatter.format(\n                        getResources(),\n                        arguments,\n                        R.string.file_count);\n\n                TextView fileNameView = contentPreviewLayout.findViewById(\n                        R.id.content_preview_filename);\n                fileNameView.setText(fileName);\n\n                View thumbnailView = contentPreviewLayout.findViewById(\n                        R.id.content_preview_file_thumbnail);\n                thumbnailView.setVisibility(View.GONE);\n\n                ImageView fileIconView = contentPreviewLayout.findViewById(\n                        R.id.content_preview_file_icon);\n                fileIconView.setVisibility(View.VISIBLE);\n                fileIconView.setImageResource(R.drawable.ic_file_copy);\n            }\n        }\n\n        return contentPreviewLayout;\n    }\n\n    private void loadFileUriIntoView(final Uri uri, final View parent) {\n        FileInfo fileInfo = extractFileInfo(uri, getContentResolver());\n\n        TextView fileNameView = parent.findViewById(R.id.content_preview_filename);\n        fileNameView.setText(fileInfo.name);\n\n        if (fileInfo.hasThumbnail) {\n            mPreviewCoord = new ContentPreviewCoordinator(parent, false);\n            mPreviewCoord.loadUriIntoView(R.id.content_preview_file_thumbnail, uri, 0);\n        } else {\n            View thumbnailView = parent.findViewById(R.id.content_preview_file_thumbnail);\n            thumbnailView.setVisibility(View.GONE);\n\n            ImageView fileIconView = parent.findViewById(R.id.content_preview_file_icon);\n            fileIconView.setVisibility(View.VISIBLE);\n            fileIconView.setImageResource(R.drawable.chooser_file_generic);\n        }\n    }\n\n    /**\n     * Indicate if the incoming content URI should be allowed.\n     *\n     * @param uri the uri to test\n     * @return true if the URI is allowed for content preview\n     */\n    private static boolean validForContentPreview(Uri uri) throws SecurityException {\n        if (uri == null) {\n            return false;\n        }\n        int userId = getUserIdFromUri(uri, UserHandle.USER_CURRENT);\n        if (userId != UserHandle.USER_CURRENT && userId != UserHandle.myUserId()) {\n            Log.e(TAG, \"dropped invalid content URI belonging to user \" + userId);\n            return false;\n        }\n        return true;\n    }\n\n    @VisibleForTesting\n    protected boolean isImageType(String mimeType) {\n        return mimeType != null && mimeType.startsWith(\"image/\");\n    }\n\n    @ContentPreviewType\n    private int findPreferredContentPreview(Uri uri, ContentResolver resolver) {\n        if (uri == null) {\n            return CONTENT_PREVIEW_TEXT;\n        }\n\n        String mimeType = resolver.getType(uri);\n        return isImageType(mimeType) ? CONTENT_PREVIEW_IMAGE : CONTENT_PREVIEW_FILE;\n    }\n\n    /**\n     * In {@link android.content.Intent#getType}, the app may specify a very general\n     * mime-type that broadly covers all data being shared, such as {@literal *}/*\n     * when sending an image and text. We therefore should inspect each item for the\n     * the preferred type, in order of IMAGE, FILE, TEXT.\n     */\n    @ContentPreviewType\n    private int findPreferredContentPreview(Intent targetIntent, ContentResolver resolver) {\n        String action = targetIntent.getAction();\n        if (Intent.ACTION_SEND.equals(action)) {\n            Uri uri = targetIntent.getParcelableExtra(Intent.EXTRA_STREAM, android.net.Uri.class);\n            return findPreferredContentPreview(uri, resolver);\n        } else if (Intent.ACTION_SEND_MULTIPLE.equals(action)) {\n            List<Uri> uris = targetIntent.getParcelableArrayListExtra(Intent.EXTRA_STREAM, android.net.Uri.class);\n            if (uris == null || uris.isEmpty()) {\n                return CONTENT_PREVIEW_TEXT;\n            }\n\n            for (Uri uri : uris) {\n                // Defaulting to file preview when there are mixed image/file types is\n                // preferable, as it shows the user the correct number of items being shared\n                if (findPreferredContentPreview(uri, resolver) == CONTENT_PREVIEW_FILE) {\n                    return CONTENT_PREVIEW_FILE;\n                }\n            }\n\n            return CONTENT_PREVIEW_IMAGE;\n        }\n\n        return CONTENT_PREVIEW_TEXT;\n    }\n\n    private int getNumSheetExpansions() {\n        return getPreferences(Context.MODE_PRIVATE).getInt(PREF_NUM_SHEET_EXPANSIONS, 0);\n    }\n\n    private void incrementNumSheetExpansions() {\n        getPreferences(Context.MODE_PRIVATE).edit().putInt(PREF_NUM_SHEET_EXPANSIONS,\n                getNumSheetExpansions() + 1).apply();\n    }\n\n    @Override\n    protected void onStop() {\n        super.onStop();\n        if (maybeCancelFinishAnimation()) {\n            finish();\n        }\n    }\n\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n\n        if (isFinishing()) {\n            mLatencyTracker.onActionCancel(ACTION_LOAD_SHARE_SHEET);\n        }\n\n        if (mRefinementResultReceiver != null) {\n            mRefinementResultReceiver.destroy();\n            mRefinementResultReceiver = null;\n        }\n        mChooserHandler.removeAllMessages();\n\n        if (mPreviewCoord != null) mPreviewCoord.cancelLoads();\n\n        mChooserMultiProfilePagerAdapter.getActiveListAdapter().destroyAppPredictor();\n        if (mChooserMultiProfilePagerAdapter.getInactiveListAdapter() != null) {\n            mChooserMultiProfilePagerAdapter.getInactiveListAdapter().destroyAppPredictor();\n        }\n        mPersonalAppPredictor = null;\n        mWorkAppPredictor = null;\n    }\n\n    @Override // ResolverListCommunicator\n    public Intent getReplacementIntent(ActivityInfo aInfo, Intent defIntent) {\n        Intent result = defIntent;\n        if (mReplacementExtras != null) {\n            final Bundle replExtras = mReplacementExtras.getBundle(aInfo.packageName);\n            if (replExtras != null) {\n                result = new Intent(defIntent);\n                result.putExtras(replExtras);\n            }\n        }\n        if (aInfo.name.equals(IntentForwarderActivity.FORWARD_INTENT_TO_PARENT)\n                || aInfo.name.equals(IntentForwarderActivity.FORWARD_INTENT_TO_MANAGED_PROFILE)) {\n            result = Intent.createChooser(result,\n                    getIntent().getCharSequenceExtra(Intent.EXTRA_TITLE));\n\n            // Don't auto-launch single intents if the intent is being forwarded. This is done\n            // because automatically launching a resolving application as a response to the user\n            // action of switching accounts is pretty unexpected.\n            result.putExtra(Intent.EXTRA_AUTO_LAUNCH_SINGLE_CHOICE, false);\n        }\n        return result;\n    }\n\n    @Override\n    public void onActivityStarted(TargetInfo cti) {\n        if (mChosenComponentSender != null) {\n            final ComponentName target = cti.getResolvedComponentName();\n            if (target != null) {\n                final Intent fillIn = new Intent().putExtra(Intent.EXTRA_CHOSEN_COMPONENT, target);\n                try {\n                    mChosenComponentSender.sendIntent(this, Activity.RESULT_OK, fillIn, null, null);\n                } catch (IntentSender.SendIntentException e) {\n                    Slog.e(TAG, \"Unable to launch supplied IntentSender to report \"\n                            + \"the chosen component: \" + e);\n                }\n            }\n        }\n    }\n\n    @Override\n    public void addUseDifferentAppLabelIfNecessary(ResolverListAdapter adapter) {\n        if (mCallerChooserTargets != null && mCallerChooserTargets.length > 0) {\n            mChooserMultiProfilePagerAdapter.getActiveListAdapter().addServiceResults(\n                    /* origTarget */ null,\n                    Lists.newArrayList(mCallerChooserTargets),\n                    TARGET_TYPE_DEFAULT,\n                    /* directShareShortcutInfoCache */ null);\n        }\n    }\n\n    @Override\n    public int getLayoutResource() {\n        return R.layout.chooser_grid;\n    }\n\n    @Override // ResolverListCommunicator\n    public boolean shouldGetActivityMetadata() {\n        return true;\n    }\n\n    @Override\n    public boolean shouldAutoLaunchSingleChoice(TargetInfo target) {\n        // Note that this is only safe because the Intent handled by the ChooserActivity is\n        // guaranteed to contain no extras unknown to the local ClassLoader. That is why this\n        // method can not be replaced in the ResolverActivity whole hog.\n        if (!super.shouldAutoLaunchSingleChoice(target)) {\n            return false;\n        }\n\n        return getIntent().getBooleanExtra(Intent.EXTRA_AUTO_LAUNCH_SINGLE_CHOICE, true);\n    }\n\n    private void showTargetDetails(TargetInfo targetInfo) {\n        if (targetInfo == null) return;\n\n        ArrayList<DisplayResolveInfo> targetList;\n        ChooserTargetActionsDialogFragment fragment = new ChooserTargetActionsDialogFragment();\n        Bundle bundle = new Bundle();\n\n        if (targetInfo instanceof SelectableTargetInfo) {\n            SelectableTargetInfo selectableTargetInfo = (SelectableTargetInfo) targetInfo;\n            if (selectableTargetInfo.getDisplayResolveInfo() == null\n                    || selectableTargetInfo.getChooserTarget() == null) {\n                Log.e(TAG, \"displayResolveInfo or chooserTarget in selectableTargetInfo are null\");\n                return;\n            }\n            targetList = new ArrayList<>();\n            targetList.add(selectableTargetInfo.getDisplayResolveInfo());\n            bundle.putString(ChooserTargetActionsDialogFragment.SHORTCUT_ID_KEY,\n                    selectableTargetInfo.getChooserTarget().getIntentExtras().getString(\n                            Intent.EXTRA_SHORTCUT_ID));\n            bundle.putBoolean(ChooserTargetActionsDialogFragment.IS_SHORTCUT_PINNED_KEY,\n                    selectableTargetInfo.isPinned());\n            bundle.putParcelable(ChooserTargetActionsDialogFragment.INTENT_FILTER_KEY,\n                    getTargetIntentFilter());\n            if (selectableTargetInfo.getDisplayLabel() != null) {\n                bundle.putString(ChooserTargetActionsDialogFragment.SHORTCUT_TITLE_KEY,\n                        selectableTargetInfo.getDisplayLabel().toString());\n            }\n        } else if (targetInfo instanceof MultiDisplayResolveInfo) {\n            // For multiple targets, include info on all targets\n            MultiDisplayResolveInfo mti = (MultiDisplayResolveInfo) targetInfo;\n            targetList = mti.getTargets();\n        } else {\n            targetList = new ArrayList<DisplayResolveInfo>();\n            targetList.add((DisplayResolveInfo) targetInfo);\n        }\n        // Adding userHandle from ResolveInfo allows the app icon in Dialog Box to be\n        // resolved correctly.\n        bundle.putParcelable(ChooserTargetActionsDialogFragment.USER_HANDLE_KEY,\n                getResolveInfoUserHandle(\n                        targetInfo.getResolveInfo(),\n                        mChooserMultiProfilePagerAdapter.getCurrentUserHandle()));\n        bundle.putParcelableArrayList(ChooserTargetActionsDialogFragment.TARGET_INFOS_KEY,\n                targetList);\n        fragment.setArguments(bundle);\n\n        fragment.show(getFragmentManager(), TARGET_DETAILS_FRAGMENT_TAG);\n    }\n\n    private void modifyTargetIntent(Intent in) {\n        if (isSendAction(in)) {\n            in.addFlags(Intent.FLAG_ACTIVITY_NEW_DOCUMENT |\n                    Intent.FLAG_ACTIVITY_MULTIPLE_TASK);\n        }\n    }\n\n    @Override\n    protected boolean onTargetSelected(TargetInfo target, boolean alwaysCheck) {\n        if (mRefinementIntentSender != null) {\n            final Intent fillIn = new Intent();\n            final List<Intent> sourceIntents = target.getAllSourceIntents();\n            if (!sourceIntents.isEmpty()) {\n                fillIn.putExtra(Intent.EXTRA_INTENT, sourceIntents.get(0));\n                if (sourceIntents.size() > 1) {\n                    final Intent[] alts = new Intent[sourceIntents.size() - 1];\n                    for (int i = 1, N = sourceIntents.size(); i < N; i++) {\n                        alts[i - 1] = sourceIntents.get(i);\n                    }\n                    fillIn.putExtra(Intent.EXTRA_ALTERNATE_INTENTS, alts);\n                }\n                if (mRefinementResultReceiver != null) {\n                    mRefinementResultReceiver.destroy();\n                }\n                mRefinementResultReceiver = new RefinementResultReceiver(this, target, null);\n                fillIn.putExtra(Intent.EXTRA_RESULT_RECEIVER,\n                        mRefinementResultReceiver);\n                try {\n                    mRefinementIntentSender.sendIntent(this, 0, fillIn, null, null);\n                    return false;\n                } catch (SendIntentException e) {\n                    Log.e(TAG, \"Refinement IntentSender failed to send\", e);\n                }\n            }\n        }\n        updateModelAndChooserCounts(target);\n        return super.onTargetSelected(target, alwaysCheck);\n    }\n\n    @Override\n    public void startSelected(int which, boolean always, boolean filtered) {\n        ChooserListAdapter currentListAdapter =\n                mChooserMultiProfilePagerAdapter.getActiveListAdapter();\n        TargetInfo targetInfo = currentListAdapter\n                .targetInfoForPosition(which, filtered);\n        if (targetInfo != null && targetInfo instanceof NotSelectableTargetInfo) {\n            return;\n        }\n\n        final long selectionCost = System.currentTimeMillis() - mChooserShownTime;\n\n        if (targetInfo instanceof MultiDisplayResolveInfo) {\n            MultiDisplayResolveInfo mti = (MultiDisplayResolveInfo) targetInfo;\n            if (!mti.hasSelected()) {\n                ChooserStackedAppDialogFragment f = new ChooserStackedAppDialogFragment();\n                Bundle b = new Bundle();\n                // Add userHandle based badge to the stackedAppDialogBox.\n                b.putParcelable(ChooserTargetActionsDialogFragment.USER_HANDLE_KEY,\n                        getResolveInfoUserHandle(\n                                targetInfo.getResolveInfo(),\n                                mChooserMultiProfilePagerAdapter.getCurrentUserHandle()));\n                b.putObject(ChooserStackedAppDialogFragment.MULTI_DRI_KEY,\n                        mti);\n                b.putInt(ChooserStackedAppDialogFragment.WHICH_KEY, which);\n                f.setArguments(b);\n\n                f.show(getFragmentManager(), TARGET_DETAILS_FRAGMENT_TAG);\n                return;\n            }\n        }\n\n        super.startSelected(which, always, filtered);\n\n        if (currentListAdapter.getCount() > 0) {\n            // Log the index of which type of target the user picked.\n            // Lower values mean the ranking was better.\n            int cat = 0;\n            int value = which;\n            int directTargetAlsoRanked = -1;\n            int numCallerProvided = 0;\n            HashedStringCache.HashResult directTargetHashed = null;\n            switch (currentListAdapter.getPositionTargetType(which)) {\n                case ChooserListAdapter.TARGET_SERVICE:\n                    cat = MetricsEvent.ACTION_ACTIVITY_CHOOSER_PICKED_SERVICE_TARGET;\n                    // Log the package name + target name to answer the question if most users\n                    // share to mostly the same person or to a bunch of different people.\n                    ChooserTarget target = currentListAdapter.getChooserTargetForValue(value);\n                    directTargetHashed = HashedStringCache.getInstance().hashString(\n                            this,\n                            TAG,\n                            target.getComponentName().getPackageName()\n                                    + target.getTitle().toString(),\n                            mMaxHashSaltDays);\n                    SelectableTargetInfo selectableTargetInfo = (SelectableTargetInfo) targetInfo;\n                    directTargetAlsoRanked = getRankedPosition(selectableTargetInfo);\n\n                    if (mCallerChooserTargets != null) {\n                        numCallerProvided = mCallerChooserTargets.length;\n                    }\n                    getChooserActivityLogger().logShareTargetSelected(\n                            SELECTION_TYPE_SERVICE,\n                            targetInfo.getResolveInfo().activityInfo.processName,\n                            value,\n                            selectableTargetInfo.isPinned()\n                    );\n                    break;\n                case ChooserListAdapter.TARGET_CALLER:\n                case ChooserListAdapter.TARGET_STANDARD:\n                    cat = MetricsEvent.ACTION_ACTIVITY_CHOOSER_PICKED_APP_TARGET;\n                    value -= currentListAdapter.getSurfacedTargetInfo().size();\n                    numCallerProvided = currentListAdapter.getCallerTargetCount();\n                    getChooserActivityLogger().logShareTargetSelected(\n                            SELECTION_TYPE_APP,\n                            targetInfo.getResolveInfo().activityInfo.processName,\n                            value,\n                            targetInfo.isPinned()\n                    );\n                    break;\n                case ChooserListAdapter.TARGET_STANDARD_AZ:\n                    // A-Z targets are unranked standard targets; we use -1 to mark that they\n                    // are from the alphabetical pool.\n                    value = -1;\n                    cat = MetricsEvent.ACTION_ACTIVITY_CHOOSER_PICKED_STANDARD_TARGET;\n                    getChooserActivityLogger().logShareTargetSelected(\n                            SELECTION_TYPE_STANDARD,\n                            targetInfo.getResolveInfo().activityInfo.processName,\n                            value,\n                            false\n                    );\n                    break;\n            }\n\n            if (cat != 0) {\n                LogMaker targetLogMaker = new LogMaker(cat).setSubtype(value);\n                if (directTargetHashed != null) {\n                    targetLogMaker.addTaggedData(\n                            MetricsEvent.FIELD_HASHED_TARGET_NAME, directTargetHashed.hashedString);\n                    targetLogMaker.addTaggedData(\n                                    MetricsEvent.FIELD_HASHED_TARGET_SALT_GEN,\n                                    directTargetHashed.saltGeneration);\n                    targetLogMaker.addTaggedData(MetricsEvent.FIELD_RANKED_POSITION,\n                                    directTargetAlsoRanked);\n                }\n                targetLogMaker.addTaggedData(MetricsEvent.FIELD_IS_CATEGORY_USED,\n                        numCallerProvided);\n                getMetricsLogger().write(targetLogMaker);\n            }\n\n            if (mIsSuccessfullySelected) {\n                if (DEBUG) {\n                    Log.d(TAG, \"User Selection Time Cost is \" + selectionCost);\n                    Log.d(TAG, \"position of selected app/service/caller is \" +\n                            Integer.toString(value));\n                }\n                MetricsLogger.histogram(null, \"user_selection_cost_for_smart_sharing\",\n                        (int) selectionCost);\n                MetricsLogger.histogram(null, \"app_position_for_smart_sharing\", value);\n            }\n        }\n    }\n\n    private int getRankedPosition(SelectableTargetInfo targetInfo) {\n        String targetPackageName =\n                targetInfo.getChooserTarget().getComponentName().getPackageName();\n        ChooserListAdapter currentListAdapter =\n                mChooserMultiProfilePagerAdapter.getActiveListAdapter();\n        int maxRankedResults = Math.min(currentListAdapter.mDisplayList.size(),\n                MAX_LOG_RANK_POSITION);\n\n        for (int i = 0; i < maxRankedResults; i++) {\n            if (currentListAdapter.mDisplayList.get(i)\n                    .getResolveInfo().activityInfo.packageName.equals(targetPackageName)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    @Override\n    protected boolean shouldAddFooterView() {\n        // To accommodate for window insets\n        return true;\n    }\n\n    @Override\n    protected void applyFooterView(int height) {\n        int count = mChooserMultiProfilePagerAdapter.getItemCount();\n\n        for (int i = 0; i < count; i++) {\n            mChooserMultiProfilePagerAdapter.getAdapterForIndex(i).setFooterHeight(height);\n        }\n    }\n\n    private IntentFilter getTargetIntentFilter() {\n        try {\n            final Intent intent = getTargetIntent();\n            String dataString = intent.getDataString();\n            if (intent.getType() == null) {\n                if (!TextUtils.isEmpty(dataString)) {\n                    return new IntentFilter(intent.getAction(), dataString);\n                }\n                Log.e(TAG, \"Failed to get target intent filter: intent data and type are null\");\n                return null;\n            }\n            IntentFilter intentFilter = new IntentFilter(intent.getAction(), intent.getType());\n            List<Uri> contentUris = new ArrayList<>();\n            if (Intent.ACTION_SEND.equals(intent.getAction())) {\n                Uri uri = (Uri) intent.getParcelableExtra(Intent.EXTRA_STREAM, android.net.Uri.class);\n                if (uri != null) {\n                    contentUris.add(uri);\n                }\n            } else {\n                List<Uri> uris = intent.getParcelableArrayListExtra(Intent.EXTRA_STREAM, android.net.Uri.class);\n                if (uris != null) {\n                    contentUris.addAll(uris);\n                }\n            }\n            for (Uri uri : contentUris) {\n                intentFilter.addDataScheme(uri.getScheme());\n                intentFilter.addDataAuthority(uri.getAuthority(), null);\n                intentFilter.addDataPath(uri.getPath(), PatternMatcher.PATTERN_LITERAL);\n            }\n            return intentFilter;\n        } catch (Exception e) {\n            Log.e(TAG, \"Failed to get target intent filter\", e);\n            return null;\n        }\n    }\n\n    @VisibleForTesting\n    protected void queryDirectShareTargets(\n                ChooserListAdapter adapter, boolean skipAppPredictionService) {\n        mQueriedSharingShortcutsTimeMs = System.currentTimeMillis();\n        UserHandle userHandle = adapter.getUserHandle();\n        if (!skipAppPredictionService) {\n            AppPredictor appPredictor = getAppPredictorForDirectShareIfEnabled(userHandle);\n            if (appPredictor != null) {\n                appPredictor.requestPredictionUpdate();\n                return;\n            }\n        }\n        // Default to just querying ShortcutManager if AppPredictor not present.\n        final IntentFilter filter = getTargetIntentFilter();\n        if (filter == null) {\n            return;\n        }\n\n        AsyncTask.execute(() -> {\n            Context selectedProfileContext = createContextAsUser(userHandle, 0 /* flags */);\n            ShortcutManager sm = (ShortcutManager) selectedProfileContext\n                    .getSystemService(Context.SHORTCUT_SERVICE);\n            List<ShortcutManager.ShareShortcutInfo> resultList = sm.getShareTargets(filter);\n            sendShareShortcutInfoList(resultList, adapter, null, userHandle);\n        });\n    }\n\n    /**\n     * Returns {@code false} if {@code userHandle} is the work profile and it's either\n     * in quiet mode or not running.\n     */\n    private boolean shouldQueryShortcutManager(UserHandle userHandle) {\n        if (!shouldShowTabs()) {\n            return true;\n        }\n        if (!getWorkProfileUserHandle().equals(userHandle)) {\n            return true;\n        }\n        if (!isUserRunning(userHandle)) {\n            return false;\n        }\n        if (!isUserUnlocked(userHandle)) {\n            return false;\n        }\n        if (isQuietModeEnabled(userHandle)) {\n            return false;\n        }\n        return true;\n    }\n\n    private void sendShareShortcutInfoList(\n                List<ShortcutManager.ShareShortcutInfo> resultList,\n                ChooserListAdapter chooserListAdapter,\n                @Nullable List<AppTarget> appTargets, UserHandle userHandle) {\n        if (appTargets != null && appTargets.size() != resultList.size()) {\n            throw new RuntimeException(\"resultList and appTargets must have the same size.\"\n                    + \" resultList.size()=\" + resultList.size()\n                    + \" appTargets.size()=\" + appTargets.size());\n        }\n        Context selectedProfileContext = createContextAsUser(userHandle, 0 /* flags */);\n        for (int i = resultList.size() - 1; i >= 0; i--) {\n            final String packageName = resultList.get(i).getTargetComponent().getPackageName();\n            if (!isPackageEnabled(selectedProfileContext, packageName)) {\n                resultList.remove(i);\n                if (appTargets != null) {\n                    appTargets.remove(i);\n                }\n            }\n        }\n\n        // If |appTargets| is not null, results are from AppPredictionService and already sorted.\n        final int shortcutType = (appTargets == null ? TARGET_TYPE_SHORTCUTS_FROM_SHORTCUT_MANAGER :\n                TARGET_TYPE_SHORTCUTS_FROM_PREDICTION_SERVICE);\n\n        // Match ShareShortcutInfos with DisplayResolveInfos to be able to use the old code path\n        // for direct share targets. After ShareSheet is refactored we should use the\n        // ShareShortcutInfos directly.\n        List<ServiceResultInfo> resultRecords = new ArrayList<>();\n        for (int i = 0; i < chooserListAdapter.getDisplayResolveInfoCount(); i++) {\n            DisplayResolveInfo displayResolveInfo = chooserListAdapter.getDisplayResolveInfo(i);\n            List<ShortcutManager.ShareShortcutInfo> matchingShortcuts =\n                    filterShortcutsByTargetComponentName(\n                            resultList, displayResolveInfo.getResolvedComponentName());\n            if (matchingShortcuts.isEmpty()) {\n                continue;\n            }\n            List<ChooserTarget> chooserTargets = convertToChooserTarget(\n                    matchingShortcuts, resultList, appTargets, shortcutType);\n\n            ServiceResultInfo resultRecord = new ServiceResultInfo(\n                    displayResolveInfo, chooserTargets, userHandle);\n            resultRecords.add(resultRecord);\n        }\n\n        sendShortcutManagerShareTargetResults(\n                shortcutType, resultRecords.toArray(new ServiceResultInfo[0]));\n    }\n\n    private List<ShortcutManager.ShareShortcutInfo> filterShortcutsByTargetComponentName(\n            List<ShortcutManager.ShareShortcutInfo> allShortcuts, ComponentName requiredTarget) {\n        List<ShortcutManager.ShareShortcutInfo> matchingShortcuts = new ArrayList<>();\n        for (ShortcutManager.ShareShortcutInfo shortcut : allShortcuts) {\n            if (requiredTarget.equals(shortcut.getTargetComponent())) {\n                matchingShortcuts.add(shortcut);\n            }\n        }\n        return matchingShortcuts;\n    }\n\n    @VisibleForTesting\n    protected void sendShortcutManagerShareTargetResults(\n            int shortcutType, ServiceResultInfo[] results) {\n        final Message msg = Message.obtain();\n        msg.what = ChooserHandler.SHORTCUT_MANAGER_ALL_SHARE_TARGET_RESULTS;\n        msg.obj = results;\n        msg.arg1 = shortcutType;\n        mChooserHandler.sendMessage(msg);\n    }\n\n    private boolean isPackageEnabled(Context context, String packageName) {\n        if (TextUtils.isEmpty(packageName)) {\n            return false;\n        }\n        ApplicationInfo appInfo;\n        try {\n            appInfo = context.getPackageManager().getApplicationInfo(packageName, 0);\n        } catch (NameNotFoundException e) {\n            return false;\n        }\n\n        if (appInfo != null && appInfo.enabled\n                && (appInfo.flags & ApplicationInfo.FLAG_SUSPENDED) == 0) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Converts a list of ShareShortcutInfos to ChooserTargets.\n     * @param matchingShortcuts List of shortcuts, all from the same package, that match the current\n     *                         share intent filter.\n     * @param allShortcuts List of all the shortcuts from all the packages on the device that are\n     *                    returned for the current sharing action.\n     * @param allAppTargets List of AppTargets. Null if the results are not from prediction service.\n     * @param shortcutType One of the values TARGET_TYPE_SHORTCUTS_FROM_SHORTCUT_MANAGER or\n     *                    TARGET_TYPE_SHORTCUTS_FROM_PREDICTION_SERVICE\n     * @return A list of ChooserTargets sorted by score in descending order.\n     */\n    @VisibleForTesting\n    @NonNull\n    public List<ChooserTarget> convertToChooserTarget(\n            @NonNull List<ShortcutManager.ShareShortcutInfo> matchingShortcuts,\n            @NonNull List<ShortcutManager.ShareShortcutInfo> allShortcuts,\n            @Nullable List<AppTarget> allAppTargets, @ShareTargetType int shortcutType) {\n        // A set of distinct scores for the matched shortcuts. We use index of a rank in the sorted\n        // list instead of the actual rank value when converting a rank to a score.\n        List<Integer> scoreList = new ArrayList<>();\n        if (shortcutType == TARGET_TYPE_SHORTCUTS_FROM_SHORTCUT_MANAGER) {\n            for (int i = 0; i < matchingShortcuts.size(); i++) {\n                int shortcutRank = matchingShortcuts.get(i).getShortcutInfo().getRank();\n                if (!scoreList.contains(shortcutRank)) {\n                    scoreList.add(shortcutRank);\n                }\n            }\n            Collections.sort(scoreList);\n        }\n\n        List<ChooserTarget> chooserTargetList = new ArrayList<>(matchingShortcuts.size());\n        for (int i = 0; i < matchingShortcuts.size(); i++) {\n            ShortcutInfo shortcutInfo = matchingShortcuts.get(i).getShortcutInfo();\n            int indexInAllShortcuts = allShortcuts.indexOf(matchingShortcuts.get(i));\n\n            float score;\n            if (shortcutType == TARGET_TYPE_SHORTCUTS_FROM_PREDICTION_SERVICE) {\n                // Incoming results are ordered. Create a score based on index in the original list.\n                score = Math.max(1.0f - (0.01f * indexInAllShortcuts), 0.0f);\n            } else {\n                // Create a score based on the rank of the shortcut.\n                int rankIndex = scoreList.indexOf(shortcutInfo.getRank());\n                score = Math.max(1.0f - (0.01f * rankIndex), 0.0f);\n            }\n\n            Bundle extras = new Bundle();\n            extras.putString(Intent.EXTRA_SHORTCUT_ID, shortcutInfo.getId());\n\n            ChooserTarget chooserTarget = new ChooserTarget(\n                    shortcutInfo.getLabel(),\n                    null, // Icon will be loaded later if this target is selected to be shown.\n                    score, matchingShortcuts.get(i).getTargetComponent().clone(), extras);\n\n            chooserTargetList.add(chooserTarget);\n            if (mDirectShareAppTargetCache != null && allAppTargets != null) {\n                mDirectShareAppTargetCache.put(chooserTarget,\n                        allAppTargets.get(indexInAllShortcuts));\n            }\n            if (mDirectShareShortcutInfoCache != null) {\n                mDirectShareShortcutInfoCache.put(chooserTarget, shortcutInfo);\n            }\n        }\n        // Sort ChooserTargets by score in descending order\n        Comparator<ChooserTarget> byScore =\n                (ChooserTarget a, ChooserTarget b) -> -Float.compare(a.getScore(), b.getScore());\n        Collections.sort(chooserTargetList, byScore);\n        return chooserTargetList;\n    }\n\n    private void logDirectShareTargetReceived(int logCategory) {\n        final int apiLatency = (int) (System.currentTimeMillis() - mQueriedSharingShortcutsTimeMs);\n        getMetricsLogger().write(new LogMaker(logCategory).setSubtype(apiLatency));\n    }\n\n    void updateModelAndChooserCounts(TargetInfo info) {\n        if (info != null && info instanceof MultiDisplayResolveInfo) {\n            info = ((MultiDisplayResolveInfo) info).getSelectedTarget();\n        }\n        if (info != null) {\n            sendClickToAppPredictor(info);\n            final ResolveInfo ri = info.getResolveInfo();\n            Intent targetIntent = getTargetIntent();\n            if (ri != null && ri.activityInfo != null && targetIntent != null) {\n                ChooserListAdapter currentListAdapter =\n                        mChooserMultiProfilePagerAdapter.getActiveListAdapter();\n                if (currentListAdapter != null) {\n                    sendImpressionToAppPredictor(info, currentListAdapter);\n                    currentListAdapter.updateModel(info);\n                    currentListAdapter.updateChooserCounts(\n                            ri.activityInfo.packageName,\n                            targetIntent.getAction(),\n                            ri.userHandle);\n                }\n                if (DEBUG) {\n                    Log.d(TAG, \"ResolveInfo Package is \" + ri.activityInfo.packageName);\n                    Log.d(TAG, \"Action to be updated is \" + targetIntent.getAction());\n                }\n            } else if (DEBUG) {\n                Log.d(TAG, \"Can not log Chooser Counts of null ResovleInfo\");\n            }\n        }\n        mIsSuccessfullySelected = true;\n    }\n\n    private void sendImpressionToAppPredictor(TargetInfo targetInfo, ChooserListAdapter adapter) {\n        AppPredictor directShareAppPredictor = getAppPredictorForDirectShareIfEnabled(\n                mChooserMultiProfilePagerAdapter.getCurrentUserHandle());\n        if (directShareAppPredictor == null) {\n            return;\n        }\n        // Send DS target impression info to AppPredictor, only when user chooses app share.\n        if (targetInfo instanceof ChooserTargetInfo) {\n            return;\n        }\n        List<ChooserTargetInfo> surfacedTargetInfo = adapter.getSurfacedTargetInfo();\n        List<AppTargetId> targetIds = new ArrayList<>();\n        for (ChooserTargetInfo chooserTargetInfo : surfacedTargetInfo) {\n            ChooserTarget chooserTarget = chooserTargetInfo.getChooserTarget();\n            ComponentName componentName = chooserTarget.getComponentName();\n            if (mDirectShareShortcutInfoCache.containsKey(chooserTarget)) {\n                String shortcutId = mDirectShareShortcutInfoCache.get(chooserTarget).getId();\n                targetIds.add(new AppTargetId(\n                        String.format(\"%s/%s/%s\", shortcutId, componentName.flattenToString(),\n                                SHORTCUT_TARGET)));\n            }\n        }\n        directShareAppPredictor.notifyLaunchLocationShown(LAUNCH_LOCATION_DIRECT_SHARE, targetIds);\n    }\n\n    private void sendClickToAppPredictor(TargetInfo targetInfo) {\n        AppPredictor directShareAppPredictor = getAppPredictorForDirectShareIfEnabled(\n                mChooserMultiProfilePagerAdapter.getCurrentUserHandle());\n        if (directShareAppPredictor == null) {\n            return;\n        }\n        if (!(targetInfo instanceof ChooserTargetInfo)) {\n            return;\n        }\n        ChooserTarget chooserTarget = ((ChooserTargetInfo) targetInfo).getChooserTarget();\n        AppTarget appTarget = null;\n        if (mDirectShareAppTargetCache != null) {\n            appTarget = mDirectShareAppTargetCache.get(chooserTarget);\n        }\n        // This is a direct share click that was provided by the APS\n        if (appTarget != null) {\n            directShareAppPredictor.notifyAppTargetEvent(\n                    new AppTargetEvent.Builder(appTarget, AppTargetEvent.ACTION_LAUNCH)\n                        .setLaunchLocation(LAUNCH_LOCATION_DIRECT_SHARE)\n                        .build());\n        }\n    }\n\n    @Nullable\n    private AppPredictor createAppPredictor(UserHandle userHandle) {\n        if (!mIsAppPredictorComponentAvailable) {\n            return null;\n        }\n\n        if (getPersonalProfileUserHandle().equals(userHandle)) {\n            if (mPersonalAppPredictor != null) {\n                return mPersonalAppPredictor;\n            }\n        } else {\n            if (mWorkAppPredictor != null) {\n                return mWorkAppPredictor;\n            }\n        }\n\n        // TODO(b/148230574): Currently AppPredictor fetches only the same-profile app targets.\n        // Make AppPredictor work cross-profile.\n        Context contextAsUser = createContextAsUser(userHandle, 0 /* flags */);\n        final IntentFilter filter = getTargetIntentFilter();\n        Bundle extras = new Bundle();\n        extras.putParcelable(APP_PREDICTION_INTENT_FILTER_KEY, filter);\n        populateTextContent(extras);\n        AppPredictionContext appPredictionContext = new AppPredictionContext.Builder(contextAsUser)\n            .setUiSurface(APP_PREDICTION_SHARE_UI_SURFACE)\n            .setPredictedTargetCount(APP_PREDICTION_SHARE_TARGET_QUERY_PACKAGE_LIMIT)\n            .setExtras(extras)\n            .build();\n        AppPredictionManager appPredictionManager =\n                contextAsUser\n                        .getSystemService(AppPredictionManager.class);\n        AppPredictor appPredictionSession = appPredictionManager.createAppPredictionSession(\n                appPredictionContext);\n        if (getPersonalProfileUserHandle().equals(userHandle)) {\n            mPersonalAppPredictor = appPredictionSession;\n        } else {\n            mWorkAppPredictor = appPredictionSession;\n        }\n        return appPredictionSession;\n    }\n\n    private void populateTextContent(Bundle extras) {\n        final Intent intent = getTargetIntent();\n        String sharedText = intent.getStringExtra(Intent.EXTRA_TEXT);\n        extras.putString(SHARED_TEXT_KEY, sharedText);\n    }\n\n    /**\n     * This will return an app predictor if it is enabled for direct share sorting\n     * and if one exists. Otherwise, it returns null.\n     * @param userHandle\n     */\n    @Nullable\n    private AppPredictor getAppPredictorForDirectShareIfEnabled(UserHandle userHandle) {\n        return ChooserFlags.USE_PREDICTION_MANAGER_FOR_DIRECT_TARGETS\n                && !ActivityManager.isLowRamDeviceStatic() ? createAppPredictor(userHandle) : null;\n    }\n\n    /**\n     * This will return an app predictor if it is enabled for share activity sorting\n     * and if one exists. Otherwise, it returns null.\n     */\n    @Nullable\n    private AppPredictor getAppPredictorForShareActivitiesIfEnabled(UserHandle userHandle) {\n        // We cannot use APS service when clone profile is present as APS service cannot sort\n        // cross profile targets as of now.\n        return USE_PREDICTION_MANAGER_FOR_SHARE_ACTIVITIES && getCloneProfileUserHandle() == null\n                ? createAppPredictor(userHandle) : null;\n    }\n\n    void onRefinementResult(TargetInfo selectedTarget, Intent matchingIntent) {\n        if (mRefinementResultReceiver != null) {\n            mRefinementResultReceiver.destroy();\n            mRefinementResultReceiver = null;\n        }\n        if (selectedTarget == null) {\n            Log.e(TAG, \"Refinement result intent did not match any known targets; canceling\");\n        } else if (!checkTargetSourceIntent(selectedTarget, matchingIntent)) {\n            Log.e(TAG, \"onRefinementResult: Selected target \" + selectedTarget\n                    + \" cannot match refined source intent \" + matchingIntent);\n        } else {\n            TargetInfo clonedTarget = selectedTarget.cloneFilledIn(matchingIntent, 0);\n            if (super.onTargetSelected(clonedTarget, false)) {\n                updateModelAndChooserCounts(clonedTarget);\n                finish();\n                return;\n            }\n        }\n        onRefinementCanceled();\n    }\n\n    void onRefinementCanceled() {\n        if (mRefinementResultReceiver != null) {\n            mRefinementResultReceiver.destroy();\n            mRefinementResultReceiver = null;\n        }\n        finish();\n    }\n\n    boolean checkTargetSourceIntent(TargetInfo target, Intent matchingIntent) {\n        final List<Intent> targetIntents = target.getAllSourceIntents();\n        for (int i = 0, N = targetIntents.size(); i < N; i++) {\n            final Intent targetIntent = targetIntents.get(i);\n            if (targetIntent.filterEquals(matchingIntent)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Sort intents alphabetically based on display label.\n     */\n    static class AzInfoComparator implements Comparator<DisplayResolveInfo> {\n        Comparator<DisplayResolveInfo> mComparator;\n        AzInfoComparator(Context context) {\n            Collator collator = Collator\n                    .getInstance(context.getResources().getConfiguration().locale);\n            // Adding two stage comparator, first stage compares using displayLabel, next stage\n            //  compares using resolveInfo.userHandle\n            mComparator = Comparator.comparing(DisplayResolveInfo::getDisplayLabel, collator)\n                    .thenComparingInt(displayResolveInfo ->\n                            getResolveInfoUserHandle(\n                                    displayResolveInfo.getResolveInfo(),\n                                    // TODO: User resolveInfo.userHandle, once its available.\n                                    UserHandle.SYSTEM).getIdentifier());\n        }\n\n        @Override\n        public int compare(\n                DisplayResolveInfo lhsp, DisplayResolveInfo rhsp) {\n            return mComparator.compare(lhsp, rhsp);\n        }\n    }\n\n    protected MetricsLogger getMetricsLogger() {\n        if (mMetricsLogger == null) {\n            mMetricsLogger = new MetricsLogger();\n        }\n        return mMetricsLogger;\n    }\n\n    protected ChooserActivityLogger getChooserActivityLogger() {\n        if (mChooserActivityLogger == null) {\n            mChooserActivityLogger = new ChooserActivityLoggerImpl();\n        }\n        return mChooserActivityLogger;\n    }\n\n    public class ChooserListController extends ResolverListController {\n        public ChooserListController(Context context,\n                PackageManager pm,\n                Intent targetIntent,\n                String referrerPackageName,\n                int launchedFromUid,\n                UserHandle userId,\n                AbstractResolverComparator resolverComparator,\n                UserHandle queryIntentsAsUser) {\n            super(context, pm, targetIntent, referrerPackageName, launchedFromUid, userId,\n                    resolverComparator, queryIntentsAsUser);\n        }\n\n        @Override\n        boolean isComponentFiltered(ComponentName name) {\n            if (mFilteredComponentNames == null) {\n                return false;\n            }\n            for (ComponentName filteredComponentName : mFilteredComponentNames) {\n                if (name.equals(filteredComponentName)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        @Override\n        public boolean isComponentPinned(ComponentName name) {\n            return mPinnedSharedPrefs.getBoolean(name.flattenToString(), false);\n        }\n\n        @Override\n        public boolean isFixedAtTop(ComponentName name) {\n            return name != null && name.equals(getNearbySharingComponent())\n                    && shouldNearbyShareBeFirstInRankedRow();\n        }\n    }\n\n    @VisibleForTesting\n    public ChooserGridAdapter createChooserGridAdapter(Context context,\n            List<Intent> payloadIntents, Intent[] initialIntents, List<ResolveInfo> rList,\n            boolean filterLastUsed, UserHandle userHandle) {\n        ChooserListAdapter chooserListAdapter = createChooserListAdapter(context, payloadIntents,\n                initialIntents, rList, filterLastUsed, userHandle);\n        AppPredictor.Callback appPredictorCallback = createAppPredictorCallback(chooserListAdapter);\n        AppPredictor appPredictor = setupAppPredictorForUser(userHandle, appPredictorCallback);\n        chooserListAdapter.setAppPredictor(appPredictor);\n        chooserListAdapter.setAppPredictorCallback(appPredictorCallback);\n        return new ChooserGridAdapter(chooserListAdapter);\n    }\n\n    @VisibleForTesting\n    public ChooserListAdapter createChooserListAdapter(Context context,\n            List<Intent> payloadIntents,\n            Intent[] initialIntents,\n            List<ResolveInfo> rList,\n            boolean filterLastUsed,\n            UserHandle userHandle) {\n        UserHandle initialIntentsUserSpace = isLaunchedAsCloneProfile()\n                && userHandle.equals(getPersonalProfileUserHandle())\n                ? getCloneProfileUserHandle() : userHandle;\n        return new ChooserListAdapter(context, payloadIntents, initialIntents, rList,\n                filterLastUsed, createListController(userHandle), this,\n                this, context.getPackageManager(),\n                getChooserActivityLogger(), initialIntentsUserSpace);\n    }\n\n    @VisibleForTesting\n    protected ResolverListController createListController(UserHandle userHandle) {\n        AppPredictor appPredictor = getAppPredictorForShareActivitiesIfEnabled(userHandle);\n        AbstractResolverComparator resolverComparator;\n        if (appPredictor != null) {\n            resolverComparator = new AppPredictionServiceResolverComparator(this, getTargetIntent(),\n                    getReferrerPackageName(), appPredictor, userHandle, getChooserActivityLogger());\n        } else {\n            resolverComparator =\n                    new ResolverRankerServiceResolverComparator(\n                            this,\n                            getTargetIntent(),\n                            getReferrerPackageName(),\n                            null,\n                            getChooserActivityLogger(),\n                            getResolverRankerServiceUserHandleList(userHandle));\n        }\n\n        UserHandle queryIntentsUser = getQueryIntentsUser(userHandle);\n        return new ChooserListController(\n                this,\n                mPm,\n                getTargetIntent(),\n                getReferrerPackageName(),\n                mLaunchedFromUid,\n                userHandle,\n                resolverComparator,\n                queryIntentsUser == null ? userHandle : queryIntentsUser);\n    }\n\n    @VisibleForTesting\n    protected Bitmap loadThumbnail(Uri uri, Size size) {\n        if (uri == null || size == null) {\n            return null;\n        }\n\n        try {\n            return getContentResolver().loadThumbnail(uri, size, null);\n        } catch (IOException | NullPointerException | SecurityException ex) {\n            logContentPreviewWarning(uri);\n        }\n        return null;\n    }\n\n    static final class PlaceHolderTargetInfo extends NotSelectableTargetInfo {\n        public Drawable getDisplayIcon(Context context) {\n            AnimatedVectorDrawable avd = (AnimatedVectorDrawable)\n                    context.getDrawable(R.drawable.chooser_direct_share_icon_placeholder);\n            avd.start(); // Start animation after generation\n            return avd;\n        }\n    }\n\n    protected static final class EmptyTargetInfo extends NotSelectableTargetInfo {\n        public EmptyTargetInfo() {}\n\n        public Drawable getDisplayIcon(Context context) {\n            return null;\n        }\n    }\n\n    private void handleScroll(View view, int x, int y, int oldx, int oldy) {\n        if (mChooserMultiProfilePagerAdapter.getCurrentRootAdapter() != null) {\n            mChooserMultiProfilePagerAdapter.getCurrentRootAdapter().handleScroll(view, y, oldy);\n        }\n    }\n\n    /*\n     * Need to dynamically adjust how many icons can fit per row before we add them,\n     * which also means setting the correct offset to initially show the content\n     * preview area + 2 rows of targets\n     */\n    private void handleLayoutChange(View v, int left, int top, int right, int bottom, int oldLeft,\n            int oldTop, int oldRight, int oldBottom) {\n        if (mChooserMultiProfilePagerAdapter == null) {\n            return;\n        }\n        RecyclerView recyclerView = mChooserMultiProfilePagerAdapter.getActiveAdapterView();\n        ChooserGridAdapter gridAdapter = mChooserMultiProfilePagerAdapter.getCurrentRootAdapter();\n        // Skip height calculation if recycler view was scrolled to prevent it inaccurately\n        // calculating the height, as the logic below does not account for the scrolled offset.\n        if (gridAdapter == null || recyclerView == null\n                || recyclerView.computeVerticalScrollOffset() != 0) {\n            return;\n        }\n\n        final int availableWidth = right - left - v.getPaddingLeft() - v.getPaddingRight();\n        boolean isLayoutUpdated = gridAdapter.consumeLayoutRequest()\n                || gridAdapter.calculateChooserTargetWidth(availableWidth)\n                || recyclerView.getAdapter() == null\n                || availableWidth != mCurrAvailableWidth;\n\n        boolean insetsChanged = !Objects.equals(mLastAppliedInsets, mSystemWindowInsets);\n\n        if (isLayoutUpdated\n                || insetsChanged\n                || mLastNumberOfChildren != recyclerView.getChildCount()) {\n            mCurrAvailableWidth = availableWidth;\n            if (isLayoutUpdated) {\n                // It is very important we call setAdapter from here. Otherwise in some cases\n                // the resolver list doesn't get populated, such as b/150922090, b/150918223\n                // and b/150936654\n                recyclerView.setAdapter(gridAdapter);\n                ((GridLayoutManager) recyclerView.getLayoutManager()).setSpanCount(\n                        mMaxTargetsPerRow);\n\n                updateTabPadding();\n            }\n\n            UserHandle currentUserHandle = mChooserMultiProfilePagerAdapter.getCurrentUserHandle();\n            int currentProfile = getProfileForUser(currentUserHandle);\n            int initialProfile = findSelectedProfile();\n            if (currentProfile != initialProfile) {\n                return;\n            }\n\n            if (mLastNumberOfChildren == recyclerView.getChildCount() && !insetsChanged) {\n                return;\n            }\n\n            getMainThreadHandler().post(() -> {\n                if (mResolverDrawerLayout == null || gridAdapter == null) {\n                    return;\n                }\n                int offset = calculateDrawerOffset(top, bottom, recyclerView, gridAdapter);\n                mResolverDrawerLayout.setCollapsibleHeightReserved(offset);\n                mEnterTransitionAnimationDelegate.markOffsetCalculated();\n                mLastAppliedInsets = mSystemWindowInsets;\n            });\n        }\n    }\n\n    private int calculateDrawerOffset(\n            int top, int bottom, RecyclerView recyclerView, ChooserGridAdapter gridAdapter) {\n\n        final int bottomInset = mSystemWindowInsets != null\n                ? mSystemWindowInsets.bottom : 0;\n        int offset = bottomInset;\n        int rowsToShow = gridAdapter.getSystemRowCount()\n                + gridAdapter.getProfileRowCount()\n                + gridAdapter.getServiceTargetRowCount()\n                + gridAdapter.getCallerAndRankedTargetRowCount();\n\n        // then this is most likely not a SEND_* action, so check\n        // the app target count\n        if (rowsToShow == 0) {\n            rowsToShow = gridAdapter.getRowCount();\n        }\n\n        // still zero? then use a default height and leave, which\n        // can happen when there are no targets to show\n        if (rowsToShow == 0 && !shouldShowStickyContentPreview()) {\n            offset += getResources().getDimensionPixelSize(\n                    R.dimen.chooser_max_collapsed_height);\n            return offset;\n        }\n\n        View stickyContentPreview = findViewById(R.id.content_preview_container);\n        if (shouldShowStickyContentPreview() && isStickyContentPreviewShowing()) {\n            offset += stickyContentPreview.getHeight();\n        }\n\n        if (shouldShowTabs()) {\n            offset += findViewById(R.id.tabs).getHeight();\n        }\n\n        if (recyclerView.getVisibility() == View.VISIBLE) {\n            int directShareHeight = 0;\n            rowsToShow = Math.min(4, rowsToShow);\n            boolean shouldShowExtraRow = shouldShowExtraRow(rowsToShow);\n            mLastNumberOfChildren = recyclerView.getChildCount();\n            for (int i = 0, childCount = recyclerView.getChildCount();\n                    i < childCount && rowsToShow > 0; i++) {\n                View child = recyclerView.getChildAt(i);\n                if (((GridLayoutManager.LayoutParams)\n                        child.getLayoutParams()).getSpanIndex() != 0) {\n                    continue;\n                }\n                int height = child.getHeight();\n                offset += height;\n                if (shouldShowExtraRow) {\n                    offset += height;\n                }\n\n                if (gridAdapter.getTargetType(\n                        recyclerView.getChildAdapterPosition(child))\n                        == ChooserListAdapter.TARGET_SERVICE) {\n                    directShareHeight = height;\n                }\n                rowsToShow--;\n            }\n\n            boolean isExpandable = getResources().getConfiguration().orientation\n                    == Configuration.ORIENTATION_PORTRAIT && !isInMultiWindowMode();\n            if (directShareHeight != 0 && shouldShowContentPreview()\n                    && isExpandable) {\n                // make sure to leave room for direct share 4->8 expansion\n                int requiredExpansionHeight =\n                        (int) (directShareHeight / DIRECT_SHARE_EXPANSION_RATE);\n                int topInset = mSystemWindowInsets != null ? mSystemWindowInsets.top : 0;\n                int minHeight = bottom - top - mResolverDrawerLayout.getAlwaysShowHeight()\n                        - requiredExpansionHeight - topInset - bottomInset;\n\n                offset = Math.min(offset, minHeight);\n            }\n        } else {\n            ViewGroup currentEmptyStateView = getActiveEmptyStateView();\n            if (currentEmptyStateView.getVisibility() == View.VISIBLE) {\n                offset += currentEmptyStateView.getHeight();\n            }\n        }\n\n        return Math.min(offset, bottom - top);\n    }\n\n    /**\n     * If we have a tabbed view and are showing 1 row in the current profile and an empty\n     * state screen in the other profile, to prevent cropping of the empty state screen we show\n     * a second row in the current profile.\n     */\n    private boolean shouldShowExtraRow(int rowsToShow) {\n        return shouldShowTabs()\n                && rowsToShow == 1\n                && mChooserMultiProfilePagerAdapter.shouldShowEmptyStateScreen(\n                        mChooserMultiProfilePagerAdapter.getInactiveListAdapter());\n    }\n\n    /**\n     * Returns {@link #PROFILE_WORK}, if the given user handle matches work user handle.\n     * Returns {@link #PROFILE_PERSONAL}, otherwise.\n     **/\n    private int getProfileForUser(UserHandle currentUserHandle) {\n        if (currentUserHandle.equals(getWorkProfileUserHandle())) {\n            return PROFILE_WORK;\n        }\n        // We return personal profile, as it is the default when there is no work profile, personal\n        // profile represents rootUser, clonedUser & secondaryUser, covering all use cases.\n        return PROFILE_PERSONAL;\n    }\n\n    private ViewGroup getActiveEmptyStateView() {\n        int currentPage = mChooserMultiProfilePagerAdapter.getCurrentPage();\n        return mChooserMultiProfilePagerAdapter.getItem(currentPage).getEmptyStateView();\n    }\n\n    static class BaseChooserTargetComparator implements Comparator<ChooserTarget> {\n        @Override\n        public int compare(ChooserTarget lhs, ChooserTarget rhs) {\n            // Descending order\n            return (int) Math.signum(rhs.getScore() - lhs.getScore());\n        }\n    }\n\n    @Override // ResolverListCommunicator\n    public void onHandlePackagesChanged(ResolverListAdapter listAdapter) {\n        mChooserMultiProfilePagerAdapter.getActiveListAdapter().notifyDataSetChanged();\n        super.onHandlePackagesChanged(listAdapter);\n    }\n\n    @Override // SelectableTargetInfoCommunicator\n    public ActivityInfoPresentationGetter makePresentationGetter(ActivityInfo info) {\n        return mChooserMultiProfilePagerAdapter.getActiveListAdapter().makePresentationGetter(info);\n    }\n\n    @Override // SelectableTargetInfoCommunicator\n    public Intent getReferrerFillInIntent() {\n        return mReferrerFillInIntent;\n    }\n\n    @Override // ChooserListCommunicator\n    public int getMaxRankedTargets() {\n        return mMaxTargetsPerRow;\n    }\n\n    @Override // ChooserListCommunicator\n    public void sendListViewUpdateMessage(UserHandle userHandle) {\n        Message msg = Message.obtain();\n        msg.what = ChooserHandler.LIST_VIEW_UPDATE_MESSAGE;\n        msg.obj = userHandle;\n        mChooserHandler.sendMessageDelayed(msg, mListViewUpdateDelayMs);\n    }\n\n    @Override\n    public void onListRebuilt(ResolverListAdapter listAdapter, boolean rebuildComplete) {\n        setupScrollListener();\n        maybeSetupGlobalLayoutListener();\n\n        ChooserListAdapter chooserListAdapter = (ChooserListAdapter) listAdapter;\n        if (chooserListAdapter.getUserHandle()\n                .equals(mChooserMultiProfilePagerAdapter.getCurrentUserHandle())) {\n            mChooserMultiProfilePagerAdapter.getActiveAdapterView()\n                    .setAdapter(mChooserMultiProfilePagerAdapter.getCurrentRootAdapter());\n            mChooserMultiProfilePagerAdapter\n                    .setupListAdapter(mChooserMultiProfilePagerAdapter.getCurrentPage());\n        }\n\n        if (chooserListAdapter.mDisplayList == null\n                || chooserListAdapter.mDisplayList.isEmpty()) {\n            chooserListAdapter.notifyDataSetChanged();\n        } else {\n            chooserListAdapter.updateAlphabeticalList();\n        }\n\n        if (rebuildComplete) {\n            getChooserActivityLogger().logSharesheetAppLoadComplete();\n            maybeQueryAdditionalPostProcessingTargets(chooserListAdapter);\n            mLatencyTracker.onActionEnd(ACTION_LOAD_SHARE_SHEET);\n        }\n    }\n\n    private void maybeQueryAdditionalPostProcessingTargets(ChooserListAdapter chooserListAdapter) {\n        // don't support direct share on low ram devices\n        if (ActivityManager.isLowRamDeviceStatic()) {\n            return;\n        }\n\n        // no need to query direct share for work profile when its locked or disabled\n        if (!shouldQueryShortcutManager(chooserListAdapter.getUserHandle())) {\n            return;\n        }\n\n        if (ChooserFlags.USE_PREDICTION_MANAGER_FOR_DIRECT_TARGETS) {\n            if (DEBUG) {\n                Log.d(TAG, \"querying direct share targets from ShortcutManager\");\n            }\n\n            queryDirectShareTargets(chooserListAdapter, false);\n        }\n    }\n\n    @VisibleForTesting\n    protected boolean isUserRunning(UserHandle userHandle) {\n        UserManager userManager = getSystemService(UserManager.class);\n        return userManager.isUserRunning(userHandle);\n    }\n\n    @VisibleForTesting\n    protected boolean isUserUnlocked(UserHandle userHandle) {\n        UserManager userManager = getSystemService(UserManager.class);\n        return userManager.isUserUnlocked(userHandle);\n    }\n\n    @VisibleForTesting\n    protected boolean isQuietModeEnabled(UserHandle userHandle) {\n        UserManager userManager = getSystemService(UserManager.class);\n        return userManager.isQuietModeEnabled(userHandle);\n    }\n\n    private void setupScrollListener() {\n        if (mResolverDrawerLayout == null) {\n            return;\n        }\n        int elevatedViewResId = shouldShowTabs() ? R.id.tabs : R.id.chooser_header;\n        final View elevatedView = mResolverDrawerLayout.findViewById(elevatedViewResId);\n        final float defaultElevation = elevatedView.getElevation();\n        final float chooserHeaderScrollElevation =\n                getResources().getDimensionPixelSize(R.dimen.chooser_header_scroll_elevation);\n        mChooserMultiProfilePagerAdapter.getActiveAdapterView().addOnScrollListener(\n                new RecyclerView.OnScrollListener() {\n                    public void onScrollStateChanged(RecyclerView view, int scrollState) {\n                        if (scrollState == RecyclerView.SCROLL_STATE_IDLE) {\n                            if (mScrollStatus == SCROLL_STATUS_SCROLLING_VERTICAL) {\n                                mScrollStatus = SCROLL_STATUS_IDLE;\n                                setHorizontalScrollingEnabled(true);\n                            }\n                        } else if (scrollState == RecyclerView.SCROLL_STATE_DRAGGING) {\n                            if (mScrollStatus == SCROLL_STATUS_IDLE) {\n                                mScrollStatus = SCROLL_STATUS_SCROLLING_VERTICAL;\n                                setHorizontalScrollingEnabled(false);\n                            }\n                        }\n                    }\n\n                    public void onScrolled(RecyclerView view, int dx, int dy) {\n                        if (view.getChildCount() > 0) {\n                            View child = view.getLayoutManager().findViewByPosition(0);\n                            if (child == null || child.getTop() < 0) {\n                                elevatedView.setElevation(chooserHeaderScrollElevation);\n                                return;\n                            }\n                        }\n\n                        elevatedView.setElevation(defaultElevation);\n                    }\n                });\n    }\n\n    private void maybeSetupGlobalLayoutListener() {\n        if (shouldShowTabs()) {\n            return;\n        }\n        final View recyclerView = mChooserMultiProfilePagerAdapter.getActiveAdapterView();\n        recyclerView.getViewTreeObserver()\n                .addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {\n                    @Override\n                    public void onGlobalLayout() {\n                        // Fixes an issue were the accessibility border disappears on list creation.\n                        recyclerView.getViewTreeObserver().removeOnGlobalLayoutListener(this);\n                        final TextView titleView = findViewById(R.id.title);\n                        if (titleView != null) {\n                            titleView.setFocusable(true);\n                            titleView.setFocusableInTouchMode(true);\n                            titleView.requestFocus();\n                            titleView.requestAccessibilityFocus();\n                        }\n                    }\n                });\n    }\n\n    @Override // ChooserListCommunicator\n    public boolean isSendAction(Intent targetIntent) {\n        if (targetIntent == null) {\n            return false;\n        }\n\n        String action = targetIntent.getAction();\n        if (action == null) {\n            return false;\n        }\n\n        if (Intent.ACTION_SEND.equals(action) || Intent.ACTION_SEND_MULTIPLE.equals(action)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * The sticky content preview is shown only when we have a tabbed view. It's shown above\n     * the tabs so it is not part of the scrollable list. If we are not in tabbed view,\n     * we instead show the content preview as a regular list item.\n     */\n    private boolean shouldShowStickyContentPreview() {\n        return shouldShowStickyContentPreviewNoOrientationCheck()\n                && !getResources().getBoolean(R.bool.resolver_landscape_phone);\n    }\n\n    private boolean shouldShowStickyContentPreviewNoOrientationCheck() {\n        return shouldShowTabs()\n                && (mMultiProfilePagerAdapter.getListAdapterForUserHandle(\n                        UserHandle.of(UserHandle.myUserId())).getCount() > 0\n                    || shouldShowContentPreviewWhenEmpty())\n                && shouldShowContentPreview();\n    }\n\n    /**\n     * This method could be used to override the default behavior when we hide the preview area\n     * when the current tab doesn't have any items.\n     *\n     * @return true if we want to show the content preview area even if the tab for the current\n     *         user is empty\n     */\n    protected boolean shouldShowContentPreviewWhenEmpty() {\n        return false;\n    }\n\n    /**\n     * @return true if we want to show the content preview area\n     */\n    protected boolean shouldShowContentPreview() {\n        return isSendAction(getTargetIntent());\n    }\n\n    private void updateStickyContentPreview() {\n        if (shouldShowStickyContentPreviewNoOrientationCheck()) {\n            // The sticky content preview is only shown when we show the work and personal tabs.\n            // We don't show it in landscape as otherwise there is no room for scrolling.\n            // If the sticky content preview will be shown at some point with orientation change,\n            // then always preload it to avoid subsequent resizing of the share sheet.\n            ViewGroup contentPreviewContainer = findViewById(R.id.content_preview_container);\n            if (contentPreviewContainer.getChildCount() == 0) {\n                ViewGroup contentPreviewView = createContentPreviewView(contentPreviewContainer);\n                contentPreviewContainer.addView(contentPreviewView);\n            }\n        }\n        if (shouldShowStickyContentPreview()) {\n            showStickyContentPreview();\n        } else {\n            hideStickyContentPreview();\n        }\n    }\n\n    private void showStickyContentPreview() {\n        if (isStickyContentPreviewShowing()) {\n            return;\n        }\n        ViewGroup contentPreviewContainer = findViewById(R.id.content_preview_container);\n        contentPreviewContainer.setVisibility(View.VISIBLE);\n    }\n\n    private boolean isStickyContentPreviewShowing() {\n        ViewGroup contentPreviewContainer = findViewById(R.id.content_preview_container);\n        return contentPreviewContainer.getVisibility() == View.VISIBLE;\n    }\n\n    private void hideStickyContentPreview() {\n        if (!isStickyContentPreviewShowing()) {\n            return;\n        }\n        ViewGroup contentPreviewContainer = findViewById(R.id.content_preview_container);\n        contentPreviewContainer.setVisibility(View.GONE);\n    }\n\n    private void logActionShareWithPreview() {\n        Intent targetIntent = getTargetIntent();\n        int previewType = findPreferredContentPreview(targetIntent, getContentResolver());\n        getMetricsLogger().write(new LogMaker(MetricsEvent.ACTION_SHARE_WITH_PREVIEW)\n                .setSubtype(previewType));\n    }\n\n    private void startFinishAnimation() {\n        View rootView = findRootView();\n        if (rootView != null) {\n            rootView.startAnimation(new FinishAnimation(this, rootView));\n        }\n    }\n\n    private boolean maybeCancelFinishAnimation() {\n        View rootView = findRootView();\n        Animation animation = rootView == null ? null : rootView.getAnimation();\n        if (animation instanceof FinishAnimation) {\n            boolean hasEnded = animation.hasEnded();\n            animation.cancel();\n            rootView.clearAnimation();\n            return !hasEnded;\n        }\n        return false;\n    }\n\n    private View findRootView() {\n        if (mContentView == null) {\n            mContentView = findViewById(android.R.id.content);\n        }\n        return mContentView;\n    }\n\n    abstract static class ViewHolderBase extends RecyclerView.ViewHolder {\n        private int mViewType;\n\n        ViewHolderBase(View itemView, int viewType) {\n            super(itemView);\n            this.mViewType = viewType;\n        }\n\n        int getViewType() {\n            return mViewType;\n        }\n    }\n\n    /**\n     * Used to bind types of individual item including\n     * {@link ChooserGridAdapter#VIEW_TYPE_NORMAL},\n     * {@link ChooserGridAdapter#VIEW_TYPE_CONTENT_PREVIEW},\n     * {@link ChooserGridAdapter#VIEW_TYPE_PROFILE},\n     * and {@link ChooserGridAdapter#VIEW_TYPE_AZ_LABEL}.\n     */\n    final class ItemViewHolder extends ViewHolderBase {\n        ResolverListAdapter.ViewHolder mWrappedViewHolder;\n        int mListPosition = ChooserListAdapter.NO_POSITION;\n\n        ItemViewHolder(View itemView, boolean isClickable, int viewType) {\n            super(itemView, viewType);\n            mWrappedViewHolder = new ResolverListAdapter.ViewHolder(itemView);\n            if (isClickable) {\n                itemView.setOnClickListener(v -> startSelected(mListPosition,\n                        false/* always */, true/* filterd */));\n\n                itemView.setOnLongClickListener(v -> {\n                    final TargetInfo ti = mChooserMultiProfilePagerAdapter.getActiveListAdapter()\n                            .targetInfoForPosition(mListPosition, /* filtered */ true);\n\n                    // This should always be the case for ItemViewHolder, check for validity\n                    if (ti instanceof DisplayResolveInfo && shouldShowTargetDetails(ti)) {\n                        showTargetDetails((DisplayResolveInfo) ti);\n                    }\n                    return true;\n                });\n            }\n        }\n    }\n\n    private boolean shouldShowTargetDetails(TargetInfo ti) {\n        ComponentName nearbyShare = getNearbySharingComponent();\n        //  Suppress target details for nearby share to hide pin/unpin action\n        boolean isNearbyShare = nearbyShare != null && nearbyShare.equals(\n                ti.getResolvedComponentName()) && shouldNearbyShareBeFirstInRankedRow();\n        return ti instanceof SelectableTargetInfo\n                || (ti instanceof DisplayResolveInfo && !isNearbyShare);\n    }\n\n    /**\n     * Add a footer to the list, to support scrolling behavior below the navbar.\n     */\n    static final class FooterViewHolder extends ViewHolderBase {\n        FooterViewHolder(View itemView, int viewType) {\n            super(itemView, viewType);\n        }\n    }\n\n    /**\n     * Intentionally override the {@link ResolverActivity} implementation as we only need that\n     * implementation for the intent resolver case.\n     */\n    @Override\n    public void onButtonClick(View v) {}\n\n    /**\n     * Intentionally override the {@link ResolverActivity} implementation as we only need that\n     * implementation for the intent resolver case.\n     */\n    @Override\n    protected void resetButtonBar() {}\n\n    @Override\n    protected String getMetricsCategory() {\n        return METRICS_CATEGORY_CHOOSER;\n    }\n\n    @Override\n    protected void onProfileTabSelected() {\n        ChooserGridAdapter currentRootAdapter =\n                mChooserMultiProfilePagerAdapter.getCurrentRootAdapter();\n        currentRootAdapter.updateDirectShareExpansion();\n        // This fixes an edge case where after performing a variety of gestures, vertical scrolling\n        // ends up disabled. That's because at some point the old tab's vertical scrolling is\n        // disabled and the new tab's is enabled. For context, see b/159997845\n        setVerticalScrollEnabled(true);\n        if (mResolverDrawerLayout != null) {\n            mResolverDrawerLayout.scrollNestedScrollableChildBackToTop();\n        }\n    }\n\n    @Override\n    protected WindowInsets onApplyWindowInsets(View v, WindowInsets insets) {\n        if (shouldShowTabs()) {\n            mChooserMultiProfilePagerAdapter\n                    .setEmptyStateBottomOffset(insets.getSystemWindowInsetBottom());\n            mChooserMultiProfilePagerAdapter.setupContainerPadding(\n                    getActiveEmptyStateView().findViewById(R.id.resolver_empty_state_container));\n        }\n\n        WindowInsets result = super.onApplyWindowInsets(v, insets);\n        if (mResolverDrawerLayout != null) {\n            mResolverDrawerLayout.requestLayout();\n        }\n        return result;\n    }\n\n    private void setHorizontalScrollingEnabled(boolean enabled) {\n        ResolverViewPager viewPager = findViewById(R.id.profile_pager);\n        viewPager.setSwipingEnabled(enabled);\n    }\n\n    private void setVerticalScrollEnabled(boolean enabled) {\n        ChooserGridLayoutManager layoutManager =\n                (ChooserGridLayoutManager) mChooserMultiProfilePagerAdapter.getActiveAdapterView()\n                        .getLayoutManager();\n        layoutManager.setVerticalScrollEnabled(enabled);\n    }\n\n    @Override\n    void onHorizontalSwipeStateChanged(int state) {\n        if (state == ViewPager.SCROLL_STATE_DRAGGING) {\n            if (mScrollStatus == SCROLL_STATUS_IDLE) {\n                mScrollStatus = SCROLL_STATUS_SCROLLING_HORIZONTAL;\n                setVerticalScrollEnabled(false);\n            }\n        } else if (state == ViewPager.SCROLL_STATE_IDLE) {\n            if (mScrollStatus == SCROLL_STATUS_SCROLLING_HORIZONTAL) {\n                mScrollStatus = SCROLL_STATUS_IDLE;\n                setVerticalScrollEnabled(true);\n            }\n        }\n    }\n\n    /**\n     * Adapter for all types of items and targets in ShareSheet.\n     * Note that ranked sections like Direct Share - while appearing grid-like - are handled on the\n     * row level by this adapter but not on the item level. Individual targets within the row are\n     * handled by {@link ChooserListAdapter}\n     */\n    @VisibleForTesting\n    public final class ChooserGridAdapter extends RecyclerView.Adapter<RecyclerView.ViewHolder> {\n        private ChooserListAdapter mChooserListAdapter;\n        private final LayoutInflater mLayoutInflater;\n\n        private DirectShareViewHolder mDirectShareViewHolder;\n        private int mChooserTargetWidth = 0;\n        private boolean mShowAzLabelIfPoss;\n        private boolean mLayoutRequested = false;\n\n        private int mFooterHeight = 0;\n\n        private static final int VIEW_TYPE_DIRECT_SHARE = 0;\n        private static final int VIEW_TYPE_NORMAL = 1;\n        private static final int VIEW_TYPE_CONTENT_PREVIEW = 2;\n        private static final int VIEW_TYPE_PROFILE = 3;\n        private static final int VIEW_TYPE_AZ_LABEL = 4;\n        private static final int VIEW_TYPE_CALLER_AND_RANK = 5;\n        private static final int VIEW_TYPE_FOOTER = 6;\n\n        private static final int NUM_EXPANSIONS_TO_HIDE_AZ_LABEL = 20;\n\n        ChooserGridAdapter(ChooserListAdapter wrappedAdapter) {\n            super();\n            mChooserListAdapter = wrappedAdapter;\n            mLayoutInflater = LayoutInflater.from(ChooserActivity.this);\n\n            mShowAzLabelIfPoss = getNumSheetExpansions() < NUM_EXPANSIONS_TO_HIDE_AZ_LABEL;\n\n            wrappedAdapter.registerDataSetObserver(new DataSetObserver() {\n                @Override\n                public void onChanged() {\n                    super.onChanged();\n                    notifyDataSetChanged();\n                }\n\n                @Override\n                public void onInvalidated() {\n                    super.onInvalidated();\n                    notifyDataSetChanged();\n                }\n            });\n        }\n\n        public void setFooterHeight(int height) {\n            mFooterHeight = height;\n        }\n\n        /**\n         * Calculate the chooser target width to maximize space per item\n         *\n         * @param width The new row width to use for recalculation\n         * @return true if the view width has changed\n         */\n        public boolean calculateChooserTargetWidth(int width) {\n            if (width == 0) {\n                return false;\n            }\n\n            // Limit width to the maximum width of the chooser activity\n            int maxWidth = getResources().getDimensionPixelSize(R.dimen.chooser_width);\n            width = Math.min(maxWidth, width);\n\n            int newWidth = width / mMaxTargetsPerRow;\n            if (newWidth != mChooserTargetWidth) {\n                mChooserTargetWidth = newWidth;\n                return true;\n            }\n\n            return false;\n        }\n\n        /**\n         * Hides the list item content preview.\n         * <p>Not to be confused with the sticky content preview which is above the\n         * personal and work tabs.\n         */\n        public void hideContentPreview() {\n            mLayoutRequested = true;\n            notifyDataSetChanged();\n        }\n\n        public boolean consumeLayoutRequest() {\n            boolean oldValue = mLayoutRequested;\n            mLayoutRequested = false;\n            return oldValue;\n        }\n\n        public int getRowCount() {\n            return (int) (\n                    getSystemRowCount()\n                            + getProfileRowCount()\n                            + getServiceTargetRowCount()\n                            + getCallerAndRankedTargetRowCount()\n                            + getAzLabelRowCount()\n                            + Math.ceil(\n                            (float) mChooserListAdapter.getAlphaTargetCount()\n                                    / mMaxTargetsPerRow)\n            );\n        }\n\n        /**\n         * Whether the \"system\" row of targets is displayed.\n         * This area includes the content preview (if present) and action row.\n         */\n        public int getSystemRowCount() {\n            // For the tabbed case we show the sticky content preview above the tabs,\n            // please refer to shouldShowStickyContentPreview\n            if (shouldShowTabs()) {\n                return 0;\n            }\n\n            if (!shouldShowContentPreview()) {\n                return 0;\n            }\n\n            if (mChooserListAdapter == null || mChooserListAdapter.getCount() == 0) {\n                return 0;\n            }\n\n            return 1;\n        }\n\n        public int getProfileRowCount() {\n            if (shouldShowTabs()) {\n                return 0;\n            }\n            return mChooserListAdapter.getOtherProfile() == null ? 0 : 1;\n        }\n\n        public int getFooterRowCount() {\n            return 1;\n        }\n\n        public int getCallerAndRankedTargetRowCount() {\n            return (int) Math.ceil(\n                    ((float) mChooserListAdapter.getCallerTargetCount()\n                            + mChooserListAdapter.getRankedTargetCount()) / mMaxTargetsPerRow);\n        }\n\n        // There can be at most one row in the listview, that is internally\n        // a ViewGroup with 2 rows\n        public int getServiceTargetRowCount() {\n            if (shouldShowContentPreview()\n                    && !ActivityManager.isLowRamDeviceStatic()) {\n                return 1;\n            }\n            return 0;\n        }\n\n        public int getAzLabelRowCount() {\n            // Only show a label if the a-z list is showing\n            return (mShowAzLabelIfPoss && mChooserListAdapter.getAlphaTargetCount() > 0) ? 1 : 0;\n        }\n\n        @Override\n        public int getItemCount() {\n            return (int) (\n                    getSystemRowCount()\n                            + getProfileRowCount()\n                            + getServiceTargetRowCount()\n                            + getCallerAndRankedTargetRowCount()\n                            + getAzLabelRowCount()\n                            + mChooserListAdapter.getAlphaTargetCount()\n                            + getFooterRowCount()\n            );\n        }\n\n        @Override\n        public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n            switch (viewType) {\n                case VIEW_TYPE_CONTENT_PREVIEW:\n                    return new ItemViewHolder(createContentPreviewView(parent), false, viewType);\n                case VIEW_TYPE_PROFILE:\n                    return new ItemViewHolder(createProfileView(parent), false, viewType);\n                case VIEW_TYPE_AZ_LABEL:\n                    return new ItemViewHolder(createAzLabelView(parent), false, viewType);\n                case VIEW_TYPE_NORMAL:\n                    return new ItemViewHolder(\n                            mChooserListAdapter.createView(parent), true, viewType);\n                case VIEW_TYPE_DIRECT_SHARE:\n                case VIEW_TYPE_CALLER_AND_RANK:\n                    return createItemGroupViewHolder(viewType, parent);\n                case VIEW_TYPE_FOOTER:\n                    Space sp = new Space(parent.getContext());\n                    sp.setLayoutParams(new RecyclerView.LayoutParams(\n                            LayoutParams.MATCH_PARENT, mFooterHeight));\n                    return new FooterViewHolder(sp, viewType);\n                default:\n                    // Since we catch all possible viewTypes above, no chance this is being called.\n                    return null;\n            }\n        }\n\n        @Override\n        public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) {\n            int viewType = ((ViewHolderBase) holder).getViewType();\n            switch (viewType) {\n                case VIEW_TYPE_DIRECT_SHARE:\n                case VIEW_TYPE_CALLER_AND_RANK:\n                    bindItemGroupViewHolder(position, (ItemGroupViewHolder) holder);\n                    break;\n                case VIEW_TYPE_NORMAL:\n                    bindItemViewHolder(position, (ItemViewHolder) holder);\n                    break;\n                default:\n            }\n        }\n\n        @Override\n        public int getItemViewType(int position) {\n            int count;\n\n            int countSum = (count = getSystemRowCount());\n            if (count > 0 && position < countSum) return VIEW_TYPE_CONTENT_PREVIEW;\n\n            countSum += (count = getProfileRowCount());\n            if (count > 0 && position < countSum) return VIEW_TYPE_PROFILE;\n\n            countSum += (count = getServiceTargetRowCount());\n            if (count > 0 && position < countSum) return VIEW_TYPE_DIRECT_SHARE;\n\n            countSum += (count = getCallerAndRankedTargetRowCount());\n            if (count > 0 && position < countSum) return VIEW_TYPE_CALLER_AND_RANK;\n\n            countSum += (count = getAzLabelRowCount());\n            if (count > 0 && position < countSum) return VIEW_TYPE_AZ_LABEL;\n\n            if (position == getItemCount() - 1) return VIEW_TYPE_FOOTER;\n\n            return VIEW_TYPE_NORMAL;\n        }\n\n        public int getTargetType(int position) {\n            return mChooserListAdapter.getPositionTargetType(getListPosition(position));\n        }\n\n        private View createProfileView(ViewGroup parent) {\n            View profileRow = mLayoutInflater.inflate(R.layout.chooser_profile_row, parent, false);\n            mProfileView = profileRow.findViewById(R.id.profile_button);\n            mProfileView.setOnClickListener(ChooserActivity.this::onProfileClick);\n            updateProfileViewButton();\n            return profileRow;\n        }\n\n        private View createAzLabelView(ViewGroup parent) {\n            return mLayoutInflater.inflate(R.layout.chooser_az_label_row, parent, false);\n        }\n\n        private ItemGroupViewHolder loadViewsIntoGroup(ItemGroupViewHolder holder) {\n            final int spec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);\n            final int exactSpec = MeasureSpec.makeMeasureSpec(mChooserTargetWidth,\n                    MeasureSpec.EXACTLY);\n            int columnCount = holder.getColumnCount();\n\n            final boolean isDirectShare = holder instanceof DirectShareViewHolder;\n\n            for (int i = 0; i < columnCount; i++) {\n                final View v = mChooserListAdapter.createView(holder.getRowByIndex(i));\n                final int column = i;\n                v.setOnClickListener(new OnClickListener() {\n                    @Override\n                    public void onClick(View v) {\n                        startSelected(holder.getItemIndex(column), false, true);\n                    }\n                });\n\n                // Show menu for both direct share and app share targets after long click.\n                v.setOnLongClickListener(v1 -> {\n                    TargetInfo ti = mChooserListAdapter.targetInfoForPosition(\n                            holder.getItemIndex(column), true);\n                    if (shouldShowTargetDetails(ti)) {\n                        showTargetDetails(ti);\n                    }\n                    return true;\n                });\n\n                holder.addView(i, v);\n\n                // Force Direct Share to be 2 lines and auto-wrap to second line via hoz scroll =\n                // false. TextView#setHorizontallyScrolling must be reset after #setLines. Must be\n                // done before measuring.\n                if (isDirectShare) {\n                    final ViewHolder vh = (ViewHolder) v.getTag();\n                    vh.text.setLines(2);\n                    vh.text.setHorizontallyScrolling(false);\n                    vh.text2.setVisibility(View.GONE);\n                }\n\n                // Force height to be a given so we don't have visual disruption during scaling.\n                v.measure(exactSpec, spec);\n                setViewBounds(v, v.getMeasuredWidth(), v.getMeasuredHeight());\n            }\n\n            final ViewGroup viewGroup = holder.getViewGroup();\n\n            // Pre-measure and fix height so we can scale later.\n            holder.measure();\n            setViewBounds(viewGroup, LayoutParams.MATCH_PARENT, holder.getMeasuredRowHeight());\n\n            if (isDirectShare) {\n                DirectShareViewHolder dsvh = (DirectShareViewHolder) holder;\n                setViewBounds(dsvh.getRow(0), LayoutParams.MATCH_PARENT, dsvh.getMinRowHeight());\n                setViewBounds(dsvh.getRow(1), LayoutParams.MATCH_PARENT, dsvh.getMinRowHeight());\n            }\n\n            viewGroup.setTag(holder);\n            return holder;\n        }\n\n        private void setViewBounds(View view, int widthPx, int heightPx) {\n            LayoutParams lp = view.getLayoutParams();\n            if (lp == null) {\n                lp = new LayoutParams(widthPx, heightPx);\n                view.setLayoutParams(lp);\n            } else {\n                lp.height = heightPx;\n                lp.width = widthPx;\n            }\n        }\n\n        ItemGroupViewHolder createItemGroupViewHolder(int viewType, ViewGroup parent) {\n            if (viewType == VIEW_TYPE_DIRECT_SHARE) {\n                ViewGroup parentGroup = (ViewGroup) mLayoutInflater.inflate(\n                        R.layout.chooser_row_direct_share, parent, false);\n                ViewGroup row1 = (ViewGroup) mLayoutInflater.inflate(R.layout.chooser_row,\n                        parentGroup, false);\n                ViewGroup row2 = (ViewGroup) mLayoutInflater.inflate(R.layout.chooser_row,\n                        parentGroup, false);\n                parentGroup.addView(row1);\n                parentGroup.addView(row2);\n\n                mDirectShareViewHolder = new DirectShareViewHolder(parentGroup,\n                        Lists.newArrayList(row1, row2), mMaxTargetsPerRow, viewType,\n                        mChooserMultiProfilePagerAdapter::getActiveListAdapter);\n                loadViewsIntoGroup(mDirectShareViewHolder);\n\n                return mDirectShareViewHolder;\n            } else {\n                ViewGroup row = (ViewGroup) mLayoutInflater.inflate(R.layout.chooser_row, parent,\n                        false);\n                ItemGroupViewHolder holder =\n                        new SingleRowViewHolder(row, mMaxTargetsPerRow, viewType);\n                loadViewsIntoGroup(holder);\n\n                return holder;\n            }\n        }\n\n        /**\n         * Need to merge CALLER + ranked STANDARD into a single row and prevent a separator from\n         * showing on top of the AZ list if the AZ label is visible. All other types are placed into\n         * their own row as determined by their target type, and dividers are added in the list to\n         * separate each type.\n         */\n        int getRowType(int rowPosition) {\n            // Merge caller and ranked standard into a single row\n            int positionType = mChooserListAdapter.getPositionTargetType(rowPosition);\n            if (positionType == ChooserListAdapter.TARGET_CALLER) {\n                return ChooserListAdapter.TARGET_STANDARD;\n            }\n\n            // If an the A-Z label is shown, prevent a separator from appearing by making the A-Z\n            // row type the same as the suggestion row type\n            if (getAzLabelRowCount() > 0 && positionType == ChooserListAdapter.TARGET_STANDARD_AZ) {\n                return ChooserListAdapter.TARGET_STANDARD;\n            }\n\n            return positionType;\n        }\n\n        void bindItemViewHolder(int position, ItemViewHolder holder) {\n            View v = holder.itemView;\n            int listPosition = getListPosition(position);\n            holder.mListPosition = listPosition;\n            mChooserListAdapter.bindView(listPosition, v);\n        }\n\n        void bindItemGroupViewHolder(int position, ItemGroupViewHolder holder) {\n            final ViewGroup viewGroup = (ViewGroup) holder.itemView;\n            int start = getListPosition(position);\n            int startType = getRowType(start);\n\n            int columnCount = holder.getColumnCount();\n            int end = start + columnCount - 1;\n            while (getRowType(end) != startType && end >= start) {\n                end--;\n            }\n\n            if (end == start && mChooserListAdapter.getItem(start) instanceof EmptyTargetInfo) {\n                final TextView textView = viewGroup.findViewById(R.id.chooser_row_text_option);\n\n                if (textView.getVisibility() != View.VISIBLE) {\n                    textView.setAlpha(0.0f);\n                    textView.setVisibility(View.VISIBLE);\n                    textView.setText(R.string.chooser_no_direct_share_targets);\n\n                    ValueAnimator fadeAnim = ObjectAnimator.ofFloat(textView, \"alpha\", 0.0f, 1.0f);\n                    fadeAnim.setInterpolator(new DecelerateInterpolator(1.0f));\n\n                    float translationInPx = getResources().getDimensionPixelSize(\n                            R.dimen.chooser_row_text_option_translate);\n                    textView.setTranslationY(translationInPx);\n                    ValueAnimator translateAnim = ObjectAnimator.ofFloat(textView, \"translationY\",\n                            0.0f);\n                    translateAnim.setInterpolator(new DecelerateInterpolator(1.0f));\n\n                    AnimatorSet animSet = new AnimatorSet();\n                    animSet.setDuration(NO_DIRECT_SHARE_ANIM_IN_MILLIS);\n                    animSet.setStartDelay(NO_DIRECT_SHARE_ANIM_IN_MILLIS);\n                    animSet.playTogether(fadeAnim, translateAnim);\n                    animSet.start();\n                }\n            }\n\n            for (int i = 0; i < columnCount; i++) {\n                final View v = holder.getView(i);\n\n                if (start + i <= end) {\n                    holder.setViewVisibility(i, View.VISIBLE);\n                    holder.setItemIndex(i, start + i);\n                    mChooserListAdapter.bindView(holder.getItemIndex(i), v);\n                } else {\n                    holder.setViewVisibility(i, View.INVISIBLE);\n                }\n            }\n        }\n\n        int getListPosition(int position) {\n            position -= getSystemRowCount() + getProfileRowCount();\n\n            final int serviceCount = mChooserListAdapter.getServiceTargetCount();\n            final int serviceRows = (int) Math.ceil((float) serviceCount / getMaxRankedTargets());\n            if (position < serviceRows) {\n                return position * mMaxTargetsPerRow;\n            }\n\n            position -= serviceRows;\n\n            final int callerAndRankedCount = mChooserListAdapter.getCallerTargetCount()\n                                                 + mChooserListAdapter.getRankedTargetCount();\n            final int callerAndRankedRows = getCallerAndRankedTargetRowCount();\n            if (position < callerAndRankedRows) {\n                return serviceCount + position * mMaxTargetsPerRow;\n            }\n\n            position -= getAzLabelRowCount() + callerAndRankedRows;\n\n            return callerAndRankedCount + serviceCount + position;\n        }\n\n        public void handleScroll(View v, int y, int oldy) {\n            boolean canExpandDirectShare = canExpandDirectShare();\n            if (mDirectShareViewHolder != null && canExpandDirectShare) {\n                mDirectShareViewHolder.handleScroll(\n                        mChooserMultiProfilePagerAdapter.getActiveAdapterView(), y, oldy,\n                        mMaxTargetsPerRow);\n            }\n        }\n\n        /**\n         * Only expand direct share area if there is a minimum number of targets.\n         */\n        private boolean canExpandDirectShare() {\n            // Do not enable until we have confirmed more apps are using sharing shortcuts\n            // Check git history for enablement logic\n            return false;\n        }\n\n        public ChooserListAdapter getListAdapter() {\n            return mChooserListAdapter;\n        }\n\n        boolean shouldCellSpan(int position) {\n            return getItemViewType(position) == VIEW_TYPE_NORMAL;\n        }\n\n        void updateDirectShareExpansion() {\n            if (mDirectShareViewHolder == null || !canExpandDirectShare()) {\n                return;\n            }\n            RecyclerView activeAdapterView =\n                    mChooserMultiProfilePagerAdapter.getActiveAdapterView();\n            if (mResolverDrawerLayout.isCollapsed()) {\n                mDirectShareViewHolder.collapse(activeAdapterView);\n            } else {\n                mDirectShareViewHolder.expand(activeAdapterView);\n            }\n        }\n    }\n\n    /**\n     * Used to bind types for group of items including:\n     * {@link ChooserGridAdapter#VIEW_TYPE_DIRECT_SHARE},\n     * and {@link ChooserGridAdapter#VIEW_TYPE_CALLER_AND_RANK}.\n     */\n    abstract static class ItemGroupViewHolder extends ViewHolderBase {\n        protected int mMeasuredRowHeight;\n        private int[] mItemIndices;\n        protected final View[] mCells;\n        private final int mColumnCount;\n\n        ItemGroupViewHolder(int cellCount, View itemView, int viewType) {\n            super(itemView, viewType);\n            this.mCells = new View[cellCount];\n            this.mItemIndices = new int[cellCount];\n            this.mColumnCount = cellCount;\n        }\n\n        abstract ViewGroup addView(int index, View v);\n\n        abstract ViewGroup getViewGroup();\n\n        abstract ViewGroup getRowByIndex(int index);\n\n        abstract ViewGroup getRow(int rowNumber);\n\n        abstract void setViewVisibility(int i, int visibility);\n\n        public int getColumnCount() {\n            return mColumnCount;\n        }\n\n        public void measure() {\n            final int spec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);\n            getViewGroup().measure(spec, spec);\n            mMeasuredRowHeight = getViewGroup().getMeasuredHeight();\n        }\n\n        public int getMeasuredRowHeight() {\n            return mMeasuredRowHeight;\n        }\n\n        public void setItemIndex(int itemIndex, int listIndex) {\n            mItemIndices[itemIndex] = listIndex;\n        }\n\n        public int getItemIndex(int itemIndex) {\n            return mItemIndices[itemIndex];\n        }\n\n        public View getView(int index) {\n            return mCells[index];\n        }\n    }\n\n    static class SingleRowViewHolder extends ItemGroupViewHolder {\n        private final ViewGroup mRow;\n\n        SingleRowViewHolder(ViewGroup row, int cellCount, int viewType) {\n            super(cellCount, row, viewType);\n\n            this.mRow = row;\n        }\n\n        public ViewGroup getViewGroup() {\n            return mRow;\n        }\n\n        public ViewGroup getRowByIndex(int index) {\n            return mRow;\n        }\n\n        public ViewGroup getRow(int rowNumber) {\n            if (rowNumber == 0) return mRow;\n            return null;\n        }\n\n        public ViewGroup addView(int index, View v) {\n            mRow.addView(v);\n            mCells[index] = v;\n\n            return mRow;\n        }\n\n        public void setViewVisibility(int i, int visibility) {\n            getView(i).setVisibility(visibility);\n        }\n    }\n\n    static class DirectShareViewHolder extends ItemGroupViewHolder {\n        private final ViewGroup mParent;\n        private final List<ViewGroup> mRows;\n        private int mCellCountPerRow;\n\n        private boolean mHideDirectShareExpansion = false;\n        private int mDirectShareMinHeight = 0;\n        private int mDirectShareCurrHeight = 0;\n        private int mDirectShareMaxHeight = 0;\n\n        private final boolean[] mCellVisibility;\n\n        private final Supplier<ChooserListAdapter> mListAdapterSupplier;\n\n        DirectShareViewHolder(ViewGroup parent, List<ViewGroup> rows, int cellCountPerRow,\n                int viewType, Supplier<ChooserListAdapter> listAdapterSupplier) {\n            super(rows.size() * cellCountPerRow, parent, viewType);\n\n            this.mParent = parent;\n            this.mRows = rows;\n            this.mCellCountPerRow = cellCountPerRow;\n            this.mCellVisibility = new boolean[rows.size() * cellCountPerRow];\n            Arrays.fill(mCellVisibility, true);\n            this.mListAdapterSupplier = listAdapterSupplier;\n        }\n\n        public ViewGroup addView(int index, View v) {\n            ViewGroup row = getRowByIndex(index);\n            row.addView(v);\n            mCells[index] = v;\n\n            return row;\n        }\n\n        public ViewGroup getViewGroup() {\n            return mParent;\n        }\n\n        public ViewGroup getRowByIndex(int index) {\n            return mRows.get(index / mCellCountPerRow);\n        }\n\n        public ViewGroup getRow(int rowNumber) {\n            return mRows.get(rowNumber);\n        }\n\n        public void measure() {\n            final int spec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);\n            getRow(0).measure(spec, spec);\n            getRow(1).measure(spec, spec);\n\n            mDirectShareMinHeight = getRow(0).getMeasuredHeight();\n            mDirectShareCurrHeight = mDirectShareCurrHeight > 0\n                    ? mDirectShareCurrHeight : mDirectShareMinHeight;\n            mDirectShareMaxHeight = 2 * mDirectShareMinHeight;\n        }\n\n        public int getMeasuredRowHeight() {\n            return mDirectShareCurrHeight;\n        }\n\n        public int getMinRowHeight() {\n            return mDirectShareMinHeight;\n        }\n\n        public void setViewVisibility(int i, int visibility) {\n            final View v = getView(i);\n            if (visibility == View.VISIBLE) {\n                mCellVisibility[i] = true;\n                v.setVisibility(visibility);\n                v.setAlpha(1.0f);\n            } else if (visibility == View.INVISIBLE && mCellVisibility[i]) {\n                mCellVisibility[i] = false;\n\n                ValueAnimator fadeAnim = ObjectAnimator.ofFloat(v, \"alpha\", 1.0f, 0f);\n                fadeAnim.setDuration(NO_DIRECT_SHARE_ANIM_IN_MILLIS);\n                fadeAnim.setInterpolator(new AccelerateInterpolator(1.0f));\n                fadeAnim.addListener(new AnimatorListenerAdapter() {\n                    public void onAnimationEnd(Animator animation) {\n                        v.setVisibility(View.INVISIBLE);\n                    }\n                });\n                fadeAnim.start();\n            }\n        }\n\n        public void handleScroll(RecyclerView view, int y, int oldy, int maxTargetsPerRow) {\n            // only exit early if fully collapsed, otherwise onListRebuilt() with shifting\n            // targets can lock us into an expanded mode\n            boolean notExpanded = mDirectShareCurrHeight == mDirectShareMinHeight;\n            if (notExpanded) {\n                if (mHideDirectShareExpansion) {\n                    return;\n                }\n\n                // only expand if we have more than maxTargetsPerRow, and delay that decision\n                // until they start to scroll\n                ChooserListAdapter adapter = mListAdapterSupplier.get();\n                int validTargets = adapter.getSelectableServiceTargetCount();\n                if (validTargets <= maxTargetsPerRow) {\n                    mHideDirectShareExpansion = true;\n                    return;\n                }\n            }\n\n            int yDiff = (int) ((oldy - y) * DIRECT_SHARE_EXPANSION_RATE);\n\n            int prevHeight = mDirectShareCurrHeight;\n            int newHeight = Math.min(prevHeight + yDiff, mDirectShareMaxHeight);\n            newHeight = Math.max(newHeight, mDirectShareMinHeight);\n            yDiff = newHeight - prevHeight;\n\n            updateDirectShareRowHeight(view, yDiff, newHeight);\n        }\n\n        void expand(RecyclerView view) {\n            updateDirectShareRowHeight(view, mDirectShareMaxHeight - mDirectShareCurrHeight,\n                    mDirectShareMaxHeight);\n        }\n\n        void collapse(RecyclerView view) {\n            updateDirectShareRowHeight(view, mDirectShareMinHeight - mDirectShareCurrHeight,\n                    mDirectShareMinHeight);\n        }\n\n        private void updateDirectShareRowHeight(RecyclerView view, int yDiff, int newHeight) {\n            if (view == null || view.getChildCount() == 0 || yDiff == 0) {\n                return;\n            }\n\n            // locate the item to expand, and offset the rows below that one\n            boolean foundExpansion = false;\n            for (int i = 0; i < view.getChildCount(); i++) {\n                View child = view.getChildAt(i);\n\n                if (foundExpansion) {\n                    child.offsetTopAndBottom(yDiff);\n                } else {\n                    if (child.getTag() != null && child.getTag() instanceof DirectShareViewHolder) {\n                        int widthSpec = MeasureSpec.makeMeasureSpec(child.getWidth(),\n                                MeasureSpec.EXACTLY);\n                        int heightSpec = MeasureSpec.makeMeasureSpec(newHeight,\n                                MeasureSpec.EXACTLY);\n                        child.measure(widthSpec, heightSpec);\n                        child.getLayoutParams().height = child.getMeasuredHeight();\n                        child.layout(child.getLeft(), child.getTop(), child.getRight(),\n                                child.getTop() + child.getMeasuredHeight());\n\n                        foundExpansion = true;\n                    }\n                }\n            }\n\n            if (foundExpansion) {\n                mDirectShareCurrHeight = newHeight;\n            }\n        }\n    }\n\n    /**\n     * Shortcuts grouped by application.\n     */\n    @VisibleForTesting\n    public static class ServiceResultInfo {\n        public final DisplayResolveInfo originalTarget;\n        public final List<ChooserTarget> resultTargets;\n        public final UserHandle userHandle;\n\n        public ServiceResultInfo(DisplayResolveInfo ot, List<ChooserTarget> rt,\n                UserHandle userHandle) {\n            originalTarget = ot;\n            resultTargets = rt;\n            this.userHandle = userHandle;\n        }\n    }\n\n    static class ChooserTargetRankingInfo {\n        public final List<AppTarget> scores;\n        public final UserHandle userHandle;\n\n        ChooserTargetRankingInfo(List<AppTarget> chooserTargetScores,\n                UserHandle userHandle) {\n            this.scores = chooserTargetScores;\n            this.userHandle = userHandle;\n        }\n    }\n\n    static class RefinementResultReceiver extends ResultReceiver {\n        private ChooserActivity mChooserActivity;\n        private TargetInfo mSelectedTarget;\n\n        public RefinementResultReceiver(ChooserActivity host, TargetInfo target,\n                Handler handler) {\n            super(handler);\n            mChooserActivity = host;\n            mSelectedTarget = target;\n        }\n\n        @Override\n        protected void onReceiveResult(int resultCode, Bundle resultData) {\n            if (mChooserActivity == null) {\n                Log.e(TAG, \"Destroyed RefinementResultReceiver received a result\");\n                return;\n            }\n            if (resultData == null) {\n                Log.e(TAG, \"RefinementResultReceiver received null resultData\");\n                return;\n            }\n\n            switch (resultCode) {\n                case RESULT_CANCELED:\n                    mChooserActivity.onRefinementCanceled();\n                    break;\n                case RESULT_OK:\n                    Parcelable intentParcelable = resultData.getParcelable(Intent.EXTRA_INTENT);\n                    if (intentParcelable instanceof Intent) {\n                        mChooserActivity.onRefinementResult(mSelectedTarget,\n                                (Intent) intentParcelable);\n                    } else {\n                        Log.e(TAG, \"RefinementResultReceiver received RESULT_OK but no Intent\"\n                                + \" in resultData with key Intent.EXTRA_INTENT\");\n                    }\n                    break;\n                default:\n                    Log.w(TAG, \"Unknown result code \" + resultCode\n                            + \" sent to RefinementResultReceiver\");\n                    break;\n            }\n        }\n\n        public void destroy() {\n            mChooserActivity = null;\n            mSelectedTarget = null;\n        }\n    }\n\n    /**\n     * Used internally to round image corners while obeying view padding.\n     */\n    public static class RoundedRectImageView extends ImageView {\n        private int mRadius = 0;\n        private Path mPath = new Path();\n        private Paint mOverlayPaint = new Paint(0);\n        private Paint mRoundRectPaint = new Paint(0);\n        private Paint mTextPaint = new Paint(Paint.ANTI_ALIAS_FLAG);\n        private String mExtraImageCount = null;\n\n        public RoundedRectImageView(Context context) {\n            super(context);\n        }\n\n        public RoundedRectImageView(Context context, AttributeSet attrs) {\n            this(context, attrs, 0);\n        }\n\n        public RoundedRectImageView(Context context, AttributeSet attrs, int defStyleAttr) {\n            this(context, attrs, defStyleAttr, 0);\n        }\n\n        public RoundedRectImageView(Context context, AttributeSet attrs, int defStyleAttr,\n                int defStyleRes) {\n            super(context, attrs, defStyleAttr, defStyleRes);\n            mRadius = context.getResources().getDimensionPixelSize(R.dimen.chooser_corner_radius);\n\n            mOverlayPaint.setColor(0x99000000);\n            mOverlayPaint.setStyle(Paint.Style.FILL);\n\n            mRoundRectPaint.setColor(context.getResources().getColor(R.color.chooser_row_divider));\n            mRoundRectPaint.setStyle(Paint.Style.STROKE);\n            mRoundRectPaint.setStrokeWidth(context.getResources()\n                    .getDimensionPixelSize(R.dimen.chooser_preview_image_border));\n\n            mTextPaint.setColor(Color.WHITE);\n            mTextPaint.setTextSize(context.getResources()\n                    .getDimensionPixelSize(R.dimen.chooser_preview_image_font_size));\n            mTextPaint.setTextAlign(Paint.Align.CENTER);\n        }\n\n        private void updatePath(int width, int height) {\n            mPath.reset();\n\n            int imageWidth = width - getPaddingRight() - getPaddingLeft();\n            int imageHeight = height - getPaddingBottom() - getPaddingTop();\n            mPath.addRoundRect(getPaddingLeft(), getPaddingTop(), imageWidth, imageHeight, mRadius,\n                    mRadius, Path.Direction.CW);\n        }\n\n        /**\n          * Sets the corner radius on all corners\n          *\n          * param radius 0 for no radius, &gt; 0 for a visible corner radius\n          */\n        public void setRadius(int radius) {\n            mRadius = radius;\n            updatePath(getWidth(), getHeight());\n        }\n\n        /**\n          * Display an overlay with extra image count on 3rd image\n          */\n        public void setExtraImageCount(int count) {\n            if (count > 0) {\n                this.mExtraImageCount = \"+\" + count;\n            } else {\n                this.mExtraImageCount = null;\n            }\n        }\n\n        @Override\n        protected void onSizeChanged(int width, int height, int oldWidth, int oldHeight) {\n            super.onSizeChanged(width, height, oldWidth, oldHeight);\n            updatePath(width, height);\n        }\n\n        @Override\n        protected void onDraw(Canvas canvas) {\n            if (mRadius != 0) {\n                canvas.clipPath(mPath);\n            }\n\n            super.onDraw(canvas);\n\n            int x = getPaddingLeft();\n            int y = getPaddingRight();\n            int width = getWidth() - getPaddingRight() - getPaddingLeft();\n            int height = getHeight() - getPaddingBottom() - getPaddingTop();\n            if (mExtraImageCount != null) {\n                canvas.drawRect(x, y, width, height, mOverlayPaint);\n\n                int xPos = canvas.getWidth() / 2;\n                int yPos = (int) ((canvas.getHeight() / 2.0f)\n                        - ((mTextPaint.descent() + mTextPaint.ascent()) / 2.0f));\n\n                canvas.drawText(mExtraImageCount, xPos, yPos, mTextPaint);\n            }\n\n            canvas.drawRoundRect(x, y, width, height, mRadius, mRadius, mRoundRectPaint);\n        }\n    }\n\n    /**\n     * A helper class to track app's readiness for the scene transition animation.\n     * The app is ready when both the image is laid out and the drawer offset is calculated.\n     */\n    private class EnterTransitionAnimationDelegate implements View.OnLayoutChangeListener {\n        private boolean mPreviewReady = false;\n        private boolean mOffsetCalculated = false;\n\n        void postponeTransition() {\n            postponeEnterTransition();\n        }\n\n        void markImagePreviewReady() {\n            if (!mPreviewReady) {\n                mPreviewReady = true;\n                maybeStartListenForLayout();\n            }\n        }\n\n        void markOffsetCalculated() {\n            if (!mOffsetCalculated) {\n                mOffsetCalculated = true;\n                maybeStartListenForLayout();\n            }\n        }\n\n        private void maybeStartListenForLayout() {\n            if (mPreviewReady && mOffsetCalculated && mResolverDrawerLayout != null) {\n                if (mResolverDrawerLayout.isInLayout()) {\n                    startPostponedEnterTransition();\n                } else {\n                    mResolverDrawerLayout.addOnLayoutChangeListener(this);\n                    mResolverDrawerLayout.requestLayout();\n                }\n            }\n        }\n\n        @Override\n        public void onLayoutChange(View v, int left, int top, int right, int bottom, int oldLeft,\n                int oldTop, int oldRight, int oldBottom) {\n            v.removeOnLayoutChangeListener(this);\n            startPostponedEnterTransition();\n        }\n    }\n\n    /**\n     * Used in combination with the scene transition when launching the image editor\n     */\n    private static class FinishAnimation extends AlphaAnimation implements\n            Animation.AnimationListener {\n        @Nullable\n        private Activity mActivity;\n        @Nullable\n        private View mRootView;\n        private final float mFromAlpha;\n\n        FinishAnimation(@NonNull Activity activity, @NonNull View rootView) {\n            super(rootView.getAlpha(), 0.0f);\n            mActivity = activity;\n            mRootView = rootView;\n            mFromAlpha = rootView.getAlpha();\n            setInterpolator(new LinearInterpolator());\n            long duration = activity.getWindow().getTransitionBackgroundFadeDuration();\n            setDuration(duration);\n            // The scene transition animation looks better when it's not overlapped with this\n            // fade-out animation thus the delay.\n            // It is most likely that the image editor will cause this activity to stop and this\n            // animation will be cancelled in the background without running (i.e. we'll animate\n            // only when this activity remains partially visible after the image editor launch).\n            setStartOffset(duration);\n            super.setAnimationListener(this);\n        }\n\n        @Override\n        public void setAnimationListener(AnimationListener listener) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public void cancel() {\n            if (mRootView != null) {\n                mRootView.setAlpha(mFromAlpha);\n            }\n            cleanup();\n            super.cancel();\n        }\n\n        @Override\n        public void onAnimationStart(Animation animation) {\n        }\n\n        @Override\n        public void onAnimationEnd(Animation animation) {\n            Activity activity = mActivity;\n            cleanup();\n            if (activity != null) {\n                activity.finish();\n            }\n        }\n\n        @Override\n        public void onAnimationRepeat(Animation animation) {\n        }\n\n        private void cleanup() {\n            mActivity = null;\n            mRootView = null;\n        }\n    }\n\n    @Override\n    protected void maybeLogProfileChange() {\n        getChooserActivityLogger().logShareheetProfileChanged();\n    }\n\n    private boolean shouldNearbyShareBeFirstInRankedRow() {\n        return ActivityManager.isLowRamDeviceStatic() && mIsNearbyShareFirstTargetInRankedApp;\n    }\n\n    private boolean shouldNearbyShareBeIncludedAsActionButton() {\n        return !shouldNearbyShareBeFirstInRankedRow();\n    }\n\n    private boolean hasValidIcon(ChooserTarget target) {\n        Icon icon = target.getIcon();\n        if (icon == null) {\n            return true;\n        }\n        if (icon.getType() == Icon.TYPE_URI || icon.getType() == Icon.TYPE_URI_ADAPTIVE_BITMAP) {\n            Uri uri = icon.getUri();\n            try {\n                getUriGrantsManager().checkGrantUriPermission_ignoreNonSystem(\n                        getLaunchedFromUid(),\n                        getPackageName(),\n                        getUriWithoutUserId(uri),\n                        Intent.FLAG_GRANT_READ_URI_PERMISSION,\n                        getUserIdFromUri(uri)\n                );\n            } catch (SecurityException | RemoteException e) {\n                Log.e(TAG, \"Failed to get URI permission for: \" + uri, e);\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private IUriGrantsManager getUriGrantsManager() {\n        return UriGrantsManager.getService();\n    }\n\n    private static ChooserTarget removeIcon(ChooserTarget target) {\n        if (target == null) {\n            return null;\n        }\n        return new ChooserTarget(\n                target.getTitle(),\n                null,\n                target.getScore(),\n                target.getComponentName(),\n                target.getIntentExtras());\n    }\n}\n```",
                        "downstream_file_content": "```java\n/*\n * Copyright (C) 2008 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.internal.app;\n\nimport static android.content.ContentProvider.getUserIdFromUri;\n\nimport static com.android.internal.util.LatencyTracker.ACTION_LOAD_SHARE_SHEET;\n\nimport static java.lang.annotation.RetentionPolicy.SOURCE;\n\nimport android.animation.Animator;\nimport android.animation.AnimatorListenerAdapter;\nimport android.animation.AnimatorSet;\nimport android.animation.ObjectAnimator;\nimport android.animation.ValueAnimator;\nimport android.annotation.IntDef;\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.app.Activity;\nimport android.app.ActivityManager;\nimport android.app.SharedElementCallback;\nimport android.app.prediction.AppPredictionContext;\nimport android.app.prediction.AppPredictionManager;\nimport android.app.prediction.AppPredictor;\nimport android.app.prediction.AppTarget;\nimport android.app.prediction.AppTargetEvent;\nimport android.app.prediction.AppTargetId;\nimport android.compat.annotation.UnsupportedAppUsage;\nimport android.content.ClipData;\nimport android.content.ClipboardManager;\nimport android.content.ComponentName;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.IntentSender;\nimport android.content.IntentSender.SendIntentException;\nimport android.content.SharedPreferences;\nimport android.content.pm.ActivityInfo;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManager.NameNotFoundException;\nimport android.content.pm.ResolveInfo;\nimport android.content.pm.ShortcutInfo;\nimport android.content.pm.ShortcutManager;\nimport android.content.res.Configuration;\nimport android.content.res.Resources;\nimport android.database.Cursor;\nimport android.database.DataSetObserver;\nimport android.graphics.Bitmap;\nimport android.graphics.Canvas;\nimport android.graphics.Color;\nimport android.graphics.Paint;\nimport android.graphics.Path;\nimport android.graphics.drawable.AnimatedVectorDrawable;\nimport android.graphics.drawable.Drawable;\nimport android.graphics.drawable.Icon;\nimport android.metrics.LogMaker;\nimport android.net.Uri;\nimport android.os.AsyncTask;\nimport android.os.Bundle;\nimport android.os.Environment;\nimport android.os.Handler;\nimport android.os.Message;\nimport android.os.Parcelable;\nimport android.os.PatternMatcher;\nimport android.os.RemoteException;\nimport android.os.ResultReceiver;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.os.storage.StorageManager;\nimport android.provider.DeviceConfig;\nimport android.provider.DocumentsContract;\nimport android.provider.Downloads;\nimport android.provider.OpenableColumns;\nimport android.provider.Settings;\nimport android.service.chooser.ChooserTarget;\nimport android.text.TextUtils;\nimport android.util.AttributeSet;\nimport android.util.HashedStringCache;\nimport android.util.Log;\nimport android.util.PluralsMessageFormatter;\nimport android.util.Size;\nimport android.util.Slog;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.View.MeasureSpec;\nimport android.view.View.OnClickListener;\nimport android.view.ViewGroup;\nimport android.view.ViewGroup.LayoutParams;\nimport android.view.ViewTreeObserver;\nimport android.view.WindowInsets;\nimport android.view.animation.AccelerateInterpolator;\nimport android.view.animation.DecelerateInterpolator;\nimport android.widget.Button;\nimport android.widget.ImageView;\nimport android.widget.Space;\nimport android.widget.TextView;\n\nimport com.android.internal.R;\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.app.ResolverListAdapter.ActivityInfoPresentationGetter;\nimport com.android.internal.app.ResolverListAdapter.ViewHolder;\nimport com.android.internal.app.chooser.ChooserTargetInfo;\nimport com.android.internal.app.chooser.DisplayResolveInfo;\nimport com.android.internal.app.chooser.MultiDisplayResolveInfo;\nimport com.android.internal.app.chooser.NotSelectableTargetInfo;\nimport com.android.internal.app.chooser.SelectableTargetInfo;\nimport com.android.internal.app.chooser.SelectableTargetInfo.SelectableTargetInfoCommunicator;\nimport com.android.internal.app.chooser.TargetInfo;\nimport com.android.internal.config.sysui.SystemUiDeviceConfigFlags;\nimport com.android.internal.content.PackageMonitor;\nimport com.android.internal.logging.MetricsLogger;\nimport com.android.internal.logging.nano.MetricsProto.MetricsEvent;\nimport com.android.internal.util.FrameworkStatsLog;\nimport com.android.internal.widget.GridLayoutManager;\nimport com.android.internal.widget.RecyclerView;\nimport com.android.internal.widget.ResolverDrawerLayout;\nimport com.android.internal.widget.ViewPager;\n\nimport com.google.android.collect.Lists;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.net.URISyntaxException;\nimport java.text.Collator;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.function.Supplier;\nimport java.util.stream.Collectors;\n\n/**\n * The Chooser Activity handles intent resolution specifically for sharing intents -\n * for example, those generated by @see android.content.Intent#createChooser(Intent, CharSequence).\n *\n */\npublic class ChooserActivity extends ResolverActivity implements\n        ChooserListAdapter.ChooserListCommunicator,\n        SelectableTargetInfoCommunicator {\n    private static final String TAG = \"ChooserActivity\";\n\n    private AppPredictor mPersonalAppPredictor;\n    private AppPredictor mWorkAppPredictor;\n    private boolean mShouldDisplayLandscape;\n\n    @UnsupportedAppUsage\n    public ChooserActivity() {\n    }\n    /**\n     * Boolean extra to change the following behavior: Normally, ChooserActivity finishes itself\n     * in onStop when launched in a new task. If this extra is set to true, we do not finish\n     * ourselves when onStop gets called.\n     */\n    public static final String EXTRA_PRIVATE_RETAIN_IN_ON_STOP\n            = \"com.android.internal.app.ChooserActivity.EXTRA_PRIVATE_RETAIN_IN_ON_STOP\";\n\n\n    /**\n     * Transition name for the first image preview.\n     * To be used for shared element transition into this activity.\n     * @hide\n     */\n    public static final String FIRST_IMAGE_PREVIEW_TRANSITION_NAME = \"screenshot_preview_image\";\n\n    private static final String PREF_NUM_SHEET_EXPANSIONS = \"pref_num_sheet_expansions\";\n\n    private static final String CHIP_LABEL_METADATA_KEY = \"android.service.chooser.chip_label\";\n    private static final String CHIP_ICON_METADATA_KEY = \"android.service.chooser.chip_icon\";\n\n    private static final boolean DEBUG = true;\n\n    private static final boolean USE_PREDICTION_MANAGER_FOR_SHARE_ACTIVITIES = true;\n    // TODO(b/123088566) Share these in a better way.\n    private static final String APP_PREDICTION_SHARE_UI_SURFACE = \"share\";\n    public static final String LAUNCH_LOCATION_DIRECT_SHARE = \"direct_share\";\n    public static final String CHOOSER_TARGET = \"chooser_target\";\n    private static final String SHORTCUT_TARGET = \"shortcut_target\";\n    private static final int APP_PREDICTION_SHARE_TARGET_QUERY_PACKAGE_LIMIT = 20;\n    public static final String APP_PREDICTION_INTENT_FILTER_KEY = \"intent_filter\";\n    private static final String SHARED_TEXT_KEY = \"shared_text\";\n\n    private static final String PLURALS_COUNT = \"count\";\n    private static final String PLURALS_FILE_NAME = \"file_name\";\n\n    private boolean mIsAppPredictorComponentAvailable;\n    private Map<ChooserTarget, AppTarget> mDirectShareAppTargetCache;\n    private Map<ChooserTarget, ShortcutInfo> mDirectShareShortcutInfoCache;\n\n    public static final int TARGET_TYPE_DEFAULT = 0;\n    public static final int TARGET_TYPE_CHOOSER_TARGET = 1;\n    public static final int TARGET_TYPE_SHORTCUTS_FROM_SHORTCUT_MANAGER = 2;\n    public static final int TARGET_TYPE_SHORTCUTS_FROM_PREDICTION_SERVICE = 3;\n\n    public static final int SELECTION_TYPE_SERVICE = 1;\n    public static final int SELECTION_TYPE_APP = 2;\n    public static final int SELECTION_TYPE_STANDARD = 3;\n    public static final int SELECTION_TYPE_COPY = 4;\n    public static final int SELECTION_TYPE_NEARBY = 5;\n    public static final int SELECTION_TYPE_EDIT = 6;\n\n    private static final int SCROLL_STATUS_IDLE = 0;\n    private static final int SCROLL_STATUS_SCROLLING_VERTICAL = 1;\n    private static final int SCROLL_STATUS_SCROLLING_HORIZONTAL = 2;\n\n    // statsd logger wrapper\n    protected ChooserActivityLogger mChooserActivityLogger;\n\n    @IntDef(flag = false, prefix = { \"TARGET_TYPE_\" }, value = {\n            TARGET_TYPE_DEFAULT,\n            TARGET_TYPE_CHOOSER_TARGET,\n            TARGET_TYPE_SHORTCUTS_FROM_SHORTCUT_MANAGER,\n            TARGET_TYPE_SHORTCUTS_FROM_PREDICTION_SERVICE\n    })\n    @Retention(RetentionPolicy.SOURCE)\n    public @interface ShareTargetType {}\n\n    /**\n     * The transition time between placeholders for direct share to a message\n     * indicating that non are available.\n     */\n    private static final int NO_DIRECT_SHARE_ANIM_IN_MILLIS = 200;\n\n    private static final float DIRECT_SHARE_EXPANSION_RATE = 0.78f;\n\n    private static final int DEFAULT_SALT_EXPIRATION_DAYS = 7;\n    private int mMaxHashSaltDays = DeviceConfig.getInt(DeviceConfig.NAMESPACE_SYSTEMUI,\n            SystemUiDeviceConfigFlags.HASH_SALT_MAX_DAYS,\n            DEFAULT_SALT_EXPIRATION_DAYS);\n\n    private static final boolean DEFAULT_IS_NEARBY_SHARE_FIRST_TARGET_IN_RANKED_APP = false;\n    private boolean mIsNearbyShareFirstTargetInRankedApp =\n            DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_SYSTEMUI,\n                    SystemUiDeviceConfigFlags.IS_NEARBY_SHARE_FIRST_TARGET_IN_RANKED_APP,\n                    DEFAULT_IS_NEARBY_SHARE_FIRST_TARGET_IN_RANKED_APP);\n\n    private static final int DEFAULT_LIST_VIEW_UPDATE_DELAY_MS = 125;\n\n    @VisibleForTesting\n    int mListViewUpdateDelayMs = DeviceConfig.getInt(DeviceConfig.NAMESPACE_SYSTEMUI,\n            SystemUiDeviceConfigFlags.SHARESHEET_LIST_VIEW_UPDATE_DELAY,\n            DEFAULT_LIST_VIEW_UPDATE_DELAY_MS);\n\n    private Bundle mReplacementExtras;\n    private IntentSender mChosenComponentSender;\n    private IntentSender mRefinementIntentSender;\n    private RefinementResultReceiver mRefinementResultReceiver;\n    private ChooserTarget[] mCallerChooserTargets;\n    private ComponentName[] mFilteredComponentNames;\n\n    private Intent mReferrerFillInIntent;\n\n    private long mChooserShownTime;\n    protected boolean mIsSuccessfullySelected;\n\n    private long mQueriedSharingShortcutsTimeMs;\n\n    private int mCurrAvailableWidth = 0;\n    private int mLastNumberOfChildren = -1;\n    private int mMaxTargetsPerRow = 1;\n\n    private static final String TARGET_DETAILS_FRAGMENT_TAG = \"targetDetailsFragment\";\n\n    private static final int MAX_LOG_RANK_POSITION = 12;\n\n    private static final int MAX_EXTRA_INITIAL_INTENTS = 2;\n    private static final int MAX_EXTRA_CHOOSER_TARGETS = 2;\n\n    private SharedPreferences mPinnedSharedPrefs;\n    private static final String PINNED_SHARED_PREFS_NAME = \"chooser_pin_settings\";\n\n    @Retention(SOURCE)\n    @IntDef({CONTENT_PREVIEW_FILE, CONTENT_PREVIEW_IMAGE, CONTENT_PREVIEW_TEXT})\n    private @interface ContentPreviewType {\n    }\n\n    // Starting at 1 since 0 is considered \"undefined\" for some of the database transformations\n    // of tron logs.\n    protected static final int CONTENT_PREVIEW_IMAGE = 1;\n    protected static final int CONTENT_PREVIEW_FILE = 2;\n    protected static final int CONTENT_PREVIEW_TEXT = 3;\n    protected MetricsLogger mMetricsLogger;\n\n    private ContentPreviewCoordinator mPreviewCoord;\n    private int mScrollStatus = SCROLL_STATUS_IDLE;\n\n    @VisibleForTesting\n    protected ChooserMultiProfilePagerAdapter mChooserMultiProfilePagerAdapter;\n    private final EnterTransitionAnimationDelegate mEnterTransitionAnimationDelegate =\n            new EnterTransitionAnimationDelegate();\n\n    private boolean mRemoveSharedElements = false;\n\n    private class ContentPreviewCoordinator {\n        private static final int IMAGE_FADE_IN_MILLIS = 150;\n        private static final int IMAGE_LOAD_TIMEOUT = 1;\n        private static final int IMAGE_LOAD_INTO_VIEW = 2;\n\n        private final int mImageLoadTimeoutMillis =\n                getResources().getInteger(R.integer.config_shortAnimTime);\n\n        private final View mParentView;\n        private boolean mHideParentOnFail;\n        private boolean mAtLeastOneLoaded = false;\n\n        class LoadUriTask {\n            public final Uri mUri;\n            public final int mImageResourceId;\n            public final int mExtraCount;\n            public final Bitmap mBmp;\n\n            LoadUriTask(int imageResourceId, Uri uri, int extraCount, Bitmap bmp) {\n                this.mImageResourceId = imageResourceId;\n                this.mUri = uri;\n                this.mExtraCount = extraCount;\n                this.mBmp = bmp;\n            }\n        }\n\n        // If at least one image loads within the timeout period, allow other\n        // loads to continue. Otherwise terminate and optionally hide\n        // the parent area\n        private final Handler mHandler = new Handler() {\n            @Override\n            public void handleMessage(Message msg) {\n                switch (msg.what) {\n                    case IMAGE_LOAD_TIMEOUT:\n                        maybeHideContentPreview();\n                        break;\n\n                    case IMAGE_LOAD_INTO_VIEW:\n                        if (isFinishing()) break;\n\n                        LoadUriTask task = (LoadUriTask) msg.obj;\n                        RoundedRectImageView imageView = mParentView.findViewById(\n                                task.mImageResourceId);\n                        if (task.mBmp == null) {\n                            imageView.setVisibility(View.GONE);\n                            maybeHideContentPreview();\n                            return;\n                        }\n\n                        mAtLeastOneLoaded = true;\n                        imageView.setVisibility(View.VISIBLE);\n                        imageView.setAlpha(0.0f);\n                        imageView.setImageBitmap(task.mBmp);\n\n                        ValueAnimator fadeAnim = ObjectAnimator.ofFloat(imageView, \"alpha\", 0.0f,\n                                1.0f);\n                        fadeAnim.setInterpolator(new DecelerateInterpolator(1.0f));\n                        fadeAnim.setDuration(IMAGE_FADE_IN_MILLIS);\n                        fadeAnim.start();\n\n                        if (task.mExtraCount > 0) {\n                            imageView.setExtraImageCount(task.mExtraCount);\n                        }\n\n                        setupPreDrawForSharedElementTransition(imageView);\n                }\n            }\n        };\n\n        private void setupPreDrawForSharedElementTransition(View v) {\n            v.getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {\n                @Override\n                public boolean onPreDraw() {\n                    v.getViewTreeObserver().removeOnPreDrawListener(this);\n\n                    if (!mRemoveSharedElements && isActivityTransitionRunning()) {\n                        // Disable the window animations as it interferes with the\n                        // transition animation.\n                        getWindow().setWindowAnimations(0);\n                    }\n                    mEnterTransitionAnimationDelegate.markImagePreviewReady();\n                    return true;\n                }\n            });\n        }\n\n        ContentPreviewCoordinator(View parentView, boolean hideParentOnFail) {\n            super();\n\n            this.mParentView = parentView;\n            this.mHideParentOnFail = hideParentOnFail;\n        }\n\n        private void loadUriIntoView(final int imageResourceId, final Uri uri,\n                final int extraImages) {\n            mHandler.sendEmptyMessageDelayed(IMAGE_LOAD_TIMEOUT, mImageLoadTimeoutMillis);\n\n            AsyncTask.THREAD_POOL_EXECUTOR.execute(() -> {\n                int size = getResources().getDimensionPixelSize(\n                        R.dimen.chooser_preview_image_max_dimen);\n                final Bitmap bmp = loadThumbnail(uri, new Size(size, size));\n                final Message msg = Message.obtain();\n                msg.what = IMAGE_LOAD_INTO_VIEW;\n                msg.obj = new LoadUriTask(imageResourceId, uri, extraImages, bmp);\n                mHandler.sendMessage(msg);\n            });\n        }\n\n        private void cancelLoads() {\n            mHandler.removeMessages(IMAGE_LOAD_INTO_VIEW);\n            mHandler.removeMessages(IMAGE_LOAD_TIMEOUT);\n        }\n\n        private void maybeHideContentPreview() {\n            if (!mAtLeastOneLoaded) {\n                if (mHideParentOnFail) {\n                    Log.i(TAG, \"Hiding image preview area. Timed out waiting for preview to load\"\n                            + \" within \" + mImageLoadTimeoutMillis + \"ms.\");\n                    collapseParentView();\n                    if (shouldShowTabs()) {\n                        hideStickyContentPreview();\n                    } else if (mChooserMultiProfilePagerAdapter.getCurrentRootAdapter() != null) {\n                        mChooserMultiProfilePagerAdapter.getCurrentRootAdapter()\n                                .hideContentPreview();\n                    }\n                    mHideParentOnFail = false;\n                }\n                mRemoveSharedElements = true;\n                mEnterTransitionAnimationDelegate.markImagePreviewReady();\n            }\n        }\n\n        private void collapseParentView() {\n            // This will effectively hide the content preview row by forcing the height\n            // to zero. It is faster than forcing a relayout of the listview\n            final View v = mParentView;\n            int widthSpec = MeasureSpec.makeMeasureSpec(v.getWidth(), MeasureSpec.EXACTLY);\n            int heightSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.EXACTLY);\n            v.measure(widthSpec, heightSpec);\n            v.getLayoutParams().height = 0;\n            v.layout(v.getLeft(), v.getTop(), v.getRight(), v.getTop());\n            v.invalidate();\n        }\n    }\n\n    private final ChooserHandler mChooserHandler = new ChooserHandler();\n\n    private class ChooserHandler extends Handler {\n        private static final int LIST_VIEW_UPDATE_MESSAGE = 6;\n        private static final int SHORTCUT_MANAGER_ALL_SHARE_TARGET_RESULTS = 7;\n\n        private void removeAllMessages() {\n            removeMessages(LIST_VIEW_UPDATE_MESSAGE);\n            removeMessages(SHORTCUT_MANAGER_ALL_SHARE_TARGET_RESULTS);\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            if (mChooserMultiProfilePagerAdapter.getActiveListAdapter() == null || isDestroyed()) {\n                return;\n            }\n\n            switch (msg.what) {\n                case LIST_VIEW_UPDATE_MESSAGE:\n                    if (DEBUG) {\n                        Log.d(TAG, \"LIST_VIEW_UPDATE_MESSAGE; \");\n                    }\n\n                    UserHandle userHandle = (UserHandle) msg.obj;\n                    mChooserMultiProfilePagerAdapter.getListAdapterForUserHandle(userHandle)\n                            .refreshListView();\n                    break;\n\n                case SHORTCUT_MANAGER_ALL_SHARE_TARGET_RESULTS:\n                    if (DEBUG) Log.d(TAG, \"SHORTCUT_MANAGER_ALL_SHARE_TARGET_RESULTS\");\n                    final ServiceResultInfo[] resultInfos = (ServiceResultInfo[]) msg.obj;\n                    for (ServiceResultInfo resultInfo : resultInfos) {\n                        if (resultInfo.resultTargets != null) {\n                            ChooserListAdapter adapterForUserHandle =\n                                    mChooserMultiProfilePagerAdapter.getListAdapterForUserHandle(\n                                            resultInfo.userHandle);\n                            if (adapterForUserHandle != null) {\n                                adapterForUserHandle.addServiceResults(\n                                        resultInfo.originalTarget,\n                                        resultInfo.resultTargets, msg.arg1,\n                                        mDirectShareShortcutInfoCache);\n                            }\n                        }\n                    }\n\n                    logDirectShareTargetReceived(\n                            MetricsEvent.ACTION_DIRECT_SHARE_TARGETS_LOADED_SHORTCUT_MANAGER);\n                    sendVoiceChoicesIfNeeded();\n                    getChooserActivityLogger().logSharesheetDirectLoadComplete();\n\n                    mChooserMultiProfilePagerAdapter.getActiveListAdapter()\n                            .completeServiceTargetLoading();\n                    break;\n\n                default:\n                    super.handleMessage(msg);\n            }\n        }\n    };\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        if (Settings.Secure.getIntForUser(getContentResolver(),\n                Settings.Secure.SECURE_FRP_MODE, 0,\n                getUserId()) == 1) {\n            Log.e(TAG, \"Sharing disabled due to active FRP lock.\");\n            super.onCreate(savedInstanceState);\n            finish();\n            return;\n        }\n        final long intentReceivedTime = System.currentTimeMillis();\n        mLatencyTracker.onActionStart(ACTION_LOAD_SHARE_SHEET);\n\n        getChooserActivityLogger().logSharesheetTriggered();\n        // This is the only place this value is being set. Effectively final.\n        mIsAppPredictorComponentAvailable = isAppPredictionServiceAvailable();\n\n        mIsSuccessfullySelected = false;\n        Intent intent = getIntent();\n        Parcelable targetParcelable = intent.getParcelableExtra(Intent.EXTRA_INTENT);\n        if (targetParcelable instanceof Uri) {\n            try {\n                targetParcelable = Intent.parseUri(targetParcelable.toString(),\n                        Intent.URI_INTENT_SCHEME);\n            } catch (URISyntaxException ex) {\n                // doesn't parse as an intent; let the next test fail and error out\n            }\n        }\n\n        if (!(targetParcelable instanceof Intent)) {\n            Log.w(\"ChooserActivity\", \"Target is not an intent: \" + targetParcelable);\n            finish();\n            super.onCreate(null);\n            return;\n        }\n        Intent target = (Intent) targetParcelable;\n        if (target != null) {\n            modifyTargetIntent(target);\n        }\n        Parcelable[] targetsParcelable\n                = intent.getParcelableArrayExtra(Intent.EXTRA_ALTERNATE_INTENTS);\n        if (targetsParcelable != null) {\n            final boolean offset = target == null;\n            Intent[] additionalTargets =\n                    new Intent[offset ? targetsParcelable.length - 1 : targetsParcelable.length];\n            for (int i = 0; i < targetsParcelable.length; i++) {\n                if (!(targetsParcelable[i] instanceof Intent)) {\n                    Log.w(TAG, \"EXTRA_ALTERNATE_INTENTS array entry #\" + i + \" is not an Intent: \"\n                            + targetsParcelable[i]);\n                    finish();\n                    super.onCreate(null);\n                    return;\n                }\n                final Intent additionalTarget = (Intent) targetsParcelable[i];\n                if (i == 0 && target == null) {\n                    target = additionalTarget;\n                    modifyTargetIntent(target);\n                } else {\n                    additionalTargets[offset ? i - 1 : i] = additionalTarget;\n                    modifyTargetIntent(additionalTarget);\n                }\n            }\n            setAdditionalTargets(additionalTargets);\n        }\n\n        mReplacementExtras = intent.getBundleExtra(Intent.EXTRA_REPLACEMENT_EXTRAS);\n\n        // Do not allow the title to be changed when sharing content\n        CharSequence title = null;\n        if (target != null) {\n            if (!isSendAction(target)) {\n                title = intent.getCharSequenceExtra(Intent.EXTRA_TITLE);\n            } else {\n                Log.w(TAG, \"Ignoring intent's EXTRA_TITLE, deprecated in P. You may wish to set a\"\n                        + \" preview title by using EXTRA_TITLE property of the wrapped\"\n                        + \" EXTRA_INTENT.\");\n            }\n        }\n\n        int defaultTitleRes = 0;\n        if (title == null) {\n            defaultTitleRes = com.android.internal.R.string.chooseActivity;\n        }\n\n        Parcelable[] pa = intent.getParcelableArrayExtra(Intent.EXTRA_INITIAL_INTENTS);\n        Intent[] initialIntents = null;\n        if (pa != null) {\n            int count = Math.min(pa.length, MAX_EXTRA_INITIAL_INTENTS);\n            initialIntents = new Intent[count];\n            for (int i = 0; i < count; i++) {\n                if (!(pa[i] instanceof Intent)) {\n                    Log.w(TAG, \"Initial intent #\" + i + \" not an Intent: \" + pa[i]);\n                    finish();\n                    super.onCreate(null);\n                    return;\n                }\n                final Intent in = (Intent) pa[i];\n                modifyTargetIntent(in);\n                initialIntents[i] = in;\n            }\n        }\n\n        mReferrerFillInIntent = new Intent().putExtra(Intent.EXTRA_REFERRER, getReferrer());\n\n        mChosenComponentSender = intent.getParcelableExtra(\n                Intent.EXTRA_CHOSEN_COMPONENT_INTENT_SENDER);\n        mRefinementIntentSender = intent.getParcelableExtra(\n                Intent.EXTRA_CHOOSER_REFINEMENT_INTENT_SENDER);\n        setSafeForwardingMode(true);\n\n        mPinnedSharedPrefs = getPinnedSharedPrefs(this);\n\n        pa = intent.getParcelableArrayExtra(Intent.EXTRA_EXCLUDE_COMPONENTS);\n\n\n        // Exclude out Nearby from main list if chip is present, to avoid duplication\n        ComponentName nearbySharingComponent = getNearbySharingComponent();\n        boolean shouldFilterNearby = !shouldNearbyShareBeFirstInRankedRow()\n                && nearbySharingComponent != null;\n\n        if (pa != null) {\n            ComponentName[] names = new ComponentName[pa.length + (shouldFilterNearby ? 1 : 0)];\n            for (int i = 0; i < pa.length; i++) {\n                if (!(pa[i] instanceof ComponentName)) {\n                    Log.w(TAG, \"Filtered component #\" + i + \" not a ComponentName: \" + pa[i]);\n                    names = null;\n                    break;\n                }\n                names[i] = (ComponentName) pa[i];\n            }\n            if (shouldFilterNearby) {\n                names[names.length - 1] = nearbySharingComponent;\n            }\n\n            mFilteredComponentNames = names;\n        } else if (shouldFilterNearby) {\n            mFilteredComponentNames = new ComponentName[1];\n            mFilteredComponentNames[0] = nearbySharingComponent;\n        }\n\n        pa = intent.getParcelableArrayExtra(Intent.EXTRA_CHOOSER_TARGETS);\n        if (pa != null) {\n            int count = Math.min(pa.length, MAX_EXTRA_CHOOSER_TARGETS);\n            ChooserTarget[] targets = new ChooserTarget[count];\n            for (int i = 0; i < count; i++) {\n                if (!(pa[i] instanceof ChooserTarget)) {\n                    Log.w(TAG, \"Chooser target #\" + i + \" not a ChooserTarget: \" + pa[i]);\n                    targets = null;\n                    break;\n                }\n                ChooserTarget chooserTarget = (ChooserTarget) pa[i];\n                if (!hasValidIcon(chooserTarget)) {\n                    chooserTarget = removeIcon(chooserTarget);\n                }\n                targets[i] = chooserTarget;\n            }\n            mCallerChooserTargets = targets;\n        }\n\n        mMaxTargetsPerRow = getResources().getInteger(R.integer.config_chooser_max_targets_per_row);\n        mShouldDisplayLandscape =\n                shouldDisplayLandscape(getResources().getConfiguration().orientation);\n        setRetainInOnStop(intent.getBooleanExtra(EXTRA_PRIVATE_RETAIN_IN_ON_STOP, false));\n        super.onCreate(savedInstanceState, target, title, defaultTitleRes, initialIntents,\n                null, false);\n\n        mChooserShownTime = System.currentTimeMillis();\n        final long systemCost = mChooserShownTime - intentReceivedTime;\n\n        getMetricsLogger().write(new LogMaker(MetricsEvent.ACTION_ACTIVITY_CHOOSER_SHOWN)\n                .setSubtype(isWorkProfile() ? MetricsEvent.MANAGED_PROFILE :\n                        MetricsEvent.PARENT_PROFILE)\n                .addTaggedData(MetricsEvent.FIELD_SHARESHEET_MIMETYPE, target.getType())\n                .addTaggedData(MetricsEvent.FIELD_TIME_TO_APP_TARGETS, systemCost));\n\n        if (mResolverDrawerLayout != null) {\n            mResolverDrawerLayout.addOnLayoutChangeListener(this::handleLayoutChange);\n\n            // expand/shrink direct share 4 -> 8 viewgroup\n            if (isSendAction(target)) {\n                mResolverDrawerLayout.setOnScrollChangeListener(this::handleScroll);\n            }\n\n            mResolverDrawerLayout.setOnCollapsedChangedListener(\n                    new ResolverDrawerLayout.OnCollapsedChangedListener() {\n\n                        // Only consider one expansion per activity creation\n                        private boolean mWrittenOnce = false;\n\n                        @Override\n                        public void onCollapsedChanged(boolean isCollapsed) {\n                            if (!isCollapsed && !mWrittenOnce) {\n                                incrementNumSheetExpansions();\n                                mWrittenOnce = true;\n                            }\n                            getChooserActivityLogger()\n                                    .logSharesheetExpansionChanged(isCollapsed);\n                        }\n                    });\n        }\n\n        if (DEBUG) {\n            Log.d(TAG, \"System Time Cost is \" + systemCost);\n        }\n\n        getChooserActivityLogger().logShareStarted(\n                FrameworkStatsLog.SHARESHEET_STARTED,\n                getReferrerPackageName(),\n                target.getType(),\n                mCallerChooserTargets == null ? 0 : mCallerChooserTargets.length,\n                initialIntents == null ? 0 : initialIntents.length,\n                isWorkProfile(),\n                findPreferredContentPreview(getTargetIntent(), getContentResolver()),\n                target.getAction()\n        );\n        mDirectShareShortcutInfoCache = new HashMap<>();\n\n        setEnterSharedElementCallback(new SharedElementCallback() {\n            @Override\n            public void onMapSharedElements(List<String> names, Map<String, View> sharedElements) {\n                if (mRemoveSharedElements) {\n                    names.remove(FIRST_IMAGE_PREVIEW_TRANSITION_NAME);\n                    sharedElements.remove(FIRST_IMAGE_PREVIEW_TRANSITION_NAME);\n                }\n                super.onMapSharedElements(names, sharedElements);\n                mRemoveSharedElements = false;\n            }\n        });\n        mEnterTransitionAnimationDelegate.postponeTransition();\n    }\n\n    @Override\n    protected int appliedThemeResId() {\n        return R.style.Theme_DeviceDefault_Chooser;\n    }\n\n    private AppPredictor setupAppPredictorForUser(UserHandle userHandle,\n            AppPredictor.Callback appPredictorCallback) {\n        AppPredictor appPredictor = getAppPredictorForDirectShareIfEnabled(userHandle);\n        if (appPredictor == null) {\n            return null;\n        }\n        mDirectShareAppTargetCache = new HashMap<>();\n        appPredictor.registerPredictionUpdates(this.getMainExecutor(), appPredictorCallback);\n        return appPredictor;\n    }\n\n    private AppPredictor.Callback createAppPredictorCallback(\n            ChooserListAdapter chooserListAdapter) {\n        return resultList -> {\n            if (isFinishing() || isDestroyed()) {\n                return;\n            }\n            if (chooserListAdapter.getCount() == 0) {\n                return;\n            }\n            if (resultList.isEmpty()\n                    && shouldQueryShortcutManager(chooserListAdapter.getUserHandle())) {\n                // APS may be disabled, so try querying targets ourselves.\n                queryDirectShareTargets(chooserListAdapter, true);\n                return;\n            }\n            final List<ShortcutManager.ShareShortcutInfo> shareShortcutInfos =\n                    new ArrayList<>();\n\n            List<AppTarget> shortcutResults = new ArrayList<>();\n            for (AppTarget appTarget : resultList) {\n                if (appTarget.getShortcutInfo() == null) {\n                    continue;\n                }\n                shortcutResults.add(appTarget);\n            }\n            resultList = shortcutResults;\n            for (AppTarget appTarget : resultList) {\n                shareShortcutInfos.add(new ShortcutManager.ShareShortcutInfo(\n                        appTarget.getShortcutInfo(),\n                        new ComponentName(\n                                appTarget.getPackageName(), appTarget.getClassName())));\n            }\n            sendShareShortcutInfoList(shareShortcutInfos, chooserListAdapter, resultList,\n                    chooserListAdapter.getUserHandle());\n        };\n    }\n\n    static SharedPreferences getPinnedSharedPrefs(Context context) {\n        // The code below is because in the android:ui process, no one can hear you scream.\n        // The package info in the context isn't initialized in the way it is for normal apps,\n        // so the standard, name-based context.getSharedPreferences doesn't work. Instead, we\n        // build the path manually below using the same policy that appears in ContextImpl.\n        // This fails silently under the hood if there's a problem, so if we find ourselves in\n        // the case where we don't have access to credential encrypted storage we just won't\n        // have our pinned target info.\n        final File prefsFile = new File(new File(\n                Environment.getDataUserCePackageDirectory(StorageManager.UUID_PRIVATE_INTERNAL,\n                        context.getUserId(), context.getPackageName()),\n                \"shared_prefs\"),\n                PINNED_SHARED_PREFS_NAME + \".xml\");\n        return context.getSharedPreferences(prefsFile, MODE_PRIVATE);\n    }\n\n    @Override\n    protected AbstractMultiProfilePagerAdapter createMultiProfilePagerAdapter(\n            Intent[] initialIntents,\n            List<ResolveInfo> rList,\n            boolean filterLastUsed) {\n        if (shouldShowTabs()) {\n            mChooserMultiProfilePagerAdapter = createChooserMultiProfilePagerAdapterForTwoProfiles(\n                    initialIntents, rList, filterLastUsed);\n        } else {\n            mChooserMultiProfilePagerAdapter = createChooserMultiProfilePagerAdapterForOneProfile(\n                    initialIntents, rList, filterLastUsed);\n        }\n        return mChooserMultiProfilePagerAdapter;\n    }\n\n    private ChooserMultiProfilePagerAdapter createChooserMultiProfilePagerAdapterForOneProfile(\n            Intent[] initialIntents,\n            List<ResolveInfo> rList,\n            boolean filterLastUsed) {\n        ChooserGridAdapter adapter = createChooserGridAdapter(\n                /* context */ this,\n                /* payloadIntents */ mIntents,\n                initialIntents,\n                rList,\n                filterLastUsed,\n                /* userHandle */ UserHandle.of(UserHandle.myUserId()));\n        return new ChooserMultiProfilePagerAdapter(\n                /* context */ this,\n                adapter,\n                getPersonalProfileUserHandle(),\n                /* workProfileUserHandle= */ null,\n                isSendAction(getTargetIntent()), mMaxTargetsPerRow);\n    }\n\n    private ChooserMultiProfilePagerAdapter createChooserMultiProfilePagerAdapterForTwoProfiles(\n            Intent[] initialIntents,\n            List<ResolveInfo> rList,\n            boolean filterLastUsed) {\n        int selectedProfile = findSelectedProfile();\n        ChooserGridAdapter personalAdapter = createChooserGridAdapter(\n                /* context */ this,\n                /* payloadIntents */ mIntents,\n                selectedProfile == PROFILE_PERSONAL ? initialIntents : null,\n                rList,\n                filterLastUsed,\n                /* userHandle */ getPersonalProfileUserHandle());\n        ChooserGridAdapter workAdapter = createChooserGridAdapter(\n                /* context */ this,\n                /* payloadIntents */ mIntents,\n                selectedProfile == PROFILE_WORK ? initialIntents : null,\n                rList,\n                filterLastUsed,\n                /* userHandle */ getWorkProfileUserHandle());\n        return new ChooserMultiProfilePagerAdapter(\n                /* context */ this,\n                personalAdapter,\n                workAdapter,\n                selectedProfile,\n                getPersonalProfileUserHandle(),\n                getWorkProfileUserHandle(),\n                isSendAction(getTargetIntent()), mMaxTargetsPerRow);\n    }\n\n    private int findSelectedProfile() {\n        int selectedProfile = getSelectedProfileExtra();\n        if (selectedProfile == -1) {\n            selectedProfile = getProfileForUser(getUser());\n        }\n        return selectedProfile;\n    }\n\n    @Override\n    protected boolean postRebuildList(boolean rebuildCompleted) {\n        updateStickyContentPreview();\n        if (shouldShowStickyContentPreview()\n                || mChooserMultiProfilePagerAdapter\n                        .getCurrentRootAdapter().getSystemRowCount() != 0) {\n            logActionShareWithPreview();\n        }\n        return postRebuildListInternal(rebuildCompleted);\n    }\n\n    /**\n     * Returns true if app prediction service is defined and the component exists on device.\n     */\n    private boolean isAppPredictionServiceAvailable() {\n        return getPackageManager().getAppPredictionServicePackageName() != null;\n    }\n\n    /**\n     * Check if the profile currently used is a work profile.\n     * @return true if it is work profile, false if it is parent profile (or no work profile is\n     * set up)\n     */\n    protected boolean isWorkProfile() {\n        return getSystemService(UserManager.class)\n                .getUserInfo(UserHandle.myUserId()).isManagedProfile();\n    }\n\n    @Override\n    protected PackageMonitor createPackageMonitor(ResolverListAdapter listAdapter) {\n        return new PackageMonitor() {\n            @Override\n            public void onSomePackagesChanged() {\n                handlePackagesChanged(listAdapter);\n            }\n        };\n    }\n\n    /**\n     * Update UI to reflect changes in data.\n     */\n    public void handlePackagesChanged() {\n        handlePackagesChanged(/* listAdapter */ null);\n    }\n\n    /**\n     * Update UI to reflect changes in data.\n     * <p>If {@code listAdapter} is {@code null}, both profile list adapters are updated if\n     * available.\n     */\n    private void handlePackagesChanged(@Nullable ResolverListAdapter listAdapter) {\n        // Refresh pinned items\n        mPinnedSharedPrefs = getPinnedSharedPrefs(this);\n        if (listAdapter == null) {\n            mChooserMultiProfilePagerAdapter.getActiveListAdapter().handlePackagesChanged();\n            if (mChooserMultiProfilePagerAdapter.getCount() > 1) {\n                mChooserMultiProfilePagerAdapter.getInactiveListAdapter().handlePackagesChanged();\n            }\n        } else {\n            listAdapter.handlePackagesChanged();\n        }\n        updateProfileViewButton();\n    }\n\n    private void onCopyButtonClicked(View v) {\n        Intent targetIntent = getTargetIntent();\n        if (targetIntent == null) {\n            finish();\n        } else {\n            final String action = targetIntent.getAction();\n\n            ClipData clipData = null;\n            if (Intent.ACTION_SEND.equals(action)) {\n                String extraText = targetIntent.getStringExtra(Intent.EXTRA_TEXT);\n                Uri extraStream = targetIntent.getParcelableExtra(Intent.EXTRA_STREAM);\n\n                if (extraText != null) {\n                    clipData = ClipData.newPlainText(null, extraText);\n                } else if (extraStream != null) {\n                    clipData = ClipData.newUri(getContentResolver(), null, extraStream);\n                } else {\n                    Log.w(TAG, \"No data available to copy to clipboard\");\n                    return;\n                }\n            } else if (Intent.ACTION_SEND_MULTIPLE.equals(action)) {\n                final ArrayList<Uri> streams = targetIntent.getParcelableArrayListExtra(\n                        Intent.EXTRA_STREAM);\n                clipData = ClipData.newUri(getContentResolver(), null, streams.get(0));\n                for (int i = 1; i < streams.size(); i++) {\n                    clipData.addItem(getContentResolver(), new ClipData.Item(streams.get(i)));\n                }\n            } else {\n                // expected to only be visible with ACTION_SEND or ACTION_SEND_MULTIPLE\n                // so warn about unexpected action\n                Log.w(TAG, \"Action (\" + action + \") not supported for copying to clipboard\");\n                return;\n            }\n\n            ClipboardManager clipboardManager = (ClipboardManager) getSystemService(\n                    Context.CLIPBOARD_SERVICE);\n            clipboardManager.setPrimaryClipAsPackage(clipData, getReferrerPackageName());\n\n            // Log share completion via copy\n            LogMaker targetLogMaker = new LogMaker(\n                    MetricsEvent.ACTION_ACTIVITY_CHOOSER_PICKED_SYSTEM_TARGET).setSubtype(1);\n            getMetricsLogger().write(targetLogMaker);\n            getChooserActivityLogger().logShareTargetSelected(\n                    SELECTION_TYPE_COPY,\n                    \"\",\n                    -1,\n                    false);\n\n            setResult(RESULT_OK);\n            finish();\n        }\n    }\n\n    @Override\n    protected void onResume() {\n        super.onResume();\n        Log.d(TAG, \"onResume: \" + getComponentName().flattenToShortString());\n    }\n\n    @Override\n    public void onConfigurationChanged(Configuration newConfig) {\n        super.onConfigurationChanged(newConfig);\n        ViewPager viewPager = findViewById(R.id.profile_pager);\n        if (viewPager.isLayoutRtl()) {\n            mMultiProfilePagerAdapter.setupViewPager(viewPager);\n        }\n\n        mShouldDisplayLandscape = shouldDisplayLandscape(newConfig.orientation);\n        mMaxTargetsPerRow = getResources().getInteger(R.integer.config_chooser_max_targets_per_row);\n        adjustPreviewWidth(newConfig.orientation, null);\n        updateStickyContentPreview();\n        updateTabPadding();\n    }\n\n    private boolean shouldDisplayLandscape(int orientation) {\n        // Sharesheet fixes the # of items per row and therefore can not correctly lay out\n        // when in the restricted size of multi-window mode. In the future, would be nice\n        // to use minimum dp size requirements instead\n        return orientation == Configuration.ORIENTATION_LANDSCAPE && !isInMultiWindowMode();\n    }\n\n    private void adjustPreviewWidth(int orientation, View parent) {\n        int width = -1;\n        if (mShouldDisplayLandscape) {\n            width = getResources().getDimensionPixelSize(R.dimen.chooser_preview_width);\n        }\n\n        parent = parent == null ? getWindow().getDecorView() : parent;\n\n        updateLayoutWidth(R.id.content_preview_text_layout, width, parent);\n        updateLayoutWidth(R.id.content_preview_title_layout, width, parent);\n        updateLayoutWidth(R.id.content_preview_file_layout, width, parent);\n    }\n\n    private void updateTabPadding() {\n        if (shouldShowTabs()) {\n            View tabs = findViewById(R.id.tabs);\n            float iconSize = getResources().getDimension(R.dimen.chooser_icon_size);\n            // The entire width consists of icons or padding. Divide the item padding in half to get\n            // paddingHorizontal.\n            float padding = (tabs.getWidth() - mMaxTargetsPerRow * iconSize)\n                    / mMaxTargetsPerRow / 2;\n            // Subtract the margin the buttons already have.\n            padding -= getResources().getDimension(R.dimen.resolver_profile_tab_margin);\n            tabs.setPadding((int) padding, 0, (int) padding, 0);\n        }\n    }\n\n    private void updateLayoutWidth(int layoutResourceId, int width, View parent) {\n        View view = parent.findViewById(layoutResourceId);\n        if (view != null && view.getLayoutParams() != null) {\n            LayoutParams params = view.getLayoutParams();\n            params.width = width;\n            view.setLayoutParams(params);\n        }\n    }\n\n    private ViewGroup createContentPreviewView(ViewGroup parent) {\n        Intent targetIntent = getTargetIntent();\n        int previewType = findPreferredContentPreview(targetIntent, getContentResolver());\n        return displayContentPreview(previewType, targetIntent, getLayoutInflater(), parent);\n    }\n\n    @VisibleForTesting\n    protected ComponentName getNearbySharingComponent() {\n        String nearbyComponent = Settings.Secure.getString(\n                getContentResolver(),\n                Settings.Secure.NEARBY_SHARING_COMPONENT);\n        if (TextUtils.isEmpty(nearbyComponent)) {\n            nearbyComponent = getString(R.string.config_defaultNearbySharingComponent);\n        }\n        if (TextUtils.isEmpty(nearbyComponent)) {\n            return null;\n        }\n        return ComponentName.unflattenFromString(nearbyComponent);\n    }\n\n    @VisibleForTesting\n    protected @Nullable ComponentName getEditSharingComponent() {\n        String editorPackage = getApplicationContext().getString(R.string.config_systemImageEditor);\n        if (editorPackage == null || TextUtils.isEmpty(editorPackage)) {\n            return null;\n        }\n        return ComponentName.unflattenFromString(editorPackage);\n    }\n\n    @VisibleForTesting\n    protected TargetInfo getEditSharingTarget(Intent originalIntent) {\n        final ComponentName cn = getEditSharingComponent();\n\n        final Intent resolveIntent = new Intent(originalIntent);\n        resolveIntent.setComponent(cn);\n        resolveIntent.setAction(Intent.ACTION_EDIT);\n        final ResolveInfo ri = getPackageManager().resolveActivity(\n                resolveIntent, PackageManager.GET_META_DATA);\n        if (ri == null || ri.activityInfo == null) {\n            Log.e(TAG, \"Device-specified image edit component (\" + cn\n                    + \") not available\");\n            return null;\n        }\n\n        final DisplayResolveInfo dri = new DisplayResolveInfo(\n                originalIntent, ri, getString(R.string.screenshot_edit), \"\", resolveIntent, null);\n        dri.setDisplayIcon(getDrawable(R.drawable.ic_screenshot_edit));\n        return dri;\n    }\n\n\n    @VisibleForTesting\n    protected TargetInfo getNearbySharingTarget(Intent originalIntent) {\n        final ComponentName cn = getNearbySharingComponent();\n        if (cn == null) return null;\n\n        final Intent resolveIntent = new Intent(originalIntent);\n        resolveIntent.setComponent(cn);\n        final ResolveInfo ri = getPackageManager().resolveActivity(\n                resolveIntent, PackageManager.GET_META_DATA);\n        if (ri == null || ri.activityInfo == null) {\n            Log.e(TAG, \"Device-specified nearby sharing component (\" + cn\n                    + \") not available\");\n            return null;\n        }\n\n        // Allow the nearby sharing component to provide a more appropriate icon and label\n        // for the chip.\n        CharSequence name = null;\n        Drawable icon = null;\n        final Bundle metaData = ri.activityInfo.metaData;\n        if (metaData != null) {\n            try {\n                final Resources pkgRes = getPackageManager().getResourcesForActivity(cn);\n                final int nameResId = metaData.getInt(CHIP_LABEL_METADATA_KEY);\n                name = pkgRes.getString(nameResId);\n                final int resId = metaData.getInt(CHIP_ICON_METADATA_KEY);\n                icon = pkgRes.getDrawable(resId);\n            } catch (Resources.NotFoundException ex) {\n            } catch (NameNotFoundException ex) {\n            }\n        }\n        if (TextUtils.isEmpty(name)) {\n            name = ri.loadLabel(getPackageManager());\n        }\n        if (icon == null) {\n            icon = ri.loadIcon(getPackageManager());\n        }\n\n        final DisplayResolveInfo dri = new DisplayResolveInfo(\n                originalIntent, ri, name, \"\", resolveIntent, null);\n        dri.setDisplayIcon(icon);\n        return dri;\n    }\n\n    private Button createActionButton(Drawable icon, CharSequence title, View.OnClickListener r) {\n        Button b = (Button) LayoutInflater.from(this).inflate(R.layout.chooser_action_button, null);\n        if (icon != null) {\n            final int size = getResources()\n                    .getDimensionPixelSize(R.dimen.chooser_action_button_icon_size);\n            icon.setBounds(0, 0, size, size);\n            b.setCompoundDrawablesRelative(icon, null, null, null);\n        }\n        b.setText(title);\n        b.setOnClickListener(r);\n        return b;\n    }\n\n    private Button createCopyButton() {\n        final Button b = createActionButton(\n                getDrawable(R.drawable.ic_menu_copy_material),\n                getString(R.string.copy), this::onCopyButtonClicked);\n        b.setId(R.id.chooser_copy_button);\n        return b;\n    }\n\n    private @Nullable Button createNearbyButton(Intent originalIntent) {\n        final TargetInfo ti = getNearbySharingTarget(originalIntent);\n        if (ti == null) return null;\n\n        final Button b = createActionButton(\n                ti.getDisplayIcon(this),\n                ti.getDisplayLabel(),\n                (View unused) -> {\n                    // Log share completion via nearby\n                    getChooserActivityLogger().logShareTargetSelected(\n                            SELECTION_TYPE_NEARBY,\n                            \"\",\n                            -1,\n                            false);\n                    // Action bar is user-independent, always start as primary\n                    safelyStartActivityAsUser(ti, getPersonalProfileUserHandle());\n                    finish();\n                }\n        );\n        b.setId(R.id.chooser_nearby_button);\n        return b;\n    }\n\n    private @Nullable Button createEditButton(Intent originalIntent) {\n        final TargetInfo ti = getEditSharingTarget(originalIntent);\n        if (ti == null) return null;\n\n        final Button b = createActionButton(\n                ti.getDisplayIcon(this),\n                ti.getDisplayLabel(),\n                (View unused) -> {\n                    // Log share completion via edit\n                    getChooserActivityLogger().logShareTargetSelected(\n                            SELECTION_TYPE_EDIT,\n                            \"\",\n                            -1,\n                            false);\n                    // Action bar is user-independent, always start as primary\n                    safelyStartActivityAsUser(ti, getPersonalProfileUserHandle());\n                    finish();\n                }\n        );\n        b.setId(R.id.chooser_edit_button);\n        return b;\n    }\n\n    private void addActionButton(ViewGroup parent, Button b) {\n        if (b == null) return;\n        final ViewGroup.MarginLayoutParams lp = new ViewGroup.MarginLayoutParams(\n                        LayoutParams.WRAP_CONTENT,\n                        LayoutParams.WRAP_CONTENT\n                );\n        final int gap = getResources().getDimensionPixelSize(R.dimen.resolver_icon_margin) / 2;\n        lp.setMarginsRelative(gap, 0, gap, 0);\n        parent.addView(b, lp);\n    }\n\n    private ViewGroup displayContentPreview(@ContentPreviewType int previewType,\n            Intent targetIntent, LayoutInflater layoutInflater, ViewGroup parent) {\n        ViewGroup layout = null;\n\n        switch (previewType) {\n            case CONTENT_PREVIEW_TEXT:\n                layout = displayTextContentPreview(targetIntent, layoutInflater, parent);\n                break;\n            case CONTENT_PREVIEW_IMAGE:\n                layout = displayImageContentPreview(targetIntent, layoutInflater, parent);\n                break;\n            case CONTENT_PREVIEW_FILE:\n                layout = displayFileContentPreview(targetIntent, layoutInflater, parent);\n                break;\n            default:\n                Log.e(TAG, \"Unexpected content preview type: \" + previewType);\n        }\n\n        if (layout != null) {\n            adjustPreviewWidth(getResources().getConfiguration().orientation, layout);\n        }\n        if (previewType != CONTENT_PREVIEW_IMAGE) {\n            mEnterTransitionAnimationDelegate.markImagePreviewReady();\n        }\n\n        return layout;\n    }\n\n    private ViewGroup displayTextContentPreview(Intent targetIntent, LayoutInflater layoutInflater,\n            ViewGroup parent) {\n        ViewGroup contentPreviewLayout = (ViewGroup) layoutInflater.inflate(\n                R.layout.chooser_grid_preview_text, parent, false);\n\n        final ViewGroup actionRow =\n                (ViewGroup) contentPreviewLayout.findViewById(R.id.chooser_action_row);\n        addActionButton(actionRow, createCopyButton());\n        if (shouldNearbyShareBeIncludedAsActionButton()) {\n            addActionButton(actionRow, createNearbyButton(targetIntent));\n        }\n\n        CharSequence sharingText = targetIntent.getCharSequenceExtra(Intent.EXTRA_TEXT);\n        if (sharingText == null) {\n            contentPreviewLayout.findViewById(R.id.content_preview_text_layout).setVisibility(\n                    View.GONE);\n        } else {\n            TextView textView = contentPreviewLayout.findViewById(R.id.content_preview_text);\n            textView.setText(sharingText);\n        }\n\n        String previewTitle = targetIntent.getStringExtra(Intent.EXTRA_TITLE);\n        if (TextUtils.isEmpty(previewTitle)) {\n            contentPreviewLayout.findViewById(R.id.content_preview_title_layout).setVisibility(\n                    View.GONE);\n        } else {\n            TextView previewTitleView = contentPreviewLayout.findViewById(\n                    R.id.content_preview_title);\n            previewTitleView.setText(previewTitle);\n\n            ClipData previewData = targetIntent.getClipData();\n            Uri previewThumbnail = null;\n            if (previewData != null) {\n                if (previewData.getItemCount() > 0) {\n                    ClipData.Item previewDataItem = previewData.getItemAt(0);\n                    previewThumbnail = previewDataItem.getUri();\n                }\n            }\n\n            ImageView previewThumbnailView = contentPreviewLayout.findViewById(\n                    R.id.content_preview_thumbnail);\n            if (!validForContentPreview(previewThumbnail)) {\n                previewThumbnailView.setVisibility(View.GONE);\n            } else {\n                mPreviewCoord = new ContentPreviewCoordinator(contentPreviewLayout, false);\n                mPreviewCoord.loadUriIntoView(R.id.content_preview_thumbnail, previewThumbnail, 0);\n            }\n        }\n\n        return contentPreviewLayout;\n    }\n\n    private ViewGroup displayImageContentPreview(Intent targetIntent, LayoutInflater layoutInflater,\n            ViewGroup parent) {\n        ViewGroup contentPreviewLayout = (ViewGroup) layoutInflater.inflate(\n                R.layout.chooser_grid_preview_image, parent, false);\n        ViewGroup imagePreview = contentPreviewLayout.findViewById(R.id.content_preview_image_area);\n\n        final ViewGroup actionRow =\n                (ViewGroup) contentPreviewLayout.findViewById(R.id.chooser_action_row);\n        //TODO: addActionButton(actionRow, createCopyButton());\n        if (shouldNearbyShareBeIncludedAsActionButton()) {\n            addActionButton(actionRow, createNearbyButton(targetIntent));\n        }\n        addActionButton(actionRow, createEditButton(targetIntent));\n\n        mPreviewCoord = new ContentPreviewCoordinator(contentPreviewLayout, false);\n\n        String action = targetIntent.getAction();\n        if (Intent.ACTION_SEND.equals(action)) {\n            Uri uri = targetIntent.getParcelableExtra(Intent.EXTRA_STREAM);\n            if (!validForContentPreview(uri)) {\n                contentPreviewLayout.setVisibility(View.GONE);\n                return contentPreviewLayout;\n            }\n            imagePreview.findViewById(R.id.content_preview_image_1_large)\n                    .setTransitionName(ChooserActivity.FIRST_IMAGE_PREVIEW_TRANSITION_NAME);\n            mPreviewCoord.loadUriIntoView(R.id.content_preview_image_1_large, uri, 0);\n        } else {\n            ContentResolver resolver = getContentResolver();\n\n            List<Uri> uris = targetIntent.getParcelableArrayListExtra(Intent.EXTRA_STREAM);\n            List<Uri> imageUris = new ArrayList<>();\n            for (Uri uri : uris) {\n                if (validForContentPreview(uri) && isImageType(resolver.getType(uri))) {\n                    imageUris.add(uri);\n                }\n            }\n\n            if (imageUris.size() == 0) {\n                Log.i(TAG, \"Attempted to display image preview area with zero\"\n                        + \" available images detected in EXTRA_STREAM list\");\n                imagePreview.setVisibility(View.GONE);\n                return contentPreviewLayout;\n            }\n\n            imagePreview.findViewById(R.id.content_preview_image_1_large)\n                    .setTransitionName(ChooserActivity.FIRST_IMAGE_PREVIEW_TRANSITION_NAME);\n            mPreviewCoord.loadUriIntoView(R.id.content_preview_image_1_large, imageUris.get(0), 0);\n\n            if (imageUris.size() == 2) {\n                mPreviewCoord.loadUriIntoView(R.id.content_preview_image_2_large,\n                        imageUris.get(1), 0);\n            } else if (imageUris.size() > 2) {\n                mPreviewCoord.loadUriIntoView(R.id.content_preview_image_2_small,\n                        imageUris.get(1), 0);\n                mPreviewCoord.loadUriIntoView(R.id.content_preview_image_3_small,\n                        imageUris.get(2), imageUris.size() - 3);\n            }\n        }\n\n        return contentPreviewLayout;\n    }\n\n    private static class FileInfo {\n        public final String name;\n        public final boolean hasThumbnail;\n\n        FileInfo(String name, boolean hasThumbnail) {\n            this.name = name;\n            this.hasThumbnail = hasThumbnail;\n        }\n    }\n\n    /**\n     * Wrapping the ContentResolver call to expose for easier mocking,\n     * and to avoid mocking Android core classes.\n     */\n    @VisibleForTesting\n    public Cursor queryResolver(ContentResolver resolver, Uri uri) {\n        return resolver.query(uri, null, null, null, null);\n    }\n\n    private FileInfo extractFileInfo(Uri uri, ContentResolver resolver) {\n        String fileName = null;\n        boolean hasThumbnail = false;\n\n        try (Cursor cursor = queryResolver(resolver, uri)) {\n            if (cursor != null && cursor.getCount() > 0) {\n                int nameIndex = cursor.getColumnIndex(OpenableColumns.DISPLAY_NAME);\n                int titleIndex = cursor.getColumnIndex(Downloads.Impl.COLUMN_TITLE);\n                int flagsIndex = cursor.getColumnIndex(DocumentsContract.Document.COLUMN_FLAGS);\n\n                cursor.moveToFirst();\n                if (nameIndex != -1) {\n                    fileName = cursor.getString(nameIndex);\n                } else if (titleIndex != -1) {\n                    fileName = cursor.getString(titleIndex);\n                }\n\n                if (flagsIndex != -1) {\n                    hasThumbnail = (cursor.getInt(flagsIndex)\n                            & DocumentsContract.Document.FLAG_SUPPORTS_THUMBNAIL) != 0;\n                }\n            }\n        } catch (SecurityException | NullPointerException e) {\n            logContentPreviewWarning(uri);\n        }\n\n        if (TextUtils.isEmpty(fileName)) {\n            fileName = uri.getPath();\n            int index = fileName.lastIndexOf('/');\n            if (index != -1) {\n                fileName = fileName.substring(index + 1);\n            }\n        }\n\n        return new FileInfo(fileName, hasThumbnail);\n    }\n\n    private void logContentPreviewWarning(Uri uri) {\n        // The ContentResolver already logs the exception. Log something more informative.\n        Log.w(TAG, \"Could not load (\" + uri.toString() + \") thumbnail/name for preview. If \"\n                + \"desired, consider using Intent#createChooser to launch the ChooserActivity, \"\n                + \"and set your Intent's clipData and flags in accordance with that method's \"\n                + \"documentation\");\n    }\n\n    private ViewGroup displayFileContentPreview(Intent targetIntent, LayoutInflater layoutInflater,\n            ViewGroup parent) {\n\n        ViewGroup contentPreviewLayout = (ViewGroup) layoutInflater.inflate(\n                R.layout.chooser_grid_preview_file, parent, false);\n\n        final ViewGroup actionRow =\n                (ViewGroup) contentPreviewLayout.findViewById(R.id.chooser_action_row);\n        //TODO(b/120417119): addActionButton(actionRow, createCopyButton());\n        if (shouldNearbyShareBeIncludedAsActionButton()) {\n            addActionButton(actionRow, createNearbyButton(targetIntent));\n        }\n\n        String action = targetIntent.getAction();\n        if (Intent.ACTION_SEND.equals(action)) {\n            Uri uri = targetIntent.getParcelableExtra(Intent.EXTRA_STREAM);\n            if (!validForContentPreview(uri)) {\n                contentPreviewLayout.setVisibility(View.GONE);\n                return contentPreviewLayout;\n            }\n            loadFileUriIntoView(uri, contentPreviewLayout);\n        } else {\n            List<Uri> uris = targetIntent.getParcelableArrayListExtra(Intent.EXTRA_STREAM);\n            uris = uris.stream()\n                    .filter(ChooserActivity::validForContentPreview)\n                    .collect(Collectors.toList());\n            int uriCount = uris.size();\n\n            if (uriCount == 0) {\n                contentPreviewLayout.setVisibility(View.GONE);\n                Log.i(TAG,\n                        \"Appears to be no uris available in EXTRA_STREAM, removing \"\n                                + \"preview area\");\n                return contentPreviewLayout;\n            } else if (uriCount == 1) {\n                loadFileUriIntoView(uris.get(0), contentPreviewLayout);\n            } else {\n                FileInfo fileInfo = extractFileInfo(uris.get(0), getContentResolver());\n                int remUriCount = uriCount - 1;\n                Map<String, Object> arguments = new HashMap<>();\n                arguments.put(PLURALS_COUNT, remUriCount);\n                arguments.put(PLURALS_FILE_NAME, fileInfo.name);\n                String fileName = PluralsMessageFormatter.format(\n                        getResources(),\n                        arguments,\n                        R.string.file_count);\n\n                TextView fileNameView = contentPreviewLayout.findViewById(\n                        R.id.content_preview_filename);\n                fileNameView.setText(fileName);\n\n                View thumbnailView = contentPreviewLayout.findViewById(\n                        R.id.content_preview_file_thumbnail);\n                thumbnailView.setVisibility(View.GONE);\n\n                ImageView fileIconView = contentPreviewLayout.findViewById(\n                        R.id.content_preview_file_icon);\n                fileIconView.setVisibility(View.VISIBLE);\n                fileIconView.setImageResource(R.drawable.ic_file_copy);\n            }\n        }\n\n        return contentPreviewLayout;\n    }\n\n    private void loadFileUriIntoView(final Uri uri, final View parent) {\n        FileInfo fileInfo = extractFileInfo(uri, getContentResolver());\n\n        TextView fileNameView = parent.findViewById(R.id.content_preview_filename);\n        fileNameView.setText(fileInfo.name);\n\n        if (fileInfo.hasThumbnail) {\n            mPreviewCoord = new ContentPreviewCoordinator(parent, false);\n            mPreviewCoord.loadUriIntoView(R.id.content_preview_file_thumbnail, uri, 0);\n        } else {\n            View thumbnailView = parent.findViewById(R.id.content_preview_file_thumbnail);\n            thumbnailView.setVisibility(View.GONE);\n\n            ImageView fileIconView = parent.findViewById(R.id.content_preview_file_icon);\n            fileIconView.setVisibility(View.VISIBLE);\n            fileIconView.setImageResource(R.drawable.chooser_file_generic);\n        }\n    }\n\n    /**\n     * Indicate if the incoming content URI should be allowed.\n     *\n     * @param uri the uri to test\n     * @return true if the URI is allowed for content preview\n     */\n    private static boolean validForContentPreview(Uri uri) throws SecurityException {\n        if (uri == null) {\n            return false;\n        }\n        int userId = getUserIdFromUri(uri, UserHandle.USER_CURRENT);\n        if (userId != UserHandle.USER_CURRENT && userId != UserHandle.myUserId()) {\n            Log.e(TAG, \"dropped invalid content URI belonging to user \" + userId);\n            return false;\n        }\n        return true;\n    }\n\n    @VisibleForTesting\n    protected boolean isImageType(String mimeType) {\n        return mimeType != null && mimeType.startsWith(\"image/\");\n    }\n\n    @ContentPreviewType\n    private int findPreferredContentPreview(Uri uri, ContentResolver resolver) {\n        if (uri == null) {\n            return CONTENT_PREVIEW_TEXT;\n        }\n\n        String mimeType = resolver.getType(uri);\n        return isImageType(mimeType) ? CONTENT_PREVIEW_IMAGE : CONTENT_PREVIEW_FILE;\n    }\n\n    /**\n     * In {@link android.content.Intent#getType}, the app may specify a very general\n     * mime-type that broadly covers all data being shared, such as {@literal *}/*\n     * when sending an image and text. We therefore should inspect each item for the\n     * the preferred type, in order of IMAGE, FILE, TEXT.\n     */\n    @ContentPreviewType\n    private int findPreferredContentPreview(Intent targetIntent, ContentResolver resolver) {\n        String action = targetIntent.getAction();\n        if (Intent.ACTION_SEND.equals(action)) {\n            Uri uri = targetIntent.getParcelableExtra(Intent.EXTRA_STREAM);\n            return findPreferredContentPreview(uri, resolver);\n        } else if (Intent.ACTION_SEND_MULTIPLE.equals(action)) {\n            List<Uri> uris = targetIntent.getParcelableArrayListExtra(Intent.EXTRA_STREAM);\n            if (uris == null || uris.isEmpty()) {\n                return CONTENT_PREVIEW_TEXT;\n            }\n\n            for (Uri uri : uris) {\n                // Defaulting to file preview when there are mixed image/file types is\n                // preferable, as it shows the user the correct number of items being shared\n                if (findPreferredContentPreview(uri, resolver) == CONTENT_PREVIEW_FILE) {\n                    return CONTENT_PREVIEW_FILE;\n                }\n            }\n\n            return CONTENT_PREVIEW_IMAGE;\n        }\n\n        return CONTENT_PREVIEW_TEXT;\n    }\n\n    private int getNumSheetExpansions() {\n        return getPreferences(Context.MODE_PRIVATE).getInt(PREF_NUM_SHEET_EXPANSIONS, 0);\n    }\n\n    private void incrementNumSheetExpansions() {\n        getPreferences(Context.MODE_PRIVATE).edit().putInt(PREF_NUM_SHEET_EXPANSIONS,\n                getNumSheetExpansions() + 1).apply();\n    }\n\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n\n        if (isFinishing()) {\n            mLatencyTracker.onActionCancel(ACTION_LOAD_SHARE_SHEET);\n        }\n\n        if (mRefinementResultReceiver != null) {\n            mRefinementResultReceiver.destroy();\n            mRefinementResultReceiver = null;\n        }\n        mChooserHandler.removeAllMessages();\n\n        if (mPreviewCoord != null) mPreviewCoord.cancelLoads();\n\n        mChooserMultiProfilePagerAdapter.getActiveListAdapter().destroyAppPredictor();\n        if (mChooserMultiProfilePagerAdapter.getInactiveListAdapter() != null) {\n            mChooserMultiProfilePagerAdapter.getInactiveListAdapter().destroyAppPredictor();\n        }\n    }\n\n    @Override // ResolverListCommunicator\n    public Intent getReplacementIntent(ActivityInfo aInfo, Intent defIntent) {\n        Intent result = defIntent;\n        if (mReplacementExtras != null) {\n            final Bundle replExtras = mReplacementExtras.getBundle(aInfo.packageName);\n            if (replExtras != null) {\n                result = new Intent(defIntent);\n                result.putExtras(replExtras);\n            }\n        }\n        if (aInfo.name.equals(IntentForwarderActivity.FORWARD_INTENT_TO_PARENT)\n                || aInfo.name.equals(IntentForwarderActivity.FORWARD_INTENT_TO_MANAGED_PROFILE)) {\n            result = Intent.createChooser(result,\n                    getIntent().getCharSequenceExtra(Intent.EXTRA_TITLE));\n\n            // Don't auto-launch single intents if the intent is being forwarded. This is done\n            // because automatically launching a resolving application as a response to the user\n            // action of switching accounts is pretty unexpected.\n            result.putExtra(Intent.EXTRA_AUTO_LAUNCH_SINGLE_CHOICE, false);\n        }\n        return result;\n    }\n\n    @Override\n    public void onActivityStarted(TargetInfo cti) {\n        if (mChosenComponentSender != null) {\n            final ComponentName target = cti.getResolvedComponentName();\n            if (target != null) {\n                final Intent fillIn = new Intent().putExtra(Intent.EXTRA_CHOSEN_COMPONENT, target);\n                try {\n                    mChosenComponentSender.sendIntent(this, Activity.RESULT_OK, fillIn, null, null);\n                } catch (IntentSender.SendIntentException e) {\n                    Slog.e(TAG, \"Unable to launch supplied IntentSender to report \"\n                            + \"the chosen component: \" + e);\n                }\n            }\n        }\n    }\n\n    @Override\n    public void addUseDifferentAppLabelIfNecessary(ResolverListAdapter adapter) {\n        if (mCallerChooserTargets != null && mCallerChooserTargets.length > 0) {\n            mChooserMultiProfilePagerAdapter.getActiveListAdapter().addServiceResults(\n                    /* origTarget */ null,\n                    Lists.newArrayList(mCallerChooserTargets),\n                    TARGET_TYPE_DEFAULT,\n                    /* directShareShortcutInfoCache */ null);\n        }\n    }\n\n    @Override\n    public int getLayoutResource() {\n        return R.layout.chooser_grid;\n    }\n\n    @Override // ResolverListCommunicator\n    public boolean shouldGetActivityMetadata() {\n        return true;\n    }\n\n    @Override\n    public boolean shouldAutoLaunchSingleChoice(TargetInfo target) {\n        // Note that this is only safe because the Intent handled by the ChooserActivity is\n        // guaranteed to contain no extras unknown to the local ClassLoader. That is why this\n        // method can not be replaced in the ResolverActivity whole hog.\n        if (!super.shouldAutoLaunchSingleChoice(target)) {\n            return false;\n        }\n\n        return getIntent().getBooleanExtra(Intent.EXTRA_AUTO_LAUNCH_SINGLE_CHOICE, true);\n    }\n\n    private void showTargetDetails(TargetInfo targetInfo) {\n        if (targetInfo == null) return;\n\n        ArrayList<DisplayResolveInfo> targetList;\n        ChooserTargetActionsDialogFragment fragment = new ChooserTargetActionsDialogFragment();\n        Bundle bundle = new Bundle();\n\n        if (targetInfo instanceof SelectableTargetInfo) {\n            SelectableTargetInfo selectableTargetInfo = (SelectableTargetInfo) targetInfo;\n            if (selectableTargetInfo.getDisplayResolveInfo() == null\n                    || selectableTargetInfo.getChooserTarget() == null) {\n                Log.e(TAG, \"displayResolveInfo or chooserTarget in selectableTargetInfo are null\");\n                return;\n            }\n            targetList = new ArrayList<>();\n            targetList.add(selectableTargetInfo.getDisplayResolveInfo());\n            bundle.putString(ChooserTargetActionsDialogFragment.SHORTCUT_ID_KEY,\n                    selectableTargetInfo.getChooserTarget().getIntentExtras().getString(\n                            Intent.EXTRA_SHORTCUT_ID));\n            bundle.putBoolean(ChooserTargetActionsDialogFragment.IS_SHORTCUT_PINNED_KEY,\n                    selectableTargetInfo.isPinned());\n            bundle.putParcelable(ChooserTargetActionsDialogFragment.INTENT_FILTER_KEY,\n                    getTargetIntentFilter());\n            if (selectableTargetInfo.getDisplayLabel() != null) {\n                bundle.putString(ChooserTargetActionsDialogFragment.SHORTCUT_TITLE_KEY,\n                        selectableTargetInfo.getDisplayLabel().toString());\n            }\n        } else if (targetInfo instanceof MultiDisplayResolveInfo) {\n            // For multiple targets, include info on all targets\n            MultiDisplayResolveInfo mti = (MultiDisplayResolveInfo) targetInfo;\n            targetList = mti.getTargets();\n        } else {\n            targetList = new ArrayList<DisplayResolveInfo>();\n            targetList.add((DisplayResolveInfo) targetInfo);\n        }\n        bundle.putParcelable(ChooserTargetActionsDialogFragment.USER_HANDLE_KEY,\n                mChooserMultiProfilePagerAdapter.getCurrentUserHandle());\n        bundle.putParcelableArrayList(ChooserTargetActionsDialogFragment.TARGET_INFOS_KEY,\n                targetList);\n        fragment.setArguments(bundle);\n\n        fragment.show(getFragmentManager(), TARGET_DETAILS_FRAGMENT_TAG);\n    }\n\n    private void modifyTargetIntent(Intent in) {\n        if (isSendAction(in)) {\n            in.addFlags(Intent.FLAG_ACTIVITY_NEW_DOCUMENT |\n                    Intent.FLAG_ACTIVITY_MULTIPLE_TASK);\n        }\n    }\n\n    @Override\n    protected boolean onTargetSelected(TargetInfo target, boolean alwaysCheck) {\n        if (mRefinementIntentSender != null) {\n            final Intent fillIn = new Intent();\n            final List<Intent> sourceIntents = target.getAllSourceIntents();\n            if (!sourceIntents.isEmpty()) {\n                fillIn.putExtra(Intent.EXTRA_INTENT, sourceIntents.get(0));\n                if (sourceIntents.size() > 1) {\n                    final Intent[] alts = new Intent[sourceIntents.size() - 1];\n                    for (int i = 1, N = sourceIntents.size(); i < N; i++) {\n                        alts[i - 1] = sourceIntents.get(i);\n                    }\n                    fillIn.putExtra(Intent.EXTRA_ALTERNATE_INTENTS, alts);\n                }\n                if (mRefinementResultReceiver != null) {\n                    mRefinementResultReceiver.destroy();\n                }\n                mRefinementResultReceiver = new RefinementResultReceiver(this, target, null);\n                fillIn.putExtra(Intent.EXTRA_RESULT_RECEIVER,\n                        mRefinementResultReceiver);\n                try {\n                    mRefinementIntentSender.sendIntent(this, 0, fillIn, null, null);\n                    return false;\n                } catch (SendIntentException e) {\n                    Log.e(TAG, \"Refinement IntentSender failed to send\", e);\n                }\n            }\n        }\n        updateModelAndChooserCounts(target);\n        return super.onTargetSelected(target, alwaysCheck);\n    }\n\n    @Override\n    public void startSelected(int which, boolean always, boolean filtered) {\n        ChooserListAdapter currentListAdapter =\n                mChooserMultiProfilePagerAdapter.getActiveListAdapter();\n        TargetInfo targetInfo = currentListAdapter\n                .targetInfoForPosition(which, filtered);\n        if (targetInfo != null && targetInfo instanceof NotSelectableTargetInfo) {\n            return;\n        }\n\n        final long selectionCost = System.currentTimeMillis() - mChooserShownTime;\n\n        if (targetInfo instanceof MultiDisplayResolveInfo) {\n            MultiDisplayResolveInfo mti = (MultiDisplayResolveInfo) targetInfo;\n            if (!mti.hasSelected()) {\n                ChooserStackedAppDialogFragment f = new ChooserStackedAppDialogFragment();\n                Bundle b = new Bundle();\n                b.putParcelable(ChooserTargetActionsDialogFragment.USER_HANDLE_KEY,\n                        mChooserMultiProfilePagerAdapter.getCurrentUserHandle());\n                b.putObject(ChooserStackedAppDialogFragment.MULTI_DRI_KEY,\n                        mti);\n                b.putInt(ChooserStackedAppDialogFragment.WHICH_KEY, which);\n                f.setArguments(b);\n\n                f.show(getFragmentManager(), TARGET_DETAILS_FRAGMENT_TAG);\n                return;\n            }\n        }\n\n        super.startSelected(which, always, filtered);\n\n        if (currentListAdapter.getCount() > 0) {\n            // Log the index of which type of target the user picked.\n            // Lower values mean the ranking was better.\n            int cat = 0;\n            int value = which;\n            int directTargetAlsoRanked = -1;\n            int numCallerProvided = 0;\n            HashedStringCache.HashResult directTargetHashed = null;\n            switch (currentListAdapter.getPositionTargetType(which)) {\n                case ChooserListAdapter.TARGET_SERVICE:\n                    cat = MetricsEvent.ACTION_ACTIVITY_CHOOSER_PICKED_SERVICE_TARGET;\n                    // Log the package name + target name to answer the question if most users\n                    // share to mostly the same person or to a bunch of different people.\n                    ChooserTarget target = currentListAdapter.getChooserTargetForValue(value);\n                    directTargetHashed = HashedStringCache.getInstance().hashString(\n                            this,\n                            TAG,\n                            target.getComponentName().getPackageName()\n                                    + target.getTitle().toString(),\n                            mMaxHashSaltDays);\n                    SelectableTargetInfo selectableTargetInfo = (SelectableTargetInfo) targetInfo;\n                    directTargetAlsoRanked = getRankedPosition(selectableTargetInfo);\n\n                    if (mCallerChooserTargets != null) {\n                        numCallerProvided = mCallerChooserTargets.length;\n                    }\n                    getChooserActivityLogger().logShareTargetSelected(\n                            SELECTION_TYPE_SERVICE,\n                            targetInfo.getResolveInfo().activityInfo.processName,\n                            value,\n                            selectableTargetInfo.isPinned()\n                    );\n                    break;\n                case ChooserListAdapter.TARGET_CALLER:\n                case ChooserListAdapter.TARGET_STANDARD:\n                    cat = MetricsEvent.ACTION_ACTIVITY_CHOOSER_PICKED_APP_TARGET;\n                    value -= currentListAdapter.getSurfacedTargetInfo().size();\n                    numCallerProvided = currentListAdapter.getCallerTargetCount();\n                    getChooserActivityLogger().logShareTargetSelected(\n                            SELECTION_TYPE_APP,\n                            targetInfo.getResolveInfo().activityInfo.processName,\n                            value,\n                            targetInfo.isPinned()\n                    );\n                    break;\n                case ChooserListAdapter.TARGET_STANDARD_AZ:\n                    // A-Z targets are unranked standard targets; we use -1 to mark that they\n                    // are from the alphabetical pool.\n                    value = -1;\n                    cat = MetricsEvent.ACTION_ACTIVITY_CHOOSER_PICKED_STANDARD_TARGET;\n                    getChooserActivityLogger().logShareTargetSelected(\n                            SELECTION_TYPE_STANDARD,\n                            targetInfo.getResolveInfo().activityInfo.processName,\n                            value,\n                            false\n                    );\n                    break;\n            }\n\n            if (cat != 0) {\n                LogMaker targetLogMaker = new LogMaker(cat).setSubtype(value);\n                if (directTargetHashed != null) {\n                    targetLogMaker.addTaggedData(\n                            MetricsEvent.FIELD_HASHED_TARGET_NAME, directTargetHashed.hashedString);\n                    targetLogMaker.addTaggedData(\n                                    MetricsEvent.FIELD_HASHED_TARGET_SALT_GEN,\n                                    directTargetHashed.saltGeneration);\n                    targetLogMaker.addTaggedData(MetricsEvent.FIELD_RANKED_POSITION,\n                                    directTargetAlsoRanked);\n                }\n                targetLogMaker.addTaggedData(MetricsEvent.FIELD_IS_CATEGORY_USED,\n                        numCallerProvided);\n                getMetricsLogger().write(targetLogMaker);\n            }\n\n            if (mIsSuccessfullySelected) {\n                if (DEBUG) {\n                    Log.d(TAG, \"User Selection Time Cost is \" + selectionCost);\n                    Log.d(TAG, \"position of selected app/service/caller is \" +\n                            Integer.toString(value));\n                }\n                MetricsLogger.histogram(null, \"user_selection_cost_for_smart_sharing\",\n                        (int) selectionCost);\n                MetricsLogger.histogram(null, \"app_position_for_smart_sharing\", value);\n            }\n        }\n    }\n\n    private int getRankedPosition(SelectableTargetInfo targetInfo) {\n        String targetPackageName =\n                targetInfo.getChooserTarget().getComponentName().getPackageName();\n        ChooserListAdapter currentListAdapter =\n                mChooserMultiProfilePagerAdapter.getActiveListAdapter();\n        int maxRankedResults = Math.min(currentListAdapter.mDisplayList.size(),\n                MAX_LOG_RANK_POSITION);\n\n        for (int i = 0; i < maxRankedResults; i++) {\n            if (currentListAdapter.mDisplayList.get(i)\n                    .getResolveInfo().activityInfo.packageName.equals(targetPackageName)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    @Override\n    protected boolean shouldAddFooterView() {\n        // To accommodate for window insets\n        return true;\n    }\n\n    @Override\n    protected void applyFooterView(int height) {\n        int count = mChooserMultiProfilePagerAdapter.getItemCount();\n\n        for (int i = 0; i < count; i++) {\n            mChooserMultiProfilePagerAdapter.getAdapterForIndex(i).setFooterHeight(height);\n        }\n    }\n\n    private IntentFilter getTargetIntentFilter() {\n        try {\n            final Intent intent = getTargetIntent();\n            String dataString = intent.getDataString();\n            if (intent.getType() == null) {\n                if (!TextUtils.isEmpty(dataString)) {\n                    return new IntentFilter(intent.getAction(), dataString);\n                }\n                Log.e(TAG, \"Failed to get target intent filter: intent data and type are null\");\n                return null;\n            }\n            IntentFilter intentFilter = new IntentFilter(intent.getAction(), intent.getType());\n            List<Uri> contentUris = new ArrayList<>();\n            if (Intent.ACTION_SEND.equals(intent.getAction())) {\n                Uri uri = (Uri) intent.getParcelableExtra(Intent.EXTRA_STREAM);\n                if (uri != null) {\n                    contentUris.add(uri);\n                }\n            } else {\n                List<Uri> uris = intent.getParcelableArrayListExtra(Intent.EXTRA_STREAM);\n                if (uris != null) {\n                    contentUris.addAll(uris);\n                }\n            }\n            for (Uri uri : contentUris) {\n                intentFilter.addDataScheme(uri.getScheme());\n                intentFilter.addDataAuthority(uri.getAuthority(), null);\n                intentFilter.addDataPath(uri.getPath(), PatternMatcher.PATTERN_LITERAL);\n            }\n            return intentFilter;\n        } catch (Exception e) {\n            Log.e(TAG, \"Failed to get target intent filter\", e);\n            return null;\n        }\n    }\n\n    @VisibleForTesting\n    protected void queryDirectShareTargets(\n                ChooserListAdapter adapter, boolean skipAppPredictionService) {\n        mQueriedSharingShortcutsTimeMs = System.currentTimeMillis();\n        UserHandle userHandle = adapter.getUserHandle();\n        if (!skipAppPredictionService) {\n            AppPredictor appPredictor = getAppPredictorForDirectShareIfEnabled(userHandle);\n            if (appPredictor != null) {\n                appPredictor.requestPredictionUpdate();\n                return;\n            }\n        }\n        // Default to just querying ShortcutManager if AppPredictor not present.\n        final IntentFilter filter = getTargetIntentFilter();\n        if (filter == null) {\n            return;\n        }\n\n        AsyncTask.execute(() -> {\n            Context selectedProfileContext = createContextAsUser(userHandle, 0 /* flags */);\n            ShortcutManager sm = (ShortcutManager) selectedProfileContext\n                    .getSystemService(Context.SHORTCUT_SERVICE);\n            List<ShortcutManager.ShareShortcutInfo> resultList = sm.getShareTargets(filter);\n            sendShareShortcutInfoList(resultList, adapter, null, userHandle);\n        });\n    }\n\n    /**\n     * Returns {@code false} if {@code userHandle} is the work profile and it's either\n     * in quiet mode or not running.\n     */\n    private boolean shouldQueryShortcutManager(UserHandle userHandle) {\n        if (!shouldShowTabs()) {\n            return true;\n        }\n        if (!getWorkProfileUserHandle().equals(userHandle)) {\n            return true;\n        }\n        if (!isUserRunning(userHandle)) {\n            return false;\n        }\n        if (!isUserUnlocked(userHandle)) {\n            return false;\n        }\n        if (isQuietModeEnabled(userHandle)) {\n            return false;\n        }\n        return true;\n    }\n\n    private void sendShareShortcutInfoList(\n                List<ShortcutManager.ShareShortcutInfo> resultList,\n                ChooserListAdapter chooserListAdapter,\n                @Nullable List<AppTarget> appTargets, UserHandle userHandle) {\n        if (appTargets != null && appTargets.size() != resultList.size()) {\n            throw new RuntimeException(\"resultList and appTargets must have the same size.\"\n                    + \" resultList.size()=\" + resultList.size()\n                    + \" appTargets.size()=\" + appTargets.size());\n        }\n        Context selectedProfileContext = createContextAsUser(userHandle, 0 /* flags */);\n        for (int i = resultList.size() - 1; i >= 0; i--) {\n            final String packageName = resultList.get(i).getTargetComponent().getPackageName();\n            if (!isPackageEnabled(selectedProfileContext, packageName)) {\n                resultList.remove(i);\n                if (appTargets != null) {\n                    appTargets.remove(i);\n                }\n            }\n        }\n\n        // If |appTargets| is not null, results are from AppPredictionService and already sorted.\n        final int shortcutType = (appTargets == null ? TARGET_TYPE_SHORTCUTS_FROM_SHORTCUT_MANAGER :\n                TARGET_TYPE_SHORTCUTS_FROM_PREDICTION_SERVICE);\n\n        // Match ShareShortcutInfos with DisplayResolveInfos to be able to use the old code path\n        // for direct share targets. After ShareSheet is refactored we should use the\n        // ShareShortcutInfos directly.\n        List<ServiceResultInfo> resultRecords = new ArrayList<>();\n        for (int i = 0; i < chooserListAdapter.getDisplayResolveInfoCount(); i++) {\n            DisplayResolveInfo displayResolveInfo = chooserListAdapter.getDisplayResolveInfo(i);\n            List<ShortcutManager.ShareShortcutInfo> matchingShortcuts =\n                    filterShortcutsByTargetComponentName(\n                            resultList, displayResolveInfo.getResolvedComponentName());\n            if (matchingShortcuts.isEmpty()) {\n                continue;\n            }\n            List<ChooserTarget> chooserTargets = convertToChooserTarget(\n                    matchingShortcuts, resultList, appTargets, shortcutType);\n\n            ServiceResultInfo resultRecord = new ServiceResultInfo(\n                    displayResolveInfo, chooserTargets, userHandle);\n            resultRecords.add(resultRecord);\n        }\n\n        sendShortcutManagerShareTargetResults(\n                shortcutType, resultRecords.toArray(new ServiceResultInfo[0]));\n    }\n\n    private List<ShortcutManager.ShareShortcutInfo> filterShortcutsByTargetComponentName(\n            List<ShortcutManager.ShareShortcutInfo> allShortcuts, ComponentName requiredTarget) {\n        List<ShortcutManager.ShareShortcutInfo> matchingShortcuts = new ArrayList<>();\n        for (ShortcutManager.ShareShortcutInfo shortcut : allShortcuts) {\n            if (requiredTarget.equals(shortcut.getTargetComponent())) {\n                matchingShortcuts.add(shortcut);\n            }\n        }\n        return matchingShortcuts;\n    }\n\n    private void sendShortcutManagerShareTargetResults(\n            int shortcutType, ServiceResultInfo[] results) {\n        final Message msg = Message.obtain();\n        msg.what = ChooserHandler.SHORTCUT_MANAGER_ALL_SHARE_TARGET_RESULTS;\n        msg.obj = results;\n        msg.arg1 = shortcutType;\n        mChooserHandler.sendMessage(msg);\n    }\n\n    private boolean isPackageEnabled(Context context, String packageName) {\n        if (TextUtils.isEmpty(packageName)) {\n            return false;\n        }\n        ApplicationInfo appInfo;\n        try {\n            appInfo = context.getPackageManager().getApplicationInfo(packageName, 0);\n        } catch (NameNotFoundException e) {\n            return false;\n        }\n\n        if (appInfo != null && appInfo.enabled\n                && (appInfo.flags & ApplicationInfo.FLAG_SUSPENDED) == 0) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Converts a list of ShareShortcutInfos to ChooserTargets.\n     * @param matchingShortcuts List of shortcuts, all from the same package, that match the current\n     *                         share intent filter.\n     * @param allShortcuts List of all the shortcuts from all the packages on the device that are\n     *                    returned for the current sharing action.\n     * @param allAppTargets List of AppTargets. Null if the results are not from prediction service.\n     * @param shortcutType One of the values TARGET_TYPE_SHORTCUTS_FROM_SHORTCUT_MANAGER or\n     *                    TARGET_TYPE_SHORTCUTS_FROM_PREDICTION_SERVICE\n     * @return A list of ChooserTargets sorted by score in descending order.\n     */\n    @VisibleForTesting\n    @NonNull\n    public List<ChooserTarget> convertToChooserTarget(\n            @NonNull List<ShortcutManager.ShareShortcutInfo> matchingShortcuts,\n            @NonNull List<ShortcutManager.ShareShortcutInfo> allShortcuts,\n            @Nullable List<AppTarget> allAppTargets, @ShareTargetType int shortcutType) {\n        // A set of distinct scores for the matched shortcuts. We use index of a rank in the sorted\n        // list instead of the actual rank value when converting a rank to a score.\n        List<Integer> scoreList = new ArrayList<>();\n        if (shortcutType == TARGET_TYPE_SHORTCUTS_FROM_SHORTCUT_MANAGER) {\n            for (int i = 0; i < matchingShortcuts.size(); i++) {\n                int shortcutRank = matchingShortcuts.get(i).getShortcutInfo().getRank();\n                if (!scoreList.contains(shortcutRank)) {\n                    scoreList.add(shortcutRank);\n                }\n            }\n            Collections.sort(scoreList);\n        }\n\n        List<ChooserTarget> chooserTargetList = new ArrayList<>(matchingShortcuts.size());\n        for (int i = 0; i < matchingShortcuts.size(); i++) {\n            ShortcutInfo shortcutInfo = matchingShortcuts.get(i).getShortcutInfo();\n            int indexInAllShortcuts = allShortcuts.indexOf(matchingShortcuts.get(i));\n\n            float score;\n            if (shortcutType == TARGET_TYPE_SHORTCUTS_FROM_PREDICTION_SERVICE) {\n                // Incoming results are ordered. Create a score based on index in the original list.\n                score = Math.max(1.0f - (0.01f * indexInAllShortcuts), 0.0f);\n            } else {\n                // Create a score based on the rank of the shortcut.\n                int rankIndex = scoreList.indexOf(shortcutInfo.getRank());\n                score = Math.max(1.0f - (0.01f * rankIndex), 0.0f);\n            }\n\n            Bundle extras = new Bundle();\n            extras.putString(Intent.EXTRA_SHORTCUT_ID, shortcutInfo.getId());\n\n            ChooserTarget chooserTarget = new ChooserTarget(\n                    shortcutInfo.getLabel(),\n                    null, // Icon will be loaded later if this target is selected to be shown.\n                    score, matchingShortcuts.get(i).getTargetComponent().clone(), extras);\n\n            chooserTargetList.add(chooserTarget);\n            if (mDirectShareAppTargetCache != null && allAppTargets != null) {\n                mDirectShareAppTargetCache.put(chooserTarget,\n                        allAppTargets.get(indexInAllShortcuts));\n            }\n            if (mDirectShareShortcutInfoCache != null) {\n                mDirectShareShortcutInfoCache.put(chooserTarget, shortcutInfo);\n            }\n        }\n        // Sort ChooserTargets by score in descending order\n        Comparator<ChooserTarget> byScore =\n                (ChooserTarget a, ChooserTarget b) -> -Float.compare(a.getScore(), b.getScore());\n        Collections.sort(chooserTargetList, byScore);\n        return chooserTargetList;\n    }\n\n    private void logDirectShareTargetReceived(int logCategory) {\n        final int apiLatency = (int) (System.currentTimeMillis() - mQueriedSharingShortcutsTimeMs);\n        getMetricsLogger().write(new LogMaker(logCategory).setSubtype(apiLatency));\n    }\n\n    void updateModelAndChooserCounts(TargetInfo info) {\n        if (info != null && info instanceof MultiDisplayResolveInfo) {\n            info = ((MultiDisplayResolveInfo) info).getSelectedTarget();\n        }\n        if (info != null) {\n            sendClickToAppPredictor(info);\n            final ResolveInfo ri = info.getResolveInfo();\n            Intent targetIntent = getTargetIntent();\n            if (ri != null && ri.activityInfo != null && targetIntent != null) {\n                ChooserListAdapter currentListAdapter =\n                        mChooserMultiProfilePagerAdapter.getActiveListAdapter();\n                if (currentListAdapter != null) {\n                    sendImpressionToAppPredictor(info, currentListAdapter);\n                    currentListAdapter.updateModel(info.getResolvedComponentName());\n                    currentListAdapter.updateChooserCounts(ri.activityInfo.packageName,\n                            targetIntent.getAction());\n                }\n                if (DEBUG) {\n                    Log.d(TAG, \"ResolveInfo Package is \" + ri.activityInfo.packageName);\n                    Log.d(TAG, \"Action to be updated is \" + targetIntent.getAction());\n                }\n            } else if (DEBUG) {\n                Log.d(TAG, \"Can not log Chooser Counts of null ResovleInfo\");\n            }\n        }\n        mIsSuccessfullySelected = true;\n    }\n\n    private void sendImpressionToAppPredictor(TargetInfo targetInfo, ChooserListAdapter adapter) {\n        AppPredictor directShareAppPredictor = getAppPredictorForDirectShareIfEnabled(\n                mChooserMultiProfilePagerAdapter.getCurrentUserHandle());\n        if (directShareAppPredictor == null) {\n            return;\n        }\n        // Send DS target impression info to AppPredictor, only when user chooses app share.\n        if (targetInfo instanceof ChooserTargetInfo) {\n            return;\n        }\n        List<ChooserTargetInfo> surfacedTargetInfo = adapter.getSurfacedTargetInfo();\n        List<AppTargetId> targetIds = new ArrayList<>();\n        for (ChooserTargetInfo chooserTargetInfo : surfacedTargetInfo) {\n            ChooserTarget chooserTarget = chooserTargetInfo.getChooserTarget();\n            ComponentName componentName = chooserTarget.getComponentName();\n            if (mDirectShareShortcutInfoCache.containsKey(chooserTarget)) {\n                String shortcutId = mDirectShareShortcutInfoCache.get(chooserTarget).getId();\n                targetIds.add(new AppTargetId(\n                        String.format(\"%s/%s/%s\", shortcutId, componentName.flattenToString(),\n                                SHORTCUT_TARGET)));\n            }\n        }\n        directShareAppPredictor.notifyLaunchLocationShown(LAUNCH_LOCATION_DIRECT_SHARE, targetIds);\n    }\n\n    private void sendClickToAppPredictor(TargetInfo targetInfo) {\n        AppPredictor directShareAppPredictor = getAppPredictorForDirectShareIfEnabled(\n                mChooserMultiProfilePagerAdapter.getCurrentUserHandle());\n        if (directShareAppPredictor == null) {\n            return;\n        }\n        if (!(targetInfo instanceof ChooserTargetInfo)) {\n            return;\n        }\n        ChooserTarget chooserTarget = ((ChooserTargetInfo) targetInfo).getChooserTarget();\n        AppTarget appTarget = null;\n        if (mDirectShareAppTargetCache != null) {\n            appTarget = mDirectShareAppTargetCache.get(chooserTarget);\n        }\n        // This is a direct share click that was provided by the APS\n        if (appTarget != null) {\n            directShareAppPredictor.notifyAppTargetEvent(\n                    new AppTargetEvent.Builder(appTarget, AppTargetEvent.ACTION_LAUNCH)\n                        .setLaunchLocation(LAUNCH_LOCATION_DIRECT_SHARE)\n                        .build());\n        }\n    }\n\n    @Nullable\n    private AppPredictor createAppPredictor(UserHandle userHandle) {\n        if (!mIsAppPredictorComponentAvailable) {\n            return null;\n        }\n\n        if (getPersonalProfileUserHandle().equals(userHandle)) {\n            if (mPersonalAppPredictor != null) {\n                return mPersonalAppPredictor;\n            }\n        } else {\n            if (mWorkAppPredictor != null) {\n                return mWorkAppPredictor;\n            }\n        }\n\n        // TODO(b/148230574): Currently AppPredictor fetches only the same-profile app targets.\n        // Make AppPredictor work cross-profile.\n        Context contextAsUser = createContextAsUser(userHandle, 0 /* flags */);\n        final IntentFilter filter = getTargetIntentFilter();\n        Bundle extras = new Bundle();\n        extras.putParcelable(APP_PREDICTION_INTENT_FILTER_KEY, filter);\n        populateTextContent(extras);\n        AppPredictionContext appPredictionContext = new AppPredictionContext.Builder(contextAsUser)\n            .setUiSurface(APP_PREDICTION_SHARE_UI_SURFACE)\n            .setPredictedTargetCount(APP_PREDICTION_SHARE_TARGET_QUERY_PACKAGE_LIMIT)\n            .setExtras(extras)\n            .build();\n        AppPredictionManager appPredictionManager =\n                contextAsUser\n                        .getSystemService(AppPredictionManager.class);\n        AppPredictor appPredictionSession = appPredictionManager.createAppPredictionSession(\n                appPredictionContext);\n        if (getPersonalProfileUserHandle().equals(userHandle)) {\n            mPersonalAppPredictor = appPredictionSession;\n        } else {\n            mWorkAppPredictor = appPredictionSession;\n        }\n        return appPredictionSession;\n    }\n\n    private void populateTextContent(Bundle extras) {\n        final Intent intent = getTargetIntent();\n        String sharedText = intent.getStringExtra(Intent.EXTRA_TEXT);\n        extras.putString(SHARED_TEXT_KEY, sharedText);\n    }\n\n    /**\n     * This will return an app predictor if it is enabled for direct share sorting\n     * and if one exists. Otherwise, it returns null.\n     * @param userHandle\n     */\n    @Nullable\n    private AppPredictor getAppPredictorForDirectShareIfEnabled(UserHandle userHandle) {\n        return ChooserFlags.USE_PREDICTION_MANAGER_FOR_DIRECT_TARGETS\n                && !ActivityManager.isLowRamDeviceStatic() ? createAppPredictor(userHandle) : null;\n    }\n\n    /**\n     * This will return an app predictor if it is enabled for share activity sorting\n     * and if one exists. Otherwise, it returns null.\n     */\n    @Nullable\n    private AppPredictor getAppPredictorForShareActivitiesIfEnabled(UserHandle userHandle) {\n        return USE_PREDICTION_MANAGER_FOR_SHARE_ACTIVITIES ? createAppPredictor(userHandle) : null;\n    }\n\n    void onRefinementResult(TargetInfo selectedTarget, Intent matchingIntent) {\n        if (mRefinementResultReceiver != null) {\n            mRefinementResultReceiver.destroy();\n            mRefinementResultReceiver = null;\n        }\n        if (selectedTarget == null) {\n            Log.e(TAG, \"Refinement result intent did not match any known targets; canceling\");\n        } else if (!checkTargetSourceIntent(selectedTarget, matchingIntent)) {\n            Log.e(TAG, \"onRefinementResult: Selected target \" + selectedTarget\n                    + \" cannot match refined source intent \" + matchingIntent);\n        } else {\n            TargetInfo clonedTarget = selectedTarget.cloneFilledIn(matchingIntent, 0);\n            if (super.onTargetSelected(clonedTarget, false)) {\n                updateModelAndChooserCounts(clonedTarget);\n                finish();\n                return;\n            }\n        }\n        onRefinementCanceled();\n    }\n\n    void onRefinementCanceled() {\n        if (mRefinementResultReceiver != null) {\n            mRefinementResultReceiver.destroy();\n            mRefinementResultReceiver = null;\n        }\n        finish();\n    }\n\n    boolean checkTargetSourceIntent(TargetInfo target, Intent matchingIntent) {\n        final List<Intent> targetIntents = target.getAllSourceIntents();\n        for (int i = 0, N = targetIntents.size(); i < N; i++) {\n            final Intent targetIntent = targetIntents.get(i);\n            if (targetIntent.filterEquals(matchingIntent)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Sort intents alphabetically based on display label.\n     */\n    static class AzInfoComparator implements Comparator<DisplayResolveInfo> {\n        Collator mCollator;\n        AzInfoComparator(Context context) {\n            mCollator = Collator.getInstance(context.getResources().getConfiguration().locale);\n        }\n\n        @Override\n        public int compare(\n                DisplayResolveInfo lhsp, DisplayResolveInfo rhsp) {\n            return mCollator.compare(lhsp.getDisplayLabel(), rhsp.getDisplayLabel());\n        }\n    }\n\n    protected MetricsLogger getMetricsLogger() {\n        if (mMetricsLogger == null) {\n            mMetricsLogger = new MetricsLogger();\n        }\n        return mMetricsLogger;\n    }\n\n    protected ChooserActivityLogger getChooserActivityLogger() {\n        if (mChooserActivityLogger == null) {\n            mChooserActivityLogger = new ChooserActivityLoggerImpl();\n        }\n        return mChooserActivityLogger;\n    }\n\n    public class ChooserListController extends ResolverListController {\n        public ChooserListController(Context context,\n                PackageManager pm,\n                Intent targetIntent,\n                String referrerPackageName,\n                int launchedFromUid,\n                UserHandle userId,\n                AbstractResolverComparator resolverComparator) {\n            super(context, pm, targetIntent, referrerPackageName, launchedFromUid, userId,\n                    resolverComparator);\n        }\n\n        @Override\n        boolean isComponentFiltered(ComponentName name) {\n            if (mFilteredComponentNames == null) {\n                return false;\n            }\n            for (ComponentName filteredComponentName : mFilteredComponentNames) {\n                if (name.equals(filteredComponentName)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        @Override\n        public boolean isComponentPinned(ComponentName name) {\n            return mPinnedSharedPrefs.getBoolean(name.flattenToString(), false);\n        }\n\n        @Override\n        public boolean isFixedAtTop(ComponentName name) {\n            return name != null && name.equals(getNearbySharingComponent())\n                    && shouldNearbyShareBeFirstInRankedRow();\n        }\n    }\n\n    @VisibleForTesting\n    public ChooserGridAdapter createChooserGridAdapter(Context context,\n            List<Intent> payloadIntents, Intent[] initialIntents, List<ResolveInfo> rList,\n            boolean filterLastUsed, UserHandle userHandle) {\n        ChooserListAdapter chooserListAdapter = createChooserListAdapter(context, payloadIntents,\n                initialIntents, rList, filterLastUsed,\n                createListController(userHandle));\n        AppPredictor.Callback appPredictorCallback = createAppPredictorCallback(chooserListAdapter);\n        AppPredictor appPredictor = setupAppPredictorForUser(userHandle, appPredictorCallback);\n        chooserListAdapter.setAppPredictor(appPredictor);\n        chooserListAdapter.setAppPredictorCallback(appPredictorCallback);\n        return new ChooserGridAdapter(chooserListAdapter);\n    }\n\n    @VisibleForTesting\n    public ChooserListAdapter createChooserListAdapter(Context context,\n            List<Intent> payloadIntents, Intent[] initialIntents, List<ResolveInfo> rList,\n            boolean filterLastUsed, ResolverListController resolverListController) {\n        return new ChooserListAdapter(context, payloadIntents, initialIntents, rList,\n                filterLastUsed, resolverListController, this,\n                this, context.getPackageManager(),\n                getChooserActivityLogger());\n    }\n\n    @VisibleForTesting\n    protected ResolverListController createListController(UserHandle userHandle) {\n        AppPredictor appPredictor = getAppPredictorForShareActivitiesIfEnabled(userHandle);\n        AbstractResolverComparator resolverComparator;\n        if (appPredictor != null) {\n            resolverComparator = new AppPredictionServiceResolverComparator(this, getTargetIntent(),\n                    getReferrerPackageName(), appPredictor, userHandle, getChooserActivityLogger());\n        } else {\n            resolverComparator =\n                    new ResolverRankerServiceResolverComparator(this, getTargetIntent(),\n                        getReferrerPackageName(), null, getChooserActivityLogger());\n        }\n\n        return new ChooserListController(\n                this,\n                mPm,\n                getTargetIntent(),\n                getReferrerPackageName(),\n                mLaunchedFromUid,\n                userHandle,\n                resolverComparator);\n    }\n\n    @VisibleForTesting\n    protected Bitmap loadThumbnail(Uri uri, Size size) {\n        if (uri == null || size == null) {\n            return null;\n        }\n\n        try {\n            return getContentResolver().loadThumbnail(uri, size, null);\n        } catch (IOException | NullPointerException | SecurityException ex) {\n            logContentPreviewWarning(uri);\n        }\n        return null;\n    }\n\n    static final class PlaceHolderTargetInfo extends NotSelectableTargetInfo {\n        public Drawable getDisplayIcon(Context context) {\n            AnimatedVectorDrawable avd = (AnimatedVectorDrawable)\n                    context.getDrawable(R.drawable.chooser_direct_share_icon_placeholder);\n            avd.start(); // Start animation after generation\n            return avd;\n        }\n    }\n\n    protected static final class EmptyTargetInfo extends NotSelectableTargetInfo {\n        public EmptyTargetInfo() {}\n\n        public Drawable getDisplayIcon(Context context) {\n            return null;\n        }\n    }\n\n    private void handleScroll(View view, int x, int y, int oldx, int oldy) {\n        if (mChooserMultiProfilePagerAdapter.getCurrentRootAdapter() != null) {\n            mChooserMultiProfilePagerAdapter.getCurrentRootAdapter().handleScroll(view, y, oldy);\n        }\n    }\n\n    /*\n     * Need to dynamically adjust how many icons can fit per row before we add them,\n     * which also means setting the correct offset to initially show the content\n     * preview area + 2 rows of targets\n     */\n    private void handleLayoutChange(View v, int left, int top, int right, int bottom, int oldLeft,\n            int oldTop, int oldRight, int oldBottom) {\n        if (mChooserMultiProfilePagerAdapter == null) {\n            return;\n        }\n        RecyclerView recyclerView = mChooserMultiProfilePagerAdapter.getActiveAdapterView();\n        ChooserGridAdapter gridAdapter = mChooserMultiProfilePagerAdapter.getCurrentRootAdapter();\n        // Skip height calculation if recycler view was scrolled to prevent it inaccurately\n        // calculating the height, as the logic below does not account for the scrolled offset.\n        if (gridAdapter == null || recyclerView == null\n                || recyclerView.computeVerticalScrollOffset() != 0) {\n            return;\n        }\n\n        final int availableWidth = right - left - v.getPaddingLeft() - v.getPaddingRight();\n        boolean isLayoutUpdated = gridAdapter.consumeLayoutRequest()\n                || gridAdapter.calculateChooserTargetWidth(availableWidth)\n                || recyclerView.getAdapter() == null\n                || availableWidth != mCurrAvailableWidth;\n        if (isLayoutUpdated\n                || mLastNumberOfChildren != recyclerView.getChildCount()) {\n            mCurrAvailableWidth = availableWidth;\n            if (isLayoutUpdated) {\n                // It is very important we call setAdapter from here. Otherwise in some cases\n                // the resolver list doesn't get populated, such as b/150922090, b/150918223\n                // and b/150936654\n                recyclerView.setAdapter(gridAdapter);\n                ((GridLayoutManager) recyclerView.getLayoutManager()).setSpanCount(\n                        mMaxTargetsPerRow);\n\n                updateTabPadding();\n            }\n\n            UserHandle currentUserHandle = mChooserMultiProfilePagerAdapter.getCurrentUserHandle();\n            int currentProfile = getProfileForUser(currentUserHandle);\n            int initialProfile = findSelectedProfile();\n            if (currentProfile != initialProfile) {\n                return;\n            }\n\n            if (mLastNumberOfChildren == recyclerView.getChildCount()) {\n                return;\n            }\n\n            getMainThreadHandler().post(() -> {\n                if (mResolverDrawerLayout == null || gridAdapter == null) {\n                    return;\n                }\n                int offset = calculateDrawerOffset(top, bottom, recyclerView, gridAdapter);\n                mResolverDrawerLayout.setCollapsibleHeightReserved(offset);\n                mEnterTransitionAnimationDelegate.markOffsetCalculated();\n            });\n        }\n    }\n\n    private int calculateDrawerOffset(\n            int top, int bottom, RecyclerView recyclerView, ChooserGridAdapter gridAdapter) {\n\n        final int bottomInset = mSystemWindowInsets != null\n                ? mSystemWindowInsets.bottom : 0;\n        int offset = bottomInset;\n        int rowsToShow = gridAdapter.getSystemRowCount()\n                + gridAdapter.getProfileRowCount()\n                + gridAdapter.getServiceTargetRowCount()\n                + gridAdapter.getCallerAndRankedTargetRowCount();\n\n        // then this is most likely not a SEND_* action, so check\n        // the app target count\n        if (rowsToShow == 0) {\n            rowsToShow = gridAdapter.getRowCount();\n        }\n\n        // still zero? then use a default height and leave, which\n        // can happen when there are no targets to show\n        if (rowsToShow == 0 && !shouldShowStickyContentPreview()) {\n            offset += getResources().getDimensionPixelSize(\n                    R.dimen.chooser_max_collapsed_height);\n            return offset;\n        }\n\n        View stickyContentPreview = findViewById(R.id.content_preview_container);\n        if (shouldShowStickyContentPreview() && isStickyContentPreviewShowing()) {\n            offset += stickyContentPreview.getHeight();\n        }\n\n        if (shouldShowTabs()) {\n            offset += findViewById(R.id.tabs).getHeight();\n        }\n\n        if (recyclerView.getVisibility() == View.VISIBLE) {\n            int directShareHeight = 0;\n            rowsToShow = Math.min(4, rowsToShow);\n            boolean shouldShowExtraRow = shouldShowExtraRow(rowsToShow);\n            mLastNumberOfChildren = recyclerView.getChildCount();\n            for (int i = 0, childCount = recyclerView.getChildCount();\n                    i < childCount && rowsToShow > 0; i++) {\n                View child = recyclerView.getChildAt(i);\n                if (((GridLayoutManager.LayoutParams)\n                        child.getLayoutParams()).getSpanIndex() != 0) {\n                    continue;\n                }\n                int height = child.getHeight();\n                offset += height;\n                if (shouldShowExtraRow) {\n                    offset += height;\n                }\n\n                if (gridAdapter.getTargetType(\n                        recyclerView.getChildAdapterPosition(child))\n                        == ChooserListAdapter.TARGET_SERVICE) {\n                    directShareHeight = height;\n                }\n                rowsToShow--;\n            }\n\n            boolean isExpandable = getResources().getConfiguration().orientation\n                    == Configuration.ORIENTATION_PORTRAIT && !isInMultiWindowMode();\n            if (directShareHeight != 0 && isSendAction(getTargetIntent())\n                    && isExpandable) {\n                // make sure to leave room for direct share 4->8 expansion\n                int requiredExpansionHeight =\n                        (int) (directShareHeight / DIRECT_SHARE_EXPANSION_RATE);\n                int topInset = mSystemWindowInsets != null ? mSystemWindowInsets.top : 0;\n                int minHeight = bottom - top - mResolverDrawerLayout.getAlwaysShowHeight()\n                        - requiredExpansionHeight - topInset - bottomInset;\n\n                offset = Math.min(offset, minHeight);\n            }\n        } else {\n            ViewGroup currentEmptyStateView = getActiveEmptyStateView();\n            if (currentEmptyStateView.getVisibility() == View.VISIBLE) {\n                offset += currentEmptyStateView.getHeight();\n            }\n        }\n\n        return Math.min(offset, bottom - top);\n    }\n\n    /**\n     * If we have a tabbed view and are showing 1 row in the current profile and an empty\n     * state screen in the other profile, to prevent cropping of the empty state screen we show\n     * a second row in the current profile.\n     */\n    private boolean shouldShowExtraRow(int rowsToShow) {\n        return shouldShowTabs()\n                && rowsToShow == 1\n                && mChooserMultiProfilePagerAdapter.shouldShowEmptyStateScreen(\n                        mChooserMultiProfilePagerAdapter.getInactiveListAdapter());\n    }\n\n    /**\n     * Returns {@link #PROFILE_PERSONAL}, {@link #PROFILE_WORK}, or -1 if the given user handle\n     * does not match either the personal or work user handle.\n     **/\n    private int getProfileForUser(UserHandle currentUserHandle) {\n        if (currentUserHandle.equals(getPersonalProfileUserHandle())) {\n            return PROFILE_PERSONAL;\n        } else if (currentUserHandle.equals(getWorkProfileUserHandle())) {\n            return PROFILE_WORK;\n        }\n        Log.e(TAG, \"User \" + currentUserHandle + \" does not belong to a personal or work profile.\");\n        return -1;\n    }\n\n    private ViewGroup getActiveEmptyStateView() {\n        int currentPage = mChooserMultiProfilePagerAdapter.getCurrentPage();\n        return mChooserMultiProfilePagerAdapter.getItem(currentPage).getEmptyStateView();\n    }\n\n    static class BaseChooserTargetComparator implements Comparator<ChooserTarget> {\n        @Override\n        public int compare(ChooserTarget lhs, ChooserTarget rhs) {\n            // Descending order\n            return (int) Math.signum(rhs.getScore() - lhs.getScore());\n        }\n    }\n\n    @Override // ResolverListCommunicator\n    public void onHandlePackagesChanged(ResolverListAdapter listAdapter) {\n        mChooserMultiProfilePagerAdapter.getActiveListAdapter().notifyDataSetChanged();\n        super.onHandlePackagesChanged(listAdapter);\n    }\n\n    @Override // SelectableTargetInfoCommunicator\n    public ActivityInfoPresentationGetter makePresentationGetter(ActivityInfo info) {\n        return mChooserMultiProfilePagerAdapter.getActiveListAdapter().makePresentationGetter(info);\n    }\n\n    @Override // SelectableTargetInfoCommunicator\n    public Intent getReferrerFillInIntent() {\n        return mReferrerFillInIntent;\n    }\n\n    @Override // ChooserListCommunicator\n    public int getMaxRankedTargets() {\n        return mMaxTargetsPerRow;\n    }\n\n    @Override // ChooserListCommunicator\n    public void sendListViewUpdateMessage(UserHandle userHandle) {\n        Message msg = Message.obtain();\n        msg.what = ChooserHandler.LIST_VIEW_UPDATE_MESSAGE;\n        msg.obj = userHandle;\n        mChooserHandler.sendMessageDelayed(msg, mListViewUpdateDelayMs);\n    }\n\n    @Override\n    public void onListRebuilt(ResolverListAdapter listAdapter, boolean rebuildComplete) {\n        setupScrollListener();\n        maybeSetupGlobalLayoutListener();\n\n        ChooserListAdapter chooserListAdapter = (ChooserListAdapter) listAdapter;\n        if (chooserListAdapter.getUserHandle()\n                .equals(mChooserMultiProfilePagerAdapter.getCurrentUserHandle())) {\n            mChooserMultiProfilePagerAdapter.getActiveAdapterView()\n                    .setAdapter(mChooserMultiProfilePagerAdapter.getCurrentRootAdapter());\n            mChooserMultiProfilePagerAdapter\n                    .setupListAdapter(mChooserMultiProfilePagerAdapter.getCurrentPage());\n        }\n\n        if (chooserListAdapter.mDisplayList == null\n                || chooserListAdapter.mDisplayList.isEmpty()) {\n            chooserListAdapter.notifyDataSetChanged();\n        } else {\n            chooserListAdapter.updateAlphabeticalList();\n        }\n\n        if (rebuildComplete) {\n            getChooserActivityLogger().logSharesheetAppLoadComplete();\n            maybeQueryAdditionalPostProcessingTargets(chooserListAdapter);\n            mLatencyTracker.onActionEnd(ACTION_LOAD_SHARE_SHEET);\n        }\n    }\n\n    private void maybeQueryAdditionalPostProcessingTargets(ChooserListAdapter chooserListAdapter) {\n        // don't support direct share on low ram devices\n        if (ActivityManager.isLowRamDeviceStatic()) {\n            return;\n        }\n\n        // no need to query direct share for work profile when its locked or disabled\n        if (!shouldQueryShortcutManager(chooserListAdapter.getUserHandle())) {\n            return;\n        }\n\n        if (ChooserFlags.USE_PREDICTION_MANAGER_FOR_DIRECT_TARGETS) {\n            if (DEBUG) {\n                Log.d(TAG, \"querying direct share targets from ShortcutManager\");\n            }\n\n            queryDirectShareTargets(chooserListAdapter, false);\n        }\n    }\n\n    @VisibleForTesting\n    protected boolean isUserRunning(UserHandle userHandle) {\n        UserManager userManager = getSystemService(UserManager.class);\n        return userManager.isUserRunning(userHandle);\n    }\n\n    @VisibleForTesting\n    protected boolean isUserUnlocked(UserHandle userHandle) {\n        UserManager userManager = getSystemService(UserManager.class);\n        return userManager.isUserUnlocked(userHandle);\n    }\n\n    @VisibleForTesting\n    protected boolean isQuietModeEnabled(UserHandle userHandle) {\n        UserManager userManager = getSystemService(UserManager.class);\n        return userManager.isQuietModeEnabled(userHandle);\n    }\n\n    private void setupScrollListener() {\n        if (mResolverDrawerLayout == null) {\n            return;\n        }\n        int elevatedViewResId = shouldShowTabs() ? R.id.tabs : R.id.chooser_header;\n        final View elevatedView = mResolverDrawerLayout.findViewById(elevatedViewResId);\n        final float defaultElevation = elevatedView.getElevation();\n        final float chooserHeaderScrollElevation =\n                getResources().getDimensionPixelSize(R.dimen.chooser_header_scroll_elevation);\n        mChooserMultiProfilePagerAdapter.getActiveAdapterView().addOnScrollListener(\n                new RecyclerView.OnScrollListener() {\n                    public void onScrollStateChanged(RecyclerView view, int scrollState) {\n                        if (scrollState == RecyclerView.SCROLL_STATE_IDLE) {\n                            if (mScrollStatus == SCROLL_STATUS_SCROLLING_VERTICAL) {\n                                mScrollStatus = SCROLL_STATUS_IDLE;\n                                setHorizontalScrollingEnabled(true);\n                            }\n                        } else if (scrollState == RecyclerView.SCROLL_STATE_DRAGGING) {\n                            if (mScrollStatus == SCROLL_STATUS_IDLE) {\n                                mScrollStatus = SCROLL_STATUS_SCROLLING_VERTICAL;\n                                setHorizontalScrollingEnabled(false);\n                            }\n                        }\n                    }\n\n                    public void onScrolled(RecyclerView view, int dx, int dy) {\n                        if (view.getChildCount() > 0) {\n                            View child = view.getLayoutManager().findViewByPosition(0);\n                            if (child == null || child.getTop() < 0) {\n                                elevatedView.setElevation(chooserHeaderScrollElevation);\n                                return;\n                            }\n                        }\n\n                        elevatedView.setElevation(defaultElevation);\n                    }\n                });\n    }\n\n    private void maybeSetupGlobalLayoutListener() {\n        if (shouldShowTabs()) {\n            return;\n        }\n        final View recyclerView = mChooserMultiProfilePagerAdapter.getActiveAdapterView();\n        recyclerView.getViewTreeObserver()\n                .addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {\n                    @Override\n                    public void onGlobalLayout() {\n                        // Fixes an issue were the accessibility border disappears on list creation.\n                        recyclerView.getViewTreeObserver().removeOnGlobalLayoutListener(this);\n                        final TextView titleView = findViewById(R.id.title);\n                        if (titleView != null) {\n                            titleView.setFocusable(true);\n                            titleView.setFocusableInTouchMode(true);\n                            titleView.requestFocus();\n                            titleView.requestAccessibilityFocus();\n                        }\n                    }\n                });\n    }\n\n    @Override // ChooserListCommunicator\n    public boolean isSendAction(Intent targetIntent) {\n        if (targetIntent == null) {\n            return false;\n        }\n\n        String action = targetIntent.getAction();\n        if (action == null) {\n            return false;\n        }\n\n        if (Intent.ACTION_SEND.equals(action) || Intent.ACTION_SEND_MULTIPLE.equals(action)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * The sticky content preview is shown only when we have a tabbed view. It's shown above\n     * the tabs so it is not part of the scrollable list. If we are not in tabbed view,\n     * we instead show the content preview as a regular list item.\n     */\n    private boolean shouldShowStickyContentPreview() {\n        return shouldShowStickyContentPreviewNoOrientationCheck()\n                && !getResources().getBoolean(R.bool.resolver_landscape_phone);\n    }\n\n    private boolean shouldShowStickyContentPreviewNoOrientationCheck() {\n        return shouldShowTabs()\n                && mMultiProfilePagerAdapter.getListAdapterForUserHandle(\n                UserHandle.of(UserHandle.myUserId())).getCount() > 0\n                && isSendAction(getTargetIntent());\n    }\n\n    private void updateStickyContentPreview() {\n        if (shouldShowStickyContentPreviewNoOrientationCheck()) {\n            // The sticky content preview is only shown when we show the work and personal tabs.\n            // We don't show it in landscape as otherwise there is no room for scrolling.\n            // If the sticky content preview will be shown at some point with orientation change,\n            // then always preload it to avoid subsequent resizing of the share sheet.\n            ViewGroup contentPreviewContainer = findViewById(R.id.content_preview_container);\n            if (contentPreviewContainer.getChildCount() == 0) {\n                ViewGroup contentPreviewView = createContentPreviewView(contentPreviewContainer);\n                contentPreviewContainer.addView(contentPreviewView);\n            }\n        }\n        if (shouldShowStickyContentPreview()) {\n            showStickyContentPreview();\n        } else {\n            hideStickyContentPreview();\n        }\n    }\n\n    private void showStickyContentPreview() {\n        if (isStickyContentPreviewShowing()) {\n            return;\n        }\n        ViewGroup contentPreviewContainer = findViewById(R.id.content_preview_container);\n        contentPreviewContainer.setVisibility(View.VISIBLE);\n    }\n\n    private boolean isStickyContentPreviewShowing() {\n        ViewGroup contentPreviewContainer = findViewById(R.id.content_preview_container);\n        return contentPreviewContainer.getVisibility() == View.VISIBLE;\n    }\n\n    private void hideStickyContentPreview() {\n        if (!isStickyContentPreviewShowing()) {\n            return;\n        }\n        ViewGroup contentPreviewContainer = findViewById(R.id.content_preview_container);\n        contentPreviewContainer.setVisibility(View.GONE);\n    }\n\n    private void logActionShareWithPreview() {\n        Intent targetIntent = getTargetIntent();\n        int previewType = findPreferredContentPreview(targetIntent, getContentResolver());\n        getMetricsLogger().write(new LogMaker(MetricsEvent.ACTION_SHARE_WITH_PREVIEW)\n                .setSubtype(previewType));\n    }\n\n    abstract static class ViewHolderBase extends RecyclerView.ViewHolder {\n        private int mViewType;\n\n        ViewHolderBase(View itemView, int viewType) {\n            super(itemView);\n            this.mViewType = viewType;\n        }\n\n        int getViewType() {\n            return mViewType;\n        }\n    }\n\n    /**\n     * Used to bind types of individual item including\n     * {@link ChooserGridAdapter#VIEW_TYPE_NORMAL},\n     * {@link ChooserGridAdapter#VIEW_TYPE_CONTENT_PREVIEW},\n     * {@link ChooserGridAdapter#VIEW_TYPE_PROFILE},\n     * and {@link ChooserGridAdapter#VIEW_TYPE_AZ_LABEL}.\n     */\n    final class ItemViewHolder extends ViewHolderBase {\n        ResolverListAdapter.ViewHolder mWrappedViewHolder;\n        int mListPosition = ChooserListAdapter.NO_POSITION;\n\n        ItemViewHolder(View itemView, boolean isClickable, int viewType) {\n            super(itemView, viewType);\n            mWrappedViewHolder = new ResolverListAdapter.ViewHolder(itemView);\n            if (isClickable) {\n                itemView.setOnClickListener(v -> startSelected(mListPosition,\n                        false/* always */, true/* filterd */));\n\n                itemView.setOnLongClickListener(v -> {\n                    final TargetInfo ti = mChooserMultiProfilePagerAdapter.getActiveListAdapter()\n                            .targetInfoForPosition(mListPosition, /* filtered */ true);\n\n                    // This should always be the case for ItemViewHolder, check for validity\n                    if (ti instanceof DisplayResolveInfo && shouldShowTargetDetails(ti)) {\n                        showTargetDetails((DisplayResolveInfo) ti);\n                    }\n                    return true;\n                });\n            }\n        }\n    }\n\n    private boolean shouldShowTargetDetails(TargetInfo ti) {\n        ComponentName nearbyShare = getNearbySharingComponent();\n        //  Suppress target details for nearby share to hide pin/unpin action\n        boolean isNearbyShare = nearbyShare != null && nearbyShare.equals(\n                ti.getResolvedComponentName()) && shouldNearbyShareBeFirstInRankedRow();\n        return ti instanceof SelectableTargetInfo\n                || (ti instanceof DisplayResolveInfo && !isNearbyShare);\n    }\n\n    /**\n     * Add a footer to the list, to support scrolling behavior below the navbar.\n     */\n    static final class FooterViewHolder extends ViewHolderBase {\n        FooterViewHolder(View itemView, int viewType) {\n            super(itemView, viewType);\n        }\n    }\n\n    /**\n     * Intentionally override the {@link ResolverActivity} implementation as we only need that\n     * implementation for the intent resolver case.\n     */\n    @Override\n    public void onButtonClick(View v) {}\n\n    /**\n     * Intentionally override the {@link ResolverActivity} implementation as we only need that\n     * implementation for the intent resolver case.\n     */\n    @Override\n    protected void resetButtonBar() {}\n\n    @Override\n    protected String getMetricsCategory() {\n        return METRICS_CATEGORY_CHOOSER;\n    }\n\n    @Override\n    protected void onProfileTabSelected() {\n        ChooserGridAdapter currentRootAdapter =\n                mChooserMultiProfilePagerAdapter.getCurrentRootAdapter();\n        currentRootAdapter.updateDirectShareExpansion();\n        // This fixes an edge case where after performing a variety of gestures, vertical scrolling\n        // ends up disabled. That's because at some point the old tab's vertical scrolling is\n        // disabled and the new tab's is enabled. For context, see b/159997845\n        setVerticalScrollEnabled(true);\n        if (mResolverDrawerLayout != null) {\n            mResolverDrawerLayout.scrollNestedScrollableChildBackToTop();\n        }\n    }\n\n    @Override\n    protected WindowInsets onApplyWindowInsets(View v, WindowInsets insets) {\n        if (shouldShowTabs()) {\n            mChooserMultiProfilePagerAdapter\n                    .setEmptyStateBottomOffset(insets.getSystemWindowInsetBottom());\n            mChooserMultiProfilePagerAdapter.setupContainerPadding(\n                    getActiveEmptyStateView().findViewById(R.id.resolver_empty_state_container));\n        }\n        return super.onApplyWindowInsets(v, insets);\n    }\n\n    private void setHorizontalScrollingEnabled(boolean enabled) {\n        ResolverViewPager viewPager = findViewById(R.id.profile_pager);\n        viewPager.setSwipingEnabled(enabled);\n    }\n\n    private void setVerticalScrollEnabled(boolean enabled) {\n        ChooserGridLayoutManager layoutManager =\n                (ChooserGridLayoutManager) mChooserMultiProfilePagerAdapter.getActiveAdapterView()\n                        .getLayoutManager();\n        layoutManager.setVerticalScrollEnabled(enabled);\n    }\n\n    @Override\n    void onHorizontalSwipeStateChanged(int state) {\n        if (state == ViewPager.SCROLL_STATE_DRAGGING) {\n            if (mScrollStatus == SCROLL_STATUS_IDLE) {\n                mScrollStatus = SCROLL_STATUS_SCROLLING_HORIZONTAL;\n                setVerticalScrollEnabled(false);\n            }\n        } else if (state == ViewPager.SCROLL_STATE_IDLE) {\n            if (mScrollStatus == SCROLL_STATUS_SCROLLING_HORIZONTAL) {\n                mScrollStatus = SCROLL_STATUS_IDLE;\n                setVerticalScrollEnabled(true);\n            }\n        }\n    }\n\n    /**\n     * Adapter for all types of items and targets in ShareSheet.\n     * Note that ranked sections like Direct Share - while appearing grid-like - are handled on the\n     * row level by this adapter but not on the item level. Individual targets within the row are\n     * handled by {@link ChooserListAdapter}\n     */\n    @VisibleForTesting\n    public final class ChooserGridAdapter extends RecyclerView.Adapter<RecyclerView.ViewHolder> {\n        private ChooserListAdapter mChooserListAdapter;\n        private final LayoutInflater mLayoutInflater;\n\n        private DirectShareViewHolder mDirectShareViewHolder;\n        private int mChooserTargetWidth = 0;\n        private boolean mShowAzLabelIfPoss;\n        private boolean mLayoutRequested = false;\n\n        private int mFooterHeight = 0;\n\n        private static final int VIEW_TYPE_DIRECT_SHARE = 0;\n        private static final int VIEW_TYPE_NORMAL = 1;\n        private static final int VIEW_TYPE_CONTENT_PREVIEW = 2;\n        private static final int VIEW_TYPE_PROFILE = 3;\n        private static final int VIEW_TYPE_AZ_LABEL = 4;\n        private static final int VIEW_TYPE_CALLER_AND_RANK = 5;\n        private static final int VIEW_TYPE_FOOTER = 6;\n\n        private static final int NUM_EXPANSIONS_TO_HIDE_AZ_LABEL = 20;\n\n        ChooserGridAdapter(ChooserListAdapter wrappedAdapter) {\n            super();\n            mChooserListAdapter = wrappedAdapter;\n            mLayoutInflater = LayoutInflater.from(ChooserActivity.this);\n\n            mShowAzLabelIfPoss = getNumSheetExpansions() < NUM_EXPANSIONS_TO_HIDE_AZ_LABEL;\n\n            wrappedAdapter.registerDataSetObserver(new DataSetObserver() {\n                @Override\n                public void onChanged() {\n                    super.onChanged();\n                    notifyDataSetChanged();\n                }\n\n                @Override\n                public void onInvalidated() {\n                    super.onInvalidated();\n                    notifyDataSetChanged();\n                }\n            });\n        }\n\n        public void setFooterHeight(int height) {\n            mFooterHeight = height;\n        }\n\n        /**\n         * Calculate the chooser target width to maximize space per item\n         *\n         * @param width The new row width to use for recalculation\n         * @return true if the view width has changed\n         */\n        public boolean calculateChooserTargetWidth(int width) {\n            if (width == 0) {\n                return false;\n            }\n\n            // Limit width to the maximum width of the chooser activity\n            int maxWidth = getResources().getDimensionPixelSize(R.dimen.chooser_width);\n            width = Math.min(maxWidth, width);\n\n            int newWidth = width / mMaxTargetsPerRow;\n            if (newWidth != mChooserTargetWidth) {\n                mChooserTargetWidth = newWidth;\n                return true;\n            }\n\n            return false;\n        }\n\n        /**\n         * Hides the list item content preview.\n         * <p>Not to be confused with the sticky content preview which is above the\n         * personal and work tabs.\n         */\n        public void hideContentPreview() {\n            mLayoutRequested = true;\n            notifyDataSetChanged();\n        }\n\n        public boolean consumeLayoutRequest() {\n            boolean oldValue = mLayoutRequested;\n            mLayoutRequested = false;\n            return oldValue;\n        }\n\n        public int getRowCount() {\n            return (int) (\n                    getSystemRowCount()\n                            + getProfileRowCount()\n                            + getServiceTargetRowCount()\n                            + getCallerAndRankedTargetRowCount()\n                            + getAzLabelRowCount()\n                            + Math.ceil(\n                            (float) mChooserListAdapter.getAlphaTargetCount()\n                                    / mMaxTargetsPerRow)\n            );\n        }\n\n        /**\n         * Whether the \"system\" row of targets is displayed.\n         * This area includes the content preview (if present) and action row.\n         */\n        public int getSystemRowCount() {\n            // For the tabbed case we show the sticky content preview above the tabs,\n            // please refer to shouldShowStickyContentPreview\n            if (shouldShowTabs()) {\n                return 0;\n            }\n\n            if (!isSendAction(getTargetIntent())) {\n                return 0;\n            }\n\n            if (mChooserListAdapter == null || mChooserListAdapter.getCount() == 0) {\n                return 0;\n            }\n\n            return 1;\n        }\n\n        public int getProfileRowCount() {\n            if (shouldShowTabs()) {\n                return 0;\n            }\n            return mChooserListAdapter.getOtherProfile() == null ? 0 : 1;\n        }\n\n        public int getFooterRowCount() {\n            return 1;\n        }\n\n        public int getCallerAndRankedTargetRowCount() {\n            return (int) Math.ceil(\n                    ((float) mChooserListAdapter.getCallerTargetCount()\n                            + mChooserListAdapter.getRankedTargetCount()) / mMaxTargetsPerRow);\n        }\n\n        // There can be at most one row in the listview, that is internally\n        // a ViewGroup with 2 rows\n        public int getServiceTargetRowCount() {\n            if (isSendAction(getTargetIntent())\n                    && !ActivityManager.isLowRamDeviceStatic()) {\n                return 1;\n            }\n            return 0;\n        }\n\n        public int getAzLabelRowCount() {\n            // Only show a label if the a-z list is showing\n            return (mShowAzLabelIfPoss && mChooserListAdapter.getAlphaTargetCount() > 0) ? 1 : 0;\n        }\n\n        @Override\n        public int getItemCount() {\n            return (int) (\n                    getSystemRowCount()\n                            + getProfileRowCount()\n                            + getServiceTargetRowCount()\n                            + getCallerAndRankedTargetRowCount()\n                            + getAzLabelRowCount()\n                            + mChooserListAdapter.getAlphaTargetCount()\n                            + getFooterRowCount()\n            );\n        }\n\n        @Override\n        public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n            switch (viewType) {\n                case VIEW_TYPE_CONTENT_PREVIEW:\n                    return new ItemViewHolder(createContentPreviewView(parent), false, viewType);\n                case VIEW_TYPE_PROFILE:\n                    return new ItemViewHolder(createProfileView(parent), false, viewType);\n                case VIEW_TYPE_AZ_LABEL:\n                    return new ItemViewHolder(createAzLabelView(parent), false, viewType);\n                case VIEW_TYPE_NORMAL:\n                    return new ItemViewHolder(\n                            mChooserListAdapter.createView(parent), true, viewType);\n                case VIEW_TYPE_DIRECT_SHARE:\n                case VIEW_TYPE_CALLER_AND_RANK:\n                    return createItemGroupViewHolder(viewType, parent);\n                case VIEW_TYPE_FOOTER:\n                    Space sp = new Space(parent.getContext());\n                    sp.setLayoutParams(new RecyclerView.LayoutParams(\n                            LayoutParams.MATCH_PARENT, mFooterHeight));\n                    return new FooterViewHolder(sp, viewType);\n                default:\n                    // Since we catch all possible viewTypes above, no chance this is being called.\n                    return null;\n            }\n        }\n\n        @Override\n        public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) {\n            int viewType = ((ViewHolderBase) holder).getViewType();\n            switch (viewType) {\n                case VIEW_TYPE_DIRECT_SHARE:\n                case VIEW_TYPE_CALLER_AND_RANK:\n                    bindItemGroupViewHolder(position, (ItemGroupViewHolder) holder);\n                    break;\n                case VIEW_TYPE_NORMAL:\n                    bindItemViewHolder(position, (ItemViewHolder) holder);\n                    break;\n                default:\n            }\n        }\n\n        @Override\n        public int getItemViewType(int position) {\n            int count;\n\n            int countSum = (count = getSystemRowCount());\n            if (count > 0 && position < countSum) return VIEW_TYPE_CONTENT_PREVIEW;\n\n            countSum += (count = getProfileRowCount());\n            if (count > 0 && position < countSum) return VIEW_TYPE_PROFILE;\n\n            countSum += (count = getServiceTargetRowCount());\n            if (count > 0 && position < countSum) return VIEW_TYPE_DIRECT_SHARE;\n\n            countSum += (count = getCallerAndRankedTargetRowCount());\n            if (count > 0 && position < countSum) return VIEW_TYPE_CALLER_AND_RANK;\n\n            countSum += (count = getAzLabelRowCount());\n            if (count > 0 && position < countSum) return VIEW_TYPE_AZ_LABEL;\n\n            if (position == getItemCount() - 1) return VIEW_TYPE_FOOTER;\n\n            return VIEW_TYPE_NORMAL;\n        }\n\n        public int getTargetType(int position) {\n            return mChooserListAdapter.getPositionTargetType(getListPosition(position));\n        }\n\n        private View createProfileView(ViewGroup parent) {\n            View profileRow = mLayoutInflater.inflate(R.layout.chooser_profile_row, parent, false);\n            mProfileView = profileRow.findViewById(R.id.profile_button);\n            mProfileView.setOnClickListener(ChooserActivity.this::onProfileClick);\n            updateProfileViewButton();\n            return profileRow;\n        }\n\n        private View createAzLabelView(ViewGroup parent) {\n            return mLayoutInflater.inflate(R.layout.chooser_az_label_row, parent, false);\n        }\n\n        private ItemGroupViewHolder loadViewsIntoGroup(ItemGroupViewHolder holder) {\n            final int spec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);\n            final int exactSpec = MeasureSpec.makeMeasureSpec(mChooserTargetWidth,\n                    MeasureSpec.EXACTLY);\n            int columnCount = holder.getColumnCount();\n\n            final boolean isDirectShare = holder instanceof DirectShareViewHolder;\n\n            for (int i = 0; i < columnCount; i++) {\n                final View v = mChooserListAdapter.createView(holder.getRowByIndex(i));\n                final int column = i;\n                v.setOnClickListener(new OnClickListener() {\n                    @Override\n                    public void onClick(View v) {\n                        startSelected(holder.getItemIndex(column), false, true);\n                    }\n                });\n\n                // Show menu for both direct share and app share targets after long click.\n                v.setOnLongClickListener(v1 -> {\n                    TargetInfo ti = mChooserListAdapter.targetInfoForPosition(\n                            holder.getItemIndex(column), true);\n                    if (shouldShowTargetDetails(ti)) {\n                        showTargetDetails(ti);\n                    }\n                    return true;\n                });\n\n                holder.addView(i, v);\n\n                // Force Direct Share to be 2 lines and auto-wrap to second line via hoz scroll =\n                // false. TextView#setHorizontallyScrolling must be reset after #setLines. Must be\n                // done before measuring.\n                if (isDirectShare) {\n                    final ViewHolder vh = (ViewHolder) v.getTag();\n                    vh.text.setLines(2);\n                    vh.text.setHorizontallyScrolling(false);\n                    vh.text2.setVisibility(View.GONE);\n                }\n\n                // Force height to be a given so we don't have visual disruption during scaling.\n                v.measure(exactSpec, spec);\n                setViewBounds(v, v.getMeasuredWidth(), v.getMeasuredHeight());\n            }\n\n            final ViewGroup viewGroup = holder.getViewGroup();\n\n            // Pre-measure and fix height so we can scale later.\n            holder.measure();\n            setViewBounds(viewGroup, LayoutParams.MATCH_PARENT, holder.getMeasuredRowHeight());\n\n            if (isDirectShare) {\n                DirectShareViewHolder dsvh = (DirectShareViewHolder) holder;\n                setViewBounds(dsvh.getRow(0), LayoutParams.MATCH_PARENT, dsvh.getMinRowHeight());\n                setViewBounds(dsvh.getRow(1), LayoutParams.MATCH_PARENT, dsvh.getMinRowHeight());\n            }\n\n            viewGroup.setTag(holder);\n            return holder;\n        }\n\n        private void setViewBounds(View view, int widthPx, int heightPx) {\n            LayoutParams lp = view.getLayoutParams();\n            if (lp == null) {\n                lp = new LayoutParams(widthPx, heightPx);\n                view.setLayoutParams(lp);\n            } else {\n                lp.height = heightPx;\n                lp.width = widthPx;\n            }\n        }\n\n        ItemGroupViewHolder createItemGroupViewHolder(int viewType, ViewGroup parent) {\n            if (viewType == VIEW_TYPE_DIRECT_SHARE) {\n                ViewGroup parentGroup = (ViewGroup) mLayoutInflater.inflate(\n                        R.layout.chooser_row_direct_share, parent, false);\n                ViewGroup row1 = (ViewGroup) mLayoutInflater.inflate(R.layout.chooser_row,\n                        parentGroup, false);\n                ViewGroup row2 = (ViewGroup) mLayoutInflater.inflate(R.layout.chooser_row,\n                        parentGroup, false);\n                parentGroup.addView(row1);\n                parentGroup.addView(row2);\n\n                mDirectShareViewHolder = new DirectShareViewHolder(parentGroup,\n                        Lists.newArrayList(row1, row2), mMaxTargetsPerRow, viewType,\n                        mChooserMultiProfilePagerAdapter::getActiveListAdapter);\n                loadViewsIntoGroup(mDirectShareViewHolder);\n\n                return mDirectShareViewHolder;\n            } else {\n                ViewGroup row = (ViewGroup) mLayoutInflater.inflate(R.layout.chooser_row, parent,\n                        false);\n                ItemGroupViewHolder holder =\n                        new SingleRowViewHolder(row, mMaxTargetsPerRow, viewType);\n                loadViewsIntoGroup(holder);\n\n                return holder;\n            }\n        }\n\n        /**\n         * Need to merge CALLER + ranked STANDARD into a single row and prevent a separator from\n         * showing on top of the AZ list if the AZ label is visible. All other types are placed into\n         * their own row as determined by their target type, and dividers are added in the list to\n         * separate each type.\n         */\n        int getRowType(int rowPosition) {\n            // Merge caller and ranked standard into a single row\n            int positionType = mChooserListAdapter.getPositionTargetType(rowPosition);\n            if (positionType == ChooserListAdapter.TARGET_CALLER) {\n                return ChooserListAdapter.TARGET_STANDARD;\n            }\n\n            // If an the A-Z label is shown, prevent a separator from appearing by making the A-Z\n            // row type the same as the suggestion row type\n            if (getAzLabelRowCount() > 0 && positionType == ChooserListAdapter.TARGET_STANDARD_AZ) {\n                return ChooserListAdapter.TARGET_STANDARD;\n            }\n\n            return positionType;\n        }\n\n        void bindItemViewHolder(int position, ItemViewHolder holder) {\n            View v = holder.itemView;\n            int listPosition = getListPosition(position);\n            holder.mListPosition = listPosition;\n            mChooserListAdapter.bindView(listPosition, v);\n        }\n\n        void bindItemGroupViewHolder(int position, ItemGroupViewHolder holder) {\n            final ViewGroup viewGroup = (ViewGroup) holder.itemView;\n            int start = getListPosition(position);\n            int startType = getRowType(start);\n\n            int columnCount = holder.getColumnCount();\n            int end = start + columnCount - 1;\n            while (getRowType(end) != startType && end >= start) {\n                end--;\n            }\n\n            if (end == start && mChooserListAdapter.getItem(start) instanceof EmptyTargetInfo) {\n                final TextView textView = viewGroup.findViewById(R.id.chooser_row_text_option);\n\n                if (textView.getVisibility() != View.VISIBLE) {\n                    textView.setAlpha(0.0f);\n                    textView.setVisibility(View.VISIBLE);\n                    textView.setText(R.string.chooser_no_direct_share_targets);\n\n                    ValueAnimator fadeAnim = ObjectAnimator.ofFloat(textView, \"alpha\", 0.0f, 1.0f);\n                    fadeAnim.setInterpolator(new DecelerateInterpolator(1.0f));\n\n                    float translationInPx = getResources().getDimensionPixelSize(\n                            R.dimen.chooser_row_text_option_translate);\n                    textView.setTranslationY(translationInPx);\n                    ValueAnimator translateAnim = ObjectAnimator.ofFloat(textView, \"translationY\",\n                            0.0f);\n                    translateAnim.setInterpolator(new DecelerateInterpolator(1.0f));\n\n                    AnimatorSet animSet = new AnimatorSet();\n                    animSet.setDuration(NO_DIRECT_SHARE_ANIM_IN_MILLIS);\n                    animSet.setStartDelay(NO_DIRECT_SHARE_ANIM_IN_MILLIS);\n                    animSet.playTogether(fadeAnim, translateAnim);\n                    animSet.start();\n                }\n            }\n\n            for (int i = 0; i < columnCount; i++) {\n                final View v = holder.getView(i);\n\n                if (start + i <= end) {\n                    holder.setViewVisibility(i, View.VISIBLE);\n                    holder.setItemIndex(i, start + i);\n                    mChooserListAdapter.bindView(holder.getItemIndex(i), v);\n                } else {\n                    holder.setViewVisibility(i, View.INVISIBLE);\n                }\n            }\n        }\n\n        int getListPosition(int position) {\n            position -= getSystemRowCount() + getProfileRowCount();\n\n            final int serviceCount = mChooserListAdapter.getServiceTargetCount();\n            final int serviceRows = (int) Math.ceil((float) serviceCount / getMaxRankedTargets());\n            if (position < serviceRows) {\n                return position * mMaxTargetsPerRow;\n            }\n\n            position -= serviceRows;\n\n            final int callerAndRankedCount = mChooserListAdapter.getCallerTargetCount()\n                                                 + mChooserListAdapter.getRankedTargetCount();\n            final int callerAndRankedRows = getCallerAndRankedTargetRowCount();\n            if (position < callerAndRankedRows) {\n                return serviceCount + position * mMaxTargetsPerRow;\n            }\n\n            position -= getAzLabelRowCount() + callerAndRankedRows;\n\n            return callerAndRankedCount + serviceCount + position;\n        }\n\n        public void handleScroll(View v, int y, int oldy) {\n            boolean canExpandDirectShare = canExpandDirectShare();\n            if (mDirectShareViewHolder != null && canExpandDirectShare) {\n                mDirectShareViewHolder.handleScroll(\n                        mChooserMultiProfilePagerAdapter.getActiveAdapterView(), y, oldy,\n                        mMaxTargetsPerRow);\n            }\n        }\n\n        /**\n         * Only expand direct share area if there is a minimum number of targets.\n         */\n        private boolean canExpandDirectShare() {\n            // Do not enable until we have confirmed more apps are using sharing shortcuts\n            // Check git history for enablement logic\n            return false;\n        }\n\n        public ChooserListAdapter getListAdapter() {\n            return mChooserListAdapter;\n        }\n\n        boolean shouldCellSpan(int position) {\n            return getItemViewType(position) == VIEW_TYPE_NORMAL;\n        }\n\n        void updateDirectShareExpansion() {\n            if (mDirectShareViewHolder == null || !canExpandDirectShare()) {\n                return;\n            }\n            RecyclerView activeAdapterView =\n                    mChooserMultiProfilePagerAdapter.getActiveAdapterView();\n            if (mResolverDrawerLayout.isCollapsed()) {\n                mDirectShareViewHolder.collapse(activeAdapterView);\n            } else {\n                mDirectShareViewHolder.expand(activeAdapterView);\n            }\n        }\n    }\n\n    /**\n     * Used to bind types for group of items including:\n     * {@link ChooserGridAdapter#VIEW_TYPE_DIRECT_SHARE},\n     * and {@link ChooserGridAdapter#VIEW_TYPE_CALLER_AND_RANK}.\n     */\n    abstract static class ItemGroupViewHolder extends ViewHolderBase {\n        protected int mMeasuredRowHeight;\n        private int[] mItemIndices;\n        protected final View[] mCells;\n        private final int mColumnCount;\n\n        ItemGroupViewHolder(int cellCount, View itemView, int viewType) {\n            super(itemView, viewType);\n            this.mCells = new View[cellCount];\n            this.mItemIndices = new int[cellCount];\n            this.mColumnCount = cellCount;\n        }\n\n        abstract ViewGroup addView(int index, View v);\n\n        abstract ViewGroup getViewGroup();\n\n        abstract ViewGroup getRowByIndex(int index);\n\n        abstract ViewGroup getRow(int rowNumber);\n\n        abstract void setViewVisibility(int i, int visibility);\n\n        public int getColumnCount() {\n            return mColumnCount;\n        }\n\n        public void measure() {\n            final int spec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);\n            getViewGroup().measure(spec, spec);\n            mMeasuredRowHeight = getViewGroup().getMeasuredHeight();\n        }\n\n        public int getMeasuredRowHeight() {\n            return mMeasuredRowHeight;\n        }\n\n        public void setItemIndex(int itemIndex, int listIndex) {\n            mItemIndices[itemIndex] = listIndex;\n        }\n\n        public int getItemIndex(int itemIndex) {\n            return mItemIndices[itemIndex];\n        }\n\n        public View getView(int index) {\n            return mCells[index];\n        }\n    }\n\n    static class SingleRowViewHolder extends ItemGroupViewHolder {\n        private final ViewGroup mRow;\n\n        SingleRowViewHolder(ViewGroup row, int cellCount, int viewType) {\n            super(cellCount, row, viewType);\n\n            this.mRow = row;\n        }\n\n        public ViewGroup getViewGroup() {\n            return mRow;\n        }\n\n        public ViewGroup getRowByIndex(int index) {\n            return mRow;\n        }\n\n        public ViewGroup getRow(int rowNumber) {\n            if (rowNumber == 0) return mRow;\n            return null;\n        }\n\n        public ViewGroup addView(int index, View v) {\n            mRow.addView(v);\n            mCells[index] = v;\n\n            return mRow;\n        }\n\n        public void setViewVisibility(int i, int visibility) {\n            getView(i).setVisibility(visibility);\n        }\n    }\n\n    static class DirectShareViewHolder extends ItemGroupViewHolder {\n        private final ViewGroup mParent;\n        private final List<ViewGroup> mRows;\n        private int mCellCountPerRow;\n\n        private boolean mHideDirectShareExpansion = false;\n        private int mDirectShareMinHeight = 0;\n        private int mDirectShareCurrHeight = 0;\n        private int mDirectShareMaxHeight = 0;\n\n        private final boolean[] mCellVisibility;\n\n        private final Supplier<ChooserListAdapter> mListAdapterSupplier;\n\n        DirectShareViewHolder(ViewGroup parent, List<ViewGroup> rows, int cellCountPerRow,\n                int viewType, Supplier<ChooserListAdapter> listAdapterSupplier) {\n            super(rows.size() * cellCountPerRow, parent, viewType);\n\n            this.mParent = parent;\n            this.mRows = rows;\n            this.mCellCountPerRow = cellCountPerRow;\n            this.mCellVisibility = new boolean[rows.size() * cellCountPerRow];\n            this.mListAdapterSupplier = listAdapterSupplier;\n        }\n\n        public ViewGroup addView(int index, View v) {\n            ViewGroup row = getRowByIndex(index);\n            row.addView(v);\n            mCells[index] = v;\n\n            return row;\n        }\n\n        public ViewGroup getViewGroup() {\n            return mParent;\n        }\n\n        public ViewGroup getRowByIndex(int index) {\n            return mRows.get(index / mCellCountPerRow);\n        }\n\n        public ViewGroup getRow(int rowNumber) {\n            return mRows.get(rowNumber);\n        }\n\n        public void measure() {\n            final int spec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);\n            getRow(0).measure(spec, spec);\n            getRow(1).measure(spec, spec);\n\n            mDirectShareMinHeight = getRow(0).getMeasuredHeight();\n            mDirectShareCurrHeight = mDirectShareCurrHeight > 0\n                    ? mDirectShareCurrHeight : mDirectShareMinHeight;\n            mDirectShareMaxHeight = 2 * mDirectShareMinHeight;\n        }\n\n        public int getMeasuredRowHeight() {\n            return mDirectShareCurrHeight;\n        }\n\n        public int getMinRowHeight() {\n            return mDirectShareMinHeight;\n        }\n\n        public void setViewVisibility(int i, int visibility) {\n            final View v = getView(i);\n            if (visibility == View.VISIBLE) {\n                mCellVisibility[i] = true;\n                v.setVisibility(visibility);\n                v.setAlpha(1.0f);\n            } else if (visibility == View.INVISIBLE && mCellVisibility[i]) {\n                mCellVisibility[i] = false;\n\n                ValueAnimator fadeAnim = ObjectAnimator.ofFloat(v, \"alpha\", 1.0f, 0f);\n                fadeAnim.setDuration(NO_DIRECT_SHARE_ANIM_IN_MILLIS);\n                fadeAnim.setInterpolator(new AccelerateInterpolator(1.0f));\n                fadeAnim.addListener(new AnimatorListenerAdapter() {\n                    public void onAnimationEnd(Animator animation) {\n                        v.setVisibility(View.INVISIBLE);\n                    }\n                });\n                fadeAnim.start();\n            }\n        }\n\n        public void handleScroll(RecyclerView view, int y, int oldy, int maxTargetsPerRow) {\n            // only exit early if fully collapsed, otherwise onListRebuilt() with shifting\n            // targets can lock us into an expanded mode\n            boolean notExpanded = mDirectShareCurrHeight == mDirectShareMinHeight;\n            if (notExpanded) {\n                if (mHideDirectShareExpansion) {\n                    return;\n                }\n\n                // only expand if we have more than maxTargetsPerRow, and delay that decision\n                // until they start to scroll\n                ChooserListAdapter adapter = mListAdapterSupplier.get();\n                int validTargets = adapter.getSelectableServiceTargetCount();\n                if (validTargets <= maxTargetsPerRow) {\n                    mHideDirectShareExpansion = true;\n                    return;\n                }\n            }\n\n            int yDiff = (int) ((oldy - y) * DIRECT_SHARE_EXPANSION_RATE);\n\n            int prevHeight = mDirectShareCurrHeight;\n            int newHeight = Math.min(prevHeight + yDiff, mDirectShareMaxHeight);\n            newHeight = Math.max(newHeight, mDirectShareMinHeight);\n            yDiff = newHeight - prevHeight;\n\n            updateDirectShareRowHeight(view, yDiff, newHeight);\n        }\n\n        void expand(RecyclerView view) {\n            updateDirectShareRowHeight(view, mDirectShareMaxHeight - mDirectShareCurrHeight,\n                    mDirectShareMaxHeight);\n        }\n\n        void collapse(RecyclerView view) {\n            updateDirectShareRowHeight(view, mDirectShareMinHeight - mDirectShareCurrHeight,\n                    mDirectShareMinHeight);\n        }\n\n        private void updateDirectShareRowHeight(RecyclerView view, int yDiff, int newHeight) {\n            if (view == null || view.getChildCount() == 0 || yDiff == 0) {\n                return;\n            }\n\n            // locate the item to expand, and offset the rows below that one\n            boolean foundExpansion = false;\n            for (int i = 0; i < view.getChildCount(); i++) {\n                View child = view.getChildAt(i);\n\n                if (foundExpansion) {\n                    child.offsetTopAndBottom(yDiff);\n                } else {\n                    if (child.getTag() != null && child.getTag() instanceof DirectShareViewHolder) {\n                        int widthSpec = MeasureSpec.makeMeasureSpec(child.getWidth(),\n                                MeasureSpec.EXACTLY);\n                        int heightSpec = MeasureSpec.makeMeasureSpec(newHeight,\n                                MeasureSpec.EXACTLY);\n                        child.measure(widthSpec, heightSpec);\n                        child.getLayoutParams().height = child.getMeasuredHeight();\n                        child.layout(child.getLeft(), child.getTop(), child.getRight(),\n                                child.getTop() + child.getMeasuredHeight());\n\n                        foundExpansion = true;\n                    }\n                }\n            }\n\n            if (foundExpansion) {\n                mDirectShareCurrHeight = newHeight;\n            }\n        }\n    }\n\n    static class ServiceResultInfo {\n        public final DisplayResolveInfo originalTarget;\n        public final List<ChooserTarget> resultTargets;\n        public final UserHandle userHandle;\n\n        public ServiceResultInfo(DisplayResolveInfo ot, List<ChooserTarget> rt,\n                UserHandle userHandle) {\n            originalTarget = ot;\n            resultTargets = rt;\n            this.userHandle = userHandle;\n        }\n    }\n\n    static class ChooserTargetRankingInfo {\n        public final List<AppTarget> scores;\n        public final UserHandle userHandle;\n\n        ChooserTargetRankingInfo(List<AppTarget> chooserTargetScores,\n                UserHandle userHandle) {\n            this.scores = chooserTargetScores;\n            this.userHandle = userHandle;\n        }\n    }\n\n    static class RefinementResultReceiver extends ResultReceiver {\n        private ChooserActivity mChooserActivity;\n        private TargetInfo mSelectedTarget;\n\n        public RefinementResultReceiver(ChooserActivity host, TargetInfo target,\n                Handler handler) {\n            super(handler);\n            mChooserActivity = host;\n            mSelectedTarget = target;\n        }\n\n        @Override\n        protected void onReceiveResult(int resultCode, Bundle resultData) {\n            if (mChooserActivity == null) {\n                Log.e(TAG, \"Destroyed RefinementResultReceiver received a result\");\n                return;\n            }\n            if (resultData == null) {\n                Log.e(TAG, \"RefinementResultReceiver received null resultData\");\n                return;\n            }\n\n            switch (resultCode) {\n                case RESULT_CANCELED:\n                    mChooserActivity.onRefinementCanceled();\n                    break;\n                case RESULT_OK:\n                    Parcelable intentParcelable = resultData.getParcelable(Intent.EXTRA_INTENT);\n                    if (intentParcelable instanceof Intent) {\n                        mChooserActivity.onRefinementResult(mSelectedTarget,\n                                (Intent) intentParcelable);\n                    } else {\n                        Log.e(TAG, \"RefinementResultReceiver received RESULT_OK but no Intent\"\n                                + \" in resultData with key Intent.EXTRA_INTENT\");\n                    }\n                    break;\n                default:\n                    Log.w(TAG, \"Unknown result code \" + resultCode\n                            + \" sent to RefinementResultReceiver\");\n                    break;\n            }\n        }\n\n        public void destroy() {\n            mChooserActivity = null;\n            mSelectedTarget = null;\n        }\n    }\n\n    /**\n     * Used internally to round image corners while obeying view padding.\n     */\n    public static class RoundedRectImageView extends ImageView {\n        private int mRadius = 0;\n        private Path mPath = new Path();\n        private Paint mOverlayPaint = new Paint(0);\n        private Paint mRoundRectPaint = new Paint(0);\n        private Paint mTextPaint = new Paint(Paint.ANTI_ALIAS_FLAG);\n        private String mExtraImageCount = null;\n\n        public RoundedRectImageView(Context context) {\n            super(context);\n        }\n\n        public RoundedRectImageView(Context context, AttributeSet attrs) {\n            this(context, attrs, 0);\n        }\n\n        public RoundedRectImageView(Context context, AttributeSet attrs, int defStyleAttr) {\n            this(context, attrs, defStyleAttr, 0);\n        }\n\n        public RoundedRectImageView(Context context, AttributeSet attrs, int defStyleAttr,\n                int defStyleRes) {\n            super(context, attrs, defStyleAttr, defStyleRes);\n            mRadius = context.getResources().getDimensionPixelSize(R.dimen.chooser_corner_radius);\n\n            mOverlayPaint.setColor(0x99000000);\n            mOverlayPaint.setStyle(Paint.Style.FILL);\n\n            mRoundRectPaint.setColor(context.getResources().getColor(R.color.chooser_row_divider));\n            mRoundRectPaint.setStyle(Paint.Style.STROKE);\n            mRoundRectPaint.setStrokeWidth(context.getResources()\n                    .getDimensionPixelSize(R.dimen.chooser_preview_image_border));\n\n            mTextPaint.setColor(Color.WHITE);\n            mTextPaint.setTextSize(context.getResources()\n                    .getDimensionPixelSize(R.dimen.chooser_preview_image_font_size));\n            mTextPaint.setTextAlign(Paint.Align.CENTER);\n        }\n\n        private void updatePath(int width, int height) {\n            mPath.reset();\n\n            int imageWidth = width - getPaddingRight() - getPaddingLeft();\n            int imageHeight = height - getPaddingBottom() - getPaddingTop();\n            mPath.addRoundRect(getPaddingLeft(), getPaddingTop(), imageWidth, imageHeight, mRadius,\n                    mRadius, Path.Direction.CW);\n        }\n\n        /**\n          * Sets the corner radius on all corners\n          *\n          * param radius 0 for no radius, &gt; 0 for a visible corner radius\n          */\n        public void setRadius(int radius) {\n            mRadius = radius;\n            updatePath(getWidth(), getHeight());\n        }\n\n        /**\n          * Display an overlay with extra image count on 3rd image\n          */\n        public void setExtraImageCount(int count) {\n            if (count > 0) {\n                this.mExtraImageCount = \"+\" + count;\n            } else {\n                this.mExtraImageCount = null;\n            }\n        }\n\n        @Override\n        protected void onSizeChanged(int width, int height, int oldWidth, int oldHeight) {\n            super.onSizeChanged(width, height, oldWidth, oldHeight);\n            updatePath(width, height);\n        }\n\n        @Override\n        protected void onDraw(Canvas canvas) {\n            if (mRadius != 0) {\n                canvas.clipPath(mPath);\n            }\n\n            super.onDraw(canvas);\n\n            int x = getPaddingLeft();\n            int y = getPaddingRight();\n            int width = getWidth() - getPaddingRight() - getPaddingLeft();\n            int height = getHeight() - getPaddingBottom() - getPaddingTop();\n            if (mExtraImageCount != null) {\n                canvas.drawRect(x, y, width, height, mOverlayPaint);\n\n                int xPos = canvas.getWidth() / 2;\n                int yPos = (int) ((canvas.getHeight() / 2.0f)\n                        - ((mTextPaint.descent() + mTextPaint.ascent()) / 2.0f));\n\n                canvas.drawText(mExtraImageCount, xPos, yPos, mTextPaint);\n            }\n\n            canvas.drawRoundRect(x, y, width, height, mRadius, mRadius, mRoundRectPaint);\n        }\n    }\n\n    /**\n     * A helper class to track app's readiness for the scene transition animation.\n     * The app is ready when both the image is laid out and the drawer offset is calculated.\n     */\n    private class EnterTransitionAnimationDelegate implements View.OnLayoutChangeListener {\n        private boolean mPreviewReady = false;\n        private boolean mOffsetCalculated = false;\n\n        void postponeTransition() {\n            postponeEnterTransition();\n        }\n\n        void markImagePreviewReady() {\n            if (!mPreviewReady) {\n                mPreviewReady = true;\n                maybeStartListenForLayout();\n            }\n        }\n\n        void markOffsetCalculated() {\n            if (!mOffsetCalculated) {\n                mOffsetCalculated = true;\n                maybeStartListenForLayout();\n            }\n        }\n\n        private void maybeStartListenForLayout() {\n            if (mPreviewReady && mOffsetCalculated && mResolverDrawerLayout != null) {\n                if (mResolverDrawerLayout.isInLayout()) {\n                    startPostponedEnterTransition();\n                } else {\n                    mResolverDrawerLayout.addOnLayoutChangeListener(this);\n                    mResolverDrawerLayout.requestLayout();\n                }\n            }\n        }\n\n        @Override\n        public void onLayoutChange(View v, int left, int top, int right, int bottom, int oldLeft,\n                int oldTop, int oldRight, int oldBottom) {\n            v.removeOnLayoutChangeListener(this);\n            startPostponedEnterTransition();\n        }\n    }\n\n    @Override\n    protected void maybeLogProfileChange() {\n        getChooserActivityLogger().logShareheetProfileChanged();\n    }\n\n    private boolean shouldNearbyShareBeFirstInRankedRow() {\n        return ActivityManager.isLowRamDeviceStatic() && mIsNearbyShareFirstTargetInRankedApp;\n    }\n\n    private boolean shouldNearbyShareBeIncludedAsActionButton() {\n        return !shouldNearbyShareBeFirstInRankedRow();\n    }\n\n    private boolean hasValidIcon(ChooserTarget target) {\n        Icon icon = target.getIcon();\n        if (icon == null) {\n            return true;\n        }\n        if (icon.getType() == Icon.TYPE_URI || icon.getType() == Icon.TYPE_URI_ADAPTIVE_BITMAP) {\n            Uri uri = icon.getUri();\n            try {\n                getUriGrantsManager().checkGrantUriPermission_ignoreNonSystem(\n                        getLaunchedFromUid(),\n                        getPackageName(),\n                        getUriWithoutUserId(uri),\n                        Intent.FLAG_GRANT_READ_URI_PERMISSION,\n                        getUserIdFromUri(uri)\n                );\n            } catch (SecurityException | RemoteException e) {\n                Log.e(TAG, \"Failed to get URI permission for: \" + uri, e);\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private IUriGrantsManager getUriGrantsManager() {\n        return UriGrantsManager.getService();\n    }\n\n    private static ChooserTarget removeIcon(ChooserTarget target) {\n        if (target == null) {\n            return null;\n        }\n        return new ChooserTarget(\n                target.getTitle(),\n                null,\n                target.getScore(),\n                target.getComponentName(),\n                target.getIntentExtras());\n    }\n}\n```"
                    }
                ]
            }
        ],
        "upstream_patch_content": "From bad47a2280c7107e1213f4adc5a3825a62698d00 Mon Sep 17 00:00:00 2001\nFrom: Andrey Yepin <ayepin@google.com>\nDate: Mon, 9 Dec 2024 21:34:17 -0800\nSubject: [PATCH] Verify that the caller has permissions for the icons it\n provided.\n\nBug: 277207798\nTest: manual testing: first reroduce the issue as described in the\n ticket then check that it is not reproduceable after the fix.\nChange-Id: I08992550507572a4878c501184360a58adef53ad\n---\n .../android/internal/app/ChooserActivity.java | 50 ++++++++++++++++++-\n 1 file changed, 49 insertions(+), 1 deletion(-)\n\ndiff --git a/core/java/com/android/internal/app/ChooserActivity.java b/core/java/com/android/internal/app/ChooserActivity.java\nindex f9d553ffc0c1..ebd015f1c429 100644\n--- a/core/java/com/android/internal/app/ChooserActivity.java\n+++ b/core/java/com/android/internal/app/ChooserActivity.java\n@@ -21,6 +21,7 @@ import static android.app.admin.DevicePolicyResources.Strings.Core.RESOLVER_CANT\n import static android.app.admin.DevicePolicyResources.Strings.Core.RESOLVER_CANT_SHARE_WITH_PERSONAL;\n import static android.app.admin.DevicePolicyResources.Strings.Core.RESOLVER_CANT_SHARE_WITH_WORK;\n import static android.app.admin.DevicePolicyResources.Strings.Core.RESOLVER_CROSS_PROFILE_BLOCKED_TITLE;\n+import static android.content.ContentProvider.getUriWithoutUserId;\n import static android.content.ContentProvider.getUserIdFromUri;\n import static android.stats.devicepolicy.DevicePolicyEnums.RESOLVER_EMPTY_STATE_NO_SHARING_TO_PERSONAL;\n import static android.stats.devicepolicy.DevicePolicyEnums.RESOLVER_EMPTY_STATE_NO_SHARING_TO_WORK;\n@@ -40,7 +41,9 @@ import android.annotation.Nullable;\n import android.app.Activity;\n import android.app.ActivityManager;\n import android.app.ActivityOptions;\n+import android.app.IUriGrantsManager;\n import android.app.SharedElementCallback;\n+import android.app.UriGrantsManager;\n import android.app.prediction.AppPredictionContext;\n import android.app.prediction.AppPredictionManager;\n import android.app.prediction.AppPredictor;\n@@ -77,6 +80,7 @@ import android.graphics.Paint;\n import android.graphics.Path;\n import android.graphics.drawable.AnimatedVectorDrawable;\n import android.graphics.drawable.Drawable;\n+import android.graphics.drawable.Icon;\n import android.metrics.LogMaker;\n import android.net.Uri;\n import android.os.AsyncTask;\n@@ -86,6 +90,7 @@ import android.os.Handler;\n import android.os.Message;\n import android.os.Parcelable;\n import android.os.PatternMatcher;\n+import android.os.RemoteException;\n import android.os.ResultReceiver;\n import android.os.UserHandle;\n import android.os.UserManager;\n@@ -692,7 +697,11 @@ public class ChooserActivity extends ResolverActivity implements\n                     targets = null;\n                     break;\n                 }\n-                targets[i] = (ChooserTarget) pa[i];\n+                ChooserTarget chooserTarget = (ChooserTarget) pa[i];\n+                if (!hasValidIcon(chooserTarget)) {\n+                    chooserTarget = removeIcon(chooserTarget);\n+                }\n+                targets[i] = chooserTarget;\n             }\n             mCallerChooserTargets = targets;\n         }\n@@ -4313,4 +4322,43 @@ public class ChooserActivity extends ResolverActivity implements\n     private boolean shouldNearbyShareBeIncludedAsActionButton() {\n         return !shouldNearbyShareBeFirstInRankedRow();\n     }\n+\n+    private boolean hasValidIcon(ChooserTarget target) {\n+        Icon icon = target.getIcon();\n+        if (icon == null) {\n+            return true;\n+        }\n+        if (icon.getType() == Icon.TYPE_URI || icon.getType() == Icon.TYPE_URI_ADAPTIVE_BITMAP) {\n+            Uri uri = icon.getUri();\n+            try {\n+                getUriGrantsManager().checkGrantUriPermission_ignoreNonSystem(\n+                        getLaunchedFromUid(),\n+                        getPackageName(),\n+                        getUriWithoutUserId(uri),\n+                        Intent.FLAG_GRANT_READ_URI_PERMISSION,\n+                        getUserIdFromUri(uri)\n+                );\n+            } catch (SecurityException | RemoteException e) {\n+                Log.e(TAG, \"Failed to get URI permission for: \" + uri, e);\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private IUriGrantsManager getUriGrantsManager() {\n+        return UriGrantsManager.getService();\n+    }\n+\n+    private static ChooserTarget removeIcon(ChooserTarget target) {\n+        if (target == null) {\n+            return null;\n+        }\n+        return new ChooserTarget(\n+                target.getTitle(),\n+                null,\n+                target.getScore(),\n+                target.getComponentName(),\n+                target.getIntentExtras());\n+    }\n }\n-- \n2.39.5 (Apple Git-154)\n\n",
        "upstream_commits": [
            "bad47a2280c7107e1213f4adc5a3825a62698d00"
        ]
    },
    {
        "id": "ASB-A-283101289",
        "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-283101289",
        "severity": "High",
        "failures": [
            {
                "downstream_version": "12",
                "branch_used": "android12-release",
                "downstream_patch": "73fa082a7202100da107ae14dd7742ecd86da053",
                "repo_path": "android_repos/base",
                "result": "failure",
                "downstream_patch_content": "commit 73fa082a7202100da107ae14dd7742ecd86da053\nAuthor: Tim Yu <yunicorn@google.com>\nDate:   Tue Jun 20 21:24:36 2023 +0000\n\n    [DO NOT MERGE] Verify URI Permissions in Autofill RemoteViews\n    \n    Check permissions of URI inside of FillResponse's RemoteViews. If the\n    current user does not have the required permissions to view the URI, the\n    RemoteView is dropped from displaying.\n    \n    This fixes a security spill in which a user can view content of another\n    user through a malicious Autofill provider.\n    \n    Bug: 283137865\n    Fixes: b/283264674 b/281666022 b/281665050 b/281848557 b/281533566\n    b/281534749 b/283101289\n    Test: Verified by POC app attached in bugs\n    Test: atest CtsAutoFillServiceTestCases (added new tests)\n    Change-Id: I6f4d2a35e89bbed7bd9e07bf5cd3e2d68b20af9a\n\ndiff --git a/services/autofill/java/com/android/server/autofill/Helper.java b/services/autofill/java/com/android/server/autofill/Helper.java\nindex bc5d6457c945..48113a81cca5 100644\n--- a/services/autofill/java/com/android/server/autofill/Helper.java\n+++ b/services/autofill/java/com/android/server/autofill/Helper.java\n@@ -18,6 +18,8 @@ package com.android.server.autofill;\n \n import android.annotation.NonNull;\n import android.annotation.Nullable;\n+import android.annotation.UserIdInt;\n+import android.app.ActivityManager;\n import android.app.assist.AssistStructure;\n import android.app.assist.AssistStructure.ViewNode;\n import android.app.assist.AssistStructure.WindowNode;\n@@ -34,6 +36,7 @@ import android.view.View;\n import android.view.WindowManager;\n import android.view.autofill.AutofillId;\n import android.view.autofill.AutofillValue;\n+import android.widget.RemoteViews;\n \n import com.android.internal.logging.nano.MetricsProto.MetricsEvent;\n import com.android.internal.util.ArrayUtils;\n@@ -42,6 +45,8 @@ import java.io.PrintWriter;\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n \n public final class Helper {\n \n@@ -75,6 +80,44 @@ public final class Helper {\n         throw new UnsupportedOperationException(\"contains static members only\");\n     }\n \n+    private static boolean checkRemoteViewUriPermissions(\n+            @UserIdInt int userId, @NonNull RemoteViews rView) {\n+        final AtomicBoolean permissionsOk = new AtomicBoolean(true);\n+\n+        rView.visitUris(uri -> {\n+            int uriOwnerId = android.content.ContentProvider.getUserIdFromUri(uri);\n+            boolean allowed = uriOwnerId == userId;\n+            permissionsOk.set(allowed && permissionsOk.get());\n+        });\n+\n+        return permissionsOk.get();\n+    }\n+\n+    /**\n+     * Checks the URI permissions of the remote view,\n+     * to see if the current userId is able to access it.\n+     *\n+     * Returns the RemoteView that is passed if user is able, null otherwise.\n+     *\n+     * TODO: instead of returning a null remoteview when\n+     * the current userId cannot access an URI,\n+     * return a new RemoteView with the URI removed.\n+     */\n+    public static @Nullable RemoteViews sanitizeRemoteView(RemoteViews rView) {\n+        if (rView == null) return null;\n+\n+        int userId = ActivityManager.getCurrentUser();\n+\n+        boolean ok = checkRemoteViewUriPermissions(userId, rView);\n+        if (!ok) {\n+            Slog.w(TAG,\n+                    \"sanitizeRemoteView() user: \" + userId\n+                    + \" tried accessing resource that does not belong to them\");\n+        }\n+        return (ok ? rView : null);\n+    }\n+\n+\n     @Nullable\n     static AutofillId[] toArray(@Nullable ArraySet<AutofillId> set) {\n         if (set == null) return null;\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/FillUi.java b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\nindex 27ea3d618afa..af6e38b1d46c 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n@@ -141,8 +141,9 @@ final class FillUi {\n \n         final LayoutInflater inflater = LayoutInflater.from(mContext);\n \n-        final RemoteViews headerPresentation = response.getHeader();\n-        final RemoteViews footerPresentation = response.getFooter();\n+        final RemoteViews headerPresentation = Helper.sanitizeRemoteView(response.getHeader());\n+        final RemoteViews footerPresentation = Helper.sanitizeRemoteView(response.getFooter());\n+\n         final ViewGroup decor;\n         if (mFullScreen) {\n             decor = (ViewGroup) inflater.inflate(R.layout.autofill_dataset_picker_fullscreen, null);\n@@ -220,6 +221,9 @@ final class FillUi {\n             ViewGroup container = decor.findViewById(R.id.autofill_dataset_picker);\n             final View content;\n             try {\n+                if (Helper.sanitizeRemoteView(response.getPresentation()) == null) {\n+                    throw new RuntimeException(\"Permission error accessing RemoteView\");\n+                }\n                 content = response.getPresentation().applyWithTheme(\n                         mContext, decor, interceptionHandler, mThemeId);\n                 container.addView(content);\n@@ -299,7 +303,8 @@ final class FillUi {\n                 final Dataset dataset = response.getDatasets().get(i);\n                 final int index = dataset.getFieldIds().indexOf(focusedViewId);\n                 if (index >= 0) {\n-                    final RemoteViews presentation = dataset.getFieldPresentation(index);\n+                    final RemoteViews presentation = Helper.sanitizeRemoteView(\n+                            dataset.getFieldPresentation(index));\n                     if (presentation == null) {\n                         Slog.w(TAG, \"not displaying UI on field \" + focusedViewId + \" because \"\n                                 + \"service didn't provide a presentation for it on \" + dataset);\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\nindex 826a98afe2f8..49df4a8b66ed 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n@@ -368,8 +368,7 @@ final class SaveUi {\n             return false;\n         }\n         writeLog(MetricsEvent.AUTOFILL_SAVE_CUSTOM_DESCRIPTION);\n-\n-        final RemoteViews template = customDescription.getPresentation();\n+        final RemoteViews template = Helper.sanitizeRemoteView(customDescription.getPresentation());\n         if (template == null) {\n             Slog.w(TAG, \"No remote view on custom description\");\n             return false;\n",
                "file_conflicts": []
            },
            {
                "downstream_version": "12L",
                "branch_used": "android12L-release",
                "downstream_patch": "f7ca136c514dc975c3f46d95c53fd6b3752c577a",
                "repo_path": "android_repos/base",
                "result": "failure",
                "downstream_patch_content": "commit f7ca136c514dc975c3f46d95c53fd6b3752c577a\nAuthor: Tim Yu <yunicorn@google.com>\nDate:   Tue Jun 20 21:24:36 2023 +0000\n\n    [DO NOT MERGE] Verify URI Permissions in Autofill RemoteViews\n    \n    Check permissions of URI inside of FillResponse's RemoteViews. If the\n    current user does not have the required permissions to view the URI, the\n    RemoteView is dropped from displaying.\n    \n    This fixes a security spill in which a user can view content of another\n    user through a malicious Autofill provider.\n    \n    Bug: 283137865\n    Fixes: b/283264674 b/281666022 b/281665050 b/281848557 b/281533566\n    b/281534749 b/283101289\n    Test: Verified by POC app attached in bugs\n    Test: atest CtsAutoFillServiceTestCases (added new tests)\n    Change-Id: I6f4d2a35e89bbed7bd9e07bf5cd3e2d68b20af9a\n\ndiff --git a/services/autofill/java/com/android/server/autofill/Helper.java b/services/autofill/java/com/android/server/autofill/Helper.java\nindex bc5d6457c945..48113a81cca5 100644\n--- a/services/autofill/java/com/android/server/autofill/Helper.java\n+++ b/services/autofill/java/com/android/server/autofill/Helper.java\n@@ -18,6 +18,8 @@ package com.android.server.autofill;\n \n import android.annotation.NonNull;\n import android.annotation.Nullable;\n+import android.annotation.UserIdInt;\n+import android.app.ActivityManager;\n import android.app.assist.AssistStructure;\n import android.app.assist.AssistStructure.ViewNode;\n import android.app.assist.AssistStructure.WindowNode;\n@@ -34,6 +36,7 @@ import android.view.View;\n import android.view.WindowManager;\n import android.view.autofill.AutofillId;\n import android.view.autofill.AutofillValue;\n+import android.widget.RemoteViews;\n \n import com.android.internal.logging.nano.MetricsProto.MetricsEvent;\n import com.android.internal.util.ArrayUtils;\n@@ -42,6 +45,8 @@ import java.io.PrintWriter;\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n \n public final class Helper {\n \n@@ -75,6 +80,44 @@ public final class Helper {\n         throw new UnsupportedOperationException(\"contains static members only\");\n     }\n \n+    private static boolean checkRemoteViewUriPermissions(\n+            @UserIdInt int userId, @NonNull RemoteViews rView) {\n+        final AtomicBoolean permissionsOk = new AtomicBoolean(true);\n+\n+        rView.visitUris(uri -> {\n+            int uriOwnerId = android.content.ContentProvider.getUserIdFromUri(uri);\n+            boolean allowed = uriOwnerId == userId;\n+            permissionsOk.set(allowed && permissionsOk.get());\n+        });\n+\n+        return permissionsOk.get();\n+    }\n+\n+    /**\n+     * Checks the URI permissions of the remote view,\n+     * to see if the current userId is able to access it.\n+     *\n+     * Returns the RemoteView that is passed if user is able, null otherwise.\n+     *\n+     * TODO: instead of returning a null remoteview when\n+     * the current userId cannot access an URI,\n+     * return a new RemoteView with the URI removed.\n+     */\n+    public static @Nullable RemoteViews sanitizeRemoteView(RemoteViews rView) {\n+        if (rView == null) return null;\n+\n+        int userId = ActivityManager.getCurrentUser();\n+\n+        boolean ok = checkRemoteViewUriPermissions(userId, rView);\n+        if (!ok) {\n+            Slog.w(TAG,\n+                    \"sanitizeRemoteView() user: \" + userId\n+                    + \" tried accessing resource that does not belong to them\");\n+        }\n+        return (ok ? rView : null);\n+    }\n+\n+\n     @Nullable\n     static AutofillId[] toArray(@Nullable ArraySet<AutofillId> set) {\n         if (set == null) return null;\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/FillUi.java b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\nindex 27ea3d618afa..af6e38b1d46c 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n@@ -141,8 +141,9 @@ final class FillUi {\n \n         final LayoutInflater inflater = LayoutInflater.from(mContext);\n \n-        final RemoteViews headerPresentation = response.getHeader();\n-        final RemoteViews footerPresentation = response.getFooter();\n+        final RemoteViews headerPresentation = Helper.sanitizeRemoteView(response.getHeader());\n+        final RemoteViews footerPresentation = Helper.sanitizeRemoteView(response.getFooter());\n+\n         final ViewGroup decor;\n         if (mFullScreen) {\n             decor = (ViewGroup) inflater.inflate(R.layout.autofill_dataset_picker_fullscreen, null);\n@@ -220,6 +221,9 @@ final class FillUi {\n             ViewGroup container = decor.findViewById(R.id.autofill_dataset_picker);\n             final View content;\n             try {\n+                if (Helper.sanitizeRemoteView(response.getPresentation()) == null) {\n+                    throw new RuntimeException(\"Permission error accessing RemoteView\");\n+                }\n                 content = response.getPresentation().applyWithTheme(\n                         mContext, decor, interceptionHandler, mThemeId);\n                 container.addView(content);\n@@ -299,7 +303,8 @@ final class FillUi {\n                 final Dataset dataset = response.getDatasets().get(i);\n                 final int index = dataset.getFieldIds().indexOf(focusedViewId);\n                 if (index >= 0) {\n-                    final RemoteViews presentation = dataset.getFieldPresentation(index);\n+                    final RemoteViews presentation = Helper.sanitizeRemoteView(\n+                            dataset.getFieldPresentation(index));\n                     if (presentation == null) {\n                         Slog.w(TAG, \"not displaying UI on field \" + focusedViewId + \" because \"\n                                 + \"service didn't provide a presentation for it on \" + dataset);\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\nindex 826a98afe2f8..49df4a8b66ed 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n@@ -368,8 +368,7 @@ final class SaveUi {\n             return false;\n         }\n         writeLog(MetricsEvent.AUTOFILL_SAVE_CUSTOM_DESCRIPTION);\n-\n-        final RemoteViews template = customDescription.getPresentation();\n+        final RemoteViews template = Helper.sanitizeRemoteView(customDescription.getPresentation());\n         if (template == null) {\n             Slog.w(TAG, \"No remote view on custom description\");\n             return false;\n",
                "file_conflicts": []
            }
        ],
        "upstream_patch_content": "From bf7fbbccd920596e514d1559fb3feaca70e55e78 Mon Sep 17 00:00:00 2001\nFrom: Tim Yu <yunicorn@google.com>\nDate: Tue, 20 Jun 2023 21:24:36 +0000\nSubject: [PATCH] [DO NOT MERGE] Verify URI Permissions in Autofill RemoteViews\n\nCheck permissions of URI inside of FillResponse's RemoteViews. If the\ncurrent user does not have the required permissions to view the URI, the\nRemoteView is dropped from displaying.\n\nThis fixes a security spill in which a user can view content of another\nuser through a malicious Autofill provider.\n\nBug: 283137865\nFixes: b/283264674 b/281666022 b/281665050 b/281848557 b/281533566\nb/281534749 b/283101289\nTest: Verified by POC app attached in bugs\nTest: atest CtsAutoFillServiceTestCases (added new tests)\nChange-Id: I6f4d2a35e89bbed7bd9e07bf5cd3e2d68b20af9a\n---\n .../com/android/server/autofill/Helper.java   | 43 +++++++++++++++++++\n .../server/autofill/ui/DialogFillUi.java      | 12 ++++--\n .../android/server/autofill/ui/FillUi.java    | 11 +++--\n .../android/server/autofill/ui/SaveUi.java    |  3 +-\n 4 files changed, 60 insertions(+), 9 deletions(-)\n\ndiff --git a/services/autofill/java/com/android/server/autofill/Helper.java b/services/autofill/java/com/android/server/autofill/Helper.java\nindex 82af38200166..ad8f5e1481e1 100644\n--- a/services/autofill/java/com/android/server/autofill/Helper.java\n+++ b/services/autofill/java/com/android/server/autofill/Helper.java\n@@ -20,6 +20,8 @@ import static com.android.server.autofill.Helper.sDebug;\n \n import android.annotation.NonNull;\n import android.annotation.Nullable;\n+import android.annotation.UserIdInt;\n+import android.app.ActivityManager;\n import android.app.assist.AssistStructure;\n import android.app.assist.AssistStructure.ViewNode;\n import android.app.assist.AssistStructure.WindowNode;\n@@ -40,6 +42,7 @@ import android.view.View;\n import android.view.WindowManager;\n import android.view.autofill.AutofillId;\n import android.view.autofill.AutofillValue;\n+import android.widget.RemoteViews;\n \n import com.android.internal.logging.nano.MetricsProto.MetricsEvent;\n import com.android.internal.util.ArrayUtils;\n@@ -50,6 +53,8 @@ import java.lang.ref.WeakReference;\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n \n public final class Helper {\n \n@@ -83,6 +88,44 @@ public final class Helper {\n         throw new UnsupportedOperationException(\"contains static members only\");\n     }\n \n+    private static boolean checkRemoteViewUriPermissions(\n+            @UserIdInt int userId, @NonNull RemoteViews rView) {\n+        final AtomicBoolean permissionsOk = new AtomicBoolean(true);\n+\n+        rView.visitUris(uri -> {\n+            int uriOwnerId = android.content.ContentProvider.getUserIdFromUri(uri);\n+            boolean allowed = uriOwnerId == userId;\n+            permissionsOk.set(allowed & permissionsOk.get());\n+        });\n+\n+        return permissionsOk.get();\n+    }\n+\n+    /**\n+     * Checks the URI permissions of the remote view,\n+     * to see if the current userId is able to access it.\n+     *\n+     * Returns the RemoteView that is passed if user is able, null otherwise.\n+     *\n+     * TODO: instead of returning a null remoteview when\n+     * the current userId cannot access an URI,\n+     * return a new RemoteView with the URI removed.\n+     */\n+    public static @Nullable RemoteViews sanitizeRemoteView(RemoteViews rView) {\n+        if (rView == null) return null;\n+\n+        int userId = ActivityManager.getCurrentUser();\n+\n+        boolean ok = checkRemoteViewUriPermissions(userId, rView);\n+        if (!ok) {\n+            Slog.w(TAG,\n+                    \"sanitizeRemoteView() user: \" + userId\n+                    + \" tried accessing resource that does not belong to them\");\n+        }\n+        return (ok ? rView : null);\n+    }\n+\n+\n     @Nullable\n     static AutofillId[] toArray(@Nullable ArraySet<AutofillId> set) {\n         if (set == null) return null;\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java b/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java\nindex dbeb624bd202..fa414e3b172b 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java\n@@ -53,6 +53,7 @@ import android.widget.TextView;\n \n import com.android.internal.R;\n import com.android.server.autofill.AutofillManagerService;\n+import com.android.server.autofill.Helper;\n \n import java.io.PrintWriter;\n import java.util.ArrayList;\n@@ -208,7 +209,8 @@ final class DialogFillUi {\n     }\n \n     private void setHeader(View decor, FillResponse response) {\n-        final RemoteViews presentation = response.getDialogHeader();\n+        final RemoteViews presentation =\n+                Helper.sanitizeRemoteView(response.getDialogHeader());\n         if (presentation == null) {\n             return;\n         }\n@@ -243,9 +245,10 @@ final class DialogFillUi {\n     }\n \n     private void initialAuthenticationLayout(View decor, FillResponse response) {\n-        RemoteViews presentation = response.getDialogPresentation();\n+        RemoteViews presentation = Helper.sanitizeRemoteView(\n+                response.getDialogPresentation());\n         if (presentation == null) {\n-            presentation = response.getPresentation();\n+            presentation = Helper.sanitizeRemoteView(response.getPresentation());\n         }\n         if (presentation == null) {\n             throw new RuntimeException(\"No presentation for fill dialog authentication\");\n@@ -289,7 +292,8 @@ final class DialogFillUi {\n             final Dataset dataset = response.getDatasets().get(i);\n             final int index = dataset.getFieldIds().indexOf(focusedViewId);\n             if (index >= 0) {\n-                RemoteViews presentation = dataset.getFieldDialogPresentation(index);\n+                RemoteViews presentation = Helper.sanitizeRemoteView(\n+                        dataset.getFieldDialogPresentation(index));\n                 if (presentation == null) {\n                     if (sDebug) {\n                         Slog.w(TAG, \"not displaying UI on field \" + focusedViewId + \" because \"\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/FillUi.java b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\nindex 129ce72e037d..cdfe7bb4f4a7 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n@@ -148,8 +148,9 @@ final class FillUi {\n \n         final LayoutInflater inflater = LayoutInflater.from(mContext);\n \n-        final RemoteViews headerPresentation = response.getHeader();\n-        final RemoteViews footerPresentation = response.getFooter();\n+        final RemoteViews headerPresentation = Helper.sanitizeRemoteView(response.getHeader());\n+        final RemoteViews footerPresentation = Helper.sanitizeRemoteView(response.getFooter());\n+\n         final ViewGroup decor;\n         if (mFullScreen) {\n             decor = (ViewGroup) inflater.inflate(R.layout.autofill_dataset_picker_fullscreen, null);\n@@ -227,6 +228,9 @@ final class FillUi {\n             ViewGroup container = decor.findViewById(R.id.autofill_dataset_picker);\n             final View content;\n             try {\n+                if (Helper.sanitizeRemoteView(response.getPresentation()) == null) {\n+                    throw new RuntimeException(\"Permission error accessing RemoteView\");\n+                }\n                 content = response.getPresentation().applyWithTheme(\n                         mContext, decor, interceptionHandler, mThemeId);\n                 container.addView(content);\n@@ -306,7 +310,8 @@ final class FillUi {\n                 final Dataset dataset = response.getDatasets().get(i);\n                 final int index = dataset.getFieldIds().indexOf(focusedViewId);\n                 if (index >= 0) {\n-                    final RemoteViews presentation = dataset.getFieldPresentation(index);\n+                    final RemoteViews presentation = Helper.sanitizeRemoteView(\n+                            dataset.getFieldPresentation(index));\n                     if (presentation == null) {\n                         Slog.w(TAG, \"not displaying UI on field \" + focusedViewId + \" because \"\n                                 + \"service didn't provide a presentation for it on \" + dataset);\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\nindex f035d0764279..70382f1d5274 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n@@ -384,8 +384,7 @@ final class SaveUi {\n             return false;\n         }\n         writeLog(MetricsEvent.AUTOFILL_SAVE_CUSTOM_DESCRIPTION);\n-\n-        final RemoteViews template = customDescription.getPresentation();\n+        final RemoteViews template = Helper.sanitizeRemoteView(customDescription.getPresentation());\n         if (template == null) {\n             Slog.w(TAG, \"No remote view on custom description\");\n             return false;\n-- \n2.39.5 (Apple Git-154)\n\n",
        "upstream_commits": [
            "bf7fbbccd920596e514d1559fb3feaca70e55e78"
        ]
    },
    {
        "id": "ASB-A-352542820",
        "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-352542820",
        "severity": "High",
        "failures": [
            {
                "downstream_version": "12",
                "branch_used": "android12-release",
                "downstream_patch": "44a35ac07bcc076871b8054331096aaff8ee10f0",
                "repo_path": "android_repos/Settings",
                "result": "failure",
                "downstream_patch_content": "commit 44a35ac07bcc076871b8054331096aaff8ee10f0\nAuthor: Adam Bookatz <bookatz@google.com>\nDate:   Mon Nov 18 15:53:41 2024 -0800\n\n    Don't let profiles open the UserSettings overflow [DO NOT MERGE]\n    \n    Really, profiles aren't expected to open Settings at all. But if they\n    do somehow, the overflow shouldn't appear.\n    \n    Bug: 352542820\n    Flag: EXEMPT bugfix\n    Test: Try to access the overflow of the work profile by launching its Settings in\n    adb shell am start --user 10 'com.android.settings/.Settings\\$UserSettingsActivity'\n    \n    Change-Id: I5e4c095cda3e19fa5c63c2c550a526f5da8ec5c1\n    Merged-In: I5e4c095cda3e19fa5c63c2c550a526f5da8ec5c1\n    (cherry picked from commit 69c7f5dac580361792bbb189178653b297d06c8a)\n\ndiff --git a/src/com/android/settings/users/UserSettings.java b/src/com/android/settings/users/UserSettings.java\nindex ee23fc379d8..56bdfba3069 100644\n--- a/src/com/android/settings/users/UserSettings.java\n+++ b/src/com/android/settings/users/UserSettings.java\n@@ -358,8 +358,8 @@ public class UserSettings extends SettingsPreferenceFragment\n         int pos = 0;\n         // TODO(b/191509236): The menu item does not need to be accessible for guest users,\n         //  regardless of mGuestUserAutoCreated\n-        if (!mUserCaps.mIsAdmin && canSwitchUserNow() && !(isCurrentUserGuest()\n-                && mGuestUserAutoCreated)) {\n+        if (!mUserCaps.mIsAdmin && canSwitchUserNow() && !mUserManager.isProfile()\n+                && !(isCurrentUserGuest() && mGuestUserAutoCreated)) {\n             String nickname = mUserManager.getUserName();\n             MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                     getResources().getString(R.string.user_remove_user_menu, nickname));\n",
                "file_conflicts": [
                    {
                        "file_name": "src/com/android/settings/users/UserSettings.java",
                        "total_hunks": 1,
                        "failed_hunks": [
                            1
                        ],
                        "inline_merge_conflicts": [],
                        "rej_file_content": "```diff\n--- src/com/android/settings/users/UserSettings.java\n+++ src/com/android/settings/users/UserSettings.java\n@@ -465,7 +465,7 @@ public class UserSettings extends SettingsPreferenceFragment\n     public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n         int pos = 0;\n         if (!isCurrentUserAdmin() && (canSwitchUserNow() || Flags.newMultiuserSettingsUx())\n-                && !isCurrentUserGuest()) {\n+                && !isCurrentUserGuest() && !mUserManager.isProfile()) {\n             String nickname = mUserManager.getUserName();\n             MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                     getResources().getString(R.string.user_remove_user_menu, nickname));\n```",
                        "patch_apply_output": "patching file src/com/android/settings/users/UserSettings.java\nHunk #1 FAILED at 465.\n1 out of 1 hunk FAILED -- saving rejects to file src/com/android/settings/users/UserSettings.java.rej",
                        "inline_merge_output": "patching file src/com/android/settings/users/UserSettings.java\nHunk #1 already applied at 468.",
                        "upstream_file_content": "```java\n/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.settings.users;\n\nimport static com.android.settingslib.Utils.getColorAttrDefaultColor;\n\nimport android.app.Activity;\nimport android.app.ActivityManager;\nimport android.app.Dialog;\nimport android.app.admin.DevicePolicyManager;\nimport android.app.settings.SettingsEnums;\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.pm.UserInfo;\nimport android.content.res.Resources;\nimport android.graphics.Bitmap;\nimport android.graphics.BitmapFactory;\nimport android.graphics.BlendMode;\nimport android.graphics.drawable.Drawable;\nimport android.graphics.drawable.LayerDrawable;\nimport android.multiuser.Flags;\nimport android.net.Uri;\nimport android.os.AsyncTask;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.Message;\nimport android.os.Process;\nimport android.os.RemoteException;\nimport android.os.Trace;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.provider.ContactsContract;\nimport android.provider.Settings;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.util.SparseArray;\nimport android.view.Gravity;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.WindowManagerGlobal;\nimport android.widget.SimpleAdapter;\nimport android.widget.Toast;\n\nimport androidx.annotation.VisibleForTesting;\nimport androidx.annotation.WorkerThread;\nimport androidx.appcompat.app.AlertDialog;\nimport androidx.preference.Preference;\nimport androidx.preference.PreferenceGroup;\nimport androidx.preference.PreferenceScreen;\n\nimport com.android.internal.util.UserIcons;\nimport com.android.internal.widget.LockPatternUtils;\nimport com.android.settings.R;\nimport com.android.settings.SettingsActivity;\nimport com.android.settings.SettingsPreferenceFragment;\nimport com.android.settings.Utils;\nimport com.android.settings.core.SubSettingLauncher;\nimport com.android.settings.password.ChooseLockGeneric;\nimport com.android.settings.search.BaseSearchIndexProvider;\nimport com.android.settings.widget.MainSwitchBarController;\nimport com.android.settings.widget.SettingsMainSwitchBar;\nimport com.android.settingslib.RestrictedLockUtils.EnforcedAdmin;\nimport com.android.settingslib.RestrictedLockUtilsInternal;\nimport com.android.settingslib.RestrictedPreference;\nimport com.android.settingslib.drawable.CircleFramedDrawable;\nimport com.android.settingslib.search.SearchIndexable;\nimport com.android.settingslib.search.SearchIndexableRaw;\nimport com.android.settingslib.users.CreateUserDialogController;\nimport com.android.settingslib.users.EditUserInfoController;\nimport com.android.settingslib.users.GrantAdminDialogController;\nimport com.android.settingslib.users.UserCreatingDialog;\nimport com.android.settingslib.utils.ThreadUtils;\n\nimport com.google.android.setupcompat.util.WizardManagerHelper;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.stream.Collectors;\n\n/**\n * Screen that manages the list of users on the device.\n * Secondary users and a guest user can be created if there is no restriction.\n *\n * The first user in the list is always the current user.\n * Owner is the primary user.\n */\n@SearchIndexable\npublic class UserSettings extends SettingsPreferenceFragment\n        implements Preference.OnPreferenceClickListener,\n        MultiUserSwitchBarController.OnMultiUserSwitchChangedListener,\n        DialogInterface.OnDismissListener {\n\n    private static final String TAG = \"UserSettings\";\n\n    /** UserId of the user being removed */\n    private static final String SAVE_REMOVING_USER = \"removing_user\";\n    private static final String SAVE_CREATE_USER = \"create_user\";\n\n    private static final String KEY_USER_LIST = \"user_list\";\n    private static final String KEY_USER_ME = \"user_me\";\n    private static final String KEY_USER_GUEST = \"user_guest\";\n    private static final String KEY_ADD_GUEST = \"guest_add\";\n    private static final String KEY_ADD_USER = \"user_add\";\n    private static final String KEY_ADD_SUPERVISED_USER = \"supervised_user_add\";\n    private static final String KEY_ADD_USER_WHEN_LOCKED = \"user_settings_add_users_when_locked\";\n    private static final String KEY_ENABLE_GUEST_TELEPHONY = \"enable_guest_calling\";\n    private static final String KEY_MULTIUSER_TOP_INTRO = \"multiuser_top_intro\";\n    private static final String KEY_TIMEOUT_TO_DOCK_USER = \"timeout_to_dock_user_preference\";\n    private static final String KEY_GUEST_CATEGORY = \"guest_category\";\n    private static final String KEY_GUEST_RESET = \"guest_reset\";\n    private static final String KEY_GUEST_EXIT = \"guest_exit\";\n    private static final String KEY_REMOVE_GUEST_ON_EXIT = \"remove_guest_on_exit\";\n    private static final String KEY_GUEST_USER_CATEGORY = \"guest_user_category\";\n    private static final String KEY_ALLOW_MULTIPLE_USERS = \"allow_multiple_users\";\n    private static final String KEY_USER_SETTINGS_SCREEN = \"user_settings_screen\";\n\n    private static final String SETTING_GUEST_HAS_LOGGED_IN = \"systemui.guest_has_logged_in\";\n\n    private static final int MENU_REMOVE_USER = Menu.FIRST;\n\n    private static final IntentFilter USER_REMOVED_INTENT_FILTER;\n\n    private static final int DIALOG_CONFIRM_REMOVE = 1;\n    private static final int DIALOG_ADD_USER = 2;\n    // Dialogs with id 3 and 4 got removed\n    private static final int DIALOG_USER_CANNOT_MANAGE = 5;\n    private static final int DIALOG_CHOOSE_USER_TYPE = 6;\n    private static final int DIALOG_NEED_LOCKSCREEN = 7;\n    private static final int DIALOG_CONFIRM_REMOVE_GUEST = 8;\n    private static final int DIALOG_USER_PROFILE_EDITOR = 9;\n    private static final int DIALOG_USER_PROFILE_EDITOR_ADD_USER = 10;\n    private static final int DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE = 11;\n    private static final int DIALOG_CONFIRM_REMOVE_GUEST_WITH_AUTO_CREATE = 12;\n    private static final int DIALOG_CONFIRM_RESET_AND_RESTART_GUEST = 13;\n    private static final int DIALOG_CONFIRM_EXIT_GUEST_EPHEMERAL = 14;\n    private static final int DIALOG_CONFIRM_EXIT_GUEST_NON_EPHEMERAL = 15;\n    private static final int DIALOG_GRANT_ADMIN = 16;\n\n    private static final int MESSAGE_UPDATE_LIST = 1;\n    private static final int MESSAGE_USER_CREATED = 2;\n    static final int MESSAGE_REMOVE_GUEST_ON_EXIT_CONTROLLER_GUEST_REMOVED = 3;\n\n    private static final int USER_TYPE_USER = 1;\n    private static final int USER_TYPE_RESTRICTED_PROFILE = 2;\n\n    private static final int REQUEST_CHOOSE_LOCK = 10;\n    private static final int REQUEST_EDIT_GUEST = 11;\n\n    static final int RESULT_GUEST_REMOVED = 100;\n\n    private static final String KEY_TITLE = \"title\";\n    private static final String KEY_SUMMARY = \"summary\";\n\n    private static final String EXTRA_OPEN_DIALOG_USER_PROFILE_EDITOR =\n            \"EXTRA_OPEN_DIALOG_USER_PROFILE_EDITOR\";\n\n    static {\n        USER_REMOVED_INTENT_FILTER = new IntentFilter(Intent.ACTION_USER_REMOVED);\n        USER_REMOVED_INTENT_FILTER.addAction(Intent.ACTION_USER_INFO_CHANGED);\n    }\n\n    @VisibleForTesting\n    PreferenceGroup mUserListCategory;\n    @VisibleForTesting\n    PreferenceGroup mGuestUserCategory;\n    @VisibleForTesting\n    PreferenceGroup mGuestCategory;\n    @VisibleForTesting\n    Preference mGuestResetPreference;\n    @VisibleForTesting\n    Preference mGuestExitPreference;\n    @VisibleForTesting\n    UserPreference mMePreference;\n    @VisibleForTesting\n    RestrictedPreference mAddGuest;\n    @VisibleForTesting\n    RestrictedPreference mAddUser;\n    @VisibleForTesting\n    RestrictedPreference mAddSupervisedUser;\n    @VisibleForTesting\n    SparseArray<Bitmap> mUserIcons = new SparseArray<>();\n    private int mRemovingUserId = -1;\n    private boolean mAddingUser;\n    private boolean mGuestUserAutoCreated;\n    private String mConfigSupervisedUserCreationPackage;\n    private String mAddingUserName;\n    private UserCapabilities mUserCaps;\n    private boolean mShouldUpdateUserList = true;\n    private final Object mUserLock = new Object();\n    private UserManager mUserManager;\n    private static SparseArray<Bitmap> sDarkDefaultUserBitmapCache = new SparseArray<>();\n\n    private MultiUserSwitchBarController mSwitchBarController;\n\n    private GrantAdminDialogController mGrantAdminDialogController =\n            new GrantAdminDialogController();\n    private EditUserInfoController mEditUserInfoController =\n            new EditUserInfoController(Utils.FILE_PROVIDER_AUTHORITY);\n    private CreateUserDialogController mCreateUserDialogController =\n            new CreateUserDialogController(Utils.FILE_PROVIDER_AUTHORITY);\n    private AddUserWhenLockedPreferenceController mAddUserWhenLockedPreferenceController;\n    private GuestTelephonyPreferenceController mGuestTelephonyPreferenceController;\n    private RemoveGuestOnExitPreferenceController mRemoveGuestOnExitPreferenceController;\n    private MultiUserTopIntroPreferenceController mMultiUserTopIntroPreferenceController;\n    private TimeoutToDockUserPreferenceController mTimeoutToDockUserPreferenceController;\n    private UserCreatingDialog mUserCreatingDialog;\n    private final AtomicBoolean mGuestCreationScheduled = new AtomicBoolean();\n    private final ExecutorService mExecutor = Executors.newSingleThreadExecutor();\n\n    private CharSequence mPendingUserName;\n    private Drawable mPendingUserIcon;\n    private boolean mPendingUserIsAdmin;\n\n    // A place to cache the generated default avatar\n    private Drawable mDefaultIconDrawable;\n\n    // TODO:   Replace current Handler solution to something that doesn't leak memory and works\n    // TODO:   during a configuration change\n    private Handler mHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MESSAGE_UPDATE_LIST:\n                    updateUserList();\n                    break;\n                case MESSAGE_REMOVE_GUEST_ON_EXIT_CONTROLLER_GUEST_REMOVED:\n                    updateUserList();\n                    if (mGuestUserAutoCreated) {\n                        scheduleGuestCreation();\n                    }\n                    break;\n            }\n        }\n    };\n\n    private BroadcastReceiver mUserChangeReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            if (intent.getAction().equals(Intent.ACTION_USER_REMOVED)) {\n                mRemovingUserId = -1;\n            } else if (intent.getAction().equals(Intent.ACTION_USER_INFO_CHANGED)) {\n                int userHandle = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, -1);\n                if (userHandle != -1) {\n                    mUserIcons.remove(userHandle);\n                }\n            }\n            mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n        }\n    };\n\n    @Override\n    public int getMetricsCategory() {\n        return SettingsEnums.USER;\n    }\n\n    @Override\n    public void onActivityCreated(Bundle savedInstanceState) {\n        super.onActivityCreated(savedInstanceState);\n        // Assume we are in a SettingsActivity. This is only safe because we currently use\n        // SettingsActivity as base for all preference fragments.\n        final SettingsActivity activity = (SettingsActivity) getActivity();\n        final SettingsMainSwitchBar switchBar = activity.getSwitchBar();\n        switchBar.setTitle(getContext().getString(R.string.multiple_users_main_switch_title));\n        if (!mUserCaps.mIsGuest) {\n            switchBar.show();\n        } else {\n            switchBar.hide();\n        }\n        mSwitchBarController = new MultiUserSwitchBarController(activity,\n                new MainSwitchBarController(switchBar), this /* listener */);\n        getSettingsLifecycle().addObserver(mSwitchBarController);\n        boolean openUserEditDialog = getIntent().getBooleanExtra(\n                EXTRA_OPEN_DIALOG_USER_PROFILE_EDITOR, false);\n        if (switchBar.isChecked() && openUserEditDialog) {\n            showDialog(DIALOG_USER_PROFILE_EDITOR);\n        }\n    }\n\n    @Override\n    public void onCreate(Bundle icicle) {\n        super.onCreate(icicle);\n        addPreferencesFromResource(R.xml.user_settings);\n        final Activity activity = getActivity();\n        if (!WizardManagerHelper.isDeviceProvisioned(activity)) {\n            activity.finish();\n            return;\n        }\n\n        mGuestUserAutoCreated = getPrefContext().getResources().getBoolean(\n                com.android.internal.R.bool.config_guestUserAutoCreated);\n\n        mAddUserWhenLockedPreferenceController = new AddUserWhenLockedPreferenceController(\n                activity, KEY_ADD_USER_WHEN_LOCKED);\n\n        mGuestTelephonyPreferenceController = new GuestTelephonyPreferenceController(\n                activity, KEY_ENABLE_GUEST_TELEPHONY);\n\n        mRemoveGuestOnExitPreferenceController = new RemoveGuestOnExitPreferenceController(\n                activity, KEY_REMOVE_GUEST_ON_EXIT, this, mHandler);\n\n        mMultiUserTopIntroPreferenceController = new MultiUserTopIntroPreferenceController(activity,\n                KEY_MULTIUSER_TOP_INTRO);\n\n        mTimeoutToDockUserPreferenceController = new TimeoutToDockUserPreferenceController(\n                activity, KEY_TIMEOUT_TO_DOCK_USER);\n\n        final PreferenceScreen screen = getPreferenceScreen();\n        mAddUserWhenLockedPreferenceController.displayPreference(screen);\n        mGuestTelephonyPreferenceController.displayPreference(screen);\n        mRemoveGuestOnExitPreferenceController.displayPreference(screen);\n        mMultiUserTopIntroPreferenceController.displayPreference(screen);\n        mTimeoutToDockUserPreferenceController.displayPreference(screen);\n\n        screen.findPreference(mAddUserWhenLockedPreferenceController.getPreferenceKey())\n                .setOnPreferenceChangeListener(mAddUserWhenLockedPreferenceController);\n\n        screen.findPreference(mGuestTelephonyPreferenceController.getPreferenceKey())\n                .setOnPreferenceChangeListener(mGuestTelephonyPreferenceController);\n\n        screen.findPreference(mRemoveGuestOnExitPreferenceController.getPreferenceKey())\n                .setOnPreferenceChangeListener(mRemoveGuestOnExitPreferenceController);\n\n        if (icicle != null) {\n            if (icicle.containsKey(SAVE_REMOVING_USER)) {\n                mRemovingUserId = icicle.getInt(SAVE_REMOVING_USER);\n            }\n            if (icicle.containsKey(SAVE_CREATE_USER)) {\n                mCreateUserDialogController.onRestoreInstanceState(icicle);\n            } else {\n                mEditUserInfoController.onRestoreInstanceState(icicle);\n            }\n        }\n\n        mUserCaps = UserCapabilities.create(activity);\n        mUserManager = (UserManager) activity.getSystemService(Context.USER_SERVICE);\n        if (!mUserCaps.mEnabled) {\n            return;\n        }\n\n        final int myUserId = UserHandle.myUserId();\n\n        mUserListCategory = (PreferenceGroup) findPreference(KEY_USER_LIST);\n        mMePreference = new UserPreference(getPrefContext(), null /* attrs */, myUserId);\n        mMePreference.setKey(KEY_USER_ME);\n        mMePreference.setOnPreferenceClickListener(this);\n\n        mGuestCategory = findPreference(KEY_GUEST_CATEGORY);\n\n        mGuestResetPreference = findPreference(KEY_GUEST_RESET);\n        mGuestResetPreference.setOnPreferenceClickListener(this);\n\n        mGuestExitPreference = findPreference(KEY_GUEST_EXIT);\n        mGuestExitPreference.setOnPreferenceClickListener(this);\n\n        mGuestUserCategory = findPreference(KEY_GUEST_USER_CATEGORY);\n\n        mAddGuest = findPreference(KEY_ADD_GUEST);\n        mAddGuest.setOnPreferenceClickListener(this);\n\n        mAddUser = findPreference(KEY_ADD_USER);\n        if (!mUserCaps.mCanAddRestrictedProfile) {\n            // Label should only mention adding a \"user\", not a \"profile\"\n            mAddUser.setTitle(com.android.settingslib.R.string.user_add_user);\n        }\n        mAddUser.setOnPreferenceClickListener(this);\n\n        setConfigSupervisedUserCreationPackage();\n        mAddSupervisedUser = findPreference(KEY_ADD_SUPERVISED_USER);\n        mAddSupervisedUser.setOnPreferenceClickListener(this);\n\n        activity.registerReceiverAsUser(\n                mUserChangeReceiver, UserHandle.ALL, USER_REMOVED_INTENT_FILTER, null, mHandler,\n                Context.RECEIVER_EXPORTED_UNAUDITED);\n\n        updateUI();\n        mShouldUpdateUserList = false;\n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n\n        if (!mUserCaps.mEnabled) {\n            return;\n        }\n        final PreferenceScreen screen = getPreferenceScreen();\n\n        mAddUserWhenLockedPreferenceController.updateState(screen.findPreference(\n                mAddUserWhenLockedPreferenceController.getPreferenceKey()));\n        mGuestTelephonyPreferenceController.updateState(screen.findPreference(\n                mGuestTelephonyPreferenceController.getPreferenceKey()));\n        mTimeoutToDockUserPreferenceController.updateState(screen.findPreference(\n                mTimeoutToDockUserPreferenceController.getPreferenceKey()));\n        mRemoveGuestOnExitPreferenceController.updateState(screen.findPreference(\n                mRemoveGuestOnExitPreferenceController.getPreferenceKey()));\n        mSwitchBarController.updateState();\n        if (mShouldUpdateUserList) {\n            updateUI();\n        }\n    }\n\n    @Override\n    public void onPause() {\n        mShouldUpdateUserList = true;\n        super.onPause();\n    }\n\n    @Override\n    public void onDestroy() {\n        super.onDestroy();\n\n        if (mUserCaps == null || !mUserCaps.mEnabled) {\n            return;\n        }\n\n        getActivity().unregisterReceiver(mUserChangeReceiver);\n    }\n\n    @Override\n    public void onSaveInstanceState(Bundle outState) {\n        if (mCreateUserDialogController.isActive()) {\n            outState.putBoolean(SAVE_CREATE_USER, mCreateUserDialogController.isActive());\n            mCreateUserDialogController.onSaveInstanceState(outState);\n        } else {\n            mEditUserInfoController.onSaveInstanceState(outState);\n        }\n        outState.putInt(SAVE_REMOVING_USER, mRemovingUserId);\n        super.onSaveInstanceState(outState);\n    }\n\n    @Override\n    public void startActivityForResult(Intent intent, int requestCode) {\n        mEditUserInfoController.startingActivityForResult();\n        mCreateUserDialogController.startingActivityForResult();\n        super.startActivityForResult(intent, requestCode);\n    }\n\n    @Override\n    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n        int pos = 0;\n        if (!isCurrentUserAdmin() && (canSwitchUserNow() || Flags.newMultiuserSettingsUx())\n                && !isCurrentUserGuest() && !mUserManager.isProfile()) {\n            String nickname = mUserManager.getUserName();\n            MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                    getResources().getString(R.string.user_remove_user_menu, nickname));\n            removeThisUser.setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);\n\n            final EnforcedAdmin disallowRemoveUserAdmin =\n                    RestrictedLockUtilsInternal.checkIfRestrictionEnforced(getContext(),\n                            UserManager.DISALLOW_REMOVE_USER, UserHandle.myUserId());\n            RestrictedLockUtilsInternal.setMenuItemAsDisabledByAdmin(getContext(), removeThisUser,\n                    disallowRemoveUserAdmin);\n        }\n        super.onCreateOptionsMenu(menu, inflater);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        final int itemId = item.getItemId();\n        if (itemId == MENU_REMOVE_USER) {\n            onRemoveUserClicked(UserHandle.myUserId());\n            return true;\n        } else {\n            return super.onOptionsItemSelected(item);\n        }\n    }\n\n    @Override\n    public void onMultiUserSwitchChanged(boolean newState) {\n        updateUI();\n    }\n\n    private void updateUI() {\n        mUserCaps.updateAddUserCapabilities(getActivity());\n        loadProfile();\n        updateUserList();\n    }\n\n    /**\n     * Loads profile information for the current user.\n     */\n    private void loadProfile() {\n        if (isCurrentUserGuest()) {\n            // No need to load profile information\n            mMePreference.setIcon(getEncircledDefaultIcon());\n            mMePreference.setTitle(mGuestUserAutoCreated\n                    ? com.android.settingslib.R.string.guest_reset_guest\n                    : com.android.settingslib.R.string.guest_exit_guest);\n            mMePreference.setSelectable(true);\n            // removing a guest will result in switching back to the admin user\n            mMePreference.setEnabled(canSwitchUserNow());\n            return;\n        }\n\n        new AsyncTask<Void, Void, String>() {\n            @Override\n            protected void onPostExecute(String result) {\n                finishLoadProfile(result);\n            }\n\n            @Override\n            protected String doInBackground(Void... values) {\n                UserInfo user = mUserManager.getUserInfo(UserHandle.myUserId());\n                if (user.iconPath == null || user.iconPath.equals(\"\")) {\n                    // Assign profile photo.\n                    copyMeProfilePhoto(getActivity(), user);\n                }\n                return user.name;\n            }\n        }.execute();\n    }\n\n    private void finishLoadProfile(String profileName) {\n        if (getActivity() == null) {\n            return;\n        }\n        mMePreference.setTitle(getString(R.string.user_you, profileName));\n        int myUserId = UserHandle.myUserId();\n        Bitmap b = mUserManager.getUserIcon(myUserId);\n        if (b != null) {\n            mMePreference.setIcon(encircleUserIcon(b));\n            mUserIcons.put(myUserId, b);\n        }\n    }\n\n    private boolean hasLockscreenSecurity() {\n        LockPatternUtils lpu = new LockPatternUtils(getActivity());\n        return lpu.isSecure(UserHandle.myUserId());\n    }\n\n    private void launchChooseLockscreen() {\n        Intent chooseLockIntent = new Intent(DevicePolicyManager.ACTION_SET_NEW_PASSWORD)\n                .setPackage(getContext().getPackageName());\n        chooseLockIntent.putExtra(ChooseLockGeneric.ChooseLockGenericFragment.HIDE_INSECURE_OPTIONS,\n                true);\n        startActivityForResult(chooseLockIntent, REQUEST_CHOOSE_LOCK);\n    }\n\n    @Override\n    public void onActivityResult(int requestCode, int resultCode, Intent data) {\n        super.onActivityResult(requestCode, resultCode, data);\n\n        if (requestCode == REQUEST_CHOOSE_LOCK) {\n            if (resultCode != Activity.RESULT_CANCELED && hasLockscreenSecurity()) {\n                addUserNow(USER_TYPE_RESTRICTED_PROFILE);\n            }\n        } else if (mGuestUserAutoCreated && requestCode == REQUEST_EDIT_GUEST\n                && resultCode == RESULT_GUEST_REMOVED) {\n            scheduleGuestCreation();\n        } else {\n            mCreateUserDialogController.onActivityResult(requestCode, resultCode, data);\n            mEditUserInfoController.onActivityResult(requestCode, resultCode, data);\n        }\n    }\n\n    private void onAddUserClicked(int userType) {\n        synchronized (mUserLock) {\n            if (mRemovingUserId == -1 && !mAddingUser) {\n                switch (userType) {\n                    case USER_TYPE_USER:\n                        showDialog(DIALOG_ADD_USER);\n                        break;\n                    case USER_TYPE_RESTRICTED_PROFILE:\n                        if (hasLockscreenSecurity()) {\n                            showDialog(DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE);\n                        } else {\n                            showDialog(DIALOG_NEED_LOCKSCREEN);\n                        }\n                        break;\n                }\n            }\n        }\n    }\n\n    private void onAddSupervisedUserClicked() {\n        final Intent intent = new Intent()\n                .setAction(UserManager.ACTION_CREATE_SUPERVISED_USER)\n                .setPackage(mConfigSupervisedUserCreationPackage)\n                .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n\n        startActivity(intent);\n    }\n\n    private void onAddGuestClicked() {\n        Context context = getContext();\n        final UserCreatingDialog guestCreatingDialog =\n                new UserCreatingDialog(getActivity(), /* isGuest= */ true);\n        guestCreatingDialog.show();\n\n        ThreadUtils.postOnBackgroundThread(() -> {\n            mMetricsFeatureProvider.action(getActivity(), SettingsEnums.ACTION_USER_GUEST_ADD);\n            Trace.beginSection(\"UserSettings.addGuest\");\n            final UserInfo guest = mUserManager.createGuest(context);\n            Trace.endSection();\n\n            ThreadUtils.postOnMainThread(() -> {\n                guestCreatingDialog.dismiss();\n                if (guest == null) {\n                    Toast.makeText(context,\n                            com.android.settingslib.R.string.add_guest_failed,\n                            Toast.LENGTH_SHORT).show();\n                    return;\n                }\n                openUserDetails(guest, true, context);\n            });\n        });\n    }\n\n    private void onRemoveUserClicked(int userId) {\n        synchronized (mUserLock) {\n            if (mRemovingUserId == -1 && !mAddingUser) {\n                mRemovingUserId = userId;\n                showDialog(DIALOG_CONFIRM_REMOVE);\n            }\n        }\n    }\n\n    private void onUserCreated(UserInfo userInfo, Context context) {\n        hideUserCreatingDialog();\n        mAddingUser = false;\n        openUserDetails(userInfo, true, context);\n    }\n\n    private void hideUserCreatingDialog() {\n        if (mUserCreatingDialog != null && mUserCreatingDialog.isShowing()) {\n            mUserCreatingDialog.dismiss();\n        }\n    }\n\n    private void onUserCreationFailed() {\n        Toast.makeText(getContext(),\n                com.android.settingslib.R.string.add_user_failed,\n                Toast.LENGTH_SHORT).show();\n        hideUserCreatingDialog();\n    }\n\n    private void openUserDetails(UserInfo userInfo, boolean newUser) {\n        openUserDetails(userInfo, newUser, getContext());\n    }\n\n    private void openUserDetails(UserInfo userInfo, boolean newUser, Context context) {\n        // to prevent a crash when config changes during user creation,\n        // we simply ignore this redirection step\n        if (context == null) {\n            return;\n        }\n\n        Bundle extras = new Bundle();\n        extras.putInt(UserDetailsSettings.EXTRA_USER_ID, userInfo.id);\n        extras.putBoolean(AppRestrictionsFragment.EXTRA_NEW_USER, newUser);\n\n        SubSettingLauncher launcher = new SubSettingLauncher(context)\n                .setDestination(UserDetailsSettings.class.getName())\n                .setArguments(extras)\n                .setTitleText(userInfo.name)\n                .setSourceMetricsCategory(getMetricsCategory());\n        if (mGuestUserAutoCreated && userInfo.isGuest()) {\n            launcher.setResultListener(this, REQUEST_EDIT_GUEST);\n        }\n        launcher.launch();\n    }\n\n    @Override\n    public void onDialogShowing() {\n        super.onDialogShowing();\n\n        setOnDismissListener(this);\n    }\n\n    @Override\n    public Dialog onCreateDialog(int dialogId) {\n        Context context = getActivity();\n        if (context == null) {\n            return null;\n        }\n        switch (dialogId) {\n            case DIALOG_CONFIRM_REMOVE: {\n                Dialog dlg =\n                        UserDialogs.createRemoveDialog(getActivity(), mRemovingUserId,\n                                new DialogInterface.OnClickListener() {\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        removeUserNow();\n                                    }\n                                }\n                        );\n                return dlg;\n            }\n            case DIALOG_USER_CANNOT_MANAGE:\n                return new AlertDialog.Builder(context)\n                        .setMessage(R.string.user_cannot_manage_message)\n                        .setPositiveButton(android.R.string.ok, null)\n                        .create();\n            case DIALOG_ADD_USER: {\n                synchronized (mUserLock) {\n                    mPendingUserName = getString(\n                            com.android.settingslib.R.string.user_new_user_name);\n                    mPendingUserIcon = null;\n                }\n                return buildAddUserDialog(USER_TYPE_USER);\n            }\n            case DIALOG_CHOOSE_USER_TYPE: {\n                List<HashMap<String, String>> data = new ArrayList<HashMap<String, String>>();\n                HashMap<String, String> addUserItem = new HashMap<String, String>();\n                addUserItem.put(KEY_TITLE, getString(\n                        com.android.settingslib.R.string.user_add_user_item_title));\n                addUserItem.put(KEY_SUMMARY, getString(\n                        com.android.settingslib.R.string.user_add_user_item_summary));\n                HashMap<String, String> addProfileItem = new HashMap<String, String>();\n                addProfileItem.put(KEY_TITLE, getString(\n                        com.android.settingslib.R.string.user_add_profile_item_title));\n                addProfileItem.put(KEY_SUMMARY, getString(\n                        com.android.settingslib.R.string.user_add_profile_item_summary));\n                data.add(addUserItem);\n                data.add(addProfileItem);\n                AlertDialog.Builder builder = new AlertDialog.Builder(context);\n                SimpleAdapter adapter = new SimpleAdapter(builder.getContext(),\n                        data, R.layout.two_line_list_item,\n                        new String[]{KEY_TITLE, KEY_SUMMARY},\n                        new int[]{R.id.title, R.id.summary});\n                builder.setTitle(com.android.settingslib.R.string.user_add_user_type_title);\n                builder.setAdapter(adapter,\n                        new DialogInterface.OnClickListener() {\n                            @Override\n                            public void onClick(DialogInterface dialog, int which) {\n                                onAddUserClicked(which == 0\n                                        ? USER_TYPE_USER\n                                        : USER_TYPE_RESTRICTED_PROFILE);\n                            }\n                        });\n                return builder.create();\n            }\n            case DIALOG_NEED_LOCKSCREEN: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setMessage(com.android.settingslib.R.string.user_need_lock_message)\n                        .setPositiveButton(com.android.settingslib.R.string.user_set_lock_button,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        launchChooseLockscreen();\n                                    }\n                                })\n                        .setNegativeButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            case DIALOG_CONFIRM_REMOVE_GUEST: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setTitle(com.android.settingslib.R.string.guest_remove_guest_dialog_title)\n                        .setMessage(R.string.user_exit_guest_confirm_message)\n                        .setPositiveButton(R.string.user_exit_guest_dialog_remove,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        clearAndExitGuest();\n                                    }\n                                })\n                        .setNegativeButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            case DIALOG_CONFIRM_EXIT_GUEST_EPHEMERAL: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setTitle(com.android.settingslib.R.string.guest_exit_dialog_title)\n                        .setMessage(com.android.settingslib.R.string.guest_exit_dialog_message)\n                        .setPositiveButton(\n                                com.android.settingslib.R.string.guest_exit_dialog_button,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        clearAndExitGuest();\n                                    }\n                                })\n                        .setNeutralButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            case DIALOG_CONFIRM_EXIT_GUEST_NON_EPHEMERAL: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setTitle(\n                            com.android.settingslib.R.string.guest_exit_dialog_title_non_ephemeral)\n                        .setMessage(\n                            com.android.settingslib\n                                .R.string.guest_exit_dialog_message_non_ephemeral)\n                        .setPositiveButton(\n                            com.android.settingslib.R.string.guest_exit_save_data_button,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        exitGuest();\n                                    }\n                                })\n                        .setNegativeButton(\n                            com.android.settingslib.R.string.guest_exit_clear_data_button,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        clearAndExitGuest();\n                                    }\n                                })\n                        .setNeutralButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            case DIALOG_USER_PROFILE_EDITOR: {\n                return buildEditCurrentUserDialog();\n            }\n            case DIALOG_USER_PROFILE_EDITOR_ADD_USER: {\n                synchronized (mUserLock) {\n                    mPendingUserName = getString(\n                            com.android.settingslib.R.string.user_new_user_name);\n                    mPendingUserIcon = null;\n                }\n                return buildAddUserDialog(USER_TYPE_USER);\n            }\n            case DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE: {\n                synchronized (mUserLock) {\n                    mPendingUserName = getString(\n                            com.android.settingslib.R.string.user_new_profile_name);\n                    mPendingUserIcon = null;\n                }\n                return buildAddUserDialog(USER_TYPE_RESTRICTED_PROFILE);\n            }\n            case DIALOG_CONFIRM_REMOVE_GUEST_WITH_AUTO_CREATE: {\n                return UserDialogs.createResetGuestDialog(getActivity(),\n                        (dialog, which) -> clearAndExitGuest());\n            }\n            case DIALOG_CONFIRM_RESET_AND_RESTART_GUEST: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setTitle(\n                            com.android.settingslib.R.string.guest_reset_and_restart_dialog_title)\n                        .setMessage(\n                            com.android.settingslib.R.string.guest_reset_and_restart_dialog_message)\n                        .setPositiveButton(\n                            com.android.settingslib.R.string.guest_reset_guest_confirm_button,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        resetAndRestartGuest();\n                                    }\n                                })\n                        .setNeutralButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            default:\n                return null;\n        }\n    }\n\n    private Dialog buildEditCurrentUserDialog() {\n        final Activity activity = getActivity();\n        if (activity == null) {\n            return null;\n        }\n\n        UserInfo user = mUserManager.getUserInfo(Process.myUserHandle().getIdentifier());\n        Drawable userIcon = Utils.getUserIcon(activity, mUserManager, user);\n\n        return mEditUserInfoController.createDialog(\n                activity,\n                this::startActivityForResult,\n                userIcon,\n                user.name,\n                (newUserName, newUserIcon) -> {\n                    if (newUserIcon != userIcon) {\n                        ThreadUtils.postOnBackgroundThread(() ->\n                                mUserManager.setUserIcon(user.id,\n                                        UserIcons.convertToBitmapAtUserIconSize(\n                                                activity.getResources(), newUserIcon)));\n                        mMePreference.setIcon(newUserIcon);\n                        if (Flags.avatarSync()) {\n                            final String pkg = getString(R.string.config_avatar_picker_package);\n                            final String action = pkg + \".set.confirm\";\n                            activity.sendBroadcast(new Intent(action).setPackage(pkg));\n                        }\n                    }\n\n                    if (!TextUtils.isEmpty(newUserName) && !newUserName.equals(user.name)) {\n                        mMePreference.setTitle(newUserName);\n                        mUserManager.setUserName(user.id, newUserName);\n                    }\n                }, () -> {\n                    if (Flags.avatarSync()) {\n                        final String pkg = getString(R.string.config_avatar_picker_package);\n                        final String action = pkg + \".set.cancel\";\n                        activity.sendBroadcast(new Intent(action).setPackage(pkg));\n                    }\n                });\n    }\n\n    private Dialog buildAddUserDialog(int userType) {\n        Dialog d;\n        synchronized (mUserLock) {\n            d = mCreateUserDialogController.createDialog(\n                    getActivity(),\n                    this::startActivityForResult,\n                    canCreateAdminUser(),\n                    (userName, userIcon, isAdmin) -> {\n                        mPendingUserIcon = userIcon;\n                        mPendingUserName = userName;\n                        mPendingUserIsAdmin = isAdmin;\n                        addUserNow(userType);\n                    },\n                    () -> {\n                        synchronized (mUserLock) {\n                            mPendingUserIcon = null;\n                            mPendingUserName = null;\n                        }\n                    }\n            );\n        }\n        return d;\n    }\n\n    /**\n     * Checks if the creation of a new admin user is allowed.\n     * @return {@code true} if creating a new admin is allowed, {@code false} otherwise.\n     */\n    private boolean canCreateAdminUser() {\n        if (Flags.unicornModeRefactoringForHsumReadOnly()) {\n            return UserManager.isMultipleAdminEnabled()\n                    && !mUserManager.hasUserRestriction(UserManager.DISALLOW_GRANT_ADMIN);\n        } else {\n            return UserManager.isMultipleAdminEnabled();\n        }\n    }\n\n    @Override\n    public int getDialogMetricsCategory(int dialogId) {\n        switch (dialogId) {\n            case DIALOG_CONFIRM_REMOVE:\n                return SettingsEnums.DIALOG_USER_REMOVE;\n            case DIALOG_USER_CANNOT_MANAGE:\n                return SettingsEnums.DIALOG_USER_CANNOT_MANAGE;\n            case DIALOG_GRANT_ADMIN:\n                return SettingsEnums.DIALOG_GRANT_USER_ADMIN;\n            case DIALOG_ADD_USER:\n                return SettingsEnums.DIALOG_USER_ADD;\n            case DIALOG_CHOOSE_USER_TYPE:\n                return SettingsEnums.DIALOG_USER_CHOOSE_TYPE;\n            case DIALOG_NEED_LOCKSCREEN:\n                return SettingsEnums.DIALOG_USER_NEED_LOCKSCREEN;\n            case DIALOG_CONFIRM_REMOVE_GUEST:\n            case DIALOG_CONFIRM_REMOVE_GUEST_WITH_AUTO_CREATE:\n            case DIALOG_CONFIRM_EXIT_GUEST_EPHEMERAL:\n            case DIALOG_CONFIRM_EXIT_GUEST_NON_EPHEMERAL:\n            case DIALOG_CONFIRM_RESET_AND_RESTART_GUEST:\n                return SettingsEnums.DIALOG_USER_CONFIRM_EXIT_GUEST;\n            case DIALOG_USER_PROFILE_EDITOR:\n            case DIALOG_USER_PROFILE_EDITOR_ADD_USER:\n            case DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE:\n                return SettingsEnums.DIALOG_USER_EDIT_PROFILE;\n            default:\n                return 0;\n        }\n    }\n\n    private void removeUserNow() {\n        if (mRemovingUserId == UserHandle.myUserId()) {\n            removeThisUser();\n        } else {\n            ThreadUtils.postOnBackgroundThread(new Runnable() {\n                @Override\n                public void run() {\n                    synchronized (mUserLock) {\n                        mUserManager.removeUser(mRemovingUserId);\n                        mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n                    }\n                }\n            });\n        }\n    }\n\n    private void removeThisUser() {\n        if (!canSwitchUserNow()) {\n            Log.w(TAG, \"Cannot remove current user when switching is disabled\");\n            return;\n        }\n        try {\n            mUserManager.removeUserWhenPossible(\n                    UserHandle.of(UserHandle.myUserId()), /* overrideDevicePolicy= */ false);\n            ActivityManager.getService().switchUser(\n                    mUserManager.getPreviousForegroundUser().getIdentifier());\n        } catch (RemoteException re) {\n            Log.e(TAG, \"Unable to remove self user\");\n        }\n    }\n\n    private void switchToUserId(int userId) {\n        if (!canSwitchUserNow()) {\n            Log.w(TAG, \"Cannot switch current user when switching is disabled\");\n            return;\n        }\n        try {\n            ActivityManager.getService().switchUser(userId);\n        } catch (RemoteException re) {\n            Log.e(TAG, \"Unable to switch user\");\n        }\n    }\n\n    private void addUserNow(final int userType) {\n        Trace.beginAsyncSection(\"UserSettings.addUserNow\", 0);\n        synchronized (mUserLock) {\n            mAddingUser = true;\n            mAddingUserName = userType == USER_TYPE_USER\n                    ? (mPendingUserName != null ? mPendingUserName.toString()\n                    : getString(com.android.settingslib.R.string.user_new_user_name))\n                    : (mPendingUserName != null ? mPendingUserName.toString()\n                            : getString(com.android.settingslib.R.string.user_new_profile_name));\n        }\n\n        mUserCreatingDialog = new UserCreatingDialog(getActivity());\n        mUserCreatingDialog.show();\n        createUser(userType, mAddingUserName);\n    }\n\n    @VisibleForTesting\n    void createUser(final int userType, String userName) {\n        Context context = getContext();\n        Resources resources = getResources();\n        final Drawable selectedUserIcon = mPendingUserIcon;\n        Future<?> unusedCreateUserFuture = ThreadUtils.postOnBackgroundThread(() -> {\n            UserInfo user;\n\n            if (userType == USER_TYPE_USER) {\n                user = mUserManager.createUser(\n                        userName,\n                        mUserManager.USER_TYPE_FULL_SECONDARY,\n                        0);\n                if (mPendingUserIsAdmin) {\n                    mUserManager.setUserAdmin(user.id);\n                }\n            } else {\n                user = mUserManager.createRestrictedProfile(userName);\n            }\n\n            ThreadUtils.postOnMainThread(() -> {\n                if (user == null) {\n                    mAddingUser = false;\n                    mPendingUserIcon = null;\n                    mPendingUserName = null;\n                    onUserCreationFailed();\n                    return;\n                }\n\n                Future<?> unusedSettingIconFuture = ThreadUtils.postOnBackgroundThread(() -> {\n                    Drawable newUserIcon = selectedUserIcon;\n                    if (newUserIcon == null) {\n                        newUserIcon = UserIcons.getDefaultUserIcon(resources, user.id, false);\n                    }\n                    mUserManager.setUserIcon(\n                            user.id, UserIcons.convertToBitmapAtUserIconSize(\n                                    resources, newUserIcon));\n                });\n\n                mPendingUserIcon = null;\n                mPendingUserName = null;\n\n                onUserCreated(user, context);\n            });\n        });\n    }\n\n\n    /**\n     * Erase the current user (guest) and switch to another user.\n     */\n    @VisibleForTesting\n    void clearAndExitGuest() {\n        // Just to be safe\n        if (!isCurrentUserGuest()) {\n            return;\n        }\n        mMetricsFeatureProvider.action(getActivity(),\n                SettingsEnums.ACTION_USER_GUEST_EXIT_CONFIRMED);\n\n        int guestUserId = UserHandle.myUserId();\n        // Using markGuestForDeletion allows us to create a new guest before this one is\n        // fully removed.\n        boolean marked = mUserManager.markGuestForDeletion(guestUserId);\n        if (!marked) {\n            Log.w(TAG, \"Couldn't mark the guest for deletion for user \" + guestUserId);\n            return;\n        }\n\n        removeThisUser();\n        if (mGuestUserAutoCreated) {\n            scheduleGuestCreation();\n        }\n    }\n\n    /**\n     * Switch to another user.\n     */\n    private void exitGuest() {\n        // Just to be safe\n        if (!isCurrentUserGuest()) {\n            return;\n        }\n        mMetricsFeatureProvider.action(getActivity(),\n                SettingsEnums.ACTION_USER_GUEST_EXIT_CONFIRMED);\n        switchToUserId(mUserManager.getPreviousForegroundUser().getIdentifier());\n    }\n\n    private int createGuest() {\n        UserInfo guest;\n        Context context = getPrefContext();\n        try {\n            guest = mUserManager.createGuest(context);\n        } catch (UserManager.UserOperationException e) {\n            Log.e(TAG, \"Couldn't create guest user\", e);\n            return UserHandle.USER_NULL;\n        }\n        if (guest == null) {\n            Log.e(TAG, \"Couldn't create guest, most likely because there already exists one\");\n            return UserHandle.USER_NULL;\n        }\n        return guest.id;\n    }\n\n    /**\n     * Remove current guest and start a new guest session\n     */\n    private void resetAndRestartGuest() {\n        // Just to be safe\n        if (!isCurrentUserGuest()) {\n            return;\n        }\n        int oldGuestUserId = UserHandle.myUserId();\n        // Using markGuestForDeletion allows us to create a new guest before this one is\n        // fully removed.\n        boolean marked = mUserManager.markGuestForDeletion(oldGuestUserId);\n        if (!marked) {\n            Log.w(TAG, \"Couldn't mark the guest for deletion for user \" + oldGuestUserId);\n            return;\n        }\n\n        try {\n            // Create a new guest in the foreground, and then immediately switch to it\n            int newGuestUserId = createGuest();\n            if (newGuestUserId == UserHandle.USER_NULL) {\n                Log.e(TAG, \"Could not create new guest, switching back to previous user\");\n                switchToUserId(mUserManager.getPreviousForegroundUser().getIdentifier());\n                mUserManager.removeUser(oldGuestUserId);\n                WindowManagerGlobal.getWindowManagerService().lockNow(/* options= */ null);\n                return;\n            }\n            switchToUserId(newGuestUserId);\n            mUserManager.removeUser(oldGuestUserId);\n        } catch (RemoteException e) {\n            Log.e(TAG, \"Couldn't remove guest because ActivityManager or WindowManager is dead\");\n            return;\n        }\n    }\n\n    /**\n     * Create a guest user in the background\n     */\n    @VisibleForTesting\n    void scheduleGuestCreation() {\n        // TODO(b/191067027): Move guest recreation to system_server\n        if (mGuestCreationScheduled.compareAndSet(/* expect= */ false, /* update= */ true)) {\n            // Once mGuestCreationScheduled=true, mAddGuest needs to be updated so that it shows\n            // \"Resetting guest...\"\n            mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n            mExecutor.execute(() -> {\n                UserInfo guest = mUserManager.createGuest(getContext());\n                mGuestCreationScheduled.set(false);\n                if (guest == null) {\n                    Log.e(TAG, \"Unable to automatically recreate guest user\");\n                }\n                // The list needs to be updated whether or not guest creation worked. If guest\n                // creation failed, the list needs to update so that \"Add guest\" is displayed.\n                // Otherwise, the UX could be stuck in a state where there is no way to switch to\n                // the guest user (e.g. Guest would not be selectable, and it would be stuck\n                // saying \"Resetting guest...\")\n                mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n            });\n        }\n    }\n\n    @VisibleForTesting\n    void updateUserList() {\n        final Context context = getActivity();\n        if (context == null) {\n            return;\n        }\n\n        List<UserInfo> users;\n        if (Flags.newMultiuserSettingsUx()) {\n            // Only users that can be switched to should show up here.\n            // e.g. Managed profiles appear under Accounts Settings instead\n            users = mUserManager.getAliveUsers().stream()\n                    .filter(UserInfo::supportsSwitchToByUser)\n                    .collect(Collectors.toList());\n        } else {\n            if (mUserCaps.mUserSwitcherEnabled) {\n                // Only users that can be switched to should show up here.\n                // e.g. Managed profiles appear under Accounts Settings instead\n                users = mUserManager.getAliveUsers().stream()\n                        .filter(UserInfo::supportsSwitchToByUser)\n                        .collect(Collectors.toList());\n            } else {\n                // Only current user will be displayed in case of multi-user switch is disabled\n                users = List.of(mUserManager.getUserInfo(context.getUserId()));\n            }\n        }\n\n        final ArrayList<Integer> missingIcons = new ArrayList<>();\n        final ArrayList<UserPreference> userPreferences = new ArrayList<>();\n\n        // mMePreference shows a icon for current user. However when current user is a guest, we\n        // don't show the guest user icon, instead we show two preferences for guest user to\n        // exit and reset itself. Hence we don't add mMePreference, i.e. guest user to the\n        // list of users visible in the UI.\n        if (!isCurrentUserGuest()) {\n            userPreferences.add(mMePreference);\n        }\n\n        boolean canOpenUserDetails =\n                isCurrentUserAdmin() || (canSwitchUserNow() && !mUserCaps.mDisallowSwitchUser);\n        for (UserInfo user : users) {\n            if (user.isGuest()) {\n                // Guest user is added to guest category via updateGuestCategory\n                // and not to user list so skip guest here\n                continue;\n            }\n            UserPreference pref;\n            if (user.id == UserHandle.myUserId()) {\n                pref = mMePreference;\n            } else {\n                pref = new UserPreference(getPrefContext(), null, user.id);\n                pref.setTitle(user.name);\n                userPreferences.add(pref);\n                pref.setOnPreferenceClickListener(this);\n                pref.setEnabled(canOpenUserDetails);\n                pref.setSelectable(true);\n                pref.setKey(\"id=\" + user.id);\n            }\n            if (pref == null) {\n                continue;\n            }\n            if (user.isMain()) {\n                pref.setSummary(R.string.user_owner);\n            } else if (user.isAdmin()) {\n                pref.setSummary(R.string.user_admin);\n            }\n            if (user.id != UserHandle.myUserId() && !user.isGuest() && !user.isInitialized()) {\n                // sometimes after creating a guest the initialized flag isn't immediately set\n                // and we don't want to show \"Not set up\" summary for them\n                if (user.isRestricted()) {\n                    pref.setSummary(R.string.user_summary_restricted_not_set_up);\n                } else {\n                    pref.setSummary(R.string.user_summary_not_set_up);\n                    // Disallow setting up user which results in user switching when the\n                    // restriction is set.\n                    // If newMultiuserSettingsUx flag is enabled, allow opening user details page\n                    // since switch to user will be disabled\n                    pref.setEnabled((!mUserCaps.mDisallowSwitchUser && canSwitchUserNow())\n                            || Flags.newMultiuserSettingsUx());\n                }\n            } else if (user.isRestricted()) {\n                pref.setSummary(R.string.user_summary_restricted_profile);\n            }\n            if (user.iconPath != null) {\n                if (mUserIcons.get(user.id) == null) {\n                    // Icon not loaded yet, print a placeholder\n                    missingIcons.add(user.id);\n                    pref.setIcon(getEncircledDefaultIcon());\n                } else {\n                    setPhotoId(pref, user);\n                }\n            } else {\n                // Icon not available yet, print a placeholder\n                pref.setIcon(getEncircledDefaultIcon());\n            }\n        }\n\n        // Add a temporary entry for the user being created\n        if (mAddingUser) {\n            UserPreference pref = new UserPreference(getPrefContext(), null,\n                    UserPreference.USERID_UNKNOWN);\n            pref.setEnabled(false);\n            pref.setTitle(mAddingUserName);\n            pref.setIcon(getEncircledDefaultIcon());\n            userPreferences.add(pref);\n        }\n\n        // Sort list of users by serialNum\n        Collections.sort(userPreferences, UserPreference.SERIAL_NUMBER_COMPARATOR);\n\n        getActivity().invalidateOptionsMenu();\n\n        // Load the icons\n        if (missingIcons.size() > 0) {\n            loadIconsAsync(missingIcons);\n        }\n\n        // If restricted profiles are supported, mUserListCategory will have a special title\n        if (mUserCaps.mCanAddRestrictedProfile) {\n            mUserListCategory.setTitle(R.string.user_list_title);\n        } else if (isCurrentUserGuest()) {\n            mUserListCategory.setTitle(R.string.other_user_category_title);\n        } else {\n            mUserListCategory.setTitle(R.string.user_category_title);\n        }\n\n        // Remove everything from mUserListCategory and add new users.\n        mUserListCategory.removeAll();\n\n        final Preference addUserOnLockScreen = getPreferenceScreen().findPreference(\n                mAddUserWhenLockedPreferenceController.getPreferenceKey());\n        mAddUserWhenLockedPreferenceController.updateState(addUserOnLockScreen);\n\n        final Preference guestCallPreference = getPreferenceScreen().findPreference(\n                mGuestTelephonyPreferenceController.getPreferenceKey());\n        mGuestTelephonyPreferenceController.updateState(guestCallPreference);\n\n        final Preference multiUserTopIntroPreference = getPreferenceScreen().findPreference(\n                mMultiUserTopIntroPreferenceController.getPreferenceKey());\n        mMultiUserTopIntroPreferenceController.updateState(multiUserTopIntroPreference);\n        updateGuestPreferences();\n        updateGuestCategory(context, users);\n        updateAddUser(context);\n        updateAddSupervisedUser(context);\n\n        for (UserPreference userPreference : userPreferences) {\n            userPreference.setOrder(Preference.DEFAULT_ORDER);\n            mUserListCategory.addPreference(userPreference);\n        }\n\n    }\n\n    @VisibleForTesting\n    void setConfigSupervisedUserCreationPackage() {\n        mConfigSupervisedUserCreationPackage = getPrefContext().getString(\n                com.android.internal.R.string.config_supervisedUserCreationPackage);\n    }\n\n    private boolean isCurrentUserGuest() {\n        return mUserCaps.mIsGuest;\n    }\n\n    private boolean isCurrentUserAdmin() {\n        return mUserCaps.mIsAdmin;\n    }\n\n    private boolean canSwitchUserNow() {\n        return mUserManager.getUserSwitchability() == UserManager.SWITCHABILITY_STATUS_OK;\n    }\n\n    private void updateGuestPreferences() {\n        // reset guest and exit guest preferences are shown only in guest mode.\n        // For all other users these are not visible.\n        mGuestCategory.setVisible(false);\n        mGuestResetPreference.setVisible(false);\n        mGuestExitPreference.setVisible(false);\n        if (!isCurrentUserGuest()) {\n            return;\n        }\n        mGuestCategory.setVisible(true);\n        mGuestExitPreference.setVisible(true);\n        mGuestResetPreference.setVisible(true);\n\n        boolean isGuestFirstLogin = Settings.Secure.getIntForUser(\n                getContext().getContentResolver(),\n                SETTING_GUEST_HAS_LOGGED_IN,\n                0,\n                UserHandle.myUserId()) <= 1;\n        String guestExitSummary;\n        if (mUserCaps.mIsEphemeral) {\n            guestExitSummary = getContext().getString(\n                    com.android.settingslib.R.string.guest_notification_ephemeral);\n        } else if (isGuestFirstLogin) {\n            guestExitSummary = getContext().getString(\n                    com.android.settingslib.R.string.guest_notification_non_ephemeral);\n        } else {\n            guestExitSummary = getContext().getString(\n                    com.android.settingslib.R\n                            .string.guest_notification_non_ephemeral_non_first_login);\n        }\n        mGuestExitPreference.setSummary(guestExitSummary);\n    }\n\n    private void updateGuestCategory(Context context, List<UserInfo> users) {\n        // show guest category title and related guest preferences\n        // - if guest is created, then show guest user preference\n        // - if guest is not created and its allowed to create guest,\n        //   then show \"add guest\" preference\n        // - if allowed, show \"reset guest on exit\" preference\n        // - if there is nothing to show, then make the guest category as not visible\n        // - guest category is not visible for guest user.\n        UserPreference pref = null;\n        boolean isGuestAlreadyCreated = false;\n        boolean canOpenUserDetails =\n                isCurrentUserAdmin() || (canSwitchUserNow() && !mUserCaps.mDisallowSwitchUser);\n\n        mGuestUserCategory.removeAll();\n        mGuestUserCategory.setVisible(false);\n        for (UserInfo user : users) {\n            if (!user.isGuest() || !user.isEnabled()) {\n                // Only look at enabled, guest users\n                continue;\n            }\n            final Context prefContext = getPrefContext();\n            pref = new UserPreference(prefContext, null, user.id);\n            pref.setTitle(user.name);\n            pref.setOnPreferenceClickListener(this);\n            pref.setEnabled(canOpenUserDetails);\n            pref.setSelectable(true);\n            Drawable icon = getContext().getDrawable(\n                    com.android.settingslib.R.drawable.ic_account_circle_outline);\n            icon.setTint(\n                    getColorAttrDefaultColor(getContext(), android.R.attr.colorControlNormal));\n            pref.setIcon(encircleUserIcon(\n                    UserIcons.convertToBitmapAtUserIconSize(\n                            getContext().getResources(), icon)));\n            pref.setKey(KEY_USER_GUEST);\n            pref.setOrder(Preference.DEFAULT_ORDER);\n            if (mUserCaps.mDisallowSwitchUser && !Flags.newMultiuserSettingsUx()) {\n                pref.setDisabledByAdmin(\n                        RestrictedLockUtilsInternal.getDeviceOwner(context));\n            } else {\n                pref.setDisabledByAdmin(null);\n            }\n            if (Flags.newMultiuserSettingsUx()) {\n                mGuestUserCategory.addPreference(pref);\n                // guest user preference is shown hence also make guest category visible\n                mGuestUserCategory.setVisible(true);\n            } else {\n                if (mUserCaps.mUserSwitcherEnabled) {\n                    mGuestUserCategory.addPreference(pref);\n                    // guest user preference is shown hence also make guest category visible\n                    mGuestUserCategory.setVisible(true);\n                }\n            }\n            isGuestAlreadyCreated = true;\n        }\n        boolean isVisible = updateAddGuestPreference(context, isGuestAlreadyCreated);\n        if (isVisible) {\n            // \"add guest\" preference is shown hence also make guest category visible\n            mGuestUserCategory.setVisible(true);\n        }\n        final Preference removeGuestOnExit = getPreferenceScreen().findPreference(\n                mRemoveGuestOnExitPreferenceController.getPreferenceKey());\n        mRemoveGuestOnExitPreferenceController.updateState(removeGuestOnExit);\n        if (mRemoveGuestOnExitPreferenceController.isAvailable()) {\n            // \"reset guest on exit\" preference is shown hence also make guest category visible\n            mGuestUserCategory.setVisible(true);\n        }\n        if (isCurrentUserGuest()) {\n            // guest category is not visible for guest user.\n            mGuestUserCategory.setVisible(false);\n        }\n    }\n\n    private boolean updateAddGuestPreference(Context context, boolean isGuestAlreadyCreated) {\n        boolean isVisible = false;\n        if (!isGuestAlreadyCreated && (mUserCaps.mCanAddGuest\n                || (Flags.newMultiuserSettingsUx() && mUserCaps.mDisallowAddUser))\n                && mUserManager.canAddMoreUsers(UserManager.USER_TYPE_FULL_GUEST)\n                && WizardManagerHelper.isDeviceProvisioned(context)\n                && (mUserCaps.mUserSwitcherEnabled || Flags.newMultiuserSettingsUx())) {\n            Drawable icon = context.getDrawable(\n                    com.android.settingslib.R.drawable.ic_account_circle);\n            mAddGuest.setIcon(centerAndTint(icon));\n            isVisible = true;\n            mAddGuest.setVisible(true);\n            mAddGuest.setSelectable(true);\n            if (mGuestUserAutoCreated && mGuestCreationScheduled.get()) {\n                mAddGuest.setTitle(com.android.internal.R.string.guest_name);\n                mAddGuest.setSummary(com.android.settingslib.R.string.guest_resetting);\n                mAddGuest.setEnabled(false);\n            } else {\n                mAddGuest.setTitle(com.android.settingslib.R.string.guest_new_guest);\n                if (Flags.newMultiuserSettingsUx()\n                        && mUserCaps.mDisallowAddUserSetByAdmin) {\n                    mAddGuest.setDisabledByAdmin(mUserCaps.mEnforcedAdmin);\n                } else if (Flags.newMultiuserSettingsUx() && mUserCaps.mDisallowAddUser) {\n                    final List<UserManager.EnforcingUser> enforcingUsers =\n                            mUserManager.getUserRestrictionSources(UserManager.DISALLOW_ADD_USER,\n                                    UserHandle.of(UserHandle.myUserId()));\n                    if (!enforcingUsers.isEmpty()) {\n                        final UserManager.EnforcingUser enforcingUser = enforcingUsers.get(0);\n                        final int restrictionSource = enforcingUser.getUserRestrictionSource();\n                        if (restrictionSource == UserManager.RESTRICTION_SOURCE_SYSTEM) {\n                            mAddGuest.setEnabled(false);\n                        } else {\n                            mAddGuest.setVisible(false);\n                        }\n                    }\n                } else {\n                    mAddGuest.setEnabled(canSwitchUserNow() || Flags.newMultiuserSettingsUx());\n                }\n            }\n        } else {\n            mAddGuest.setVisible(false);\n        }\n        return isVisible;\n    }\n\n    private void updateAddUser(Context context) {\n        updateAddUserCommon(context, mAddUser, mUserCaps.mCanAddRestrictedProfile);\n        Drawable icon = context.getDrawable(\n                com.android.settingslib.R.drawable.ic_account_circle_filled);\n        mAddUser.setIcon(centerAndTint(icon));\n    }\n\n    private void updateAddSupervisedUser(Context context) {\n        if (!TextUtils.isEmpty(mConfigSupervisedUserCreationPackage)) {\n            updateAddUserCommon(context, mAddSupervisedUser, false);\n            Drawable icon = context.getDrawable(\n                    com.android.settingslib.R.drawable.ic_add_supervised_user);\n            mAddSupervisedUser.setIcon(centerAndTint(icon));\n        } else {\n            mAddSupervisedUser.setVisible(false);\n        }\n    }\n\n    private void updateAddUserCommon(Context context, RestrictedPreference addUser,\n            boolean canAddRestrictedProfile) {\n        if ((mUserCaps.mCanAddUser\n                && !(mUserCaps.mDisallowAddUserSetByAdmin && Flags.newMultiuserSettingsUx()))\n                && WizardManagerHelper.isDeviceProvisioned(context)\n                && (mUserCaps.mUserSwitcherEnabled || Flags.newMultiuserSettingsUx())) {\n            addUser.setVisible(true);\n            addUser.setSelectable(true);\n            final boolean canAddMoreUsers =\n                    mUserManager.canAddMoreUsers(UserManager.USER_TYPE_FULL_SECONDARY)\n                            || (canAddRestrictedProfile\n                            && mUserManager.canAddMoreUsers(UserManager.USER_TYPE_FULL_RESTRICTED));\n            addUser.setEnabled(canAddMoreUsers && !mAddingUser\n                    && (canSwitchUserNow() || Flags.newMultiuserSettingsUx()));\n\n            if (!canAddMoreUsers) {\n                addUser.setSummary(getString(R.string.user_add_max_count));\n            } else {\n                addUser.setSummary(null);\n            }\n            if (addUser.isEnabled()) {\n                addUser.setDisabledByAdmin(\n                        mUserCaps.mDisallowAddUser ? mUserCaps.mEnforcedAdmin : null);\n            }\n        } else if (Flags.newMultiuserSettingsUx() && mUserCaps.mDisallowAddUserSetByAdmin) {\n            addUser.setVisible(true);\n            addUser.setDisabledByAdmin(mUserCaps.mEnforcedAdmin);\n        } else if (Flags.newMultiuserSettingsUx() && mUserCaps.mDisallowAddUser) {\n            final List<UserManager.EnforcingUser> enforcingUsers =\n                    mUserManager.getUserRestrictionSources(UserManager.DISALLOW_ADD_USER,\n                            UserHandle.of(UserHandle.myUserId()));\n            if (!enforcingUsers.isEmpty()) {\n                final UserManager.EnforcingUser enforcingUser = enforcingUsers.get(0);\n                final int restrictionSource = enforcingUser.getUserRestrictionSource();\n                if (restrictionSource == UserManager.RESTRICTION_SOURCE_SYSTEM) {\n                    addUser.setVisible(true);\n                    addUser.setEnabled(false);\n                } else {\n                    addUser.setVisible(false);\n                }\n            }\n        } else {\n            addUser.setVisible(false);\n        }\n    }\n\n    private Drawable centerAndTint(Drawable icon) {\n        icon.setTintBlendMode(BlendMode.SRC_IN);\n        icon.setTint(getColorAttrDefaultColor(getContext(), android.R.attr.textColorPrimary));\n\n        Drawable bg = getContext().getDrawable(com.android.settingslib.R.drawable.user_avatar_bg)\n                .mutate();\n        LayerDrawable ld = new LayerDrawable(new Drawable[] {bg, icon});\n        int size = getContext().getResources().getDimensionPixelSize(\n                R.dimen.multiple_users_avatar_size);\n        int bgSize = getContext().getResources().getDimensionPixelSize(\n                R.dimen.multiple_users_user_icon_size);\n        ld.setLayerSize(1, size, size);\n        ld.setLayerSize(0, bgSize, bgSize);\n        ld.setLayerGravity(1, Gravity.CENTER);\n\n        return ld;\n    }\n\n    /**\n     * @return number of non-guest non-managed users\n     */\n    @VisibleForTesting\n    int getRealUsersCount() {\n        return (int) mUserManager.getUsers()\n                .stream()\n                .filter(user -> !user.isGuest() && !user.isProfile())\n                .count();\n    }\n\n    private void loadIconsAsync(List<Integer> missingIcons) {\n        new AsyncTask<List<Integer>, Void, Void>() {\n            @Override\n            protected void onPostExecute(Void result) {\n                updateUserList();\n            }\n\n            @Override\n            protected Void doInBackground(List<Integer>... values) {\n                for (int userId : values[0]) {\n                    Bitmap bitmap = mUserManager.getUserIcon(userId);\n                    if (bitmap == null) {\n                        bitmap = getDefaultUserIconAsBitmap(getContext().getResources(), userId);\n                    }\n                    mUserIcons.append(userId, bitmap);\n                }\n                return null;\n            }\n        }.execute(missingIcons);\n    }\n\n    private Drawable getEncircledDefaultIcon() {\n        if (mDefaultIconDrawable == null) {\n            mDefaultIconDrawable = encircleUserIcon(\n                    getDefaultUserIconAsBitmap(getContext().getResources(), UserHandle.USER_NULL));\n        }\n        return mDefaultIconDrawable;\n    }\n\n    private void setPhotoId(Preference pref, UserInfo user) {\n        Bitmap bitmap = mUserIcons.get(user.id);\n        if (bitmap != null) {\n            pref.setIcon(encircleUserIcon(bitmap));\n        }\n    }\n\n    @Override\n    public boolean onPreferenceClick(Preference pref) {\n        mMetricsFeatureProvider.logSettingsTileClick(pref.getKey(), getMetricsCategory());\n        if (isCurrentUserGuest()) {\n            if (mGuestResetPreference != null && pref == mGuestResetPreference) {\n                showDialog(DIALOG_CONFIRM_RESET_AND_RESTART_GUEST);\n                return true;\n            }\n            if (mGuestExitPreference != null && pref == mGuestExitPreference) {\n                if (mUserCaps.mIsEphemeral) {\n                    showDialog(DIALOG_CONFIRM_EXIT_GUEST_EPHEMERAL);\n                } else {\n                    showDialog(DIALOG_CONFIRM_EXIT_GUEST_NON_EPHEMERAL);\n                }\n                return true;\n            }\n        }\n        if (pref == mMePreference) {\n            if (!isCurrentUserGuest()) {\n                showDialog(DIALOG_USER_PROFILE_EDITOR);\n                return true;\n            }\n        } else if (pref instanceof UserPreference) {\n            UserInfo userInfo = mUserManager.getUserInfo(((UserPreference) pref).getUserId());\n            openUserDetails(userInfo, false);\n            return true;\n        } else if (pref == mAddUser) {\n            mMetricsFeatureProvider.action(getActivity(), SettingsEnums.ACTION_USER_ADD);\n            // If we allow both types, show a picker, otherwise directly go to\n            // flow for full user.\n            if (mUserCaps.mCanAddRestrictedProfile) {\n                showDialog(DIALOG_CHOOSE_USER_TYPE);\n            } else {\n                onAddUserClicked(USER_TYPE_USER);\n            }\n            return true;\n        } else if (pref == mAddSupervisedUser) {\n            mMetricsFeatureProvider.action(getActivity(), SettingsEnums.ACTION_USER_SUPERVISED_ADD);\n            Trace.beginSection(\"UserSettings.addSupervisedUser\");\n            onAddSupervisedUserClicked();\n            Trace.endSection();\n            return true;\n        } else if (pref == mAddGuest) {\n            mAddGuest.setEnabled(false); // prevent multiple tap issue\n            onAddGuestClicked();\n            return true;\n        }\n        return false;\n    }\n\n    private Drawable encircleUserIcon(Bitmap icon) {\n        return new CircleFramedDrawable(\n                icon,\n                getActivity().getResources().getDimensionPixelSize(\n                        R.dimen.multiple_users_user_icon_size));\n    }\n\n    @Override\n    public void onDismiss(DialogInterface dialog) {\n        synchronized (mUserLock) {\n            mRemovingUserId = -1;\n            updateUserList();\n            if (mCreateUserDialogController.isActive()) {\n                mCreateUserDialogController.finish();\n            }\n        }\n    }\n\n    @Override\n    public int getHelpResource() {\n        return R.string.help_url_users;\n    }\n\n    /**\n     * Returns a default user icon (as a {@link Bitmap}) for the given user.\n     *\n     * Note that for guest users, you should pass in {@code UserHandle.USER_NULL}.\n     *\n     * @param resources resources object to fetch the user icon.\n     * @param userId    the user id or {@code UserHandle.USER_NULL} for a non-user specific icon\n     */\n    private static Bitmap getDefaultUserIconAsBitmap(Resources resources, int userId) {\n        Bitmap bitmap = null;\n        // Try finding the corresponding bitmap in the dark bitmap cache\n        bitmap = sDarkDefaultUserBitmapCache.get(userId);\n        if (bitmap == null) {\n            bitmap = UserIcons.convertToBitmapAtUserIconSize(resources,\n                    UserIcons.getDefaultUserIcon(resources, userId, false));\n            // Save it to cache\n            sDarkDefaultUserBitmapCache.put(userId, bitmap);\n        }\n        return bitmap;\n    }\n\n    /**\n     * Assign the default photo to user with {@paramref userId}\n     *\n     * @param context used to get the {@link UserManager}\n     * @param userId  used to get the icon bitmap\n     * @return true if assign photo successfully, false if failed\n     */\n    @VisibleForTesting\n    static boolean assignDefaultPhoto(Context context, int userId) {\n        if (context == null) {\n            return false;\n        }\n        UserManager um = (UserManager) context.getSystemService(Context.USER_SERVICE);\n        Bitmap bitmap = getDefaultUserIconAsBitmap(context.getResources(), userId);\n        um.setUserIcon(userId, bitmap);\n\n        return true;\n    }\n\n    @WorkerThread\n    static void copyMeProfilePhoto(Context context, UserInfo user) {\n        Uri contactUri = ContactsContract.Profile.CONTENT_URI;\n\n        int userId = user != null ? user.id : UserHandle.myUserId();\n\n        InputStream avatarDataStream = ContactsContract.Contacts.openContactPhotoInputStream(\n                context.getContentResolver(),\n                contactUri, true);\n        // If there's no profile photo, assign a default avatar\n        if (avatarDataStream == null) {\n            assignDefaultPhoto(context, userId);\n            return;\n        }\n\n        UserManager um = (UserManager) context.getSystemService(Context.USER_SERVICE);\n        Bitmap decodedIcon = BitmapFactory.decodeStream(avatarDataStream);\n        CircleFramedDrawable drawable = CircleFramedDrawable.getInstance(context, decodedIcon);\n        Bitmap icon = UserIcons.convertToBitmapAtUserIconSize(context.getResources(), drawable);\n\n        um.setUserIcon(userId, icon);\n        try {\n            avatarDataStream.close();\n        } catch (IOException ioe) {\n        }\n    }\n\n    public static final BaseSearchIndexProvider SEARCH_INDEX_DATA_PROVIDER =\n            new BaseSearchIndexProvider(R.xml.user_settings) {\n\n                @Override\n                protected boolean isPageSearchEnabled(Context context) {\n                    final UserCapabilities userCaps = UserCapabilities.create(context);\n                    return userCaps.mEnabled;\n                }\n\n                @Override\n                public List<SearchIndexableRaw> getRawDataToIndex(Context context,\n                        boolean enabled) {\n                    final List<SearchIndexableRaw> rawData = new ArrayList<>();\n                    if (!UserManager.supportsMultipleUsers()) {\n                        return rawData;\n                    }\n\n                    SearchIndexableRaw multipleUsersData = new SearchIndexableRaw(context);\n                    multipleUsersData.key = KEY_USER_SETTINGS_SCREEN;\n                    multipleUsersData.title =\n                            context.getString(R.string.user_settings_title);\n                    multipleUsersData.keywords =\n                            context.getString(R.string.multiple_users_title_keywords);\n                    multipleUsersData.screenTitle =\n                            context.getString(R.string.user_settings_title);\n                    rawData.add(multipleUsersData);\n\n                    SearchIndexableRaw allowMultipleUsersResult = new SearchIndexableRaw(context);\n\n                    allowMultipleUsersResult.key = KEY_ALLOW_MULTIPLE_USERS;\n                    allowMultipleUsersResult.title =\n                            context.getString(R.string.multiple_users_main_switch_title);\n                    allowMultipleUsersResult.keywords =\n                            context.getString(R.string.multiple_users_main_switch_keywords);\n                    allowMultipleUsersResult.screenTitle =\n                            context.getString(R.string.user_settings_title);\n                    allowMultipleUsersResult.className =\n                            MultiUserSwitchBarController.class.getName();\n\n                    rawData.add(allowMultipleUsersResult);\n\n                    SearchIndexableRaw addUserData = new SearchIndexableRaw(context);\n                    addUserData.key = KEY_ADD_USER;\n\n                    // Dynamically set the title of addUser preference\n                    final UserCapabilities userCaps = UserCapabilities.create(context);\n                    if (!userCaps.mCanAddRestrictedProfile) {\n                        addUserData.title = context.getString(\n                                com.android.settingslib.R.string.user_add_user);\n                    } else {\n                        addUserData.title = context.getString(\n                                R.string.user_add_user_or_profile_menu);\n                    }\n                    addUserData.screenTitle = context.getString(R.string.user_settings_title);\n                    addUserData.iconResId = R.drawable.ic_add_40dp;\n\n                    rawData.add(addUserData);\n\n                    return rawData;\n                }\n\n                @Override\n                public List<String> getNonIndexableKeysFromXml(Context context, int xmlResId,\n                        boolean suppressAllPage) {\n                    final List<String> niks = super.getNonIndexableKeysFromXml(context, xmlResId,\n                            suppressAllPage);\n                    if (TextUtils.isEmpty(context.getString(\n                            com.android.internal.R.string.config_supervisedUserCreationPackage))) {\n                        niks.add(KEY_ADD_SUPERVISED_USER);\n                    }\n                    AddUserWhenLockedPreferenceController controller =\n                            new AddUserWhenLockedPreferenceController(\n                                    context, KEY_ADD_USER_WHEN_LOCKED);\n                    controller.updateNonIndexableKeys(niks);\n                    new AutoSyncDataPreferenceController(context, null /* parent */)\n                            .updateNonIndexableKeys(niks);\n                    new AutoSyncPersonalDataPreferenceController(context, null /* parent */)\n                            .updateNonIndexableKeys(niks);\n                    new AutoSyncWorkDataPreferenceController(context, null /* parent */)\n                            .updateNonIndexableKeys(niks);\n                    if (suppressAllPage) {\n                        niks.add(KEY_ALLOW_MULTIPLE_USERS);\n                    }\n                    return niks;\n                }\n            };\n}\n```",
                        "downstream_file_content": "```java\n/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.settings.users;\n\nimport android.annotation.NonNull;\nimport android.app.Activity;\nimport android.app.ActivityManager;\nimport android.app.Dialog;\nimport android.app.admin.DevicePolicyManager;\nimport android.app.settings.SettingsEnums;\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.SharedPreferences;\nimport android.content.pm.UserInfo;\nimport android.content.res.Resources;\nimport android.graphics.Bitmap;\nimport android.graphics.BitmapFactory;\nimport android.graphics.drawable.Drawable;\nimport android.net.Uri;\nimport android.os.AsyncTask;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.Message;\nimport android.os.Process;\nimport android.os.RemoteException;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.provider.ContactsContract;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.util.SparseArray;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.widget.SimpleAdapter;\nimport android.widget.Toast;\n\nimport androidx.annotation.VisibleForTesting;\nimport androidx.annotation.WorkerThread;\nimport androidx.appcompat.app.AlertDialog;\nimport androidx.preference.Preference;\nimport androidx.preference.PreferenceGroup;\nimport androidx.preference.PreferenceScreen;\n\nimport com.android.internal.util.UserIcons;\nimport com.android.internal.widget.LockPatternUtils;\nimport com.android.settings.R;\nimport com.android.settings.SettingsActivity;\nimport com.android.settings.SettingsPreferenceFragment;\nimport com.android.settings.Utils;\nimport com.android.settings.core.SubSettingLauncher;\nimport com.android.settings.password.ChooseLockGeneric;\nimport com.android.settings.search.BaseSearchIndexProvider;\nimport com.android.settings.widget.MainSwitchBarController;\nimport com.android.settings.widget.SettingsMainSwitchBar;\nimport com.android.settingslib.RestrictedLockUtils.EnforcedAdmin;\nimport com.android.settingslib.RestrictedLockUtilsInternal;\nimport com.android.settingslib.RestrictedPreference;\nimport com.android.settingslib.drawable.CircleFramedDrawable;\nimport com.android.settingslib.search.SearchIndexable;\nimport com.android.settingslib.users.EditUserInfoController;\nimport com.android.settingslib.users.UserCreatingDialog;\nimport com.android.settingslib.utils.ThreadUtils;\n\nimport com.google.android.setupcompat.util.WizardManagerHelper;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\n/**\n * Screen that manages the list of users on the device.\n * Secondary users and a guest user can be created if there is no restriction.\n *\n * The first user in the list is always the current user.\n * Owner is the primary user.\n */\n@SearchIndexable\npublic class UserSettings extends SettingsPreferenceFragment\n        implements Preference.OnPreferenceClickListener,\n        MultiUserSwitchBarController.OnMultiUserSwitchChangedListener,\n        DialogInterface.OnDismissListener {\n\n    private static final String TAG = \"UserSettings\";\n\n    /** UserId of the user being removed */\n    private static final String SAVE_REMOVING_USER = \"removing_user\";\n\n    private static final String KEY_USER_LIST = \"user_list\";\n    private static final String KEY_USER_ME = \"user_me\";\n    private static final String KEY_USER_GUEST = \"user_guest\";\n    private static final String KEY_ADD_GUEST = \"guest_add\";\n    private static final String KEY_ADD_USER = \"user_add\";\n    private static final String KEY_ADD_USER_WHEN_LOCKED = \"user_settings_add_users_when_locked\";\n    private static final String KEY_MULTIUSER_TOP_INTRO = \"multiuser_top_intro\";\n\n    private static final int MENU_REMOVE_USER = Menu.FIRST;\n\n    private static final IntentFilter USER_REMOVED_INTENT_FILTER;\n\n    private static final int DIALOG_CONFIRM_REMOVE = 1;\n    private static final int DIALOG_ADD_USER = 2;\n    // Dialogs with id 3 and 4 got removed\n    private static final int DIALOG_USER_CANNOT_MANAGE = 5;\n    private static final int DIALOG_CHOOSE_USER_TYPE = 6;\n    private static final int DIALOG_NEED_LOCKSCREEN = 7;\n    private static final int DIALOG_CONFIRM_EXIT_GUEST = 8;\n    private static final int DIALOG_USER_PROFILE_EDITOR = 9;\n    private static final int DIALOG_USER_PROFILE_EDITOR_ADD_USER = 10;\n    private static final int DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE = 11;\n    private static final int DIALOG_CONFIRM_RESET_GUEST = 12;\n\n    private static final int MESSAGE_UPDATE_LIST = 1;\n    private static final int MESSAGE_USER_CREATED = 2;\n\n    private static final int USER_TYPE_USER = 1;\n    private static final int USER_TYPE_RESTRICTED_PROFILE = 2;\n\n    private static final int REQUEST_CHOOSE_LOCK = 10;\n    private static final int REQUEST_EDIT_GUEST = 11;\n\n    static final int RESULT_GUEST_REMOVED = 100;\n\n    private static final String KEY_ADD_USER_LONG_MESSAGE_DISPLAYED =\n            \"key_add_user_long_message_displayed\";\n\n    private static final String KEY_TITLE = \"title\";\n    private static final String KEY_SUMMARY = \"summary\";\n\n    static {\n        USER_REMOVED_INTENT_FILTER = new IntentFilter(Intent.ACTION_USER_REMOVED);\n        USER_REMOVED_INTENT_FILTER.addAction(Intent.ACTION_USER_INFO_CHANGED);\n    }\n\n    @VisibleForTesting\n    PreferenceGroup mUserListCategory;\n    @VisibleForTesting\n    UserPreference mMePreference;\n    @VisibleForTesting\n    RestrictedPreference mAddGuest;\n    @VisibleForTesting\n    RestrictedPreference mAddUser;\n    @VisibleForTesting\n    SparseArray<Bitmap> mUserIcons = new SparseArray<>();\n    private int mRemovingUserId = -1;\n    private boolean mAddingUser;\n    private boolean mGuestUserAutoCreated;\n    private String mAddingUserName;\n    private UserCapabilities mUserCaps;\n    private boolean mShouldUpdateUserList = true;\n    private final Object mUserLock = new Object();\n    private UserManager mUserManager;\n    private static SparseArray<Bitmap> sDarkDefaultUserBitmapCache = new SparseArray<>();\n\n    private MultiUserSwitchBarController mSwitchBarController;\n    private EditUserInfoController mEditUserInfoController =\n            new EditUserInfoController(Utils.FILE_PROVIDER_AUTHORITY);\n    private AddUserWhenLockedPreferenceController mAddUserWhenLockedPreferenceController;\n    private MultiUserTopIntroPreferenceController mMultiUserTopIntroPreferenceController;\n    private UserCreatingDialog mUserCreatingDialog;\n    private final AtomicBoolean mGuestCreationScheduled = new AtomicBoolean();\n    private final ExecutorService mExecutor = Executors.newSingleThreadExecutor();\n\n    private CharSequence mPendingUserName;\n    private Drawable mPendingUserIcon;\n\n    // A place to cache the generated default avatar\n    private Drawable mDefaultIconDrawable;\n\n    // TODO:   Replace current Handler solution to something that doesn't leak memory and works\n    // TODO:   during a configuration change\n    private Handler mHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MESSAGE_UPDATE_LIST:\n                    updateUserList();\n                    break;\n                case MESSAGE_USER_CREATED:\n                    onUserCreated(msg.arg1);\n                    break;\n            }\n        }\n    };\n\n    private BroadcastReceiver mUserChangeReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            if (intent.getAction().equals(Intent.ACTION_USER_REMOVED)) {\n                mRemovingUserId = -1;\n            } else if (intent.getAction().equals(Intent.ACTION_USER_INFO_CHANGED)) {\n                int userHandle = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, -1);\n                if (userHandle != -1) {\n                    mUserIcons.remove(userHandle);\n                }\n            }\n            mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n        }\n    };\n\n    @Override\n    public int getMetricsCategory() {\n        return SettingsEnums.USER;\n    }\n\n    @Override\n    public void onActivityCreated(Bundle savedInstanceState) {\n        super.onActivityCreated(savedInstanceState);\n        // Assume we are in a SettingsActivity. This is only safe because we currently use\n        // SettingsActivity as base for all preference fragments.\n        final SettingsActivity activity = (SettingsActivity) getActivity();\n        final SettingsMainSwitchBar switchBar = activity.getSwitchBar();\n        switchBar.setTitle(getContext().getString(R.string.multiple_users_main_switch_title));\n        switchBar.show();\n        mSwitchBarController = new MultiUserSwitchBarController(activity,\n                new MainSwitchBarController(switchBar), this /* listener */);\n        getSettingsLifecycle().addObserver(mSwitchBarController);\n    }\n\n    @Override\n    public void onCreate(Bundle icicle) {\n        super.onCreate(icicle);\n        addPreferencesFromResource(R.xml.user_settings);\n        final Activity activity = getActivity();\n        if (!WizardManagerHelper.isDeviceProvisioned(activity)) {\n            activity.finish();\n            return;\n        }\n\n        mGuestUserAutoCreated = getPrefContext().getResources().getBoolean(\n                        com.android.internal.R.bool.config_guestUserAutoCreated);\n\n        mAddUserWhenLockedPreferenceController = new AddUserWhenLockedPreferenceController(\n                activity, KEY_ADD_USER_WHEN_LOCKED);\n\n        mMultiUserTopIntroPreferenceController = new MultiUserTopIntroPreferenceController(activity,\n                KEY_MULTIUSER_TOP_INTRO);\n\n        final PreferenceScreen screen = getPreferenceScreen();\n        mAddUserWhenLockedPreferenceController.displayPreference(screen);\n        mMultiUserTopIntroPreferenceController.displayPreference(screen);\n\n        screen.findPreference(mAddUserWhenLockedPreferenceController.getPreferenceKey())\n                .setOnPreferenceChangeListener(mAddUserWhenLockedPreferenceController);\n\n        if (icicle != null) {\n            if (icicle.containsKey(SAVE_REMOVING_USER)) {\n                mRemovingUserId = icicle.getInt(SAVE_REMOVING_USER);\n            }\n            mEditUserInfoController.onRestoreInstanceState(icicle);\n        }\n\n        mUserCaps = UserCapabilities.create(activity);\n        mUserManager = (UserManager) activity.getSystemService(Context.USER_SERVICE);\n        if (!mUserCaps.mEnabled) {\n            return;\n        }\n\n        final int myUserId = UserHandle.myUserId();\n\n        mUserListCategory = (PreferenceGroup) findPreference(KEY_USER_LIST);\n        mMePreference = new UserPreference(getPrefContext(), null /* attrs */, myUserId);\n        mMePreference.setKey(KEY_USER_ME);\n        mMePreference.setOnPreferenceClickListener(this);\n        if (mUserCaps.mIsAdmin) {\n            mMePreference.setSummary(R.string.user_admin);\n        }\n\n        mAddGuest = findPreference(KEY_ADD_GUEST);\n        mAddGuest.setOnPreferenceClickListener(this);\n\n        mAddUser = findPreference(KEY_ADD_USER);\n        if (!mUserCaps.mCanAddRestrictedProfile) {\n            // Label should only mention adding a \"user\", not a \"profile\"\n            mAddUser.setTitle(R.string.user_add_user_menu);\n        }\n        mAddUser.setOnPreferenceClickListener(this);\n\n        activity.registerReceiverAsUser(\n                mUserChangeReceiver, UserHandle.ALL, USER_REMOVED_INTENT_FILTER, null, mHandler);\n\n        updateUI();\n        mShouldUpdateUserList = false;\n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n\n        if (!mUserCaps.mEnabled) {\n            return;\n        }\n        final PreferenceScreen screen = getPreferenceScreen();\n\n        mAddUserWhenLockedPreferenceController.updateState(screen.findPreference(\n                mAddUserWhenLockedPreferenceController.getPreferenceKey()));\n\n        if (mShouldUpdateUserList) {\n            updateUI();\n        }\n    }\n\n    @Override\n    public void onPause() {\n        mShouldUpdateUserList = true;\n        super.onPause();\n    }\n\n    @Override\n    public void onDestroy() {\n        super.onDestroy();\n\n        if (mUserCaps == null || !mUserCaps.mEnabled) {\n            return;\n        }\n\n        getActivity().unregisterReceiver(mUserChangeReceiver);\n    }\n\n    @Override\n    public void onSaveInstanceState(Bundle outState) {\n        mEditUserInfoController.onSaveInstanceState(outState);\n        outState.putInt(SAVE_REMOVING_USER, mRemovingUserId);\n        super.onSaveInstanceState(outState);\n    }\n\n    @Override\n    public void startActivityForResult(Intent intent, int requestCode) {\n        mEditUserInfoController.startingActivityForResult();\n        super.startActivityForResult(intent, requestCode);\n    }\n\n    @Override\n    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n        int pos = 0;\n        // TODO(b/191509236): The menu item does not need to be accessible for guest users,\n        //  regardless of mGuestUserAutoCreated\n        if (!mUserCaps.mIsAdmin && canSwitchUserNow() && !(isCurrentUserGuest()\n                && mGuestUserAutoCreated)) {\n            String nickname = mUserManager.getUserName();\n            MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                    getResources().getString(R.string.user_remove_user_menu, nickname));\n            removeThisUser.setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);\n\n            final EnforcedAdmin disallowRemoveUserAdmin =\n                    RestrictedLockUtilsInternal.checkIfRestrictionEnforced(getContext(),\n                            UserManager.DISALLOW_REMOVE_USER, UserHandle.myUserId());\n            RestrictedLockUtilsInternal.setMenuItemAsDisabledByAdmin(getContext(), removeThisUser,\n                    disallowRemoveUserAdmin);\n        }\n        super.onCreateOptionsMenu(menu, inflater);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        final int itemId = item.getItemId();\n        if (itemId == MENU_REMOVE_USER) {\n            onRemoveUserClicked(UserHandle.myUserId());\n            return true;\n        } else {\n            return super.onOptionsItemSelected(item);\n        }\n    }\n\n    @Override\n    public void onMultiUserSwitchChanged(boolean newState) {\n        updateUI();\n    }\n\n    private void updateUI() {\n        mUserCaps.updateAddUserCapabilities(getActivity());\n        loadProfile();\n        updateUserList();\n    }\n\n    /**\n     * Loads profile information for the current user.\n     */\n    private void loadProfile() {\n        if (isCurrentUserGuest()) {\n            // No need to load profile information\n            mMePreference.setIcon(getEncircledDefaultIcon());\n            mMePreference.setTitle(\n                    mGuestUserAutoCreated ? com.android.settingslib.R.string.guest_reset_guest\n                            : R.string.user_exit_guest_title);\n            mMePreference.setSelectable(true);\n            // removing a guest will result in switching back to the admin user\n            mMePreference.setEnabled(canSwitchUserNow());\n            return;\n        }\n\n        new AsyncTask<Void, Void, String>() {\n            @Override\n            protected void onPostExecute(String result) {\n                finishLoadProfile(result);\n            }\n\n            @Override\n            protected String doInBackground(Void... values) {\n                UserInfo user = mUserManager.getUserInfo(UserHandle.myUserId());\n                if (user.iconPath == null || user.iconPath.equals(\"\")) {\n                    // Assign profile photo.\n                    copyMeProfilePhoto(getActivity(), user);\n                }\n                return user.name;\n            }\n        }.execute();\n    }\n\n    private void finishLoadProfile(String profileName) {\n        if (getActivity() == null) {\n            return;\n        }\n        mMePreference.setTitle(getString(R.string.user_you, profileName));\n        int myUserId = UserHandle.myUserId();\n        Bitmap b = mUserManager.getUserIcon(myUserId);\n        if (b != null) {\n            mMePreference.setIcon(encircle(b));\n            mUserIcons.put(myUserId, b);\n        }\n    }\n\n    private boolean hasLockscreenSecurity() {\n        LockPatternUtils lpu = new LockPatternUtils(getActivity());\n        return lpu.isSecure(UserHandle.myUserId());\n    }\n\n    private void launchChooseLockscreen() {\n        Intent chooseLockIntent = new Intent(DevicePolicyManager.ACTION_SET_NEW_PASSWORD);\n        chooseLockIntent.putExtra(ChooseLockGeneric.ChooseLockGenericFragment.HIDE_INSECURE_OPTIONS,\n                true);\n        startActivityForResult(chooseLockIntent, REQUEST_CHOOSE_LOCK);\n    }\n\n    @Override\n    public void onActivityResult(int requestCode, int resultCode, Intent data) {\n        super.onActivityResult(requestCode, resultCode, data);\n\n        if (requestCode == REQUEST_CHOOSE_LOCK) {\n            if (resultCode != Activity.RESULT_CANCELED && hasLockscreenSecurity()) {\n                addUserNow(USER_TYPE_RESTRICTED_PROFILE);\n            }\n        } else if (mGuestUserAutoCreated && requestCode == REQUEST_EDIT_GUEST\n                && resultCode == RESULT_GUEST_REMOVED) {\n            scheduleGuestCreation();\n        } else {\n            mEditUserInfoController.onActivityResult(requestCode, resultCode, data);\n        }\n    }\n\n    private void onAddUserClicked(int userType) {\n        synchronized (mUserLock) {\n            if (mRemovingUserId == -1 && !mAddingUser) {\n                switch (userType) {\n                    case USER_TYPE_USER:\n                        showDialog(DIALOG_ADD_USER);\n                        break;\n                    case USER_TYPE_RESTRICTED_PROFILE:\n                        if (hasLockscreenSecurity()) {\n                            showDialog(DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE);\n                        } else {\n                            showDialog(DIALOG_NEED_LOCKSCREEN);\n                        }\n                        break;\n                }\n            }\n        }\n    }\n\n    private void onRemoveUserClicked(int userId) {\n        synchronized (mUserLock) {\n            if (mRemovingUserId == -1 && !mAddingUser) {\n                mRemovingUserId = userId;\n                showDialog(DIALOG_CONFIRM_REMOVE);\n            }\n        }\n    }\n\n    private void onUserCreated(int userId) {\n        hideUserCreatingDialog();\n        // prevent crash when config changes during user creation\n        if (getContext() == null) {\n            return;\n        }\n        mAddingUser = false;\n        UserInfo userInfo = mUserManager.getUserInfo(userId);\n        openUserDetails(userInfo, true);\n    }\n\n    private void hideUserCreatingDialog() {\n        if (mUserCreatingDialog != null && mUserCreatingDialog.isShowing()) {\n            mUserCreatingDialog.dismiss();\n        }\n    }\n\n    private void onUserCreationFailed() {\n        Toast.makeText(getContext(),\n                com.android.settingslib.R.string.add_user_failed,\n                Toast.LENGTH_SHORT).show();\n        hideUserCreatingDialog();\n    }\n\n    private void openUserDetails(UserInfo userInfo, boolean newUser) {\n        Bundle extras = new Bundle();\n        extras.putInt(UserDetailsSettings.EXTRA_USER_ID, userInfo.id);\n        extras.putBoolean(AppRestrictionsFragment.EXTRA_NEW_USER, newUser);\n\n        final Context context = getContext();\n        SubSettingLauncher launcher = new SubSettingLauncher(context)\n                .setDestination(UserDetailsSettings.class.getName())\n                .setArguments(extras)\n                .setTitleText(getUserName(context, userInfo))\n                .setSourceMetricsCategory(getMetricsCategory());\n        if (mGuestUserAutoCreated && userInfo.isGuest()) {\n            launcher.setResultListener(this, REQUEST_EDIT_GUEST);\n        }\n        launcher.launch();\n    }\n\n    @Override\n    public void onDialogShowing() {\n        super.onDialogShowing();\n\n        setOnDismissListener(this);\n    }\n\n    @Override\n    public Dialog onCreateDialog(int dialogId) {\n        Context context = getActivity();\n        if (context == null) {\n            return null;\n        }\n        switch (dialogId) {\n            case DIALOG_CONFIRM_REMOVE: {\n                Dialog dlg =\n                        UserDialogs.createRemoveDialog(getActivity(), mRemovingUserId,\n                                new DialogInterface.OnClickListener() {\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        removeUserNow();\n                                    }\n                                }\n                        );\n                return dlg;\n            }\n            case DIALOG_USER_CANNOT_MANAGE:\n                return new AlertDialog.Builder(context)\n                        .setMessage(R.string.user_cannot_manage_message)\n                        .setPositiveButton(android.R.string.ok, null)\n                        .create();\n            case DIALOG_ADD_USER: {\n                final SharedPreferences preferences = getActivity().getPreferences(\n                        Context.MODE_PRIVATE);\n                final boolean longMessageDisplayed = preferences.getBoolean(\n                        KEY_ADD_USER_LONG_MESSAGE_DISPLAYED, false);\n                final int messageResId = longMessageDisplayed\n                        ? com.android.settingslib.R.string.user_add_user_message_short\n                        : com.android.settingslib.R.string.user_add_user_message_long;\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setTitle(com.android.settingslib.R.string.user_add_user_title)\n                        .setMessage(messageResId)\n                        .setPositiveButton(android.R.string.ok,\n                                new DialogInterface.OnClickListener() {\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        showDialog(DIALOG_USER_PROFILE_EDITOR_ADD_USER);\n                                        if (!longMessageDisplayed) {\n                                            preferences.edit().putBoolean(\n                                                    KEY_ADD_USER_LONG_MESSAGE_DISPLAYED,\n                                                    true).apply();\n                                        }\n                                    }\n                                })\n                        .setNegativeButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            case DIALOG_CHOOSE_USER_TYPE: {\n                List<HashMap<String, String>> data = new ArrayList<HashMap<String, String>>();\n                HashMap<String, String> addUserItem = new HashMap<String, String>();\n                addUserItem.put(KEY_TITLE, getString(\n                        com.android.settingslib.R.string.user_add_user_item_title));\n                addUserItem.put(KEY_SUMMARY, getString(\n                        com.android.settingslib.R.string.user_add_user_item_summary));\n                HashMap<String, String> addProfileItem = new HashMap<String, String>();\n                addProfileItem.put(KEY_TITLE, getString(\n                        com.android.settingslib.R.string.user_add_profile_item_title));\n                addProfileItem.put(KEY_SUMMARY, getString(\n                        com.android.settingslib.R.string.user_add_profile_item_summary));\n                data.add(addUserItem);\n                data.add(addProfileItem);\n                AlertDialog.Builder builder = new AlertDialog.Builder(context);\n                SimpleAdapter adapter = new SimpleAdapter(builder.getContext(),\n                        data, R.layout.two_line_list_item,\n                        new String[]{KEY_TITLE, KEY_SUMMARY},\n                        new int[]{R.id.title, R.id.summary});\n                builder.setTitle(com.android.settingslib.R.string.user_add_user_type_title);\n                builder.setAdapter(adapter,\n                        new DialogInterface.OnClickListener() {\n                            @Override\n                            public void onClick(DialogInterface dialog, int which) {\n                                onAddUserClicked(which == 0\n                                        ? USER_TYPE_USER\n                                        : USER_TYPE_RESTRICTED_PROFILE);\n                            }\n                        });\n                return builder.create();\n            }\n            case DIALOG_NEED_LOCKSCREEN: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setMessage(com.android.settingslib.R.string.user_need_lock_message)\n                        .setPositiveButton(com.android.settingslib.R.string.user_set_lock_button,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        launchChooseLockscreen();\n                                    }\n                                })\n                        .setNegativeButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            case DIALOG_CONFIRM_EXIT_GUEST: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setTitle(R.string.user_exit_guest_confirm_title)\n                        .setMessage(R.string.user_exit_guest_confirm_message)\n                        .setPositiveButton(R.string.user_exit_guest_dialog_remove,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        exitGuest();\n                                    }\n                                })\n                        .setNegativeButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            case DIALOG_USER_PROFILE_EDITOR: {\n                return buildEditCurrentUserDialog();\n            }\n            case DIALOG_USER_PROFILE_EDITOR_ADD_USER: {\n                synchronized (mUserLock) {\n                    mPendingUserName = getString(\n                            com.android.settingslib.R.string.user_new_user_name);\n                    mPendingUserIcon = null;\n                }\n                return buildAddUserDialog(USER_TYPE_USER);\n            }\n            case DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE: {\n                synchronized (mUserLock) {\n                    mPendingUserName = getString(\n                            com.android.settingslib.R.string.user_new_profile_name);\n                    mPendingUserIcon = null;\n                }\n                return buildAddUserDialog(USER_TYPE_RESTRICTED_PROFILE);\n            }\n            case DIALOG_CONFIRM_RESET_GUEST: {\n                return UserDialogs.createResetGuestDialog(getActivity(),\n                        (dialog, which) -> resetGuest());\n            }\n            default:\n                return null;\n        }\n    }\n\n    private Dialog buildEditCurrentUserDialog() {\n        final Activity activity = getActivity();\n        if (activity == null) {\n            return null;\n        }\n\n        UserInfo user = mUserManager.getUserInfo(Process.myUserHandle().getIdentifier());\n        Drawable userIcon = Utils.getUserIcon(activity, mUserManager, user);\n\n        return mEditUserInfoController.createDialog(\n                activity,\n                this::startActivityForResult,\n                userIcon,\n                user.name,\n                getString(com.android.settingslib.R.string.profile_info_settings_title),\n                (newUserName, newUserIcon) -> {\n                    if (newUserIcon != userIcon) {\n                        ThreadUtils.postOnBackgroundThread(() ->\n                                mUserManager.setUserIcon(user.id,\n                                        UserIcons.convertToBitmap(newUserIcon)));\n                        mMePreference.setIcon(newUserIcon);\n                    }\n\n                    if (!TextUtils.isEmpty(newUserName) && !newUserName.equals(user.name)) {\n                        mMePreference.setTitle(newUserName);\n                        mUserManager.setUserName(user.id, newUserName);\n                    }\n                }, null);\n    }\n\n    private Dialog buildAddUserDialog(int userType) {\n        Dialog d;\n        synchronized (mUserLock) {\n            d = mEditUserInfoController.createDialog(\n                    getActivity(),\n                    this::startActivityForResult,\n                    null,\n                    mPendingUserName.toString(),\n                    getString(userType == USER_TYPE_USER\n                            ? com.android.settingslib.R.string.user_info_settings_title\n                            : com.android.settingslib.R.string.profile_info_settings_title),\n                    (userName, userIcon) -> {\n                        mPendingUserIcon = userIcon;\n                        mPendingUserName = userName;\n                        addUserNow(userType);\n                    },\n                    () -> {\n                        synchronized (mUserLock) {\n                            mPendingUserIcon = null;\n                            mPendingUserName = null;\n                        }\n                    }\n            );\n        }\n        return d;\n    }\n\n    @Override\n    public int getDialogMetricsCategory(int dialogId) {\n        switch (dialogId) {\n            case DIALOG_CONFIRM_REMOVE:\n                return SettingsEnums.DIALOG_USER_REMOVE;\n            case DIALOG_USER_CANNOT_MANAGE:\n                return SettingsEnums.DIALOG_USER_CANNOT_MANAGE;\n            case DIALOG_ADD_USER:\n                return SettingsEnums.DIALOG_USER_ADD;\n            case DIALOG_CHOOSE_USER_TYPE:\n                return SettingsEnums.DIALOG_USER_CHOOSE_TYPE;\n            case DIALOG_NEED_LOCKSCREEN:\n                return SettingsEnums.DIALOG_USER_NEED_LOCKSCREEN;\n            case DIALOG_CONFIRM_EXIT_GUEST:\n            case DIALOG_CONFIRM_RESET_GUEST:\n                return SettingsEnums.DIALOG_USER_CONFIRM_EXIT_GUEST;\n            case DIALOG_USER_PROFILE_EDITOR:\n            case DIALOG_USER_PROFILE_EDITOR_ADD_USER:\n            case DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE:\n                return SettingsEnums.DIALOG_USER_EDIT_PROFILE;\n            default:\n                return 0;\n        }\n    }\n\n    private void removeUserNow() {\n        if (mRemovingUserId == UserHandle.myUserId()) {\n            removeThisUser();\n        } else {\n            ThreadUtils.postOnBackgroundThread(new Runnable() {\n                @Override\n                public void run() {\n                    synchronized (mUserLock) {\n                        mUserManager.removeUser(mRemovingUserId);\n                        mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n                    }\n                }\n            });\n        }\n    }\n\n    private void removeThisUser() {\n        if (!canSwitchUserNow()) {\n            Log.w(TAG, \"Cannot remove current user when switching is disabled\");\n            return;\n        }\n        try {\n            getContext().getSystemService(UserManager.class)\n                    .removeUserOrSetEphemeral(UserHandle.myUserId(),\n                            /* evenWhenDisallowed= */ false);\n            ActivityManager.getService().switchUser(UserHandle.USER_SYSTEM);\n        } catch (RemoteException re) {\n            Log.e(TAG, \"Unable to remove self user\");\n        }\n    }\n\n    private void addUserNow(final int userType) {\n        synchronized (mUserLock) {\n            mAddingUser = true;\n            mAddingUserName = userType == USER_TYPE_USER\n                    ? (mPendingUserName != null ? mPendingUserName.toString()\n                    : getString(R.string.user_new_user_name))\n                    : (mPendingUserName != null ? mPendingUserName.toString()\n                            : getString(R.string.user_new_profile_name));\n        }\n\n        mUserCreatingDialog = new UserCreatingDialog(getActivity());\n        mUserCreatingDialog.show();\n        ThreadUtils.postOnBackgroundThread(new Runnable() {\n            @Override\n            public void run() {\n                UserInfo user;\n                String username;\n\n                synchronized (mUserLock) {\n                    username = mAddingUserName;\n                }\n\n                // Could take a few seconds\n                if (userType == USER_TYPE_USER) {\n                    user = mUserManager.createUser(username, 0);\n                } else {\n                    user = mUserManager.createRestrictedProfile(username);\n                }\n\n                synchronized (mUserLock) {\n                    if (user == null) {\n                        mAddingUser = false;\n                        mPendingUserIcon = null;\n                        mPendingUserName = null;\n                        ThreadUtils.postOnMainThread(() -> onUserCreationFailed());\n                        return;\n                    }\n\n                    Drawable newUserIcon = mPendingUserIcon;\n                    if (newUserIcon == null) {\n                        newUserIcon = UserIcons.getDefaultUserIcon(getResources(), user.id, false);\n                    }\n                    mUserManager.setUserIcon(user.id, UserIcons.convertToBitmap(newUserIcon));\n\n                    if (userType == USER_TYPE_USER) {\n                        mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n                    }\n\n                    mHandler.sendMessage(mHandler.obtainMessage(\n                            MESSAGE_USER_CREATED, user.id, user.serialNumber));\n\n                    mPendingUserIcon = null;\n                    mPendingUserName = null;\n                }\n            }\n        });\n    }\n\n    /**\n     * Erase the current user (guest) and switch to another user.\n     */\n    @VisibleForTesting\n    void exitGuest() {\n        // Just to be safe\n        if (!isCurrentUserGuest()) {\n            return;\n        }\n        mMetricsFeatureProvider.action(getActivity(),\n                SettingsEnums.ACTION_USER_GUEST_EXIT_CONFIRMED);\n        removeThisUser();\n    }\n\n    /**\n     * Erase the current user (assuming it is a guest user), and create a new one in the background\n     */\n    @VisibleForTesting\n    void resetGuest() {\n        // Just to be safe\n        if (!isCurrentUserGuest()) {\n            return;\n        }\n        int guestUserId = UserHandle.myUserId();\n        // Using markGuestForDeletion allows us to create a new guest before this one is\n        // fully removed. This could happen if someone calls scheduleGuestCreation()\n        // immediately after calling this method.\n        boolean marked = mUserManager.markGuestForDeletion(guestUserId);\n        if (!marked) {\n            Log.w(TAG, \"Couldn't mark the guest for deletion for user \" + guestUserId);\n            return;\n        }\n        exitGuest();\n        scheduleGuestCreation();\n    }\n\n    /**\n     * Create a guest user in the background\n     */\n    @VisibleForTesting\n    void scheduleGuestCreation() {\n        // TODO(b/191067027): Move guest recreation to system_server\n        if (mGuestCreationScheduled.compareAndSet(/* expect= */ false, /* update= */ true)) {\n            // Once mGuestCreationScheduled=true, mAddGuest needs to be updated so that it shows\n            // \"Resetting guest...\"\n            mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n            mExecutor.execute(() -> {\n                UserInfo guest = mUserManager.createGuest(\n                        getContext(), getString(com.android.settingslib.R.string.user_guest));\n                mGuestCreationScheduled.set(false);\n                if (guest == null) {\n                    Log.e(TAG, \"Unable to automatically recreate guest user\");\n                }\n                // The list needs to be updated whether or not guest creation worked. If guest\n                // creation failed, the list needs to update so that \"Add guest\" is displayed.\n                // Otherwise, the UX could be stuck in a state where there is no way to switch to\n                // the guest user (e.g. Guest would not be selectable, and it would be stuck\n                // saying \"Resetting guest...\")\n                mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n            });\n        }\n    }\n\n    @VisibleForTesting\n    void updateUserList() {\n        final Context context = getActivity();\n        if (context == null) {\n            return;\n        }\n        final List<UserInfo> users = mUserManager.getAliveUsers();\n\n        final ArrayList<Integer> missingIcons = new ArrayList<>();\n        final ArrayList<UserPreference> userPreferences = new ArrayList<>();\n        userPreferences.add(mMePreference);\n\n        boolean canOpenUserDetails =\n                mUserCaps.mIsAdmin || (canSwitchUserNow() && !mUserCaps.mDisallowSwitchUser);\n        for (UserInfo user : users) {\n            if (!user.supportsSwitchToByUser()) {\n                // Only users that can be switched to should show up here.\n                // e.g. Managed profiles appear under Accounts Settings instead\n                continue;\n            }\n            UserPreference pref;\n            if (user.id == UserHandle.myUserId()) {\n                pref = mMePreference;\n            } else {\n                final Context prefContext = getPrefContext();\n                pref = new UserPreference(prefContext, null, user.id);\n                pref.setTitle(getUserName(prefContext, user));\n                userPreferences.add(pref);\n                pref.setOnPreferenceClickListener(this);\n                pref.setEnabled(canOpenUserDetails);\n                pref.setSelectable(true);\n\n                if (user.isGuest()) {\n                    pref.setIcon(getEncircledDefaultIcon());\n                    pref.setKey(KEY_USER_GUEST);\n                    if (mUserCaps.mDisallowSwitchUser) {\n                        pref.setDisabledByAdmin(\n                                RestrictedLockUtilsInternal.getDeviceOwner(context));\n                    } else {\n                        pref.setDisabledByAdmin(null);\n                    }\n                } else {\n                    pref.setKey(\"id=\" + user.id);\n                    if (user.isAdmin()) {\n                        pref.setSummary(R.string.user_admin);\n                    }\n                }\n            }\n            if (pref == null) {\n                continue;\n            }\n            if (user.id != UserHandle.myUserId() && !user.isGuest() && !user.isInitialized()) {\n                // sometimes after creating a guest the initialized flag isn't immediately set\n                // and we don't want to show \"Not set up\" summary for them\n                if (user.isRestricted()) {\n                    pref.setSummary(R.string.user_summary_restricted_not_set_up);\n                } else {\n                    pref.setSummary(R.string.user_summary_not_set_up);\n                    // Disallow setting up user which results in user switching when the\n                    // restriction is set.\n                    pref.setEnabled(!mUserCaps.mDisallowSwitchUser && canSwitchUserNow());\n                }\n            } else if (user.isRestricted()) {\n                pref.setSummary(R.string.user_summary_restricted_profile);\n            }\n            if (user.iconPath != null) {\n                if (mUserIcons.get(user.id) == null) {\n                    // Icon not loaded yet, print a placeholder\n                    missingIcons.add(user.id);\n                    pref.setIcon(getEncircledDefaultIcon());\n                } else {\n                    setPhotoId(pref, user);\n                }\n            } else {\n                // Icon not available yet, print a placeholder\n                pref.setIcon(getEncircledDefaultIcon());\n            }\n        }\n\n        // Add a temporary entry for the user being created\n        if (mAddingUser) {\n            UserPreference pref = new UserPreference(getPrefContext(), null,\n                    UserPreference.USERID_UNKNOWN);\n            pref.setEnabled(false);\n            pref.setTitle(mAddingUserName);\n            pref.setIcon(getEncircledDefaultIcon());\n            userPreferences.add(pref);\n        }\n\n\n        // Sort list of users by serialNum\n        Collections.sort(userPreferences, UserPreference.SERIAL_NUMBER_COMPARATOR);\n\n        getActivity().invalidateOptionsMenu();\n\n        // Load the icons\n        if (missingIcons.size() > 0) {\n            loadIconsAsync(missingIcons);\n        }\n\n        // If profiles are supported, mUserListCategory will have a special title\n        if (mUserCaps.mCanAddRestrictedProfile) {\n            mUserListCategory.setTitle(R.string.user_list_title);\n        } else {\n            mUserListCategory.setTitle(null);\n        }\n\n        // Remove everything from mUserListCategory and add new users.\n        mUserListCategory.removeAll();\n\n        // If multi-user is disabled, just show top info and return.\n        final Preference addUserOnLockScreen = getPreferenceScreen().findPreference(\n                mAddUserWhenLockedPreferenceController.getPreferenceKey());\n        mAddUserWhenLockedPreferenceController.updateState(addUserOnLockScreen);\n\n        final Preference multiUserTopIntroPrefence = getPreferenceScreen().findPreference(\n                mMultiUserTopIntroPreferenceController.getPreferenceKey());\n        mMultiUserTopIntroPreferenceController.updateState(multiUserTopIntroPrefence);\n        mUserListCategory.setVisible(mUserCaps.mUserSwitcherEnabled);\n\n        updateAddGuest(context, users.stream().anyMatch(UserInfo::isGuest));\n        updateAddUser(context);\n\n        if (!mUserCaps.mUserSwitcherEnabled) {\n            return;\n        }\n\n        for (UserPreference userPreference : userPreferences) {\n            userPreference.setOrder(Preference.DEFAULT_ORDER);\n            mUserListCategory.addPreference(userPreference);\n        }\n\n    }\n\n    private boolean isCurrentUserGuest() {\n        return mUserCaps.mIsGuest;\n    }\n\n    private boolean canSwitchUserNow() {\n        return mUserManager.getUserSwitchability() == UserManager.SWITCHABILITY_STATUS_OK;\n    }\n\n    private void updateAddGuest(Context context, boolean isGuestAlreadyCreated) {\n        if (!isGuestAlreadyCreated && mUserCaps.mCanAddGuest\n                && WizardManagerHelper.isDeviceProvisioned(context)\n                && mUserCaps.mUserSwitcherEnabled) {\n            mAddGuest.setVisible(true);\n            mAddGuest.setIcon(getEncircledDefaultIcon());\n            mAddGuest.setSelectable(true);\n            if (mGuestUserAutoCreated && mGuestCreationScheduled.get()) {\n                mAddGuest.setTitle(com.android.settingslib.R.string.user_guest);\n                mAddGuest.setSummary(R.string.guest_resetting);\n                mAddGuest.setEnabled(false);\n            } else {\n                mAddGuest.setTitle(com.android.settingslib.R.string.guest_new_guest);\n                mAddGuest.setEnabled(canSwitchUserNow());\n            }\n        } else {\n            mAddGuest.setVisible(false);\n        }\n    }\n\n    private void updateAddUser(Context context) {\n        if ((mUserCaps.mCanAddUser || mUserCaps.mDisallowAddUserSetByAdmin)\n                && WizardManagerHelper.isDeviceProvisioned(context)\n                && mUserCaps.mUserSwitcherEnabled) {\n            mAddUser.setVisible(true);\n            mAddUser.setSelectable(true);\n            final boolean canAddMoreUsers = mUserManager.canAddMoreUsers();\n            mAddUser.setEnabled(canAddMoreUsers && !mAddingUser && canSwitchUserNow());\n            if (!canAddMoreUsers) {\n                mAddUser.setSummary(\n                        getString(R.string.user_add_max_count, getRealUsersCount()));\n            } else {\n                mAddUser.setSummary(null);\n            }\n            if (mAddUser.isEnabled()) {\n                mAddUser.setDisabledByAdmin(\n                        mUserCaps.mDisallowAddUser ? mUserCaps.mEnforcedAdmin : null);\n            }\n        } else {\n            mAddUser.setVisible(false);\n        }\n    }\n\n    /**\n     * @return number of non-guest non-managed users\n     */\n    @VisibleForTesting\n    int getRealUsersCount() {\n        return (int) mUserManager.getUsers()\n                .stream()\n                .filter(user -> !user.isGuest() && !user.isProfile())\n                .count();\n    }\n\n    private void loadIconsAsync(List<Integer> missingIcons) {\n        new AsyncTask<List<Integer>, Void, Void>() {\n            @Override\n            protected void onPostExecute(Void result) {\n                updateUserList();\n            }\n\n            @Override\n            protected Void doInBackground(List<Integer>... values) {\n                for (int userId : values[0]) {\n                    Bitmap bitmap = mUserManager.getUserIcon(userId);\n                    if (bitmap == null) {\n                        bitmap = getDefaultUserIconAsBitmap(getContext().getResources(), userId);\n                    }\n                    mUserIcons.append(userId, bitmap);\n                }\n                return null;\n            }\n        }.execute(missingIcons);\n    }\n\n    private Drawable getEncircledDefaultIcon() {\n        if (mDefaultIconDrawable == null) {\n            mDefaultIconDrawable = encircle(\n                    getDefaultUserIconAsBitmap(getContext().getResources(), UserHandle.USER_NULL));\n        }\n        return mDefaultIconDrawable;\n    }\n\n    private void setPhotoId(Preference pref, UserInfo user) {\n        Bitmap bitmap = mUserIcons.get(user.id);\n        if (bitmap != null) {\n            pref.setIcon(encircle(bitmap));\n        }\n    }\n\n    /** Returns the user's name, or the appropriate string in the case of a Guest. */\n    public static String getUserName(Context context, @NonNull UserInfo userInfo) {\n        if (userInfo.isGuest()) {\n            return context.getString(R.string.user_guest);\n        }\n        return userInfo.name;\n    }\n\n    @Override\n    public boolean onPreferenceClick(Preference pref) {\n        if (pref == mMePreference) {\n            if (isCurrentUserGuest()) {\n                if (mGuestUserAutoCreated) {\n                    showDialog(DIALOG_CONFIRM_RESET_GUEST);\n                } else {\n                    showDialog(DIALOG_CONFIRM_EXIT_GUEST);\n                }\n            } else {\n                showDialog(DIALOG_USER_PROFILE_EDITOR);\n            }\n            return true;\n        } else if (pref instanceof UserPreference) {\n            UserInfo userInfo = mUserManager.getUserInfo(((UserPreference) pref).getUserId());\n            openUserDetails(userInfo, false);\n            return true;\n        } else if (pref == mAddUser) {\n            // If we allow both types, show a picker, otherwise directly go to\n            // flow for full user.\n            if (mUserCaps.mCanAddRestrictedProfile) {\n                showDialog(DIALOG_CHOOSE_USER_TYPE);\n            } else {\n                onAddUserClicked(USER_TYPE_USER);\n            }\n            return true;\n        } else if (pref == mAddGuest) {\n            mAddGuest.setEnabled(false); // prevent multiple tap issue\n            mMetricsFeatureProvider.action(getActivity(), SettingsEnums.ACTION_USER_GUEST_ADD);\n            UserInfo guest = mUserManager.createGuest(\n                    getContext(), getString(com.android.settingslib.R.string.user_guest));\n            if (guest == null) {\n                Toast.makeText(getContext(),\n                        com.android.settingslib.R.string.add_user_failed,\n                        Toast.LENGTH_SHORT).show();\n                return true;\n            }\n            openUserDetails(guest, true);\n            return true;\n        }\n        return false;\n    }\n\n    private Drawable encircle(Bitmap icon) {\n        Drawable circled = CircleFramedDrawable.getInstance(getActivity(), icon);\n        return circled;\n    }\n\n    @Override\n    public void onDismiss(DialogInterface dialog) {\n        synchronized (mUserLock) {\n            mRemovingUserId = -1;\n            updateUserList();\n        }\n    }\n\n    @Override\n    public int getHelpResource() {\n        return R.string.help_url_users;\n    }\n\n    /**\n     * Returns a default user icon (as a {@link Bitmap}) for the given user.\n     *\n     * Note that for guest users, you should pass in {@code UserHandle.USER_NULL}.\n     *\n     * @param resources resources object to fetch the user icon.\n     * @param userId    the user id or {@code UserHandle.USER_NULL} for a non-user specific icon\n     */\n    private static Bitmap getDefaultUserIconAsBitmap(Resources resources, int userId) {\n        Bitmap bitmap = null;\n        // Try finding the corresponding bitmap in the dark bitmap cache\n        bitmap = sDarkDefaultUserBitmapCache.get(userId);\n        if (bitmap == null) {\n            bitmap = UserIcons.convertToBitmap(\n                    UserIcons.getDefaultUserIcon(resources, userId, false));\n            // Save it to cache\n            sDarkDefaultUserBitmapCache.put(userId, bitmap);\n        }\n        return bitmap;\n    }\n\n    /**\n     * Assign the default photo to user with {@paramref userId}\n     *\n     * @param context used to get the {@link UserManager}\n     * @param userId  used to get the icon bitmap\n     * @return true if assign photo successfully, false if failed\n     */\n    @VisibleForTesting\n    static boolean assignDefaultPhoto(Context context, int userId) {\n        if (context == null) {\n            return false;\n        }\n        UserManager um = (UserManager) context.getSystemService(Context.USER_SERVICE);\n        Bitmap bitmap = getDefaultUserIconAsBitmap(context.getResources(), userId);\n        um.setUserIcon(userId, bitmap);\n\n        return true;\n    }\n\n    @WorkerThread\n    static void copyMeProfilePhoto(Context context, UserInfo user) {\n        Uri contactUri = ContactsContract.Profile.CONTENT_URI;\n\n        int userId = user != null ? user.id : UserHandle.myUserId();\n\n        InputStream avatarDataStream = ContactsContract.Contacts.openContactPhotoInputStream(\n                context.getContentResolver(),\n                contactUri, true);\n        // If there's no profile photo, assign a default avatar\n        if (avatarDataStream == null) {\n            assignDefaultPhoto(context, userId);\n            return;\n        }\n\n        UserManager um = (UserManager) context.getSystemService(Context.USER_SERVICE);\n        Bitmap icon = BitmapFactory.decodeStream(avatarDataStream);\n        um.setUserIcon(userId, icon);\n        try {\n            avatarDataStream.close();\n        } catch (IOException ioe) {\n        }\n    }\n\n    public static final BaseSearchIndexProvider SEARCH_INDEX_DATA_PROVIDER =\n            new BaseSearchIndexProvider(R.xml.user_settings) {\n\n                @Override\n                protected boolean isPageSearchEnabled(Context context) {\n                    final UserCapabilities userCaps = UserCapabilities.create(context);\n                    return userCaps.mEnabled;\n                }\n\n                @Override\n                public List<String> getNonIndexableKeysFromXml(Context context, int xmlResId,\n                        boolean suppressAllPage) {\n                    final List<String> niks = super.getNonIndexableKeysFromXml(context, xmlResId,\n                            suppressAllPage);\n                    AddUserWhenLockedPreferenceController controller =\n                            new AddUserWhenLockedPreferenceController(\n                                    context, KEY_ADD_USER_WHEN_LOCKED);\n                    controller.updateNonIndexableKeys(niks);\n                    new AutoSyncDataPreferenceController(context, null /* parent */)\n                            .updateNonIndexableKeys(niks);\n                    new AutoSyncPersonalDataPreferenceController(context, null /* parent */)\n                            .updateNonIndexableKeys(niks);\n                    new AutoSyncWorkDataPreferenceController(context, null /* parent */)\n                            .updateNonIndexableKeys(niks);\n                    return niks;\n                }\n            };\n}\n```"
                    }
                ]
            },
            {
                "downstream_version": "12L",
                "branch_used": "android12L-release",
                "downstream_patch": "4901c86b765f5e72075fb5e26374c097920a56f5",
                "repo_path": "android_repos/Settings",
                "result": "failure",
                "downstream_patch_content": "commit 4901c86b765f5e72075fb5e26374c097920a56f5\nAuthor: Adam Bookatz <bookatz@google.com>\nDate:   Mon Nov 18 15:53:41 2024 -0800\n\n    Don't let profiles open the UserSettings overflow [DO NOT MERGE]\n    \n    Really, profiles aren't expected to open Settings at all. But if they\n    do somehow, the overflow shouldn't appear.\n    \n    Bug: 352542820\n    Flag: EXEMPT bugfix\n    Test: Try to access the overflow of the work profile by launching its Settings in\n    adb shell am start --user 10 'com.android.settings/.Settings\\$UserSettingsActivity'\n    \n    Change-Id: I5e4c095cda3e19fa5c63c2c550a526f5da8ec5c1\n    Merged-In: I5e4c095cda3e19fa5c63c2c550a526f5da8ec5c1\n    (cherry picked from commit 69c7f5dac580361792bbb189178653b297d06c8a)\n\ndiff --git a/src/com/android/settings/users/UserSettings.java b/src/com/android/settings/users/UserSettings.java\nindex ee23fc379d8..56bdfba3069 100644\n--- a/src/com/android/settings/users/UserSettings.java\n+++ b/src/com/android/settings/users/UserSettings.java\n@@ -358,8 +358,8 @@ public class UserSettings extends SettingsPreferenceFragment\n         int pos = 0;\n         // TODO(b/191509236): The menu item does not need to be accessible for guest users,\n         //  regardless of mGuestUserAutoCreated\n-        if (!mUserCaps.mIsAdmin && canSwitchUserNow() && !(isCurrentUserGuest()\n-                && mGuestUserAutoCreated)) {\n+        if (!mUserCaps.mIsAdmin && canSwitchUserNow() && !mUserManager.isProfile()\n+                && !(isCurrentUserGuest() && mGuestUserAutoCreated)) {\n             String nickname = mUserManager.getUserName();\n             MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                     getResources().getString(R.string.user_remove_user_menu, nickname));\n",
                "file_conflicts": [
                    {
                        "file_name": "src/com/android/settings/users/UserSettings.java",
                        "total_hunks": 1,
                        "failed_hunks": [
                            1
                        ],
                        "inline_merge_conflicts": [],
                        "rej_file_content": "```diff\n--- src/com/android/settings/users/UserSettings.java\n+++ src/com/android/settings/users/UserSettings.java\n@@ -465,7 +465,7 @@ public class UserSettings extends SettingsPreferenceFragment\n     public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n         int pos = 0;\n         if (!isCurrentUserAdmin() && (canSwitchUserNow() || Flags.newMultiuserSettingsUx())\n-                && !isCurrentUserGuest()) {\n+                && !isCurrentUserGuest() && !mUserManager.isProfile()) {\n             String nickname = mUserManager.getUserName();\n             MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                     getResources().getString(R.string.user_remove_user_menu, nickname));\n```",
                        "patch_apply_output": "patching file src/com/android/settings/users/UserSettings.java\nHunk #1 FAILED at 465.\n1 out of 1 hunk FAILED -- saving rejects to file src/com/android/settings/users/UserSettings.java.rej",
                        "inline_merge_output": "patching file src/com/android/settings/users/UserSettings.java\nHunk #1 already applied at 468.",
                        "upstream_file_content": "```java\n/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.settings.users;\n\nimport static com.android.settingslib.Utils.getColorAttrDefaultColor;\n\nimport android.app.Activity;\nimport android.app.ActivityManager;\nimport android.app.Dialog;\nimport android.app.admin.DevicePolicyManager;\nimport android.app.settings.SettingsEnums;\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.pm.UserInfo;\nimport android.content.res.Resources;\nimport android.graphics.Bitmap;\nimport android.graphics.BitmapFactory;\nimport android.graphics.BlendMode;\nimport android.graphics.drawable.Drawable;\nimport android.graphics.drawable.LayerDrawable;\nimport android.multiuser.Flags;\nimport android.net.Uri;\nimport android.os.AsyncTask;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.Message;\nimport android.os.Process;\nimport android.os.RemoteException;\nimport android.os.Trace;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.provider.ContactsContract;\nimport android.provider.Settings;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.util.SparseArray;\nimport android.view.Gravity;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.WindowManagerGlobal;\nimport android.widget.SimpleAdapter;\nimport android.widget.Toast;\n\nimport androidx.annotation.VisibleForTesting;\nimport androidx.annotation.WorkerThread;\nimport androidx.appcompat.app.AlertDialog;\nimport androidx.preference.Preference;\nimport androidx.preference.PreferenceGroup;\nimport androidx.preference.PreferenceScreen;\n\nimport com.android.internal.util.UserIcons;\nimport com.android.internal.widget.LockPatternUtils;\nimport com.android.settings.R;\nimport com.android.settings.SettingsActivity;\nimport com.android.settings.SettingsPreferenceFragment;\nimport com.android.settings.Utils;\nimport com.android.settings.core.SubSettingLauncher;\nimport com.android.settings.password.ChooseLockGeneric;\nimport com.android.settings.search.BaseSearchIndexProvider;\nimport com.android.settings.widget.MainSwitchBarController;\nimport com.android.settings.widget.SettingsMainSwitchBar;\nimport com.android.settingslib.RestrictedLockUtils.EnforcedAdmin;\nimport com.android.settingslib.RestrictedLockUtilsInternal;\nimport com.android.settingslib.RestrictedPreference;\nimport com.android.settingslib.drawable.CircleFramedDrawable;\nimport com.android.settingslib.search.SearchIndexable;\nimport com.android.settingslib.search.SearchIndexableRaw;\nimport com.android.settingslib.users.CreateUserDialogController;\nimport com.android.settingslib.users.EditUserInfoController;\nimport com.android.settingslib.users.GrantAdminDialogController;\nimport com.android.settingslib.users.UserCreatingDialog;\nimport com.android.settingslib.utils.ThreadUtils;\n\nimport com.google.android.setupcompat.util.WizardManagerHelper;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.stream.Collectors;\n\n/**\n * Screen that manages the list of users on the device.\n * Secondary users and a guest user can be created if there is no restriction.\n *\n * The first user in the list is always the current user.\n * Owner is the primary user.\n */\n@SearchIndexable\npublic class UserSettings extends SettingsPreferenceFragment\n        implements Preference.OnPreferenceClickListener,\n        MultiUserSwitchBarController.OnMultiUserSwitchChangedListener,\n        DialogInterface.OnDismissListener {\n\n    private static final String TAG = \"UserSettings\";\n\n    /** UserId of the user being removed */\n    private static final String SAVE_REMOVING_USER = \"removing_user\";\n    private static final String SAVE_CREATE_USER = \"create_user\";\n\n    private static final String KEY_USER_LIST = \"user_list\";\n    private static final String KEY_USER_ME = \"user_me\";\n    private static final String KEY_USER_GUEST = \"user_guest\";\n    private static final String KEY_ADD_GUEST = \"guest_add\";\n    private static final String KEY_ADD_USER = \"user_add\";\n    private static final String KEY_ADD_SUPERVISED_USER = \"supervised_user_add\";\n    private static final String KEY_ADD_USER_WHEN_LOCKED = \"user_settings_add_users_when_locked\";\n    private static final String KEY_ENABLE_GUEST_TELEPHONY = \"enable_guest_calling\";\n    private static final String KEY_MULTIUSER_TOP_INTRO = \"multiuser_top_intro\";\n    private static final String KEY_TIMEOUT_TO_DOCK_USER = \"timeout_to_dock_user_preference\";\n    private static final String KEY_GUEST_CATEGORY = \"guest_category\";\n    private static final String KEY_GUEST_RESET = \"guest_reset\";\n    private static final String KEY_GUEST_EXIT = \"guest_exit\";\n    private static final String KEY_REMOVE_GUEST_ON_EXIT = \"remove_guest_on_exit\";\n    private static final String KEY_GUEST_USER_CATEGORY = \"guest_user_category\";\n    private static final String KEY_ALLOW_MULTIPLE_USERS = \"allow_multiple_users\";\n    private static final String KEY_USER_SETTINGS_SCREEN = \"user_settings_screen\";\n\n    private static final String SETTING_GUEST_HAS_LOGGED_IN = \"systemui.guest_has_logged_in\";\n\n    private static final int MENU_REMOVE_USER = Menu.FIRST;\n\n    private static final IntentFilter USER_REMOVED_INTENT_FILTER;\n\n    private static final int DIALOG_CONFIRM_REMOVE = 1;\n    private static final int DIALOG_ADD_USER = 2;\n    // Dialogs with id 3 and 4 got removed\n    private static final int DIALOG_USER_CANNOT_MANAGE = 5;\n    private static final int DIALOG_CHOOSE_USER_TYPE = 6;\n    private static final int DIALOG_NEED_LOCKSCREEN = 7;\n    private static final int DIALOG_CONFIRM_REMOVE_GUEST = 8;\n    private static final int DIALOG_USER_PROFILE_EDITOR = 9;\n    private static final int DIALOG_USER_PROFILE_EDITOR_ADD_USER = 10;\n    private static final int DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE = 11;\n    private static final int DIALOG_CONFIRM_REMOVE_GUEST_WITH_AUTO_CREATE = 12;\n    private static final int DIALOG_CONFIRM_RESET_AND_RESTART_GUEST = 13;\n    private static final int DIALOG_CONFIRM_EXIT_GUEST_EPHEMERAL = 14;\n    private static final int DIALOG_CONFIRM_EXIT_GUEST_NON_EPHEMERAL = 15;\n    private static final int DIALOG_GRANT_ADMIN = 16;\n\n    private static final int MESSAGE_UPDATE_LIST = 1;\n    private static final int MESSAGE_USER_CREATED = 2;\n    static final int MESSAGE_REMOVE_GUEST_ON_EXIT_CONTROLLER_GUEST_REMOVED = 3;\n\n    private static final int USER_TYPE_USER = 1;\n    private static final int USER_TYPE_RESTRICTED_PROFILE = 2;\n\n    private static final int REQUEST_CHOOSE_LOCK = 10;\n    private static final int REQUEST_EDIT_GUEST = 11;\n\n    static final int RESULT_GUEST_REMOVED = 100;\n\n    private static final String KEY_TITLE = \"title\";\n    private static final String KEY_SUMMARY = \"summary\";\n\n    private static final String EXTRA_OPEN_DIALOG_USER_PROFILE_EDITOR =\n            \"EXTRA_OPEN_DIALOG_USER_PROFILE_EDITOR\";\n\n    static {\n        USER_REMOVED_INTENT_FILTER = new IntentFilter(Intent.ACTION_USER_REMOVED);\n        USER_REMOVED_INTENT_FILTER.addAction(Intent.ACTION_USER_INFO_CHANGED);\n    }\n\n    @VisibleForTesting\n    PreferenceGroup mUserListCategory;\n    @VisibleForTesting\n    PreferenceGroup mGuestUserCategory;\n    @VisibleForTesting\n    PreferenceGroup mGuestCategory;\n    @VisibleForTesting\n    Preference mGuestResetPreference;\n    @VisibleForTesting\n    Preference mGuestExitPreference;\n    @VisibleForTesting\n    UserPreference mMePreference;\n    @VisibleForTesting\n    RestrictedPreference mAddGuest;\n    @VisibleForTesting\n    RestrictedPreference mAddUser;\n    @VisibleForTesting\n    RestrictedPreference mAddSupervisedUser;\n    @VisibleForTesting\n    SparseArray<Bitmap> mUserIcons = new SparseArray<>();\n    private int mRemovingUserId = -1;\n    private boolean mAddingUser;\n    private boolean mGuestUserAutoCreated;\n    private String mConfigSupervisedUserCreationPackage;\n    private String mAddingUserName;\n    private UserCapabilities mUserCaps;\n    private boolean mShouldUpdateUserList = true;\n    private final Object mUserLock = new Object();\n    private UserManager mUserManager;\n    private static SparseArray<Bitmap> sDarkDefaultUserBitmapCache = new SparseArray<>();\n\n    private MultiUserSwitchBarController mSwitchBarController;\n\n    private GrantAdminDialogController mGrantAdminDialogController =\n            new GrantAdminDialogController();\n    private EditUserInfoController mEditUserInfoController =\n            new EditUserInfoController(Utils.FILE_PROVIDER_AUTHORITY);\n    private CreateUserDialogController mCreateUserDialogController =\n            new CreateUserDialogController(Utils.FILE_PROVIDER_AUTHORITY);\n    private AddUserWhenLockedPreferenceController mAddUserWhenLockedPreferenceController;\n    private GuestTelephonyPreferenceController mGuestTelephonyPreferenceController;\n    private RemoveGuestOnExitPreferenceController mRemoveGuestOnExitPreferenceController;\n    private MultiUserTopIntroPreferenceController mMultiUserTopIntroPreferenceController;\n    private TimeoutToDockUserPreferenceController mTimeoutToDockUserPreferenceController;\n    private UserCreatingDialog mUserCreatingDialog;\n    private final AtomicBoolean mGuestCreationScheduled = new AtomicBoolean();\n    private final ExecutorService mExecutor = Executors.newSingleThreadExecutor();\n\n    private CharSequence mPendingUserName;\n    private Drawable mPendingUserIcon;\n    private boolean mPendingUserIsAdmin;\n\n    // A place to cache the generated default avatar\n    private Drawable mDefaultIconDrawable;\n\n    // TODO:   Replace current Handler solution to something that doesn't leak memory and works\n    // TODO:   during a configuration change\n    private Handler mHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MESSAGE_UPDATE_LIST:\n                    updateUserList();\n                    break;\n                case MESSAGE_REMOVE_GUEST_ON_EXIT_CONTROLLER_GUEST_REMOVED:\n                    updateUserList();\n                    if (mGuestUserAutoCreated) {\n                        scheduleGuestCreation();\n                    }\n                    break;\n            }\n        }\n    };\n\n    private BroadcastReceiver mUserChangeReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            if (intent.getAction().equals(Intent.ACTION_USER_REMOVED)) {\n                mRemovingUserId = -1;\n            } else if (intent.getAction().equals(Intent.ACTION_USER_INFO_CHANGED)) {\n                int userHandle = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, -1);\n                if (userHandle != -1) {\n                    mUserIcons.remove(userHandle);\n                }\n            }\n            mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n        }\n    };\n\n    @Override\n    public int getMetricsCategory() {\n        return SettingsEnums.USER;\n    }\n\n    @Override\n    public void onActivityCreated(Bundle savedInstanceState) {\n        super.onActivityCreated(savedInstanceState);\n        // Assume we are in a SettingsActivity. This is only safe because we currently use\n        // SettingsActivity as base for all preference fragments.\n        final SettingsActivity activity = (SettingsActivity) getActivity();\n        final SettingsMainSwitchBar switchBar = activity.getSwitchBar();\n        switchBar.setTitle(getContext().getString(R.string.multiple_users_main_switch_title));\n        if (!mUserCaps.mIsGuest) {\n            switchBar.show();\n        } else {\n            switchBar.hide();\n        }\n        mSwitchBarController = new MultiUserSwitchBarController(activity,\n                new MainSwitchBarController(switchBar), this /* listener */);\n        getSettingsLifecycle().addObserver(mSwitchBarController);\n        boolean openUserEditDialog = getIntent().getBooleanExtra(\n                EXTRA_OPEN_DIALOG_USER_PROFILE_EDITOR, false);\n        if (switchBar.isChecked() && openUserEditDialog) {\n            showDialog(DIALOG_USER_PROFILE_EDITOR);\n        }\n    }\n\n    @Override\n    public void onCreate(Bundle icicle) {\n        super.onCreate(icicle);\n        addPreferencesFromResource(R.xml.user_settings);\n        final Activity activity = getActivity();\n        if (!WizardManagerHelper.isDeviceProvisioned(activity)) {\n            activity.finish();\n            return;\n        }\n\n        mGuestUserAutoCreated = getPrefContext().getResources().getBoolean(\n                com.android.internal.R.bool.config_guestUserAutoCreated);\n\n        mAddUserWhenLockedPreferenceController = new AddUserWhenLockedPreferenceController(\n                activity, KEY_ADD_USER_WHEN_LOCKED);\n\n        mGuestTelephonyPreferenceController = new GuestTelephonyPreferenceController(\n                activity, KEY_ENABLE_GUEST_TELEPHONY);\n\n        mRemoveGuestOnExitPreferenceController = new RemoveGuestOnExitPreferenceController(\n                activity, KEY_REMOVE_GUEST_ON_EXIT, this, mHandler);\n\n        mMultiUserTopIntroPreferenceController = new MultiUserTopIntroPreferenceController(activity,\n                KEY_MULTIUSER_TOP_INTRO);\n\n        mTimeoutToDockUserPreferenceController = new TimeoutToDockUserPreferenceController(\n                activity, KEY_TIMEOUT_TO_DOCK_USER);\n\n        final PreferenceScreen screen = getPreferenceScreen();\n        mAddUserWhenLockedPreferenceController.displayPreference(screen);\n        mGuestTelephonyPreferenceController.displayPreference(screen);\n        mRemoveGuestOnExitPreferenceController.displayPreference(screen);\n        mMultiUserTopIntroPreferenceController.displayPreference(screen);\n        mTimeoutToDockUserPreferenceController.displayPreference(screen);\n\n        screen.findPreference(mAddUserWhenLockedPreferenceController.getPreferenceKey())\n                .setOnPreferenceChangeListener(mAddUserWhenLockedPreferenceController);\n\n        screen.findPreference(mGuestTelephonyPreferenceController.getPreferenceKey())\n                .setOnPreferenceChangeListener(mGuestTelephonyPreferenceController);\n\n        screen.findPreference(mRemoveGuestOnExitPreferenceController.getPreferenceKey())\n                .setOnPreferenceChangeListener(mRemoveGuestOnExitPreferenceController);\n\n        if (icicle != null) {\n            if (icicle.containsKey(SAVE_REMOVING_USER)) {\n                mRemovingUserId = icicle.getInt(SAVE_REMOVING_USER);\n            }\n            if (icicle.containsKey(SAVE_CREATE_USER)) {\n                mCreateUserDialogController.onRestoreInstanceState(icicle);\n            } else {\n                mEditUserInfoController.onRestoreInstanceState(icicle);\n            }\n        }\n\n        mUserCaps = UserCapabilities.create(activity);\n        mUserManager = (UserManager) activity.getSystemService(Context.USER_SERVICE);\n        if (!mUserCaps.mEnabled) {\n            return;\n        }\n\n        final int myUserId = UserHandle.myUserId();\n\n        mUserListCategory = (PreferenceGroup) findPreference(KEY_USER_LIST);\n        mMePreference = new UserPreference(getPrefContext(), null /* attrs */, myUserId);\n        mMePreference.setKey(KEY_USER_ME);\n        mMePreference.setOnPreferenceClickListener(this);\n\n        mGuestCategory = findPreference(KEY_GUEST_CATEGORY);\n\n        mGuestResetPreference = findPreference(KEY_GUEST_RESET);\n        mGuestResetPreference.setOnPreferenceClickListener(this);\n\n        mGuestExitPreference = findPreference(KEY_GUEST_EXIT);\n        mGuestExitPreference.setOnPreferenceClickListener(this);\n\n        mGuestUserCategory = findPreference(KEY_GUEST_USER_CATEGORY);\n\n        mAddGuest = findPreference(KEY_ADD_GUEST);\n        mAddGuest.setOnPreferenceClickListener(this);\n\n        mAddUser = findPreference(KEY_ADD_USER);\n        if (!mUserCaps.mCanAddRestrictedProfile) {\n            // Label should only mention adding a \"user\", not a \"profile\"\n            mAddUser.setTitle(com.android.settingslib.R.string.user_add_user);\n        }\n        mAddUser.setOnPreferenceClickListener(this);\n\n        setConfigSupervisedUserCreationPackage();\n        mAddSupervisedUser = findPreference(KEY_ADD_SUPERVISED_USER);\n        mAddSupervisedUser.setOnPreferenceClickListener(this);\n\n        activity.registerReceiverAsUser(\n                mUserChangeReceiver, UserHandle.ALL, USER_REMOVED_INTENT_FILTER, null, mHandler,\n                Context.RECEIVER_EXPORTED_UNAUDITED);\n\n        updateUI();\n        mShouldUpdateUserList = false;\n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n\n        if (!mUserCaps.mEnabled) {\n            return;\n        }\n        final PreferenceScreen screen = getPreferenceScreen();\n\n        mAddUserWhenLockedPreferenceController.updateState(screen.findPreference(\n                mAddUserWhenLockedPreferenceController.getPreferenceKey()));\n        mGuestTelephonyPreferenceController.updateState(screen.findPreference(\n                mGuestTelephonyPreferenceController.getPreferenceKey()));\n        mTimeoutToDockUserPreferenceController.updateState(screen.findPreference(\n                mTimeoutToDockUserPreferenceController.getPreferenceKey()));\n        mRemoveGuestOnExitPreferenceController.updateState(screen.findPreference(\n                mRemoveGuestOnExitPreferenceController.getPreferenceKey()));\n        mSwitchBarController.updateState();\n        if (mShouldUpdateUserList) {\n            updateUI();\n        }\n    }\n\n    @Override\n    public void onPause() {\n        mShouldUpdateUserList = true;\n        super.onPause();\n    }\n\n    @Override\n    public void onDestroy() {\n        super.onDestroy();\n\n        if (mUserCaps == null || !mUserCaps.mEnabled) {\n            return;\n        }\n\n        getActivity().unregisterReceiver(mUserChangeReceiver);\n    }\n\n    @Override\n    public void onSaveInstanceState(Bundle outState) {\n        if (mCreateUserDialogController.isActive()) {\n            outState.putBoolean(SAVE_CREATE_USER, mCreateUserDialogController.isActive());\n            mCreateUserDialogController.onSaveInstanceState(outState);\n        } else {\n            mEditUserInfoController.onSaveInstanceState(outState);\n        }\n        outState.putInt(SAVE_REMOVING_USER, mRemovingUserId);\n        super.onSaveInstanceState(outState);\n    }\n\n    @Override\n    public void startActivityForResult(Intent intent, int requestCode) {\n        mEditUserInfoController.startingActivityForResult();\n        mCreateUserDialogController.startingActivityForResult();\n        super.startActivityForResult(intent, requestCode);\n    }\n\n    @Override\n    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n        int pos = 0;\n        if (!isCurrentUserAdmin() && (canSwitchUserNow() || Flags.newMultiuserSettingsUx())\n                && !isCurrentUserGuest() && !mUserManager.isProfile()) {\n            String nickname = mUserManager.getUserName();\n            MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                    getResources().getString(R.string.user_remove_user_menu, nickname));\n            removeThisUser.setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);\n\n            final EnforcedAdmin disallowRemoveUserAdmin =\n                    RestrictedLockUtilsInternal.checkIfRestrictionEnforced(getContext(),\n                            UserManager.DISALLOW_REMOVE_USER, UserHandle.myUserId());\n            RestrictedLockUtilsInternal.setMenuItemAsDisabledByAdmin(getContext(), removeThisUser,\n                    disallowRemoveUserAdmin);\n        }\n        super.onCreateOptionsMenu(menu, inflater);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        final int itemId = item.getItemId();\n        if (itemId == MENU_REMOVE_USER) {\n            onRemoveUserClicked(UserHandle.myUserId());\n            return true;\n        } else {\n            return super.onOptionsItemSelected(item);\n        }\n    }\n\n    @Override\n    public void onMultiUserSwitchChanged(boolean newState) {\n        updateUI();\n    }\n\n    private void updateUI() {\n        mUserCaps.updateAddUserCapabilities(getActivity());\n        loadProfile();\n        updateUserList();\n    }\n\n    /**\n     * Loads profile information for the current user.\n     */\n    private void loadProfile() {\n        if (isCurrentUserGuest()) {\n            // No need to load profile information\n            mMePreference.setIcon(getEncircledDefaultIcon());\n            mMePreference.setTitle(mGuestUserAutoCreated\n                    ? com.android.settingslib.R.string.guest_reset_guest\n                    : com.android.settingslib.R.string.guest_exit_guest);\n            mMePreference.setSelectable(true);\n            // removing a guest will result in switching back to the admin user\n            mMePreference.setEnabled(canSwitchUserNow());\n            return;\n        }\n\n        new AsyncTask<Void, Void, String>() {\n            @Override\n            protected void onPostExecute(String result) {\n                finishLoadProfile(result);\n            }\n\n            @Override\n            protected String doInBackground(Void... values) {\n                UserInfo user = mUserManager.getUserInfo(UserHandle.myUserId());\n                if (user.iconPath == null || user.iconPath.equals(\"\")) {\n                    // Assign profile photo.\n                    copyMeProfilePhoto(getActivity(), user);\n                }\n                return user.name;\n            }\n        }.execute();\n    }\n\n    private void finishLoadProfile(String profileName) {\n        if (getActivity() == null) {\n            return;\n        }\n        mMePreference.setTitle(getString(R.string.user_you, profileName));\n        int myUserId = UserHandle.myUserId();\n        Bitmap b = mUserManager.getUserIcon(myUserId);\n        if (b != null) {\n            mMePreference.setIcon(encircleUserIcon(b));\n            mUserIcons.put(myUserId, b);\n        }\n    }\n\n    private boolean hasLockscreenSecurity() {\n        LockPatternUtils lpu = new LockPatternUtils(getActivity());\n        return lpu.isSecure(UserHandle.myUserId());\n    }\n\n    private void launchChooseLockscreen() {\n        Intent chooseLockIntent = new Intent(DevicePolicyManager.ACTION_SET_NEW_PASSWORD)\n                .setPackage(getContext().getPackageName());\n        chooseLockIntent.putExtra(ChooseLockGeneric.ChooseLockGenericFragment.HIDE_INSECURE_OPTIONS,\n                true);\n        startActivityForResult(chooseLockIntent, REQUEST_CHOOSE_LOCK);\n    }\n\n    @Override\n    public void onActivityResult(int requestCode, int resultCode, Intent data) {\n        super.onActivityResult(requestCode, resultCode, data);\n\n        if (requestCode == REQUEST_CHOOSE_LOCK) {\n            if (resultCode != Activity.RESULT_CANCELED && hasLockscreenSecurity()) {\n                addUserNow(USER_TYPE_RESTRICTED_PROFILE);\n            }\n        } else if (mGuestUserAutoCreated && requestCode == REQUEST_EDIT_GUEST\n                && resultCode == RESULT_GUEST_REMOVED) {\n            scheduleGuestCreation();\n        } else {\n            mCreateUserDialogController.onActivityResult(requestCode, resultCode, data);\n            mEditUserInfoController.onActivityResult(requestCode, resultCode, data);\n        }\n    }\n\n    private void onAddUserClicked(int userType) {\n        synchronized (mUserLock) {\n            if (mRemovingUserId == -1 && !mAddingUser) {\n                switch (userType) {\n                    case USER_TYPE_USER:\n                        showDialog(DIALOG_ADD_USER);\n                        break;\n                    case USER_TYPE_RESTRICTED_PROFILE:\n                        if (hasLockscreenSecurity()) {\n                            showDialog(DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE);\n                        } else {\n                            showDialog(DIALOG_NEED_LOCKSCREEN);\n                        }\n                        break;\n                }\n            }\n        }\n    }\n\n    private void onAddSupervisedUserClicked() {\n        final Intent intent = new Intent()\n                .setAction(UserManager.ACTION_CREATE_SUPERVISED_USER)\n                .setPackage(mConfigSupervisedUserCreationPackage)\n                .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n\n        startActivity(intent);\n    }\n\n    private void onAddGuestClicked() {\n        Context context = getContext();\n        final UserCreatingDialog guestCreatingDialog =\n                new UserCreatingDialog(getActivity(), /* isGuest= */ true);\n        guestCreatingDialog.show();\n\n        ThreadUtils.postOnBackgroundThread(() -> {\n            mMetricsFeatureProvider.action(getActivity(), SettingsEnums.ACTION_USER_GUEST_ADD);\n            Trace.beginSection(\"UserSettings.addGuest\");\n            final UserInfo guest = mUserManager.createGuest(context);\n            Trace.endSection();\n\n            ThreadUtils.postOnMainThread(() -> {\n                guestCreatingDialog.dismiss();\n                if (guest == null) {\n                    Toast.makeText(context,\n                            com.android.settingslib.R.string.add_guest_failed,\n                            Toast.LENGTH_SHORT).show();\n                    return;\n                }\n                openUserDetails(guest, true, context);\n            });\n        });\n    }\n\n    private void onRemoveUserClicked(int userId) {\n        synchronized (mUserLock) {\n            if (mRemovingUserId == -1 && !mAddingUser) {\n                mRemovingUserId = userId;\n                showDialog(DIALOG_CONFIRM_REMOVE);\n            }\n        }\n    }\n\n    private void onUserCreated(UserInfo userInfo, Context context) {\n        hideUserCreatingDialog();\n        mAddingUser = false;\n        openUserDetails(userInfo, true, context);\n    }\n\n    private void hideUserCreatingDialog() {\n        if (mUserCreatingDialog != null && mUserCreatingDialog.isShowing()) {\n            mUserCreatingDialog.dismiss();\n        }\n    }\n\n    private void onUserCreationFailed() {\n        Toast.makeText(getContext(),\n                com.android.settingslib.R.string.add_user_failed,\n                Toast.LENGTH_SHORT).show();\n        hideUserCreatingDialog();\n    }\n\n    private void openUserDetails(UserInfo userInfo, boolean newUser) {\n        openUserDetails(userInfo, newUser, getContext());\n    }\n\n    private void openUserDetails(UserInfo userInfo, boolean newUser, Context context) {\n        // to prevent a crash when config changes during user creation,\n        // we simply ignore this redirection step\n        if (context == null) {\n            return;\n        }\n\n        Bundle extras = new Bundle();\n        extras.putInt(UserDetailsSettings.EXTRA_USER_ID, userInfo.id);\n        extras.putBoolean(AppRestrictionsFragment.EXTRA_NEW_USER, newUser);\n\n        SubSettingLauncher launcher = new SubSettingLauncher(context)\n                .setDestination(UserDetailsSettings.class.getName())\n                .setArguments(extras)\n                .setTitleText(userInfo.name)\n                .setSourceMetricsCategory(getMetricsCategory());\n        if (mGuestUserAutoCreated && userInfo.isGuest()) {\n            launcher.setResultListener(this, REQUEST_EDIT_GUEST);\n        }\n        launcher.launch();\n    }\n\n    @Override\n    public void onDialogShowing() {\n        super.onDialogShowing();\n\n        setOnDismissListener(this);\n    }\n\n    @Override\n    public Dialog onCreateDialog(int dialogId) {\n        Context context = getActivity();\n        if (context == null) {\n            return null;\n        }\n        switch (dialogId) {\n            case DIALOG_CONFIRM_REMOVE: {\n                Dialog dlg =\n                        UserDialogs.createRemoveDialog(getActivity(), mRemovingUserId,\n                                new DialogInterface.OnClickListener() {\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        removeUserNow();\n                                    }\n                                }\n                        );\n                return dlg;\n            }\n            case DIALOG_USER_CANNOT_MANAGE:\n                return new AlertDialog.Builder(context)\n                        .setMessage(R.string.user_cannot_manage_message)\n                        .setPositiveButton(android.R.string.ok, null)\n                        .create();\n            case DIALOG_ADD_USER: {\n                synchronized (mUserLock) {\n                    mPendingUserName = getString(\n                            com.android.settingslib.R.string.user_new_user_name);\n                    mPendingUserIcon = null;\n                }\n                return buildAddUserDialog(USER_TYPE_USER);\n            }\n            case DIALOG_CHOOSE_USER_TYPE: {\n                List<HashMap<String, String>> data = new ArrayList<HashMap<String, String>>();\n                HashMap<String, String> addUserItem = new HashMap<String, String>();\n                addUserItem.put(KEY_TITLE, getString(\n                        com.android.settingslib.R.string.user_add_user_item_title));\n                addUserItem.put(KEY_SUMMARY, getString(\n                        com.android.settingslib.R.string.user_add_user_item_summary));\n                HashMap<String, String> addProfileItem = new HashMap<String, String>();\n                addProfileItem.put(KEY_TITLE, getString(\n                        com.android.settingslib.R.string.user_add_profile_item_title));\n                addProfileItem.put(KEY_SUMMARY, getString(\n                        com.android.settingslib.R.string.user_add_profile_item_summary));\n                data.add(addUserItem);\n                data.add(addProfileItem);\n                AlertDialog.Builder builder = new AlertDialog.Builder(context);\n                SimpleAdapter adapter = new SimpleAdapter(builder.getContext(),\n                        data, R.layout.two_line_list_item,\n                        new String[]{KEY_TITLE, KEY_SUMMARY},\n                        new int[]{R.id.title, R.id.summary});\n                builder.setTitle(com.android.settingslib.R.string.user_add_user_type_title);\n                builder.setAdapter(adapter,\n                        new DialogInterface.OnClickListener() {\n                            @Override\n                            public void onClick(DialogInterface dialog, int which) {\n                                onAddUserClicked(which == 0\n                                        ? USER_TYPE_USER\n                                        : USER_TYPE_RESTRICTED_PROFILE);\n                            }\n                        });\n                return builder.create();\n            }\n            case DIALOG_NEED_LOCKSCREEN: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setMessage(com.android.settingslib.R.string.user_need_lock_message)\n                        .setPositiveButton(com.android.settingslib.R.string.user_set_lock_button,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        launchChooseLockscreen();\n                                    }\n                                })\n                        .setNegativeButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            case DIALOG_CONFIRM_REMOVE_GUEST: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setTitle(com.android.settingslib.R.string.guest_remove_guest_dialog_title)\n                        .setMessage(R.string.user_exit_guest_confirm_message)\n                        .setPositiveButton(R.string.user_exit_guest_dialog_remove,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        clearAndExitGuest();\n                                    }\n                                })\n                        .setNegativeButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            case DIALOG_CONFIRM_EXIT_GUEST_EPHEMERAL: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setTitle(com.android.settingslib.R.string.guest_exit_dialog_title)\n                        .setMessage(com.android.settingslib.R.string.guest_exit_dialog_message)\n                        .setPositiveButton(\n                                com.android.settingslib.R.string.guest_exit_dialog_button,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        clearAndExitGuest();\n                                    }\n                                })\n                        .setNeutralButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            case DIALOG_CONFIRM_EXIT_GUEST_NON_EPHEMERAL: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setTitle(\n                            com.android.settingslib.R.string.guest_exit_dialog_title_non_ephemeral)\n                        .setMessage(\n                            com.android.settingslib\n                                .R.string.guest_exit_dialog_message_non_ephemeral)\n                        .setPositiveButton(\n                            com.android.settingslib.R.string.guest_exit_save_data_button,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        exitGuest();\n                                    }\n                                })\n                        .setNegativeButton(\n                            com.android.settingslib.R.string.guest_exit_clear_data_button,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        clearAndExitGuest();\n                                    }\n                                })\n                        .setNeutralButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            case DIALOG_USER_PROFILE_EDITOR: {\n                return buildEditCurrentUserDialog();\n            }\n            case DIALOG_USER_PROFILE_EDITOR_ADD_USER: {\n                synchronized (mUserLock) {\n                    mPendingUserName = getString(\n                            com.android.settingslib.R.string.user_new_user_name);\n                    mPendingUserIcon = null;\n                }\n                return buildAddUserDialog(USER_TYPE_USER);\n            }\n            case DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE: {\n                synchronized (mUserLock) {\n                    mPendingUserName = getString(\n                            com.android.settingslib.R.string.user_new_profile_name);\n                    mPendingUserIcon = null;\n                }\n                return buildAddUserDialog(USER_TYPE_RESTRICTED_PROFILE);\n            }\n            case DIALOG_CONFIRM_REMOVE_GUEST_WITH_AUTO_CREATE: {\n                return UserDialogs.createResetGuestDialog(getActivity(),\n                        (dialog, which) -> clearAndExitGuest());\n            }\n            case DIALOG_CONFIRM_RESET_AND_RESTART_GUEST: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setTitle(\n                            com.android.settingslib.R.string.guest_reset_and_restart_dialog_title)\n                        .setMessage(\n                            com.android.settingslib.R.string.guest_reset_and_restart_dialog_message)\n                        .setPositiveButton(\n                            com.android.settingslib.R.string.guest_reset_guest_confirm_button,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        resetAndRestartGuest();\n                                    }\n                                })\n                        .setNeutralButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            default:\n                return null;\n        }\n    }\n\n    private Dialog buildEditCurrentUserDialog() {\n        final Activity activity = getActivity();\n        if (activity == null) {\n            return null;\n        }\n\n        UserInfo user = mUserManager.getUserInfo(Process.myUserHandle().getIdentifier());\n        Drawable userIcon = Utils.getUserIcon(activity, mUserManager, user);\n\n        return mEditUserInfoController.createDialog(\n                activity,\n                this::startActivityForResult,\n                userIcon,\n                user.name,\n                (newUserName, newUserIcon) -> {\n                    if (newUserIcon != userIcon) {\n                        ThreadUtils.postOnBackgroundThread(() ->\n                                mUserManager.setUserIcon(user.id,\n                                        UserIcons.convertToBitmapAtUserIconSize(\n                                                activity.getResources(), newUserIcon)));\n                        mMePreference.setIcon(newUserIcon);\n                        if (Flags.avatarSync()) {\n                            final String pkg = getString(R.string.config_avatar_picker_package);\n                            final String action = pkg + \".set.confirm\";\n                            activity.sendBroadcast(new Intent(action).setPackage(pkg));\n                        }\n                    }\n\n                    if (!TextUtils.isEmpty(newUserName) && !newUserName.equals(user.name)) {\n                        mMePreference.setTitle(newUserName);\n                        mUserManager.setUserName(user.id, newUserName);\n                    }\n                }, () -> {\n                    if (Flags.avatarSync()) {\n                        final String pkg = getString(R.string.config_avatar_picker_package);\n                        final String action = pkg + \".set.cancel\";\n                        activity.sendBroadcast(new Intent(action).setPackage(pkg));\n                    }\n                });\n    }\n\n    private Dialog buildAddUserDialog(int userType) {\n        Dialog d;\n        synchronized (mUserLock) {\n            d = mCreateUserDialogController.createDialog(\n                    getActivity(),\n                    this::startActivityForResult,\n                    canCreateAdminUser(),\n                    (userName, userIcon, isAdmin) -> {\n                        mPendingUserIcon = userIcon;\n                        mPendingUserName = userName;\n                        mPendingUserIsAdmin = isAdmin;\n                        addUserNow(userType);\n                    },\n                    () -> {\n                        synchronized (mUserLock) {\n                            mPendingUserIcon = null;\n                            mPendingUserName = null;\n                        }\n                    }\n            );\n        }\n        return d;\n    }\n\n    /**\n     * Checks if the creation of a new admin user is allowed.\n     * @return {@code true} if creating a new admin is allowed, {@code false} otherwise.\n     */\n    private boolean canCreateAdminUser() {\n        if (Flags.unicornModeRefactoringForHsumReadOnly()) {\n            return UserManager.isMultipleAdminEnabled()\n                    && !mUserManager.hasUserRestriction(UserManager.DISALLOW_GRANT_ADMIN);\n        } else {\n            return UserManager.isMultipleAdminEnabled();\n        }\n    }\n\n    @Override\n    public int getDialogMetricsCategory(int dialogId) {\n        switch (dialogId) {\n            case DIALOG_CONFIRM_REMOVE:\n                return SettingsEnums.DIALOG_USER_REMOVE;\n            case DIALOG_USER_CANNOT_MANAGE:\n                return SettingsEnums.DIALOG_USER_CANNOT_MANAGE;\n            case DIALOG_GRANT_ADMIN:\n                return SettingsEnums.DIALOG_GRANT_USER_ADMIN;\n            case DIALOG_ADD_USER:\n                return SettingsEnums.DIALOG_USER_ADD;\n            case DIALOG_CHOOSE_USER_TYPE:\n                return SettingsEnums.DIALOG_USER_CHOOSE_TYPE;\n            case DIALOG_NEED_LOCKSCREEN:\n                return SettingsEnums.DIALOG_USER_NEED_LOCKSCREEN;\n            case DIALOG_CONFIRM_REMOVE_GUEST:\n            case DIALOG_CONFIRM_REMOVE_GUEST_WITH_AUTO_CREATE:\n            case DIALOG_CONFIRM_EXIT_GUEST_EPHEMERAL:\n            case DIALOG_CONFIRM_EXIT_GUEST_NON_EPHEMERAL:\n            case DIALOG_CONFIRM_RESET_AND_RESTART_GUEST:\n                return SettingsEnums.DIALOG_USER_CONFIRM_EXIT_GUEST;\n            case DIALOG_USER_PROFILE_EDITOR:\n            case DIALOG_USER_PROFILE_EDITOR_ADD_USER:\n            case DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE:\n                return SettingsEnums.DIALOG_USER_EDIT_PROFILE;\n            default:\n                return 0;\n        }\n    }\n\n    private void removeUserNow() {\n        if (mRemovingUserId == UserHandle.myUserId()) {\n            removeThisUser();\n        } else {\n            ThreadUtils.postOnBackgroundThread(new Runnable() {\n                @Override\n                public void run() {\n                    synchronized (mUserLock) {\n                        mUserManager.removeUser(mRemovingUserId);\n                        mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n                    }\n                }\n            });\n        }\n    }\n\n    private void removeThisUser() {\n        if (!canSwitchUserNow()) {\n            Log.w(TAG, \"Cannot remove current user when switching is disabled\");\n            return;\n        }\n        try {\n            mUserManager.removeUserWhenPossible(\n                    UserHandle.of(UserHandle.myUserId()), /* overrideDevicePolicy= */ false);\n            ActivityManager.getService().switchUser(\n                    mUserManager.getPreviousForegroundUser().getIdentifier());\n        } catch (RemoteException re) {\n            Log.e(TAG, \"Unable to remove self user\");\n        }\n    }\n\n    private void switchToUserId(int userId) {\n        if (!canSwitchUserNow()) {\n            Log.w(TAG, \"Cannot switch current user when switching is disabled\");\n            return;\n        }\n        try {\n            ActivityManager.getService().switchUser(userId);\n        } catch (RemoteException re) {\n            Log.e(TAG, \"Unable to switch user\");\n        }\n    }\n\n    private void addUserNow(final int userType) {\n        Trace.beginAsyncSection(\"UserSettings.addUserNow\", 0);\n        synchronized (mUserLock) {\n            mAddingUser = true;\n            mAddingUserName = userType == USER_TYPE_USER\n                    ? (mPendingUserName != null ? mPendingUserName.toString()\n                    : getString(com.android.settingslib.R.string.user_new_user_name))\n                    : (mPendingUserName != null ? mPendingUserName.toString()\n                            : getString(com.android.settingslib.R.string.user_new_profile_name));\n        }\n\n        mUserCreatingDialog = new UserCreatingDialog(getActivity());\n        mUserCreatingDialog.show();\n        createUser(userType, mAddingUserName);\n    }\n\n    @VisibleForTesting\n    void createUser(final int userType, String userName) {\n        Context context = getContext();\n        Resources resources = getResources();\n        final Drawable selectedUserIcon = mPendingUserIcon;\n        Future<?> unusedCreateUserFuture = ThreadUtils.postOnBackgroundThread(() -> {\n            UserInfo user;\n\n            if (userType == USER_TYPE_USER) {\n                user = mUserManager.createUser(\n                        userName,\n                        mUserManager.USER_TYPE_FULL_SECONDARY,\n                        0);\n                if (mPendingUserIsAdmin) {\n                    mUserManager.setUserAdmin(user.id);\n                }\n            } else {\n                user = mUserManager.createRestrictedProfile(userName);\n            }\n\n            ThreadUtils.postOnMainThread(() -> {\n                if (user == null) {\n                    mAddingUser = false;\n                    mPendingUserIcon = null;\n                    mPendingUserName = null;\n                    onUserCreationFailed();\n                    return;\n                }\n\n                Future<?> unusedSettingIconFuture = ThreadUtils.postOnBackgroundThread(() -> {\n                    Drawable newUserIcon = selectedUserIcon;\n                    if (newUserIcon == null) {\n                        newUserIcon = UserIcons.getDefaultUserIcon(resources, user.id, false);\n                    }\n                    mUserManager.setUserIcon(\n                            user.id, UserIcons.convertToBitmapAtUserIconSize(\n                                    resources, newUserIcon));\n                });\n\n                mPendingUserIcon = null;\n                mPendingUserName = null;\n\n                onUserCreated(user, context);\n            });\n        });\n    }\n\n\n    /**\n     * Erase the current user (guest) and switch to another user.\n     */\n    @VisibleForTesting\n    void clearAndExitGuest() {\n        // Just to be safe\n        if (!isCurrentUserGuest()) {\n            return;\n        }\n        mMetricsFeatureProvider.action(getActivity(),\n                SettingsEnums.ACTION_USER_GUEST_EXIT_CONFIRMED);\n\n        int guestUserId = UserHandle.myUserId();\n        // Using markGuestForDeletion allows us to create a new guest before this one is\n        // fully removed.\n        boolean marked = mUserManager.markGuestForDeletion(guestUserId);\n        if (!marked) {\n            Log.w(TAG, \"Couldn't mark the guest for deletion for user \" + guestUserId);\n            return;\n        }\n\n        removeThisUser();\n        if (mGuestUserAutoCreated) {\n            scheduleGuestCreation();\n        }\n    }\n\n    /**\n     * Switch to another user.\n     */\n    private void exitGuest() {\n        // Just to be safe\n        if (!isCurrentUserGuest()) {\n            return;\n        }\n        mMetricsFeatureProvider.action(getActivity(),\n                SettingsEnums.ACTION_USER_GUEST_EXIT_CONFIRMED);\n        switchToUserId(mUserManager.getPreviousForegroundUser().getIdentifier());\n    }\n\n    private int createGuest() {\n        UserInfo guest;\n        Context context = getPrefContext();\n        try {\n            guest = mUserManager.createGuest(context);\n        } catch (UserManager.UserOperationException e) {\n            Log.e(TAG, \"Couldn't create guest user\", e);\n            return UserHandle.USER_NULL;\n        }\n        if (guest == null) {\n            Log.e(TAG, \"Couldn't create guest, most likely because there already exists one\");\n            return UserHandle.USER_NULL;\n        }\n        return guest.id;\n    }\n\n    /**\n     * Remove current guest and start a new guest session\n     */\n    private void resetAndRestartGuest() {\n        // Just to be safe\n        if (!isCurrentUserGuest()) {\n            return;\n        }\n        int oldGuestUserId = UserHandle.myUserId();\n        // Using markGuestForDeletion allows us to create a new guest before this one is\n        // fully removed.\n        boolean marked = mUserManager.markGuestForDeletion(oldGuestUserId);\n        if (!marked) {\n            Log.w(TAG, \"Couldn't mark the guest for deletion for user \" + oldGuestUserId);\n            return;\n        }\n\n        try {\n            // Create a new guest in the foreground, and then immediately switch to it\n            int newGuestUserId = createGuest();\n            if (newGuestUserId == UserHandle.USER_NULL) {\n                Log.e(TAG, \"Could not create new guest, switching back to previous user\");\n                switchToUserId(mUserManager.getPreviousForegroundUser().getIdentifier());\n                mUserManager.removeUser(oldGuestUserId);\n                WindowManagerGlobal.getWindowManagerService().lockNow(/* options= */ null);\n                return;\n            }\n            switchToUserId(newGuestUserId);\n            mUserManager.removeUser(oldGuestUserId);\n        } catch (RemoteException e) {\n            Log.e(TAG, \"Couldn't remove guest because ActivityManager or WindowManager is dead\");\n            return;\n        }\n    }\n\n    /**\n     * Create a guest user in the background\n     */\n    @VisibleForTesting\n    void scheduleGuestCreation() {\n        // TODO(b/191067027): Move guest recreation to system_server\n        if (mGuestCreationScheduled.compareAndSet(/* expect= */ false, /* update= */ true)) {\n            // Once mGuestCreationScheduled=true, mAddGuest needs to be updated so that it shows\n            // \"Resetting guest...\"\n            mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n            mExecutor.execute(() -> {\n                UserInfo guest = mUserManager.createGuest(getContext());\n                mGuestCreationScheduled.set(false);\n                if (guest == null) {\n                    Log.e(TAG, \"Unable to automatically recreate guest user\");\n                }\n                // The list needs to be updated whether or not guest creation worked. If guest\n                // creation failed, the list needs to update so that \"Add guest\" is displayed.\n                // Otherwise, the UX could be stuck in a state where there is no way to switch to\n                // the guest user (e.g. Guest would not be selectable, and it would be stuck\n                // saying \"Resetting guest...\")\n                mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n            });\n        }\n    }\n\n    @VisibleForTesting\n    void updateUserList() {\n        final Context context = getActivity();\n        if (context == null) {\n            return;\n        }\n\n        List<UserInfo> users;\n        if (Flags.newMultiuserSettingsUx()) {\n            // Only users that can be switched to should show up here.\n            // e.g. Managed profiles appear under Accounts Settings instead\n            users = mUserManager.getAliveUsers().stream()\n                    .filter(UserInfo::supportsSwitchToByUser)\n                    .collect(Collectors.toList());\n        } else {\n            if (mUserCaps.mUserSwitcherEnabled) {\n                // Only users that can be switched to should show up here.\n                // e.g. Managed profiles appear under Accounts Settings instead\n                users = mUserManager.getAliveUsers().stream()\n                        .filter(UserInfo::supportsSwitchToByUser)\n                        .collect(Collectors.toList());\n            } else {\n                // Only current user will be displayed in case of multi-user switch is disabled\n                users = List.of(mUserManager.getUserInfo(context.getUserId()));\n            }\n        }\n\n        final ArrayList<Integer> missingIcons = new ArrayList<>();\n        final ArrayList<UserPreference> userPreferences = new ArrayList<>();\n\n        // mMePreference shows a icon for current user. However when current user is a guest, we\n        // don't show the guest user icon, instead we show two preferences for guest user to\n        // exit and reset itself. Hence we don't add mMePreference, i.e. guest user to the\n        // list of users visible in the UI.\n        if (!isCurrentUserGuest()) {\n            userPreferences.add(mMePreference);\n        }\n\n        boolean canOpenUserDetails =\n                isCurrentUserAdmin() || (canSwitchUserNow() && !mUserCaps.mDisallowSwitchUser);\n        for (UserInfo user : users) {\n            if (user.isGuest()) {\n                // Guest user is added to guest category via updateGuestCategory\n                // and not to user list so skip guest here\n                continue;\n            }\n            UserPreference pref;\n            if (user.id == UserHandle.myUserId()) {\n                pref = mMePreference;\n            } else {\n                pref = new UserPreference(getPrefContext(), null, user.id);\n                pref.setTitle(user.name);\n                userPreferences.add(pref);\n                pref.setOnPreferenceClickListener(this);\n                pref.setEnabled(canOpenUserDetails);\n                pref.setSelectable(true);\n                pref.setKey(\"id=\" + user.id);\n            }\n            if (pref == null) {\n                continue;\n            }\n            if (user.isMain()) {\n                pref.setSummary(R.string.user_owner);\n            } else if (user.isAdmin()) {\n                pref.setSummary(R.string.user_admin);\n            }\n            if (user.id != UserHandle.myUserId() && !user.isGuest() && !user.isInitialized()) {\n                // sometimes after creating a guest the initialized flag isn't immediately set\n                // and we don't want to show \"Not set up\" summary for them\n                if (user.isRestricted()) {\n                    pref.setSummary(R.string.user_summary_restricted_not_set_up);\n                } else {\n                    pref.setSummary(R.string.user_summary_not_set_up);\n                    // Disallow setting up user which results in user switching when the\n                    // restriction is set.\n                    // If newMultiuserSettingsUx flag is enabled, allow opening user details page\n                    // since switch to user will be disabled\n                    pref.setEnabled((!mUserCaps.mDisallowSwitchUser && canSwitchUserNow())\n                            || Flags.newMultiuserSettingsUx());\n                }\n            } else if (user.isRestricted()) {\n                pref.setSummary(R.string.user_summary_restricted_profile);\n            }\n            if (user.iconPath != null) {\n                if (mUserIcons.get(user.id) == null) {\n                    // Icon not loaded yet, print a placeholder\n                    missingIcons.add(user.id);\n                    pref.setIcon(getEncircledDefaultIcon());\n                } else {\n                    setPhotoId(pref, user);\n                }\n            } else {\n                // Icon not available yet, print a placeholder\n                pref.setIcon(getEncircledDefaultIcon());\n            }\n        }\n\n        // Add a temporary entry for the user being created\n        if (mAddingUser) {\n            UserPreference pref = new UserPreference(getPrefContext(), null,\n                    UserPreference.USERID_UNKNOWN);\n            pref.setEnabled(false);\n            pref.setTitle(mAddingUserName);\n            pref.setIcon(getEncircledDefaultIcon());\n            userPreferences.add(pref);\n        }\n\n        // Sort list of users by serialNum\n        Collections.sort(userPreferences, UserPreference.SERIAL_NUMBER_COMPARATOR);\n\n        getActivity().invalidateOptionsMenu();\n\n        // Load the icons\n        if (missingIcons.size() > 0) {\n            loadIconsAsync(missingIcons);\n        }\n\n        // If restricted profiles are supported, mUserListCategory will have a special title\n        if (mUserCaps.mCanAddRestrictedProfile) {\n            mUserListCategory.setTitle(R.string.user_list_title);\n        } else if (isCurrentUserGuest()) {\n            mUserListCategory.setTitle(R.string.other_user_category_title);\n        } else {\n            mUserListCategory.setTitle(R.string.user_category_title);\n        }\n\n        // Remove everything from mUserListCategory and add new users.\n        mUserListCategory.removeAll();\n\n        final Preference addUserOnLockScreen = getPreferenceScreen().findPreference(\n                mAddUserWhenLockedPreferenceController.getPreferenceKey());\n        mAddUserWhenLockedPreferenceController.updateState(addUserOnLockScreen);\n\n        final Preference guestCallPreference = getPreferenceScreen().findPreference(\n                mGuestTelephonyPreferenceController.getPreferenceKey());\n        mGuestTelephonyPreferenceController.updateState(guestCallPreference);\n\n        final Preference multiUserTopIntroPreference = getPreferenceScreen().findPreference(\n                mMultiUserTopIntroPreferenceController.getPreferenceKey());\n        mMultiUserTopIntroPreferenceController.updateState(multiUserTopIntroPreference);\n        updateGuestPreferences();\n        updateGuestCategory(context, users);\n        updateAddUser(context);\n        updateAddSupervisedUser(context);\n\n        for (UserPreference userPreference : userPreferences) {\n            userPreference.setOrder(Preference.DEFAULT_ORDER);\n            mUserListCategory.addPreference(userPreference);\n        }\n\n    }\n\n    @VisibleForTesting\n    void setConfigSupervisedUserCreationPackage() {\n        mConfigSupervisedUserCreationPackage = getPrefContext().getString(\n                com.android.internal.R.string.config_supervisedUserCreationPackage);\n    }\n\n    private boolean isCurrentUserGuest() {\n        return mUserCaps.mIsGuest;\n    }\n\n    private boolean isCurrentUserAdmin() {\n        return mUserCaps.mIsAdmin;\n    }\n\n    private boolean canSwitchUserNow() {\n        return mUserManager.getUserSwitchability() == UserManager.SWITCHABILITY_STATUS_OK;\n    }\n\n    private void updateGuestPreferences() {\n        // reset guest and exit guest preferences are shown only in guest mode.\n        // For all other users these are not visible.\n        mGuestCategory.setVisible(false);\n        mGuestResetPreference.setVisible(false);\n        mGuestExitPreference.setVisible(false);\n        if (!isCurrentUserGuest()) {\n            return;\n        }\n        mGuestCategory.setVisible(true);\n        mGuestExitPreference.setVisible(true);\n        mGuestResetPreference.setVisible(true);\n\n        boolean isGuestFirstLogin = Settings.Secure.getIntForUser(\n                getContext().getContentResolver(),\n                SETTING_GUEST_HAS_LOGGED_IN,\n                0,\n                UserHandle.myUserId()) <= 1;\n        String guestExitSummary;\n        if (mUserCaps.mIsEphemeral) {\n            guestExitSummary = getContext().getString(\n                    com.android.settingslib.R.string.guest_notification_ephemeral);\n        } else if (isGuestFirstLogin) {\n            guestExitSummary = getContext().getString(\n                    com.android.settingslib.R.string.guest_notification_non_ephemeral);\n        } else {\n            guestExitSummary = getContext().getString(\n                    com.android.settingslib.R\n                            .string.guest_notification_non_ephemeral_non_first_login);\n        }\n        mGuestExitPreference.setSummary(guestExitSummary);\n    }\n\n    private void updateGuestCategory(Context context, List<UserInfo> users) {\n        // show guest category title and related guest preferences\n        // - if guest is created, then show guest user preference\n        // - if guest is not created and its allowed to create guest,\n        //   then show \"add guest\" preference\n        // - if allowed, show \"reset guest on exit\" preference\n        // - if there is nothing to show, then make the guest category as not visible\n        // - guest category is not visible for guest user.\n        UserPreference pref = null;\n        boolean isGuestAlreadyCreated = false;\n        boolean canOpenUserDetails =\n                isCurrentUserAdmin() || (canSwitchUserNow() && !mUserCaps.mDisallowSwitchUser);\n\n        mGuestUserCategory.removeAll();\n        mGuestUserCategory.setVisible(false);\n        for (UserInfo user : users) {\n            if (!user.isGuest() || !user.isEnabled()) {\n                // Only look at enabled, guest users\n                continue;\n            }\n            final Context prefContext = getPrefContext();\n            pref = new UserPreference(prefContext, null, user.id);\n            pref.setTitle(user.name);\n            pref.setOnPreferenceClickListener(this);\n            pref.setEnabled(canOpenUserDetails);\n            pref.setSelectable(true);\n            Drawable icon = getContext().getDrawable(\n                    com.android.settingslib.R.drawable.ic_account_circle_outline);\n            icon.setTint(\n                    getColorAttrDefaultColor(getContext(), android.R.attr.colorControlNormal));\n            pref.setIcon(encircleUserIcon(\n                    UserIcons.convertToBitmapAtUserIconSize(\n                            getContext().getResources(), icon)));\n            pref.setKey(KEY_USER_GUEST);\n            pref.setOrder(Preference.DEFAULT_ORDER);\n            if (mUserCaps.mDisallowSwitchUser && !Flags.newMultiuserSettingsUx()) {\n                pref.setDisabledByAdmin(\n                        RestrictedLockUtilsInternal.getDeviceOwner(context));\n            } else {\n                pref.setDisabledByAdmin(null);\n            }\n            if (Flags.newMultiuserSettingsUx()) {\n                mGuestUserCategory.addPreference(pref);\n                // guest user preference is shown hence also make guest category visible\n                mGuestUserCategory.setVisible(true);\n            } else {\n                if (mUserCaps.mUserSwitcherEnabled) {\n                    mGuestUserCategory.addPreference(pref);\n                    // guest user preference is shown hence also make guest category visible\n                    mGuestUserCategory.setVisible(true);\n                }\n            }\n            isGuestAlreadyCreated = true;\n        }\n        boolean isVisible = updateAddGuestPreference(context, isGuestAlreadyCreated);\n        if (isVisible) {\n            // \"add guest\" preference is shown hence also make guest category visible\n            mGuestUserCategory.setVisible(true);\n        }\n        final Preference removeGuestOnExit = getPreferenceScreen().findPreference(\n                mRemoveGuestOnExitPreferenceController.getPreferenceKey());\n        mRemoveGuestOnExitPreferenceController.updateState(removeGuestOnExit);\n        if (mRemoveGuestOnExitPreferenceController.isAvailable()) {\n            // \"reset guest on exit\" preference is shown hence also make guest category visible\n            mGuestUserCategory.setVisible(true);\n        }\n        if (isCurrentUserGuest()) {\n            // guest category is not visible for guest user.\n            mGuestUserCategory.setVisible(false);\n        }\n    }\n\n    private boolean updateAddGuestPreference(Context context, boolean isGuestAlreadyCreated) {\n        boolean isVisible = false;\n        if (!isGuestAlreadyCreated && (mUserCaps.mCanAddGuest\n                || (Flags.newMultiuserSettingsUx() && mUserCaps.mDisallowAddUser))\n                && mUserManager.canAddMoreUsers(UserManager.USER_TYPE_FULL_GUEST)\n                && WizardManagerHelper.isDeviceProvisioned(context)\n                && (mUserCaps.mUserSwitcherEnabled || Flags.newMultiuserSettingsUx())) {\n            Drawable icon = context.getDrawable(\n                    com.android.settingslib.R.drawable.ic_account_circle);\n            mAddGuest.setIcon(centerAndTint(icon));\n            isVisible = true;\n            mAddGuest.setVisible(true);\n            mAddGuest.setSelectable(true);\n            if (mGuestUserAutoCreated && mGuestCreationScheduled.get()) {\n                mAddGuest.setTitle(com.android.internal.R.string.guest_name);\n                mAddGuest.setSummary(com.android.settingslib.R.string.guest_resetting);\n                mAddGuest.setEnabled(false);\n            } else {\n                mAddGuest.setTitle(com.android.settingslib.R.string.guest_new_guest);\n                if (Flags.newMultiuserSettingsUx()\n                        && mUserCaps.mDisallowAddUserSetByAdmin) {\n                    mAddGuest.setDisabledByAdmin(mUserCaps.mEnforcedAdmin);\n                } else if (Flags.newMultiuserSettingsUx() && mUserCaps.mDisallowAddUser) {\n                    final List<UserManager.EnforcingUser> enforcingUsers =\n                            mUserManager.getUserRestrictionSources(UserManager.DISALLOW_ADD_USER,\n                                    UserHandle.of(UserHandle.myUserId()));\n                    if (!enforcingUsers.isEmpty()) {\n                        final UserManager.EnforcingUser enforcingUser = enforcingUsers.get(0);\n                        final int restrictionSource = enforcingUser.getUserRestrictionSource();\n                        if (restrictionSource == UserManager.RESTRICTION_SOURCE_SYSTEM) {\n                            mAddGuest.setEnabled(false);\n                        } else {\n                            mAddGuest.setVisible(false);\n                        }\n                    }\n                } else {\n                    mAddGuest.setEnabled(canSwitchUserNow() || Flags.newMultiuserSettingsUx());\n                }\n            }\n        } else {\n            mAddGuest.setVisible(false);\n        }\n        return isVisible;\n    }\n\n    private void updateAddUser(Context context) {\n        updateAddUserCommon(context, mAddUser, mUserCaps.mCanAddRestrictedProfile);\n        Drawable icon = context.getDrawable(\n                com.android.settingslib.R.drawable.ic_account_circle_filled);\n        mAddUser.setIcon(centerAndTint(icon));\n    }\n\n    private void updateAddSupervisedUser(Context context) {\n        if (!TextUtils.isEmpty(mConfigSupervisedUserCreationPackage)) {\n            updateAddUserCommon(context, mAddSupervisedUser, false);\n            Drawable icon = context.getDrawable(\n                    com.android.settingslib.R.drawable.ic_add_supervised_user);\n            mAddSupervisedUser.setIcon(centerAndTint(icon));\n        } else {\n            mAddSupervisedUser.setVisible(false);\n        }\n    }\n\n    private void updateAddUserCommon(Context context, RestrictedPreference addUser,\n            boolean canAddRestrictedProfile) {\n        if ((mUserCaps.mCanAddUser\n                && !(mUserCaps.mDisallowAddUserSetByAdmin && Flags.newMultiuserSettingsUx()))\n                && WizardManagerHelper.isDeviceProvisioned(context)\n                && (mUserCaps.mUserSwitcherEnabled || Flags.newMultiuserSettingsUx())) {\n            addUser.setVisible(true);\n            addUser.setSelectable(true);\n            final boolean canAddMoreUsers =\n                    mUserManager.canAddMoreUsers(UserManager.USER_TYPE_FULL_SECONDARY)\n                            || (canAddRestrictedProfile\n                            && mUserManager.canAddMoreUsers(UserManager.USER_TYPE_FULL_RESTRICTED));\n            addUser.setEnabled(canAddMoreUsers && !mAddingUser\n                    && (canSwitchUserNow() || Flags.newMultiuserSettingsUx()));\n\n            if (!canAddMoreUsers) {\n                addUser.setSummary(getString(R.string.user_add_max_count));\n            } else {\n                addUser.setSummary(null);\n            }\n            if (addUser.isEnabled()) {\n                addUser.setDisabledByAdmin(\n                        mUserCaps.mDisallowAddUser ? mUserCaps.mEnforcedAdmin : null);\n            }\n        } else if (Flags.newMultiuserSettingsUx() && mUserCaps.mDisallowAddUserSetByAdmin) {\n            addUser.setVisible(true);\n            addUser.setDisabledByAdmin(mUserCaps.mEnforcedAdmin);\n        } else if (Flags.newMultiuserSettingsUx() && mUserCaps.mDisallowAddUser) {\n            final List<UserManager.EnforcingUser> enforcingUsers =\n                    mUserManager.getUserRestrictionSources(UserManager.DISALLOW_ADD_USER,\n                            UserHandle.of(UserHandle.myUserId()));\n            if (!enforcingUsers.isEmpty()) {\n                final UserManager.EnforcingUser enforcingUser = enforcingUsers.get(0);\n                final int restrictionSource = enforcingUser.getUserRestrictionSource();\n                if (restrictionSource == UserManager.RESTRICTION_SOURCE_SYSTEM) {\n                    addUser.setVisible(true);\n                    addUser.setEnabled(false);\n                } else {\n                    addUser.setVisible(false);\n                }\n            }\n        } else {\n            addUser.setVisible(false);\n        }\n    }\n\n    private Drawable centerAndTint(Drawable icon) {\n        icon.setTintBlendMode(BlendMode.SRC_IN);\n        icon.setTint(getColorAttrDefaultColor(getContext(), android.R.attr.textColorPrimary));\n\n        Drawable bg = getContext().getDrawable(com.android.settingslib.R.drawable.user_avatar_bg)\n                .mutate();\n        LayerDrawable ld = new LayerDrawable(new Drawable[] {bg, icon});\n        int size = getContext().getResources().getDimensionPixelSize(\n                R.dimen.multiple_users_avatar_size);\n        int bgSize = getContext().getResources().getDimensionPixelSize(\n                R.dimen.multiple_users_user_icon_size);\n        ld.setLayerSize(1, size, size);\n        ld.setLayerSize(0, bgSize, bgSize);\n        ld.setLayerGravity(1, Gravity.CENTER);\n\n        return ld;\n    }\n\n    /**\n     * @return number of non-guest non-managed users\n     */\n    @VisibleForTesting\n    int getRealUsersCount() {\n        return (int) mUserManager.getUsers()\n                .stream()\n                .filter(user -> !user.isGuest() && !user.isProfile())\n                .count();\n    }\n\n    private void loadIconsAsync(List<Integer> missingIcons) {\n        new AsyncTask<List<Integer>, Void, Void>() {\n            @Override\n            protected void onPostExecute(Void result) {\n                updateUserList();\n            }\n\n            @Override\n            protected Void doInBackground(List<Integer>... values) {\n                for (int userId : values[0]) {\n                    Bitmap bitmap = mUserManager.getUserIcon(userId);\n                    if (bitmap == null) {\n                        bitmap = getDefaultUserIconAsBitmap(getContext().getResources(), userId);\n                    }\n                    mUserIcons.append(userId, bitmap);\n                }\n                return null;\n            }\n        }.execute(missingIcons);\n    }\n\n    private Drawable getEncircledDefaultIcon() {\n        if (mDefaultIconDrawable == null) {\n            mDefaultIconDrawable = encircleUserIcon(\n                    getDefaultUserIconAsBitmap(getContext().getResources(), UserHandle.USER_NULL));\n        }\n        return mDefaultIconDrawable;\n    }\n\n    private void setPhotoId(Preference pref, UserInfo user) {\n        Bitmap bitmap = mUserIcons.get(user.id);\n        if (bitmap != null) {\n            pref.setIcon(encircleUserIcon(bitmap));\n        }\n    }\n\n    @Override\n    public boolean onPreferenceClick(Preference pref) {\n        mMetricsFeatureProvider.logSettingsTileClick(pref.getKey(), getMetricsCategory());\n        if (isCurrentUserGuest()) {\n            if (mGuestResetPreference != null && pref == mGuestResetPreference) {\n                showDialog(DIALOG_CONFIRM_RESET_AND_RESTART_GUEST);\n                return true;\n            }\n            if (mGuestExitPreference != null && pref == mGuestExitPreference) {\n                if (mUserCaps.mIsEphemeral) {\n                    showDialog(DIALOG_CONFIRM_EXIT_GUEST_EPHEMERAL);\n                } else {\n                    showDialog(DIALOG_CONFIRM_EXIT_GUEST_NON_EPHEMERAL);\n                }\n                return true;\n            }\n        }\n        if (pref == mMePreference) {\n            if (!isCurrentUserGuest()) {\n                showDialog(DIALOG_USER_PROFILE_EDITOR);\n                return true;\n            }\n        } else if (pref instanceof UserPreference) {\n            UserInfo userInfo = mUserManager.getUserInfo(((UserPreference) pref).getUserId());\n            openUserDetails(userInfo, false);\n            return true;\n        } else if (pref == mAddUser) {\n            mMetricsFeatureProvider.action(getActivity(), SettingsEnums.ACTION_USER_ADD);\n            // If we allow both types, show a picker, otherwise directly go to\n            // flow for full user.\n            if (mUserCaps.mCanAddRestrictedProfile) {\n                showDialog(DIALOG_CHOOSE_USER_TYPE);\n            } else {\n                onAddUserClicked(USER_TYPE_USER);\n            }\n            return true;\n        } else if (pref == mAddSupervisedUser) {\n            mMetricsFeatureProvider.action(getActivity(), SettingsEnums.ACTION_USER_SUPERVISED_ADD);\n            Trace.beginSection(\"UserSettings.addSupervisedUser\");\n            onAddSupervisedUserClicked();\n            Trace.endSection();\n            return true;\n        } else if (pref == mAddGuest) {\n            mAddGuest.setEnabled(false); // prevent multiple tap issue\n            onAddGuestClicked();\n            return true;\n        }\n        return false;\n    }\n\n    private Drawable encircleUserIcon(Bitmap icon) {\n        return new CircleFramedDrawable(\n                icon,\n                getActivity().getResources().getDimensionPixelSize(\n                        R.dimen.multiple_users_user_icon_size));\n    }\n\n    @Override\n    public void onDismiss(DialogInterface dialog) {\n        synchronized (mUserLock) {\n            mRemovingUserId = -1;\n            updateUserList();\n            if (mCreateUserDialogController.isActive()) {\n                mCreateUserDialogController.finish();\n            }\n        }\n    }\n\n    @Override\n    public int getHelpResource() {\n        return R.string.help_url_users;\n    }\n\n    /**\n     * Returns a default user icon (as a {@link Bitmap}) for the given user.\n     *\n     * Note that for guest users, you should pass in {@code UserHandle.USER_NULL}.\n     *\n     * @param resources resources object to fetch the user icon.\n     * @param userId    the user id or {@code UserHandle.USER_NULL} for a non-user specific icon\n     */\n    private static Bitmap getDefaultUserIconAsBitmap(Resources resources, int userId) {\n        Bitmap bitmap = null;\n        // Try finding the corresponding bitmap in the dark bitmap cache\n        bitmap = sDarkDefaultUserBitmapCache.get(userId);\n        if (bitmap == null) {\n            bitmap = UserIcons.convertToBitmapAtUserIconSize(resources,\n                    UserIcons.getDefaultUserIcon(resources, userId, false));\n            // Save it to cache\n            sDarkDefaultUserBitmapCache.put(userId, bitmap);\n        }\n        return bitmap;\n    }\n\n    /**\n     * Assign the default photo to user with {@paramref userId}\n     *\n     * @param context used to get the {@link UserManager}\n     * @param userId  used to get the icon bitmap\n     * @return true if assign photo successfully, false if failed\n     */\n    @VisibleForTesting\n    static boolean assignDefaultPhoto(Context context, int userId) {\n        if (context == null) {\n            return false;\n        }\n        UserManager um = (UserManager) context.getSystemService(Context.USER_SERVICE);\n        Bitmap bitmap = getDefaultUserIconAsBitmap(context.getResources(), userId);\n        um.setUserIcon(userId, bitmap);\n\n        return true;\n    }\n\n    @WorkerThread\n    static void copyMeProfilePhoto(Context context, UserInfo user) {\n        Uri contactUri = ContactsContract.Profile.CONTENT_URI;\n\n        int userId = user != null ? user.id : UserHandle.myUserId();\n\n        InputStream avatarDataStream = ContactsContract.Contacts.openContactPhotoInputStream(\n                context.getContentResolver(),\n                contactUri, true);\n        // If there's no profile photo, assign a default avatar\n        if (avatarDataStream == null) {\n            assignDefaultPhoto(context, userId);\n            return;\n        }\n\n        UserManager um = (UserManager) context.getSystemService(Context.USER_SERVICE);\n        Bitmap decodedIcon = BitmapFactory.decodeStream(avatarDataStream);\n        CircleFramedDrawable drawable = CircleFramedDrawable.getInstance(context, decodedIcon);\n        Bitmap icon = UserIcons.convertToBitmapAtUserIconSize(context.getResources(), drawable);\n\n        um.setUserIcon(userId, icon);\n        try {\n            avatarDataStream.close();\n        } catch (IOException ioe) {\n        }\n    }\n\n    public static final BaseSearchIndexProvider SEARCH_INDEX_DATA_PROVIDER =\n            new BaseSearchIndexProvider(R.xml.user_settings) {\n\n                @Override\n                protected boolean isPageSearchEnabled(Context context) {\n                    final UserCapabilities userCaps = UserCapabilities.create(context);\n                    return userCaps.mEnabled;\n                }\n\n                @Override\n                public List<SearchIndexableRaw> getRawDataToIndex(Context context,\n                        boolean enabled) {\n                    final List<SearchIndexableRaw> rawData = new ArrayList<>();\n                    if (!UserManager.supportsMultipleUsers()) {\n                        return rawData;\n                    }\n\n                    SearchIndexableRaw multipleUsersData = new SearchIndexableRaw(context);\n                    multipleUsersData.key = KEY_USER_SETTINGS_SCREEN;\n                    multipleUsersData.title =\n                            context.getString(R.string.user_settings_title);\n                    multipleUsersData.keywords =\n                            context.getString(R.string.multiple_users_title_keywords);\n                    multipleUsersData.screenTitle =\n                            context.getString(R.string.user_settings_title);\n                    rawData.add(multipleUsersData);\n\n                    SearchIndexableRaw allowMultipleUsersResult = new SearchIndexableRaw(context);\n\n                    allowMultipleUsersResult.key = KEY_ALLOW_MULTIPLE_USERS;\n                    allowMultipleUsersResult.title =\n                            context.getString(R.string.multiple_users_main_switch_title);\n                    allowMultipleUsersResult.keywords =\n                            context.getString(R.string.multiple_users_main_switch_keywords);\n                    allowMultipleUsersResult.screenTitle =\n                            context.getString(R.string.user_settings_title);\n                    allowMultipleUsersResult.className =\n                            MultiUserSwitchBarController.class.getName();\n\n                    rawData.add(allowMultipleUsersResult);\n\n                    SearchIndexableRaw addUserData = new SearchIndexableRaw(context);\n                    addUserData.key = KEY_ADD_USER;\n\n                    // Dynamically set the title of addUser preference\n                    final UserCapabilities userCaps = UserCapabilities.create(context);\n                    if (!userCaps.mCanAddRestrictedProfile) {\n                        addUserData.title = context.getString(\n                                com.android.settingslib.R.string.user_add_user);\n                    } else {\n                        addUserData.title = context.getString(\n                                R.string.user_add_user_or_profile_menu);\n                    }\n                    addUserData.screenTitle = context.getString(R.string.user_settings_title);\n                    addUserData.iconResId = R.drawable.ic_add_40dp;\n\n                    rawData.add(addUserData);\n\n                    return rawData;\n                }\n\n                @Override\n                public List<String> getNonIndexableKeysFromXml(Context context, int xmlResId,\n                        boolean suppressAllPage) {\n                    final List<String> niks = super.getNonIndexableKeysFromXml(context, xmlResId,\n                            suppressAllPage);\n                    if (TextUtils.isEmpty(context.getString(\n                            com.android.internal.R.string.config_supervisedUserCreationPackage))) {\n                        niks.add(KEY_ADD_SUPERVISED_USER);\n                    }\n                    AddUserWhenLockedPreferenceController controller =\n                            new AddUserWhenLockedPreferenceController(\n                                    context, KEY_ADD_USER_WHEN_LOCKED);\n                    controller.updateNonIndexableKeys(niks);\n                    new AutoSyncDataPreferenceController(context, null /* parent */)\n                            .updateNonIndexableKeys(niks);\n                    new AutoSyncPersonalDataPreferenceController(context, null /* parent */)\n                            .updateNonIndexableKeys(niks);\n                    new AutoSyncWorkDataPreferenceController(context, null /* parent */)\n                            .updateNonIndexableKeys(niks);\n                    if (suppressAllPage) {\n                        niks.add(KEY_ALLOW_MULTIPLE_USERS);\n                    }\n                    return niks;\n                }\n            };\n}\n```",
                        "downstream_file_content": "```java\n/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.settings.users;\n\nimport android.annotation.NonNull;\nimport android.app.Activity;\nimport android.app.ActivityManager;\nimport android.app.Dialog;\nimport android.app.admin.DevicePolicyManager;\nimport android.app.settings.SettingsEnums;\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.SharedPreferences;\nimport android.content.pm.UserInfo;\nimport android.content.res.Resources;\nimport android.graphics.Bitmap;\nimport android.graphics.BitmapFactory;\nimport android.graphics.drawable.Drawable;\nimport android.net.Uri;\nimport android.os.AsyncTask;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.Message;\nimport android.os.Process;\nimport android.os.RemoteException;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.provider.ContactsContract;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.util.SparseArray;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.widget.SimpleAdapter;\nimport android.widget.Toast;\n\nimport androidx.annotation.VisibleForTesting;\nimport androidx.annotation.WorkerThread;\nimport androidx.appcompat.app.AlertDialog;\nimport androidx.preference.Preference;\nimport androidx.preference.PreferenceGroup;\nimport androidx.preference.PreferenceScreen;\n\nimport com.android.internal.util.UserIcons;\nimport com.android.internal.widget.LockPatternUtils;\nimport com.android.settings.R;\nimport com.android.settings.SettingsActivity;\nimport com.android.settings.SettingsPreferenceFragment;\nimport com.android.settings.Utils;\nimport com.android.settings.core.SubSettingLauncher;\nimport com.android.settings.password.ChooseLockGeneric;\nimport com.android.settings.search.BaseSearchIndexProvider;\nimport com.android.settings.widget.MainSwitchBarController;\nimport com.android.settings.widget.SettingsMainSwitchBar;\nimport com.android.settingslib.RestrictedLockUtils.EnforcedAdmin;\nimport com.android.settingslib.RestrictedLockUtilsInternal;\nimport com.android.settingslib.RestrictedPreference;\nimport com.android.settingslib.drawable.CircleFramedDrawable;\nimport com.android.settingslib.search.SearchIndexable;\nimport com.android.settingslib.users.EditUserInfoController;\nimport com.android.settingslib.users.UserCreatingDialog;\nimport com.android.settingslib.utils.ThreadUtils;\n\nimport com.google.android.setupcompat.util.WizardManagerHelper;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\n/**\n * Screen that manages the list of users on the device.\n * Secondary users and a guest user can be created if there is no restriction.\n *\n * The first user in the list is always the current user.\n * Owner is the primary user.\n */\n@SearchIndexable\npublic class UserSettings extends SettingsPreferenceFragment\n        implements Preference.OnPreferenceClickListener,\n        MultiUserSwitchBarController.OnMultiUserSwitchChangedListener,\n        DialogInterface.OnDismissListener {\n\n    private static final String TAG = \"UserSettings\";\n\n    /** UserId of the user being removed */\n    private static final String SAVE_REMOVING_USER = \"removing_user\";\n\n    private static final String KEY_USER_LIST = \"user_list\";\n    private static final String KEY_USER_ME = \"user_me\";\n    private static final String KEY_USER_GUEST = \"user_guest\";\n    private static final String KEY_ADD_GUEST = \"guest_add\";\n    private static final String KEY_ADD_USER = \"user_add\";\n    private static final String KEY_ADD_USER_WHEN_LOCKED = \"user_settings_add_users_when_locked\";\n    private static final String KEY_MULTIUSER_TOP_INTRO = \"multiuser_top_intro\";\n\n    private static final int MENU_REMOVE_USER = Menu.FIRST;\n\n    private static final IntentFilter USER_REMOVED_INTENT_FILTER;\n\n    private static final int DIALOG_CONFIRM_REMOVE = 1;\n    private static final int DIALOG_ADD_USER = 2;\n    // Dialogs with id 3 and 4 got removed\n    private static final int DIALOG_USER_CANNOT_MANAGE = 5;\n    private static final int DIALOG_CHOOSE_USER_TYPE = 6;\n    private static final int DIALOG_NEED_LOCKSCREEN = 7;\n    private static final int DIALOG_CONFIRM_EXIT_GUEST = 8;\n    private static final int DIALOG_USER_PROFILE_EDITOR = 9;\n    private static final int DIALOG_USER_PROFILE_EDITOR_ADD_USER = 10;\n    private static final int DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE = 11;\n    private static final int DIALOG_CONFIRM_RESET_GUEST = 12;\n\n    private static final int MESSAGE_UPDATE_LIST = 1;\n    private static final int MESSAGE_USER_CREATED = 2;\n\n    private static final int USER_TYPE_USER = 1;\n    private static final int USER_TYPE_RESTRICTED_PROFILE = 2;\n\n    private static final int REQUEST_CHOOSE_LOCK = 10;\n    private static final int REQUEST_EDIT_GUEST = 11;\n\n    static final int RESULT_GUEST_REMOVED = 100;\n\n    private static final String KEY_ADD_USER_LONG_MESSAGE_DISPLAYED =\n            \"key_add_user_long_message_displayed\";\n\n    private static final String KEY_TITLE = \"title\";\n    private static final String KEY_SUMMARY = \"summary\";\n\n    static {\n        USER_REMOVED_INTENT_FILTER = new IntentFilter(Intent.ACTION_USER_REMOVED);\n        USER_REMOVED_INTENT_FILTER.addAction(Intent.ACTION_USER_INFO_CHANGED);\n    }\n\n    @VisibleForTesting\n    PreferenceGroup mUserListCategory;\n    @VisibleForTesting\n    UserPreference mMePreference;\n    @VisibleForTesting\n    RestrictedPreference mAddGuest;\n    @VisibleForTesting\n    RestrictedPreference mAddUser;\n    @VisibleForTesting\n    SparseArray<Bitmap> mUserIcons = new SparseArray<>();\n    private int mRemovingUserId = -1;\n    private boolean mAddingUser;\n    private boolean mGuestUserAutoCreated;\n    private String mAddingUserName;\n    private UserCapabilities mUserCaps;\n    private boolean mShouldUpdateUserList = true;\n    private final Object mUserLock = new Object();\n    private UserManager mUserManager;\n    private static SparseArray<Bitmap> sDarkDefaultUserBitmapCache = new SparseArray<>();\n\n    private MultiUserSwitchBarController mSwitchBarController;\n    private EditUserInfoController mEditUserInfoController =\n            new EditUserInfoController(Utils.FILE_PROVIDER_AUTHORITY);\n    private AddUserWhenLockedPreferenceController mAddUserWhenLockedPreferenceController;\n    private MultiUserTopIntroPreferenceController mMultiUserTopIntroPreferenceController;\n    private UserCreatingDialog mUserCreatingDialog;\n    private final AtomicBoolean mGuestCreationScheduled = new AtomicBoolean();\n    private final ExecutorService mExecutor = Executors.newSingleThreadExecutor();\n\n    private CharSequence mPendingUserName;\n    private Drawable mPendingUserIcon;\n\n    // A place to cache the generated default avatar\n    private Drawable mDefaultIconDrawable;\n\n    // TODO:   Replace current Handler solution to something that doesn't leak memory and works\n    // TODO:   during a configuration change\n    private Handler mHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MESSAGE_UPDATE_LIST:\n                    updateUserList();\n                    break;\n                case MESSAGE_USER_CREATED:\n                    onUserCreated(msg.arg1);\n                    break;\n            }\n        }\n    };\n\n    private BroadcastReceiver mUserChangeReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            if (intent.getAction().equals(Intent.ACTION_USER_REMOVED)) {\n                mRemovingUserId = -1;\n            } else if (intent.getAction().equals(Intent.ACTION_USER_INFO_CHANGED)) {\n                int userHandle = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, -1);\n                if (userHandle != -1) {\n                    mUserIcons.remove(userHandle);\n                }\n            }\n            mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n        }\n    };\n\n    @Override\n    public int getMetricsCategory() {\n        return SettingsEnums.USER;\n    }\n\n    @Override\n    public void onActivityCreated(Bundle savedInstanceState) {\n        super.onActivityCreated(savedInstanceState);\n        // Assume we are in a SettingsActivity. This is only safe because we currently use\n        // SettingsActivity as base for all preference fragments.\n        final SettingsActivity activity = (SettingsActivity) getActivity();\n        final SettingsMainSwitchBar switchBar = activity.getSwitchBar();\n        switchBar.setTitle(getContext().getString(R.string.multiple_users_main_switch_title));\n        switchBar.show();\n        mSwitchBarController = new MultiUserSwitchBarController(activity,\n                new MainSwitchBarController(switchBar), this /* listener */);\n        getSettingsLifecycle().addObserver(mSwitchBarController);\n    }\n\n    @Override\n    public void onCreate(Bundle icicle) {\n        super.onCreate(icicle);\n        addPreferencesFromResource(R.xml.user_settings);\n        final Activity activity = getActivity();\n        if (!WizardManagerHelper.isDeviceProvisioned(activity)) {\n            activity.finish();\n            return;\n        }\n\n        mGuestUserAutoCreated = getPrefContext().getResources().getBoolean(\n                        com.android.internal.R.bool.config_guestUserAutoCreated);\n\n        mAddUserWhenLockedPreferenceController = new AddUserWhenLockedPreferenceController(\n                activity, KEY_ADD_USER_WHEN_LOCKED);\n\n        mMultiUserTopIntroPreferenceController = new MultiUserTopIntroPreferenceController(activity,\n                KEY_MULTIUSER_TOP_INTRO);\n\n        final PreferenceScreen screen = getPreferenceScreen();\n        mAddUserWhenLockedPreferenceController.displayPreference(screen);\n        mMultiUserTopIntroPreferenceController.displayPreference(screen);\n\n        screen.findPreference(mAddUserWhenLockedPreferenceController.getPreferenceKey())\n                .setOnPreferenceChangeListener(mAddUserWhenLockedPreferenceController);\n\n        if (icicle != null) {\n            if (icicle.containsKey(SAVE_REMOVING_USER)) {\n                mRemovingUserId = icicle.getInt(SAVE_REMOVING_USER);\n            }\n            mEditUserInfoController.onRestoreInstanceState(icicle);\n        }\n\n        mUserCaps = UserCapabilities.create(activity);\n        mUserManager = (UserManager) activity.getSystemService(Context.USER_SERVICE);\n        if (!mUserCaps.mEnabled) {\n            return;\n        }\n\n        final int myUserId = UserHandle.myUserId();\n\n        mUserListCategory = (PreferenceGroup) findPreference(KEY_USER_LIST);\n        mMePreference = new UserPreference(getPrefContext(), null /* attrs */, myUserId);\n        mMePreference.setKey(KEY_USER_ME);\n        mMePreference.setOnPreferenceClickListener(this);\n        if (mUserCaps.mIsAdmin) {\n            mMePreference.setSummary(R.string.user_admin);\n        }\n\n        mAddGuest = findPreference(KEY_ADD_GUEST);\n        mAddGuest.setOnPreferenceClickListener(this);\n\n        mAddUser = findPreference(KEY_ADD_USER);\n        if (!mUserCaps.mCanAddRestrictedProfile) {\n            // Label should only mention adding a \"user\", not a \"profile\"\n            mAddUser.setTitle(R.string.user_add_user_menu);\n        }\n        mAddUser.setOnPreferenceClickListener(this);\n\n        activity.registerReceiverAsUser(\n                mUserChangeReceiver, UserHandle.ALL, USER_REMOVED_INTENT_FILTER, null, mHandler);\n\n        updateUI();\n        mShouldUpdateUserList = false;\n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n\n        if (!mUserCaps.mEnabled) {\n            return;\n        }\n        final PreferenceScreen screen = getPreferenceScreen();\n\n        mAddUserWhenLockedPreferenceController.updateState(screen.findPreference(\n                mAddUserWhenLockedPreferenceController.getPreferenceKey()));\n\n        if (mShouldUpdateUserList) {\n            updateUI();\n        }\n    }\n\n    @Override\n    public void onPause() {\n        mShouldUpdateUserList = true;\n        super.onPause();\n    }\n\n    @Override\n    public void onDestroy() {\n        super.onDestroy();\n\n        if (mUserCaps == null || !mUserCaps.mEnabled) {\n            return;\n        }\n\n        getActivity().unregisterReceiver(mUserChangeReceiver);\n    }\n\n    @Override\n    public void onSaveInstanceState(Bundle outState) {\n        mEditUserInfoController.onSaveInstanceState(outState);\n        outState.putInt(SAVE_REMOVING_USER, mRemovingUserId);\n        super.onSaveInstanceState(outState);\n    }\n\n    @Override\n    public void startActivityForResult(Intent intent, int requestCode) {\n        mEditUserInfoController.startingActivityForResult();\n        super.startActivityForResult(intent, requestCode);\n    }\n\n    @Override\n    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n        int pos = 0;\n        // TODO(b/191509236): The menu item does not need to be accessible for guest users,\n        //  regardless of mGuestUserAutoCreated\n        if (!mUserCaps.mIsAdmin && canSwitchUserNow() && !(isCurrentUserGuest()\n                && mGuestUserAutoCreated)) {\n            String nickname = mUserManager.getUserName();\n            MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                    getResources().getString(R.string.user_remove_user_menu, nickname));\n            removeThisUser.setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);\n\n            final EnforcedAdmin disallowRemoveUserAdmin =\n                    RestrictedLockUtilsInternal.checkIfRestrictionEnforced(getContext(),\n                            UserManager.DISALLOW_REMOVE_USER, UserHandle.myUserId());\n            RestrictedLockUtilsInternal.setMenuItemAsDisabledByAdmin(getContext(), removeThisUser,\n                    disallowRemoveUserAdmin);\n        }\n        super.onCreateOptionsMenu(menu, inflater);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        final int itemId = item.getItemId();\n        if (itemId == MENU_REMOVE_USER) {\n            onRemoveUserClicked(UserHandle.myUserId());\n            return true;\n        } else {\n            return super.onOptionsItemSelected(item);\n        }\n    }\n\n    @Override\n    public void onMultiUserSwitchChanged(boolean newState) {\n        updateUI();\n    }\n\n    private void updateUI() {\n        mUserCaps.updateAddUserCapabilities(getActivity());\n        loadProfile();\n        updateUserList();\n    }\n\n    /**\n     * Loads profile information for the current user.\n     */\n    private void loadProfile() {\n        if (isCurrentUserGuest()) {\n            // No need to load profile information\n            mMePreference.setIcon(getEncircledDefaultIcon());\n            mMePreference.setTitle(\n                    mGuestUserAutoCreated ? com.android.settingslib.R.string.guest_reset_guest\n                            : R.string.user_exit_guest_title);\n            mMePreference.setSelectable(true);\n            // removing a guest will result in switching back to the admin user\n            mMePreference.setEnabled(canSwitchUserNow());\n            return;\n        }\n\n        new AsyncTask<Void, Void, String>() {\n            @Override\n            protected void onPostExecute(String result) {\n                finishLoadProfile(result);\n            }\n\n            @Override\n            protected String doInBackground(Void... values) {\n                UserInfo user = mUserManager.getUserInfo(UserHandle.myUserId());\n                if (user.iconPath == null || user.iconPath.equals(\"\")) {\n                    // Assign profile photo.\n                    copyMeProfilePhoto(getActivity(), user);\n                }\n                return user.name;\n            }\n        }.execute();\n    }\n\n    private void finishLoadProfile(String profileName) {\n        if (getActivity() == null) {\n            return;\n        }\n        mMePreference.setTitle(getString(R.string.user_you, profileName));\n        int myUserId = UserHandle.myUserId();\n        Bitmap b = mUserManager.getUserIcon(myUserId);\n        if (b != null) {\n            mMePreference.setIcon(encircle(b));\n            mUserIcons.put(myUserId, b);\n        }\n    }\n\n    private boolean hasLockscreenSecurity() {\n        LockPatternUtils lpu = new LockPatternUtils(getActivity());\n        return lpu.isSecure(UserHandle.myUserId());\n    }\n\n    private void launchChooseLockscreen() {\n        Intent chooseLockIntent = new Intent(DevicePolicyManager.ACTION_SET_NEW_PASSWORD);\n        chooseLockIntent.putExtra(ChooseLockGeneric.ChooseLockGenericFragment.HIDE_INSECURE_OPTIONS,\n                true);\n        startActivityForResult(chooseLockIntent, REQUEST_CHOOSE_LOCK);\n    }\n\n    @Override\n    public void onActivityResult(int requestCode, int resultCode, Intent data) {\n        super.onActivityResult(requestCode, resultCode, data);\n\n        if (requestCode == REQUEST_CHOOSE_LOCK) {\n            if (resultCode != Activity.RESULT_CANCELED && hasLockscreenSecurity()) {\n                addUserNow(USER_TYPE_RESTRICTED_PROFILE);\n            }\n        } else if (mGuestUserAutoCreated && requestCode == REQUEST_EDIT_GUEST\n                && resultCode == RESULT_GUEST_REMOVED) {\n            scheduleGuestCreation();\n        } else {\n            mEditUserInfoController.onActivityResult(requestCode, resultCode, data);\n        }\n    }\n\n    private void onAddUserClicked(int userType) {\n        synchronized (mUserLock) {\n            if (mRemovingUserId == -1 && !mAddingUser) {\n                switch (userType) {\n                    case USER_TYPE_USER:\n                        showDialog(DIALOG_ADD_USER);\n                        break;\n                    case USER_TYPE_RESTRICTED_PROFILE:\n                        if (hasLockscreenSecurity()) {\n                            showDialog(DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE);\n                        } else {\n                            showDialog(DIALOG_NEED_LOCKSCREEN);\n                        }\n                        break;\n                }\n            }\n        }\n    }\n\n    private void onRemoveUserClicked(int userId) {\n        synchronized (mUserLock) {\n            if (mRemovingUserId == -1 && !mAddingUser) {\n                mRemovingUserId = userId;\n                showDialog(DIALOG_CONFIRM_REMOVE);\n            }\n        }\n    }\n\n    private void onUserCreated(int userId) {\n        hideUserCreatingDialog();\n        // prevent crash when config changes during user creation\n        if (getContext() == null) {\n            return;\n        }\n        mAddingUser = false;\n        UserInfo userInfo = mUserManager.getUserInfo(userId);\n        openUserDetails(userInfo, true);\n    }\n\n    private void hideUserCreatingDialog() {\n        if (mUserCreatingDialog != null && mUserCreatingDialog.isShowing()) {\n            mUserCreatingDialog.dismiss();\n        }\n    }\n\n    private void onUserCreationFailed() {\n        Toast.makeText(getContext(),\n                com.android.settingslib.R.string.add_user_failed,\n                Toast.LENGTH_SHORT).show();\n        hideUserCreatingDialog();\n    }\n\n    private void openUserDetails(UserInfo userInfo, boolean newUser) {\n        Bundle extras = new Bundle();\n        extras.putInt(UserDetailsSettings.EXTRA_USER_ID, userInfo.id);\n        extras.putBoolean(AppRestrictionsFragment.EXTRA_NEW_USER, newUser);\n\n        final Context context = getContext();\n        SubSettingLauncher launcher = new SubSettingLauncher(context)\n                .setDestination(UserDetailsSettings.class.getName())\n                .setArguments(extras)\n                .setTitleText(getUserName(context, userInfo))\n                .setSourceMetricsCategory(getMetricsCategory());\n        if (mGuestUserAutoCreated && userInfo.isGuest()) {\n            launcher.setResultListener(this, REQUEST_EDIT_GUEST);\n        }\n        launcher.launch();\n    }\n\n    @Override\n    public void onDialogShowing() {\n        super.onDialogShowing();\n\n        setOnDismissListener(this);\n    }\n\n    @Override\n    public Dialog onCreateDialog(int dialogId) {\n        Context context = getActivity();\n        if (context == null) {\n            return null;\n        }\n        switch (dialogId) {\n            case DIALOG_CONFIRM_REMOVE: {\n                Dialog dlg =\n                        UserDialogs.createRemoveDialog(getActivity(), mRemovingUserId,\n                                new DialogInterface.OnClickListener() {\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        removeUserNow();\n                                    }\n                                }\n                        );\n                return dlg;\n            }\n            case DIALOG_USER_CANNOT_MANAGE:\n                return new AlertDialog.Builder(context)\n                        .setMessage(R.string.user_cannot_manage_message)\n                        .setPositiveButton(android.R.string.ok, null)\n                        .create();\n            case DIALOG_ADD_USER: {\n                final SharedPreferences preferences = getActivity().getPreferences(\n                        Context.MODE_PRIVATE);\n                final boolean longMessageDisplayed = preferences.getBoolean(\n                        KEY_ADD_USER_LONG_MESSAGE_DISPLAYED, false);\n                final int messageResId = longMessageDisplayed\n                        ? com.android.settingslib.R.string.user_add_user_message_short\n                        : com.android.settingslib.R.string.user_add_user_message_long;\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setTitle(com.android.settingslib.R.string.user_add_user_title)\n                        .setMessage(messageResId)\n                        .setPositiveButton(android.R.string.ok,\n                                new DialogInterface.OnClickListener() {\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        showDialog(DIALOG_USER_PROFILE_EDITOR_ADD_USER);\n                                        if (!longMessageDisplayed) {\n                                            preferences.edit().putBoolean(\n                                                    KEY_ADD_USER_LONG_MESSAGE_DISPLAYED,\n                                                    true).apply();\n                                        }\n                                    }\n                                })\n                        .setNegativeButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            case DIALOG_CHOOSE_USER_TYPE: {\n                List<HashMap<String, String>> data = new ArrayList<HashMap<String, String>>();\n                HashMap<String, String> addUserItem = new HashMap<String, String>();\n                addUserItem.put(KEY_TITLE, getString(\n                        com.android.settingslib.R.string.user_add_user_item_title));\n                addUserItem.put(KEY_SUMMARY, getString(\n                        com.android.settingslib.R.string.user_add_user_item_summary));\n                HashMap<String, String> addProfileItem = new HashMap<String, String>();\n                addProfileItem.put(KEY_TITLE, getString(\n                        com.android.settingslib.R.string.user_add_profile_item_title));\n                addProfileItem.put(KEY_SUMMARY, getString(\n                        com.android.settingslib.R.string.user_add_profile_item_summary));\n                data.add(addUserItem);\n                data.add(addProfileItem);\n                AlertDialog.Builder builder = new AlertDialog.Builder(context);\n                SimpleAdapter adapter = new SimpleAdapter(builder.getContext(),\n                        data, R.layout.two_line_list_item,\n                        new String[]{KEY_TITLE, KEY_SUMMARY},\n                        new int[]{R.id.title, R.id.summary});\n                builder.setTitle(com.android.settingslib.R.string.user_add_user_type_title);\n                builder.setAdapter(adapter,\n                        new DialogInterface.OnClickListener() {\n                            @Override\n                            public void onClick(DialogInterface dialog, int which) {\n                                onAddUserClicked(which == 0\n                                        ? USER_TYPE_USER\n                                        : USER_TYPE_RESTRICTED_PROFILE);\n                            }\n                        });\n                return builder.create();\n            }\n            case DIALOG_NEED_LOCKSCREEN: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setMessage(com.android.settingslib.R.string.user_need_lock_message)\n                        .setPositiveButton(com.android.settingslib.R.string.user_set_lock_button,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        launchChooseLockscreen();\n                                    }\n                                })\n                        .setNegativeButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            case DIALOG_CONFIRM_EXIT_GUEST: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setTitle(R.string.user_exit_guest_confirm_title)\n                        .setMessage(R.string.user_exit_guest_confirm_message)\n                        .setPositiveButton(R.string.user_exit_guest_dialog_remove,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        exitGuest();\n                                    }\n                                })\n                        .setNegativeButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            case DIALOG_USER_PROFILE_EDITOR: {\n                return buildEditCurrentUserDialog();\n            }\n            case DIALOG_USER_PROFILE_EDITOR_ADD_USER: {\n                synchronized (mUserLock) {\n                    mPendingUserName = getString(\n                            com.android.settingslib.R.string.user_new_user_name);\n                    mPendingUserIcon = null;\n                }\n                return buildAddUserDialog(USER_TYPE_USER);\n            }\n            case DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE: {\n                synchronized (mUserLock) {\n                    mPendingUserName = getString(\n                            com.android.settingslib.R.string.user_new_profile_name);\n                    mPendingUserIcon = null;\n                }\n                return buildAddUserDialog(USER_TYPE_RESTRICTED_PROFILE);\n            }\n            case DIALOG_CONFIRM_RESET_GUEST: {\n                return UserDialogs.createResetGuestDialog(getActivity(),\n                        (dialog, which) -> resetGuest());\n            }\n            default:\n                return null;\n        }\n    }\n\n    private Dialog buildEditCurrentUserDialog() {\n        final Activity activity = getActivity();\n        if (activity == null) {\n            return null;\n        }\n\n        UserInfo user = mUserManager.getUserInfo(Process.myUserHandle().getIdentifier());\n        Drawable userIcon = Utils.getUserIcon(activity, mUserManager, user);\n\n        return mEditUserInfoController.createDialog(\n                activity,\n                this::startActivityForResult,\n                userIcon,\n                user.name,\n                getString(com.android.settingslib.R.string.profile_info_settings_title),\n                (newUserName, newUserIcon) -> {\n                    if (newUserIcon != userIcon) {\n                        ThreadUtils.postOnBackgroundThread(() ->\n                                mUserManager.setUserIcon(user.id,\n                                        UserIcons.convertToBitmap(newUserIcon)));\n                        mMePreference.setIcon(newUserIcon);\n                    }\n\n                    if (!TextUtils.isEmpty(newUserName) && !newUserName.equals(user.name)) {\n                        mMePreference.setTitle(newUserName);\n                        mUserManager.setUserName(user.id, newUserName);\n                    }\n                }, null);\n    }\n\n    private Dialog buildAddUserDialog(int userType) {\n        Dialog d;\n        synchronized (mUserLock) {\n            d = mEditUserInfoController.createDialog(\n                    getActivity(),\n                    this::startActivityForResult,\n                    null,\n                    mPendingUserName.toString(),\n                    getString(userType == USER_TYPE_USER\n                            ? com.android.settingslib.R.string.user_info_settings_title\n                            : com.android.settingslib.R.string.profile_info_settings_title),\n                    (userName, userIcon) -> {\n                        mPendingUserIcon = userIcon;\n                        mPendingUserName = userName;\n                        addUserNow(userType);\n                    },\n                    () -> {\n                        synchronized (mUserLock) {\n                            mPendingUserIcon = null;\n                            mPendingUserName = null;\n                        }\n                    }\n            );\n        }\n        return d;\n    }\n\n    @Override\n    public int getDialogMetricsCategory(int dialogId) {\n        switch (dialogId) {\n            case DIALOG_CONFIRM_REMOVE:\n                return SettingsEnums.DIALOG_USER_REMOVE;\n            case DIALOG_USER_CANNOT_MANAGE:\n                return SettingsEnums.DIALOG_USER_CANNOT_MANAGE;\n            case DIALOG_ADD_USER:\n                return SettingsEnums.DIALOG_USER_ADD;\n            case DIALOG_CHOOSE_USER_TYPE:\n                return SettingsEnums.DIALOG_USER_CHOOSE_TYPE;\n            case DIALOG_NEED_LOCKSCREEN:\n                return SettingsEnums.DIALOG_USER_NEED_LOCKSCREEN;\n            case DIALOG_CONFIRM_EXIT_GUEST:\n            case DIALOG_CONFIRM_RESET_GUEST:\n                return SettingsEnums.DIALOG_USER_CONFIRM_EXIT_GUEST;\n            case DIALOG_USER_PROFILE_EDITOR:\n            case DIALOG_USER_PROFILE_EDITOR_ADD_USER:\n            case DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE:\n                return SettingsEnums.DIALOG_USER_EDIT_PROFILE;\n            default:\n                return 0;\n        }\n    }\n\n    private void removeUserNow() {\n        if (mRemovingUserId == UserHandle.myUserId()) {\n            removeThisUser();\n        } else {\n            ThreadUtils.postOnBackgroundThread(new Runnable() {\n                @Override\n                public void run() {\n                    synchronized (mUserLock) {\n                        mUserManager.removeUser(mRemovingUserId);\n                        mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n                    }\n                }\n            });\n        }\n    }\n\n    private void removeThisUser() {\n        if (!canSwitchUserNow()) {\n            Log.w(TAG, \"Cannot remove current user when switching is disabled\");\n            return;\n        }\n        try {\n            getContext().getSystemService(UserManager.class)\n                    .removeUserOrSetEphemeral(UserHandle.myUserId(),\n                            /* evenWhenDisallowed= */ false);\n            ActivityManager.getService().switchUser(UserHandle.USER_SYSTEM);\n        } catch (RemoteException re) {\n            Log.e(TAG, \"Unable to remove self user\");\n        }\n    }\n\n    private void addUserNow(final int userType) {\n        synchronized (mUserLock) {\n            mAddingUser = true;\n            mAddingUserName = userType == USER_TYPE_USER\n                    ? (mPendingUserName != null ? mPendingUserName.toString()\n                    : getString(R.string.user_new_user_name))\n                    : (mPendingUserName != null ? mPendingUserName.toString()\n                            : getString(R.string.user_new_profile_name));\n        }\n\n        mUserCreatingDialog = new UserCreatingDialog(getActivity());\n        mUserCreatingDialog.show();\n        ThreadUtils.postOnBackgroundThread(new Runnable() {\n            @Override\n            public void run() {\n                UserInfo user;\n                String username;\n\n                synchronized (mUserLock) {\n                    username = mAddingUserName;\n                }\n\n                // Could take a few seconds\n                if (userType == USER_TYPE_USER) {\n                    user = mUserManager.createUser(username, 0);\n                } else {\n                    user = mUserManager.createRestrictedProfile(username);\n                }\n\n                synchronized (mUserLock) {\n                    if (user == null) {\n                        mAddingUser = false;\n                        mPendingUserIcon = null;\n                        mPendingUserName = null;\n                        ThreadUtils.postOnMainThread(() -> onUserCreationFailed());\n                        return;\n                    }\n\n                    Drawable newUserIcon = mPendingUserIcon;\n                    if (newUserIcon == null) {\n                        newUserIcon = UserIcons.getDefaultUserIcon(getResources(), user.id, false);\n                    }\n                    mUserManager.setUserIcon(user.id, UserIcons.convertToBitmap(newUserIcon));\n\n                    if (userType == USER_TYPE_USER) {\n                        mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n                    }\n\n                    mHandler.sendMessage(mHandler.obtainMessage(\n                            MESSAGE_USER_CREATED, user.id, user.serialNumber));\n\n                    mPendingUserIcon = null;\n                    mPendingUserName = null;\n                }\n            }\n        });\n    }\n\n    /**\n     * Erase the current user (guest) and switch to another user.\n     */\n    @VisibleForTesting\n    void exitGuest() {\n        // Just to be safe\n        if (!isCurrentUserGuest()) {\n            return;\n        }\n        mMetricsFeatureProvider.action(getActivity(),\n                SettingsEnums.ACTION_USER_GUEST_EXIT_CONFIRMED);\n        removeThisUser();\n    }\n\n    /**\n     * Erase the current user (assuming it is a guest user), and create a new one in the background\n     */\n    @VisibleForTesting\n    void resetGuest() {\n        // Just to be safe\n        if (!isCurrentUserGuest()) {\n            return;\n        }\n        int guestUserId = UserHandle.myUserId();\n        // Using markGuestForDeletion allows us to create a new guest before this one is\n        // fully removed. This could happen if someone calls scheduleGuestCreation()\n        // immediately after calling this method.\n        boolean marked = mUserManager.markGuestForDeletion(guestUserId);\n        if (!marked) {\n            Log.w(TAG, \"Couldn't mark the guest for deletion for user \" + guestUserId);\n            return;\n        }\n        exitGuest();\n        scheduleGuestCreation();\n    }\n\n    /**\n     * Create a guest user in the background\n     */\n    @VisibleForTesting\n    void scheduleGuestCreation() {\n        // TODO(b/191067027): Move guest recreation to system_server\n        if (mGuestCreationScheduled.compareAndSet(/* expect= */ false, /* update= */ true)) {\n            // Once mGuestCreationScheduled=true, mAddGuest needs to be updated so that it shows\n            // \"Resetting guest...\"\n            mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n            mExecutor.execute(() -> {\n                UserInfo guest = mUserManager.createGuest(\n                        getContext(), getString(com.android.settingslib.R.string.user_guest));\n                mGuestCreationScheduled.set(false);\n                if (guest == null) {\n                    Log.e(TAG, \"Unable to automatically recreate guest user\");\n                }\n                // The list needs to be updated whether or not guest creation worked. If guest\n                // creation failed, the list needs to update so that \"Add guest\" is displayed.\n                // Otherwise, the UX could be stuck in a state where there is no way to switch to\n                // the guest user (e.g. Guest would not be selectable, and it would be stuck\n                // saying \"Resetting guest...\")\n                mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n            });\n        }\n    }\n\n    @VisibleForTesting\n    void updateUserList() {\n        final Context context = getActivity();\n        if (context == null) {\n            return;\n        }\n        final List<UserInfo> users = mUserManager.getAliveUsers();\n\n        final ArrayList<Integer> missingIcons = new ArrayList<>();\n        final ArrayList<UserPreference> userPreferences = new ArrayList<>();\n        userPreferences.add(mMePreference);\n\n        boolean canOpenUserDetails =\n                mUserCaps.mIsAdmin || (canSwitchUserNow() && !mUserCaps.mDisallowSwitchUser);\n        for (UserInfo user : users) {\n            if (!user.supportsSwitchToByUser()) {\n                // Only users that can be switched to should show up here.\n                // e.g. Managed profiles appear under Accounts Settings instead\n                continue;\n            }\n            UserPreference pref;\n            if (user.id == UserHandle.myUserId()) {\n                pref = mMePreference;\n            } else {\n                final Context prefContext = getPrefContext();\n                pref = new UserPreference(prefContext, null, user.id);\n                pref.setTitle(getUserName(prefContext, user));\n                userPreferences.add(pref);\n                pref.setOnPreferenceClickListener(this);\n                pref.setEnabled(canOpenUserDetails);\n                pref.setSelectable(true);\n\n                if (user.isGuest()) {\n                    pref.setIcon(getEncircledDefaultIcon());\n                    pref.setKey(KEY_USER_GUEST);\n                    if (mUserCaps.mDisallowSwitchUser) {\n                        pref.setDisabledByAdmin(\n                                RestrictedLockUtilsInternal.getDeviceOwner(context));\n                    } else {\n                        pref.setDisabledByAdmin(null);\n                    }\n                } else {\n                    pref.setKey(\"id=\" + user.id);\n                    if (user.isAdmin()) {\n                        pref.setSummary(R.string.user_admin);\n                    }\n                }\n            }\n            if (pref == null) {\n                continue;\n            }\n            if (user.id != UserHandle.myUserId() && !user.isGuest() && !user.isInitialized()) {\n                // sometimes after creating a guest the initialized flag isn't immediately set\n                // and we don't want to show \"Not set up\" summary for them\n                if (user.isRestricted()) {\n                    pref.setSummary(R.string.user_summary_restricted_not_set_up);\n                } else {\n                    pref.setSummary(R.string.user_summary_not_set_up);\n                    // Disallow setting up user which results in user switching when the\n                    // restriction is set.\n                    pref.setEnabled(!mUserCaps.mDisallowSwitchUser && canSwitchUserNow());\n                }\n            } else if (user.isRestricted()) {\n                pref.setSummary(R.string.user_summary_restricted_profile);\n            }\n            if (user.iconPath != null) {\n                if (mUserIcons.get(user.id) == null) {\n                    // Icon not loaded yet, print a placeholder\n                    missingIcons.add(user.id);\n                    pref.setIcon(getEncircledDefaultIcon());\n                } else {\n                    setPhotoId(pref, user);\n                }\n            } else {\n                // Icon not available yet, print a placeholder\n                pref.setIcon(getEncircledDefaultIcon());\n            }\n        }\n\n        // Add a temporary entry for the user being created\n        if (mAddingUser) {\n            UserPreference pref = new UserPreference(getPrefContext(), null,\n                    UserPreference.USERID_UNKNOWN);\n            pref.setEnabled(false);\n            pref.setTitle(mAddingUserName);\n            pref.setIcon(getEncircledDefaultIcon());\n            userPreferences.add(pref);\n        }\n\n\n        // Sort list of users by serialNum\n        Collections.sort(userPreferences, UserPreference.SERIAL_NUMBER_COMPARATOR);\n\n        getActivity().invalidateOptionsMenu();\n\n        // Load the icons\n        if (missingIcons.size() > 0) {\n            loadIconsAsync(missingIcons);\n        }\n\n        // If profiles are supported, mUserListCategory will have a special title\n        if (mUserCaps.mCanAddRestrictedProfile) {\n            mUserListCategory.setTitle(R.string.user_list_title);\n        } else {\n            mUserListCategory.setTitle(null);\n        }\n\n        // Remove everything from mUserListCategory and add new users.\n        mUserListCategory.removeAll();\n\n        // If multi-user is disabled, just show top info and return.\n        final Preference addUserOnLockScreen = getPreferenceScreen().findPreference(\n                mAddUserWhenLockedPreferenceController.getPreferenceKey());\n        mAddUserWhenLockedPreferenceController.updateState(addUserOnLockScreen);\n\n        final Preference multiUserTopIntroPrefence = getPreferenceScreen().findPreference(\n                mMultiUserTopIntroPreferenceController.getPreferenceKey());\n        mMultiUserTopIntroPreferenceController.updateState(multiUserTopIntroPrefence);\n        mUserListCategory.setVisible(mUserCaps.mUserSwitcherEnabled);\n\n        updateAddGuest(context, users.stream().anyMatch(UserInfo::isGuest));\n        updateAddUser(context);\n\n        if (!mUserCaps.mUserSwitcherEnabled) {\n            return;\n        }\n\n        for (UserPreference userPreference : userPreferences) {\n            userPreference.setOrder(Preference.DEFAULT_ORDER);\n            mUserListCategory.addPreference(userPreference);\n        }\n\n    }\n\n    private boolean isCurrentUserGuest() {\n        return mUserCaps.mIsGuest;\n    }\n\n    private boolean canSwitchUserNow() {\n        return mUserManager.getUserSwitchability() == UserManager.SWITCHABILITY_STATUS_OK;\n    }\n\n    private void updateAddGuest(Context context, boolean isGuestAlreadyCreated) {\n        if (!isGuestAlreadyCreated && mUserCaps.mCanAddGuest\n                && WizardManagerHelper.isDeviceProvisioned(context)\n                && mUserCaps.mUserSwitcherEnabled) {\n            mAddGuest.setVisible(true);\n            mAddGuest.setIcon(getEncircledDefaultIcon());\n            mAddGuest.setSelectable(true);\n            if (mGuestUserAutoCreated && mGuestCreationScheduled.get()) {\n                mAddGuest.setTitle(com.android.settingslib.R.string.user_guest);\n                mAddGuest.setSummary(R.string.guest_resetting);\n                mAddGuest.setEnabled(false);\n            } else {\n                mAddGuest.setTitle(com.android.settingslib.R.string.guest_new_guest);\n                mAddGuest.setEnabled(canSwitchUserNow());\n            }\n        } else {\n            mAddGuest.setVisible(false);\n        }\n    }\n\n    private void updateAddUser(Context context) {\n        if ((mUserCaps.mCanAddUser || mUserCaps.mDisallowAddUserSetByAdmin)\n                && WizardManagerHelper.isDeviceProvisioned(context)\n                && mUserCaps.mUserSwitcherEnabled) {\n            mAddUser.setVisible(true);\n            mAddUser.setSelectable(true);\n            final boolean canAddMoreUsers = mUserManager.canAddMoreUsers();\n            mAddUser.setEnabled(canAddMoreUsers && !mAddingUser && canSwitchUserNow());\n            if (!canAddMoreUsers) {\n                mAddUser.setSummary(\n                        getString(R.string.user_add_max_count, getRealUsersCount()));\n            } else {\n                mAddUser.setSummary(null);\n            }\n            if (mAddUser.isEnabled()) {\n                mAddUser.setDisabledByAdmin(\n                        mUserCaps.mDisallowAddUser ? mUserCaps.mEnforcedAdmin : null);\n            }\n        } else {\n            mAddUser.setVisible(false);\n        }\n    }\n\n    /**\n     * @return number of non-guest non-managed users\n     */\n    @VisibleForTesting\n    int getRealUsersCount() {\n        return (int) mUserManager.getUsers()\n                .stream()\n                .filter(user -> !user.isGuest() && !user.isProfile())\n                .count();\n    }\n\n    private void loadIconsAsync(List<Integer> missingIcons) {\n        new AsyncTask<List<Integer>, Void, Void>() {\n            @Override\n            protected void onPostExecute(Void result) {\n                updateUserList();\n            }\n\n            @Override\n            protected Void doInBackground(List<Integer>... values) {\n                for (int userId : values[0]) {\n                    Bitmap bitmap = mUserManager.getUserIcon(userId);\n                    if (bitmap == null) {\n                        bitmap = getDefaultUserIconAsBitmap(getContext().getResources(), userId);\n                    }\n                    mUserIcons.append(userId, bitmap);\n                }\n                return null;\n            }\n        }.execute(missingIcons);\n    }\n\n    private Drawable getEncircledDefaultIcon() {\n        if (mDefaultIconDrawable == null) {\n            mDefaultIconDrawable = encircle(\n                    getDefaultUserIconAsBitmap(getContext().getResources(), UserHandle.USER_NULL));\n        }\n        return mDefaultIconDrawable;\n    }\n\n    private void setPhotoId(Preference pref, UserInfo user) {\n        Bitmap bitmap = mUserIcons.get(user.id);\n        if (bitmap != null) {\n            pref.setIcon(encircle(bitmap));\n        }\n    }\n\n    /** Returns the user's name, or the appropriate string in the case of a Guest. */\n    public static String getUserName(Context context, @NonNull UserInfo userInfo) {\n        if (userInfo.isGuest()) {\n            return context.getString(R.string.user_guest);\n        }\n        return userInfo.name;\n    }\n\n    @Override\n    public boolean onPreferenceClick(Preference pref) {\n        if (pref == mMePreference) {\n            if (isCurrentUserGuest()) {\n                if (mGuestUserAutoCreated) {\n                    showDialog(DIALOG_CONFIRM_RESET_GUEST);\n                } else {\n                    showDialog(DIALOG_CONFIRM_EXIT_GUEST);\n                }\n            } else {\n                showDialog(DIALOG_USER_PROFILE_EDITOR);\n            }\n            return true;\n        } else if (pref instanceof UserPreference) {\n            UserInfo userInfo = mUserManager.getUserInfo(((UserPreference) pref).getUserId());\n            openUserDetails(userInfo, false);\n            return true;\n        } else if (pref == mAddUser) {\n            // If we allow both types, show a picker, otherwise directly go to\n            // flow for full user.\n            if (mUserCaps.mCanAddRestrictedProfile) {\n                showDialog(DIALOG_CHOOSE_USER_TYPE);\n            } else {\n                onAddUserClicked(USER_TYPE_USER);\n            }\n            return true;\n        } else if (pref == mAddGuest) {\n            mAddGuest.setEnabled(false); // prevent multiple tap issue\n            mMetricsFeatureProvider.action(getActivity(), SettingsEnums.ACTION_USER_GUEST_ADD);\n            UserInfo guest = mUserManager.createGuest(\n                    getContext(), getString(com.android.settingslib.R.string.user_guest));\n            if (guest == null) {\n                Toast.makeText(getContext(),\n                        com.android.settingslib.R.string.add_user_failed,\n                        Toast.LENGTH_SHORT).show();\n                return true;\n            }\n            openUserDetails(guest, true);\n            return true;\n        }\n        return false;\n    }\n\n    private Drawable encircle(Bitmap icon) {\n        Drawable circled = CircleFramedDrawable.getInstance(getActivity(), icon);\n        return circled;\n    }\n\n    @Override\n    public void onDismiss(DialogInterface dialog) {\n        synchronized (mUserLock) {\n            mRemovingUserId = -1;\n            updateUserList();\n        }\n    }\n\n    @Override\n    public int getHelpResource() {\n        return R.string.help_url_users;\n    }\n\n    /**\n     * Returns a default user icon (as a {@link Bitmap}) for the given user.\n     *\n     * Note that for guest users, you should pass in {@code UserHandle.USER_NULL}.\n     *\n     * @param resources resources object to fetch the user icon.\n     * @param userId    the user id or {@code UserHandle.USER_NULL} for a non-user specific icon\n     */\n    private static Bitmap getDefaultUserIconAsBitmap(Resources resources, int userId) {\n        Bitmap bitmap = null;\n        // Try finding the corresponding bitmap in the dark bitmap cache\n        bitmap = sDarkDefaultUserBitmapCache.get(userId);\n        if (bitmap == null) {\n            bitmap = UserIcons.convertToBitmap(\n                    UserIcons.getDefaultUserIcon(resources, userId, false));\n            // Save it to cache\n            sDarkDefaultUserBitmapCache.put(userId, bitmap);\n        }\n        return bitmap;\n    }\n\n    /**\n     * Assign the default photo to user with {@paramref userId}\n     *\n     * @param context used to get the {@link UserManager}\n     * @param userId  used to get the icon bitmap\n     * @return true if assign photo successfully, false if failed\n     */\n    @VisibleForTesting\n    static boolean assignDefaultPhoto(Context context, int userId) {\n        if (context == null) {\n            return false;\n        }\n        UserManager um = (UserManager) context.getSystemService(Context.USER_SERVICE);\n        Bitmap bitmap = getDefaultUserIconAsBitmap(context.getResources(), userId);\n        um.setUserIcon(userId, bitmap);\n\n        return true;\n    }\n\n    @WorkerThread\n    static void copyMeProfilePhoto(Context context, UserInfo user) {\n        Uri contactUri = ContactsContract.Profile.CONTENT_URI;\n\n        int userId = user != null ? user.id : UserHandle.myUserId();\n\n        InputStream avatarDataStream = ContactsContract.Contacts.openContactPhotoInputStream(\n                context.getContentResolver(),\n                contactUri, true);\n        // If there's no profile photo, assign a default avatar\n        if (avatarDataStream == null) {\n            assignDefaultPhoto(context, userId);\n            return;\n        }\n\n        UserManager um = (UserManager) context.getSystemService(Context.USER_SERVICE);\n        Bitmap icon = BitmapFactory.decodeStream(avatarDataStream);\n        um.setUserIcon(userId, icon);\n        try {\n            avatarDataStream.close();\n        } catch (IOException ioe) {\n        }\n    }\n\n    public static final BaseSearchIndexProvider SEARCH_INDEX_DATA_PROVIDER =\n            new BaseSearchIndexProvider(R.xml.user_settings) {\n\n                @Override\n                protected boolean isPageSearchEnabled(Context context) {\n                    final UserCapabilities userCaps = UserCapabilities.create(context);\n                    return userCaps.mEnabled;\n                }\n\n                @Override\n                public List<String> getNonIndexableKeysFromXml(Context context, int xmlResId,\n                        boolean suppressAllPage) {\n                    final List<String> niks = super.getNonIndexableKeysFromXml(context, xmlResId,\n                            suppressAllPage);\n                    AddUserWhenLockedPreferenceController controller =\n                            new AddUserWhenLockedPreferenceController(\n                                    context, KEY_ADD_USER_WHEN_LOCKED);\n                    controller.updateNonIndexableKeys(niks);\n                    new AutoSyncDataPreferenceController(context, null /* parent */)\n                            .updateNonIndexableKeys(niks);\n                    new AutoSyncPersonalDataPreferenceController(context, null /* parent */)\n                            .updateNonIndexableKeys(niks);\n                    new AutoSyncWorkDataPreferenceController(context, null /* parent */)\n                            .updateNonIndexableKeys(niks);\n                    return niks;\n                }\n            };\n}\n```"
                    }
                ]
            },
            {
                "downstream_version": "13",
                "branch_used": "android13-release",
                "downstream_patch": "31e69deb2809887b5ea7b8b7a7893d7db90acdd2",
                "repo_path": "android_repos/Settings",
                "result": "failure",
                "downstream_patch_content": "commit 31e69deb2809887b5ea7b8b7a7893d7db90acdd2\nAuthor: Adam Bookatz <bookatz@google.com>\nDate:   Mon Nov 18 15:53:41 2024 -0800\n\n    Don't let profiles open the UserSettings overflow [DO NOT MERGE]\n    \n    Really, profiles aren't expected to open Settings at all. But if they\n    do somehow, the overflow shouldn't appear.\n    \n    Bug: 352542820\n    Flag: EXEMPT bugfix\n    Test: Try to access the overflow of the work profile by launching its Settings in\n    adb shell am start --user 10 'com.android.settings/.Settings\\$UserSettingsActivity'\n    \n    Change-Id: I5e4c095cda3e19fa5c63c2c550a526f5da8ec5c1\n    Merged-In: I5e4c095cda3e19fa5c63c2c550a526f5da8ec5c1\n    (cherry picked from commit 69c7f5dac580361792bbb189178653b297d06c8a)\n\ndiff --git a/src/com/android/settings/users/UserSettings.java b/src/com/android/settings/users/UserSettings.java\nindex 5ee95ddc45a..a1806fe4770 100644\n--- a/src/com/android/settings/users/UserSettings.java\n+++ b/src/com/android/settings/users/UserSettings.java\n@@ -380,8 +380,8 @@ public class UserSettings extends SettingsPreferenceFragment\n         int pos = 0;\n         // TODO(b/191509236): The menu item does not need to be accessible for guest users,\n         //  regardless of mGuestUserAutoCreated\n-        if (!mUserCaps.mIsAdmin && canSwitchUserNow() && !(isCurrentUserGuest()\n-                && mGuestUserAutoCreated)) {\n+        if (!mUserCaps.mIsAdmin && canSwitchUserNow() && !mUserManager.isProfile()\n+                && !(isCurrentUserGuest() && mGuestUserAutoCreated)) {\n             String nickname = mUserManager.getUserName();\n             MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                     getResources().getString(R.string.user_remove_user_menu, nickname));\n",
                "file_conflicts": [
                    {
                        "file_name": "src/com/android/settings/users/UserSettings.java",
                        "total_hunks": 1,
                        "failed_hunks": [
                            1
                        ],
                        "inline_merge_conflicts": [],
                        "rej_file_content": "```diff\n--- src/com/android/settings/users/UserSettings.java\n+++ src/com/android/settings/users/UserSettings.java\n@@ -465,7 +465,7 @@ public class UserSettings extends SettingsPreferenceFragment\n     public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n         int pos = 0;\n         if (!isCurrentUserAdmin() && (canSwitchUserNow() || Flags.newMultiuserSettingsUx())\n-                && !isCurrentUserGuest()) {\n+                && !isCurrentUserGuest() && !mUserManager.isProfile()) {\n             String nickname = mUserManager.getUserName();\n             MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                     getResources().getString(R.string.user_remove_user_menu, nickname));\n```",
                        "patch_apply_output": "patching file src/com/android/settings/users/UserSettings.java\nHunk #1 FAILED at 465.\n1 out of 1 hunk FAILED -- saving rejects to file src/com/android/settings/users/UserSettings.java.rej",
                        "inline_merge_output": "patching file src/com/android/settings/users/UserSettings.java\nHunk #1 already applied at 468.",
                        "upstream_file_content": "```java\n/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.settings.users;\n\nimport static com.android.settingslib.Utils.getColorAttrDefaultColor;\n\nimport android.app.Activity;\nimport android.app.ActivityManager;\nimport android.app.Dialog;\nimport android.app.admin.DevicePolicyManager;\nimport android.app.settings.SettingsEnums;\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.pm.UserInfo;\nimport android.content.res.Resources;\nimport android.graphics.Bitmap;\nimport android.graphics.BitmapFactory;\nimport android.graphics.BlendMode;\nimport android.graphics.drawable.Drawable;\nimport android.graphics.drawable.LayerDrawable;\nimport android.multiuser.Flags;\nimport android.net.Uri;\nimport android.os.AsyncTask;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.Message;\nimport android.os.Process;\nimport android.os.RemoteException;\nimport android.os.Trace;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.provider.ContactsContract;\nimport android.provider.Settings;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.util.SparseArray;\nimport android.view.Gravity;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.WindowManagerGlobal;\nimport android.widget.SimpleAdapter;\nimport android.widget.Toast;\n\nimport androidx.annotation.VisibleForTesting;\nimport androidx.annotation.WorkerThread;\nimport androidx.appcompat.app.AlertDialog;\nimport androidx.preference.Preference;\nimport androidx.preference.PreferenceGroup;\nimport androidx.preference.PreferenceScreen;\n\nimport com.android.internal.util.UserIcons;\nimport com.android.internal.widget.LockPatternUtils;\nimport com.android.settings.R;\nimport com.android.settings.SettingsActivity;\nimport com.android.settings.SettingsPreferenceFragment;\nimport com.android.settings.Utils;\nimport com.android.settings.core.SubSettingLauncher;\nimport com.android.settings.password.ChooseLockGeneric;\nimport com.android.settings.search.BaseSearchIndexProvider;\nimport com.android.settings.widget.MainSwitchBarController;\nimport com.android.settings.widget.SettingsMainSwitchBar;\nimport com.android.settingslib.RestrictedLockUtils.EnforcedAdmin;\nimport com.android.settingslib.RestrictedLockUtilsInternal;\nimport com.android.settingslib.RestrictedPreference;\nimport com.android.settingslib.drawable.CircleFramedDrawable;\nimport com.android.settingslib.search.SearchIndexable;\nimport com.android.settingslib.search.SearchIndexableRaw;\nimport com.android.settingslib.users.CreateUserDialogController;\nimport com.android.settingslib.users.EditUserInfoController;\nimport com.android.settingslib.users.GrantAdminDialogController;\nimport com.android.settingslib.users.UserCreatingDialog;\nimport com.android.settingslib.utils.ThreadUtils;\n\nimport com.google.android.setupcompat.util.WizardManagerHelper;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.stream.Collectors;\n\n/**\n * Screen that manages the list of users on the device.\n * Secondary users and a guest user can be created if there is no restriction.\n *\n * The first user in the list is always the current user.\n * Owner is the primary user.\n */\n@SearchIndexable\npublic class UserSettings extends SettingsPreferenceFragment\n        implements Preference.OnPreferenceClickListener,\n        MultiUserSwitchBarController.OnMultiUserSwitchChangedListener,\n        DialogInterface.OnDismissListener {\n\n    private static final String TAG = \"UserSettings\";\n\n    /** UserId of the user being removed */\n    private static final String SAVE_REMOVING_USER = \"removing_user\";\n    private static final String SAVE_CREATE_USER = \"create_user\";\n\n    private static final String KEY_USER_LIST = \"user_list\";\n    private static final String KEY_USER_ME = \"user_me\";\n    private static final String KEY_USER_GUEST = \"user_guest\";\n    private static final String KEY_ADD_GUEST = \"guest_add\";\n    private static final String KEY_ADD_USER = \"user_add\";\n    private static final String KEY_ADD_SUPERVISED_USER = \"supervised_user_add\";\n    private static final String KEY_ADD_USER_WHEN_LOCKED = \"user_settings_add_users_when_locked\";\n    private static final String KEY_ENABLE_GUEST_TELEPHONY = \"enable_guest_calling\";\n    private static final String KEY_MULTIUSER_TOP_INTRO = \"multiuser_top_intro\";\n    private static final String KEY_TIMEOUT_TO_DOCK_USER = \"timeout_to_dock_user_preference\";\n    private static final String KEY_GUEST_CATEGORY = \"guest_category\";\n    private static final String KEY_GUEST_RESET = \"guest_reset\";\n    private static final String KEY_GUEST_EXIT = \"guest_exit\";\n    private static final String KEY_REMOVE_GUEST_ON_EXIT = \"remove_guest_on_exit\";\n    private static final String KEY_GUEST_USER_CATEGORY = \"guest_user_category\";\n    private static final String KEY_ALLOW_MULTIPLE_USERS = \"allow_multiple_users\";\n    private static final String KEY_USER_SETTINGS_SCREEN = \"user_settings_screen\";\n\n    private static final String SETTING_GUEST_HAS_LOGGED_IN = \"systemui.guest_has_logged_in\";\n\n    private static final int MENU_REMOVE_USER = Menu.FIRST;\n\n    private static final IntentFilter USER_REMOVED_INTENT_FILTER;\n\n    private static final int DIALOG_CONFIRM_REMOVE = 1;\n    private static final int DIALOG_ADD_USER = 2;\n    // Dialogs with id 3 and 4 got removed\n    private static final int DIALOG_USER_CANNOT_MANAGE = 5;\n    private static final int DIALOG_CHOOSE_USER_TYPE = 6;\n    private static final int DIALOG_NEED_LOCKSCREEN = 7;\n    private static final int DIALOG_CONFIRM_REMOVE_GUEST = 8;\n    private static final int DIALOG_USER_PROFILE_EDITOR = 9;\n    private static final int DIALOG_USER_PROFILE_EDITOR_ADD_USER = 10;\n    private static final int DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE = 11;\n    private static final int DIALOG_CONFIRM_REMOVE_GUEST_WITH_AUTO_CREATE = 12;\n    private static final int DIALOG_CONFIRM_RESET_AND_RESTART_GUEST = 13;\n    private static final int DIALOG_CONFIRM_EXIT_GUEST_EPHEMERAL = 14;\n    private static final int DIALOG_CONFIRM_EXIT_GUEST_NON_EPHEMERAL = 15;\n    private static final int DIALOG_GRANT_ADMIN = 16;\n\n    private static final int MESSAGE_UPDATE_LIST = 1;\n    private static final int MESSAGE_USER_CREATED = 2;\n    static final int MESSAGE_REMOVE_GUEST_ON_EXIT_CONTROLLER_GUEST_REMOVED = 3;\n\n    private static final int USER_TYPE_USER = 1;\n    private static final int USER_TYPE_RESTRICTED_PROFILE = 2;\n\n    private static final int REQUEST_CHOOSE_LOCK = 10;\n    private static final int REQUEST_EDIT_GUEST = 11;\n\n    static final int RESULT_GUEST_REMOVED = 100;\n\n    private static final String KEY_TITLE = \"title\";\n    private static final String KEY_SUMMARY = \"summary\";\n\n    private static final String EXTRA_OPEN_DIALOG_USER_PROFILE_EDITOR =\n            \"EXTRA_OPEN_DIALOG_USER_PROFILE_EDITOR\";\n\n    static {\n        USER_REMOVED_INTENT_FILTER = new IntentFilter(Intent.ACTION_USER_REMOVED);\n        USER_REMOVED_INTENT_FILTER.addAction(Intent.ACTION_USER_INFO_CHANGED);\n    }\n\n    @VisibleForTesting\n    PreferenceGroup mUserListCategory;\n    @VisibleForTesting\n    PreferenceGroup mGuestUserCategory;\n    @VisibleForTesting\n    PreferenceGroup mGuestCategory;\n    @VisibleForTesting\n    Preference mGuestResetPreference;\n    @VisibleForTesting\n    Preference mGuestExitPreference;\n    @VisibleForTesting\n    UserPreference mMePreference;\n    @VisibleForTesting\n    RestrictedPreference mAddGuest;\n    @VisibleForTesting\n    RestrictedPreference mAddUser;\n    @VisibleForTesting\n    RestrictedPreference mAddSupervisedUser;\n    @VisibleForTesting\n    SparseArray<Bitmap> mUserIcons = new SparseArray<>();\n    private int mRemovingUserId = -1;\n    private boolean mAddingUser;\n    private boolean mGuestUserAutoCreated;\n    private String mConfigSupervisedUserCreationPackage;\n    private String mAddingUserName;\n    private UserCapabilities mUserCaps;\n    private boolean mShouldUpdateUserList = true;\n    private final Object mUserLock = new Object();\n    private UserManager mUserManager;\n    private static SparseArray<Bitmap> sDarkDefaultUserBitmapCache = new SparseArray<>();\n\n    private MultiUserSwitchBarController mSwitchBarController;\n\n    private GrantAdminDialogController mGrantAdminDialogController =\n            new GrantAdminDialogController();\n    private EditUserInfoController mEditUserInfoController =\n            new EditUserInfoController(Utils.FILE_PROVIDER_AUTHORITY);\n    private CreateUserDialogController mCreateUserDialogController =\n            new CreateUserDialogController(Utils.FILE_PROVIDER_AUTHORITY);\n    private AddUserWhenLockedPreferenceController mAddUserWhenLockedPreferenceController;\n    private GuestTelephonyPreferenceController mGuestTelephonyPreferenceController;\n    private RemoveGuestOnExitPreferenceController mRemoveGuestOnExitPreferenceController;\n    private MultiUserTopIntroPreferenceController mMultiUserTopIntroPreferenceController;\n    private TimeoutToDockUserPreferenceController mTimeoutToDockUserPreferenceController;\n    private UserCreatingDialog mUserCreatingDialog;\n    private final AtomicBoolean mGuestCreationScheduled = new AtomicBoolean();\n    private final ExecutorService mExecutor = Executors.newSingleThreadExecutor();\n\n    private CharSequence mPendingUserName;\n    private Drawable mPendingUserIcon;\n    private boolean mPendingUserIsAdmin;\n\n    // A place to cache the generated default avatar\n    private Drawable mDefaultIconDrawable;\n\n    // TODO:   Replace current Handler solution to something that doesn't leak memory and works\n    // TODO:   during a configuration change\n    private Handler mHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MESSAGE_UPDATE_LIST:\n                    updateUserList();\n                    break;\n                case MESSAGE_REMOVE_GUEST_ON_EXIT_CONTROLLER_GUEST_REMOVED:\n                    updateUserList();\n                    if (mGuestUserAutoCreated) {\n                        scheduleGuestCreation();\n                    }\n                    break;\n            }\n        }\n    };\n\n    private BroadcastReceiver mUserChangeReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            if (intent.getAction().equals(Intent.ACTION_USER_REMOVED)) {\n                mRemovingUserId = -1;\n            } else if (intent.getAction().equals(Intent.ACTION_USER_INFO_CHANGED)) {\n                int userHandle = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, -1);\n                if (userHandle != -1) {\n                    mUserIcons.remove(userHandle);\n                }\n            }\n            mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n        }\n    };\n\n    @Override\n    public int getMetricsCategory() {\n        return SettingsEnums.USER;\n    }\n\n    @Override\n    public void onActivityCreated(Bundle savedInstanceState) {\n        super.onActivityCreated(savedInstanceState);\n        // Assume we are in a SettingsActivity. This is only safe because we currently use\n        // SettingsActivity as base for all preference fragments.\n        final SettingsActivity activity = (SettingsActivity) getActivity();\n        final SettingsMainSwitchBar switchBar = activity.getSwitchBar();\n        switchBar.setTitle(getContext().getString(R.string.multiple_users_main_switch_title));\n        if (!mUserCaps.mIsGuest) {\n            switchBar.show();\n        } else {\n            switchBar.hide();\n        }\n        mSwitchBarController = new MultiUserSwitchBarController(activity,\n                new MainSwitchBarController(switchBar), this /* listener */);\n        getSettingsLifecycle().addObserver(mSwitchBarController);\n        boolean openUserEditDialog = getIntent().getBooleanExtra(\n                EXTRA_OPEN_DIALOG_USER_PROFILE_EDITOR, false);\n        if (switchBar.isChecked() && openUserEditDialog) {\n            showDialog(DIALOG_USER_PROFILE_EDITOR);\n        }\n    }\n\n    @Override\n    public void onCreate(Bundle icicle) {\n        super.onCreate(icicle);\n        addPreferencesFromResource(R.xml.user_settings);\n        final Activity activity = getActivity();\n        if (!WizardManagerHelper.isDeviceProvisioned(activity)) {\n            activity.finish();\n            return;\n        }\n\n        mGuestUserAutoCreated = getPrefContext().getResources().getBoolean(\n                com.android.internal.R.bool.config_guestUserAutoCreated);\n\n        mAddUserWhenLockedPreferenceController = new AddUserWhenLockedPreferenceController(\n                activity, KEY_ADD_USER_WHEN_LOCKED);\n\n        mGuestTelephonyPreferenceController = new GuestTelephonyPreferenceController(\n                activity, KEY_ENABLE_GUEST_TELEPHONY);\n\n        mRemoveGuestOnExitPreferenceController = new RemoveGuestOnExitPreferenceController(\n                activity, KEY_REMOVE_GUEST_ON_EXIT, this, mHandler);\n\n        mMultiUserTopIntroPreferenceController = new MultiUserTopIntroPreferenceController(activity,\n                KEY_MULTIUSER_TOP_INTRO);\n\n        mTimeoutToDockUserPreferenceController = new TimeoutToDockUserPreferenceController(\n                activity, KEY_TIMEOUT_TO_DOCK_USER);\n\n        final PreferenceScreen screen = getPreferenceScreen();\n        mAddUserWhenLockedPreferenceController.displayPreference(screen);\n        mGuestTelephonyPreferenceController.displayPreference(screen);\n        mRemoveGuestOnExitPreferenceController.displayPreference(screen);\n        mMultiUserTopIntroPreferenceController.displayPreference(screen);\n        mTimeoutToDockUserPreferenceController.displayPreference(screen);\n\n        screen.findPreference(mAddUserWhenLockedPreferenceController.getPreferenceKey())\n                .setOnPreferenceChangeListener(mAddUserWhenLockedPreferenceController);\n\n        screen.findPreference(mGuestTelephonyPreferenceController.getPreferenceKey())\n                .setOnPreferenceChangeListener(mGuestTelephonyPreferenceController);\n\n        screen.findPreference(mRemoveGuestOnExitPreferenceController.getPreferenceKey())\n                .setOnPreferenceChangeListener(mRemoveGuestOnExitPreferenceController);\n\n        if (icicle != null) {\n            if (icicle.containsKey(SAVE_REMOVING_USER)) {\n                mRemovingUserId = icicle.getInt(SAVE_REMOVING_USER);\n            }\n            if (icicle.containsKey(SAVE_CREATE_USER)) {\n                mCreateUserDialogController.onRestoreInstanceState(icicle);\n            } else {\n                mEditUserInfoController.onRestoreInstanceState(icicle);\n            }\n        }\n\n        mUserCaps = UserCapabilities.create(activity);\n        mUserManager = (UserManager) activity.getSystemService(Context.USER_SERVICE);\n        if (!mUserCaps.mEnabled) {\n            return;\n        }\n\n        final int myUserId = UserHandle.myUserId();\n\n        mUserListCategory = (PreferenceGroup) findPreference(KEY_USER_LIST);\n        mMePreference = new UserPreference(getPrefContext(), null /* attrs */, myUserId);\n        mMePreference.setKey(KEY_USER_ME);\n        mMePreference.setOnPreferenceClickListener(this);\n\n        mGuestCategory = findPreference(KEY_GUEST_CATEGORY);\n\n        mGuestResetPreference = findPreference(KEY_GUEST_RESET);\n        mGuestResetPreference.setOnPreferenceClickListener(this);\n\n        mGuestExitPreference = findPreference(KEY_GUEST_EXIT);\n        mGuestExitPreference.setOnPreferenceClickListener(this);\n\n        mGuestUserCategory = findPreference(KEY_GUEST_USER_CATEGORY);\n\n        mAddGuest = findPreference(KEY_ADD_GUEST);\n        mAddGuest.setOnPreferenceClickListener(this);\n\n        mAddUser = findPreference(KEY_ADD_USER);\n        if (!mUserCaps.mCanAddRestrictedProfile) {\n            // Label should only mention adding a \"user\", not a \"profile\"\n            mAddUser.setTitle(com.android.settingslib.R.string.user_add_user);\n        }\n        mAddUser.setOnPreferenceClickListener(this);\n\n        setConfigSupervisedUserCreationPackage();\n        mAddSupervisedUser = findPreference(KEY_ADD_SUPERVISED_USER);\n        mAddSupervisedUser.setOnPreferenceClickListener(this);\n\n        activity.registerReceiverAsUser(\n                mUserChangeReceiver, UserHandle.ALL, USER_REMOVED_INTENT_FILTER, null, mHandler,\n                Context.RECEIVER_EXPORTED_UNAUDITED);\n\n        updateUI();\n        mShouldUpdateUserList = false;\n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n\n        if (!mUserCaps.mEnabled) {\n            return;\n        }\n        final PreferenceScreen screen = getPreferenceScreen();\n\n        mAddUserWhenLockedPreferenceController.updateState(screen.findPreference(\n                mAddUserWhenLockedPreferenceController.getPreferenceKey()));\n        mGuestTelephonyPreferenceController.updateState(screen.findPreference(\n                mGuestTelephonyPreferenceController.getPreferenceKey()));\n        mTimeoutToDockUserPreferenceController.updateState(screen.findPreference(\n                mTimeoutToDockUserPreferenceController.getPreferenceKey()));\n        mRemoveGuestOnExitPreferenceController.updateState(screen.findPreference(\n                mRemoveGuestOnExitPreferenceController.getPreferenceKey()));\n        mSwitchBarController.updateState();\n        if (mShouldUpdateUserList) {\n            updateUI();\n        }\n    }\n\n    @Override\n    public void onPause() {\n        mShouldUpdateUserList = true;\n        super.onPause();\n    }\n\n    @Override\n    public void onDestroy() {\n        super.onDestroy();\n\n        if (mUserCaps == null || !mUserCaps.mEnabled) {\n            return;\n        }\n\n        getActivity().unregisterReceiver(mUserChangeReceiver);\n    }\n\n    @Override\n    public void onSaveInstanceState(Bundle outState) {\n        if (mCreateUserDialogController.isActive()) {\n            outState.putBoolean(SAVE_CREATE_USER, mCreateUserDialogController.isActive());\n            mCreateUserDialogController.onSaveInstanceState(outState);\n        } else {\n            mEditUserInfoController.onSaveInstanceState(outState);\n        }\n        outState.putInt(SAVE_REMOVING_USER, mRemovingUserId);\n        super.onSaveInstanceState(outState);\n    }\n\n    @Override\n    public void startActivityForResult(Intent intent, int requestCode) {\n        mEditUserInfoController.startingActivityForResult();\n        mCreateUserDialogController.startingActivityForResult();\n        super.startActivityForResult(intent, requestCode);\n    }\n\n    @Override\n    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n        int pos = 0;\n        if (!isCurrentUserAdmin() && (canSwitchUserNow() || Flags.newMultiuserSettingsUx())\n                && !isCurrentUserGuest() && !mUserManager.isProfile()) {\n            String nickname = mUserManager.getUserName();\n            MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                    getResources().getString(R.string.user_remove_user_menu, nickname));\n            removeThisUser.setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);\n\n            final EnforcedAdmin disallowRemoveUserAdmin =\n                    RestrictedLockUtilsInternal.checkIfRestrictionEnforced(getContext(),\n                            UserManager.DISALLOW_REMOVE_USER, UserHandle.myUserId());\n            RestrictedLockUtilsInternal.setMenuItemAsDisabledByAdmin(getContext(), removeThisUser,\n                    disallowRemoveUserAdmin);\n        }\n        super.onCreateOptionsMenu(menu, inflater);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        final int itemId = item.getItemId();\n        if (itemId == MENU_REMOVE_USER) {\n            onRemoveUserClicked(UserHandle.myUserId());\n            return true;\n        } else {\n            return super.onOptionsItemSelected(item);\n        }\n    }\n\n    @Override\n    public void onMultiUserSwitchChanged(boolean newState) {\n        updateUI();\n    }\n\n    private void updateUI() {\n        mUserCaps.updateAddUserCapabilities(getActivity());\n        loadProfile();\n        updateUserList();\n    }\n\n    /**\n     * Loads profile information for the current user.\n     */\n    private void loadProfile() {\n        if (isCurrentUserGuest()) {\n            // No need to load profile information\n            mMePreference.setIcon(getEncircledDefaultIcon());\n            mMePreference.setTitle(mGuestUserAutoCreated\n                    ? com.android.settingslib.R.string.guest_reset_guest\n                    : com.android.settingslib.R.string.guest_exit_guest);\n            mMePreference.setSelectable(true);\n            // removing a guest will result in switching back to the admin user\n            mMePreference.setEnabled(canSwitchUserNow());\n            return;\n        }\n\n        new AsyncTask<Void, Void, String>() {\n            @Override\n            protected void onPostExecute(String result) {\n                finishLoadProfile(result);\n            }\n\n            @Override\n            protected String doInBackground(Void... values) {\n                UserInfo user = mUserManager.getUserInfo(UserHandle.myUserId());\n                if (user.iconPath == null || user.iconPath.equals(\"\")) {\n                    // Assign profile photo.\n                    copyMeProfilePhoto(getActivity(), user);\n                }\n                return user.name;\n            }\n        }.execute();\n    }\n\n    private void finishLoadProfile(String profileName) {\n        if (getActivity() == null) {\n            return;\n        }\n        mMePreference.setTitle(getString(R.string.user_you, profileName));\n        int myUserId = UserHandle.myUserId();\n        Bitmap b = mUserManager.getUserIcon(myUserId);\n        if (b != null) {\n            mMePreference.setIcon(encircleUserIcon(b));\n            mUserIcons.put(myUserId, b);\n        }\n    }\n\n    private boolean hasLockscreenSecurity() {\n        LockPatternUtils lpu = new LockPatternUtils(getActivity());\n        return lpu.isSecure(UserHandle.myUserId());\n    }\n\n    private void launchChooseLockscreen() {\n        Intent chooseLockIntent = new Intent(DevicePolicyManager.ACTION_SET_NEW_PASSWORD)\n                .setPackage(getContext().getPackageName());\n        chooseLockIntent.putExtra(ChooseLockGeneric.ChooseLockGenericFragment.HIDE_INSECURE_OPTIONS,\n                true);\n        startActivityForResult(chooseLockIntent, REQUEST_CHOOSE_LOCK);\n    }\n\n    @Override\n    public void onActivityResult(int requestCode, int resultCode, Intent data) {\n        super.onActivityResult(requestCode, resultCode, data);\n\n        if (requestCode == REQUEST_CHOOSE_LOCK) {\n            if (resultCode != Activity.RESULT_CANCELED && hasLockscreenSecurity()) {\n                addUserNow(USER_TYPE_RESTRICTED_PROFILE);\n            }\n        } else if (mGuestUserAutoCreated && requestCode == REQUEST_EDIT_GUEST\n                && resultCode == RESULT_GUEST_REMOVED) {\n            scheduleGuestCreation();\n        } else {\n            mCreateUserDialogController.onActivityResult(requestCode, resultCode, data);\n            mEditUserInfoController.onActivityResult(requestCode, resultCode, data);\n        }\n    }\n\n    private void onAddUserClicked(int userType) {\n        synchronized (mUserLock) {\n            if (mRemovingUserId == -1 && !mAddingUser) {\n                switch (userType) {\n                    case USER_TYPE_USER:\n                        showDialog(DIALOG_ADD_USER);\n                        break;\n                    case USER_TYPE_RESTRICTED_PROFILE:\n                        if (hasLockscreenSecurity()) {\n                            showDialog(DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE);\n                        } else {\n                            showDialog(DIALOG_NEED_LOCKSCREEN);\n                        }\n                        break;\n                }\n            }\n        }\n    }\n\n    private void onAddSupervisedUserClicked() {\n        final Intent intent = new Intent()\n                .setAction(UserManager.ACTION_CREATE_SUPERVISED_USER)\n                .setPackage(mConfigSupervisedUserCreationPackage)\n                .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n\n        startActivity(intent);\n    }\n\n    private void onAddGuestClicked() {\n        Context context = getContext();\n        final UserCreatingDialog guestCreatingDialog =\n                new UserCreatingDialog(getActivity(), /* isGuest= */ true);\n        guestCreatingDialog.show();\n\n        ThreadUtils.postOnBackgroundThread(() -> {\n            mMetricsFeatureProvider.action(getActivity(), SettingsEnums.ACTION_USER_GUEST_ADD);\n            Trace.beginSection(\"UserSettings.addGuest\");\n            final UserInfo guest = mUserManager.createGuest(context);\n            Trace.endSection();\n\n            ThreadUtils.postOnMainThread(() -> {\n                guestCreatingDialog.dismiss();\n                if (guest == null) {\n                    Toast.makeText(context,\n                            com.android.settingslib.R.string.add_guest_failed,\n                            Toast.LENGTH_SHORT).show();\n                    return;\n                }\n                openUserDetails(guest, true, context);\n            });\n        });\n    }\n\n    private void onRemoveUserClicked(int userId) {\n        synchronized (mUserLock) {\n            if (mRemovingUserId == -1 && !mAddingUser) {\n                mRemovingUserId = userId;\n                showDialog(DIALOG_CONFIRM_REMOVE);\n            }\n        }\n    }\n\n    private void onUserCreated(UserInfo userInfo, Context context) {\n        hideUserCreatingDialog();\n        mAddingUser = false;\n        openUserDetails(userInfo, true, context);\n    }\n\n    private void hideUserCreatingDialog() {\n        if (mUserCreatingDialog != null && mUserCreatingDialog.isShowing()) {\n            mUserCreatingDialog.dismiss();\n        }\n    }\n\n    private void onUserCreationFailed() {\n        Toast.makeText(getContext(),\n                com.android.settingslib.R.string.add_user_failed,\n                Toast.LENGTH_SHORT).show();\n        hideUserCreatingDialog();\n    }\n\n    private void openUserDetails(UserInfo userInfo, boolean newUser) {\n        openUserDetails(userInfo, newUser, getContext());\n    }\n\n    private void openUserDetails(UserInfo userInfo, boolean newUser, Context context) {\n        // to prevent a crash when config changes during user creation,\n        // we simply ignore this redirection step\n        if (context == null) {\n            return;\n        }\n\n        Bundle extras = new Bundle();\n        extras.putInt(UserDetailsSettings.EXTRA_USER_ID, userInfo.id);\n        extras.putBoolean(AppRestrictionsFragment.EXTRA_NEW_USER, newUser);\n\n        SubSettingLauncher launcher = new SubSettingLauncher(context)\n                .setDestination(UserDetailsSettings.class.getName())\n                .setArguments(extras)\n                .setTitleText(userInfo.name)\n                .setSourceMetricsCategory(getMetricsCategory());\n        if (mGuestUserAutoCreated && userInfo.isGuest()) {\n            launcher.setResultListener(this, REQUEST_EDIT_GUEST);\n        }\n        launcher.launch();\n    }\n\n    @Override\n    public void onDialogShowing() {\n        super.onDialogShowing();\n\n        setOnDismissListener(this);\n    }\n\n    @Override\n    public Dialog onCreateDialog(int dialogId) {\n        Context context = getActivity();\n        if (context == null) {\n            return null;\n        }\n        switch (dialogId) {\n            case DIALOG_CONFIRM_REMOVE: {\n                Dialog dlg =\n                        UserDialogs.createRemoveDialog(getActivity(), mRemovingUserId,\n                                new DialogInterface.OnClickListener() {\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        removeUserNow();\n                                    }\n                                }\n                        );\n                return dlg;\n            }\n            case DIALOG_USER_CANNOT_MANAGE:\n                return new AlertDialog.Builder(context)\n                        .setMessage(R.string.user_cannot_manage_message)\n                        .setPositiveButton(android.R.string.ok, null)\n                        .create();\n            case DIALOG_ADD_USER: {\n                synchronized (mUserLock) {\n                    mPendingUserName = getString(\n                            com.android.settingslib.R.string.user_new_user_name);\n                    mPendingUserIcon = null;\n                }\n                return buildAddUserDialog(USER_TYPE_USER);\n            }\n            case DIALOG_CHOOSE_USER_TYPE: {\n                List<HashMap<String, String>> data = new ArrayList<HashMap<String, String>>();\n                HashMap<String, String> addUserItem = new HashMap<String, String>();\n                addUserItem.put(KEY_TITLE, getString(\n                        com.android.settingslib.R.string.user_add_user_item_title));\n                addUserItem.put(KEY_SUMMARY, getString(\n                        com.android.settingslib.R.string.user_add_user_item_summary));\n                HashMap<String, String> addProfileItem = new HashMap<String, String>();\n                addProfileItem.put(KEY_TITLE, getString(\n                        com.android.settingslib.R.string.user_add_profile_item_title));\n                addProfileItem.put(KEY_SUMMARY, getString(\n                        com.android.settingslib.R.string.user_add_profile_item_summary));\n                data.add(addUserItem);\n                data.add(addProfileItem);\n                AlertDialog.Builder builder = new AlertDialog.Builder(context);\n                SimpleAdapter adapter = new SimpleAdapter(builder.getContext(),\n                        data, R.layout.two_line_list_item,\n                        new String[]{KEY_TITLE, KEY_SUMMARY},\n                        new int[]{R.id.title, R.id.summary});\n                builder.setTitle(com.android.settingslib.R.string.user_add_user_type_title);\n                builder.setAdapter(adapter,\n                        new DialogInterface.OnClickListener() {\n                            @Override\n                            public void onClick(DialogInterface dialog, int which) {\n                                onAddUserClicked(which == 0\n                                        ? USER_TYPE_USER\n                                        : USER_TYPE_RESTRICTED_PROFILE);\n                            }\n                        });\n                return builder.create();\n            }\n            case DIALOG_NEED_LOCKSCREEN: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setMessage(com.android.settingslib.R.string.user_need_lock_message)\n                        .setPositiveButton(com.android.settingslib.R.string.user_set_lock_button,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        launchChooseLockscreen();\n                                    }\n                                })\n                        .setNegativeButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            case DIALOG_CONFIRM_REMOVE_GUEST: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setTitle(com.android.settingslib.R.string.guest_remove_guest_dialog_title)\n                        .setMessage(R.string.user_exit_guest_confirm_message)\n                        .setPositiveButton(R.string.user_exit_guest_dialog_remove,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        clearAndExitGuest();\n                                    }\n                                })\n                        .setNegativeButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            case DIALOG_CONFIRM_EXIT_GUEST_EPHEMERAL: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setTitle(com.android.settingslib.R.string.guest_exit_dialog_title)\n                        .setMessage(com.android.settingslib.R.string.guest_exit_dialog_message)\n                        .setPositiveButton(\n                                com.android.settingslib.R.string.guest_exit_dialog_button,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        clearAndExitGuest();\n                                    }\n                                })\n                        .setNeutralButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            case DIALOG_CONFIRM_EXIT_GUEST_NON_EPHEMERAL: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setTitle(\n                            com.android.settingslib.R.string.guest_exit_dialog_title_non_ephemeral)\n                        .setMessage(\n                            com.android.settingslib\n                                .R.string.guest_exit_dialog_message_non_ephemeral)\n                        .setPositiveButton(\n                            com.android.settingslib.R.string.guest_exit_save_data_button,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        exitGuest();\n                                    }\n                                })\n                        .setNegativeButton(\n                            com.android.settingslib.R.string.guest_exit_clear_data_button,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        clearAndExitGuest();\n                                    }\n                                })\n                        .setNeutralButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            case DIALOG_USER_PROFILE_EDITOR: {\n                return buildEditCurrentUserDialog();\n            }\n            case DIALOG_USER_PROFILE_EDITOR_ADD_USER: {\n                synchronized (mUserLock) {\n                    mPendingUserName = getString(\n                            com.android.settingslib.R.string.user_new_user_name);\n                    mPendingUserIcon = null;\n                }\n                return buildAddUserDialog(USER_TYPE_USER);\n            }\n            case DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE: {\n                synchronized (mUserLock) {\n                    mPendingUserName = getString(\n                            com.android.settingslib.R.string.user_new_profile_name);\n                    mPendingUserIcon = null;\n                }\n                return buildAddUserDialog(USER_TYPE_RESTRICTED_PROFILE);\n            }\n            case DIALOG_CONFIRM_REMOVE_GUEST_WITH_AUTO_CREATE: {\n                return UserDialogs.createResetGuestDialog(getActivity(),\n                        (dialog, which) -> clearAndExitGuest());\n            }\n            case DIALOG_CONFIRM_RESET_AND_RESTART_GUEST: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setTitle(\n                            com.android.settingslib.R.string.guest_reset_and_restart_dialog_title)\n                        .setMessage(\n                            com.android.settingslib.R.string.guest_reset_and_restart_dialog_message)\n                        .setPositiveButton(\n                            com.android.settingslib.R.string.guest_reset_guest_confirm_button,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        resetAndRestartGuest();\n                                    }\n                                })\n                        .setNeutralButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            default:\n                return null;\n        }\n    }\n\n    private Dialog buildEditCurrentUserDialog() {\n        final Activity activity = getActivity();\n        if (activity == null) {\n            return null;\n        }\n\n        UserInfo user = mUserManager.getUserInfo(Process.myUserHandle().getIdentifier());\n        Drawable userIcon = Utils.getUserIcon(activity, mUserManager, user);\n\n        return mEditUserInfoController.createDialog(\n                activity,\n                this::startActivityForResult,\n                userIcon,\n                user.name,\n                (newUserName, newUserIcon) -> {\n                    if (newUserIcon != userIcon) {\n                        ThreadUtils.postOnBackgroundThread(() ->\n                                mUserManager.setUserIcon(user.id,\n                                        UserIcons.convertToBitmapAtUserIconSize(\n                                                activity.getResources(), newUserIcon)));\n                        mMePreference.setIcon(newUserIcon);\n                        if (Flags.avatarSync()) {\n                            final String pkg = getString(R.string.config_avatar_picker_package);\n                            final String action = pkg + \".set.confirm\";\n                            activity.sendBroadcast(new Intent(action).setPackage(pkg));\n                        }\n                    }\n\n                    if (!TextUtils.isEmpty(newUserName) && !newUserName.equals(user.name)) {\n                        mMePreference.setTitle(newUserName);\n                        mUserManager.setUserName(user.id, newUserName);\n                    }\n                }, () -> {\n                    if (Flags.avatarSync()) {\n                        final String pkg = getString(R.string.config_avatar_picker_package);\n                        final String action = pkg + \".set.cancel\";\n                        activity.sendBroadcast(new Intent(action).setPackage(pkg));\n                    }\n                });\n    }\n\n    private Dialog buildAddUserDialog(int userType) {\n        Dialog d;\n        synchronized (mUserLock) {\n            d = mCreateUserDialogController.createDialog(\n                    getActivity(),\n                    this::startActivityForResult,\n                    canCreateAdminUser(),\n                    (userName, userIcon, isAdmin) -> {\n                        mPendingUserIcon = userIcon;\n                        mPendingUserName = userName;\n                        mPendingUserIsAdmin = isAdmin;\n                        addUserNow(userType);\n                    },\n                    () -> {\n                        synchronized (mUserLock) {\n                            mPendingUserIcon = null;\n                            mPendingUserName = null;\n                        }\n                    }\n            );\n        }\n        return d;\n    }\n\n    /**\n     * Checks if the creation of a new admin user is allowed.\n     * @return {@code true} if creating a new admin is allowed, {@code false} otherwise.\n     */\n    private boolean canCreateAdminUser() {\n        if (Flags.unicornModeRefactoringForHsumReadOnly()) {\n            return UserManager.isMultipleAdminEnabled()\n                    && !mUserManager.hasUserRestriction(UserManager.DISALLOW_GRANT_ADMIN);\n        } else {\n            return UserManager.isMultipleAdminEnabled();\n        }\n    }\n\n    @Override\n    public int getDialogMetricsCategory(int dialogId) {\n        switch (dialogId) {\n            case DIALOG_CONFIRM_REMOVE:\n                return SettingsEnums.DIALOG_USER_REMOVE;\n            case DIALOG_USER_CANNOT_MANAGE:\n                return SettingsEnums.DIALOG_USER_CANNOT_MANAGE;\n            case DIALOG_GRANT_ADMIN:\n                return SettingsEnums.DIALOG_GRANT_USER_ADMIN;\n            case DIALOG_ADD_USER:\n                return SettingsEnums.DIALOG_USER_ADD;\n            case DIALOG_CHOOSE_USER_TYPE:\n                return SettingsEnums.DIALOG_USER_CHOOSE_TYPE;\n            case DIALOG_NEED_LOCKSCREEN:\n                return SettingsEnums.DIALOG_USER_NEED_LOCKSCREEN;\n            case DIALOG_CONFIRM_REMOVE_GUEST:\n            case DIALOG_CONFIRM_REMOVE_GUEST_WITH_AUTO_CREATE:\n            case DIALOG_CONFIRM_EXIT_GUEST_EPHEMERAL:\n            case DIALOG_CONFIRM_EXIT_GUEST_NON_EPHEMERAL:\n            case DIALOG_CONFIRM_RESET_AND_RESTART_GUEST:\n                return SettingsEnums.DIALOG_USER_CONFIRM_EXIT_GUEST;\n            case DIALOG_USER_PROFILE_EDITOR:\n            case DIALOG_USER_PROFILE_EDITOR_ADD_USER:\n            case DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE:\n                return SettingsEnums.DIALOG_USER_EDIT_PROFILE;\n            default:\n                return 0;\n        }\n    }\n\n    private void removeUserNow() {\n        if (mRemovingUserId == UserHandle.myUserId()) {\n            removeThisUser();\n        } else {\n            ThreadUtils.postOnBackgroundThread(new Runnable() {\n                @Override\n                public void run() {\n                    synchronized (mUserLock) {\n                        mUserManager.removeUser(mRemovingUserId);\n                        mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n                    }\n                }\n            });\n        }\n    }\n\n    private void removeThisUser() {\n        if (!canSwitchUserNow()) {\n            Log.w(TAG, \"Cannot remove current user when switching is disabled\");\n            return;\n        }\n        try {\n            mUserManager.removeUserWhenPossible(\n                    UserHandle.of(UserHandle.myUserId()), /* overrideDevicePolicy= */ false);\n            ActivityManager.getService().switchUser(\n                    mUserManager.getPreviousForegroundUser().getIdentifier());\n        } catch (RemoteException re) {\n            Log.e(TAG, \"Unable to remove self user\");\n        }\n    }\n\n    private void switchToUserId(int userId) {\n        if (!canSwitchUserNow()) {\n            Log.w(TAG, \"Cannot switch current user when switching is disabled\");\n            return;\n        }\n        try {\n            ActivityManager.getService().switchUser(userId);\n        } catch (RemoteException re) {\n            Log.e(TAG, \"Unable to switch user\");\n        }\n    }\n\n    private void addUserNow(final int userType) {\n        Trace.beginAsyncSection(\"UserSettings.addUserNow\", 0);\n        synchronized (mUserLock) {\n            mAddingUser = true;\n            mAddingUserName = userType == USER_TYPE_USER\n                    ? (mPendingUserName != null ? mPendingUserName.toString()\n                    : getString(com.android.settingslib.R.string.user_new_user_name))\n                    : (mPendingUserName != null ? mPendingUserName.toString()\n                            : getString(com.android.settingslib.R.string.user_new_profile_name));\n        }\n\n        mUserCreatingDialog = new UserCreatingDialog(getActivity());\n        mUserCreatingDialog.show();\n        createUser(userType, mAddingUserName);\n    }\n\n    @VisibleForTesting\n    void createUser(final int userType, String userName) {\n        Context context = getContext();\n        Resources resources = getResources();\n        final Drawable selectedUserIcon = mPendingUserIcon;\n        Future<?> unusedCreateUserFuture = ThreadUtils.postOnBackgroundThread(() -> {\n            UserInfo user;\n\n            if (userType == USER_TYPE_USER) {\n                user = mUserManager.createUser(\n                        userName,\n                        mUserManager.USER_TYPE_FULL_SECONDARY,\n                        0);\n                if (mPendingUserIsAdmin) {\n                    mUserManager.setUserAdmin(user.id);\n                }\n            } else {\n                user = mUserManager.createRestrictedProfile(userName);\n            }\n\n            ThreadUtils.postOnMainThread(() -> {\n                if (user == null) {\n                    mAddingUser = false;\n                    mPendingUserIcon = null;\n                    mPendingUserName = null;\n                    onUserCreationFailed();\n                    return;\n                }\n\n                Future<?> unusedSettingIconFuture = ThreadUtils.postOnBackgroundThread(() -> {\n                    Drawable newUserIcon = selectedUserIcon;\n                    if (newUserIcon == null) {\n                        newUserIcon = UserIcons.getDefaultUserIcon(resources, user.id, false);\n                    }\n                    mUserManager.setUserIcon(\n                            user.id, UserIcons.convertToBitmapAtUserIconSize(\n                                    resources, newUserIcon));\n                });\n\n                mPendingUserIcon = null;\n                mPendingUserName = null;\n\n                onUserCreated(user, context);\n            });\n        });\n    }\n\n\n    /**\n     * Erase the current user (guest) and switch to another user.\n     */\n    @VisibleForTesting\n    void clearAndExitGuest() {\n        // Just to be safe\n        if (!isCurrentUserGuest()) {\n            return;\n        }\n        mMetricsFeatureProvider.action(getActivity(),\n                SettingsEnums.ACTION_USER_GUEST_EXIT_CONFIRMED);\n\n        int guestUserId = UserHandle.myUserId();\n        // Using markGuestForDeletion allows us to create a new guest before this one is\n        // fully removed.\n        boolean marked = mUserManager.markGuestForDeletion(guestUserId);\n        if (!marked) {\n            Log.w(TAG, \"Couldn't mark the guest for deletion for user \" + guestUserId);\n            return;\n        }\n\n        removeThisUser();\n        if (mGuestUserAutoCreated) {\n            scheduleGuestCreation();\n        }\n    }\n\n    /**\n     * Switch to another user.\n     */\n    private void exitGuest() {\n        // Just to be safe\n        if (!isCurrentUserGuest()) {\n            return;\n        }\n        mMetricsFeatureProvider.action(getActivity(),\n                SettingsEnums.ACTION_USER_GUEST_EXIT_CONFIRMED);\n        switchToUserId(mUserManager.getPreviousForegroundUser().getIdentifier());\n    }\n\n    private int createGuest() {\n        UserInfo guest;\n        Context context = getPrefContext();\n        try {\n            guest = mUserManager.createGuest(context);\n        } catch (UserManager.UserOperationException e) {\n            Log.e(TAG, \"Couldn't create guest user\", e);\n            return UserHandle.USER_NULL;\n        }\n        if (guest == null) {\n            Log.e(TAG, \"Couldn't create guest, most likely because there already exists one\");\n            return UserHandle.USER_NULL;\n        }\n        return guest.id;\n    }\n\n    /**\n     * Remove current guest and start a new guest session\n     */\n    private void resetAndRestartGuest() {\n        // Just to be safe\n        if (!isCurrentUserGuest()) {\n            return;\n        }\n        int oldGuestUserId = UserHandle.myUserId();\n        // Using markGuestForDeletion allows us to create a new guest before this one is\n        // fully removed.\n        boolean marked = mUserManager.markGuestForDeletion(oldGuestUserId);\n        if (!marked) {\n            Log.w(TAG, \"Couldn't mark the guest for deletion for user \" + oldGuestUserId);\n            return;\n        }\n\n        try {\n            // Create a new guest in the foreground, and then immediately switch to it\n            int newGuestUserId = createGuest();\n            if (newGuestUserId == UserHandle.USER_NULL) {\n                Log.e(TAG, \"Could not create new guest, switching back to previous user\");\n                switchToUserId(mUserManager.getPreviousForegroundUser().getIdentifier());\n                mUserManager.removeUser(oldGuestUserId);\n                WindowManagerGlobal.getWindowManagerService().lockNow(/* options= */ null);\n                return;\n            }\n            switchToUserId(newGuestUserId);\n            mUserManager.removeUser(oldGuestUserId);\n        } catch (RemoteException e) {\n            Log.e(TAG, \"Couldn't remove guest because ActivityManager or WindowManager is dead\");\n            return;\n        }\n    }\n\n    /**\n     * Create a guest user in the background\n     */\n    @VisibleForTesting\n    void scheduleGuestCreation() {\n        // TODO(b/191067027): Move guest recreation to system_server\n        if (mGuestCreationScheduled.compareAndSet(/* expect= */ false, /* update= */ true)) {\n            // Once mGuestCreationScheduled=true, mAddGuest needs to be updated so that it shows\n            // \"Resetting guest...\"\n            mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n            mExecutor.execute(() -> {\n                UserInfo guest = mUserManager.createGuest(getContext());\n                mGuestCreationScheduled.set(false);\n                if (guest == null) {\n                    Log.e(TAG, \"Unable to automatically recreate guest user\");\n                }\n                // The list needs to be updated whether or not guest creation worked. If guest\n                // creation failed, the list needs to update so that \"Add guest\" is displayed.\n                // Otherwise, the UX could be stuck in a state where there is no way to switch to\n                // the guest user (e.g. Guest would not be selectable, and it would be stuck\n                // saying \"Resetting guest...\")\n                mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n            });\n        }\n    }\n\n    @VisibleForTesting\n    void updateUserList() {\n        final Context context = getActivity();\n        if (context == null) {\n            return;\n        }\n\n        List<UserInfo> users;\n        if (Flags.newMultiuserSettingsUx()) {\n            // Only users that can be switched to should show up here.\n            // e.g. Managed profiles appear under Accounts Settings instead\n            users = mUserManager.getAliveUsers().stream()\n                    .filter(UserInfo::supportsSwitchToByUser)\n                    .collect(Collectors.toList());\n        } else {\n            if (mUserCaps.mUserSwitcherEnabled) {\n                // Only users that can be switched to should show up here.\n                // e.g. Managed profiles appear under Accounts Settings instead\n                users = mUserManager.getAliveUsers().stream()\n                        .filter(UserInfo::supportsSwitchToByUser)\n                        .collect(Collectors.toList());\n            } else {\n                // Only current user will be displayed in case of multi-user switch is disabled\n                users = List.of(mUserManager.getUserInfo(context.getUserId()));\n            }\n        }\n\n        final ArrayList<Integer> missingIcons = new ArrayList<>();\n        final ArrayList<UserPreference> userPreferences = new ArrayList<>();\n\n        // mMePreference shows a icon for current user. However when current user is a guest, we\n        // don't show the guest user icon, instead we show two preferences for guest user to\n        // exit and reset itself. Hence we don't add mMePreference, i.e. guest user to the\n        // list of users visible in the UI.\n        if (!isCurrentUserGuest()) {\n            userPreferences.add(mMePreference);\n        }\n\n        boolean canOpenUserDetails =\n                isCurrentUserAdmin() || (canSwitchUserNow() && !mUserCaps.mDisallowSwitchUser);\n        for (UserInfo user : users) {\n            if (user.isGuest()) {\n                // Guest user is added to guest category via updateGuestCategory\n                // and not to user list so skip guest here\n                continue;\n            }\n            UserPreference pref;\n            if (user.id == UserHandle.myUserId()) {\n                pref = mMePreference;\n            } else {\n                pref = new UserPreference(getPrefContext(), null, user.id);\n                pref.setTitle(user.name);\n                userPreferences.add(pref);\n                pref.setOnPreferenceClickListener(this);\n                pref.setEnabled(canOpenUserDetails);\n                pref.setSelectable(true);\n                pref.setKey(\"id=\" + user.id);\n            }\n            if (pref == null) {\n                continue;\n            }\n            if (user.isMain()) {\n                pref.setSummary(R.string.user_owner);\n            } else if (user.isAdmin()) {\n                pref.setSummary(R.string.user_admin);\n            }\n            if (user.id != UserHandle.myUserId() && !user.isGuest() && !user.isInitialized()) {\n                // sometimes after creating a guest the initialized flag isn't immediately set\n                // and we don't want to show \"Not set up\" summary for them\n                if (user.isRestricted()) {\n                    pref.setSummary(R.string.user_summary_restricted_not_set_up);\n                } else {\n                    pref.setSummary(R.string.user_summary_not_set_up);\n                    // Disallow setting up user which results in user switching when the\n                    // restriction is set.\n                    // If newMultiuserSettingsUx flag is enabled, allow opening user details page\n                    // since switch to user will be disabled\n                    pref.setEnabled((!mUserCaps.mDisallowSwitchUser && canSwitchUserNow())\n                            || Flags.newMultiuserSettingsUx());\n                }\n            } else if (user.isRestricted()) {\n                pref.setSummary(R.string.user_summary_restricted_profile);\n            }\n            if (user.iconPath != null) {\n                if (mUserIcons.get(user.id) == null) {\n                    // Icon not loaded yet, print a placeholder\n                    missingIcons.add(user.id);\n                    pref.setIcon(getEncircledDefaultIcon());\n                } else {\n                    setPhotoId(pref, user);\n                }\n            } else {\n                // Icon not available yet, print a placeholder\n                pref.setIcon(getEncircledDefaultIcon());\n            }\n        }\n\n        // Add a temporary entry for the user being created\n        if (mAddingUser) {\n            UserPreference pref = new UserPreference(getPrefContext(), null,\n                    UserPreference.USERID_UNKNOWN);\n            pref.setEnabled(false);\n            pref.setTitle(mAddingUserName);\n            pref.setIcon(getEncircledDefaultIcon());\n            userPreferences.add(pref);\n        }\n\n        // Sort list of users by serialNum\n        Collections.sort(userPreferences, UserPreference.SERIAL_NUMBER_COMPARATOR);\n\n        getActivity().invalidateOptionsMenu();\n\n        // Load the icons\n        if (missingIcons.size() > 0) {\n            loadIconsAsync(missingIcons);\n        }\n\n        // If restricted profiles are supported, mUserListCategory will have a special title\n        if (mUserCaps.mCanAddRestrictedProfile) {\n            mUserListCategory.setTitle(R.string.user_list_title);\n        } else if (isCurrentUserGuest()) {\n            mUserListCategory.setTitle(R.string.other_user_category_title);\n        } else {\n            mUserListCategory.setTitle(R.string.user_category_title);\n        }\n\n        // Remove everything from mUserListCategory and add new users.\n        mUserListCategory.removeAll();\n\n        final Preference addUserOnLockScreen = getPreferenceScreen().findPreference(\n                mAddUserWhenLockedPreferenceController.getPreferenceKey());\n        mAddUserWhenLockedPreferenceController.updateState(addUserOnLockScreen);\n\n        final Preference guestCallPreference = getPreferenceScreen().findPreference(\n                mGuestTelephonyPreferenceController.getPreferenceKey());\n        mGuestTelephonyPreferenceController.updateState(guestCallPreference);\n\n        final Preference multiUserTopIntroPreference = getPreferenceScreen().findPreference(\n                mMultiUserTopIntroPreferenceController.getPreferenceKey());\n        mMultiUserTopIntroPreferenceController.updateState(multiUserTopIntroPreference);\n        updateGuestPreferences();\n        updateGuestCategory(context, users);\n        updateAddUser(context);\n        updateAddSupervisedUser(context);\n\n        for (UserPreference userPreference : userPreferences) {\n            userPreference.setOrder(Preference.DEFAULT_ORDER);\n            mUserListCategory.addPreference(userPreference);\n        }\n\n    }\n\n    @VisibleForTesting\n    void setConfigSupervisedUserCreationPackage() {\n        mConfigSupervisedUserCreationPackage = getPrefContext().getString(\n                com.android.internal.R.string.config_supervisedUserCreationPackage);\n    }\n\n    private boolean isCurrentUserGuest() {\n        return mUserCaps.mIsGuest;\n    }\n\n    private boolean isCurrentUserAdmin() {\n        return mUserCaps.mIsAdmin;\n    }\n\n    private boolean canSwitchUserNow() {\n        return mUserManager.getUserSwitchability() == UserManager.SWITCHABILITY_STATUS_OK;\n    }\n\n    private void updateGuestPreferences() {\n        // reset guest and exit guest preferences are shown only in guest mode.\n        // For all other users these are not visible.\n        mGuestCategory.setVisible(false);\n        mGuestResetPreference.setVisible(false);\n        mGuestExitPreference.setVisible(false);\n        if (!isCurrentUserGuest()) {\n            return;\n        }\n        mGuestCategory.setVisible(true);\n        mGuestExitPreference.setVisible(true);\n        mGuestResetPreference.setVisible(true);\n\n        boolean isGuestFirstLogin = Settings.Secure.getIntForUser(\n                getContext().getContentResolver(),\n                SETTING_GUEST_HAS_LOGGED_IN,\n                0,\n                UserHandle.myUserId()) <= 1;\n        String guestExitSummary;\n        if (mUserCaps.mIsEphemeral) {\n            guestExitSummary = getContext().getString(\n                    com.android.settingslib.R.string.guest_notification_ephemeral);\n        } else if (isGuestFirstLogin) {\n            guestExitSummary = getContext().getString(\n                    com.android.settingslib.R.string.guest_notification_non_ephemeral);\n        } else {\n            guestExitSummary = getContext().getString(\n                    com.android.settingslib.R\n                            .string.guest_notification_non_ephemeral_non_first_login);\n        }\n        mGuestExitPreference.setSummary(guestExitSummary);\n    }\n\n    private void updateGuestCategory(Context context, List<UserInfo> users) {\n        // show guest category title and related guest preferences\n        // - if guest is created, then show guest user preference\n        // - if guest is not created and its allowed to create guest,\n        //   then show \"add guest\" preference\n        // - if allowed, show \"reset guest on exit\" preference\n        // - if there is nothing to show, then make the guest category as not visible\n        // - guest category is not visible for guest user.\n        UserPreference pref = null;\n        boolean isGuestAlreadyCreated = false;\n        boolean canOpenUserDetails =\n                isCurrentUserAdmin() || (canSwitchUserNow() && !mUserCaps.mDisallowSwitchUser);\n\n        mGuestUserCategory.removeAll();\n        mGuestUserCategory.setVisible(false);\n        for (UserInfo user : users) {\n            if (!user.isGuest() || !user.isEnabled()) {\n                // Only look at enabled, guest users\n                continue;\n            }\n            final Context prefContext = getPrefContext();\n            pref = new UserPreference(prefContext, null, user.id);\n            pref.setTitle(user.name);\n            pref.setOnPreferenceClickListener(this);\n            pref.setEnabled(canOpenUserDetails);\n            pref.setSelectable(true);\n            Drawable icon = getContext().getDrawable(\n                    com.android.settingslib.R.drawable.ic_account_circle_outline);\n            icon.setTint(\n                    getColorAttrDefaultColor(getContext(), android.R.attr.colorControlNormal));\n            pref.setIcon(encircleUserIcon(\n                    UserIcons.convertToBitmapAtUserIconSize(\n                            getContext().getResources(), icon)));\n            pref.setKey(KEY_USER_GUEST);\n            pref.setOrder(Preference.DEFAULT_ORDER);\n            if (mUserCaps.mDisallowSwitchUser && !Flags.newMultiuserSettingsUx()) {\n                pref.setDisabledByAdmin(\n                        RestrictedLockUtilsInternal.getDeviceOwner(context));\n            } else {\n                pref.setDisabledByAdmin(null);\n            }\n            if (Flags.newMultiuserSettingsUx()) {\n                mGuestUserCategory.addPreference(pref);\n                // guest user preference is shown hence also make guest category visible\n                mGuestUserCategory.setVisible(true);\n            } else {\n                if (mUserCaps.mUserSwitcherEnabled) {\n                    mGuestUserCategory.addPreference(pref);\n                    // guest user preference is shown hence also make guest category visible\n                    mGuestUserCategory.setVisible(true);\n                }\n            }\n            isGuestAlreadyCreated = true;\n        }\n        boolean isVisible = updateAddGuestPreference(context, isGuestAlreadyCreated);\n        if (isVisible) {\n            // \"add guest\" preference is shown hence also make guest category visible\n            mGuestUserCategory.setVisible(true);\n        }\n        final Preference removeGuestOnExit = getPreferenceScreen().findPreference(\n                mRemoveGuestOnExitPreferenceController.getPreferenceKey());\n        mRemoveGuestOnExitPreferenceController.updateState(removeGuestOnExit);\n        if (mRemoveGuestOnExitPreferenceController.isAvailable()) {\n            // \"reset guest on exit\" preference is shown hence also make guest category visible\n            mGuestUserCategory.setVisible(true);\n        }\n        if (isCurrentUserGuest()) {\n            // guest category is not visible for guest user.\n            mGuestUserCategory.setVisible(false);\n        }\n    }\n\n    private boolean updateAddGuestPreference(Context context, boolean isGuestAlreadyCreated) {\n        boolean isVisible = false;\n        if (!isGuestAlreadyCreated && (mUserCaps.mCanAddGuest\n                || (Flags.newMultiuserSettingsUx() && mUserCaps.mDisallowAddUser))\n                && mUserManager.canAddMoreUsers(UserManager.USER_TYPE_FULL_GUEST)\n                && WizardManagerHelper.isDeviceProvisioned(context)\n                && (mUserCaps.mUserSwitcherEnabled || Flags.newMultiuserSettingsUx())) {\n            Drawable icon = context.getDrawable(\n                    com.android.settingslib.R.drawable.ic_account_circle);\n            mAddGuest.setIcon(centerAndTint(icon));\n            isVisible = true;\n            mAddGuest.setVisible(true);\n            mAddGuest.setSelectable(true);\n            if (mGuestUserAutoCreated && mGuestCreationScheduled.get()) {\n                mAddGuest.setTitle(com.android.internal.R.string.guest_name);\n                mAddGuest.setSummary(com.android.settingslib.R.string.guest_resetting);\n                mAddGuest.setEnabled(false);\n            } else {\n                mAddGuest.setTitle(com.android.settingslib.R.string.guest_new_guest);\n                if (Flags.newMultiuserSettingsUx()\n                        && mUserCaps.mDisallowAddUserSetByAdmin) {\n                    mAddGuest.setDisabledByAdmin(mUserCaps.mEnforcedAdmin);\n                } else if (Flags.newMultiuserSettingsUx() && mUserCaps.mDisallowAddUser) {\n                    final List<UserManager.EnforcingUser> enforcingUsers =\n                            mUserManager.getUserRestrictionSources(UserManager.DISALLOW_ADD_USER,\n                                    UserHandle.of(UserHandle.myUserId()));\n                    if (!enforcingUsers.isEmpty()) {\n                        final UserManager.EnforcingUser enforcingUser = enforcingUsers.get(0);\n                        final int restrictionSource = enforcingUser.getUserRestrictionSource();\n                        if (restrictionSource == UserManager.RESTRICTION_SOURCE_SYSTEM) {\n                            mAddGuest.setEnabled(false);\n                        } else {\n                            mAddGuest.setVisible(false);\n                        }\n                    }\n                } else {\n                    mAddGuest.setEnabled(canSwitchUserNow() || Flags.newMultiuserSettingsUx());\n                }\n            }\n        } else {\n            mAddGuest.setVisible(false);\n        }\n        return isVisible;\n    }\n\n    private void updateAddUser(Context context) {\n        updateAddUserCommon(context, mAddUser, mUserCaps.mCanAddRestrictedProfile);\n        Drawable icon = context.getDrawable(\n                com.android.settingslib.R.drawable.ic_account_circle_filled);\n        mAddUser.setIcon(centerAndTint(icon));\n    }\n\n    private void updateAddSupervisedUser(Context context) {\n        if (!TextUtils.isEmpty(mConfigSupervisedUserCreationPackage)) {\n            updateAddUserCommon(context, mAddSupervisedUser, false);\n            Drawable icon = context.getDrawable(\n                    com.android.settingslib.R.drawable.ic_add_supervised_user);\n            mAddSupervisedUser.setIcon(centerAndTint(icon));\n        } else {\n            mAddSupervisedUser.setVisible(false);\n        }\n    }\n\n    private void updateAddUserCommon(Context context, RestrictedPreference addUser,\n            boolean canAddRestrictedProfile) {\n        if ((mUserCaps.mCanAddUser\n                && !(mUserCaps.mDisallowAddUserSetByAdmin && Flags.newMultiuserSettingsUx()))\n                && WizardManagerHelper.isDeviceProvisioned(context)\n                && (mUserCaps.mUserSwitcherEnabled || Flags.newMultiuserSettingsUx())) {\n            addUser.setVisible(true);\n            addUser.setSelectable(true);\n            final boolean canAddMoreUsers =\n                    mUserManager.canAddMoreUsers(UserManager.USER_TYPE_FULL_SECONDARY)\n                            || (canAddRestrictedProfile\n                            && mUserManager.canAddMoreUsers(UserManager.USER_TYPE_FULL_RESTRICTED));\n            addUser.setEnabled(canAddMoreUsers && !mAddingUser\n                    && (canSwitchUserNow() || Flags.newMultiuserSettingsUx()));\n\n            if (!canAddMoreUsers) {\n                addUser.setSummary(getString(R.string.user_add_max_count));\n            } else {\n                addUser.setSummary(null);\n            }\n            if (addUser.isEnabled()) {\n                addUser.setDisabledByAdmin(\n                        mUserCaps.mDisallowAddUser ? mUserCaps.mEnforcedAdmin : null);\n            }\n        } else if (Flags.newMultiuserSettingsUx() && mUserCaps.mDisallowAddUserSetByAdmin) {\n            addUser.setVisible(true);\n            addUser.setDisabledByAdmin(mUserCaps.mEnforcedAdmin);\n        } else if (Flags.newMultiuserSettingsUx() && mUserCaps.mDisallowAddUser) {\n            final List<UserManager.EnforcingUser> enforcingUsers =\n                    mUserManager.getUserRestrictionSources(UserManager.DISALLOW_ADD_USER,\n                            UserHandle.of(UserHandle.myUserId()));\n            if (!enforcingUsers.isEmpty()) {\n                final UserManager.EnforcingUser enforcingUser = enforcingUsers.get(0);\n                final int restrictionSource = enforcingUser.getUserRestrictionSource();\n                if (restrictionSource == UserManager.RESTRICTION_SOURCE_SYSTEM) {\n                    addUser.setVisible(true);\n                    addUser.setEnabled(false);\n                } else {\n                    addUser.setVisible(false);\n                }\n            }\n        } else {\n            addUser.setVisible(false);\n        }\n    }\n\n    private Drawable centerAndTint(Drawable icon) {\n        icon.setTintBlendMode(BlendMode.SRC_IN);\n        icon.setTint(getColorAttrDefaultColor(getContext(), android.R.attr.textColorPrimary));\n\n        Drawable bg = getContext().getDrawable(com.android.settingslib.R.drawable.user_avatar_bg)\n                .mutate();\n        LayerDrawable ld = new LayerDrawable(new Drawable[] {bg, icon});\n        int size = getContext().getResources().getDimensionPixelSize(\n                R.dimen.multiple_users_avatar_size);\n        int bgSize = getContext().getResources().getDimensionPixelSize(\n                R.dimen.multiple_users_user_icon_size);\n        ld.setLayerSize(1, size, size);\n        ld.setLayerSize(0, bgSize, bgSize);\n        ld.setLayerGravity(1, Gravity.CENTER);\n\n        return ld;\n    }\n\n    /**\n     * @return number of non-guest non-managed users\n     */\n    @VisibleForTesting\n    int getRealUsersCount() {\n        return (int) mUserManager.getUsers()\n                .stream()\n                .filter(user -> !user.isGuest() && !user.isProfile())\n                .count();\n    }\n\n    private void loadIconsAsync(List<Integer> missingIcons) {\n        new AsyncTask<List<Integer>, Void, Void>() {\n            @Override\n            protected void onPostExecute(Void result) {\n                updateUserList();\n            }\n\n            @Override\n            protected Void doInBackground(List<Integer>... values) {\n                for (int userId : values[0]) {\n                    Bitmap bitmap = mUserManager.getUserIcon(userId);\n                    if (bitmap == null) {\n                        bitmap = getDefaultUserIconAsBitmap(getContext().getResources(), userId);\n                    }\n                    mUserIcons.append(userId, bitmap);\n                }\n                return null;\n            }\n        }.execute(missingIcons);\n    }\n\n    private Drawable getEncircledDefaultIcon() {\n        if (mDefaultIconDrawable == null) {\n            mDefaultIconDrawable = encircleUserIcon(\n                    getDefaultUserIconAsBitmap(getContext().getResources(), UserHandle.USER_NULL));\n        }\n        return mDefaultIconDrawable;\n    }\n\n    private void setPhotoId(Preference pref, UserInfo user) {\n        Bitmap bitmap = mUserIcons.get(user.id);\n        if (bitmap != null) {\n            pref.setIcon(encircleUserIcon(bitmap));\n        }\n    }\n\n    @Override\n    public boolean onPreferenceClick(Preference pref) {\n        mMetricsFeatureProvider.logSettingsTileClick(pref.getKey(), getMetricsCategory());\n        if (isCurrentUserGuest()) {\n            if (mGuestResetPreference != null && pref == mGuestResetPreference) {\n                showDialog(DIALOG_CONFIRM_RESET_AND_RESTART_GUEST);\n                return true;\n            }\n            if (mGuestExitPreference != null && pref == mGuestExitPreference) {\n                if (mUserCaps.mIsEphemeral) {\n                    showDialog(DIALOG_CONFIRM_EXIT_GUEST_EPHEMERAL);\n                } else {\n                    showDialog(DIALOG_CONFIRM_EXIT_GUEST_NON_EPHEMERAL);\n                }\n                return true;\n            }\n        }\n        if (pref == mMePreference) {\n            if (!isCurrentUserGuest()) {\n                showDialog(DIALOG_USER_PROFILE_EDITOR);\n                return true;\n            }\n        } else if (pref instanceof UserPreference) {\n            UserInfo userInfo = mUserManager.getUserInfo(((UserPreference) pref).getUserId());\n            openUserDetails(userInfo, false);\n            return true;\n        } else if (pref == mAddUser) {\n            mMetricsFeatureProvider.action(getActivity(), SettingsEnums.ACTION_USER_ADD);\n            // If we allow both types, show a picker, otherwise directly go to\n            // flow for full user.\n            if (mUserCaps.mCanAddRestrictedProfile) {\n                showDialog(DIALOG_CHOOSE_USER_TYPE);\n            } else {\n                onAddUserClicked(USER_TYPE_USER);\n            }\n            return true;\n        } else if (pref == mAddSupervisedUser) {\n            mMetricsFeatureProvider.action(getActivity(), SettingsEnums.ACTION_USER_SUPERVISED_ADD);\n            Trace.beginSection(\"UserSettings.addSupervisedUser\");\n            onAddSupervisedUserClicked();\n            Trace.endSection();\n            return true;\n        } else if (pref == mAddGuest) {\n            mAddGuest.setEnabled(false); // prevent multiple tap issue\n            onAddGuestClicked();\n            return true;\n        }\n        return false;\n    }\n\n    private Drawable encircleUserIcon(Bitmap icon) {\n        return new CircleFramedDrawable(\n                icon,\n                getActivity().getResources().getDimensionPixelSize(\n                        R.dimen.multiple_users_user_icon_size));\n    }\n\n    @Override\n    public void onDismiss(DialogInterface dialog) {\n        synchronized (mUserLock) {\n            mRemovingUserId = -1;\n            updateUserList();\n            if (mCreateUserDialogController.isActive()) {\n                mCreateUserDialogController.finish();\n            }\n        }\n    }\n\n    @Override\n    public int getHelpResource() {\n        return R.string.help_url_users;\n    }\n\n    /**\n     * Returns a default user icon (as a {@link Bitmap}) for the given user.\n     *\n     * Note that for guest users, you should pass in {@code UserHandle.USER_NULL}.\n     *\n     * @param resources resources object to fetch the user icon.\n     * @param userId    the user id or {@code UserHandle.USER_NULL} for a non-user specific icon\n     */\n    private static Bitmap getDefaultUserIconAsBitmap(Resources resources, int userId) {\n        Bitmap bitmap = null;\n        // Try finding the corresponding bitmap in the dark bitmap cache\n        bitmap = sDarkDefaultUserBitmapCache.get(userId);\n        if (bitmap == null) {\n            bitmap = UserIcons.convertToBitmapAtUserIconSize(resources,\n                    UserIcons.getDefaultUserIcon(resources, userId, false));\n            // Save it to cache\n            sDarkDefaultUserBitmapCache.put(userId, bitmap);\n        }\n        return bitmap;\n    }\n\n    /**\n     * Assign the default photo to user with {@paramref userId}\n     *\n     * @param context used to get the {@link UserManager}\n     * @param userId  used to get the icon bitmap\n     * @return true if assign photo successfully, false if failed\n     */\n    @VisibleForTesting\n    static boolean assignDefaultPhoto(Context context, int userId) {\n        if (context == null) {\n            return false;\n        }\n        UserManager um = (UserManager) context.getSystemService(Context.USER_SERVICE);\n        Bitmap bitmap = getDefaultUserIconAsBitmap(context.getResources(), userId);\n        um.setUserIcon(userId, bitmap);\n\n        return true;\n    }\n\n    @WorkerThread\n    static void copyMeProfilePhoto(Context context, UserInfo user) {\n        Uri contactUri = ContactsContract.Profile.CONTENT_URI;\n\n        int userId = user != null ? user.id : UserHandle.myUserId();\n\n        InputStream avatarDataStream = ContactsContract.Contacts.openContactPhotoInputStream(\n                context.getContentResolver(),\n                contactUri, true);\n        // If there's no profile photo, assign a default avatar\n        if (avatarDataStream == null) {\n            assignDefaultPhoto(context, userId);\n            return;\n        }\n\n        UserManager um = (UserManager) context.getSystemService(Context.USER_SERVICE);\n        Bitmap decodedIcon = BitmapFactory.decodeStream(avatarDataStream);\n        CircleFramedDrawable drawable = CircleFramedDrawable.getInstance(context, decodedIcon);\n        Bitmap icon = UserIcons.convertToBitmapAtUserIconSize(context.getResources(), drawable);\n\n        um.setUserIcon(userId, icon);\n        try {\n            avatarDataStream.close();\n        } catch (IOException ioe) {\n        }\n    }\n\n    public static final BaseSearchIndexProvider SEARCH_INDEX_DATA_PROVIDER =\n            new BaseSearchIndexProvider(R.xml.user_settings) {\n\n                @Override\n                protected boolean isPageSearchEnabled(Context context) {\n                    final UserCapabilities userCaps = UserCapabilities.create(context);\n                    return userCaps.mEnabled;\n                }\n\n                @Override\n                public List<SearchIndexableRaw> getRawDataToIndex(Context context,\n                        boolean enabled) {\n                    final List<SearchIndexableRaw> rawData = new ArrayList<>();\n                    if (!UserManager.supportsMultipleUsers()) {\n                        return rawData;\n                    }\n\n                    SearchIndexableRaw multipleUsersData = new SearchIndexableRaw(context);\n                    multipleUsersData.key = KEY_USER_SETTINGS_SCREEN;\n                    multipleUsersData.title =\n                            context.getString(R.string.user_settings_title);\n                    multipleUsersData.keywords =\n                            context.getString(R.string.multiple_users_title_keywords);\n                    multipleUsersData.screenTitle =\n                            context.getString(R.string.user_settings_title);\n                    rawData.add(multipleUsersData);\n\n                    SearchIndexableRaw allowMultipleUsersResult = new SearchIndexableRaw(context);\n\n                    allowMultipleUsersResult.key = KEY_ALLOW_MULTIPLE_USERS;\n                    allowMultipleUsersResult.title =\n                            context.getString(R.string.multiple_users_main_switch_title);\n                    allowMultipleUsersResult.keywords =\n                            context.getString(R.string.multiple_users_main_switch_keywords);\n                    allowMultipleUsersResult.screenTitle =\n                            context.getString(R.string.user_settings_title);\n                    allowMultipleUsersResult.className =\n                            MultiUserSwitchBarController.class.getName();\n\n                    rawData.add(allowMultipleUsersResult);\n\n                    SearchIndexableRaw addUserData = new SearchIndexableRaw(context);\n                    addUserData.key = KEY_ADD_USER;\n\n                    // Dynamically set the title of addUser preference\n                    final UserCapabilities userCaps = UserCapabilities.create(context);\n                    if (!userCaps.mCanAddRestrictedProfile) {\n                        addUserData.title = context.getString(\n                                com.android.settingslib.R.string.user_add_user);\n                    } else {\n                        addUserData.title = context.getString(\n                                R.string.user_add_user_or_profile_menu);\n                    }\n                    addUserData.screenTitle = context.getString(R.string.user_settings_title);\n                    addUserData.iconResId = R.drawable.ic_add_40dp;\n\n                    rawData.add(addUserData);\n\n                    return rawData;\n                }\n\n                @Override\n                public List<String> getNonIndexableKeysFromXml(Context context, int xmlResId,\n                        boolean suppressAllPage) {\n                    final List<String> niks = super.getNonIndexableKeysFromXml(context, xmlResId,\n                            suppressAllPage);\n                    if (TextUtils.isEmpty(context.getString(\n                            com.android.internal.R.string.config_supervisedUserCreationPackage))) {\n                        niks.add(KEY_ADD_SUPERVISED_USER);\n                    }\n                    AddUserWhenLockedPreferenceController controller =\n                            new AddUserWhenLockedPreferenceController(\n                                    context, KEY_ADD_USER_WHEN_LOCKED);\n                    controller.updateNonIndexableKeys(niks);\n                    new AutoSyncDataPreferenceController(context, null /* parent */)\n                            .updateNonIndexableKeys(niks);\n                    new AutoSyncPersonalDataPreferenceController(context, null /* parent */)\n                            .updateNonIndexableKeys(niks);\n                    new AutoSyncWorkDataPreferenceController(context, null /* parent */)\n                            .updateNonIndexableKeys(niks);\n                    if (suppressAllPage) {\n                        niks.add(KEY_ALLOW_MULTIPLE_USERS);\n                    }\n                    return niks;\n                }\n            };\n}\n```",
                        "downstream_file_content": "```java\n/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.settings.users;\n\nimport static com.android.settingslib.Utils.getColorAttrDefaultColor;\n\nimport android.app.Activity;\nimport android.app.ActivityManager;\nimport android.app.Dialog;\nimport android.app.admin.DevicePolicyManager;\nimport android.app.settings.SettingsEnums;\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.SharedPreferences;\nimport android.content.pm.UserInfo;\nimport android.content.res.Resources;\nimport android.graphics.Bitmap;\nimport android.graphics.BitmapFactory;\nimport android.graphics.BlendMode;\nimport android.graphics.drawable.Drawable;\nimport android.graphics.drawable.LayerDrawable;\nimport android.net.Uri;\nimport android.os.AsyncTask;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.Message;\nimport android.os.Process;\nimport android.os.RemoteException;\nimport android.os.Trace;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.provider.ContactsContract;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.util.SparseArray;\nimport android.view.Gravity;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.widget.SimpleAdapter;\nimport android.widget.Toast;\n\nimport androidx.annotation.VisibleForTesting;\nimport androidx.annotation.WorkerThread;\nimport androidx.appcompat.app.AlertDialog;\nimport androidx.preference.Preference;\nimport androidx.preference.PreferenceGroup;\nimport androidx.preference.PreferenceScreen;\n\nimport com.android.internal.util.UserIcons;\nimport com.android.internal.widget.LockPatternUtils;\nimport com.android.settings.R;\nimport com.android.settings.SettingsActivity;\nimport com.android.settings.SettingsPreferenceFragment;\nimport com.android.settings.Utils;\nimport com.android.settings.core.SubSettingLauncher;\nimport com.android.settings.password.ChooseLockGeneric;\nimport com.android.settings.search.BaseSearchIndexProvider;\nimport com.android.settings.widget.MainSwitchBarController;\nimport com.android.settings.widget.SettingsMainSwitchBar;\nimport com.android.settingslib.RestrictedLockUtils.EnforcedAdmin;\nimport com.android.settingslib.RestrictedLockUtilsInternal;\nimport com.android.settingslib.RestrictedPreference;\nimport com.android.settingslib.drawable.CircleFramedDrawable;\nimport com.android.settingslib.search.SearchIndexable;\nimport com.android.settingslib.users.EditUserInfoController;\nimport com.android.settingslib.users.UserCreatingDialog;\nimport com.android.settingslib.utils.ThreadUtils;\n\nimport com.google.android.setupcompat.util.WizardManagerHelper;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\n/**\n * Screen that manages the list of users on the device.\n * Secondary users and a guest user can be created if there is no restriction.\n *\n * The first user in the list is always the current user.\n * Owner is the primary user.\n */\n@SearchIndexable\npublic class UserSettings extends SettingsPreferenceFragment\n        implements Preference.OnPreferenceClickListener,\n        MultiUserSwitchBarController.OnMultiUserSwitchChangedListener,\n        DialogInterface.OnDismissListener {\n\n    private static final String TAG = \"UserSettings\";\n\n    /** UserId of the user being removed */\n    private static final String SAVE_REMOVING_USER = \"removing_user\";\n\n    private static final String KEY_USER_LIST = \"user_list\";\n    private static final String KEY_USER_ME = \"user_me\";\n    private static final String KEY_USER_GUEST = \"user_guest\";\n    private static final String KEY_ADD_GUEST = \"guest_add\";\n    private static final String KEY_ADD_USER = \"user_add\";\n    private static final String KEY_ADD_SUPERVISED_USER = \"supervised_user_add\";\n    private static final String KEY_ADD_USER_WHEN_LOCKED = \"user_settings_add_users_when_locked\";\n    private static final String KEY_MULTIUSER_TOP_INTRO = \"multiuser_top_intro\";\n    private static final String KEY_TIMEOUT_TO_USER_ZERO = \"timeout_to_user_zero_preference\";\n\n    private static final int MENU_REMOVE_USER = Menu.FIRST;\n\n    private static final IntentFilter USER_REMOVED_INTENT_FILTER;\n\n    private static final int DIALOG_CONFIRM_REMOVE = 1;\n    private static final int DIALOG_ADD_USER = 2;\n    // Dialogs with id 3 and 4 got removed\n    private static final int DIALOG_USER_CANNOT_MANAGE = 5;\n    private static final int DIALOG_CHOOSE_USER_TYPE = 6;\n    private static final int DIALOG_NEED_LOCKSCREEN = 7;\n    private static final int DIALOG_CONFIRM_EXIT_GUEST = 8;\n    private static final int DIALOG_USER_PROFILE_EDITOR = 9;\n    private static final int DIALOG_USER_PROFILE_EDITOR_ADD_USER = 10;\n    private static final int DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE = 11;\n    private static final int DIALOG_CONFIRM_RESET_GUEST = 12;\n\n    private static final int MESSAGE_UPDATE_LIST = 1;\n    private static final int MESSAGE_USER_CREATED = 2;\n\n    private static final int USER_TYPE_USER = 1;\n    private static final int USER_TYPE_RESTRICTED_PROFILE = 2;\n\n    private static final int REQUEST_CHOOSE_LOCK = 10;\n    private static final int REQUEST_EDIT_GUEST = 11;\n\n    static final int RESULT_GUEST_REMOVED = 100;\n\n    private static final String KEY_ADD_USER_LONG_MESSAGE_DISPLAYED =\n            \"key_add_user_long_message_displayed\";\n\n    private static final String KEY_TITLE = \"title\";\n    private static final String KEY_SUMMARY = \"summary\";\n\n    static {\n        USER_REMOVED_INTENT_FILTER = new IntentFilter(Intent.ACTION_USER_REMOVED);\n        USER_REMOVED_INTENT_FILTER.addAction(Intent.ACTION_USER_INFO_CHANGED);\n    }\n\n    @VisibleForTesting\n    PreferenceGroup mUserListCategory;\n    @VisibleForTesting\n    UserPreference mMePreference;\n    @VisibleForTesting\n    RestrictedPreference mAddGuest;\n    @VisibleForTesting\n    RestrictedPreference mAddUser;\n    @VisibleForTesting\n    RestrictedPreference mAddSupervisedUser;\n    @VisibleForTesting\n    SparseArray<Bitmap> mUserIcons = new SparseArray<>();\n    private int mRemovingUserId = -1;\n    private boolean mAddingUser;\n    private boolean mGuestUserAutoCreated;\n    private String mConfigSupervisedUserCreationPackage;\n    private String mAddingUserName;\n    private UserCapabilities mUserCaps;\n    private boolean mShouldUpdateUserList = true;\n    private final Object mUserLock = new Object();\n    private UserManager mUserManager;\n    private static SparseArray<Bitmap> sDarkDefaultUserBitmapCache = new SparseArray<>();\n\n    private MultiUserSwitchBarController mSwitchBarController;\n    private EditUserInfoController mEditUserInfoController =\n            new EditUserInfoController(Utils.FILE_PROVIDER_AUTHORITY);\n    private AddUserWhenLockedPreferenceController mAddUserWhenLockedPreferenceController;\n    private MultiUserTopIntroPreferenceController mMultiUserTopIntroPreferenceController;\n    private TimeoutToUserZeroPreferenceController mTimeoutToUserZeroPreferenceController;\n    private UserCreatingDialog mUserCreatingDialog;\n    private final AtomicBoolean mGuestCreationScheduled = new AtomicBoolean();\n    private final ExecutorService mExecutor = Executors.newSingleThreadExecutor();\n\n    private CharSequence mPendingUserName;\n    private Drawable mPendingUserIcon;\n\n    // A place to cache the generated default avatar\n    private Drawable mDefaultIconDrawable;\n\n    // TODO:   Replace current Handler solution to something that doesn't leak memory and works\n    // TODO:   during a configuration change\n    private Handler mHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MESSAGE_UPDATE_LIST:\n                    updateUserList();\n                    break;\n                case MESSAGE_USER_CREATED:\n                    onUserCreated(msg.arg1);\n                    break;\n            }\n        }\n    };\n\n    private BroadcastReceiver mUserChangeReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            if (intent.getAction().equals(Intent.ACTION_USER_REMOVED)) {\n                mRemovingUserId = -1;\n            } else if (intent.getAction().equals(Intent.ACTION_USER_INFO_CHANGED)) {\n                int userHandle = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, -1);\n                if (userHandle != -1) {\n                    mUserIcons.remove(userHandle);\n                }\n            }\n            mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n        }\n    };\n\n    @Override\n    public int getMetricsCategory() {\n        return SettingsEnums.USER;\n    }\n\n    @Override\n    public void onActivityCreated(Bundle savedInstanceState) {\n        super.onActivityCreated(savedInstanceState);\n        // Assume we are in a SettingsActivity. This is only safe because we currently use\n        // SettingsActivity as base for all preference fragments.\n        final SettingsActivity activity = (SettingsActivity) getActivity();\n        final SettingsMainSwitchBar switchBar = activity.getSwitchBar();\n        switchBar.setTitle(getContext().getString(R.string.multiple_users_main_switch_title));\n        switchBar.show();\n        mSwitchBarController = new MultiUserSwitchBarController(activity,\n                new MainSwitchBarController(switchBar), this /* listener */);\n        getSettingsLifecycle().addObserver(mSwitchBarController);\n    }\n\n    @Override\n    public void onCreate(Bundle icicle) {\n        super.onCreate(icicle);\n        addPreferencesFromResource(R.xml.user_settings);\n        final Activity activity = getActivity();\n        if (!WizardManagerHelper.isDeviceProvisioned(activity)) {\n            activity.finish();\n            return;\n        }\n\n        mGuestUserAutoCreated = getPrefContext().getResources().getBoolean(\n                        com.android.internal.R.bool.config_guestUserAutoCreated);\n\n        mAddUserWhenLockedPreferenceController = new AddUserWhenLockedPreferenceController(\n                activity, KEY_ADD_USER_WHEN_LOCKED);\n\n        mMultiUserTopIntroPreferenceController = new MultiUserTopIntroPreferenceController(activity,\n                KEY_MULTIUSER_TOP_INTRO);\n\n        mTimeoutToUserZeroPreferenceController = new TimeoutToUserZeroPreferenceController(activity,\n                KEY_TIMEOUT_TO_USER_ZERO);\n\n        final PreferenceScreen screen = getPreferenceScreen();\n        mAddUserWhenLockedPreferenceController.displayPreference(screen);\n        mMultiUserTopIntroPreferenceController.displayPreference(screen);\n        mTimeoutToUserZeroPreferenceController.displayPreference(screen);\n\n        screen.findPreference(mAddUserWhenLockedPreferenceController.getPreferenceKey())\n                .setOnPreferenceChangeListener(mAddUserWhenLockedPreferenceController);\n\n        if (icicle != null) {\n            if (icicle.containsKey(SAVE_REMOVING_USER)) {\n                mRemovingUserId = icicle.getInt(SAVE_REMOVING_USER);\n            }\n            mEditUserInfoController.onRestoreInstanceState(icicle);\n        }\n\n        mUserCaps = UserCapabilities.create(activity);\n        mUserManager = (UserManager) activity.getSystemService(Context.USER_SERVICE);\n        if (!mUserCaps.mEnabled) {\n            return;\n        }\n\n        final int myUserId = UserHandle.myUserId();\n\n        mUserListCategory = (PreferenceGroup) findPreference(KEY_USER_LIST);\n        mMePreference = new UserPreference(getPrefContext(), null /* attrs */, myUserId);\n        mMePreference.setKey(KEY_USER_ME);\n        mMePreference.setOnPreferenceClickListener(this);\n        if (mUserCaps.mIsAdmin) {\n            mMePreference.setSummary(R.string.user_admin);\n        }\n\n        mAddGuest = findPreference(KEY_ADD_GUEST);\n        mAddGuest.setOnPreferenceClickListener(this);\n\n        mAddUser = findPreference(KEY_ADD_USER);\n        if (!mUserCaps.mCanAddRestrictedProfile) {\n            // Label should only mention adding a \"user\", not a \"profile\"\n            mAddUser.setTitle(com.android.settingslib.R.string.user_add_user);\n        }\n        mAddUser.setOnPreferenceClickListener(this);\n\n        setConfigSupervisedUserCreationPackage();\n        mAddSupervisedUser = findPreference(KEY_ADD_SUPERVISED_USER);\n        mAddSupervisedUser.setOnPreferenceClickListener(this);\n\n        activity.registerReceiverAsUser(\n                mUserChangeReceiver, UserHandle.ALL, USER_REMOVED_INTENT_FILTER, null, mHandler,\n                Context.RECEIVER_EXPORTED_UNAUDITED);\n\n        updateUI();\n        mShouldUpdateUserList = false;\n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n\n        if (!mUserCaps.mEnabled) {\n            return;\n        }\n        final PreferenceScreen screen = getPreferenceScreen();\n\n        mAddUserWhenLockedPreferenceController.updateState(screen.findPreference(\n                mAddUserWhenLockedPreferenceController.getPreferenceKey()));\n        mTimeoutToUserZeroPreferenceController.updateState(screen.findPreference(\n                mTimeoutToUserZeroPreferenceController.getPreferenceKey()));\n\n        if (mShouldUpdateUserList) {\n            updateUI();\n        }\n    }\n\n    @Override\n    public void onPause() {\n        mShouldUpdateUserList = true;\n        super.onPause();\n    }\n\n    @Override\n    public void onDestroy() {\n        super.onDestroy();\n\n        if (mUserCaps == null || !mUserCaps.mEnabled) {\n            return;\n        }\n\n        getActivity().unregisterReceiver(mUserChangeReceiver);\n    }\n\n    @Override\n    public void onSaveInstanceState(Bundle outState) {\n        mEditUserInfoController.onSaveInstanceState(outState);\n        outState.putInt(SAVE_REMOVING_USER, mRemovingUserId);\n        super.onSaveInstanceState(outState);\n    }\n\n    @Override\n    public void startActivityForResult(Intent intent, int requestCode) {\n        mEditUserInfoController.startingActivityForResult();\n        super.startActivityForResult(intent, requestCode);\n    }\n\n    @Override\n    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n        int pos = 0;\n        // TODO(b/191509236): The menu item does not need to be accessible for guest users,\n        //  regardless of mGuestUserAutoCreated\n        if (!mUserCaps.mIsAdmin && canSwitchUserNow() && !(isCurrentUserGuest()\n                && mGuestUserAutoCreated)) {\n            String nickname = mUserManager.getUserName();\n            MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                    getResources().getString(R.string.user_remove_user_menu, nickname));\n            removeThisUser.setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);\n\n            final EnforcedAdmin disallowRemoveUserAdmin =\n                    RestrictedLockUtilsInternal.checkIfRestrictionEnforced(getContext(),\n                            UserManager.DISALLOW_REMOVE_USER, UserHandle.myUserId());\n            RestrictedLockUtilsInternal.setMenuItemAsDisabledByAdmin(getContext(), removeThisUser,\n                    disallowRemoveUserAdmin);\n        }\n        super.onCreateOptionsMenu(menu, inflater);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        final int itemId = item.getItemId();\n        if (itemId == MENU_REMOVE_USER) {\n            onRemoveUserClicked(UserHandle.myUserId());\n            return true;\n        } else {\n            return super.onOptionsItemSelected(item);\n        }\n    }\n\n    @Override\n    public void onMultiUserSwitchChanged(boolean newState) {\n        updateUI();\n    }\n\n    private void updateUI() {\n        mUserCaps.updateAddUserCapabilities(getActivity());\n        loadProfile();\n        updateUserList();\n    }\n\n    /**\n     * Loads profile information for the current user.\n     */\n    private void loadProfile() {\n        if (isCurrentUserGuest()) {\n            // No need to load profile information\n            mMePreference.setIcon(getEncircledDefaultIcon());\n            mMePreference.setTitle(mGuestUserAutoCreated\n                    ? com.android.settingslib.R.string.guest_reset_guest\n                    : com.android.settingslib.R.string.guest_exit_guest);\n            mMePreference.setSelectable(true);\n            // removing a guest will result in switching back to the admin user\n            mMePreference.setEnabled(canSwitchUserNow());\n            return;\n        }\n\n        new AsyncTask<Void, Void, String>() {\n            @Override\n            protected void onPostExecute(String result) {\n                finishLoadProfile(result);\n            }\n\n            @Override\n            protected String doInBackground(Void... values) {\n                UserInfo user = mUserManager.getUserInfo(UserHandle.myUserId());\n                if (user.iconPath == null || user.iconPath.equals(\"\")) {\n                    // Assign profile photo.\n                    copyMeProfilePhoto(getActivity(), user);\n                }\n                return user.name;\n            }\n        }.execute();\n    }\n\n    private void finishLoadProfile(String profileName) {\n        if (getActivity() == null) {\n            return;\n        }\n        mMePreference.setTitle(getString(R.string.user_you, profileName));\n        int myUserId = UserHandle.myUserId();\n        Bitmap b = mUserManager.getUserIcon(myUserId);\n        if (b != null) {\n            mMePreference.setIcon(encircle(b));\n            mUserIcons.put(myUserId, b);\n        }\n    }\n\n    private boolean hasLockscreenSecurity() {\n        LockPatternUtils lpu = new LockPatternUtils(getActivity());\n        return lpu.isSecure(UserHandle.myUserId());\n    }\n\n    private void launchChooseLockscreen() {\n        Intent chooseLockIntent = new Intent(DevicePolicyManager.ACTION_SET_NEW_PASSWORD);\n        chooseLockIntent.putExtra(ChooseLockGeneric.ChooseLockGenericFragment.HIDE_INSECURE_OPTIONS,\n                true);\n        startActivityForResult(chooseLockIntent, REQUEST_CHOOSE_LOCK);\n    }\n\n    @Override\n    public void onActivityResult(int requestCode, int resultCode, Intent data) {\n        super.onActivityResult(requestCode, resultCode, data);\n\n        if (requestCode == REQUEST_CHOOSE_LOCK) {\n            if (resultCode != Activity.RESULT_CANCELED && hasLockscreenSecurity()) {\n                addUserNow(USER_TYPE_RESTRICTED_PROFILE);\n            }\n        } else if (mGuestUserAutoCreated && requestCode == REQUEST_EDIT_GUEST\n                && resultCode == RESULT_GUEST_REMOVED) {\n            scheduleGuestCreation();\n        } else {\n            mEditUserInfoController.onActivityResult(requestCode, resultCode, data);\n        }\n    }\n\n    private void onAddUserClicked(int userType) {\n        synchronized (mUserLock) {\n            if (mRemovingUserId == -1 && !mAddingUser) {\n                switch (userType) {\n                    case USER_TYPE_USER:\n                        showDialog(DIALOG_ADD_USER);\n                        break;\n                    case USER_TYPE_RESTRICTED_PROFILE:\n                        if (hasLockscreenSecurity()) {\n                            showDialog(DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE);\n                        } else {\n                            showDialog(DIALOG_NEED_LOCKSCREEN);\n                        }\n                        break;\n                }\n            }\n        }\n    }\n\n    private void onAddSupervisedUserClicked() {\n        final Intent intent = new Intent()\n                .setAction(UserManager.ACTION_CREATE_SUPERVISED_USER)\n                .setPackage(mConfigSupervisedUserCreationPackage)\n                .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n\n        startActivity(intent);\n    }\n\n    private void onAddGuestClicked() {\n        final UserCreatingDialog guestCreatingDialog =\n                new UserCreatingDialog(getActivity(), /* isGuest= */ true);\n        guestCreatingDialog.show();\n\n        ThreadUtils.postOnBackgroundThread(() -> {\n            mMetricsFeatureProvider.action(getActivity(), SettingsEnums.ACTION_USER_GUEST_ADD);\n            Trace.beginSection(\"UserSettings.addGuest\");\n            final UserInfo guest = mUserManager.createGuest(getContext());\n            Trace.endSection();\n\n            ThreadUtils.postOnMainThread(() -> {\n                guestCreatingDialog.dismiss();\n                if (guest == null) {\n                    Toast.makeText(getContext(),\n                            com.android.settingslib.R.string.add_guest_failed,\n                            Toast.LENGTH_SHORT).show();\n                    return;\n                }\n                openUserDetails(guest, true);\n            });\n        });\n    }\n\n    private void onRemoveUserClicked(int userId) {\n        synchronized (mUserLock) {\n            if (mRemovingUserId == -1 && !mAddingUser) {\n                mRemovingUserId = userId;\n                showDialog(DIALOG_CONFIRM_REMOVE);\n            }\n        }\n    }\n\n    private void onUserCreated(int userId) {\n        hideUserCreatingDialog();\n        // prevent crash when config changes during user creation\n        if (getContext() == null) {\n            return;\n        }\n        mAddingUser = false;\n        UserInfo userInfo = mUserManager.getUserInfo(userId);\n        openUserDetails(userInfo, true);\n    }\n\n    private void hideUserCreatingDialog() {\n        if (mUserCreatingDialog != null && mUserCreatingDialog.isShowing()) {\n            mUserCreatingDialog.dismiss();\n        }\n    }\n\n    private void onUserCreationFailed() {\n        Toast.makeText(getContext(),\n                com.android.settingslib.R.string.add_user_failed,\n                Toast.LENGTH_SHORT).show();\n        hideUserCreatingDialog();\n    }\n\n    private void openUserDetails(UserInfo userInfo, boolean newUser) {\n        Bundle extras = new Bundle();\n        extras.putInt(UserDetailsSettings.EXTRA_USER_ID, userInfo.id);\n        extras.putBoolean(AppRestrictionsFragment.EXTRA_NEW_USER, newUser);\n\n        SubSettingLauncher launcher = new SubSettingLauncher(getContext())\n                .setDestination(UserDetailsSettings.class.getName())\n                .setArguments(extras)\n                .setTitleText(userInfo.name)\n                .setSourceMetricsCategory(getMetricsCategory());\n        if (mGuestUserAutoCreated && userInfo.isGuest()) {\n            launcher.setResultListener(this, REQUEST_EDIT_GUEST);\n        }\n        launcher.launch();\n    }\n\n    @Override\n    public void onDialogShowing() {\n        super.onDialogShowing();\n\n        setOnDismissListener(this);\n    }\n\n    @Override\n    public Dialog onCreateDialog(int dialogId) {\n        Context context = getActivity();\n        if (context == null) {\n            return null;\n        }\n        switch (dialogId) {\n            case DIALOG_CONFIRM_REMOVE: {\n                Dialog dlg =\n                        UserDialogs.createRemoveDialog(getActivity(), mRemovingUserId,\n                                new DialogInterface.OnClickListener() {\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        removeUserNow();\n                                    }\n                                }\n                        );\n                return dlg;\n            }\n            case DIALOG_USER_CANNOT_MANAGE:\n                return new AlertDialog.Builder(context)\n                        .setMessage(R.string.user_cannot_manage_message)\n                        .setPositiveButton(android.R.string.ok, null)\n                        .create();\n            case DIALOG_ADD_USER: {\n                final SharedPreferences preferences = getActivity().getPreferences(\n                        Context.MODE_PRIVATE);\n                final boolean longMessageDisplayed = preferences.getBoolean(\n                        KEY_ADD_USER_LONG_MESSAGE_DISPLAYED, false);\n                final int messageResId = longMessageDisplayed\n                        ? com.android.settingslib.R.string.user_add_user_message_short\n                        : com.android.settingslib.R.string.user_add_user_message_long;\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setTitle(com.android.settingslib.R.string.user_add_user_title)\n                        .setMessage(messageResId)\n                        .setPositiveButton(android.R.string.ok,\n                                new DialogInterface.OnClickListener() {\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        showDialog(DIALOG_USER_PROFILE_EDITOR_ADD_USER);\n                                        if (!longMessageDisplayed) {\n                                            preferences.edit().putBoolean(\n                                                    KEY_ADD_USER_LONG_MESSAGE_DISPLAYED,\n                                                    true).apply();\n                                        }\n                                    }\n                                })\n                        .setNegativeButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            case DIALOG_CHOOSE_USER_TYPE: {\n                List<HashMap<String, String>> data = new ArrayList<HashMap<String, String>>();\n                HashMap<String, String> addUserItem = new HashMap<String, String>();\n                addUserItem.put(KEY_TITLE, getString(\n                        com.android.settingslib.R.string.user_add_user_item_title));\n                addUserItem.put(KEY_SUMMARY, getString(\n                        com.android.settingslib.R.string.user_add_user_item_summary));\n                HashMap<String, String> addProfileItem = new HashMap<String, String>();\n                addProfileItem.put(KEY_TITLE, getString(\n                        com.android.settingslib.R.string.user_add_profile_item_title));\n                addProfileItem.put(KEY_SUMMARY, getString(\n                        com.android.settingslib.R.string.user_add_profile_item_summary));\n                data.add(addUserItem);\n                data.add(addProfileItem);\n                AlertDialog.Builder builder = new AlertDialog.Builder(context);\n                SimpleAdapter adapter = new SimpleAdapter(builder.getContext(),\n                        data, R.layout.two_line_list_item,\n                        new String[]{KEY_TITLE, KEY_SUMMARY},\n                        new int[]{R.id.title, R.id.summary});\n                builder.setTitle(com.android.settingslib.R.string.user_add_user_type_title);\n                builder.setAdapter(adapter,\n                        new DialogInterface.OnClickListener() {\n                            @Override\n                            public void onClick(DialogInterface dialog, int which) {\n                                onAddUserClicked(which == 0\n                                        ? USER_TYPE_USER\n                                        : USER_TYPE_RESTRICTED_PROFILE);\n                            }\n                        });\n                return builder.create();\n            }\n            case DIALOG_NEED_LOCKSCREEN: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setMessage(com.android.settingslib.R.string.user_need_lock_message)\n                        .setPositiveButton(com.android.settingslib.R.string.user_set_lock_button,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        launchChooseLockscreen();\n                                    }\n                                })\n                        .setNegativeButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            case DIALOG_CONFIRM_EXIT_GUEST: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setTitle(com.android.settingslib.R.string.guest_remove_guest_dialog_title)\n                        .setMessage(R.string.user_exit_guest_confirm_message)\n                        .setPositiveButton(R.string.user_exit_guest_dialog_remove,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        exitGuest();\n                                    }\n                                })\n                        .setNegativeButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            case DIALOG_USER_PROFILE_EDITOR: {\n                return buildEditCurrentUserDialog();\n            }\n            case DIALOG_USER_PROFILE_EDITOR_ADD_USER: {\n                synchronized (mUserLock) {\n                    mPendingUserName = getString(\n                            com.android.settingslib.R.string.user_new_user_name);\n                    mPendingUserIcon = null;\n                }\n                return buildAddUserDialog(USER_TYPE_USER);\n            }\n            case DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE: {\n                synchronized (mUserLock) {\n                    mPendingUserName = getString(\n                            com.android.settingslib.R.string.user_new_profile_name);\n                    mPendingUserIcon = null;\n                }\n                return buildAddUserDialog(USER_TYPE_RESTRICTED_PROFILE);\n            }\n            case DIALOG_CONFIRM_RESET_GUEST: {\n                if (mGuestUserAutoCreated) {\n                    return UserDialogs.createResetGuestDialog(getActivity(),\n                        (dialog, which) -> resetGuest());\n                } else {\n                    return UserDialogs.createRemoveGuestDialog(getActivity(),\n                        (dialog, which) -> resetGuest());\n                }\n            }\n            default:\n                return null;\n        }\n    }\n\n    private Dialog buildEditCurrentUserDialog() {\n        final Activity activity = getActivity();\n        if (activity == null) {\n            return null;\n        }\n\n        UserInfo user = mUserManager.getUserInfo(Process.myUserHandle().getIdentifier());\n        Drawable userIcon = Utils.getUserIcon(activity, mUserManager, user);\n\n        return mEditUserInfoController.createDialog(\n                activity,\n                this::startActivityForResult,\n                userIcon,\n                user.name,\n                getString(com.android.settingslib.R.string.profile_info_settings_title),\n                (newUserName, newUserIcon) -> {\n                    if (newUserIcon != userIcon) {\n                        ThreadUtils.postOnBackgroundThread(() ->\n                                mUserManager.setUserIcon(user.id,\n                                        UserIcons.convertToBitmapAtUserIconSize(\n                                                activity.getResources(), newUserIcon)));\n                        mMePreference.setIcon(newUserIcon);\n                    }\n\n                    if (!TextUtils.isEmpty(newUserName) && !newUserName.equals(user.name)) {\n                        mMePreference.setTitle(newUserName);\n                        mUserManager.setUserName(user.id, newUserName);\n                    }\n                }, null);\n    }\n\n    private Dialog buildAddUserDialog(int userType) {\n        Dialog d;\n        synchronized (mUserLock) {\n            d = mEditUserInfoController.createDialog(\n                    getActivity(),\n                    this::startActivityForResult,\n                    null,\n                    mPendingUserName.toString(),\n                    getString(userType == USER_TYPE_USER\n                            ? com.android.settingslib.R.string.user_info_settings_title\n                            : com.android.settingslib.R.string.profile_info_settings_title),\n                    (userName, userIcon) -> {\n                        mPendingUserIcon = userIcon;\n                        mPendingUserName = userName;\n                        addUserNow(userType);\n                    },\n                    () -> {\n                        synchronized (mUserLock) {\n                            mPendingUserIcon = null;\n                            mPendingUserName = null;\n                        }\n                    }\n            );\n        }\n        return d;\n    }\n\n    @Override\n    public int getDialogMetricsCategory(int dialogId) {\n        switch (dialogId) {\n            case DIALOG_CONFIRM_REMOVE:\n                return SettingsEnums.DIALOG_USER_REMOVE;\n            case DIALOG_USER_CANNOT_MANAGE:\n                return SettingsEnums.DIALOG_USER_CANNOT_MANAGE;\n            case DIALOG_ADD_USER:\n                return SettingsEnums.DIALOG_USER_ADD;\n            case DIALOG_CHOOSE_USER_TYPE:\n                return SettingsEnums.DIALOG_USER_CHOOSE_TYPE;\n            case DIALOG_NEED_LOCKSCREEN:\n                return SettingsEnums.DIALOG_USER_NEED_LOCKSCREEN;\n            case DIALOG_CONFIRM_EXIT_GUEST:\n            case DIALOG_CONFIRM_RESET_GUEST:\n                return SettingsEnums.DIALOG_USER_CONFIRM_EXIT_GUEST;\n            case DIALOG_USER_PROFILE_EDITOR:\n            case DIALOG_USER_PROFILE_EDITOR_ADD_USER:\n            case DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE:\n                return SettingsEnums.DIALOG_USER_EDIT_PROFILE;\n            default:\n                return 0;\n        }\n    }\n\n    private void removeUserNow() {\n        if (mRemovingUserId == UserHandle.myUserId()) {\n            removeThisUser();\n        } else {\n            ThreadUtils.postOnBackgroundThread(new Runnable() {\n                @Override\n                public void run() {\n                    synchronized (mUserLock) {\n                        mUserManager.removeUser(mRemovingUserId);\n                        mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n                    }\n                }\n            });\n        }\n    }\n\n    private void removeThisUser() {\n        if (!canSwitchUserNow()) {\n            Log.w(TAG, \"Cannot remove current user when switching is disabled\");\n            return;\n        }\n        try {\n            getContext().getSystemService(UserManager.class)\n                    .removeUserWhenPossible(UserHandle.of(UserHandle.myUserId()),\n                            /* overrideDevicePolicy= */ false);\n            ActivityManager.getService().switchUser(UserHandle.USER_SYSTEM);\n        } catch (RemoteException re) {\n            Log.e(TAG, \"Unable to remove self user\");\n        }\n    }\n\n    private void addUserNow(final int userType) {\n        Trace.beginAsyncSection(\"UserSettings.addUserNow\", 0);\n        synchronized (mUserLock) {\n            mAddingUser = true;\n            mAddingUserName = userType == USER_TYPE_USER\n                    ? (mPendingUserName != null ? mPendingUserName.toString()\n                    : getString(R.string.user_new_user_name))\n                    : (mPendingUserName != null ? mPendingUserName.toString()\n                            : getString(R.string.user_new_profile_name));\n        }\n\n        mUserCreatingDialog = new UserCreatingDialog(getActivity());\n        mUserCreatingDialog.show();\n        ThreadUtils.postOnBackgroundThread(new AddUserNowImpl(userType, mAddingUserName));\n    }\n\n    @VisibleForTesting\n    class AddUserNowImpl implements Runnable{\n        int mUserType;\n        String mImplAddUserName;\n\n        AddUserNowImpl(final int userType, final String addUserName) {\n            mUserType = userType;\n            mImplAddUserName = addUserName;\n        }\n\n        @Override\n        public void run() {\n            runAddUser();\n            Trace.endAsyncSection(\"UserSettings.addUserNow\", 0);\n        }\n\n        private void runAddUser() {\n            UserInfo user;\n            String username;\n\n            synchronized (mUserLock) {\n                username = mImplAddUserName;\n            }\n\n            // Could take a few seconds\n            if (mUserType == USER_TYPE_USER) {\n                user = mUserManager.createUser(username, 0);\n            } else {\n                user = mUserManager.createRestrictedProfile(username);\n            }\n\n            synchronized (mUserLock) {\n                if (user == null) {\n                    mAddingUser = false;\n                    mPendingUserIcon = null;\n                    mPendingUserName = null;\n                    ThreadUtils.postOnMainThread(() -> onUserCreationFailed());\n                    return;\n                }\n\n                Drawable newUserIcon = mPendingUserIcon;\n                if (newUserIcon == null) {\n                    newUserIcon = UserIcons.getDefaultUserIcon(getResources(), user.id, false);\n                }\n                mUserManager.setUserIcon(\n                        user.id, UserIcons.convertToBitmapAtUserIconSize(\n                                getResources(), newUserIcon));\n\n                if (mUserType == USER_TYPE_USER) {\n                    mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n                }\n\n                mHandler.sendMessage(mHandler.obtainMessage(\n                        MESSAGE_USER_CREATED, user.id, user.serialNumber));\n\n                mPendingUserIcon = null;\n                mPendingUserName = null;\n            }\n        }\n    };\n\n    /**\n     * Erase the current user (guest) and switch to another user.\n     */\n    @VisibleForTesting\n    void exitGuest() {\n        // Just to be safe\n        if (!isCurrentUserGuest()) {\n            return;\n        }\n        mMetricsFeatureProvider.action(getActivity(),\n                SettingsEnums.ACTION_USER_GUEST_EXIT_CONFIRMED);\n        removeThisUser();\n    }\n\n    /**\n     * Erase the current user (assuming it is a guest user), and create a new one in the background\n     */\n    @VisibleForTesting\n    void resetGuest() {\n        // Just to be safe\n        if (!isCurrentUserGuest()) {\n            return;\n        }\n        int guestUserId = UserHandle.myUserId();\n        // Using markGuestForDeletion allows us to create a new guest before this one is\n        // fully removed. This could happen if someone calls scheduleGuestCreation()\n        // immediately after calling this method.\n        boolean marked = mUserManager.markGuestForDeletion(guestUserId);\n        if (!marked) {\n            Log.w(TAG, \"Couldn't mark the guest for deletion for user \" + guestUserId);\n            return;\n        }\n        exitGuest();\n        scheduleGuestCreation();\n    }\n\n    /**\n     * Create a guest user in the background\n     */\n    @VisibleForTesting\n    void scheduleGuestCreation() {\n        // TODO(b/191067027): Move guest recreation to system_server\n        if (mGuestCreationScheduled.compareAndSet(/* expect= */ false, /* update= */ true)) {\n            // Once mGuestCreationScheduled=true, mAddGuest needs to be updated so that it shows\n            // \"Resetting guest...\"\n            mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n            mExecutor.execute(() -> {\n                UserInfo guest = mUserManager.createGuest(getContext());\n                mGuestCreationScheduled.set(false);\n                if (guest == null) {\n                    Log.e(TAG, \"Unable to automatically recreate guest user\");\n                }\n                // The list needs to be updated whether or not guest creation worked. If guest\n                // creation failed, the list needs to update so that \"Add guest\" is displayed.\n                // Otherwise, the UX could be stuck in a state where there is no way to switch to\n                // the guest user (e.g. Guest would not be selectable, and it would be stuck\n                // saying \"Resetting guest...\")\n                mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n            });\n        }\n    }\n\n    @VisibleForTesting\n    void updateUserList() {\n        final Context context = getActivity();\n        if (context == null) {\n            return;\n        }\n        final List<UserInfo> users = mUserManager.getAliveUsers();\n\n        final ArrayList<Integer> missingIcons = new ArrayList<>();\n        final ArrayList<UserPreference> userPreferences = new ArrayList<>();\n        userPreferences.add(mMePreference);\n\n        boolean canOpenUserDetails =\n                mUserCaps.mIsAdmin || (canSwitchUserNow() && !mUserCaps.mDisallowSwitchUser);\n        for (UserInfo user : users) {\n            if (!user.supportsSwitchToByUser()) {\n                // Only users that can be switched to should show up here.\n                // e.g. Managed profiles appear under Accounts Settings instead\n                continue;\n            }\n            UserPreference pref;\n            if (user.id == UserHandle.myUserId()) {\n                pref = mMePreference;\n            } else {\n                pref = new UserPreference(getPrefContext(), null, user.id);\n                pref.setTitle(user.name);\n                userPreferences.add(pref);\n                pref.setOnPreferenceClickListener(this);\n                pref.setEnabled(canOpenUserDetails);\n                pref.setSelectable(true);\n\n                if (user.isGuest()) {\n                    pref.setIcon(getEncircledDefaultIcon());\n                    pref.setKey(KEY_USER_GUEST);\n                    if (mUserCaps.mDisallowSwitchUser) {\n                        pref.setDisabledByAdmin(\n                                RestrictedLockUtilsInternal.getDeviceOwner(context));\n                    } else {\n                        pref.setDisabledByAdmin(null);\n                    }\n                } else {\n                    pref.setKey(\"id=\" + user.id);\n                    if (user.isAdmin()) {\n                        pref.setSummary(R.string.user_admin);\n                    }\n                }\n            }\n            if (pref == null) {\n                continue;\n            }\n            if (user.id != UserHandle.myUserId() && !user.isGuest() && !user.isInitialized()) {\n                // sometimes after creating a guest the initialized flag isn't immediately set\n                // and we don't want to show \"Not set up\" summary for them\n                if (user.isRestricted()) {\n                    pref.setSummary(R.string.user_summary_restricted_not_set_up);\n                } else {\n                    pref.setSummary(R.string.user_summary_not_set_up);\n                    // Disallow setting up user which results in user switching when the\n                    // restriction is set.\n                    pref.setEnabled(!mUserCaps.mDisallowSwitchUser && canSwitchUserNow());\n                }\n            } else if (user.isRestricted()) {\n                pref.setSummary(R.string.user_summary_restricted_profile);\n            }\n            if (user.iconPath != null) {\n                if (mUserIcons.get(user.id) == null) {\n                    // Icon not loaded yet, print a placeholder\n                    missingIcons.add(user.id);\n                    pref.setIcon(getEncircledDefaultIcon());\n                } else {\n                    setPhotoId(pref, user);\n                }\n            } else {\n                // Icon not available yet, print a placeholder\n                pref.setIcon(getEncircledDefaultIcon());\n            }\n        }\n\n        // Add a temporary entry for the user being created\n        if (mAddingUser) {\n            UserPreference pref = new UserPreference(getPrefContext(), null,\n                    UserPreference.USERID_UNKNOWN);\n            pref.setEnabled(false);\n            pref.setTitle(mAddingUserName);\n            pref.setIcon(getEncircledDefaultIcon());\n            userPreferences.add(pref);\n        }\n\n\n        // Sort list of users by serialNum\n        Collections.sort(userPreferences, UserPreference.SERIAL_NUMBER_COMPARATOR);\n\n        getActivity().invalidateOptionsMenu();\n\n        // Load the icons\n        if (missingIcons.size() > 0) {\n            loadIconsAsync(missingIcons);\n        }\n\n        // If profiles are supported, mUserListCategory will have a special title\n        if (mUserCaps.mCanAddRestrictedProfile) {\n            mUserListCategory.setTitle(R.string.user_list_title);\n        } else {\n            mUserListCategory.setTitle(null);\n            mUserListCategory.setLayoutResource(R.layout.empty_view);\n        }\n\n        // Remove everything from mUserListCategory and add new users.\n        mUserListCategory.removeAll();\n\n        // If multi-user is disabled, just show top info and return.\n        final Preference addUserOnLockScreen = getPreferenceScreen().findPreference(\n                mAddUserWhenLockedPreferenceController.getPreferenceKey());\n        mAddUserWhenLockedPreferenceController.updateState(addUserOnLockScreen);\n\n        final Preference multiUserTopIntroPrefence = getPreferenceScreen().findPreference(\n                mMultiUserTopIntroPreferenceController.getPreferenceKey());\n        mMultiUserTopIntroPreferenceController.updateState(multiUserTopIntroPrefence);\n        mUserListCategory.setVisible(mUserCaps.mUserSwitcherEnabled);\n\n        updateAddGuest(context, users.stream().anyMatch(UserInfo::isGuest));\n        updateAddUser(context);\n        updateAddSupervisedUser(context);\n\n        if (!mUserCaps.mUserSwitcherEnabled) {\n            return;\n        }\n\n        for (UserPreference userPreference : userPreferences) {\n            userPreference.setOrder(Preference.DEFAULT_ORDER);\n            mUserListCategory.addPreference(userPreference);\n        }\n\n    }\n\n    @VisibleForTesting\n    void setConfigSupervisedUserCreationPackage() {\n        mConfigSupervisedUserCreationPackage = getPrefContext().getString(\n                com.android.internal.R.string.config_supervisedUserCreationPackage);\n    }\n\n    private boolean isCurrentUserGuest() {\n        return mUserCaps.mIsGuest;\n    }\n\n    private boolean canSwitchUserNow() {\n        return mUserManager.getUserSwitchability() == UserManager.SWITCHABILITY_STATUS_OK;\n    }\n\n    private void updateAddGuest(Context context, boolean isGuestAlreadyCreated) {\n        if (!isGuestAlreadyCreated && mUserCaps.mCanAddGuest\n                && mUserManager.canAddMoreUsers(UserManager.USER_TYPE_FULL_GUEST)\n                && WizardManagerHelper.isDeviceProvisioned(context)\n                && mUserCaps.mUserSwitcherEnabled) {\n            mAddGuest.setVisible(true);\n            Drawable icon = context.getDrawable(R.drawable.ic_account_circle);\n            mAddGuest.setIcon(centerAndTint(icon));\n            mAddGuest.setSelectable(true);\n            if (mGuestUserAutoCreated && mGuestCreationScheduled.get()) {\n                mAddGuest.setTitle(com.android.internal.R.string.guest_name);\n                mAddGuest.setSummary(R.string.guest_resetting);\n                mAddGuest.setEnabled(false);\n            } else {\n                mAddGuest.setTitle(com.android.settingslib.R.string.guest_new_guest);\n                mAddGuest.setEnabled(canSwitchUserNow());\n            }\n        } else {\n            mAddGuest.setVisible(false);\n        }\n    }\n\n    private void updateAddUser(Context context) {\n        updateAddUserCommon(context, mAddUser, mUserCaps.mCanAddRestrictedProfile);\n        Drawable icon = context.getDrawable(R.drawable.ic_account_circle_filled);\n        mAddUser.setIcon(centerAndTint(icon));\n    }\n\n    private void updateAddSupervisedUser(Context context) {\n        if (!TextUtils.isEmpty(mConfigSupervisedUserCreationPackage)) {\n            updateAddUserCommon(context, mAddSupervisedUser, false);\n            Drawable icon = context.getDrawable(R.drawable.ic_add_supervised_user);\n            mAddSupervisedUser.setIcon(centerAndTint(icon));\n        } else {\n            mAddSupervisedUser.setVisible(false);\n        }\n    }\n\n    private void updateAddUserCommon(Context context, RestrictedPreference addUser,\n            boolean canAddRestrictedProfile) {\n        if ((mUserCaps.mCanAddUser || mUserCaps.mDisallowAddUserSetByAdmin)\n                && WizardManagerHelper.isDeviceProvisioned(context)\n                && mUserCaps.mUserSwitcherEnabled) {\n            addUser.setVisible(true);\n            addUser.setSelectable(true);\n            final boolean canAddMoreUsers =\n                    mUserManager.canAddMoreUsers(UserManager.USER_TYPE_FULL_SECONDARY)\n                            || (canAddRestrictedProfile\n                            && mUserManager.canAddMoreUsers(UserManager.USER_TYPE_FULL_RESTRICTED));\n            addUser.setEnabled(canAddMoreUsers && !mAddingUser && canSwitchUserNow());\n\n            if (!canAddMoreUsers) {\n                addUser.setSummary(getString(R.string.user_add_max_count));\n            } else {\n                addUser.setSummary(null);\n            }\n            if (addUser.isEnabled()) {\n                addUser.setDisabledByAdmin(\n                        mUserCaps.mDisallowAddUser ? mUserCaps.mEnforcedAdmin : null);\n            }\n        } else {\n            addUser.setVisible(false);\n        }\n    }\n\n    private Drawable centerAndTint(Drawable icon) {\n        icon.setTintBlendMode(BlendMode.SRC_IN);\n        icon.setTint(getColorAttrDefaultColor(getContext(), android.R.attr.textColorPrimary));\n\n        Drawable bg = getContext().getDrawable(R.drawable.user_avatar_bg).mutate();\n        LayerDrawable ld = new LayerDrawable(new Drawable[] {bg, icon});\n        int size = getContext().getResources().getDimensionPixelSize(\n                R.dimen.multiple_users_avatar_size);\n        ld.setLayerSize(1, size, size);\n        ld.setLayerGravity(1, Gravity.CENTER);\n\n        return ld;\n    }\n\n    /**\n     * @return number of non-guest non-managed users\n     */\n    @VisibleForTesting\n    int getRealUsersCount() {\n        return (int) mUserManager.getUsers()\n                .stream()\n                .filter(user -> !user.isGuest() && !user.isProfile())\n                .count();\n    }\n\n    private void loadIconsAsync(List<Integer> missingIcons) {\n        new AsyncTask<List<Integer>, Void, Void>() {\n            @Override\n            protected void onPostExecute(Void result) {\n                updateUserList();\n            }\n\n            @Override\n            protected Void doInBackground(List<Integer>... values) {\n                for (int userId : values[0]) {\n                    Bitmap bitmap = mUserManager.getUserIcon(userId);\n                    if (bitmap == null) {\n                        bitmap = getDefaultUserIconAsBitmap(getContext().getResources(), userId);\n                    }\n                    mUserIcons.append(userId, bitmap);\n                }\n                return null;\n            }\n        }.execute(missingIcons);\n    }\n\n    private Drawable getEncircledDefaultIcon() {\n        if (mDefaultIconDrawable == null) {\n            mDefaultIconDrawable = encircle(\n                    getDefaultUserIconAsBitmap(getContext().getResources(), UserHandle.USER_NULL));\n        }\n        return mDefaultIconDrawable;\n    }\n\n    private void setPhotoId(Preference pref, UserInfo user) {\n        Bitmap bitmap = mUserIcons.get(user.id);\n        if (bitmap != null) {\n            pref.setIcon(encircle(bitmap));\n        }\n    }\n\n    @Override\n    public boolean onPreferenceClick(Preference pref) {\n        if (pref == mMePreference) {\n            if (isCurrentUserGuest()) {\n                if (mGuestUserAutoCreated) {\n                    showDialog(DIALOG_CONFIRM_RESET_GUEST);\n                } else {\n                    showDialog(DIALOG_CONFIRM_EXIT_GUEST);\n                }\n            } else {\n                showDialog(DIALOG_USER_PROFILE_EDITOR);\n            }\n            return true;\n        } else if (pref instanceof UserPreference) {\n            UserInfo userInfo = mUserManager.getUserInfo(((UserPreference) pref).getUserId());\n            openUserDetails(userInfo, false);\n            return true;\n        } else if (pref == mAddUser) {\n            // If we allow both types, show a picker, otherwise directly go to\n            // flow for full user.\n            if (mUserCaps.mCanAddRestrictedProfile) {\n                showDialog(DIALOG_CHOOSE_USER_TYPE);\n            } else {\n                onAddUserClicked(USER_TYPE_USER);\n            }\n            return true;\n        } else if (pref == mAddSupervisedUser) {\n            mMetricsFeatureProvider.action(getActivity(), SettingsEnums.ACTION_USER_SUPERVISED_ADD);\n            Trace.beginSection(\"UserSettings.addSupervisedUser\");\n            onAddSupervisedUserClicked();\n            Trace.endSection();\n            return true;\n        } else if (pref == mAddGuest) {\n            mAddGuest.setEnabled(false); // prevent multiple tap issue\n            onAddGuestClicked();\n            return true;\n        }\n        return false;\n    }\n\n    private Drawable encircle(Bitmap icon) {\n        Drawable circled = CircleFramedDrawable.getInstance(getActivity(), icon);\n        return circled;\n    }\n\n    @Override\n    public void onDismiss(DialogInterface dialog) {\n        synchronized (mUserLock) {\n            mRemovingUserId = -1;\n            updateUserList();\n        }\n    }\n\n    @Override\n    public int getHelpResource() {\n        return R.string.help_url_users;\n    }\n\n    /**\n     * Returns a default user icon (as a {@link Bitmap}) for the given user.\n     *\n     * Note that for guest users, you should pass in {@code UserHandle.USER_NULL}.\n     *\n     * @param resources resources object to fetch the user icon.\n     * @param userId    the user id or {@code UserHandle.USER_NULL} for a non-user specific icon\n     */\n    private static Bitmap getDefaultUserIconAsBitmap(Resources resources, int userId) {\n        Bitmap bitmap = null;\n        // Try finding the corresponding bitmap in the dark bitmap cache\n        bitmap = sDarkDefaultUserBitmapCache.get(userId);\n        if (bitmap == null) {\n            bitmap = UserIcons.convertToBitmapAtUserIconSize(resources,\n                    UserIcons.getDefaultUserIcon(resources, userId, false));\n            // Save it to cache\n            sDarkDefaultUserBitmapCache.put(userId, bitmap);\n        }\n        return bitmap;\n    }\n\n    /**\n     * Assign the default photo to user with {@paramref userId}\n     *\n     * @param context used to get the {@link UserManager}\n     * @param userId  used to get the icon bitmap\n     * @return true if assign photo successfully, false if failed\n     */\n    @VisibleForTesting\n    static boolean assignDefaultPhoto(Context context, int userId) {\n        if (context == null) {\n            return false;\n        }\n        UserManager um = (UserManager) context.getSystemService(Context.USER_SERVICE);\n        Bitmap bitmap = getDefaultUserIconAsBitmap(context.getResources(), userId);\n        um.setUserIcon(userId, bitmap);\n\n        return true;\n    }\n\n    @WorkerThread\n    static void copyMeProfilePhoto(Context context, UserInfo user) {\n        Uri contactUri = ContactsContract.Profile.CONTENT_URI;\n\n        int userId = user != null ? user.id : UserHandle.myUserId();\n\n        InputStream avatarDataStream = ContactsContract.Contacts.openContactPhotoInputStream(\n                context.getContentResolver(),\n                contactUri, true);\n        // If there's no profile photo, assign a default avatar\n        if (avatarDataStream == null) {\n            assignDefaultPhoto(context, userId);\n            return;\n        }\n\n        UserManager um = (UserManager) context.getSystemService(Context.USER_SERVICE);\n        Bitmap icon = BitmapFactory.decodeStream(avatarDataStream);\n        um.setUserIcon(userId, icon);\n        try {\n            avatarDataStream.close();\n        } catch (IOException ioe) {\n        }\n    }\n\n    public static final BaseSearchIndexProvider SEARCH_INDEX_DATA_PROVIDER =\n            new BaseSearchIndexProvider(R.xml.user_settings) {\n\n                @Override\n                protected boolean isPageSearchEnabled(Context context) {\n                    final UserCapabilities userCaps = UserCapabilities.create(context);\n                    return userCaps.mEnabled;\n                }\n\n                @Override\n                public List<String> getNonIndexableKeysFromXml(Context context, int xmlResId,\n                        boolean suppressAllPage) {\n                    final List<String> niks = super.getNonIndexableKeysFromXml(context, xmlResId,\n                            suppressAllPage);\n                    AddUserWhenLockedPreferenceController controller =\n                            new AddUserWhenLockedPreferenceController(\n                                    context, KEY_ADD_USER_WHEN_LOCKED);\n                    controller.updateNonIndexableKeys(niks);\n                    new AutoSyncDataPreferenceController(context, null /* parent */)\n                            .updateNonIndexableKeys(niks);\n                    new AutoSyncPersonalDataPreferenceController(context, null /* parent */)\n                            .updateNonIndexableKeys(niks);\n                    new AutoSyncWorkDataPreferenceController(context, null /* parent */)\n                            .updateNonIndexableKeys(niks);\n                    return niks;\n                }\n            };\n}\n```"
                    }
                ]
            },
            {
                "downstream_version": "14",
                "branch_used": "android14-release",
                "downstream_patch": "6e413c4cff2f306d18e9682b1e0be5ddc8427c5f",
                "repo_path": "android_repos/Settings",
                "result": "failure",
                "downstream_patch_content": "commit 6e413c4cff2f306d18e9682b1e0be5ddc8427c5f\nAuthor: Adam Bookatz <bookatz@google.com>\nDate:   Mon Nov 18 15:53:41 2024 -0800\n\n    Don't let profiles open the UserSettings overflow [DO NOT MERGE]\n    \n    Really, profiles aren't expected to open Settings at all. But if they\n    do somehow, the overflow shouldn't appear.\n    \n    Bug: 352542820\n    Flag: EXEMPT bugfix\n    Test: Try to access the overflow of the work profile by launching its Settings in\n    adb shell am start --user 10 'com.android.settings/.Settings\\$UserSettingsActivity'\n    \n    Change-Id: I5e4c095cda3e19fa5c63c2c550a526f5da8ec5c1\n    Merged-In: I5e4c095cda3e19fa5c63c2c550a526f5da8ec5c1\n    (cherry picked from commit 69c7f5dac580361792bbb189178653b297d06c8a)\n\ndiff --git a/src/com/android/settings/users/UserSettings.java b/src/com/android/settings/users/UserSettings.java\nindex 28e02ec16e2..b430068a7ef 100644\n--- a/src/com/android/settings/users/UserSettings.java\n+++ b/src/com/android/settings/users/UserSettings.java\n@@ -464,7 +464,8 @@ public class UserSettings extends SettingsPreferenceFragment\n     @Override\n     public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n         int pos = 0;\n-        if (!isCurrentUserAdmin() && canSwitchUserNow() && !isCurrentUserGuest()) {\n+        if (!isCurrentUserAdmin() && canSwitchUserNow() && !isCurrentUserGuest()\n+                && !mUserManager.isProfile()) {\n             String nickname = mUserManager.getUserName();\n             MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                     getResources().getString(R.string.user_remove_user_menu, nickname));\n",
                "file_conflicts": [
                    {
                        "file_name": "src/com/android/settings/users/UserSettings.java",
                        "total_hunks": 1,
                        "failed_hunks": [
                            1
                        ],
                        "inline_merge_conflicts": [],
                        "rej_file_content": "```diff\n--- src/com/android/settings/users/UserSettings.java\n+++ src/com/android/settings/users/UserSettings.java\n@@ -465,7 +465,7 @@ public class UserSettings extends SettingsPreferenceFragment\n     public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n         int pos = 0;\n         if (!isCurrentUserAdmin() && (canSwitchUserNow() || Flags.newMultiuserSettingsUx())\n-                && !isCurrentUserGuest()) {\n+                && !isCurrentUserGuest() && !mUserManager.isProfile()) {\n             String nickname = mUserManager.getUserName();\n             MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                     getResources().getString(R.string.user_remove_user_menu, nickname));\n```",
                        "patch_apply_output": "patching file src/com/android/settings/users/UserSettings.java\nHunk #1 FAILED at 465.\n1 out of 1 hunk FAILED -- saving rejects to file src/com/android/settings/users/UserSettings.java.rej",
                        "inline_merge_output": "patching file src/com/android/settings/users/UserSettings.java\nHunk #1 already applied at 468.",
                        "upstream_file_content": "```java\n/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.settings.users;\n\nimport static com.android.settingslib.Utils.getColorAttrDefaultColor;\n\nimport android.app.Activity;\nimport android.app.ActivityManager;\nimport android.app.Dialog;\nimport android.app.admin.DevicePolicyManager;\nimport android.app.settings.SettingsEnums;\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.pm.UserInfo;\nimport android.content.res.Resources;\nimport android.graphics.Bitmap;\nimport android.graphics.BitmapFactory;\nimport android.graphics.BlendMode;\nimport android.graphics.drawable.Drawable;\nimport android.graphics.drawable.LayerDrawable;\nimport android.multiuser.Flags;\nimport android.net.Uri;\nimport android.os.AsyncTask;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.Message;\nimport android.os.Process;\nimport android.os.RemoteException;\nimport android.os.Trace;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.provider.ContactsContract;\nimport android.provider.Settings;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.util.SparseArray;\nimport android.view.Gravity;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.WindowManagerGlobal;\nimport android.widget.SimpleAdapter;\nimport android.widget.Toast;\n\nimport androidx.annotation.VisibleForTesting;\nimport androidx.annotation.WorkerThread;\nimport androidx.appcompat.app.AlertDialog;\nimport androidx.preference.Preference;\nimport androidx.preference.PreferenceGroup;\nimport androidx.preference.PreferenceScreen;\n\nimport com.android.internal.util.UserIcons;\nimport com.android.internal.widget.LockPatternUtils;\nimport com.android.settings.R;\nimport com.android.settings.SettingsActivity;\nimport com.android.settings.SettingsPreferenceFragment;\nimport com.android.settings.Utils;\nimport com.android.settings.core.SubSettingLauncher;\nimport com.android.settings.password.ChooseLockGeneric;\nimport com.android.settings.search.BaseSearchIndexProvider;\nimport com.android.settings.widget.MainSwitchBarController;\nimport com.android.settings.widget.SettingsMainSwitchBar;\nimport com.android.settingslib.RestrictedLockUtils.EnforcedAdmin;\nimport com.android.settingslib.RestrictedLockUtilsInternal;\nimport com.android.settingslib.RestrictedPreference;\nimport com.android.settingslib.drawable.CircleFramedDrawable;\nimport com.android.settingslib.search.SearchIndexable;\nimport com.android.settingslib.search.SearchIndexableRaw;\nimport com.android.settingslib.users.CreateUserDialogController;\nimport com.android.settingslib.users.EditUserInfoController;\nimport com.android.settingslib.users.GrantAdminDialogController;\nimport com.android.settingslib.users.UserCreatingDialog;\nimport com.android.settingslib.utils.ThreadUtils;\n\nimport com.google.android.setupcompat.util.WizardManagerHelper;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.stream.Collectors;\n\n/**\n * Screen that manages the list of users on the device.\n * Secondary users and a guest user can be created if there is no restriction.\n *\n * The first user in the list is always the current user.\n * Owner is the primary user.\n */\n@SearchIndexable\npublic class UserSettings extends SettingsPreferenceFragment\n        implements Preference.OnPreferenceClickListener,\n        MultiUserSwitchBarController.OnMultiUserSwitchChangedListener,\n        DialogInterface.OnDismissListener {\n\n    private static final String TAG = \"UserSettings\";\n\n    /** UserId of the user being removed */\n    private static final String SAVE_REMOVING_USER = \"removing_user\";\n    private static final String SAVE_CREATE_USER = \"create_user\";\n\n    private static final String KEY_USER_LIST = \"user_list\";\n    private static final String KEY_USER_ME = \"user_me\";\n    private static final String KEY_USER_GUEST = \"user_guest\";\n    private static final String KEY_ADD_GUEST = \"guest_add\";\n    private static final String KEY_ADD_USER = \"user_add\";\n    private static final String KEY_ADD_SUPERVISED_USER = \"supervised_user_add\";\n    private static final String KEY_ADD_USER_WHEN_LOCKED = \"user_settings_add_users_when_locked\";\n    private static final String KEY_ENABLE_GUEST_TELEPHONY = \"enable_guest_calling\";\n    private static final String KEY_MULTIUSER_TOP_INTRO = \"multiuser_top_intro\";\n    private static final String KEY_TIMEOUT_TO_DOCK_USER = \"timeout_to_dock_user_preference\";\n    private static final String KEY_GUEST_CATEGORY = \"guest_category\";\n    private static final String KEY_GUEST_RESET = \"guest_reset\";\n    private static final String KEY_GUEST_EXIT = \"guest_exit\";\n    private static final String KEY_REMOVE_GUEST_ON_EXIT = \"remove_guest_on_exit\";\n    private static final String KEY_GUEST_USER_CATEGORY = \"guest_user_category\";\n    private static final String KEY_ALLOW_MULTIPLE_USERS = \"allow_multiple_users\";\n    private static final String KEY_USER_SETTINGS_SCREEN = \"user_settings_screen\";\n\n    private static final String SETTING_GUEST_HAS_LOGGED_IN = \"systemui.guest_has_logged_in\";\n\n    private static final int MENU_REMOVE_USER = Menu.FIRST;\n\n    private static final IntentFilter USER_REMOVED_INTENT_FILTER;\n\n    private static final int DIALOG_CONFIRM_REMOVE = 1;\n    private static final int DIALOG_ADD_USER = 2;\n    // Dialogs with id 3 and 4 got removed\n    private static final int DIALOG_USER_CANNOT_MANAGE = 5;\n    private static final int DIALOG_CHOOSE_USER_TYPE = 6;\n    private static final int DIALOG_NEED_LOCKSCREEN = 7;\n    private static final int DIALOG_CONFIRM_REMOVE_GUEST = 8;\n    private static final int DIALOG_USER_PROFILE_EDITOR = 9;\n    private static final int DIALOG_USER_PROFILE_EDITOR_ADD_USER = 10;\n    private static final int DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE = 11;\n    private static final int DIALOG_CONFIRM_REMOVE_GUEST_WITH_AUTO_CREATE = 12;\n    private static final int DIALOG_CONFIRM_RESET_AND_RESTART_GUEST = 13;\n    private static final int DIALOG_CONFIRM_EXIT_GUEST_EPHEMERAL = 14;\n    private static final int DIALOG_CONFIRM_EXIT_GUEST_NON_EPHEMERAL = 15;\n    private static final int DIALOG_GRANT_ADMIN = 16;\n\n    private static final int MESSAGE_UPDATE_LIST = 1;\n    private static final int MESSAGE_USER_CREATED = 2;\n    static final int MESSAGE_REMOVE_GUEST_ON_EXIT_CONTROLLER_GUEST_REMOVED = 3;\n\n    private static final int USER_TYPE_USER = 1;\n    private static final int USER_TYPE_RESTRICTED_PROFILE = 2;\n\n    private static final int REQUEST_CHOOSE_LOCK = 10;\n    private static final int REQUEST_EDIT_GUEST = 11;\n\n    static final int RESULT_GUEST_REMOVED = 100;\n\n    private static final String KEY_TITLE = \"title\";\n    private static final String KEY_SUMMARY = \"summary\";\n\n    private static final String EXTRA_OPEN_DIALOG_USER_PROFILE_EDITOR =\n            \"EXTRA_OPEN_DIALOG_USER_PROFILE_EDITOR\";\n\n    static {\n        USER_REMOVED_INTENT_FILTER = new IntentFilter(Intent.ACTION_USER_REMOVED);\n        USER_REMOVED_INTENT_FILTER.addAction(Intent.ACTION_USER_INFO_CHANGED);\n    }\n\n    @VisibleForTesting\n    PreferenceGroup mUserListCategory;\n    @VisibleForTesting\n    PreferenceGroup mGuestUserCategory;\n    @VisibleForTesting\n    PreferenceGroup mGuestCategory;\n    @VisibleForTesting\n    Preference mGuestResetPreference;\n    @VisibleForTesting\n    Preference mGuestExitPreference;\n    @VisibleForTesting\n    UserPreference mMePreference;\n    @VisibleForTesting\n    RestrictedPreference mAddGuest;\n    @VisibleForTesting\n    RestrictedPreference mAddUser;\n    @VisibleForTesting\n    RestrictedPreference mAddSupervisedUser;\n    @VisibleForTesting\n    SparseArray<Bitmap> mUserIcons = new SparseArray<>();\n    private int mRemovingUserId = -1;\n    private boolean mAddingUser;\n    private boolean mGuestUserAutoCreated;\n    private String mConfigSupervisedUserCreationPackage;\n    private String mAddingUserName;\n    private UserCapabilities mUserCaps;\n    private boolean mShouldUpdateUserList = true;\n    private final Object mUserLock = new Object();\n    private UserManager mUserManager;\n    private static SparseArray<Bitmap> sDarkDefaultUserBitmapCache = new SparseArray<>();\n\n    private MultiUserSwitchBarController mSwitchBarController;\n\n    private GrantAdminDialogController mGrantAdminDialogController =\n            new GrantAdminDialogController();\n    private EditUserInfoController mEditUserInfoController =\n            new EditUserInfoController(Utils.FILE_PROVIDER_AUTHORITY);\n    private CreateUserDialogController mCreateUserDialogController =\n            new CreateUserDialogController(Utils.FILE_PROVIDER_AUTHORITY);\n    private AddUserWhenLockedPreferenceController mAddUserWhenLockedPreferenceController;\n    private GuestTelephonyPreferenceController mGuestTelephonyPreferenceController;\n    private RemoveGuestOnExitPreferenceController mRemoveGuestOnExitPreferenceController;\n    private MultiUserTopIntroPreferenceController mMultiUserTopIntroPreferenceController;\n    private TimeoutToDockUserPreferenceController mTimeoutToDockUserPreferenceController;\n    private UserCreatingDialog mUserCreatingDialog;\n    private final AtomicBoolean mGuestCreationScheduled = new AtomicBoolean();\n    private final ExecutorService mExecutor = Executors.newSingleThreadExecutor();\n\n    private CharSequence mPendingUserName;\n    private Drawable mPendingUserIcon;\n    private boolean mPendingUserIsAdmin;\n\n    // A place to cache the generated default avatar\n    private Drawable mDefaultIconDrawable;\n\n    // TODO:   Replace current Handler solution to something that doesn't leak memory and works\n    // TODO:   during a configuration change\n    private Handler mHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MESSAGE_UPDATE_LIST:\n                    updateUserList();\n                    break;\n                case MESSAGE_REMOVE_GUEST_ON_EXIT_CONTROLLER_GUEST_REMOVED:\n                    updateUserList();\n                    if (mGuestUserAutoCreated) {\n                        scheduleGuestCreation();\n                    }\n                    break;\n            }\n        }\n    };\n\n    private BroadcastReceiver mUserChangeReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            if (intent.getAction().equals(Intent.ACTION_USER_REMOVED)) {\n                mRemovingUserId = -1;\n            } else if (intent.getAction().equals(Intent.ACTION_USER_INFO_CHANGED)) {\n                int userHandle = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, -1);\n                if (userHandle != -1) {\n                    mUserIcons.remove(userHandle);\n                }\n            }\n            mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n        }\n    };\n\n    @Override\n    public int getMetricsCategory() {\n        return SettingsEnums.USER;\n    }\n\n    @Override\n    public void onActivityCreated(Bundle savedInstanceState) {\n        super.onActivityCreated(savedInstanceState);\n        // Assume we are in a SettingsActivity. This is only safe because we currently use\n        // SettingsActivity as base for all preference fragments.\n        final SettingsActivity activity = (SettingsActivity) getActivity();\n        final SettingsMainSwitchBar switchBar = activity.getSwitchBar();\n        switchBar.setTitle(getContext().getString(R.string.multiple_users_main_switch_title));\n        if (!mUserCaps.mIsGuest) {\n            switchBar.show();\n        } else {\n            switchBar.hide();\n        }\n        mSwitchBarController = new MultiUserSwitchBarController(activity,\n                new MainSwitchBarController(switchBar), this /* listener */);\n        getSettingsLifecycle().addObserver(mSwitchBarController);\n        boolean openUserEditDialog = getIntent().getBooleanExtra(\n                EXTRA_OPEN_DIALOG_USER_PROFILE_EDITOR, false);\n        if (switchBar.isChecked() && openUserEditDialog) {\n            showDialog(DIALOG_USER_PROFILE_EDITOR);\n        }\n    }\n\n    @Override\n    public void onCreate(Bundle icicle) {\n        super.onCreate(icicle);\n        addPreferencesFromResource(R.xml.user_settings);\n        final Activity activity = getActivity();\n        if (!WizardManagerHelper.isDeviceProvisioned(activity)) {\n            activity.finish();\n            return;\n        }\n\n        mGuestUserAutoCreated = getPrefContext().getResources().getBoolean(\n                com.android.internal.R.bool.config_guestUserAutoCreated);\n\n        mAddUserWhenLockedPreferenceController = new AddUserWhenLockedPreferenceController(\n                activity, KEY_ADD_USER_WHEN_LOCKED);\n\n        mGuestTelephonyPreferenceController = new GuestTelephonyPreferenceController(\n                activity, KEY_ENABLE_GUEST_TELEPHONY);\n\n        mRemoveGuestOnExitPreferenceController = new RemoveGuestOnExitPreferenceController(\n                activity, KEY_REMOVE_GUEST_ON_EXIT, this, mHandler);\n\n        mMultiUserTopIntroPreferenceController = new MultiUserTopIntroPreferenceController(activity,\n                KEY_MULTIUSER_TOP_INTRO);\n\n        mTimeoutToDockUserPreferenceController = new TimeoutToDockUserPreferenceController(\n                activity, KEY_TIMEOUT_TO_DOCK_USER);\n\n        final PreferenceScreen screen = getPreferenceScreen();\n        mAddUserWhenLockedPreferenceController.displayPreference(screen);\n        mGuestTelephonyPreferenceController.displayPreference(screen);\n        mRemoveGuestOnExitPreferenceController.displayPreference(screen);\n        mMultiUserTopIntroPreferenceController.displayPreference(screen);\n        mTimeoutToDockUserPreferenceController.displayPreference(screen);\n\n        screen.findPreference(mAddUserWhenLockedPreferenceController.getPreferenceKey())\n                .setOnPreferenceChangeListener(mAddUserWhenLockedPreferenceController);\n\n        screen.findPreference(mGuestTelephonyPreferenceController.getPreferenceKey())\n                .setOnPreferenceChangeListener(mGuestTelephonyPreferenceController);\n\n        screen.findPreference(mRemoveGuestOnExitPreferenceController.getPreferenceKey())\n                .setOnPreferenceChangeListener(mRemoveGuestOnExitPreferenceController);\n\n        if (icicle != null) {\n            if (icicle.containsKey(SAVE_REMOVING_USER)) {\n                mRemovingUserId = icicle.getInt(SAVE_REMOVING_USER);\n            }\n            if (icicle.containsKey(SAVE_CREATE_USER)) {\n                mCreateUserDialogController.onRestoreInstanceState(icicle);\n            } else {\n                mEditUserInfoController.onRestoreInstanceState(icicle);\n            }\n        }\n\n        mUserCaps = UserCapabilities.create(activity);\n        mUserManager = (UserManager) activity.getSystemService(Context.USER_SERVICE);\n        if (!mUserCaps.mEnabled) {\n            return;\n        }\n\n        final int myUserId = UserHandle.myUserId();\n\n        mUserListCategory = (PreferenceGroup) findPreference(KEY_USER_LIST);\n        mMePreference = new UserPreference(getPrefContext(), null /* attrs */, myUserId);\n        mMePreference.setKey(KEY_USER_ME);\n        mMePreference.setOnPreferenceClickListener(this);\n\n        mGuestCategory = findPreference(KEY_GUEST_CATEGORY);\n\n        mGuestResetPreference = findPreference(KEY_GUEST_RESET);\n        mGuestResetPreference.setOnPreferenceClickListener(this);\n\n        mGuestExitPreference = findPreference(KEY_GUEST_EXIT);\n        mGuestExitPreference.setOnPreferenceClickListener(this);\n\n        mGuestUserCategory = findPreference(KEY_GUEST_USER_CATEGORY);\n\n        mAddGuest = findPreference(KEY_ADD_GUEST);\n        mAddGuest.setOnPreferenceClickListener(this);\n\n        mAddUser = findPreference(KEY_ADD_USER);\n        if (!mUserCaps.mCanAddRestrictedProfile) {\n            // Label should only mention adding a \"user\", not a \"profile\"\n            mAddUser.setTitle(com.android.settingslib.R.string.user_add_user);\n        }\n        mAddUser.setOnPreferenceClickListener(this);\n\n        setConfigSupervisedUserCreationPackage();\n        mAddSupervisedUser = findPreference(KEY_ADD_SUPERVISED_USER);\n        mAddSupervisedUser.setOnPreferenceClickListener(this);\n\n        activity.registerReceiverAsUser(\n                mUserChangeReceiver, UserHandle.ALL, USER_REMOVED_INTENT_FILTER, null, mHandler,\n                Context.RECEIVER_EXPORTED_UNAUDITED);\n\n        updateUI();\n        mShouldUpdateUserList = false;\n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n\n        if (!mUserCaps.mEnabled) {\n            return;\n        }\n        final PreferenceScreen screen = getPreferenceScreen();\n\n        mAddUserWhenLockedPreferenceController.updateState(screen.findPreference(\n                mAddUserWhenLockedPreferenceController.getPreferenceKey()));\n        mGuestTelephonyPreferenceController.updateState(screen.findPreference(\n                mGuestTelephonyPreferenceController.getPreferenceKey()));\n        mTimeoutToDockUserPreferenceController.updateState(screen.findPreference(\n                mTimeoutToDockUserPreferenceController.getPreferenceKey()));\n        mRemoveGuestOnExitPreferenceController.updateState(screen.findPreference(\n                mRemoveGuestOnExitPreferenceController.getPreferenceKey()));\n        mSwitchBarController.updateState();\n        if (mShouldUpdateUserList) {\n            updateUI();\n        }\n    }\n\n    @Override\n    public void onPause() {\n        mShouldUpdateUserList = true;\n        super.onPause();\n    }\n\n    @Override\n    public void onDestroy() {\n        super.onDestroy();\n\n        if (mUserCaps == null || !mUserCaps.mEnabled) {\n            return;\n        }\n\n        getActivity().unregisterReceiver(mUserChangeReceiver);\n    }\n\n    @Override\n    public void onSaveInstanceState(Bundle outState) {\n        if (mCreateUserDialogController.isActive()) {\n            outState.putBoolean(SAVE_CREATE_USER, mCreateUserDialogController.isActive());\n            mCreateUserDialogController.onSaveInstanceState(outState);\n        } else {\n            mEditUserInfoController.onSaveInstanceState(outState);\n        }\n        outState.putInt(SAVE_REMOVING_USER, mRemovingUserId);\n        super.onSaveInstanceState(outState);\n    }\n\n    @Override\n    public void startActivityForResult(Intent intent, int requestCode) {\n        mEditUserInfoController.startingActivityForResult();\n        mCreateUserDialogController.startingActivityForResult();\n        super.startActivityForResult(intent, requestCode);\n    }\n\n    @Override\n    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n        int pos = 0;\n        if (!isCurrentUserAdmin() && (canSwitchUserNow() || Flags.newMultiuserSettingsUx())\n                && !isCurrentUserGuest() && !mUserManager.isProfile()) {\n            String nickname = mUserManager.getUserName();\n            MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                    getResources().getString(R.string.user_remove_user_menu, nickname));\n            removeThisUser.setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);\n\n            final EnforcedAdmin disallowRemoveUserAdmin =\n                    RestrictedLockUtilsInternal.checkIfRestrictionEnforced(getContext(),\n                            UserManager.DISALLOW_REMOVE_USER, UserHandle.myUserId());\n            RestrictedLockUtilsInternal.setMenuItemAsDisabledByAdmin(getContext(), removeThisUser,\n                    disallowRemoveUserAdmin);\n        }\n        super.onCreateOptionsMenu(menu, inflater);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        final int itemId = item.getItemId();\n        if (itemId == MENU_REMOVE_USER) {\n            onRemoveUserClicked(UserHandle.myUserId());\n            return true;\n        } else {\n            return super.onOptionsItemSelected(item);\n        }\n    }\n\n    @Override\n    public void onMultiUserSwitchChanged(boolean newState) {\n        updateUI();\n    }\n\n    private void updateUI() {\n        mUserCaps.updateAddUserCapabilities(getActivity());\n        loadProfile();\n        updateUserList();\n    }\n\n    /**\n     * Loads profile information for the current user.\n     */\n    private void loadProfile() {\n        if (isCurrentUserGuest()) {\n            // No need to load profile information\n            mMePreference.setIcon(getEncircledDefaultIcon());\n            mMePreference.setTitle(mGuestUserAutoCreated\n                    ? com.android.settingslib.R.string.guest_reset_guest\n                    : com.android.settingslib.R.string.guest_exit_guest);\n            mMePreference.setSelectable(true);\n            // removing a guest will result in switching back to the admin user\n            mMePreference.setEnabled(canSwitchUserNow());\n            return;\n        }\n\n        new AsyncTask<Void, Void, String>() {\n            @Override\n            protected void onPostExecute(String result) {\n                finishLoadProfile(result);\n            }\n\n            @Override\n            protected String doInBackground(Void... values) {\n                UserInfo user = mUserManager.getUserInfo(UserHandle.myUserId());\n                if (user.iconPath == null || user.iconPath.equals(\"\")) {\n                    // Assign profile photo.\n                    copyMeProfilePhoto(getActivity(), user);\n                }\n                return user.name;\n            }\n        }.execute();\n    }\n\n    private void finishLoadProfile(String profileName) {\n        if (getActivity() == null) {\n            return;\n        }\n        mMePreference.setTitle(getString(R.string.user_you, profileName));\n        int myUserId = UserHandle.myUserId();\n        Bitmap b = mUserManager.getUserIcon(myUserId);\n        if (b != null) {\n            mMePreference.setIcon(encircleUserIcon(b));\n            mUserIcons.put(myUserId, b);\n        }\n    }\n\n    private boolean hasLockscreenSecurity() {\n        LockPatternUtils lpu = new LockPatternUtils(getActivity());\n        return lpu.isSecure(UserHandle.myUserId());\n    }\n\n    private void launchChooseLockscreen() {\n        Intent chooseLockIntent = new Intent(DevicePolicyManager.ACTION_SET_NEW_PASSWORD)\n                .setPackage(getContext().getPackageName());\n        chooseLockIntent.putExtra(ChooseLockGeneric.ChooseLockGenericFragment.HIDE_INSECURE_OPTIONS,\n                true);\n        startActivityForResult(chooseLockIntent, REQUEST_CHOOSE_LOCK);\n    }\n\n    @Override\n    public void onActivityResult(int requestCode, int resultCode, Intent data) {\n        super.onActivityResult(requestCode, resultCode, data);\n\n        if (requestCode == REQUEST_CHOOSE_LOCK) {\n            if (resultCode != Activity.RESULT_CANCELED && hasLockscreenSecurity()) {\n                addUserNow(USER_TYPE_RESTRICTED_PROFILE);\n            }\n        } else if (mGuestUserAutoCreated && requestCode == REQUEST_EDIT_GUEST\n                && resultCode == RESULT_GUEST_REMOVED) {\n            scheduleGuestCreation();\n        } else {\n            mCreateUserDialogController.onActivityResult(requestCode, resultCode, data);\n            mEditUserInfoController.onActivityResult(requestCode, resultCode, data);\n        }\n    }\n\n    private void onAddUserClicked(int userType) {\n        synchronized (mUserLock) {\n            if (mRemovingUserId == -1 && !mAddingUser) {\n                switch (userType) {\n                    case USER_TYPE_USER:\n                        showDialog(DIALOG_ADD_USER);\n                        break;\n                    case USER_TYPE_RESTRICTED_PROFILE:\n                        if (hasLockscreenSecurity()) {\n                            showDialog(DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE);\n                        } else {\n                            showDialog(DIALOG_NEED_LOCKSCREEN);\n                        }\n                        break;\n                }\n            }\n        }\n    }\n\n    private void onAddSupervisedUserClicked() {\n        final Intent intent = new Intent()\n                .setAction(UserManager.ACTION_CREATE_SUPERVISED_USER)\n                .setPackage(mConfigSupervisedUserCreationPackage)\n                .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n\n        startActivity(intent);\n    }\n\n    private void onAddGuestClicked() {\n        Context context = getContext();\n        final UserCreatingDialog guestCreatingDialog =\n                new UserCreatingDialog(getActivity(), /* isGuest= */ true);\n        guestCreatingDialog.show();\n\n        ThreadUtils.postOnBackgroundThread(() -> {\n            mMetricsFeatureProvider.action(getActivity(), SettingsEnums.ACTION_USER_GUEST_ADD);\n            Trace.beginSection(\"UserSettings.addGuest\");\n            final UserInfo guest = mUserManager.createGuest(context);\n            Trace.endSection();\n\n            ThreadUtils.postOnMainThread(() -> {\n                guestCreatingDialog.dismiss();\n                if (guest == null) {\n                    Toast.makeText(context,\n                            com.android.settingslib.R.string.add_guest_failed,\n                            Toast.LENGTH_SHORT).show();\n                    return;\n                }\n                openUserDetails(guest, true, context);\n            });\n        });\n    }\n\n    private void onRemoveUserClicked(int userId) {\n        synchronized (mUserLock) {\n            if (mRemovingUserId == -1 && !mAddingUser) {\n                mRemovingUserId = userId;\n                showDialog(DIALOG_CONFIRM_REMOVE);\n            }\n        }\n    }\n\n    private void onUserCreated(UserInfo userInfo, Context context) {\n        hideUserCreatingDialog();\n        mAddingUser = false;\n        openUserDetails(userInfo, true, context);\n    }\n\n    private void hideUserCreatingDialog() {\n        if (mUserCreatingDialog != null && mUserCreatingDialog.isShowing()) {\n            mUserCreatingDialog.dismiss();\n        }\n    }\n\n    private void onUserCreationFailed() {\n        Toast.makeText(getContext(),\n                com.android.settingslib.R.string.add_user_failed,\n                Toast.LENGTH_SHORT).show();\n        hideUserCreatingDialog();\n    }\n\n    private void openUserDetails(UserInfo userInfo, boolean newUser) {\n        openUserDetails(userInfo, newUser, getContext());\n    }\n\n    private void openUserDetails(UserInfo userInfo, boolean newUser, Context context) {\n        // to prevent a crash when config changes during user creation,\n        // we simply ignore this redirection step\n        if (context == null) {\n            return;\n        }\n\n        Bundle extras = new Bundle();\n        extras.putInt(UserDetailsSettings.EXTRA_USER_ID, userInfo.id);\n        extras.putBoolean(AppRestrictionsFragment.EXTRA_NEW_USER, newUser);\n\n        SubSettingLauncher launcher = new SubSettingLauncher(context)\n                .setDestination(UserDetailsSettings.class.getName())\n                .setArguments(extras)\n                .setTitleText(userInfo.name)\n                .setSourceMetricsCategory(getMetricsCategory());\n        if (mGuestUserAutoCreated && userInfo.isGuest()) {\n            launcher.setResultListener(this, REQUEST_EDIT_GUEST);\n        }\n        launcher.launch();\n    }\n\n    @Override\n    public void onDialogShowing() {\n        super.onDialogShowing();\n\n        setOnDismissListener(this);\n    }\n\n    @Override\n    public Dialog onCreateDialog(int dialogId) {\n        Context context = getActivity();\n        if (context == null) {\n            return null;\n        }\n        switch (dialogId) {\n            case DIALOG_CONFIRM_REMOVE: {\n                Dialog dlg =\n                        UserDialogs.createRemoveDialog(getActivity(), mRemovingUserId,\n                                new DialogInterface.OnClickListener() {\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        removeUserNow();\n                                    }\n                                }\n                        );\n                return dlg;\n            }\n            case DIALOG_USER_CANNOT_MANAGE:\n                return new AlertDialog.Builder(context)\n                        .setMessage(R.string.user_cannot_manage_message)\n                        .setPositiveButton(android.R.string.ok, null)\n                        .create();\n            case DIALOG_ADD_USER: {\n                synchronized (mUserLock) {\n                    mPendingUserName = getString(\n                            com.android.settingslib.R.string.user_new_user_name);\n                    mPendingUserIcon = null;\n                }\n                return buildAddUserDialog(USER_TYPE_USER);\n            }\n            case DIALOG_CHOOSE_USER_TYPE: {\n                List<HashMap<String, String>> data = new ArrayList<HashMap<String, String>>();\n                HashMap<String, String> addUserItem = new HashMap<String, String>();\n                addUserItem.put(KEY_TITLE, getString(\n                        com.android.settingslib.R.string.user_add_user_item_title));\n                addUserItem.put(KEY_SUMMARY, getString(\n                        com.android.settingslib.R.string.user_add_user_item_summary));\n                HashMap<String, String> addProfileItem = new HashMap<String, String>();\n                addProfileItem.put(KEY_TITLE, getString(\n                        com.android.settingslib.R.string.user_add_profile_item_title));\n                addProfileItem.put(KEY_SUMMARY, getString(\n                        com.android.settingslib.R.string.user_add_profile_item_summary));\n                data.add(addUserItem);\n                data.add(addProfileItem);\n                AlertDialog.Builder builder = new AlertDialog.Builder(context);\n                SimpleAdapter adapter = new SimpleAdapter(builder.getContext(),\n                        data, R.layout.two_line_list_item,\n                        new String[]{KEY_TITLE, KEY_SUMMARY},\n                        new int[]{R.id.title, R.id.summary});\n                builder.setTitle(com.android.settingslib.R.string.user_add_user_type_title);\n                builder.setAdapter(adapter,\n                        new DialogInterface.OnClickListener() {\n                            @Override\n                            public void onClick(DialogInterface dialog, int which) {\n                                onAddUserClicked(which == 0\n                                        ? USER_TYPE_USER\n                                        : USER_TYPE_RESTRICTED_PROFILE);\n                            }\n                        });\n                return builder.create();\n            }\n            case DIALOG_NEED_LOCKSCREEN: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setMessage(com.android.settingslib.R.string.user_need_lock_message)\n                        .setPositiveButton(com.android.settingslib.R.string.user_set_lock_button,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        launchChooseLockscreen();\n                                    }\n                                })\n                        .setNegativeButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            case DIALOG_CONFIRM_REMOVE_GUEST: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setTitle(com.android.settingslib.R.string.guest_remove_guest_dialog_title)\n                        .setMessage(R.string.user_exit_guest_confirm_message)\n                        .setPositiveButton(R.string.user_exit_guest_dialog_remove,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        clearAndExitGuest();\n                                    }\n                                })\n                        .setNegativeButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            case DIALOG_CONFIRM_EXIT_GUEST_EPHEMERAL: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setTitle(com.android.settingslib.R.string.guest_exit_dialog_title)\n                        .setMessage(com.android.settingslib.R.string.guest_exit_dialog_message)\n                        .setPositiveButton(\n                                com.android.settingslib.R.string.guest_exit_dialog_button,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        clearAndExitGuest();\n                                    }\n                                })\n                        .setNeutralButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            case DIALOG_CONFIRM_EXIT_GUEST_NON_EPHEMERAL: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setTitle(\n                            com.android.settingslib.R.string.guest_exit_dialog_title_non_ephemeral)\n                        .setMessage(\n                            com.android.settingslib\n                                .R.string.guest_exit_dialog_message_non_ephemeral)\n                        .setPositiveButton(\n                            com.android.settingslib.R.string.guest_exit_save_data_button,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        exitGuest();\n                                    }\n                                })\n                        .setNegativeButton(\n                            com.android.settingslib.R.string.guest_exit_clear_data_button,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        clearAndExitGuest();\n                                    }\n                                })\n                        .setNeutralButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            case DIALOG_USER_PROFILE_EDITOR: {\n                return buildEditCurrentUserDialog();\n            }\n            case DIALOG_USER_PROFILE_EDITOR_ADD_USER: {\n                synchronized (mUserLock) {\n                    mPendingUserName = getString(\n                            com.android.settingslib.R.string.user_new_user_name);\n                    mPendingUserIcon = null;\n                }\n                return buildAddUserDialog(USER_TYPE_USER);\n            }\n            case DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE: {\n                synchronized (mUserLock) {\n                    mPendingUserName = getString(\n                            com.android.settingslib.R.string.user_new_profile_name);\n                    mPendingUserIcon = null;\n                }\n                return buildAddUserDialog(USER_TYPE_RESTRICTED_PROFILE);\n            }\n            case DIALOG_CONFIRM_REMOVE_GUEST_WITH_AUTO_CREATE: {\n                return UserDialogs.createResetGuestDialog(getActivity(),\n                        (dialog, which) -> clearAndExitGuest());\n            }\n            case DIALOG_CONFIRM_RESET_AND_RESTART_GUEST: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setTitle(\n                            com.android.settingslib.R.string.guest_reset_and_restart_dialog_title)\n                        .setMessage(\n                            com.android.settingslib.R.string.guest_reset_and_restart_dialog_message)\n                        .setPositiveButton(\n                            com.android.settingslib.R.string.guest_reset_guest_confirm_button,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        resetAndRestartGuest();\n                                    }\n                                })\n                        .setNeutralButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            default:\n                return null;\n        }\n    }\n\n    private Dialog buildEditCurrentUserDialog() {\n        final Activity activity = getActivity();\n        if (activity == null) {\n            return null;\n        }\n\n        UserInfo user = mUserManager.getUserInfo(Process.myUserHandle().getIdentifier());\n        Drawable userIcon = Utils.getUserIcon(activity, mUserManager, user);\n\n        return mEditUserInfoController.createDialog(\n                activity,\n                this::startActivityForResult,\n                userIcon,\n                user.name,\n                (newUserName, newUserIcon) -> {\n                    if (newUserIcon != userIcon) {\n                        ThreadUtils.postOnBackgroundThread(() ->\n                                mUserManager.setUserIcon(user.id,\n                                        UserIcons.convertToBitmapAtUserIconSize(\n                                                activity.getResources(), newUserIcon)));\n                        mMePreference.setIcon(newUserIcon);\n                        if (Flags.avatarSync()) {\n                            final String pkg = getString(R.string.config_avatar_picker_package);\n                            final String action = pkg + \".set.confirm\";\n                            activity.sendBroadcast(new Intent(action).setPackage(pkg));\n                        }\n                    }\n\n                    if (!TextUtils.isEmpty(newUserName) && !newUserName.equals(user.name)) {\n                        mMePreference.setTitle(newUserName);\n                        mUserManager.setUserName(user.id, newUserName);\n                    }\n                }, () -> {\n                    if (Flags.avatarSync()) {\n                        final String pkg = getString(R.string.config_avatar_picker_package);\n                        final String action = pkg + \".set.cancel\";\n                        activity.sendBroadcast(new Intent(action).setPackage(pkg));\n                    }\n                });\n    }\n\n    private Dialog buildAddUserDialog(int userType) {\n        Dialog d;\n        synchronized (mUserLock) {\n            d = mCreateUserDialogController.createDialog(\n                    getActivity(),\n                    this::startActivityForResult,\n                    canCreateAdminUser(),\n                    (userName, userIcon, isAdmin) -> {\n                        mPendingUserIcon = userIcon;\n                        mPendingUserName = userName;\n                        mPendingUserIsAdmin = isAdmin;\n                        addUserNow(userType);\n                    },\n                    () -> {\n                        synchronized (mUserLock) {\n                            mPendingUserIcon = null;\n                            mPendingUserName = null;\n                        }\n                    }\n            );\n        }\n        return d;\n    }\n\n    /**\n     * Checks if the creation of a new admin user is allowed.\n     * @return {@code true} if creating a new admin is allowed, {@code false} otherwise.\n     */\n    private boolean canCreateAdminUser() {\n        if (Flags.unicornModeRefactoringForHsumReadOnly()) {\n            return UserManager.isMultipleAdminEnabled()\n                    && !mUserManager.hasUserRestriction(UserManager.DISALLOW_GRANT_ADMIN);\n        } else {\n            return UserManager.isMultipleAdminEnabled();\n        }\n    }\n\n    @Override\n    public int getDialogMetricsCategory(int dialogId) {\n        switch (dialogId) {\n            case DIALOG_CONFIRM_REMOVE:\n                return SettingsEnums.DIALOG_USER_REMOVE;\n            case DIALOG_USER_CANNOT_MANAGE:\n                return SettingsEnums.DIALOG_USER_CANNOT_MANAGE;\n            case DIALOG_GRANT_ADMIN:\n                return SettingsEnums.DIALOG_GRANT_USER_ADMIN;\n            case DIALOG_ADD_USER:\n                return SettingsEnums.DIALOG_USER_ADD;\n            case DIALOG_CHOOSE_USER_TYPE:\n                return SettingsEnums.DIALOG_USER_CHOOSE_TYPE;\n            case DIALOG_NEED_LOCKSCREEN:\n                return SettingsEnums.DIALOG_USER_NEED_LOCKSCREEN;\n            case DIALOG_CONFIRM_REMOVE_GUEST:\n            case DIALOG_CONFIRM_REMOVE_GUEST_WITH_AUTO_CREATE:\n            case DIALOG_CONFIRM_EXIT_GUEST_EPHEMERAL:\n            case DIALOG_CONFIRM_EXIT_GUEST_NON_EPHEMERAL:\n            case DIALOG_CONFIRM_RESET_AND_RESTART_GUEST:\n                return SettingsEnums.DIALOG_USER_CONFIRM_EXIT_GUEST;\n            case DIALOG_USER_PROFILE_EDITOR:\n            case DIALOG_USER_PROFILE_EDITOR_ADD_USER:\n            case DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE:\n                return SettingsEnums.DIALOG_USER_EDIT_PROFILE;\n            default:\n                return 0;\n        }\n    }\n\n    private void removeUserNow() {\n        if (mRemovingUserId == UserHandle.myUserId()) {\n            removeThisUser();\n        } else {\n            ThreadUtils.postOnBackgroundThread(new Runnable() {\n                @Override\n                public void run() {\n                    synchronized (mUserLock) {\n                        mUserManager.removeUser(mRemovingUserId);\n                        mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n                    }\n                }\n            });\n        }\n    }\n\n    private void removeThisUser() {\n        if (!canSwitchUserNow()) {\n            Log.w(TAG, \"Cannot remove current user when switching is disabled\");\n            return;\n        }\n        try {\n            mUserManager.removeUserWhenPossible(\n                    UserHandle.of(UserHandle.myUserId()), /* overrideDevicePolicy= */ false);\n            ActivityManager.getService().switchUser(\n                    mUserManager.getPreviousForegroundUser().getIdentifier());\n        } catch (RemoteException re) {\n            Log.e(TAG, \"Unable to remove self user\");\n        }\n    }\n\n    private void switchToUserId(int userId) {\n        if (!canSwitchUserNow()) {\n            Log.w(TAG, \"Cannot switch current user when switching is disabled\");\n            return;\n        }\n        try {\n            ActivityManager.getService().switchUser(userId);\n        } catch (RemoteException re) {\n            Log.e(TAG, \"Unable to switch user\");\n        }\n    }\n\n    private void addUserNow(final int userType) {\n        Trace.beginAsyncSection(\"UserSettings.addUserNow\", 0);\n        synchronized (mUserLock) {\n            mAddingUser = true;\n            mAddingUserName = userType == USER_TYPE_USER\n                    ? (mPendingUserName != null ? mPendingUserName.toString()\n                    : getString(com.android.settingslib.R.string.user_new_user_name))\n                    : (mPendingUserName != null ? mPendingUserName.toString()\n                            : getString(com.android.settingslib.R.string.user_new_profile_name));\n        }\n\n        mUserCreatingDialog = new UserCreatingDialog(getActivity());\n        mUserCreatingDialog.show();\n        createUser(userType, mAddingUserName);\n    }\n\n    @VisibleForTesting\n    void createUser(final int userType, String userName) {\n        Context context = getContext();\n        Resources resources = getResources();\n        final Drawable selectedUserIcon = mPendingUserIcon;\n        Future<?> unusedCreateUserFuture = ThreadUtils.postOnBackgroundThread(() -> {\n            UserInfo user;\n\n            if (userType == USER_TYPE_USER) {\n                user = mUserManager.createUser(\n                        userName,\n                        mUserManager.USER_TYPE_FULL_SECONDARY,\n                        0);\n                if (mPendingUserIsAdmin) {\n                    mUserManager.setUserAdmin(user.id);\n                }\n            } else {\n                user = mUserManager.createRestrictedProfile(userName);\n            }\n\n            ThreadUtils.postOnMainThread(() -> {\n                if (user == null) {\n                    mAddingUser = false;\n                    mPendingUserIcon = null;\n                    mPendingUserName = null;\n                    onUserCreationFailed();\n                    return;\n                }\n\n                Future<?> unusedSettingIconFuture = ThreadUtils.postOnBackgroundThread(() -> {\n                    Drawable newUserIcon = selectedUserIcon;\n                    if (newUserIcon == null) {\n                        newUserIcon = UserIcons.getDefaultUserIcon(resources, user.id, false);\n                    }\n                    mUserManager.setUserIcon(\n                            user.id, UserIcons.convertToBitmapAtUserIconSize(\n                                    resources, newUserIcon));\n                });\n\n                mPendingUserIcon = null;\n                mPendingUserName = null;\n\n                onUserCreated(user, context);\n            });\n        });\n    }\n\n\n    /**\n     * Erase the current user (guest) and switch to another user.\n     */\n    @VisibleForTesting\n    void clearAndExitGuest() {\n        // Just to be safe\n        if (!isCurrentUserGuest()) {\n            return;\n        }\n        mMetricsFeatureProvider.action(getActivity(),\n                SettingsEnums.ACTION_USER_GUEST_EXIT_CONFIRMED);\n\n        int guestUserId = UserHandle.myUserId();\n        // Using markGuestForDeletion allows us to create a new guest before this one is\n        // fully removed.\n        boolean marked = mUserManager.markGuestForDeletion(guestUserId);\n        if (!marked) {\n            Log.w(TAG, \"Couldn't mark the guest for deletion for user \" + guestUserId);\n            return;\n        }\n\n        removeThisUser();\n        if (mGuestUserAutoCreated) {\n            scheduleGuestCreation();\n        }\n    }\n\n    /**\n     * Switch to another user.\n     */\n    private void exitGuest() {\n        // Just to be safe\n        if (!isCurrentUserGuest()) {\n            return;\n        }\n        mMetricsFeatureProvider.action(getActivity(),\n                SettingsEnums.ACTION_USER_GUEST_EXIT_CONFIRMED);\n        switchToUserId(mUserManager.getPreviousForegroundUser().getIdentifier());\n    }\n\n    private int createGuest() {\n        UserInfo guest;\n        Context context = getPrefContext();\n        try {\n            guest = mUserManager.createGuest(context);\n        } catch (UserManager.UserOperationException e) {\n            Log.e(TAG, \"Couldn't create guest user\", e);\n            return UserHandle.USER_NULL;\n        }\n        if (guest == null) {\n            Log.e(TAG, \"Couldn't create guest, most likely because there already exists one\");\n            return UserHandle.USER_NULL;\n        }\n        return guest.id;\n    }\n\n    /**\n     * Remove current guest and start a new guest session\n     */\n    private void resetAndRestartGuest() {\n        // Just to be safe\n        if (!isCurrentUserGuest()) {\n            return;\n        }\n        int oldGuestUserId = UserHandle.myUserId();\n        // Using markGuestForDeletion allows us to create a new guest before this one is\n        // fully removed.\n        boolean marked = mUserManager.markGuestForDeletion(oldGuestUserId);\n        if (!marked) {\n            Log.w(TAG, \"Couldn't mark the guest for deletion for user \" + oldGuestUserId);\n            return;\n        }\n\n        try {\n            // Create a new guest in the foreground, and then immediately switch to it\n            int newGuestUserId = createGuest();\n            if (newGuestUserId == UserHandle.USER_NULL) {\n                Log.e(TAG, \"Could not create new guest, switching back to previous user\");\n                switchToUserId(mUserManager.getPreviousForegroundUser().getIdentifier());\n                mUserManager.removeUser(oldGuestUserId);\n                WindowManagerGlobal.getWindowManagerService().lockNow(/* options= */ null);\n                return;\n            }\n            switchToUserId(newGuestUserId);\n            mUserManager.removeUser(oldGuestUserId);\n        } catch (RemoteException e) {\n            Log.e(TAG, \"Couldn't remove guest because ActivityManager or WindowManager is dead\");\n            return;\n        }\n    }\n\n    /**\n     * Create a guest user in the background\n     */\n    @VisibleForTesting\n    void scheduleGuestCreation() {\n        // TODO(b/191067027): Move guest recreation to system_server\n        if (mGuestCreationScheduled.compareAndSet(/* expect= */ false, /* update= */ true)) {\n            // Once mGuestCreationScheduled=true, mAddGuest needs to be updated so that it shows\n            // \"Resetting guest...\"\n            mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n            mExecutor.execute(() -> {\n                UserInfo guest = mUserManager.createGuest(getContext());\n                mGuestCreationScheduled.set(false);\n                if (guest == null) {\n                    Log.e(TAG, \"Unable to automatically recreate guest user\");\n                }\n                // The list needs to be updated whether or not guest creation worked. If guest\n                // creation failed, the list needs to update so that \"Add guest\" is displayed.\n                // Otherwise, the UX could be stuck in a state where there is no way to switch to\n                // the guest user (e.g. Guest would not be selectable, and it would be stuck\n                // saying \"Resetting guest...\")\n                mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n            });\n        }\n    }\n\n    @VisibleForTesting\n    void updateUserList() {\n        final Context context = getActivity();\n        if (context == null) {\n            return;\n        }\n\n        List<UserInfo> users;\n        if (Flags.newMultiuserSettingsUx()) {\n            // Only users that can be switched to should show up here.\n            // e.g. Managed profiles appear under Accounts Settings instead\n            users = mUserManager.getAliveUsers().stream()\n                    .filter(UserInfo::supportsSwitchToByUser)\n                    .collect(Collectors.toList());\n        } else {\n            if (mUserCaps.mUserSwitcherEnabled) {\n                // Only users that can be switched to should show up here.\n                // e.g. Managed profiles appear under Accounts Settings instead\n                users = mUserManager.getAliveUsers().stream()\n                        .filter(UserInfo::supportsSwitchToByUser)\n                        .collect(Collectors.toList());\n            } else {\n                // Only current user will be displayed in case of multi-user switch is disabled\n                users = List.of(mUserManager.getUserInfo(context.getUserId()));\n            }\n        }\n\n        final ArrayList<Integer> missingIcons = new ArrayList<>();\n        final ArrayList<UserPreference> userPreferences = new ArrayList<>();\n\n        // mMePreference shows a icon for current user. However when current user is a guest, we\n        // don't show the guest user icon, instead we show two preferences for guest user to\n        // exit and reset itself. Hence we don't add mMePreference, i.e. guest user to the\n        // list of users visible in the UI.\n        if (!isCurrentUserGuest()) {\n            userPreferences.add(mMePreference);\n        }\n\n        boolean canOpenUserDetails =\n                isCurrentUserAdmin() || (canSwitchUserNow() && !mUserCaps.mDisallowSwitchUser);\n        for (UserInfo user : users) {\n            if (user.isGuest()) {\n                // Guest user is added to guest category via updateGuestCategory\n                // and not to user list so skip guest here\n                continue;\n            }\n            UserPreference pref;\n            if (user.id == UserHandle.myUserId()) {\n                pref = mMePreference;\n            } else {\n                pref = new UserPreference(getPrefContext(), null, user.id);\n                pref.setTitle(user.name);\n                userPreferences.add(pref);\n                pref.setOnPreferenceClickListener(this);\n                pref.setEnabled(canOpenUserDetails);\n                pref.setSelectable(true);\n                pref.setKey(\"id=\" + user.id);\n            }\n            if (pref == null) {\n                continue;\n            }\n            if (user.isMain()) {\n                pref.setSummary(R.string.user_owner);\n            } else if (user.isAdmin()) {\n                pref.setSummary(R.string.user_admin);\n            }\n            if (user.id != UserHandle.myUserId() && !user.isGuest() && !user.isInitialized()) {\n                // sometimes after creating a guest the initialized flag isn't immediately set\n                // and we don't want to show \"Not set up\" summary for them\n                if (user.isRestricted()) {\n                    pref.setSummary(R.string.user_summary_restricted_not_set_up);\n                } else {\n                    pref.setSummary(R.string.user_summary_not_set_up);\n                    // Disallow setting up user which results in user switching when the\n                    // restriction is set.\n                    // If newMultiuserSettingsUx flag is enabled, allow opening user details page\n                    // since switch to user will be disabled\n                    pref.setEnabled((!mUserCaps.mDisallowSwitchUser && canSwitchUserNow())\n                            || Flags.newMultiuserSettingsUx());\n                }\n            } else if (user.isRestricted()) {\n                pref.setSummary(R.string.user_summary_restricted_profile);\n            }\n            if (user.iconPath != null) {\n                if (mUserIcons.get(user.id) == null) {\n                    // Icon not loaded yet, print a placeholder\n                    missingIcons.add(user.id);\n                    pref.setIcon(getEncircledDefaultIcon());\n                } else {\n                    setPhotoId(pref, user);\n                }\n            } else {\n                // Icon not available yet, print a placeholder\n                pref.setIcon(getEncircledDefaultIcon());\n            }\n        }\n\n        // Add a temporary entry for the user being created\n        if (mAddingUser) {\n            UserPreference pref = new UserPreference(getPrefContext(), null,\n                    UserPreference.USERID_UNKNOWN);\n            pref.setEnabled(false);\n            pref.setTitle(mAddingUserName);\n            pref.setIcon(getEncircledDefaultIcon());\n            userPreferences.add(pref);\n        }\n\n        // Sort list of users by serialNum\n        Collections.sort(userPreferences, UserPreference.SERIAL_NUMBER_COMPARATOR);\n\n        getActivity().invalidateOptionsMenu();\n\n        // Load the icons\n        if (missingIcons.size() > 0) {\n            loadIconsAsync(missingIcons);\n        }\n\n        // If restricted profiles are supported, mUserListCategory will have a special title\n        if (mUserCaps.mCanAddRestrictedProfile) {\n            mUserListCategory.setTitle(R.string.user_list_title);\n        } else if (isCurrentUserGuest()) {\n            mUserListCategory.setTitle(R.string.other_user_category_title);\n        } else {\n            mUserListCategory.setTitle(R.string.user_category_title);\n        }\n\n        // Remove everything from mUserListCategory and add new users.\n        mUserListCategory.removeAll();\n\n        final Preference addUserOnLockScreen = getPreferenceScreen().findPreference(\n                mAddUserWhenLockedPreferenceController.getPreferenceKey());\n        mAddUserWhenLockedPreferenceController.updateState(addUserOnLockScreen);\n\n        final Preference guestCallPreference = getPreferenceScreen().findPreference(\n                mGuestTelephonyPreferenceController.getPreferenceKey());\n        mGuestTelephonyPreferenceController.updateState(guestCallPreference);\n\n        final Preference multiUserTopIntroPreference = getPreferenceScreen().findPreference(\n                mMultiUserTopIntroPreferenceController.getPreferenceKey());\n        mMultiUserTopIntroPreferenceController.updateState(multiUserTopIntroPreference);\n        updateGuestPreferences();\n        updateGuestCategory(context, users);\n        updateAddUser(context);\n        updateAddSupervisedUser(context);\n\n        for (UserPreference userPreference : userPreferences) {\n            userPreference.setOrder(Preference.DEFAULT_ORDER);\n            mUserListCategory.addPreference(userPreference);\n        }\n\n    }\n\n    @VisibleForTesting\n    void setConfigSupervisedUserCreationPackage() {\n        mConfigSupervisedUserCreationPackage = getPrefContext().getString(\n                com.android.internal.R.string.config_supervisedUserCreationPackage);\n    }\n\n    private boolean isCurrentUserGuest() {\n        return mUserCaps.mIsGuest;\n    }\n\n    private boolean isCurrentUserAdmin() {\n        return mUserCaps.mIsAdmin;\n    }\n\n    private boolean canSwitchUserNow() {\n        return mUserManager.getUserSwitchability() == UserManager.SWITCHABILITY_STATUS_OK;\n    }\n\n    private void updateGuestPreferences() {\n        // reset guest and exit guest preferences are shown only in guest mode.\n        // For all other users these are not visible.\n        mGuestCategory.setVisible(false);\n        mGuestResetPreference.setVisible(false);\n        mGuestExitPreference.setVisible(false);\n        if (!isCurrentUserGuest()) {\n            return;\n        }\n        mGuestCategory.setVisible(true);\n        mGuestExitPreference.setVisible(true);\n        mGuestResetPreference.setVisible(true);\n\n        boolean isGuestFirstLogin = Settings.Secure.getIntForUser(\n                getContext().getContentResolver(),\n                SETTING_GUEST_HAS_LOGGED_IN,\n                0,\n                UserHandle.myUserId()) <= 1;\n        String guestExitSummary;\n        if (mUserCaps.mIsEphemeral) {\n            guestExitSummary = getContext().getString(\n                    com.android.settingslib.R.string.guest_notification_ephemeral);\n        } else if (isGuestFirstLogin) {\n            guestExitSummary = getContext().getString(\n                    com.android.settingslib.R.string.guest_notification_non_ephemeral);\n        } else {\n            guestExitSummary = getContext().getString(\n                    com.android.settingslib.R\n                            .string.guest_notification_non_ephemeral_non_first_login);\n        }\n        mGuestExitPreference.setSummary(guestExitSummary);\n    }\n\n    private void updateGuestCategory(Context context, List<UserInfo> users) {\n        // show guest category title and related guest preferences\n        // - if guest is created, then show guest user preference\n        // - if guest is not created and its allowed to create guest,\n        //   then show \"add guest\" preference\n        // - if allowed, show \"reset guest on exit\" preference\n        // - if there is nothing to show, then make the guest category as not visible\n        // - guest category is not visible for guest user.\n        UserPreference pref = null;\n        boolean isGuestAlreadyCreated = false;\n        boolean canOpenUserDetails =\n                isCurrentUserAdmin() || (canSwitchUserNow() && !mUserCaps.mDisallowSwitchUser);\n\n        mGuestUserCategory.removeAll();\n        mGuestUserCategory.setVisible(false);\n        for (UserInfo user : users) {\n            if (!user.isGuest() || !user.isEnabled()) {\n                // Only look at enabled, guest users\n                continue;\n            }\n            final Context prefContext = getPrefContext();\n            pref = new UserPreference(prefContext, null, user.id);\n            pref.setTitle(user.name);\n            pref.setOnPreferenceClickListener(this);\n            pref.setEnabled(canOpenUserDetails);\n            pref.setSelectable(true);\n            Drawable icon = getContext().getDrawable(\n                    com.android.settingslib.R.drawable.ic_account_circle_outline);\n            icon.setTint(\n                    getColorAttrDefaultColor(getContext(), android.R.attr.colorControlNormal));\n            pref.setIcon(encircleUserIcon(\n                    UserIcons.convertToBitmapAtUserIconSize(\n                            getContext().getResources(), icon)));\n            pref.setKey(KEY_USER_GUEST);\n            pref.setOrder(Preference.DEFAULT_ORDER);\n            if (mUserCaps.mDisallowSwitchUser && !Flags.newMultiuserSettingsUx()) {\n                pref.setDisabledByAdmin(\n                        RestrictedLockUtilsInternal.getDeviceOwner(context));\n            } else {\n                pref.setDisabledByAdmin(null);\n            }\n            if (Flags.newMultiuserSettingsUx()) {\n                mGuestUserCategory.addPreference(pref);\n                // guest user preference is shown hence also make guest category visible\n                mGuestUserCategory.setVisible(true);\n            } else {\n                if (mUserCaps.mUserSwitcherEnabled) {\n                    mGuestUserCategory.addPreference(pref);\n                    // guest user preference is shown hence also make guest category visible\n                    mGuestUserCategory.setVisible(true);\n                }\n            }\n            isGuestAlreadyCreated = true;\n        }\n        boolean isVisible = updateAddGuestPreference(context, isGuestAlreadyCreated);\n        if (isVisible) {\n            // \"add guest\" preference is shown hence also make guest category visible\n            mGuestUserCategory.setVisible(true);\n        }\n        final Preference removeGuestOnExit = getPreferenceScreen().findPreference(\n                mRemoveGuestOnExitPreferenceController.getPreferenceKey());\n        mRemoveGuestOnExitPreferenceController.updateState(removeGuestOnExit);\n        if (mRemoveGuestOnExitPreferenceController.isAvailable()) {\n            // \"reset guest on exit\" preference is shown hence also make guest category visible\n            mGuestUserCategory.setVisible(true);\n        }\n        if (isCurrentUserGuest()) {\n            // guest category is not visible for guest user.\n            mGuestUserCategory.setVisible(false);\n        }\n    }\n\n    private boolean updateAddGuestPreference(Context context, boolean isGuestAlreadyCreated) {\n        boolean isVisible = false;\n        if (!isGuestAlreadyCreated && (mUserCaps.mCanAddGuest\n                || (Flags.newMultiuserSettingsUx() && mUserCaps.mDisallowAddUser))\n                && mUserManager.canAddMoreUsers(UserManager.USER_TYPE_FULL_GUEST)\n                && WizardManagerHelper.isDeviceProvisioned(context)\n                && (mUserCaps.mUserSwitcherEnabled || Flags.newMultiuserSettingsUx())) {\n            Drawable icon = context.getDrawable(\n                    com.android.settingslib.R.drawable.ic_account_circle);\n            mAddGuest.setIcon(centerAndTint(icon));\n            isVisible = true;\n            mAddGuest.setVisible(true);\n            mAddGuest.setSelectable(true);\n            if (mGuestUserAutoCreated && mGuestCreationScheduled.get()) {\n                mAddGuest.setTitle(com.android.internal.R.string.guest_name);\n                mAddGuest.setSummary(com.android.settingslib.R.string.guest_resetting);\n                mAddGuest.setEnabled(false);\n            } else {\n                mAddGuest.setTitle(com.android.settingslib.R.string.guest_new_guest);\n                if (Flags.newMultiuserSettingsUx()\n                        && mUserCaps.mDisallowAddUserSetByAdmin) {\n                    mAddGuest.setDisabledByAdmin(mUserCaps.mEnforcedAdmin);\n                } else if (Flags.newMultiuserSettingsUx() && mUserCaps.mDisallowAddUser) {\n                    final List<UserManager.EnforcingUser> enforcingUsers =\n                            mUserManager.getUserRestrictionSources(UserManager.DISALLOW_ADD_USER,\n                                    UserHandle.of(UserHandle.myUserId()));\n                    if (!enforcingUsers.isEmpty()) {\n                        final UserManager.EnforcingUser enforcingUser = enforcingUsers.get(0);\n                        final int restrictionSource = enforcingUser.getUserRestrictionSource();\n                        if (restrictionSource == UserManager.RESTRICTION_SOURCE_SYSTEM) {\n                            mAddGuest.setEnabled(false);\n                        } else {\n                            mAddGuest.setVisible(false);\n                        }\n                    }\n                } else {\n                    mAddGuest.setEnabled(canSwitchUserNow() || Flags.newMultiuserSettingsUx());\n                }\n            }\n        } else {\n            mAddGuest.setVisible(false);\n        }\n        return isVisible;\n    }\n\n    private void updateAddUser(Context context) {\n        updateAddUserCommon(context, mAddUser, mUserCaps.mCanAddRestrictedProfile);\n        Drawable icon = context.getDrawable(\n                com.android.settingslib.R.drawable.ic_account_circle_filled);\n        mAddUser.setIcon(centerAndTint(icon));\n    }\n\n    private void updateAddSupervisedUser(Context context) {\n        if (!TextUtils.isEmpty(mConfigSupervisedUserCreationPackage)) {\n            updateAddUserCommon(context, mAddSupervisedUser, false);\n            Drawable icon = context.getDrawable(\n                    com.android.settingslib.R.drawable.ic_add_supervised_user);\n            mAddSupervisedUser.setIcon(centerAndTint(icon));\n        } else {\n            mAddSupervisedUser.setVisible(false);\n        }\n    }\n\n    private void updateAddUserCommon(Context context, RestrictedPreference addUser,\n            boolean canAddRestrictedProfile) {\n        if ((mUserCaps.mCanAddUser\n                && !(mUserCaps.mDisallowAddUserSetByAdmin && Flags.newMultiuserSettingsUx()))\n                && WizardManagerHelper.isDeviceProvisioned(context)\n                && (mUserCaps.mUserSwitcherEnabled || Flags.newMultiuserSettingsUx())) {\n            addUser.setVisible(true);\n            addUser.setSelectable(true);\n            final boolean canAddMoreUsers =\n                    mUserManager.canAddMoreUsers(UserManager.USER_TYPE_FULL_SECONDARY)\n                            || (canAddRestrictedProfile\n                            && mUserManager.canAddMoreUsers(UserManager.USER_TYPE_FULL_RESTRICTED));\n            addUser.setEnabled(canAddMoreUsers && !mAddingUser\n                    && (canSwitchUserNow() || Flags.newMultiuserSettingsUx()));\n\n            if (!canAddMoreUsers) {\n                addUser.setSummary(getString(R.string.user_add_max_count));\n            } else {\n                addUser.setSummary(null);\n            }\n            if (addUser.isEnabled()) {\n                addUser.setDisabledByAdmin(\n                        mUserCaps.mDisallowAddUser ? mUserCaps.mEnforcedAdmin : null);\n            }\n        } else if (Flags.newMultiuserSettingsUx() && mUserCaps.mDisallowAddUserSetByAdmin) {\n            addUser.setVisible(true);\n            addUser.setDisabledByAdmin(mUserCaps.mEnforcedAdmin);\n        } else if (Flags.newMultiuserSettingsUx() && mUserCaps.mDisallowAddUser) {\n            final List<UserManager.EnforcingUser> enforcingUsers =\n                    mUserManager.getUserRestrictionSources(UserManager.DISALLOW_ADD_USER,\n                            UserHandle.of(UserHandle.myUserId()));\n            if (!enforcingUsers.isEmpty()) {\n                final UserManager.EnforcingUser enforcingUser = enforcingUsers.get(0);\n                final int restrictionSource = enforcingUser.getUserRestrictionSource();\n                if (restrictionSource == UserManager.RESTRICTION_SOURCE_SYSTEM) {\n                    addUser.setVisible(true);\n                    addUser.setEnabled(false);\n                } else {\n                    addUser.setVisible(false);\n                }\n            }\n        } else {\n            addUser.setVisible(false);\n        }\n    }\n\n    private Drawable centerAndTint(Drawable icon) {\n        icon.setTintBlendMode(BlendMode.SRC_IN);\n        icon.setTint(getColorAttrDefaultColor(getContext(), android.R.attr.textColorPrimary));\n\n        Drawable bg = getContext().getDrawable(com.android.settingslib.R.drawable.user_avatar_bg)\n                .mutate();\n        LayerDrawable ld = new LayerDrawable(new Drawable[] {bg, icon});\n        int size = getContext().getResources().getDimensionPixelSize(\n                R.dimen.multiple_users_avatar_size);\n        int bgSize = getContext().getResources().getDimensionPixelSize(\n                R.dimen.multiple_users_user_icon_size);\n        ld.setLayerSize(1, size, size);\n        ld.setLayerSize(0, bgSize, bgSize);\n        ld.setLayerGravity(1, Gravity.CENTER);\n\n        return ld;\n    }\n\n    /**\n     * @return number of non-guest non-managed users\n     */\n    @VisibleForTesting\n    int getRealUsersCount() {\n        return (int) mUserManager.getUsers()\n                .stream()\n                .filter(user -> !user.isGuest() && !user.isProfile())\n                .count();\n    }\n\n    private void loadIconsAsync(List<Integer> missingIcons) {\n        new AsyncTask<List<Integer>, Void, Void>() {\n            @Override\n            protected void onPostExecute(Void result) {\n                updateUserList();\n            }\n\n            @Override\n            protected Void doInBackground(List<Integer>... values) {\n                for (int userId : values[0]) {\n                    Bitmap bitmap = mUserManager.getUserIcon(userId);\n                    if (bitmap == null) {\n                        bitmap = getDefaultUserIconAsBitmap(getContext().getResources(), userId);\n                    }\n                    mUserIcons.append(userId, bitmap);\n                }\n                return null;\n            }\n        }.execute(missingIcons);\n    }\n\n    private Drawable getEncircledDefaultIcon() {\n        if (mDefaultIconDrawable == null) {\n            mDefaultIconDrawable = encircleUserIcon(\n                    getDefaultUserIconAsBitmap(getContext().getResources(), UserHandle.USER_NULL));\n        }\n        return mDefaultIconDrawable;\n    }\n\n    private void setPhotoId(Preference pref, UserInfo user) {\n        Bitmap bitmap = mUserIcons.get(user.id);\n        if (bitmap != null) {\n            pref.setIcon(encircleUserIcon(bitmap));\n        }\n    }\n\n    @Override\n    public boolean onPreferenceClick(Preference pref) {\n        mMetricsFeatureProvider.logSettingsTileClick(pref.getKey(), getMetricsCategory());\n        if (isCurrentUserGuest()) {\n            if (mGuestResetPreference != null && pref == mGuestResetPreference) {\n                showDialog(DIALOG_CONFIRM_RESET_AND_RESTART_GUEST);\n                return true;\n            }\n            if (mGuestExitPreference != null && pref == mGuestExitPreference) {\n                if (mUserCaps.mIsEphemeral) {\n                    showDialog(DIALOG_CONFIRM_EXIT_GUEST_EPHEMERAL);\n                } else {\n                    showDialog(DIALOG_CONFIRM_EXIT_GUEST_NON_EPHEMERAL);\n                }\n                return true;\n            }\n        }\n        if (pref == mMePreference) {\n            if (!isCurrentUserGuest()) {\n                showDialog(DIALOG_USER_PROFILE_EDITOR);\n                return true;\n            }\n        } else if (pref instanceof UserPreference) {\n            UserInfo userInfo = mUserManager.getUserInfo(((UserPreference) pref).getUserId());\n            openUserDetails(userInfo, false);\n            return true;\n        } else if (pref == mAddUser) {\n            mMetricsFeatureProvider.action(getActivity(), SettingsEnums.ACTION_USER_ADD);\n            // If we allow both types, show a picker, otherwise directly go to\n            // flow for full user.\n            if (mUserCaps.mCanAddRestrictedProfile) {\n                showDialog(DIALOG_CHOOSE_USER_TYPE);\n            } else {\n                onAddUserClicked(USER_TYPE_USER);\n            }\n            return true;\n        } else if (pref == mAddSupervisedUser) {\n            mMetricsFeatureProvider.action(getActivity(), SettingsEnums.ACTION_USER_SUPERVISED_ADD);\n            Trace.beginSection(\"UserSettings.addSupervisedUser\");\n            onAddSupervisedUserClicked();\n            Trace.endSection();\n            return true;\n        } else if (pref == mAddGuest) {\n            mAddGuest.setEnabled(false); // prevent multiple tap issue\n            onAddGuestClicked();\n            return true;\n        }\n        return false;\n    }\n\n    private Drawable encircleUserIcon(Bitmap icon) {\n        return new CircleFramedDrawable(\n                icon,\n                getActivity().getResources().getDimensionPixelSize(\n                        R.dimen.multiple_users_user_icon_size));\n    }\n\n    @Override\n    public void onDismiss(DialogInterface dialog) {\n        synchronized (mUserLock) {\n            mRemovingUserId = -1;\n            updateUserList();\n            if (mCreateUserDialogController.isActive()) {\n                mCreateUserDialogController.finish();\n            }\n        }\n    }\n\n    @Override\n    public int getHelpResource() {\n        return R.string.help_url_users;\n    }\n\n    /**\n     * Returns a default user icon (as a {@link Bitmap}) for the given user.\n     *\n     * Note that for guest users, you should pass in {@code UserHandle.USER_NULL}.\n     *\n     * @param resources resources object to fetch the user icon.\n     * @param userId    the user id or {@code UserHandle.USER_NULL} for a non-user specific icon\n     */\n    private static Bitmap getDefaultUserIconAsBitmap(Resources resources, int userId) {\n        Bitmap bitmap = null;\n        // Try finding the corresponding bitmap in the dark bitmap cache\n        bitmap = sDarkDefaultUserBitmapCache.get(userId);\n        if (bitmap == null) {\n            bitmap = UserIcons.convertToBitmapAtUserIconSize(resources,\n                    UserIcons.getDefaultUserIcon(resources, userId, false));\n            // Save it to cache\n            sDarkDefaultUserBitmapCache.put(userId, bitmap);\n        }\n        return bitmap;\n    }\n\n    /**\n     * Assign the default photo to user with {@paramref userId}\n     *\n     * @param context used to get the {@link UserManager}\n     * @param userId  used to get the icon bitmap\n     * @return true if assign photo successfully, false if failed\n     */\n    @VisibleForTesting\n    static boolean assignDefaultPhoto(Context context, int userId) {\n        if (context == null) {\n            return false;\n        }\n        UserManager um = (UserManager) context.getSystemService(Context.USER_SERVICE);\n        Bitmap bitmap = getDefaultUserIconAsBitmap(context.getResources(), userId);\n        um.setUserIcon(userId, bitmap);\n\n        return true;\n    }\n\n    @WorkerThread\n    static void copyMeProfilePhoto(Context context, UserInfo user) {\n        Uri contactUri = ContactsContract.Profile.CONTENT_URI;\n\n        int userId = user != null ? user.id : UserHandle.myUserId();\n\n        InputStream avatarDataStream = ContactsContract.Contacts.openContactPhotoInputStream(\n                context.getContentResolver(),\n                contactUri, true);\n        // If there's no profile photo, assign a default avatar\n        if (avatarDataStream == null) {\n            assignDefaultPhoto(context, userId);\n            return;\n        }\n\n        UserManager um = (UserManager) context.getSystemService(Context.USER_SERVICE);\n        Bitmap decodedIcon = BitmapFactory.decodeStream(avatarDataStream);\n        CircleFramedDrawable drawable = CircleFramedDrawable.getInstance(context, decodedIcon);\n        Bitmap icon = UserIcons.convertToBitmapAtUserIconSize(context.getResources(), drawable);\n\n        um.setUserIcon(userId, icon);\n        try {\n            avatarDataStream.close();\n        } catch (IOException ioe) {\n        }\n    }\n\n    public static final BaseSearchIndexProvider SEARCH_INDEX_DATA_PROVIDER =\n            new BaseSearchIndexProvider(R.xml.user_settings) {\n\n                @Override\n                protected boolean isPageSearchEnabled(Context context) {\n                    final UserCapabilities userCaps = UserCapabilities.create(context);\n                    return userCaps.mEnabled;\n                }\n\n                @Override\n                public List<SearchIndexableRaw> getRawDataToIndex(Context context,\n                        boolean enabled) {\n                    final List<SearchIndexableRaw> rawData = new ArrayList<>();\n                    if (!UserManager.supportsMultipleUsers()) {\n                        return rawData;\n                    }\n\n                    SearchIndexableRaw multipleUsersData = new SearchIndexableRaw(context);\n                    multipleUsersData.key = KEY_USER_SETTINGS_SCREEN;\n                    multipleUsersData.title =\n                            context.getString(R.string.user_settings_title);\n                    multipleUsersData.keywords =\n                            context.getString(R.string.multiple_users_title_keywords);\n                    multipleUsersData.screenTitle =\n                            context.getString(R.string.user_settings_title);\n                    rawData.add(multipleUsersData);\n\n                    SearchIndexableRaw allowMultipleUsersResult = new SearchIndexableRaw(context);\n\n                    allowMultipleUsersResult.key = KEY_ALLOW_MULTIPLE_USERS;\n                    allowMultipleUsersResult.title =\n                            context.getString(R.string.multiple_users_main_switch_title);\n                    allowMultipleUsersResult.keywords =\n                            context.getString(R.string.multiple_users_main_switch_keywords);\n                    allowMultipleUsersResult.screenTitle =\n                            context.getString(R.string.user_settings_title);\n                    allowMultipleUsersResult.className =\n                            MultiUserSwitchBarController.class.getName();\n\n                    rawData.add(allowMultipleUsersResult);\n\n                    SearchIndexableRaw addUserData = new SearchIndexableRaw(context);\n                    addUserData.key = KEY_ADD_USER;\n\n                    // Dynamically set the title of addUser preference\n                    final UserCapabilities userCaps = UserCapabilities.create(context);\n                    if (!userCaps.mCanAddRestrictedProfile) {\n                        addUserData.title = context.getString(\n                                com.android.settingslib.R.string.user_add_user);\n                    } else {\n                        addUserData.title = context.getString(\n                                R.string.user_add_user_or_profile_menu);\n                    }\n                    addUserData.screenTitle = context.getString(R.string.user_settings_title);\n                    addUserData.iconResId = R.drawable.ic_add_40dp;\n\n                    rawData.add(addUserData);\n\n                    return rawData;\n                }\n\n                @Override\n                public List<String> getNonIndexableKeysFromXml(Context context, int xmlResId,\n                        boolean suppressAllPage) {\n                    final List<String> niks = super.getNonIndexableKeysFromXml(context, xmlResId,\n                            suppressAllPage);\n                    if (TextUtils.isEmpty(context.getString(\n                            com.android.internal.R.string.config_supervisedUserCreationPackage))) {\n                        niks.add(KEY_ADD_SUPERVISED_USER);\n                    }\n                    AddUserWhenLockedPreferenceController controller =\n                            new AddUserWhenLockedPreferenceController(\n                                    context, KEY_ADD_USER_WHEN_LOCKED);\n                    controller.updateNonIndexableKeys(niks);\n                    new AutoSyncDataPreferenceController(context, null /* parent */)\n                            .updateNonIndexableKeys(niks);\n                    new AutoSyncPersonalDataPreferenceController(context, null /* parent */)\n                            .updateNonIndexableKeys(niks);\n                    new AutoSyncWorkDataPreferenceController(context, null /* parent */)\n                            .updateNonIndexableKeys(niks);\n                    if (suppressAllPage) {\n                        niks.add(KEY_ALLOW_MULTIPLE_USERS);\n                    }\n                    return niks;\n                }\n            };\n}\n```",
                        "downstream_file_content": "```java\n/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.settings.users;\n\nimport static com.android.settingslib.Utils.getColorAttrDefaultColor;\n\nimport android.app.Activity;\nimport android.app.ActivityManager;\nimport android.app.Dialog;\nimport android.app.admin.DevicePolicyManager;\nimport android.app.settings.SettingsEnums;\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.pm.UserInfo;\nimport android.content.res.Resources;\nimport android.graphics.Bitmap;\nimport android.graphics.BitmapFactory;\nimport android.graphics.BlendMode;\nimport android.graphics.drawable.Drawable;\nimport android.graphics.drawable.LayerDrawable;\nimport android.net.Uri;\nimport android.os.AsyncTask;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.Message;\nimport android.os.Process;\nimport android.os.RemoteException;\nimport android.os.Trace;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.provider.ContactsContract;\nimport android.provider.Settings;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.util.SparseArray;\nimport android.view.Gravity;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.WindowManagerGlobal;\nimport android.widget.SimpleAdapter;\nimport android.widget.Toast;\n\nimport androidx.annotation.VisibleForTesting;\nimport androidx.annotation.WorkerThread;\nimport androidx.appcompat.app.AlertDialog;\nimport androidx.preference.Preference;\nimport androidx.preference.PreferenceGroup;\nimport androidx.preference.PreferenceScreen;\n\nimport com.android.internal.util.UserIcons;\nimport com.android.internal.widget.LockPatternUtils;\nimport com.android.settings.R;\nimport com.android.settings.SettingsActivity;\nimport com.android.settings.SettingsPreferenceFragment;\nimport com.android.settings.Utils;\nimport com.android.settings.core.SubSettingLauncher;\nimport com.android.settings.password.ChooseLockGeneric;\nimport com.android.settings.search.BaseSearchIndexProvider;\nimport com.android.settings.widget.MainSwitchBarController;\nimport com.android.settings.widget.SettingsMainSwitchBar;\nimport com.android.settingslib.RestrictedLockUtils.EnforcedAdmin;\nimport com.android.settingslib.RestrictedLockUtilsInternal;\nimport com.android.settingslib.RestrictedPreference;\nimport com.android.settingslib.drawable.CircleFramedDrawable;\nimport com.android.settingslib.search.SearchIndexable;\nimport com.android.settingslib.search.SearchIndexableRaw;\nimport com.android.settingslib.users.CreateUserDialogController;\nimport com.android.settingslib.users.EditUserInfoController;\nimport com.android.settingslib.users.GrantAdminDialogController;\nimport com.android.settingslib.users.UserCreatingDialog;\nimport com.android.settingslib.utils.ThreadUtils;\n\nimport com.google.android.setupcompat.util.WizardManagerHelper;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.stream.Collectors;\n\n/**\n * Screen that manages the list of users on the device.\n * Secondary users and a guest user can be created if there is no restriction.\n *\n * The first user in the list is always the current user.\n * Owner is the primary user.\n */\n@SearchIndexable\npublic class UserSettings extends SettingsPreferenceFragment\n        implements Preference.OnPreferenceClickListener,\n        MultiUserSwitchBarController.OnMultiUserSwitchChangedListener,\n        DialogInterface.OnDismissListener {\n\n    private static final String TAG = \"UserSettings\";\n\n    /** UserId of the user being removed */\n    private static final String SAVE_REMOVING_USER = \"removing_user\";\n    private static final String SAVE_CREATE_USER = \"create_user\";\n\n    private static final String KEY_USER_LIST = \"user_list\";\n    private static final String KEY_USER_ME = \"user_me\";\n    private static final String KEY_USER_GUEST = \"user_guest\";\n    private static final String KEY_ADD_GUEST = \"guest_add\";\n    private static final String KEY_ADD_USER = \"user_add\";\n    private static final String KEY_ADD_SUPERVISED_USER = \"supervised_user_add\";\n    private static final String KEY_ADD_USER_WHEN_LOCKED = \"user_settings_add_users_when_locked\";\n    private static final String KEY_ENABLE_GUEST_TELEPHONY = \"enable_guest_calling\";\n    private static final String KEY_MULTIUSER_TOP_INTRO = \"multiuser_top_intro\";\n    private static final String KEY_TIMEOUT_TO_DOCK_USER = \"timeout_to_dock_user_preference\";\n    private static final String KEY_GUEST_CATEGORY = \"guest_category\";\n    private static final String KEY_GUEST_RESET = \"guest_reset\";\n    private static final String KEY_GUEST_EXIT = \"guest_exit\";\n    private static final String KEY_REMOVE_GUEST_ON_EXIT = \"remove_guest_on_exit\";\n    private static final String KEY_GUEST_USER_CATEGORY = \"guest_user_category\";\n    private static final String KEY_ALLOW_MULTIPLE_USERS = \"allow_multiple_users\";\n\n    private static final String SETTING_GUEST_HAS_LOGGED_IN = \"systemui.guest_has_logged_in\";\n\n    private static final int MENU_REMOVE_USER = Menu.FIRST;\n\n    private static final IntentFilter USER_REMOVED_INTENT_FILTER;\n\n    private static final int DIALOG_CONFIRM_REMOVE = 1;\n    private static final int DIALOG_ADD_USER = 2;\n    // Dialogs with id 3 and 4 got removed\n    private static final int DIALOG_USER_CANNOT_MANAGE = 5;\n    private static final int DIALOG_CHOOSE_USER_TYPE = 6;\n    private static final int DIALOG_NEED_LOCKSCREEN = 7;\n    private static final int DIALOG_CONFIRM_REMOVE_GUEST = 8;\n    private static final int DIALOG_USER_PROFILE_EDITOR = 9;\n    private static final int DIALOG_USER_PROFILE_EDITOR_ADD_USER = 10;\n    private static final int DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE = 11;\n    private static final int DIALOG_CONFIRM_REMOVE_GUEST_WITH_AUTO_CREATE = 12;\n    private static final int DIALOG_CONFIRM_RESET_AND_RESTART_GUEST = 13;\n    private static final int DIALOG_CONFIRM_EXIT_GUEST_EPHEMERAL = 14;\n    private static final int DIALOG_CONFIRM_EXIT_GUEST_NON_EPHEMERAL = 15;\n    private static final int DIALOG_GRANT_ADMIN = 16;\n\n    private static final int MESSAGE_UPDATE_LIST = 1;\n    private static final int MESSAGE_USER_CREATED = 2;\n    static final int MESSAGE_REMOVE_GUEST_ON_EXIT_CONTROLLER_GUEST_REMOVED = 3;\n\n    private static final int USER_TYPE_USER = 1;\n    private static final int USER_TYPE_RESTRICTED_PROFILE = 2;\n\n    private static final int REQUEST_CHOOSE_LOCK = 10;\n    private static final int REQUEST_EDIT_GUEST = 11;\n\n    static final int RESULT_GUEST_REMOVED = 100;\n\n    private static final String KEY_TITLE = \"title\";\n    private static final String KEY_SUMMARY = \"summary\";\n\n    private static final String EXTRA_OPEN_DIALOG_USER_PROFILE_EDITOR =\n            \"EXTRA_OPEN_DIALOG_USER_PROFILE_EDITOR\";\n\n    static {\n        USER_REMOVED_INTENT_FILTER = new IntentFilter(Intent.ACTION_USER_REMOVED);\n        USER_REMOVED_INTENT_FILTER.addAction(Intent.ACTION_USER_INFO_CHANGED);\n    }\n\n    @VisibleForTesting\n    PreferenceGroup mUserListCategory;\n    @VisibleForTesting\n    PreferenceGroup mGuestUserCategory;\n    @VisibleForTesting\n    PreferenceGroup mGuestCategory;\n    @VisibleForTesting\n    Preference mGuestResetPreference;\n    @VisibleForTesting\n    Preference mGuestExitPreference;\n    @VisibleForTesting\n    UserPreference mMePreference;\n    @VisibleForTesting\n    RestrictedPreference mAddGuest;\n    @VisibleForTesting\n    RestrictedPreference mAddUser;\n    @VisibleForTesting\n    RestrictedPreference mAddSupervisedUser;\n    @VisibleForTesting\n    SparseArray<Bitmap> mUserIcons = new SparseArray<>();\n    private int mRemovingUserId = -1;\n    private boolean mAddingUser;\n    private boolean mGuestUserAutoCreated;\n    private String mConfigSupervisedUserCreationPackage;\n    private String mAddingUserName;\n    private UserCapabilities mUserCaps;\n    private boolean mShouldUpdateUserList = true;\n    private final Object mUserLock = new Object();\n    private UserManager mUserManager;\n    private static SparseArray<Bitmap> sDarkDefaultUserBitmapCache = new SparseArray<>();\n\n    private MultiUserSwitchBarController mSwitchBarController;\n\n    private GrantAdminDialogController mGrantAdminDialogController =\n            new GrantAdminDialogController();\n    private EditUserInfoController mEditUserInfoController =\n            new EditUserInfoController(Utils.FILE_PROVIDER_AUTHORITY);\n    private CreateUserDialogController mCreateUserDialogController =\n            new CreateUserDialogController(Utils.FILE_PROVIDER_AUTHORITY);\n    private AddUserWhenLockedPreferenceController mAddUserWhenLockedPreferenceController;\n    private GuestTelephonyPreferenceController mGuestTelephonyPreferenceController;\n    private RemoveGuestOnExitPreferenceController mRemoveGuestOnExitPreferenceController;\n    private MultiUserTopIntroPreferenceController mMultiUserTopIntroPreferenceController;\n    private TimeoutToDockUserPreferenceController mTimeoutToDockUserPreferenceController;\n    private UserCreatingDialog mUserCreatingDialog;\n    private final AtomicBoolean mGuestCreationScheduled = new AtomicBoolean();\n    private final ExecutorService mExecutor = Executors.newSingleThreadExecutor();\n\n    private CharSequence mPendingUserName;\n    private Drawable mPendingUserIcon;\n    private boolean mPendingUserIsAdmin;\n\n    // A place to cache the generated default avatar\n    private Drawable mDefaultIconDrawable;\n\n    // TODO:   Replace current Handler solution to something that doesn't leak memory and works\n    // TODO:   during a configuration change\n    private Handler mHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MESSAGE_UPDATE_LIST:\n                    updateUserList();\n                    break;\n                case MESSAGE_REMOVE_GUEST_ON_EXIT_CONTROLLER_GUEST_REMOVED:\n                    updateUserList();\n                    if (mGuestUserAutoCreated) {\n                        scheduleGuestCreation();\n                    }\n                    break;\n            }\n        }\n    };\n\n    private BroadcastReceiver mUserChangeReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            if (intent.getAction().equals(Intent.ACTION_USER_REMOVED)) {\n                mRemovingUserId = -1;\n            } else if (intent.getAction().equals(Intent.ACTION_USER_INFO_CHANGED)) {\n                int userHandle = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, -1);\n                if (userHandle != -1) {\n                    mUserIcons.remove(userHandle);\n                }\n            }\n            mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n        }\n    };\n\n    @Override\n    public int getMetricsCategory() {\n        return SettingsEnums.USER;\n    }\n\n    @Override\n    public void onActivityCreated(Bundle savedInstanceState) {\n        super.onActivityCreated(savedInstanceState);\n        // Assume we are in a SettingsActivity. This is only safe because we currently use\n        // SettingsActivity as base for all preference fragments.\n        final SettingsActivity activity = (SettingsActivity) getActivity();\n        final SettingsMainSwitchBar switchBar = activity.getSwitchBar();\n        switchBar.setTitle(getContext().getString(R.string.multiple_users_main_switch_title));\n        if (isCurrentUserAdmin()) {\n            switchBar.show();\n        } else {\n            switchBar.hide();\n        }\n        mSwitchBarController = new MultiUserSwitchBarController(activity,\n                new MainSwitchBarController(switchBar), this /* listener */);\n        getSettingsLifecycle().addObserver(mSwitchBarController);\n        boolean openUserEditDialog = getIntent().getBooleanExtra(\n                EXTRA_OPEN_DIALOG_USER_PROFILE_EDITOR, false);\n        if (switchBar.isChecked() && openUserEditDialog) {\n            showDialog(DIALOG_USER_PROFILE_EDITOR);\n        }\n    }\n\n    @Override\n    public void onCreate(Bundle icicle) {\n        super.onCreate(icicle);\n        addPreferencesFromResource(R.xml.user_settings);\n        final Activity activity = getActivity();\n        if (!WizardManagerHelper.isDeviceProvisioned(activity)) {\n            activity.finish();\n            return;\n        }\n\n        mGuestUserAutoCreated = getPrefContext().getResources().getBoolean(\n                com.android.internal.R.bool.config_guestUserAutoCreated);\n\n        mAddUserWhenLockedPreferenceController = new AddUserWhenLockedPreferenceController(\n                activity, KEY_ADD_USER_WHEN_LOCKED);\n\n        mGuestTelephonyPreferenceController = new GuestTelephonyPreferenceController(\n                activity, KEY_ENABLE_GUEST_TELEPHONY);\n\n        mRemoveGuestOnExitPreferenceController = new RemoveGuestOnExitPreferenceController(\n                activity, KEY_REMOVE_GUEST_ON_EXIT, this, mHandler);\n\n        mMultiUserTopIntroPreferenceController = new MultiUserTopIntroPreferenceController(activity,\n                KEY_MULTIUSER_TOP_INTRO);\n\n        mTimeoutToDockUserPreferenceController = new TimeoutToDockUserPreferenceController(\n                activity, KEY_TIMEOUT_TO_DOCK_USER);\n\n        final PreferenceScreen screen = getPreferenceScreen();\n        mAddUserWhenLockedPreferenceController.displayPreference(screen);\n        mGuestTelephonyPreferenceController.displayPreference(screen);\n        mRemoveGuestOnExitPreferenceController.displayPreference(screen);\n        mMultiUserTopIntroPreferenceController.displayPreference(screen);\n        mTimeoutToDockUserPreferenceController.displayPreference(screen);\n\n        screen.findPreference(mAddUserWhenLockedPreferenceController.getPreferenceKey())\n                .setOnPreferenceChangeListener(mAddUserWhenLockedPreferenceController);\n\n        screen.findPreference(mGuestTelephonyPreferenceController.getPreferenceKey())\n                .setOnPreferenceChangeListener(mGuestTelephonyPreferenceController);\n\n        screen.findPreference(mRemoveGuestOnExitPreferenceController.getPreferenceKey())\n                .setOnPreferenceChangeListener(mRemoveGuestOnExitPreferenceController);\n\n        if (icicle != null) {\n            if (icicle.containsKey(SAVE_REMOVING_USER)) {\n                mRemovingUserId = icicle.getInt(SAVE_REMOVING_USER);\n            }\n            if (icicle.containsKey(SAVE_CREATE_USER)) {\n                mCreateUserDialogController.onRestoreInstanceState(icicle);\n            } else {\n                mEditUserInfoController.onRestoreInstanceState(icicle);\n            }\n        }\n\n        mUserCaps = UserCapabilities.create(activity);\n        mUserManager = (UserManager) activity.getSystemService(Context.USER_SERVICE);\n        if (!mUserCaps.mEnabled) {\n            return;\n        }\n\n        final int myUserId = UserHandle.myUserId();\n\n        mUserListCategory = (PreferenceGroup) findPreference(KEY_USER_LIST);\n        mMePreference = new UserPreference(getPrefContext(), null /* attrs */, myUserId);\n        mMePreference.setKey(KEY_USER_ME);\n        mMePreference.setOnPreferenceClickListener(this);\n        if (isCurrentUserAdmin()) {\n            mMePreference.setSummary(R.string.user_admin);\n        }\n\n        mGuestCategory = findPreference(KEY_GUEST_CATEGORY);\n\n        mGuestResetPreference = findPreference(KEY_GUEST_RESET);\n        mGuestResetPreference.setOnPreferenceClickListener(this);\n\n        mGuestExitPreference = findPreference(KEY_GUEST_EXIT);\n        mGuestExitPreference.setOnPreferenceClickListener(this);\n\n        mGuestUserCategory = findPreference(KEY_GUEST_USER_CATEGORY);\n\n        mAddGuest = findPreference(KEY_ADD_GUEST);\n        mAddGuest.setOnPreferenceClickListener(this);\n\n        mAddUser = findPreference(KEY_ADD_USER);\n        if (!mUserCaps.mCanAddRestrictedProfile) {\n            // Label should only mention adding a \"user\", not a \"profile\"\n            mAddUser.setTitle(com.android.settingslib.R.string.user_add_user);\n        }\n        mAddUser.setOnPreferenceClickListener(this);\n\n        setConfigSupervisedUserCreationPackage();\n        mAddSupervisedUser = findPreference(KEY_ADD_SUPERVISED_USER);\n        mAddSupervisedUser.setOnPreferenceClickListener(this);\n\n        activity.registerReceiverAsUser(\n                mUserChangeReceiver, UserHandle.ALL, USER_REMOVED_INTENT_FILTER, null, mHandler,\n                Context.RECEIVER_EXPORTED_UNAUDITED);\n\n        updateUI();\n        mShouldUpdateUserList = false;\n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n\n        if (!mUserCaps.mEnabled) {\n            return;\n        }\n        final PreferenceScreen screen = getPreferenceScreen();\n\n        mAddUserWhenLockedPreferenceController.updateState(screen.findPreference(\n                mAddUserWhenLockedPreferenceController.getPreferenceKey()));\n        mGuestTelephonyPreferenceController.updateState(screen.findPreference(\n                mGuestTelephonyPreferenceController.getPreferenceKey()));\n        mTimeoutToDockUserPreferenceController.updateState(screen.findPreference(\n                mTimeoutToDockUserPreferenceController.getPreferenceKey()));\n        mRemoveGuestOnExitPreferenceController.updateState(screen.findPreference(\n                mRemoveGuestOnExitPreferenceController.getPreferenceKey()));\n        if (mShouldUpdateUserList) {\n            updateUI();\n        }\n    }\n\n    @Override\n    public void onPause() {\n        mShouldUpdateUserList = true;\n        super.onPause();\n    }\n\n    @Override\n    public void onDestroy() {\n        super.onDestroy();\n\n        if (mUserCaps == null || !mUserCaps.mEnabled) {\n            return;\n        }\n\n        getActivity().unregisterReceiver(mUserChangeReceiver);\n    }\n\n    @Override\n    public void onSaveInstanceState(Bundle outState) {\n        if (mCreateUserDialogController.isActive()) {\n            outState.putBoolean(SAVE_CREATE_USER, mCreateUserDialogController.isActive());\n            mCreateUserDialogController.onSaveInstanceState(outState);\n        } else {\n            mEditUserInfoController.onSaveInstanceState(outState);\n        }\n        outState.putInt(SAVE_REMOVING_USER, mRemovingUserId);\n        super.onSaveInstanceState(outState);\n    }\n\n    @Override\n    public void startActivityForResult(Intent intent, int requestCode) {\n        mEditUserInfoController.startingActivityForResult();\n        mCreateUserDialogController.startingActivityForResult();\n        super.startActivityForResult(intent, requestCode);\n    }\n\n    @Override\n    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n        int pos = 0;\n        if (!isCurrentUserAdmin() && canSwitchUserNow() && !isCurrentUserGuest()) {\n            String nickname = mUserManager.getUserName();\n            MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                    getResources().getString(R.string.user_remove_user_menu, nickname));\n            removeThisUser.setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);\n\n            final EnforcedAdmin disallowRemoveUserAdmin =\n                    RestrictedLockUtilsInternal.checkIfRestrictionEnforced(getContext(),\n                            UserManager.DISALLOW_REMOVE_USER, UserHandle.myUserId());\n            RestrictedLockUtilsInternal.setMenuItemAsDisabledByAdmin(getContext(), removeThisUser,\n                    disallowRemoveUserAdmin);\n        }\n        super.onCreateOptionsMenu(menu, inflater);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        final int itemId = item.getItemId();\n        if (itemId == MENU_REMOVE_USER) {\n            onRemoveUserClicked(UserHandle.myUserId());\n            return true;\n        } else {\n            return super.onOptionsItemSelected(item);\n        }\n    }\n\n    @Override\n    public void onMultiUserSwitchChanged(boolean newState) {\n        updateUI();\n    }\n\n    private void updateUI() {\n        mUserCaps.updateAddUserCapabilities(getActivity());\n        loadProfile();\n        updateUserList();\n    }\n\n    /**\n     * Loads profile information for the current user.\n     */\n    private void loadProfile() {\n        if (isCurrentUserGuest()) {\n            // No need to load profile information\n            mMePreference.setIcon(getEncircledDefaultIcon());\n            mMePreference.setTitle(mGuestUserAutoCreated\n                    ? com.android.settingslib.R.string.guest_reset_guest\n                    : com.android.settingslib.R.string.guest_exit_guest);\n            mMePreference.setSelectable(true);\n            // removing a guest will result in switching back to the admin user\n            mMePreference.setEnabled(canSwitchUserNow());\n            return;\n        }\n\n        new AsyncTask<Void, Void, String>() {\n            @Override\n            protected void onPostExecute(String result) {\n                finishLoadProfile(result);\n            }\n\n            @Override\n            protected String doInBackground(Void... values) {\n                UserInfo user = mUserManager.getUserInfo(UserHandle.myUserId());\n                if (user.iconPath == null || user.iconPath.equals(\"\")) {\n                    // Assign profile photo.\n                    copyMeProfilePhoto(getActivity(), user);\n                }\n                return user.name;\n            }\n        }.execute();\n    }\n\n    private void finishLoadProfile(String profileName) {\n        if (getActivity() == null) {\n            return;\n        }\n        mMePreference.setTitle(getString(R.string.user_you, profileName));\n        int myUserId = UserHandle.myUserId();\n        Bitmap b = mUserManager.getUserIcon(myUserId);\n        if (b != null) {\n            mMePreference.setIcon(encircleUserIcon(b));\n            mUserIcons.put(myUserId, b);\n        }\n    }\n\n    private boolean hasLockscreenSecurity() {\n        LockPatternUtils lpu = new LockPatternUtils(getActivity());\n        return lpu.isSecure(UserHandle.myUserId());\n    }\n\n    private void launchChooseLockscreen() {\n        Intent chooseLockIntent = new Intent(DevicePolicyManager.ACTION_SET_NEW_PASSWORD);\n        chooseLockIntent.putExtra(ChooseLockGeneric.ChooseLockGenericFragment.HIDE_INSECURE_OPTIONS,\n                true);\n        startActivityForResult(chooseLockIntent, REQUEST_CHOOSE_LOCK);\n    }\n\n    @Override\n    public void onActivityResult(int requestCode, int resultCode, Intent data) {\n        super.onActivityResult(requestCode, resultCode, data);\n\n        if (requestCode == REQUEST_CHOOSE_LOCK) {\n            if (resultCode != Activity.RESULT_CANCELED && hasLockscreenSecurity()) {\n                addUserNow(USER_TYPE_RESTRICTED_PROFILE);\n            }\n        } else if (mGuestUserAutoCreated && requestCode == REQUEST_EDIT_GUEST\n                && resultCode == RESULT_GUEST_REMOVED) {\n            scheduleGuestCreation();\n        } else {\n            mCreateUserDialogController.onActivityResult(requestCode, resultCode, data);\n            mEditUserInfoController.onActivityResult(requestCode, resultCode, data);\n        }\n    }\n\n    private void onAddUserClicked(int userType) {\n        synchronized (mUserLock) {\n            if (mRemovingUserId == -1 && !mAddingUser) {\n                switch (userType) {\n                    case USER_TYPE_USER:\n                        showDialog(DIALOG_ADD_USER);\n                        break;\n                    case USER_TYPE_RESTRICTED_PROFILE:\n                        if (hasLockscreenSecurity()) {\n                            showDialog(DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE);\n                        } else {\n                            showDialog(DIALOG_NEED_LOCKSCREEN);\n                        }\n                        break;\n                }\n            }\n        }\n    }\n\n    private void onAddSupervisedUserClicked() {\n        final Intent intent = new Intent()\n                .setAction(UserManager.ACTION_CREATE_SUPERVISED_USER)\n                .setPackage(mConfigSupervisedUserCreationPackage)\n                .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n\n        startActivity(intent);\n    }\n\n    private void onAddGuestClicked() {\n        Context context = getContext();\n        final UserCreatingDialog guestCreatingDialog =\n                new UserCreatingDialog(getActivity(), /* isGuest= */ true);\n        guestCreatingDialog.show();\n\n        ThreadUtils.postOnBackgroundThread(() -> {\n            mMetricsFeatureProvider.action(getActivity(), SettingsEnums.ACTION_USER_GUEST_ADD);\n            Trace.beginSection(\"UserSettings.addGuest\");\n            final UserInfo guest = mUserManager.createGuest(context);\n            Trace.endSection();\n\n            ThreadUtils.postOnMainThread(() -> {\n                guestCreatingDialog.dismiss();\n                if (guest == null) {\n                    Toast.makeText(context,\n                            com.android.settingslib.R.string.add_guest_failed,\n                            Toast.LENGTH_SHORT).show();\n                    return;\n                }\n                openUserDetails(guest, true, context);\n            });\n        });\n    }\n\n    private void onRemoveUserClicked(int userId) {\n        synchronized (mUserLock) {\n            if (mRemovingUserId == -1 && !mAddingUser) {\n                mRemovingUserId = userId;\n                showDialog(DIALOG_CONFIRM_REMOVE);\n            }\n        }\n    }\n\n    private void onUserCreated(UserInfo userInfo, Context context) {\n        hideUserCreatingDialog();\n        mAddingUser = false;\n        openUserDetails(userInfo, true, context);\n    }\n\n    private void hideUserCreatingDialog() {\n        if (mUserCreatingDialog != null && mUserCreatingDialog.isShowing()) {\n            mUserCreatingDialog.dismiss();\n        }\n    }\n\n    private void onUserCreationFailed() {\n        Toast.makeText(getContext(),\n                com.android.settingslib.R.string.add_user_failed,\n                Toast.LENGTH_SHORT).show();\n        hideUserCreatingDialog();\n    }\n\n    private void openUserDetails(UserInfo userInfo, boolean newUser) {\n        openUserDetails(userInfo, newUser, getContext());\n    }\n\n    private void openUserDetails(UserInfo userInfo, boolean newUser, Context context) {\n        // to prevent a crash when config changes during user creation,\n        // we simply ignore this redirection step\n        if (context == null) {\n            return;\n        }\n\n        Bundle extras = new Bundle();\n        extras.putInt(UserDetailsSettings.EXTRA_USER_ID, userInfo.id);\n        extras.putBoolean(AppRestrictionsFragment.EXTRA_NEW_USER, newUser);\n\n        SubSettingLauncher launcher = new SubSettingLauncher(context)\n                .setDestination(UserDetailsSettings.class.getName())\n                .setArguments(extras)\n                .setTitleText(userInfo.name)\n                .setSourceMetricsCategory(getMetricsCategory());\n        if (mGuestUserAutoCreated && userInfo.isGuest()) {\n            launcher.setResultListener(this, REQUEST_EDIT_GUEST);\n        }\n        launcher.launch();\n    }\n\n    @Override\n    public void onDialogShowing() {\n        super.onDialogShowing();\n\n        setOnDismissListener(this);\n    }\n\n    @Override\n    public Dialog onCreateDialog(int dialogId) {\n        Context context = getActivity();\n        if (context == null) {\n            return null;\n        }\n        switch (dialogId) {\n            case DIALOG_CONFIRM_REMOVE: {\n                Dialog dlg =\n                        UserDialogs.createRemoveDialog(getActivity(), mRemovingUserId,\n                                new DialogInterface.OnClickListener() {\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        removeUserNow();\n                                    }\n                                }\n                        );\n                return dlg;\n            }\n            case DIALOG_USER_CANNOT_MANAGE:\n                return new AlertDialog.Builder(context)\n                        .setMessage(R.string.user_cannot_manage_message)\n                        .setPositiveButton(android.R.string.ok, null)\n                        .create();\n            case DIALOG_ADD_USER: {\n                synchronized (mUserLock) {\n                    mPendingUserName = getString(\n                            com.android.settingslib.R.string.user_new_user_name);\n                    mPendingUserIcon = null;\n                }\n                return buildAddUserDialog(USER_TYPE_USER);\n            }\n            case DIALOG_CHOOSE_USER_TYPE: {\n                List<HashMap<String, String>> data = new ArrayList<HashMap<String, String>>();\n                HashMap<String, String> addUserItem = new HashMap<String, String>();\n                addUserItem.put(KEY_TITLE, getString(\n                        com.android.settingslib.R.string.user_add_user_item_title));\n                addUserItem.put(KEY_SUMMARY, getString(\n                        com.android.settingslib.R.string.user_add_user_item_summary));\n                HashMap<String, String> addProfileItem = new HashMap<String, String>();\n                addProfileItem.put(KEY_TITLE, getString(\n                        com.android.settingslib.R.string.user_add_profile_item_title));\n                addProfileItem.put(KEY_SUMMARY, getString(\n                        com.android.settingslib.R.string.user_add_profile_item_summary));\n                data.add(addUserItem);\n                data.add(addProfileItem);\n                AlertDialog.Builder builder = new AlertDialog.Builder(context);\n                SimpleAdapter adapter = new SimpleAdapter(builder.getContext(),\n                        data, R.layout.two_line_list_item,\n                        new String[]{KEY_TITLE, KEY_SUMMARY},\n                        new int[]{R.id.title, R.id.summary});\n                builder.setTitle(com.android.settingslib.R.string.user_add_user_type_title);\n                builder.setAdapter(adapter,\n                        new DialogInterface.OnClickListener() {\n                            @Override\n                            public void onClick(DialogInterface dialog, int which) {\n                                onAddUserClicked(which == 0\n                                        ? USER_TYPE_USER\n                                        : USER_TYPE_RESTRICTED_PROFILE);\n                            }\n                        });\n                return builder.create();\n            }\n            case DIALOG_NEED_LOCKSCREEN: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setMessage(com.android.settingslib.R.string.user_need_lock_message)\n                        .setPositiveButton(com.android.settingslib.R.string.user_set_lock_button,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        launchChooseLockscreen();\n                                    }\n                                })\n                        .setNegativeButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            case DIALOG_CONFIRM_REMOVE_GUEST: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setTitle(com.android.settingslib.R.string.guest_remove_guest_dialog_title)\n                        .setMessage(R.string.user_exit_guest_confirm_message)\n                        .setPositiveButton(R.string.user_exit_guest_dialog_remove,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        clearAndExitGuest();\n                                    }\n                                })\n                        .setNegativeButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            case DIALOG_CONFIRM_EXIT_GUEST_EPHEMERAL: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setTitle(com.android.settingslib.R.string.guest_exit_dialog_title)\n                        .setMessage(com.android.settingslib.R.string.guest_exit_dialog_message)\n                        .setPositiveButton(\n                                com.android.settingslib.R.string.guest_exit_dialog_button,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        clearAndExitGuest();\n                                    }\n                                })\n                        .setNeutralButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            case DIALOG_CONFIRM_EXIT_GUEST_NON_EPHEMERAL: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setTitle(\n                            com.android.settingslib.R.string.guest_exit_dialog_title_non_ephemeral)\n                        .setMessage(\n                            com.android.settingslib\n                                .R.string.guest_exit_dialog_message_non_ephemeral)\n                        .setPositiveButton(\n                            com.android.settingslib.R.string.guest_exit_save_data_button,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        exitGuest();\n                                    }\n                                })\n                        .setNegativeButton(\n                            com.android.settingslib.R.string.guest_exit_clear_data_button,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        clearAndExitGuest();\n                                    }\n                                })\n                        .setNeutralButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            case DIALOG_USER_PROFILE_EDITOR: {\n                return buildEditCurrentUserDialog();\n            }\n            case DIALOG_USER_PROFILE_EDITOR_ADD_USER: {\n                synchronized (mUserLock) {\n                    mPendingUserName = getString(\n                            com.android.settingslib.R.string.user_new_user_name);\n                    mPendingUserIcon = null;\n                }\n                return buildAddUserDialog(USER_TYPE_USER);\n            }\n            case DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE: {\n                synchronized (mUserLock) {\n                    mPendingUserName = getString(\n                            com.android.settingslib.R.string.user_new_profile_name);\n                    mPendingUserIcon = null;\n                }\n                return buildAddUserDialog(USER_TYPE_RESTRICTED_PROFILE);\n            }\n            case DIALOG_CONFIRM_REMOVE_GUEST_WITH_AUTO_CREATE: {\n                return UserDialogs.createResetGuestDialog(getActivity(),\n                        (dialog, which) -> clearAndExitGuest());\n            }\n            case DIALOG_CONFIRM_RESET_AND_RESTART_GUEST: {\n                Dialog dlg = new AlertDialog.Builder(context)\n                        .setTitle(\n                            com.android.settingslib.R.string.guest_reset_and_restart_dialog_title)\n                        .setMessage(\n                            com.android.settingslib.R.string.guest_reset_and_restart_dialog_message)\n                        .setPositiveButton(\n                            com.android.settingslib.R.string.guest_reset_guest_confirm_button,\n                                new DialogInterface.OnClickListener() {\n                                    @Override\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        resetAndRestartGuest();\n                                    }\n                                })\n                        .setNeutralButton(android.R.string.cancel, null)\n                        .create();\n                return dlg;\n            }\n            default:\n                return null;\n        }\n    }\n\n    private Dialog buildEditCurrentUserDialog() {\n        final Activity activity = getActivity();\n        if (activity == null) {\n            return null;\n        }\n\n        UserInfo user = mUserManager.getUserInfo(Process.myUserHandle().getIdentifier());\n        Drawable userIcon = Utils.getUserIcon(activity, mUserManager, user);\n\n        return mEditUserInfoController.createDialog(\n                activity,\n                this::startActivityForResult,\n                userIcon,\n                user.name,\n                getString(com.android.settingslib.R.string.profile_info_settings_title),\n                (newUserName, newUserIcon) -> {\n                    if (newUserIcon != userIcon) {\n                        ThreadUtils.postOnBackgroundThread(() ->\n                                mUserManager.setUserIcon(user.id,\n                                        UserIcons.convertToBitmapAtUserIconSize(\n                                                activity.getResources(), newUserIcon)));\n                        mMePreference.setIcon(newUserIcon);\n                    }\n\n                    if (!TextUtils.isEmpty(newUserName) && !newUserName.equals(user.name)) {\n                        mMePreference.setTitle(newUserName);\n                        mUserManager.setUserName(user.id, newUserName);\n                    }\n                }, null);\n    }\n\n    private Dialog buildAddUserDialog(int userType) {\n        Dialog d;\n        synchronized (mUserLock) {\n            d = mCreateUserDialogController.createDialog(\n                    getActivity(),\n                    this::startActivityForResult,\n                    UserManager.isMultipleAdminEnabled(),\n                    (userName, userIcon, isAdmin) -> {\n                        mPendingUserIcon = userIcon;\n                        mPendingUserName = userName;\n                        mPendingUserIsAdmin = isAdmin;\n                        addUserNow(userType);\n                    },\n                    () -> {\n                        synchronized (mUserLock) {\n                            mPendingUserIcon = null;\n                            mPendingUserName = null;\n                        }\n                    }\n            );\n        }\n        return d;\n    }\n\n    @Override\n    public int getDialogMetricsCategory(int dialogId) {\n        switch (dialogId) {\n            case DIALOG_CONFIRM_REMOVE:\n                return SettingsEnums.DIALOG_USER_REMOVE;\n            case DIALOG_USER_CANNOT_MANAGE:\n                return SettingsEnums.DIALOG_USER_CANNOT_MANAGE;\n            case DIALOG_GRANT_ADMIN:\n                return SettingsEnums.DIALOG_GRANT_USER_ADMIN;\n            case DIALOG_ADD_USER:\n                return SettingsEnums.DIALOG_USER_ADD;\n            case DIALOG_CHOOSE_USER_TYPE:\n                return SettingsEnums.DIALOG_USER_CHOOSE_TYPE;\n            case DIALOG_NEED_LOCKSCREEN:\n                return SettingsEnums.DIALOG_USER_NEED_LOCKSCREEN;\n            case DIALOG_CONFIRM_REMOVE_GUEST:\n            case DIALOG_CONFIRM_REMOVE_GUEST_WITH_AUTO_CREATE:\n            case DIALOG_CONFIRM_EXIT_GUEST_EPHEMERAL:\n            case DIALOG_CONFIRM_EXIT_GUEST_NON_EPHEMERAL:\n            case DIALOG_CONFIRM_RESET_AND_RESTART_GUEST:\n                return SettingsEnums.DIALOG_USER_CONFIRM_EXIT_GUEST;\n            case DIALOG_USER_PROFILE_EDITOR:\n            case DIALOG_USER_PROFILE_EDITOR_ADD_USER:\n            case DIALOG_USER_PROFILE_EDITOR_ADD_RESTRICTED_PROFILE:\n                return SettingsEnums.DIALOG_USER_EDIT_PROFILE;\n            default:\n                return 0;\n        }\n    }\n\n    private void removeUserNow() {\n        if (mRemovingUserId == UserHandle.myUserId()) {\n            removeThisUser();\n        } else {\n            ThreadUtils.postOnBackgroundThread(new Runnable() {\n                @Override\n                public void run() {\n                    synchronized (mUserLock) {\n                        mUserManager.removeUser(mRemovingUserId);\n                        mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n                    }\n                }\n            });\n        }\n    }\n\n    private void removeThisUser() {\n        if (!canSwitchUserNow()) {\n            Log.w(TAG, \"Cannot remove current user when switching is disabled\");\n            return;\n        }\n        try {\n            getContext().getSystemService(UserManager.class)\n                    .removeUserWhenPossible(UserHandle.of(UserHandle.myUserId()),\n                            /* overrideDevicePolicy= */ false);\n            ActivityManager.getService().switchUser(UserHandle.USER_SYSTEM);\n        } catch (RemoteException re) {\n            Log.e(TAG, \"Unable to remove self user\");\n        }\n    }\n\n    private void switchToUserId(int userId) {\n        if (!canSwitchUserNow()) {\n            Log.w(TAG, \"Cannot switch current user when switching is disabled\");\n            return;\n        }\n        try {\n            ActivityManager.getService().switchUser(userId);\n        } catch (RemoteException re) {\n            Log.e(TAG, \"Unable to switch user\");\n        }\n    }\n\n    private void addUserNow(final int userType) {\n        Trace.beginAsyncSection(\"UserSettings.addUserNow\", 0);\n        synchronized (mUserLock) {\n            mAddingUser = true;\n            mAddingUserName = userType == USER_TYPE_USER\n                    ? (mPendingUserName != null ? mPendingUserName.toString()\n                    : getString(R.string.user_new_user_name))\n                    : (mPendingUserName != null ? mPendingUserName.toString()\n                            : getString(R.string.user_new_profile_name));\n        }\n\n        mUserCreatingDialog = new UserCreatingDialog(getActivity());\n        mUserCreatingDialog.show();\n        createUser(userType, mAddingUserName);\n    }\n\n    @VisibleForTesting\n    void createUser(final int userType, String userName) {\n        Context context = getContext();\n        Resources resources = getResources();\n        final Drawable selectedUserIcon = mPendingUserIcon;\n        Future<?> unusedCreateUserFuture = ThreadUtils.postOnBackgroundThread(() -> {\n            UserInfo user;\n\n            if (userType == USER_TYPE_USER) {\n                user = mUserManager.createUser(\n                        userName,\n                        mUserManager.USER_TYPE_FULL_SECONDARY,\n                        0);\n                if (mPendingUserIsAdmin) {\n                    mUserManager.setUserAdmin(user.id);\n                }\n            } else {\n                user = mUserManager.createRestrictedProfile(userName);\n            }\n\n            ThreadUtils.postOnMainThread(() -> {\n                if (user == null) {\n                    mAddingUser = false;\n                    mPendingUserIcon = null;\n                    mPendingUserName = null;\n                    onUserCreationFailed();\n                    return;\n                }\n\n                Future<?> unusedSettingIconFuture = ThreadUtils.postOnBackgroundThread(() -> {\n                    Drawable newUserIcon = selectedUserIcon;\n                    if (newUserIcon == null) {\n                        newUserIcon = UserIcons.getDefaultUserIcon(resources, user.id, false);\n                    }\n                    mUserManager.setUserIcon(\n                            user.id, UserIcons.convertToBitmapAtUserIconSize(\n                                    resources, newUserIcon));\n                });\n\n                mPendingUserIcon = null;\n                mPendingUserName = null;\n\n                onUserCreated(user, context);\n            });\n        });\n    }\n\n\n    /**\n     * Erase the current user (guest) and switch to another user.\n     */\n    @VisibleForTesting\n    void clearAndExitGuest() {\n        // Just to be safe\n        if (!isCurrentUserGuest()) {\n            return;\n        }\n        mMetricsFeatureProvider.action(getActivity(),\n                SettingsEnums.ACTION_USER_GUEST_EXIT_CONFIRMED);\n\n        int guestUserId = UserHandle.myUserId();\n        // Using markGuestForDeletion allows us to create a new guest before this one is\n        // fully removed.\n        boolean marked = mUserManager.markGuestForDeletion(guestUserId);\n        if (!marked) {\n            Log.w(TAG, \"Couldn't mark the guest for deletion for user \" + guestUserId);\n            return;\n        }\n\n        removeThisUser();\n        if (mGuestUserAutoCreated) {\n            scheduleGuestCreation();\n        }\n    }\n\n    /**\n     * Switch to another user.\n     */\n    private void exitGuest() {\n        // Just to be safe\n        if (!isCurrentUserGuest()) {\n            return;\n        }\n        mMetricsFeatureProvider.action(getActivity(),\n                SettingsEnums.ACTION_USER_GUEST_EXIT_CONFIRMED);\n        switchToUserId(UserHandle.USER_SYSTEM);\n    }\n\n    private int createGuest() {\n        UserInfo guest;\n        Context context = getPrefContext();\n        try {\n            guest = mUserManager.createGuest(context);\n        } catch (UserManager.UserOperationException e) {\n            Log.e(TAG, \"Couldn't create guest user\", e);\n            return UserHandle.USER_NULL;\n        }\n        if (guest == null) {\n            Log.e(TAG, \"Couldn't create guest, most likely because there already exists one\");\n            return UserHandle.USER_NULL;\n        }\n        return guest.id;\n    }\n\n    /**\n     * Remove current guest and start a new guest session\n     */\n    private void resetAndRestartGuest() {\n        // Just to be safe\n        if (!isCurrentUserGuest()) {\n            return;\n        }\n        int oldGuestUserId = UserHandle.myUserId();\n        // Using markGuestForDeletion allows us to create a new guest before this one is\n        // fully removed.\n        boolean marked = mUserManager.markGuestForDeletion(oldGuestUserId);\n        if (!marked) {\n            Log.w(TAG, \"Couldn't mark the guest for deletion for user \" + oldGuestUserId);\n            return;\n        }\n\n        try {\n            // Create a new guest in the foreground, and then immediately switch to it\n            int newGuestUserId = createGuest();\n            if (newGuestUserId == UserHandle.USER_NULL) {\n                Log.e(TAG, \"Could not create new guest, switching back to system user\");\n                switchToUserId(UserHandle.USER_SYSTEM);\n                mUserManager.removeUser(oldGuestUserId);\n                WindowManagerGlobal.getWindowManagerService().lockNow(/* options= */ null);\n                return;\n            }\n            switchToUserId(newGuestUserId);\n            mUserManager.removeUser(oldGuestUserId);\n        } catch (RemoteException e) {\n            Log.e(TAG, \"Couldn't remove guest because ActivityManager or WindowManager is dead\");\n            return;\n        }\n    }\n\n    /**\n     * Create a guest user in the background\n     */\n    @VisibleForTesting\n    void scheduleGuestCreation() {\n        // TODO(b/191067027): Move guest recreation to system_server\n        if (mGuestCreationScheduled.compareAndSet(/* expect= */ false, /* update= */ true)) {\n            // Once mGuestCreationScheduled=true, mAddGuest needs to be updated so that it shows\n            // \"Resetting guest...\"\n            mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n            mExecutor.execute(() -> {\n                UserInfo guest = mUserManager.createGuest(getContext());\n                mGuestCreationScheduled.set(false);\n                if (guest == null) {\n                    Log.e(TAG, \"Unable to automatically recreate guest user\");\n                }\n                // The list needs to be updated whether or not guest creation worked. If guest\n                // creation failed, the list needs to update so that \"Add guest\" is displayed.\n                // Otherwise, the UX could be stuck in a state where there is no way to switch to\n                // the guest user (e.g. Guest would not be selectable, and it would be stuck\n                // saying \"Resetting guest...\")\n                mHandler.sendEmptyMessage(MESSAGE_UPDATE_LIST);\n            });\n        }\n    }\n\n    @VisibleForTesting\n    void updateUserList() {\n        final Context context = getActivity();\n        if (context == null) {\n            return;\n        }\n\n        List<UserInfo> users;\n        if (mUserCaps.mUserSwitcherEnabled) {\n            // Only users that can be switched to should show up here.\n            // e.g. Managed profiles appear under Accounts Settings instead\n            users = mUserManager.getAliveUsers().stream()\n                    .filter(UserInfo::supportsSwitchToByUser)\n                    .collect(Collectors.toList());\n        } else {\n            // Only current user will be displayed in case of multi-user switch is disabled\n            users = List.of(mUserManager.getUserInfo(context.getUserId()));\n        }\n\n        final ArrayList<Integer> missingIcons = new ArrayList<>();\n        final ArrayList<UserPreference> userPreferences = new ArrayList<>();\n\n        // mMePreference shows a icon for current user. However when current user is a guest, we\n        // don't show the guest user icon, instead we show two preferences for guest user to\n        // exit and reset itself. Hence we don't add mMePreference, i.e. guest user to the\n        // list of users visible in the UI.\n        if (!isCurrentUserGuest()) {\n            userPreferences.add(mMePreference);\n        }\n\n        boolean canOpenUserDetails =\n                isCurrentUserAdmin() || (canSwitchUserNow() && !mUserCaps.mDisallowSwitchUser);\n        for (UserInfo user : users) {\n            if (user.isGuest()) {\n                // Guest user is added to guest category via updateGuestCategory\n                // and not to user list so skip guest here\n                continue;\n            }\n            UserPreference pref;\n            if (user.id == UserHandle.myUserId()) {\n                pref = mMePreference;\n            } else {\n                pref = new UserPreference(getPrefContext(), null, user.id);\n                pref.setTitle(user.name);\n                userPreferences.add(pref);\n                pref.setOnPreferenceClickListener(this);\n                pref.setEnabled(canOpenUserDetails);\n                pref.setSelectable(true);\n                pref.setKey(\"id=\" + user.id);\n                if (user.isAdmin()) {\n                    pref.setSummary(R.string.user_admin);\n                }\n            }\n            if (pref == null) {\n                continue;\n            }\n            if (user.id != UserHandle.myUserId() && !user.isGuest() && !user.isInitialized()) {\n                // sometimes after creating a guest the initialized flag isn't immediately set\n                // and we don't want to show \"Not set up\" summary for them\n                if (user.isRestricted()) {\n                    pref.setSummary(R.string.user_summary_restricted_not_set_up);\n                } else {\n                    pref.setSummary(R.string.user_summary_not_set_up);\n                    // Disallow setting up user which results in user switching when the\n                    // restriction is set.\n                    pref.setEnabled(!mUserCaps.mDisallowSwitchUser && canSwitchUserNow());\n                }\n            } else if (user.isRestricted()) {\n                pref.setSummary(R.string.user_summary_restricted_profile);\n            }\n            if (user.iconPath != null) {\n                if (mUserIcons.get(user.id) == null) {\n                    // Icon not loaded yet, print a placeholder\n                    missingIcons.add(user.id);\n                    pref.setIcon(getEncircledDefaultIcon());\n                } else {\n                    setPhotoId(pref, user);\n                }\n            } else {\n                // Icon not available yet, print a placeholder\n                pref.setIcon(getEncircledDefaultIcon());\n            }\n        }\n\n        // Add a temporary entry for the user being created\n        if (mAddingUser) {\n            UserPreference pref = new UserPreference(getPrefContext(), null,\n                    UserPreference.USERID_UNKNOWN);\n            pref.setEnabled(false);\n            pref.setTitle(mAddingUserName);\n            pref.setIcon(getEncircledDefaultIcon());\n            userPreferences.add(pref);\n        }\n\n        // Sort list of users by serialNum\n        Collections.sort(userPreferences, UserPreference.SERIAL_NUMBER_COMPARATOR);\n\n        getActivity().invalidateOptionsMenu();\n\n        // Load the icons\n        if (missingIcons.size() > 0) {\n            loadIconsAsync(missingIcons);\n        }\n\n        // If restricted profiles are supported, mUserListCategory will have a special title\n        if (mUserCaps.mCanAddRestrictedProfile) {\n            mUserListCategory.setTitle(R.string.user_list_title);\n        } else if (isCurrentUserGuest()) {\n            mUserListCategory.setTitle(R.string.other_user_category_title);\n        } else {\n            mUserListCategory.setTitle(R.string.user_category_title);\n        }\n\n        // Remove everything from mUserListCategory and add new users.\n        mUserListCategory.removeAll();\n\n        final Preference addUserOnLockScreen = getPreferenceScreen().findPreference(\n                mAddUserWhenLockedPreferenceController.getPreferenceKey());\n        mAddUserWhenLockedPreferenceController.updateState(addUserOnLockScreen);\n\n        final Preference guestCallPreference = getPreferenceScreen().findPreference(\n                mGuestTelephonyPreferenceController.getPreferenceKey());\n        mGuestTelephonyPreferenceController.updateState(guestCallPreference);\n\n        final Preference multiUserTopIntroPreference = getPreferenceScreen().findPreference(\n                mMultiUserTopIntroPreferenceController.getPreferenceKey());\n        mMultiUserTopIntroPreferenceController.updateState(multiUserTopIntroPreference);\n        updateGuestPreferences();\n        updateGuestCategory(context, users);\n        updateAddUser(context);\n        updateAddSupervisedUser(context);\n\n        for (UserPreference userPreference : userPreferences) {\n            userPreference.setOrder(Preference.DEFAULT_ORDER);\n            mUserListCategory.addPreference(userPreference);\n        }\n\n    }\n\n    @VisibleForTesting\n    void setConfigSupervisedUserCreationPackage() {\n        mConfigSupervisedUserCreationPackage = getPrefContext().getString(\n                com.android.internal.R.string.config_supervisedUserCreationPackage);\n    }\n\n    private boolean isCurrentUserGuest() {\n        return mUserCaps.mIsGuest;\n    }\n\n    private boolean isCurrentUserAdmin() {\n        return mUserCaps.mIsAdmin;\n    }\n\n    private boolean canSwitchUserNow() {\n        return mUserManager.getUserSwitchability() == UserManager.SWITCHABILITY_STATUS_OK;\n    }\n\n    private void updateGuestPreferences() {\n        // reset guest and exit guest preferences are shown only in guest mode.\n        // For all other users these are not visible.\n        mGuestCategory.setVisible(false);\n        mGuestResetPreference.setVisible(false);\n        mGuestExitPreference.setVisible(false);\n        if (!isCurrentUserGuest()) {\n            return;\n        }\n        mGuestCategory.setVisible(true);\n        mGuestExitPreference.setVisible(true);\n        mGuestResetPreference.setVisible(true);\n\n        boolean isGuestFirstLogin = Settings.Secure.getIntForUser(\n                getContext().getContentResolver(),\n                SETTING_GUEST_HAS_LOGGED_IN,\n                0,\n                UserHandle.myUserId()) <= 1;\n        String guestExitSummary;\n        if (mUserCaps.mIsEphemeral) {\n            guestExitSummary = getContext().getString(\n                    R.string.guest_notification_ephemeral);\n        } else if (isGuestFirstLogin) {\n            guestExitSummary = getContext().getString(\n                    R.string.guest_notification_non_ephemeral);\n        } else {\n            guestExitSummary = getContext().getString(\n                    R.string.guest_notification_non_ephemeral_non_first_login);\n        }\n        mGuestExitPreference.setSummary(guestExitSummary);\n    }\n\n    private void updateGuestCategory(Context context, List<UserInfo> users) {\n        // show guest category title and related guest preferences\n        // - if guest is created, then show guest user preference\n        // - if guest is not created and its allowed to create guest,\n        //   then show \"add guest\" preference\n        // - if allowed, show \"reset guest on exit\" preference\n        // - if there is nothing to show, then make the guest category as not visible\n        // - guest category is not visible for guest user.\n        UserPreference pref = null;\n        boolean isGuestAlreadyCreated = false;\n        boolean canOpenUserDetails =\n                isCurrentUserAdmin() || (canSwitchUserNow() && !mUserCaps.mDisallowSwitchUser);\n\n        mGuestUserCategory.removeAll();\n        mGuestUserCategory.setVisible(false);\n        for (UserInfo user : users) {\n            if (!user.isGuest() || !user.isEnabled()) {\n                // Only look at enabled, guest users\n                continue;\n            }\n            final Context prefContext = getPrefContext();\n            pref = new UserPreference(prefContext, null, user.id);\n            pref.setTitle(user.name);\n            pref.setOnPreferenceClickListener(this);\n            pref.setEnabled(canOpenUserDetails);\n            pref.setSelectable(true);\n            Drawable icon = getContext().getDrawable(R.drawable.ic_account_circle_outline);\n            icon.setTint(\n                    getColorAttrDefaultColor(getContext(), android.R.attr.colorControlNormal));\n            pref.setIcon(encircleUserIcon(\n                    UserIcons.convertToBitmapAtUserIconSize(\n                            getContext().getResources(), icon)));\n            pref.setKey(KEY_USER_GUEST);\n            pref.setOrder(Preference.DEFAULT_ORDER);\n            if (mUserCaps.mDisallowSwitchUser) {\n                pref.setDisabledByAdmin(\n                        RestrictedLockUtilsInternal.getDeviceOwner(context));\n            } else {\n                pref.setDisabledByAdmin(null);\n            }\n            if (mUserCaps.mUserSwitcherEnabled) {\n                mGuestUserCategory.addPreference(pref);\n                // guest user preference is shown hence also make guest category visible\n                mGuestUserCategory.setVisible(true);\n            }\n            isGuestAlreadyCreated = true;\n        }\n        boolean isVisible = updateAddGuestPreference(context, isGuestAlreadyCreated);\n        if (isVisible) {\n            // \"add guest\" preference is shown hence also make guest category visible\n            mGuestUserCategory.setVisible(true);\n        }\n        final Preference removeGuestOnExit = getPreferenceScreen().findPreference(\n                mRemoveGuestOnExitPreferenceController.getPreferenceKey());\n        mRemoveGuestOnExitPreferenceController.updateState(removeGuestOnExit);\n        if (mRemoveGuestOnExitPreferenceController.isAvailable()) {\n            // \"reset guest on exit\" preference is shown hence also make guest category visible\n            mGuestUserCategory.setVisible(true);\n        }\n        if (isCurrentUserGuest()) {\n            // guest category is not visible for guest user.\n            mGuestUserCategory.setVisible(false);\n        }\n    }\n\n    private boolean updateAddGuestPreference(Context context, boolean isGuestAlreadyCreated) {\n        boolean isVisible = false;\n        if (!isGuestAlreadyCreated && mUserCaps.mCanAddGuest\n                && mUserManager.canAddMoreUsers(UserManager.USER_TYPE_FULL_GUEST)\n                && WizardManagerHelper.isDeviceProvisioned(context)\n                && mUserCaps.mUserSwitcherEnabled) {\n            Drawable icon = context.getDrawable(R.drawable.ic_account_circle);\n            mAddGuest.setIcon(centerAndTint(icon));\n            isVisible = true;\n            mAddGuest.setVisible(true);\n            mAddGuest.setSelectable(true);\n            if (mGuestUserAutoCreated && mGuestCreationScheduled.get()) {\n                mAddGuest.setTitle(com.android.internal.R.string.guest_name);\n                mAddGuest.setSummary(R.string.guest_resetting);\n                mAddGuest.setEnabled(false);\n            } else {\n                mAddGuest.setTitle(com.android.settingslib.R.string.guest_new_guest);\n                mAddGuest.setEnabled(canSwitchUserNow());\n            }\n        } else {\n            mAddGuest.setVisible(false);\n        }\n        return isVisible;\n    }\n\n    private void updateAddUser(Context context) {\n        updateAddUserCommon(context, mAddUser, mUserCaps.mCanAddRestrictedProfile);\n        Drawable icon = context.getDrawable(R.drawable.ic_account_circle_filled);\n        mAddUser.setIcon(centerAndTint(icon));\n    }\n\n    private void updateAddSupervisedUser(Context context) {\n        if (!TextUtils.isEmpty(mConfigSupervisedUserCreationPackage)) {\n            updateAddUserCommon(context, mAddSupervisedUser, false);\n            Drawable icon = context.getDrawable(R.drawable.ic_add_supervised_user);\n            mAddSupervisedUser.setIcon(centerAndTint(icon));\n        } else {\n            mAddSupervisedUser.setVisible(false);\n        }\n    }\n\n    private void updateAddUserCommon(Context context, RestrictedPreference addUser,\n            boolean canAddRestrictedProfile) {\n        if ((mUserCaps.mCanAddUser && !mUserCaps.mDisallowAddUserSetByAdmin)\n                && WizardManagerHelper.isDeviceProvisioned(context)\n                && mUserCaps.mUserSwitcherEnabled) {\n            addUser.setVisible(true);\n            addUser.setSelectable(true);\n            final boolean canAddMoreUsers =\n                    mUserManager.canAddMoreUsers(UserManager.USER_TYPE_FULL_SECONDARY)\n                            || (canAddRestrictedProfile\n                            && mUserManager.canAddMoreUsers(UserManager.USER_TYPE_FULL_RESTRICTED));\n            addUser.setEnabled(canAddMoreUsers && !mAddingUser && canSwitchUserNow());\n\n            if (!canAddMoreUsers) {\n                addUser.setSummary(getString(R.string.user_add_max_count));\n            } else {\n                addUser.setSummary(null);\n            }\n            if (addUser.isEnabled()) {\n                addUser.setDisabledByAdmin(\n                        mUserCaps.mDisallowAddUser ? mUserCaps.mEnforcedAdmin : null);\n            }\n        } else {\n            addUser.setVisible(false);\n        }\n    }\n\n    private Drawable centerAndTint(Drawable icon) {\n        icon.setTintBlendMode(BlendMode.SRC_IN);\n        icon.setTint(getColorAttrDefaultColor(getContext(), android.R.attr.textColorPrimary));\n\n        Drawable bg = getContext().getDrawable(R.drawable.user_avatar_bg).mutate();\n        LayerDrawable ld = new LayerDrawable(new Drawable[] {bg, icon});\n        int size = getContext().getResources().getDimensionPixelSize(\n                R.dimen.multiple_users_avatar_size);\n        int bgSize = getContext().getResources().getDimensionPixelSize(\n                R.dimen.multiple_users_user_icon_size);\n        ld.setLayerSize(1, size, size);\n        ld.setLayerSize(0, bgSize, bgSize);\n        ld.setLayerGravity(1, Gravity.CENTER);\n\n        return ld;\n    }\n\n    /**\n     * @return number of non-guest non-managed users\n     */\n    @VisibleForTesting\n    int getRealUsersCount() {\n        return (int) mUserManager.getUsers()\n                .stream()\n                .filter(user -> !user.isGuest() && !user.isProfile())\n                .count();\n    }\n\n    private void loadIconsAsync(List<Integer> missingIcons) {\n        new AsyncTask<List<Integer>, Void, Void>() {\n            @Override\n            protected void onPostExecute(Void result) {\n                updateUserList();\n            }\n\n            @Override\n            protected Void doInBackground(List<Integer>... values) {\n                for (int userId : values[0]) {\n                    Bitmap bitmap = mUserManager.getUserIcon(userId);\n                    if (bitmap == null) {\n                        bitmap = getDefaultUserIconAsBitmap(getContext().getResources(), userId);\n                    }\n                    mUserIcons.append(userId, bitmap);\n                }\n                return null;\n            }\n        }.execute(missingIcons);\n    }\n\n    private Drawable getEncircledDefaultIcon() {\n        if (mDefaultIconDrawable == null) {\n            mDefaultIconDrawable = encircleUserIcon(\n                    getDefaultUserIconAsBitmap(getContext().getResources(), UserHandle.USER_NULL));\n        }\n        return mDefaultIconDrawable;\n    }\n\n    private void setPhotoId(Preference pref, UserInfo user) {\n        Bitmap bitmap = mUserIcons.get(user.id);\n        if (bitmap != null) {\n            pref.setIcon(encircleUserIcon(bitmap));\n        }\n    }\n\n    @Override\n    public boolean onPreferenceClick(Preference pref) {\n        mMetricsFeatureProvider.logSettingsTileClick(pref.getKey(), getMetricsCategory());\n        if (isCurrentUserGuest()) {\n            if (mGuestResetPreference != null && pref == mGuestResetPreference) {\n                showDialog(DIALOG_CONFIRM_RESET_AND_RESTART_GUEST);\n                return true;\n            }\n            if (mGuestExitPreference != null && pref == mGuestExitPreference) {\n                if (mUserCaps.mIsEphemeral) {\n                    showDialog(DIALOG_CONFIRM_EXIT_GUEST_EPHEMERAL);\n                } else {\n                    showDialog(DIALOG_CONFIRM_EXIT_GUEST_NON_EPHEMERAL);\n                }\n                return true;\n            }\n        }\n        if (pref == mMePreference) {\n            if (!isCurrentUserGuest()) {\n                showDialog(DIALOG_USER_PROFILE_EDITOR);\n                return true;\n            }\n        } else if (pref instanceof UserPreference) {\n            UserInfo userInfo = mUserManager.getUserInfo(((UserPreference) pref).getUserId());\n            openUserDetails(userInfo, false);\n            return true;\n        } else if (pref == mAddUser) {\n            mMetricsFeatureProvider.action(getActivity(), SettingsEnums.ACTION_USER_ADD);\n            // If we allow both types, show a picker, otherwise directly go to\n            // flow for full user.\n            if (mUserCaps.mCanAddRestrictedProfile) {\n                showDialog(DIALOG_CHOOSE_USER_TYPE);\n            } else {\n                onAddUserClicked(USER_TYPE_USER);\n            }\n            return true;\n        } else if (pref == mAddSupervisedUser) {\n            mMetricsFeatureProvider.action(getActivity(), SettingsEnums.ACTION_USER_SUPERVISED_ADD);\n            Trace.beginSection(\"UserSettings.addSupervisedUser\");\n            onAddSupervisedUserClicked();\n            Trace.endSection();\n            return true;\n        } else if (pref == mAddGuest) {\n            mAddGuest.setEnabled(false); // prevent multiple tap issue\n            onAddGuestClicked();\n            return true;\n        }\n        return false;\n    }\n\n    private Drawable encircleUserIcon(Bitmap icon) {\n        return new CircleFramedDrawable(\n                icon,\n                getActivity().getResources().getDimensionPixelSize(\n                        R.dimen.multiple_users_user_icon_size));\n    }\n\n    @Override\n    public void onDismiss(DialogInterface dialog) {\n        synchronized (mUserLock) {\n            mRemovingUserId = -1;\n            updateUserList();\n            if (mCreateUserDialogController.isActive()) {\n                mCreateUserDialogController.clear();\n            }\n        }\n    }\n\n    @Override\n    public int getHelpResource() {\n        return R.string.help_url_users;\n    }\n\n    /**\n     * Returns a default user icon (as a {@link Bitmap}) for the given user.\n     *\n     * Note that for guest users, you should pass in {@code UserHandle.USER_NULL}.\n     *\n     * @param resources resources object to fetch the user icon.\n     * @param userId    the user id or {@code UserHandle.USER_NULL} for a non-user specific icon\n     */\n    private static Bitmap getDefaultUserIconAsBitmap(Resources resources, int userId) {\n        Bitmap bitmap = null;\n        // Try finding the corresponding bitmap in the dark bitmap cache\n        bitmap = sDarkDefaultUserBitmapCache.get(userId);\n        if (bitmap == null) {\n            bitmap = UserIcons.convertToBitmapAtUserIconSize(resources,\n                    UserIcons.getDefaultUserIcon(resources, userId, false));\n            // Save it to cache\n            sDarkDefaultUserBitmapCache.put(userId, bitmap);\n        }\n        return bitmap;\n    }\n\n    /**\n     * Assign the default photo to user with {@paramref userId}\n     *\n     * @param context used to get the {@link UserManager}\n     * @param userId  used to get the icon bitmap\n     * @return true if assign photo successfully, false if failed\n     */\n    @VisibleForTesting\n    static boolean assignDefaultPhoto(Context context, int userId) {\n        if (context == null) {\n            return false;\n        }\n        UserManager um = (UserManager) context.getSystemService(Context.USER_SERVICE);\n        Bitmap bitmap = getDefaultUserIconAsBitmap(context.getResources(), userId);\n        um.setUserIcon(userId, bitmap);\n\n        return true;\n    }\n\n    @WorkerThread\n    static void copyMeProfilePhoto(Context context, UserInfo user) {\n        Uri contactUri = ContactsContract.Profile.CONTENT_URI;\n\n        int userId = user != null ? user.id : UserHandle.myUserId();\n\n        InputStream avatarDataStream = ContactsContract.Contacts.openContactPhotoInputStream(\n                context.getContentResolver(),\n                contactUri, true);\n        // If there's no profile photo, assign a default avatar\n        if (avatarDataStream == null) {\n            assignDefaultPhoto(context, userId);\n            return;\n        }\n\n        UserManager um = (UserManager) context.getSystemService(Context.USER_SERVICE);\n        Bitmap decodedIcon = BitmapFactory.decodeStream(avatarDataStream);\n        CircleFramedDrawable drawable = CircleFramedDrawable.getInstance(context, decodedIcon);\n        Bitmap icon = UserIcons.convertToBitmapAtUserIconSize(context.getResources(), drawable);\n\n        um.setUserIcon(userId, icon);\n        try {\n            avatarDataStream.close();\n        } catch (IOException ioe) {\n        }\n    }\n\n    public static final BaseSearchIndexProvider SEARCH_INDEX_DATA_PROVIDER =\n            new BaseSearchIndexProvider(R.xml.user_settings) {\n\n                @Override\n                protected boolean isPageSearchEnabled(Context context) {\n                    final UserCapabilities userCaps = UserCapabilities.create(context);\n                    return userCaps.mEnabled;\n                }\n\n                @Override\n                public List<SearchIndexableRaw> getRawDataToIndex(Context context,\n                        boolean enabled) {\n                    final List<SearchIndexableRaw> rawData = new ArrayList<>();\n\n                    SearchIndexableRaw allowMultipleUsersResult = new SearchIndexableRaw(context);\n\n                    allowMultipleUsersResult.key = KEY_ALLOW_MULTIPLE_USERS;\n                    allowMultipleUsersResult.title =\n                            context.getString(R.string.multiple_users_main_switch_title);\n                    allowMultipleUsersResult.keywords =\n                            context.getString(R.string.multiple_users_main_switch_keywords);\n                    allowMultipleUsersResult.screenTitle =\n                            context.getString(R.string.user_settings_title);\n                    allowMultipleUsersResult.className =\n                            MultiUserSwitchBarController.class.getName();\n\n                    rawData.add(allowMultipleUsersResult);\n                    return rawData;\n                }\n\n                @Override\n                public List<String> getNonIndexableKeysFromXml(Context context, int xmlResId,\n                        boolean suppressAllPage) {\n                    final List<String> niks = super.getNonIndexableKeysFromXml(context, xmlResId,\n                            suppressAllPage);\n                    AddUserWhenLockedPreferenceController controller =\n                            new AddUserWhenLockedPreferenceController(\n                                    context, KEY_ADD_USER_WHEN_LOCKED);\n                    controller.updateNonIndexableKeys(niks);\n                    new AutoSyncDataPreferenceController(context, null /* parent */)\n                            .updateNonIndexableKeys(niks);\n                    new AutoSyncPersonalDataPreferenceController(context, null /* parent */)\n                            .updateNonIndexableKeys(niks);\n                    new AutoSyncWorkDataPreferenceController(context, null /* parent */)\n                            .updateNonIndexableKeys(niks);\n                    return niks;\n                }\n            };\n}\n```"
                    }
                ]
            }
        ],
        "upstream_patch_content": "From 69c7f5dac580361792bbb189178653b297d06c8a Mon Sep 17 00:00:00 2001\nFrom: Adam Bookatz <bookatz@google.com>\nDate: Mon, 18 Nov 2024 15:53:41 -0800\nSubject: [PATCH] Don't let profiles open the UserSettings overflow\n\nReally, profiles aren't expected to open Settings at all. But if they\ndo somehow, the overflow shouldn't appear.\n\nBug: 352542820\nFlag: EXEMPT bugfix\nTest: Try to access the overflow of the work profile by launching its Settings in\nadb shell am start --user 10 'com.android.settings/.Settings\\$UserSettingsActivity'\n\nChange-Id: I5e4c095cda3e19fa5c63c2c550a526f5da8ec5c1\n---\n src/com/android/settings/users/UserSettings.java | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\ndiff --git a/src/com/android/settings/users/UserSettings.java b/src/com/android/settings/users/UserSettings.java\nindex 0881b29a3b3..589f512ac23 100644\n--- a/src/com/android/settings/users/UserSettings.java\n+++ b/src/com/android/settings/users/UserSettings.java\n@@ -465,7 +465,7 @@ public class UserSettings extends SettingsPreferenceFragment\n     public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n         int pos = 0;\n         if (!isCurrentUserAdmin() && (canSwitchUserNow() || Flags.newMultiuserSettingsUx())\n-                && !isCurrentUserGuest()) {\n+                && !isCurrentUserGuest() && !mUserManager.isProfile()) {\n             String nickname = mUserManager.getUserName();\n             MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                     getResources().getString(R.string.user_remove_user_menu, nickname));\n-- \n2.39.5 (Apple Git-154)\n\n",
        "upstream_commits": [
            "69c7f5dac580361792bbb189178653b297d06c8a"
        ]
    },
    {
        "id": "ASB-A-296915500",
        "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-296915500",
        "severity": "High",
        "failures": [
            {
                "downstream_version": "13",
                "branch_used": "android13-release",
                "downstream_patch": "5bcfd347823f1d3893d843db2286f2013923fad8",
                "repo_path": "android_repos/Bluetooth",
                "result": "failure",
                "downstream_patch_content": "commit 5bcfd347823f1d3893d843db2286f2013923fad8\nAuthor: Billy Huang <billyhuang@google.com>\nDate:   Wed Oct 2 14:45:37 2024 -0700\n\n    RESTRICT AUTOMERGE backport \"opp: validate that content uri belongs to current user\"\n    \n    Bug: 296915500\n    Flag: EXEMPT trivial fix with complete testing coverage\n    Test: atest GoogleBluetoothInstrumentationTests:BluetoothOppSendFileInfoTest\n    Ignore-AOSP-First: fix for undisclosed vulnerability\n    Merged-In: I76b25fcd446d5e0530308e21deafa68d0b768edc\n    Change-Id: Ibff36089bfde4b5bb28d797aeae1423b668943a2\n\ndiff --git a/android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java b/android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java\nindex 46e3ba144e..10087c9f16 100644\n--- a/android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java\n+++ b/android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java\n@@ -32,6 +32,8 @@\n \n package com.android.bluetooth.opp;\n \n+import static android.os.UserHandle.myUserId;\n+\n import android.content.ContentResolver;\n import android.content.Context;\n import android.content.res.AssetFileDescriptor;\n@@ -39,6 +41,7 @@ import android.database.Cursor;\n import android.database.sqlite.SQLiteException;\n import android.net.Uri;\n import android.provider.OpenableColumns;\n+import android.text.TextUtils;\n import android.util.EventLog;\n import android.util.Log;\n \n@@ -48,6 +51,7 @@ import java.io.File;\n import java.io.FileInputStream;\n import java.io.FileNotFoundException;\n import java.io.IOException;\n+import java.util.Objects;\n \n /**\n  * This class stores information about a single sending file It will only be\n@@ -116,6 +120,11 @@ public class BluetoothOppSendFileInfo {\n                 return SEND_FILE_INFO_ERROR;\n             }\n \n+            if (isContentUriForOtherUser(uri)) {\n+                Log.e(TAG, \"Uri: \" + uri + \" is invalid for user \" + myUserId());\n+                return SEND_FILE_INFO_ERROR;\n+            }\n+\n             contentType = contentResolver.getType(uri);\n             Cursor metadataCursor;\n             try {\n@@ -247,6 +256,12 @@ public class BluetoothOppSendFileInfo {\n         return new BluetoothOppSendFileInfo(fileName, contentType, length, is, 0);\n     }\n \n+    private static boolean isContentUriForOtherUser(Uri uri) {\n+        String uriUserId = uri.getUserInfo();\n+        return !TextUtils.isEmpty(uriUserId)\n+                && !Objects.equals(uriUserId, String.valueOf(myUserId()));\n+    }\n+\n     private static long getStreamSize(FileInputStream is) throws IOException {\n         long length = 0;\n         byte[] unused = new byte[4096];\ndiff --git a/android/app/tests/unit/src/com/android/bluetooth/opp/BluetoothOppSendFileInfoTest.java b/android/app/tests/unit/src/com/android/bluetooth/opp/BluetoothOppSendFileInfoTest.java\nnew file mode 100644\nindex 0000000000..9fb93ac968\n--- /dev/null\n+++ b/android/app/tests/unit/src/com/android/bluetooth/opp/BluetoothOppSendFileInfoTest.java\n@@ -0,0 +1,205 @@\n+/*\n+ * Copyright 2024 The Android Open Source Project\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.android.bluetooth.opp;\n+\n+import static android.os.UserHandle.myUserId;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+\n+import android.content.ContentResolver;\n+import android.content.Context;\n+import android.content.IContentProvider;\n+import android.content.pm.ApplicationInfo;\n+import android.content.res.AssetFileDescriptor;\n+import android.database.MatrixCursor;\n+import android.net.Uri;\n+import android.os.Build;\n+import android.provider.OpenableColumns;\n+import android.test.mock.MockContentProvider;\n+import android.test.mock.MockContext;\n+\n+import androidx.test.runner.AndroidJUnit4;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import java.io.FileInputStream;\n+\n+@RunWith(AndroidJUnit4.class)\n+public class BluetoothOppSendFileInfoTest {\n+    public static final String PROVIDER_NAME_MEDIA = \"media\";\n+    TestContext mContext;\n+    TestContentResolver mContentResolver;\n+    MockContentProvider mContentProvider;\n+    MatrixCursor mCursor;\n+\n+    private static Uri buildContentUriWithEncodedAuthority(String authority) {\n+        return new Uri.Builder().scheme(\"content\")\n+                .encodedAuthority(authority)\n+                .path(\"external/images/media/1\")\n+                .build();\n+    }\n+\n+    @Before\n+    public void setUp() {\n+        mContext = new TestContext();\n+        mContentResolver = mContext.getContentResolver();\n+        mContentProvider = mContext.getContentProvider();\n+    }\n+\n+    @Test\n+    public void generateFileInfo_withContentUriForOtherUser_returnsSendFileInfoError()\n+            throws Exception {\n+        String type = \"image/jpeg\";\n+        Uri uri = buildContentUriWithEncodedAuthority((myUserId() + 1) + \"@\" + PROVIDER_NAME_MEDIA);\n+        doReturn(type).when(mContentProvider).getType(any());\n+        long fileLength = 1000;\n+        String fileName = \"pic.jpg\";\n+        FileInputStream fs = mock(FileInputStream.class);\n+        AssetFileDescriptor fd = mock(AssetFileDescriptor.class);\n+        doReturn(fileLength).when(fd).getLength();\n+        doReturn(fs).when(fd).createInputStream();\n+        doReturn(fd).when(mContentProvider).openAssetFile(eq(uri), any(), any());\n+        mCursor =\n+                new MatrixCursor(new String[]{OpenableColumns.DISPLAY_NAME, OpenableColumns.SIZE});\n+        mCursor.addRow(new Object[]{fileName, fileLength});\n+        doReturn(mCursor).when(mContentProvider).query(eq(uri), any(), any(), any(), any());\n+        BluetoothOppSendFileInfo info =\n+                BluetoothOppSendFileInfo.generateFileInfo(mContext, uri, type, true);\n+        assertThat(info).isEqualTo(BluetoothOppSendFileInfo.SEND_FILE_INFO_ERROR);\n+    }\n+\n+    @Test\n+    public void generateFileInfo_withContentUriForImplicitUser_returnsInfoWithCorrectLength()\n+            throws Exception {\n+        String type = \"image/jpeg\";\n+        Uri uri = buildContentUriWithEncodedAuthority(PROVIDER_NAME_MEDIA);\n+        doReturn(type).when(mContentProvider).getType(any());\n+        long fileLength = 1000;\n+        String fileName = \"pic.jpg\";\n+        FileInputStream fs = mock(FileInputStream.class);\n+        AssetFileDescriptor fd = mock(AssetFileDescriptor.class);\n+        doReturn(fileLength).when(fd).getLength();\n+        doReturn(fs).when(fd).createInputStream();\n+        doReturn(fd).when(mContentProvider).openAssetFile(eq(uri), any(), any());\n+        mCursor =\n+                new MatrixCursor(new String[]{OpenableColumns.DISPLAY_NAME, OpenableColumns.SIZE});\n+        mCursor.addRow(new Object[]{fileName, fileLength});\n+        doReturn(mCursor).when(mContentProvider).query(eq(uri), any(), any(), any(), any());\n+        BluetoothOppSendFileInfo info =\n+                BluetoothOppSendFileInfo.generateFileInfo(mContext, uri, type, true);\n+        assertThat(info.mInputStream).isEqualTo(fs);\n+        assertThat(info.mFileName).isEqualTo(fileName);\n+        assertThat(info.mLength).isEqualTo(fileLength);\n+        assertThat(info.mStatus).isEqualTo(0);\n+    }\n+\n+    @Test\n+    public void generateFileInfo_withContentUriForSameUser_returnsInfoWithCorrectLength()\n+            throws Exception {\n+        String type = \"image/jpeg\";\n+        Uri uri = buildContentUriWithEncodedAuthority(myUserId() + \"@\" + PROVIDER_NAME_MEDIA);\n+        doReturn(type).when(mContentProvider).getType(any());\n+        long fileLength = 1000;\n+        String fileName = \"pic.jpg\";\n+        FileInputStream fs = mock(FileInputStream.class);\n+        AssetFileDescriptor fd = mock(AssetFileDescriptor.class);\n+        doReturn(fileLength).when(fd).getLength();\n+        doReturn(fs).when(fd).createInputStream();\n+        doReturn(fd).when(mContentProvider).openAssetFile(eq(uri), any(), any());\n+        mCursor =\n+                new MatrixCursor(new String[]{OpenableColumns.DISPLAY_NAME, OpenableColumns.SIZE});\n+        mCursor.addRow(new Object[]{fileName, fileLength});\n+        doReturn(mCursor).when(mContentProvider).query(eq(uri), any(), any(), any(), any());\n+        BluetoothOppSendFileInfo info =\n+                BluetoothOppSendFileInfo.generateFileInfo(mContext, uri, type, true);\n+        assertThat(info.mInputStream).isEqualTo(fs);\n+        assertThat(info.mFileName).isEqualTo(fileName);\n+        assertThat(info.mLength).isEqualTo(fileLength);\n+        assertThat(info.mStatus).isEqualTo(0);\n+    }\n+\n+    public static final class TestContext extends MockContext {\n+        private final TestContentResolver mContentResolver;\n+        private final MockContentProvider mContentProvider;\n+\n+        public TestContext() {\n+            mContentProvider = spy(new MockContentProvider(this));\n+            mContentResolver = new TestContentResolver(this, mContentProvider);\n+        }\n+\n+        @Override\n+        public TestContentResolver getContentResolver() {\n+            return mContentResolver;\n+        }\n+\n+        public MockContentProvider getContentProvider() {\n+            return mContentProvider;\n+        }\n+\n+        @Override\n+        public String getOpPackageName() {\n+            return \"test.package\";\n+        }\n+\n+        @Override\n+        public ApplicationInfo getApplicationInfo() {\n+            ApplicationInfo applicationInfo = new ApplicationInfo();\n+            applicationInfo.targetSdkVersion = Build.VERSION.SDK_INT;\n+            return applicationInfo;\n+        }\n+    }\n+\n+    public static final class TestContentResolver extends ContentResolver {\n+        private final MockContentProvider mContentProvider;\n+\n+        public TestContentResolver(Context context, MockContentProvider contentProvider) {\n+            super(context, contentProvider);\n+            mContentProvider = contentProvider;\n+        }\n+\n+        @Override\n+        protected IContentProvider acquireProvider(Context c, String name) {\n+            return mContentProvider.getIContentProvider();\n+        }\n+\n+        @Override\n+        public boolean releaseProvider(IContentProvider icp) {\n+            return true;\n+        }\n+\n+        @Override\n+        protected IContentProvider acquireUnstableProvider(Context c, String name) {\n+            return mContentProvider.getIContentProvider();\n+        }\n+\n+        @Override\n+        public boolean releaseUnstableProvider(IContentProvider icp) {\n+            return true;\n+        }\n+\n+        @Override\n+        public void unstableProviderDied(IContentProvider icp) {\n+        }\n+    }\n+}\n",
                "file_conflicts": [
                    {
                        "file_name": "android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java",
                        "total_hunks": 5,
                        "failed_hunks": [
                            1,
                            3
                        ],
                        "inline_merge_conflicts": [],
                        "rej_file_content": "```diff\n--- android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java\n+++ android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java\n@@ -32,6 +32,8 @@\n \n package com.android.bluetooth.opp;\n \n+import static android.os.UserHandle.myUserId;\n+\n import android.bluetooth.BluetoothProfile;\n import android.bluetooth.BluetoothProtoEnums;\n import android.content.ContentResolver;\n@@ -54,12 +57,13 @@ import java.io.File;\n import java.io.FileInputStream;\n import java.io.FileNotFoundException;\n import java.io.IOException;\n+import java.util.Objects;\n \n /**\n  * This class stores information about a single sending file It will only be used for outbound\n  * share.\n  */\n-// Next tag value for ContentProfileErrorReportUtils.report(): 15\n+// Next tag value for ContentProfileErrorReportUtils.report(): 16\n public class BluetoothOppSendFileInfo {\n     private static final String TAG = \"BluetoothOppSendFileInfo\";\n```",
                        "patch_apply_output": "patching file android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java\nHunk #1 FAILED at 32.\nHunk #2 succeeded at 39 (offset -2 lines).\nHunk #3 FAILED at 54.\nHunk #4 succeeded at 117 (offset -8 lines).\nHunk #5 succeeded at 258 (offset -106 lines).\n2 out of 5 hunks FAILED -- saving rejects to file android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java.rej",
                        "inline_merge_output": "patching file android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java\nHunk #1 already applied at 35-36.\nHunk #2 already applied at 46.\nHunk #3 already applied at 59,65.\nHunk #5 merged at 386-391.",
                        "upstream_file_content": "```java\n/*\n * Copyright (c) 2008-2009, Motorola, Inc.\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * - Neither the name of the Motorola, Inc. nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage com.android.bluetooth.opp;\n\nimport static android.os.UserHandle.myUserId;\n\nimport android.bluetooth.BluetoothProfile;\nimport android.bluetooth.BluetoothProtoEnums;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.res.AssetFileDescriptor;\nimport android.database.Cursor;\nimport android.database.sqlite.SQLiteException;\nimport android.net.Uri;\nimport android.provider.OpenableColumns;\nimport android.text.TextUtils;\nimport android.util.EventLog;\nimport android.util.Log;\n\nimport com.android.bluetooth.BluetoothMethodProxy;\nimport com.android.bluetooth.BluetoothStatsLog;\nimport com.android.bluetooth.R;\nimport com.android.bluetooth.content_profiles.ContentProfileErrorReportUtils;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.util.Objects;\n\n/**\n * This class stores information about a single sending file It will only be used for outbound\n * share.\n */\n// Next tag value for ContentProfileErrorReportUtils.report(): 16\npublic class BluetoothOppSendFileInfo {\n    private static final String TAG = \"BluetoothOppSendFileInfo\";\n\n    /** Reusable SendFileInfo for error status. */\n    static final BluetoothOppSendFileInfo SEND_FILE_INFO_ERROR =\n            new BluetoothOppSendFileInfo(null, null, 0, null, BluetoothShare.STATUS_FILE_ERROR);\n\n    /** readable media file name */\n    public final String mFileName;\n\n    /** media file input stream */\n    public final FileInputStream mInputStream;\n\n    /** vCard string data */\n    public final String mData;\n\n    public final int mStatus;\n\n    public final String mMimetype;\n\n    public final long mLength;\n\n    /** for media file */\n    public BluetoothOppSendFileInfo(\n            String fileName, String type, long length, FileInputStream inputStream, int status) {\n        mFileName = fileName;\n        mMimetype = type;\n        mLength = length;\n        mInputStream = inputStream;\n        mStatus = status;\n        mData = null;\n    }\n\n    /** for vCard, or later for vCal, vNote. Not used currently */\n    public BluetoothOppSendFileInfo(String data, String type, long length, int status) {\n        mFileName = null;\n        mInputStream = null;\n        mData = data;\n        mMimetype = type;\n        mLength = length;\n        mStatus = status;\n    }\n\n    public static BluetoothOppSendFileInfo generateFileInfo(\n            Context context, Uri uri, String type, boolean fromExternal) {\n        ContentResolver contentResolver = context.getContentResolver();\n        String scheme = uri.getScheme();\n        String fileName = null;\n        String contentType;\n        long length = 0;\n        // Support all Uri with \"content\" scheme\n        // This will allow more 3rd party applications to share files via\n        // bluetooth\n        if (\"content\".equals(scheme)) {\n            if (fromExternal && BluetoothOppUtility.isForbiddenContent(uri)) {\n                EventLog.writeEvent(0x534e4554, \"179910660\", -1, uri.toString());\n                Log.e(TAG, \"Content from forbidden URI is not allowed.\");\n                ContentProfileErrorReportUtils.report(\n                        BluetoothProfile.OPP,\n                        BluetoothProtoEnums.BLUETOOTH_OPP_SEND_FILE_INFO,\n                        BluetoothStatsLog.BLUETOOTH_CONTENT_PROFILE_ERROR_REPORTED__TYPE__LOG_ERROR,\n                        0);\n                return SEND_FILE_INFO_ERROR;\n            }\n\n            if (isContentUriForOtherUser(uri)) {\n                Log.e(TAG, \"Uri: \" + uri + \" is invalid for user \" + myUserId());\n                ContentProfileErrorReportUtils.report(\n                        BluetoothProfile.OPP,\n                        BluetoothProtoEnums.BLUETOOTH_OPP_SEND_FILE_INFO,\n                        BluetoothStatsLog.BLUETOOTH_CONTENT_PROFILE_ERROR_REPORTED__TYPE__LOG_ERROR,\n                        15);\n                return SEND_FILE_INFO_ERROR;\n            }\n\n            contentType = contentResolver.getType(uri);\n            Cursor metadataCursor;\n            try {\n                metadataCursor =\n                        BluetoothMethodProxy.getInstance()\n                                .contentResolverQuery(\n                                        contentResolver,\n                                        uri,\n                                        new String[] {\n                                            OpenableColumns.DISPLAY_NAME, OpenableColumns.SIZE\n                                        },\n                                        null,\n                                        null,\n                                        null);\n            } catch (SQLiteException e) {\n                ContentProfileErrorReportUtils.report(\n                        BluetoothProfile.OPP,\n                        BluetoothProtoEnums.BLUETOOTH_OPP_SEND_FILE_INFO,\n                        BluetoothStatsLog.BLUETOOTH_CONTENT_PROFILE_ERROR_REPORTED__TYPE__EXCEPTION,\n                        1);\n                // some content providers don't support the DISPLAY_NAME or SIZE columns\n                metadataCursor = null;\n            } catch (SecurityException e) {\n                ContentProfileErrorReportUtils.report(\n                        BluetoothProfile.OPP,\n                        BluetoothProtoEnums.BLUETOOTH_OPP_SEND_FILE_INFO,\n                        BluetoothStatsLog.BLUETOOTH_CONTENT_PROFILE_ERROR_REPORTED__TYPE__EXCEPTION,\n                        2);\n                Log.e(TAG, \"generateFileInfo: Permission error, could not access URI: \" + uri);\n                return SEND_FILE_INFO_ERROR;\n            }\n\n            if (metadataCursor != null) {\n                try {\n                    if (metadataCursor.moveToFirst()) {\n                        int indexName = metadataCursor.getColumnIndex(OpenableColumns.DISPLAY_NAME);\n                        int indexSize = metadataCursor.getColumnIndex(OpenableColumns.SIZE);\n                        if (indexName != -1) {\n                            fileName = metadataCursor.getString(indexName);\n                        }\n                        if (indexSize != -1) {\n                            length = metadataCursor.getLong(indexSize);\n                        }\n                        Log.d(TAG, \"fileName = \" + fileName + \" length = \" + length);\n                    }\n                } finally {\n                    metadataCursor.close();\n                }\n            }\n            if (fileName == null) {\n                // use last segment of URI if DISPLAY_NAME query fails\n                fileName = uri.getLastPathSegment();\n                Log.d(TAG, \"fileName from URI :\" + fileName);\n            }\n        } else if (\"file\".equals(scheme)) {\n            if (uri.getPath() == null) {\n                Log.e(TAG, \"Invalid URI path: \" + uri);\n                ContentProfileErrorReportUtils.report(\n                        BluetoothProfile.OPP,\n                        BluetoothProtoEnums.BLUETOOTH_OPP_SEND_FILE_INFO,\n                        BluetoothStatsLog.BLUETOOTH_CONTENT_PROFILE_ERROR_REPORTED__TYPE__LOG_ERROR,\n                        3);\n                return SEND_FILE_INFO_ERROR;\n            }\n            if (fromExternal && !BluetoothOppUtility.isInExternalStorageDir(uri)) {\n                EventLog.writeEvent(0x534e4554, \"35310991\", -1, uri.getPath());\n                Log.e(\n                        TAG,\n                        \"File based URI not in Environment.getExternalStorageDirectory() is not \"\n                                + \"allowed.\");\n                ContentProfileErrorReportUtils.report(\n                        BluetoothProfile.OPP,\n                        BluetoothProtoEnums.BLUETOOTH_OPP_SEND_FILE_INFO,\n                        BluetoothStatsLog.BLUETOOTH_CONTENT_PROFILE_ERROR_REPORTED__TYPE__LOG_ERROR,\n                        4);\n                return SEND_FILE_INFO_ERROR;\n            }\n            fileName = uri.getLastPathSegment();\n            contentType = type;\n            File f = new File(uri.getPath());\n            length = f.length();\n        } else {\n            // currently don't accept other scheme\n            return SEND_FILE_INFO_ERROR;\n        }\n        FileInputStream is = null;\n        if (scheme.equals(\"content\")) {\n            try {\n                // We've found that content providers don't always have the\n                // right size in _OpenableColumns.SIZE\n                // As a second source of getting the correct file length,\n                // get a file descriptor and get the stat length\n                AssetFileDescriptor fd =\n                        BluetoothMethodProxy.getInstance()\n                                .contentResolverOpenAssetFileDescriptor(contentResolver, uri, \"r\");\n                long statLength = fd.getLength();\n                if (length != statLength && statLength > 0) {\n                    Log.e(\n                            TAG,\n                            \"Content provider length is wrong (\"\n                                    + Long.toString(length)\n                                    + \"), using stat length (\"\n                                    + Long.toString(statLength)\n                                    + \")\");\n                    ContentProfileErrorReportUtils.report(\n                            BluetoothProfile.OPP,\n                            BluetoothProtoEnums.BLUETOOTH_OPP_SEND_FILE_INFO,\n                            BluetoothStatsLog\n                                    .BLUETOOTH_CONTENT_PROFILE_ERROR_REPORTED__TYPE__LOG_ERROR,\n                            5);\n                    length = statLength;\n                }\n\n                try {\n                    // This creates an auto-closing input-stream, so\n                    // the file descriptor will be closed whenever the InputStream\n                    // is closed.\n                    is = fd.createInputStream();\n\n                    // If the database doesn't contain the file size, get the size\n                    // by reading through the entire stream\n                    if (length == 0) {\n                        length = getStreamSize(is);\n                        Log.w(TAG, \"File length not provided. Length from stream = \" + length);\n                        ContentProfileErrorReportUtils.report(\n                                BluetoothProfile.OPP,\n                                BluetoothProtoEnums.BLUETOOTH_OPP_SEND_FILE_INFO,\n                                BluetoothStatsLog\n                                        .BLUETOOTH_CONTENT_PROFILE_ERROR_REPORTED__TYPE__LOG_WARN,\n                                6);\n                        // Reset the stream\n                        fd =\n                                BluetoothMethodProxy.getInstance()\n                                        .contentResolverOpenAssetFileDescriptor(\n                                                contentResolver, uri, \"r\");\n                        is = fd.createInputStream();\n                    }\n                } catch (IOException e) {\n                    ContentProfileErrorReportUtils.report(\n                            BluetoothProfile.OPP,\n                            BluetoothProtoEnums.BLUETOOTH_OPP_SEND_FILE_INFO,\n                            BluetoothStatsLog\n                                    .BLUETOOTH_CONTENT_PROFILE_ERROR_REPORTED__TYPE__EXCEPTION,\n                            7);\n                    try {\n                        fd.close();\n                    } catch (IOException e2) {\n                        ContentProfileErrorReportUtils.report(\n                                BluetoothProfile.OPP,\n                                BluetoothProtoEnums.BLUETOOTH_OPP_SEND_FILE_INFO,\n                                BluetoothStatsLog\n                                        .BLUETOOTH_CONTENT_PROFILE_ERROR_REPORTED__TYPE__EXCEPTION,\n                                8);\n                        // Ignore\n                    }\n                }\n            } catch (FileNotFoundException e) {\n                ContentProfileErrorReportUtils.report(\n                        BluetoothProfile.OPP,\n                        BluetoothProtoEnums.BLUETOOTH_OPP_SEND_FILE_INFO,\n                        BluetoothStatsLog.BLUETOOTH_CONTENT_PROFILE_ERROR_REPORTED__TYPE__EXCEPTION,\n                        9);\n                // Ignore\n            } catch (SecurityException e) {\n                ContentProfileErrorReportUtils.report(\n                        BluetoothProfile.OPP,\n                        BluetoothProtoEnums.BLUETOOTH_OPP_SEND_FILE_INFO,\n                        BluetoothStatsLog.BLUETOOTH_CONTENT_PROFILE_ERROR_REPORTED__TYPE__EXCEPTION,\n                        10);\n                return SEND_FILE_INFO_ERROR;\n            }\n        }\n\n        if (is == null) {\n            try {\n                is =\n                        (FileInputStream)\n                                BluetoothMethodProxy.getInstance()\n                                        .contentResolverOpenInputStream(contentResolver, uri);\n\n                // If the database doesn't contain the file size, get the size\n                // by reading through the entire stream\n                if (length == 0) {\n                    length = getStreamSize(is);\n                    // Reset the stream\n                    is =\n                            (FileInputStream)\n                                    BluetoothMethodProxy.getInstance()\n                                            .contentResolverOpenInputStream(contentResolver, uri);\n                }\n            } catch (FileNotFoundException e) {\n                ContentProfileErrorReportUtils.report(\n                        BluetoothProfile.OPP,\n                        BluetoothProtoEnums.BLUETOOTH_OPP_SEND_FILE_INFO,\n                        BluetoothStatsLog.BLUETOOTH_CONTENT_PROFILE_ERROR_REPORTED__TYPE__EXCEPTION,\n                        11);\n                return SEND_FILE_INFO_ERROR;\n            } catch (IOException e) {\n                ContentProfileErrorReportUtils.report(\n                        BluetoothProfile.OPP,\n                        BluetoothProtoEnums.BLUETOOTH_OPP_SEND_FILE_INFO,\n                        BluetoothStatsLog.BLUETOOTH_CONTENT_PROFILE_ERROR_REPORTED__TYPE__EXCEPTION,\n                        12);\n                return SEND_FILE_INFO_ERROR;\n            }\n        }\n\n        if (length == 0) {\n            Log.e(TAG, \"Could not determine size of file\");\n            ContentProfileErrorReportUtils.report(\n                    BluetoothProfile.OPP,\n                    BluetoothProtoEnums.BLUETOOTH_OPP_SEND_FILE_INFO,\n                    BluetoothStatsLog.BLUETOOTH_CONTENT_PROFILE_ERROR_REPORTED__TYPE__LOG_ERROR,\n                    13);\n            return SEND_FILE_INFO_ERROR;\n        } else if (length > 0xffffffffL) {\n            Log.e(TAG, \"File of size: \" + length + \" bytes can't be transferred\");\n            ContentProfileErrorReportUtils.report(\n                    BluetoothProfile.OPP,\n                    BluetoothProtoEnums.BLUETOOTH_OPP_SEND_FILE_INFO,\n                    BluetoothStatsLog.BLUETOOTH_CONTENT_PROFILE_ERROR_REPORTED__TYPE__LOG_ERROR,\n                    14);\n            throw new IllegalArgumentException(\n                    context.getString(R.string.bluetooth_opp_file_limit_exceeded));\n        }\n\n        return new BluetoothOppSendFileInfo(fileName, contentType, length, is, 0);\n    }\n\n    private static boolean isContentUriForOtherUser(Uri uri) {\n        String uriUserId = uri.getUserInfo();\n        return !TextUtils.isEmpty(uriUserId)\n                && !Objects.equals(uriUserId, String.valueOf(myUserId()));\n    }\n\n    private static long getStreamSize(FileInputStream is) throws IOException {\n        long length = 0;\n        byte[] unused = new byte[4096];\n        int bytesRead = is.read(unused, 0, 4096);\n        while (bytesRead != -1) {\n            length += bytesRead;\n            bytesRead = is.read(unused, 0, 4096);\n        }\n        return length;\n    }\n}\n```",
                        "downstream_file_content": "```java\n/*\n * Copyright (c) 2008-2009, Motorola, Inc.\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * - Neither the name of the Motorola, Inc. nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage com.android.bluetooth.opp;\n\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.res.AssetFileDescriptor;\nimport android.database.Cursor;\nimport android.database.sqlite.SQLiteException;\nimport android.net.Uri;\nimport android.provider.OpenableColumns;\nimport android.text.TextUtils;\nimport android.util.EventLog;\nimport android.util.Log;\n\nimport com.android.bluetooth.R;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\n\n/**\n * This class stores information about a single sending file It will only be\n * used for outbound share.\n */\npublic class BluetoothOppSendFileInfo {\n    private static final String TAG = \"BluetoothOppSendFileInfo\";\n\n    private static final boolean D = Constants.DEBUG;\n\n\n    /** Reusable SendFileInfo for error status. */\n    static final BluetoothOppSendFileInfo SEND_FILE_INFO_ERROR =\n            new BluetoothOppSendFileInfo(null, null, 0, null, BluetoothShare.STATUS_FILE_ERROR);\n\n    /** readable media file name */\n    public final String mFileName;\n\n    /** media file input stream */\n    public final FileInputStream mInputStream;\n\n    /** vCard string data */\n    public final String mData;\n\n    public final int mStatus;\n\n    public final String mMimetype;\n\n    public final long mLength;\n\n    /** for media file */\n    public BluetoothOppSendFileInfo(String fileName, String type, long length,\n            FileInputStream inputStream, int status) {\n        mFileName = fileName;\n        mMimetype = type;\n        mLength = length;\n        mInputStream = inputStream;\n        mStatus = status;\n        mData = null;\n    }\n\n    /** for vCard, or later for vCal, vNote. Not used currently */\n    public BluetoothOppSendFileInfo(String data, String type, long length, int status) {\n        mFileName = null;\n        mInputStream = null;\n        mData = data;\n        mMimetype = type;\n        mLength = length;\n        mStatus = status;\n    }\n\n    public static BluetoothOppSendFileInfo generateFileInfo(Context context, Uri uri, String type,\n            boolean fromExternal) {\n        ContentResolver contentResolver = context.getContentResolver();\n        String scheme = uri.getScheme();\n        String fileName = null;\n        String contentType;\n        long length = 0;\n        // Support all Uri with \"content\" scheme\n        // This will allow more 3rd party applications to share files via\n        // bluetooth\n        if (\"content\".equals(scheme)) {\n            if (fromExternal && BluetoothOppUtility.isForbiddenContent(uri)) {\n                EventLog.writeEvent(0x534e4554, \"179910660\", -1, uri.toString());\n                Log.e(TAG, \"Content from forbidden URI is not allowed.\");\n                return SEND_FILE_INFO_ERROR;\n            }\n\n            if (isContentUriForOtherUser(uri)) {\n                Log.e(TAG, \"Uri: \" + uri + \" is invalid for user \" + myUserId());\n                ContentProfileErrorReportUtils.report(\n                        BluetoothProfile.OPP,\n                        BluetoothProtoEnums.BLUETOOTH_OPP_SEND_FILE_INFO,\n                        BluetoothStatsLog.BLUETOOTH_CONTENT_PROFILE_ERROR_REPORTED__TYPE__LOG_ERROR,\n                        15);\n                return SEND_FILE_INFO_ERROR;\n            }\n\n            contentType = contentResolver.getType(uri);\n            Cursor metadataCursor;\n            try {\n                metadataCursor = contentResolver.query(uri, new String[]{\n                        OpenableColumns.DISPLAY_NAME, OpenableColumns.SIZE\n                }, null, null, null);\n            } catch (SQLiteException e) {\n                // some content providers don't support the DISPLAY_NAME or SIZE columns\n                metadataCursor = null;\n            } catch (SecurityException e) {\n                Log.e(TAG, \"generateFileInfo: Permission error, could not access URI: \" + uri);\n                return SEND_FILE_INFO_ERROR;\n            }\n\n            if (metadataCursor != null) {\n                try {\n                    if (metadataCursor.moveToFirst()) {\n                        int indexName = metadataCursor.getColumnIndex(OpenableColumns.DISPLAY_NAME);\n                        int indexSize = metadataCursor.getColumnIndex(OpenableColumns.SIZE);\n                        if (indexName != -1) {\n                            fileName = metadataCursor.getString(indexName);\n                        }\n                        if (indexSize != -1) {\n                            length = metadataCursor.getLong(indexSize);\n                        }\n                        if (D) {\n                            Log.d(TAG, \"fileName = \" + fileName + \" length = \" + length);\n                        }\n                    }\n                } finally {\n                    metadataCursor.close();\n                }\n            }\n            if (fileName == null) {\n                // use last segment of URI if DISPLAY_NAME query fails\n                fileName = uri.getLastPathSegment();\n                if (D) Log.d(TAG, \"fileName from URI :\" + fileName);\n            }\n        } else if (\"file\".equals(scheme)) {\n            if (uri.getPath() == null) {\n                Log.e(TAG, \"Invalid URI path: \" + uri);\n                return SEND_FILE_INFO_ERROR;\n            }\n            if (fromExternal && !BluetoothOppUtility.isInExternalStorageDir(uri)) {\n                EventLog.writeEvent(0x534e4554, \"35310991\", -1, uri.getPath());\n                Log.e(TAG, \"File based URI not in Environment.getExternalStorageDirectory() is not \"\n                        + \"allowed.\");\n                return SEND_FILE_INFO_ERROR;\n            }\n            fileName = uri.getLastPathSegment();\n            contentType = type;\n            File f = new File(uri.getPath());\n            length = f.length();\n        } else {\n            // currently don't accept other scheme\n            return SEND_FILE_INFO_ERROR;\n        }\n        FileInputStream is = null;\n        if (scheme.equals(\"content\")) {\n            try {\n                // We've found that content providers don't always have the\n                // right size in _OpenableColumns.SIZE\n                // As a second source of getting the correct file length,\n                // get a file descriptor and get the stat length\n                AssetFileDescriptor fd = contentResolver.openAssetFileDescriptor(uri, \"r\");\n                long statLength = fd.getLength();\n                if (length != statLength && statLength > 0) {\n                    Log.e(TAG, \"Content provider length is wrong (\" + Long.toString(length)\n                            + \"), using stat length (\" + Long.toString(statLength) + \")\");\n                    length = statLength;\n                }\n\n                try {\n                    // This creates an auto-closing input-stream, so\n                    // the file descriptor will be closed whenever the InputStream\n                    // is closed.\n                    is = fd.createInputStream();\n\n                    // If the database doesn't contain the file size, get the size\n                    // by reading through the entire stream\n                    if (length == 0) {\n                        length = getStreamSize(is);\n                        Log.w(TAG, \"File length not provided. Length from stream = \" + length);\n                        // Reset the stream\n                        fd = contentResolver.openAssetFileDescriptor(uri, \"r\");\n                        is = fd.createInputStream();\n                    }\n                } catch (IOException e) {\n                    try {\n                        fd.close();\n                    } catch (IOException e2) {\n                        // Ignore\n                    }\n                }\n            } catch (FileNotFoundException e) {\n                // Ignore\n            } catch (SecurityException e) {\n                return SEND_FILE_INFO_ERROR;\n            }\n        }\n\n        if (is == null) {\n            try {\n                is = (FileInputStream) contentResolver.openInputStream(uri);\n\n                // If the database doesn't contain the file size, get the size\n                // by reading through the entire stream\n                if (length == 0) {\n                    length = getStreamSize(is);\n                    // Reset the stream\n                    is = (FileInputStream) contentResolver.openInputStream(uri);\n                }\n            } catch (FileNotFoundException e) {\n                return SEND_FILE_INFO_ERROR;\n            } catch (IOException e) {\n                return SEND_FILE_INFO_ERROR;\n            }\n        }\n\n        if (length == 0) {\n            Log.e(TAG, \"Could not determine size of file\");\n            return SEND_FILE_INFO_ERROR;\n        } else if (length > 0xffffffffL) {\n            Log.e(TAG, \"File of size: \" + length + \" bytes can't be transferred\");\n            throw new IllegalArgumentException(context\n                .getString(R.string.bluetooth_opp_file_limit_exceeded));\n        }\n\n        return new BluetoothOppSendFileInfo(fileName, contentType, length, is, 0);\n    }\n\n    private static boolean isContentUriForOtherUser(Uri uri) {\n        String uriUserId = uri.getUserInfo();\n        return !TextUtils.isEmpty(uriUserId)\n                && !Objects.equals(uriUserId, String.valueOf(myUserId()));\n    }\n\n    private static long getStreamSize(FileInputStream is) throws IOException {\n        long length = 0;\n        byte[] unused = new byte[4096];\n        int bytesRead = is.read(unused, 0, 4096);\n        while (bytesRead != -1) {\n            length += bytesRead;\n            bytesRead = is.read(unused, 0, 4096);\n        }\n        return length;\n    }\n}\n```"
                    }
                ]
            },
            {
                "downstream_version": "14",
                "branch_used": "android14-release",
                "downstream_patch": "2c5add83a18d87ea4a46bc8ab7f675e32c8d6a56",
                "repo_path": "android_repos/Bluetooth",
                "result": "failure",
                "downstream_patch_content": "commit 2c5add83a18d87ea4a46bc8ab7f675e32c8d6a56\nAuthor: Billy Huang <billyhuang@google.com>\nDate:   Wed Oct 2 14:27:47 2024 -0700\n\n    RESTRICT AUTOMERGE backport \"opp: validate that content uri belongs to current user\"\n    \n    Bug: 296915500\n    Flag: EXEMPT trivial fix with complete testing coverage\n    Test: atest GoogleBluetoothInstrumentationTests:BluetoothOppSendFileInfoTest\n    Ignore-AOSP-First: fix for undisclosed vulnerability\n    Merged-In: I76b25fcd446d5e0530308e21deafa68d0b768edc\n    Change-Id: I0b6423025c95c13eeea3cbf584212913b5fbf307\n\ndiff --git a/android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java b/android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java\nindex 2adb8e5f44..7ce134341a 100644\n--- a/android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java\n+++ b/android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java\n@@ -32,6 +32,8 @@\n \n package com.android.bluetooth.opp;\n \n+import static android.os.UserHandle.myUserId;\n+\n import android.content.ContentResolver;\n import android.content.Context;\n import android.content.res.AssetFileDescriptor;\n@@ -39,6 +41,7 @@ import android.database.Cursor;\n import android.database.sqlite.SQLiteException;\n import android.net.Uri;\n import android.provider.OpenableColumns;\n+import android.text.TextUtils;\n import android.util.EventLog;\n import android.util.Log;\n \n@@ -49,6 +52,7 @@ import java.io.File;\n import java.io.FileInputStream;\n import java.io.FileNotFoundException;\n import java.io.IOException;\n+import java.util.Objects;\n \n /**\n  * This class stores information about a single sending file It will only be\n@@ -117,6 +121,11 @@ public class BluetoothOppSendFileInfo {\n                 return SEND_FILE_INFO_ERROR;\n             }\n \n+            if (isContentUriForOtherUser(uri)) {\n+                Log.e(TAG, \"Uri: \" + uri + \" is invalid for user \" + myUserId());\n+                return SEND_FILE_INFO_ERROR;\n+            }\n+\n             contentType = contentResolver.getType(uri);\n             Cursor metadataCursor;\n             try {\n@@ -253,6 +262,12 @@ public class BluetoothOppSendFileInfo {\n         return new BluetoothOppSendFileInfo(fileName, contentType, length, is, 0);\n     }\n \n+    private static boolean isContentUriForOtherUser(Uri uri) {\n+        String uriUserId = uri.getUserInfo();\n+        return !TextUtils.isEmpty(uriUserId)\n+                && !Objects.equals(uriUserId, String.valueOf(myUserId()));\n+    }\n+\n     private static long getStreamSize(FileInputStream is) throws IOException {\n         long length = 0;\n         byte[] unused = new byte[4096];\ndiff --git a/android/app/tests/unit/src/com/android/bluetooth/opp/BluetoothOppSendFileInfoTest.java b/android/app/tests/unit/src/com/android/bluetooth/opp/BluetoothOppSendFileInfoTest.java\nindex 756836afaa..acb58272fb 100644\n--- a/android/app/tests/unit/src/com/android/bluetooth/opp/BluetoothOppSendFileInfoTest.java\n+++ b/android/app/tests/unit/src/com/android/bluetooth/opp/BluetoothOppSendFileInfoTest.java\n@@ -17,6 +17,8 @@\n \n package com.android.bluetooth.opp;\n \n+import static android.os.UserHandle.myUserId;\n+\n import static com.google.common.truth.Truth.assertThat;\n \n import static org.mockito.ArgumentMatchers.any;\n@@ -31,7 +33,6 @@ import android.content.res.AssetFileDescriptor;\n import android.database.MatrixCursor;\n import android.net.Uri;\n import android.provider.OpenableColumns;\n-import android.util.Log;\n \n import androidx.test.platform.app.InstrumentationRegistry;\n import androidx.test.runner.AndroidJUnit4;\n@@ -120,6 +121,110 @@ public class BluetoothOppSendFileInfoTest {\n         assertThat(info).isEqualTo(BluetoothOppSendFileInfo.SEND_FILE_INFO_ERROR);\n     }\n \n+    @Test\n+    public void generateFileInfo_withContentUriForOtherUser_returnsSendFileInfoError()\n+            throws Exception {\n+        String type = \"image/jpeg\";\n+        Uri uri = buildContentUriWithEncodedAuthority((myUserId() + 1) + \"@media\");\n+\n+        long fileLength = 1000;\n+        String fileName = \"pic.jpg\";\n+\n+        FileInputStream fs = mock(FileInputStream.class);\n+        AssetFileDescriptor fd = mock(AssetFileDescriptor.class);\n+        doReturn(fileLength).when(fd).getLength();\n+        doReturn(fs).when(fd).createInputStream();\n+\n+        doReturn(fd).when(mCallProxy).contentResolverOpenAssetFileDescriptor(any(), eq(uri), any());\n+\n+        mCursor =\n+                new MatrixCursor(new String[] {OpenableColumns.DISPLAY_NAME, OpenableColumns.SIZE});\n+        mCursor.addRow(new Object[] {fileName, fileLength});\n+\n+        doReturn(mCursor)\n+                .when(mCallProxy)\n+                .contentResolverQuery(any(), eq(uri), any(), any(), any(), any());\n+\n+        BluetoothOppSendFileInfo info =\n+                BluetoothOppSendFileInfo.generateFileInfo(mContext, uri, type, true);\n+\n+        assertThat(info).isEqualTo(BluetoothOppSendFileInfo.SEND_FILE_INFO_ERROR);\n+    }\n+\n+    @Test\n+    public void generateFileInfo_withContentUriForImplicitUser_returnsInfoWithCorrectLength()\n+            throws Exception {\n+        String type = \"image/jpeg\";\n+        Uri uri = buildContentUriWithEncodedAuthority(\"media\");\n+\n+        long fileLength = 1000;\n+        String fileName = \"pic.jpg\";\n+\n+        FileInputStream fs = mock(FileInputStream.class);\n+        AssetFileDescriptor fd = mock(AssetFileDescriptor.class);\n+        doReturn(fileLength).when(fd).getLength();\n+        doReturn(fs).when(fd).createInputStream();\n+\n+        doReturn(fd).when(mCallProxy).contentResolverOpenAssetFileDescriptor(any(), eq(uri), any());\n+\n+        mCursor =\n+                new MatrixCursor(new String[] {OpenableColumns.DISPLAY_NAME, OpenableColumns.SIZE});\n+        mCursor.addRow(new Object[] {fileName, fileLength});\n+\n+        doReturn(mCursor)\n+                .when(mCallProxy)\n+                .contentResolverQuery(any(), eq(uri), any(), any(), any(), any());\n+\n+        BluetoothOppSendFileInfo info =\n+                BluetoothOppSendFileInfo.generateFileInfo(mContext, uri, type, true);\n+\n+        assertThat(info.mInputStream).isEqualTo(fs);\n+        assertThat(info.mFileName).isEqualTo(fileName);\n+        assertThat(info.mLength).isEqualTo(fileLength);\n+        assertThat(info.mStatus).isEqualTo(0);\n+    }\n+\n+    @Test\n+    public void generateFileInfo_withContentUriForSameUser_returnsInfoWithCorrectLength()\n+            throws Exception {\n+        String type = \"image/jpeg\";\n+        Uri uri = buildContentUriWithEncodedAuthority(myUserId() + \"@media\");\n+\n+        long fileLength = 1000;\n+        String fileName = \"pic.jpg\";\n+\n+        FileInputStream fs = mock(FileInputStream.class);\n+        AssetFileDescriptor fd = mock(AssetFileDescriptor.class);\n+        doReturn(fileLength).when(fd).getLength();\n+        doReturn(fs).when(fd).createInputStream();\n+\n+        doReturn(fd).when(mCallProxy).contentResolverOpenAssetFileDescriptor(any(), eq(uri), any());\n+\n+        mCursor =\n+                new MatrixCursor(new String[] {OpenableColumns.DISPLAY_NAME, OpenableColumns.SIZE});\n+        mCursor.addRow(new Object[] {fileName, fileLength});\n+\n+        doReturn(mCursor)\n+                .when(mCallProxy)\n+                .contentResolverQuery(any(), eq(uri), any(), any(), any(), any());\n+\n+        BluetoothOppSendFileInfo info =\n+                BluetoothOppSendFileInfo.generateFileInfo(mContext, uri, type, true);\n+\n+        assertThat(info.mInputStream).isEqualTo(fs);\n+        assertThat(info.mFileName).isEqualTo(fileName);\n+        assertThat(info.mLength).isEqualTo(fileLength);\n+        assertThat(info.mStatus).isEqualTo(0);\n+    }\n+\n+    private static Uri buildContentUriWithEncodedAuthority(String authority) {\n+        return new Uri.Builder()\n+                .scheme(\"content\")\n+                .encodedAuthority(authority)\n+                .path(\"external/images/media/1\")\n+                .build();\n+    }\n+\n     @Test\n     public void generateFileInfo_withoutPermissionForAccessingUri_returnsSendFileInfoError() {\n         String type = \"text/plain\";\n",
                "file_conflicts": [
                    {
                        "file_name": "android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java",
                        "total_hunks": 5,
                        "failed_hunks": [
                            1,
                            3
                        ],
                        "inline_merge_conflicts": [],
                        "rej_file_content": "```diff\n--- android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java\n+++ android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java\n@@ -32,6 +32,8 @@\n \n package com.android.bluetooth.opp;\n \n+import static android.os.UserHandle.myUserId;\n+\n import android.bluetooth.BluetoothProfile;\n import android.bluetooth.BluetoothProtoEnums;\n import android.content.ContentResolver;\n@@ -54,12 +57,13 @@ import java.io.File;\n import java.io.FileInputStream;\n import java.io.FileNotFoundException;\n import java.io.IOException;\n+import java.util.Objects;\n \n /**\n  * This class stores information about a single sending file It will only be used for outbound\n  * share.\n  */\n-// Next tag value for ContentProfileErrorReportUtils.report(): 15\n+// Next tag value for ContentProfileErrorReportUtils.report(): 16\n public class BluetoothOppSendFileInfo {\n     private static final String TAG = \"BluetoothOppSendFileInfo\";\n```",
                        "patch_apply_output": "patching file android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java\nHunk #1 FAILED at 32.\nHunk #2 succeeded at 39 (offset -2 lines).\nHunk #3 FAILED at 54.\nHunk #4 succeeded at 118 (offset -7 lines).\nHunk #5 succeeded at 264 (offset -100 lines).\n2 out of 5 hunks FAILED -- saving rejects to file android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java.rej",
                        "inline_merge_output": "patching file android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java\nHunk #1 already applied at 35-36.\nHunk #2 already applied at 46.\nHunk #3 already applied at 59,65.\nHunk #5 merged at 386-391.",
                        "upstream_file_content": "```java\n/*\n * Copyright (c) 2008-2009, Motorola, Inc.\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * - Neither the name of the Motorola, Inc. nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage com.android.bluetooth.opp;\n\nimport static android.os.UserHandle.myUserId;\n\nimport android.bluetooth.BluetoothProfile;\nimport android.bluetooth.BluetoothProtoEnums;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.res.AssetFileDescriptor;\nimport android.database.Cursor;\nimport android.database.sqlite.SQLiteException;\nimport android.net.Uri;\nimport android.provider.OpenableColumns;\nimport android.text.TextUtils;\nimport android.util.EventLog;\nimport android.util.Log;\n\nimport com.android.bluetooth.BluetoothMethodProxy;\nimport com.android.bluetooth.BluetoothStatsLog;\nimport com.android.bluetooth.R;\nimport com.android.bluetooth.content_profiles.ContentProfileErrorReportUtils;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.util.Objects;\n\n/**\n * This class stores information about a single sending file It will only be used for outbound\n * share.\n */\n// Next tag value for ContentProfileErrorReportUtils.report(): 16\npublic class BluetoothOppSendFileInfo {\n    private static final String TAG = \"BluetoothOppSendFileInfo\";\n\n    /** Reusable SendFileInfo for error status. */\n    static final BluetoothOppSendFileInfo SEND_FILE_INFO_ERROR =\n            new BluetoothOppSendFileInfo(null, null, 0, null, BluetoothShare.STATUS_FILE_ERROR);\n\n    /** readable media file name */\n    public final String mFileName;\n\n    /** media file input stream */\n    public final FileInputStream mInputStream;\n\n    /** vCard string data */\n    public final String mData;\n\n    public final int mStatus;\n\n    public final String mMimetype;\n\n    public final long mLength;\n\n    /** for media file */\n    public BluetoothOppSendFileInfo(\n            String fileName, String type, long length, FileInputStream inputStream, int status) {\n        mFileName = fileName;\n        mMimetype = type;\n        mLength = length;\n        mInputStream = inputStream;\n        mStatus = status;\n        mData = null;\n    }\n\n    /** for vCard, or later for vCal, vNote. Not used currently */\n    public BluetoothOppSendFileInfo(String data, String type, long length, int status) {\n        mFileName = null;\n        mInputStream = null;\n        mData = data;\n        mMimetype = type;\n        mLength = length;\n        mStatus = status;\n    }\n\n    public static BluetoothOppSendFileInfo generateFileInfo(\n            Context context, Uri uri, String type, boolean fromExternal) {\n        ContentResolver contentResolver = context.getContentResolver();\n        String scheme = uri.getScheme();\n        String fileName = null;\n        String contentType;\n        long length = 0;\n        // Support all Uri with \"content\" scheme\n        // This will allow more 3rd party applications to share files via\n        // bluetooth\n        if (\"content\".equals(scheme)) {\n            if (fromExternal && BluetoothOppUtility.isForbiddenContent(uri)) {\n                EventLog.writeEvent(0x534e4554, \"179910660\", -1, uri.toString());\n                Log.e(TAG, \"Content from forbidden URI is not allowed.\");\n                ContentProfileErrorReportUtils.report(\n                        BluetoothProfile.OPP,\n                        BluetoothProtoEnums.BLUETOOTH_OPP_SEND_FILE_INFO,\n                        BluetoothStatsLog.BLUETOOTH_CONTENT_PROFILE_ERROR_REPORTED__TYPE__LOG_ERROR,\n                        0);\n                return SEND_FILE_INFO_ERROR;\n            }\n\n            if (isContentUriForOtherUser(uri)) {\n                Log.e(TAG, \"Uri: \" + uri + \" is invalid for user \" + myUserId());\n                ContentProfileErrorReportUtils.report(\n                        BluetoothProfile.OPP,\n                        BluetoothProtoEnums.BLUETOOTH_OPP_SEND_FILE_INFO,\n                        BluetoothStatsLog.BLUETOOTH_CONTENT_PROFILE_ERROR_REPORTED__TYPE__LOG_ERROR,\n                        15);\n                return SEND_FILE_INFO_ERROR;\n            }\n\n            contentType = contentResolver.getType(uri);\n            Cursor metadataCursor;\n            try {\n                metadataCursor =\n                        BluetoothMethodProxy.getInstance()\n                                .contentResolverQuery(\n                                        contentResolver,\n                                        uri,\n                                        new String[] {\n                                            OpenableColumns.DISPLAY_NAME, OpenableColumns.SIZE\n                                        },\n                                        null,\n                                        null,\n                                        null);\n            } catch (SQLiteException e) {\n                ContentProfileErrorReportUtils.report(\n                        BluetoothProfile.OPP,\n                        BluetoothProtoEnums.BLUETOOTH_OPP_SEND_FILE_INFO,\n                        BluetoothStatsLog.BLUETOOTH_CONTENT_PROFILE_ERROR_REPORTED__TYPE__EXCEPTION,\n                        1);\n                // some content providers don't support the DISPLAY_NAME or SIZE columns\n                metadataCursor = null;\n            } catch (SecurityException e) {\n                ContentProfileErrorReportUtils.report(\n                        BluetoothProfile.OPP,\n                        BluetoothProtoEnums.BLUETOOTH_OPP_SEND_FILE_INFO,\n                        BluetoothStatsLog.BLUETOOTH_CONTENT_PROFILE_ERROR_REPORTED__TYPE__EXCEPTION,\n                        2);\n                Log.e(TAG, \"generateFileInfo: Permission error, could not access URI: \" + uri);\n                return SEND_FILE_INFO_ERROR;\n            }\n\n            if (metadataCursor != null) {\n                try {\n                    if (metadataCursor.moveToFirst()) {\n                        int indexName = metadataCursor.getColumnIndex(OpenableColumns.DISPLAY_NAME);\n                        int indexSize = metadataCursor.getColumnIndex(OpenableColumns.SIZE);\n                        if (indexName != -1) {\n                            fileName = metadataCursor.getString(indexName);\n                        }\n                        if (indexSize != -1) {\n                            length = metadataCursor.getLong(indexSize);\n                        }\n                        Log.d(TAG, \"fileName = \" + fileName + \" length = \" + length);\n                    }\n                } finally {\n                    metadataCursor.close();\n                }\n            }\n            if (fileName == null) {\n                // use last segment of URI if DISPLAY_NAME query fails\n                fileName = uri.getLastPathSegment();\n                Log.d(TAG, \"fileName from URI :\" + fileName);\n            }\n        } else if (\"file\".equals(scheme)) {\n            if (uri.getPath() == null) {\n                Log.e(TAG, \"Invalid URI path: \" + uri);\n                ContentProfileErrorReportUtils.report(\n                        BluetoothProfile.OPP,\n                        BluetoothProtoEnums.BLUETOOTH_OPP_SEND_FILE_INFO,\n                        BluetoothStatsLog.BLUETOOTH_CONTENT_PROFILE_ERROR_REPORTED__TYPE__LOG_ERROR,\n                        3);\n                return SEND_FILE_INFO_ERROR;\n            }\n            if (fromExternal && !BluetoothOppUtility.isInExternalStorageDir(uri)) {\n                EventLog.writeEvent(0x534e4554, \"35310991\", -1, uri.getPath());\n                Log.e(\n                        TAG,\n                        \"File based URI not in Environment.getExternalStorageDirectory() is not \"\n                                + \"allowed.\");\n                ContentProfileErrorReportUtils.report(\n                        BluetoothProfile.OPP,\n                        BluetoothProtoEnums.BLUETOOTH_OPP_SEND_FILE_INFO,\n                        BluetoothStatsLog.BLUETOOTH_CONTENT_PROFILE_ERROR_REPORTED__TYPE__LOG_ERROR,\n                        4);\n                return SEND_FILE_INFO_ERROR;\n            }\n            fileName = uri.getLastPathSegment();\n            contentType = type;\n            File f = new File(uri.getPath());\n            length = f.length();\n        } else {\n            // currently don't accept other scheme\n            return SEND_FILE_INFO_ERROR;\n        }\n        FileInputStream is = null;\n        if (scheme.equals(\"content\")) {\n            try {\n                // We've found that content providers don't always have the\n                // right size in _OpenableColumns.SIZE\n                // As a second source of getting the correct file length,\n                // get a file descriptor and get the stat length\n                AssetFileDescriptor fd =\n                        BluetoothMethodProxy.getInstance()\n                                .contentResolverOpenAssetFileDescriptor(contentResolver, uri, \"r\");\n                long statLength = fd.getLength();\n                if (length != statLength && statLength > 0) {\n                    Log.e(\n                            TAG,\n                            \"Content provider length is wrong (\"\n                                    + Long.toString(length)\n                                    + \"), using stat length (\"\n                                    + Long.toString(statLength)\n                                    + \")\");\n                    ContentProfileErrorReportUtils.report(\n                            BluetoothProfile.OPP,\n                            BluetoothProtoEnums.BLUETOOTH_OPP_SEND_FILE_INFO,\n                            BluetoothStatsLog\n                                    .BLUETOOTH_CONTENT_PROFILE_ERROR_REPORTED__TYPE__LOG_ERROR,\n                            5);\n                    length = statLength;\n                }\n\n                try {\n                    // This creates an auto-closing input-stream, so\n                    // the file descriptor will be closed whenever the InputStream\n                    // is closed.\n                    is = fd.createInputStream();\n\n                    // If the database doesn't contain the file size, get the size\n                    // by reading through the entire stream\n                    if (length == 0) {\n                        length = getStreamSize(is);\n                        Log.w(TAG, \"File length not provided. Length from stream = \" + length);\n                        ContentProfileErrorReportUtils.report(\n                                BluetoothProfile.OPP,\n                                BluetoothProtoEnums.BLUETOOTH_OPP_SEND_FILE_INFO,\n                                BluetoothStatsLog\n                                        .BLUETOOTH_CONTENT_PROFILE_ERROR_REPORTED__TYPE__LOG_WARN,\n                                6);\n                        // Reset the stream\n                        fd =\n                                BluetoothMethodProxy.getInstance()\n                                        .contentResolverOpenAssetFileDescriptor(\n                                                contentResolver, uri, \"r\");\n                        is = fd.createInputStream();\n                    }\n                } catch (IOException e) {\n                    ContentProfileErrorReportUtils.report(\n                            BluetoothProfile.OPP,\n                            BluetoothProtoEnums.BLUETOOTH_OPP_SEND_FILE_INFO,\n                            BluetoothStatsLog\n                                    .BLUETOOTH_CONTENT_PROFILE_ERROR_REPORTED__TYPE__EXCEPTION,\n                            7);\n                    try {\n                        fd.close();\n                    } catch (IOException e2) {\n                        ContentProfileErrorReportUtils.report(\n                                BluetoothProfile.OPP,\n                                BluetoothProtoEnums.BLUETOOTH_OPP_SEND_FILE_INFO,\n                                BluetoothStatsLog\n                                        .BLUETOOTH_CONTENT_PROFILE_ERROR_REPORTED__TYPE__EXCEPTION,\n                                8);\n                        // Ignore\n                    }\n                }\n            } catch (FileNotFoundException e) {\n                ContentProfileErrorReportUtils.report(\n                        BluetoothProfile.OPP,\n                        BluetoothProtoEnums.BLUETOOTH_OPP_SEND_FILE_INFO,\n                        BluetoothStatsLog.BLUETOOTH_CONTENT_PROFILE_ERROR_REPORTED__TYPE__EXCEPTION,\n                        9);\n                // Ignore\n            } catch (SecurityException e) {\n                ContentProfileErrorReportUtils.report(\n                        BluetoothProfile.OPP,\n                        BluetoothProtoEnums.BLUETOOTH_OPP_SEND_FILE_INFO,\n                        BluetoothStatsLog.BLUETOOTH_CONTENT_PROFILE_ERROR_REPORTED__TYPE__EXCEPTION,\n                        10);\n                return SEND_FILE_INFO_ERROR;\n            }\n        }\n\n        if (is == null) {\n            try {\n                is =\n                        (FileInputStream)\n                                BluetoothMethodProxy.getInstance()\n                                        .contentResolverOpenInputStream(contentResolver, uri);\n\n                // If the database doesn't contain the file size, get the size\n                // by reading through the entire stream\n                if (length == 0) {\n                    length = getStreamSize(is);\n                    // Reset the stream\n                    is =\n                            (FileInputStream)\n                                    BluetoothMethodProxy.getInstance()\n                                            .contentResolverOpenInputStream(contentResolver, uri);\n                }\n            } catch (FileNotFoundException e) {\n                ContentProfileErrorReportUtils.report(\n                        BluetoothProfile.OPP,\n                        BluetoothProtoEnums.BLUETOOTH_OPP_SEND_FILE_INFO,\n                        BluetoothStatsLog.BLUETOOTH_CONTENT_PROFILE_ERROR_REPORTED__TYPE__EXCEPTION,\n                        11);\n                return SEND_FILE_INFO_ERROR;\n            } catch (IOException e) {\n                ContentProfileErrorReportUtils.report(\n                        BluetoothProfile.OPP,\n                        BluetoothProtoEnums.BLUETOOTH_OPP_SEND_FILE_INFO,\n                        BluetoothStatsLog.BLUETOOTH_CONTENT_PROFILE_ERROR_REPORTED__TYPE__EXCEPTION,\n                        12);\n                return SEND_FILE_INFO_ERROR;\n            }\n        }\n\n        if (length == 0) {\n            Log.e(TAG, \"Could not determine size of file\");\n            ContentProfileErrorReportUtils.report(\n                    BluetoothProfile.OPP,\n                    BluetoothProtoEnums.BLUETOOTH_OPP_SEND_FILE_INFO,\n                    BluetoothStatsLog.BLUETOOTH_CONTENT_PROFILE_ERROR_REPORTED__TYPE__LOG_ERROR,\n                    13);\n            return SEND_FILE_INFO_ERROR;\n        } else if (length > 0xffffffffL) {\n            Log.e(TAG, \"File of size: \" + length + \" bytes can't be transferred\");\n            ContentProfileErrorReportUtils.report(\n                    BluetoothProfile.OPP,\n                    BluetoothProtoEnums.BLUETOOTH_OPP_SEND_FILE_INFO,\n                    BluetoothStatsLog.BLUETOOTH_CONTENT_PROFILE_ERROR_REPORTED__TYPE__LOG_ERROR,\n                    14);\n            throw new IllegalArgumentException(\n                    context.getString(R.string.bluetooth_opp_file_limit_exceeded));\n        }\n\n        return new BluetoothOppSendFileInfo(fileName, contentType, length, is, 0);\n    }\n\n    private static boolean isContentUriForOtherUser(Uri uri) {\n        String uriUserId = uri.getUserInfo();\n        return !TextUtils.isEmpty(uriUserId)\n                && !Objects.equals(uriUserId, String.valueOf(myUserId()));\n    }\n\n    private static long getStreamSize(FileInputStream is) throws IOException {\n        long length = 0;\n        byte[] unused = new byte[4096];\n        int bytesRead = is.read(unused, 0, 4096);\n        while (bytesRead != -1) {\n            length += bytesRead;\n            bytesRead = is.read(unused, 0, 4096);\n        }\n        return length;\n    }\n}\n```",
                        "downstream_file_content": "```java\n/*\n * Copyright (c) 2008-2009, Motorola, Inc.\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * - Neither the name of the Motorola, Inc. nor the names of its contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage com.android.bluetooth.opp;\n\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.res.AssetFileDescriptor;\nimport android.database.Cursor;\nimport android.database.sqlite.SQLiteException;\nimport android.net.Uri;\nimport android.provider.OpenableColumns;\nimport android.text.TextUtils;\nimport android.util.EventLog;\nimport android.util.Log;\n\nimport com.android.bluetooth.BluetoothMethodProxy;\nimport com.android.bluetooth.R;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\n\n/**\n * This class stores information about a single sending file It will only be\n * used for outbound share.\n */\npublic class BluetoothOppSendFileInfo {\n    private static final String TAG = \"BluetoothOppSendFileInfo\";\n\n    private static final boolean D = Constants.DEBUG;\n\n\n    /** Reusable SendFileInfo for error status. */\n    static final BluetoothOppSendFileInfo SEND_FILE_INFO_ERROR =\n            new BluetoothOppSendFileInfo(null, null, 0, null, BluetoothShare.STATUS_FILE_ERROR);\n\n    /** readable media file name */\n    public final String mFileName;\n\n    /** media file input stream */\n    public final FileInputStream mInputStream;\n\n    /** vCard string data */\n    public final String mData;\n\n    public final int mStatus;\n\n    public final String mMimetype;\n\n    public final long mLength;\n\n    /** for media file */\n    public BluetoothOppSendFileInfo(String fileName, String type, long length,\n            FileInputStream inputStream, int status) {\n        mFileName = fileName;\n        mMimetype = type;\n        mLength = length;\n        mInputStream = inputStream;\n        mStatus = status;\n        mData = null;\n    }\n\n    /** for vCard, or later for vCal, vNote. Not used currently */\n    public BluetoothOppSendFileInfo(String data, String type, long length, int status) {\n        mFileName = null;\n        mInputStream = null;\n        mData = data;\n        mMimetype = type;\n        mLength = length;\n        mStatus = status;\n    }\n\n    public static BluetoothOppSendFileInfo generateFileInfo(Context context, Uri uri, String type,\n            boolean fromExternal) {\n        ContentResolver contentResolver = context.getContentResolver();\n        String scheme = uri.getScheme();\n        String fileName = null;\n        String contentType;\n        long length = 0;\n        // Support all Uri with \"content\" scheme\n        // This will allow more 3rd party applications to share files via\n        // bluetooth\n        if (\"content\".equals(scheme)) {\n            if (fromExternal && BluetoothOppUtility.isForbiddenContent(uri)) {\n                EventLog.writeEvent(0x534e4554, \"179910660\", -1, uri.toString());\n                Log.e(TAG, \"Content from forbidden URI is not allowed.\");\n                return SEND_FILE_INFO_ERROR;\n            }\n\n            if (isContentUriForOtherUser(uri)) {\n                Log.e(TAG, \"Uri: \" + uri + \" is invalid for user \" + myUserId());\n                ContentProfileErrorReportUtils.report(\n                        BluetoothProfile.OPP,\n                        BluetoothProtoEnums.BLUETOOTH_OPP_SEND_FILE_INFO,\n                        BluetoothStatsLog.BLUETOOTH_CONTENT_PROFILE_ERROR_REPORTED__TYPE__LOG_ERROR,\n                        15);\n                return SEND_FILE_INFO_ERROR;\n            }\n\n            contentType = contentResolver.getType(uri);\n            Cursor metadataCursor;\n            try {\n                metadataCursor = BluetoothMethodProxy.getInstance().contentResolverQuery(\n                        contentResolver, uri, new String[]{\n                                OpenableColumns.DISPLAY_NAME, OpenableColumns.SIZE\n                        }, null, null, null);\n            } catch (SQLiteException e) {\n                // some content providers don't support the DISPLAY_NAME or SIZE columns\n                metadataCursor = null;\n            } catch (SecurityException e) {\n                Log.e(TAG, \"generateFileInfo: Permission error, could not access URI: \" + uri);\n                return SEND_FILE_INFO_ERROR;\n            }\n\n            if (metadataCursor != null) {\n                try {\n                    if (metadataCursor.moveToFirst()) {\n                        int indexName = metadataCursor.getColumnIndex(OpenableColumns.DISPLAY_NAME);\n                        int indexSize = metadataCursor.getColumnIndex(OpenableColumns.SIZE);\n                        if (indexName != -1) {\n                            fileName = metadataCursor.getString(indexName);\n                        }\n                        if (indexSize != -1) {\n                            length = metadataCursor.getLong(indexSize);\n                        }\n                        if (D) {\n                            Log.d(TAG, \"fileName = \" + fileName + \" length = \" + length);\n                        }\n                    }\n                } finally {\n                    metadataCursor.close();\n                }\n            }\n            if (fileName == null) {\n                // use last segment of URI if DISPLAY_NAME query fails\n                fileName = uri.getLastPathSegment();\n                if (D) Log.d(TAG, \"fileName from URI :\" + fileName);\n            }\n        } else if (\"file\".equals(scheme)) {\n            if (uri.getPath() == null) {\n                Log.e(TAG, \"Invalid URI path: \" + uri);\n                return SEND_FILE_INFO_ERROR;\n            }\n            if (fromExternal && !BluetoothOppUtility.isInExternalStorageDir(uri)) {\n                EventLog.writeEvent(0x534e4554, \"35310991\", -1, uri.getPath());\n                Log.e(TAG, \"File based URI not in Environment.getExternalStorageDirectory() is not \"\n                        + \"allowed.\");\n                return SEND_FILE_INFO_ERROR;\n            }\n            fileName = uri.getLastPathSegment();\n            contentType = type;\n            File f = new File(uri.getPath());\n            length = f.length();\n        } else {\n            // currently don't accept other scheme\n            return SEND_FILE_INFO_ERROR;\n        }\n        FileInputStream is = null;\n        if (scheme.equals(\"content\")) {\n            try {\n                // We've found that content providers don't always have the\n                // right size in _OpenableColumns.SIZE\n                // As a second source of getting the correct file length,\n                // get a file descriptor and get the stat length\n                AssetFileDescriptor fd = BluetoothMethodProxy.getInstance()\n                        .contentResolverOpenAssetFileDescriptor(contentResolver, uri, \"r\");\n                long statLength = fd.getLength();\n                if (length != statLength && statLength > 0) {\n                    Log.e(TAG, \"Content provider length is wrong (\" + Long.toString(length)\n                            + \"), using stat length (\" + Long.toString(statLength) + \")\");\n                    length = statLength;\n                }\n\n                try {\n                    // This creates an auto-closing input-stream, so\n                    // the file descriptor will be closed whenever the InputStream\n                    // is closed.\n                    is = fd.createInputStream();\n\n                    // If the database doesn't contain the file size, get the size\n                    // by reading through the entire stream\n                    if (length == 0) {\n                        length = getStreamSize(is);\n                        Log.w(TAG, \"File length not provided. Length from stream = \" + length);\n                        // Reset the stream\n                        fd = BluetoothMethodProxy.getInstance()\n                                .contentResolverOpenAssetFileDescriptor(contentResolver, uri, \"r\");\n                        is = fd.createInputStream();\n                    }\n                } catch (IOException e) {\n                    try {\n                        fd.close();\n                    } catch (IOException e2) {\n                        // Ignore\n                    }\n                }\n            } catch (FileNotFoundException e) {\n                // Ignore\n            } catch (SecurityException e) {\n                return SEND_FILE_INFO_ERROR;\n            }\n        }\n\n        if (is == null) {\n            try {\n                is = (FileInputStream) BluetoothMethodProxy.getInstance()\n                        .contentResolverOpenInputStream(contentResolver, uri);\n\n                // If the database doesn't contain the file size, get the size\n                // by reading through the entire stream\n                if (length == 0) {\n                    length = getStreamSize(is);\n                    // Reset the stream\n                    is = (FileInputStream) BluetoothMethodProxy.getInstance()\n                            .contentResolverOpenInputStream(contentResolver, uri);\n                }\n            } catch (FileNotFoundException e) {\n                return SEND_FILE_INFO_ERROR;\n            } catch (IOException e) {\n                return SEND_FILE_INFO_ERROR;\n            }\n        }\n\n        if (length == 0) {\n            Log.e(TAG, \"Could not determine size of file\");\n            return SEND_FILE_INFO_ERROR;\n        } else if (length > 0xffffffffL) {\n            Log.e(TAG, \"File of size: \" + length + \" bytes can't be transferred\");\n            throw new IllegalArgumentException(context\n                .getString(R.string.bluetooth_opp_file_limit_exceeded));\n        }\n\n        return new BluetoothOppSendFileInfo(fileName, contentType, length, is, 0);\n    }\n\n    private static boolean isContentUriForOtherUser(Uri uri) {\n        String uriUserId = uri.getUserInfo();\n        return !TextUtils.isEmpty(uriUserId)\n                && !Objects.equals(uriUserId, String.valueOf(myUserId()));\n    }\n\n    private static long getStreamSize(FileInputStream is) throws IOException {\n        long length = 0;\n        byte[] unused = new byte[4096];\n        int bytesRead = is.read(unused, 0, 4096);\n        while (bytesRead != -1) {\n            length += bytesRead;\n            bytesRead = is.read(unused, 0, 4096);\n        }\n        return length;\n    }\n}\n```"
                    }
                ]
            }
        ],
        "upstream_patch_content": "From b5d66a17fa296117b44f23ae45ff7338cee6ae85 Mon Sep 17 00:00:00 2001\nFrom: Billy Huang <billyhuang@google.com>\nDate: Thu, 8 Aug 2024 14:57:07 -0700\nSubject: [PATCH] Reapply \"opp: validate that content uri belongs to current\n user\"\n\nCheck that the userInfo part of the content URI is\neither implicit or the same as the current userId.\n\nThis reverts commit db25b12501095bc3f371a7271e372834cde5cee5.\n\nBug: 296915500\nFlag: EXEMPT fix for vulnerability\nTest: atest GoogleBluetoothInstrumentationTests:BluetoothOppSendFileInfoTest\nIgnore-AOSP-First: fix for undisclosed vulnerability\nChange-Id: I76b25fcd446d5e0530308e21deafa68d0b768edc\n---\n .../opp/BluetoothOppSendFileInfo.java         |  22 +++-\n .../opp/BluetoothOppSendFileInfoTest.java     | 106 ++++++++++++++++++\n 2 files changed, 127 insertions(+), 1 deletion(-)\n\ndiff --git a/android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java b/android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java\nindex 16056cde79..2d727f9fdf 100644\n--- a/android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java\n+++ b/android/app/src/com/android/bluetooth/opp/BluetoothOppSendFileInfo.java\n@@ -32,6 +32,8 @@\n \n package com.android.bluetooth.opp;\n \n+import static android.os.UserHandle.myUserId;\n+\n import android.bluetooth.BluetoothProfile;\n import android.bluetooth.BluetoothProtoEnums;\n import android.content.ContentResolver;\n@@ -41,6 +43,7 @@ import android.database.Cursor;\n import android.database.sqlite.SQLiteException;\n import android.net.Uri;\n import android.provider.OpenableColumns;\n+import android.text.TextUtils;\n import android.util.EventLog;\n import android.util.Log;\n \n@@ -53,12 +56,13 @@ import java.io.File;\n import java.io.FileInputStream;\n import java.io.FileNotFoundException;\n import java.io.IOException;\n+import java.util.Objects;\n \n /**\n  * This class stores information about a single sending file It will only be used for outbound\n  * share.\n  */\n-// Next tag value for ContentProfileErrorReportUtils.report(): 15\n+// Next tag value for ContentProfileErrorReportUtils.report(): 16\n public class BluetoothOppSendFileInfo {\n     private static final String TAG = \"BluetoothOppSendFileInfo\";\n \n@@ -124,6 +128,16 @@ public class BluetoothOppSendFileInfo {\n                 return SEND_FILE_INFO_ERROR;\n             }\n \n+            if (isContentUriForOtherUser(uri)) {\n+                Log.e(TAG, \"Uri: \" + uri + \" is invalid for user \" + myUserId());\n+                ContentProfileErrorReportUtils.report(\n+                        BluetoothProfile.OPP,\n+                        BluetoothProtoEnums.BLUETOOTH_OPP_SEND_FILE_INFO,\n+                        BluetoothStatsLog.BLUETOOTH_CONTENT_PROFILE_ERROR_REPORTED__TYPE__LOG_ERROR,\n+                        15);\n+                return SEND_FILE_INFO_ERROR;\n+            }\n+\n             contentType = contentResolver.getType(uri);\n             Cursor metadataCursor;\n             try {\n@@ -353,6 +367,12 @@ public class BluetoothOppSendFileInfo {\n         return new BluetoothOppSendFileInfo(fileName, contentType, length, is, 0);\n     }\n \n+    private static boolean isContentUriForOtherUser(Uri uri) {\n+        String uriUserId = uri.getUserInfo();\n+        return !TextUtils.isEmpty(uriUserId)\n+                && !Objects.equals(uriUserId, String.valueOf(myUserId()));\n+    }\n+\n     private static long getStreamSize(FileInputStream is) throws IOException {\n         long length = 0;\n         byte[] unused = new byte[4096];\ndiff --git a/android/app/tests/unit/src/com/android/bluetooth/opp/BluetoothOppSendFileInfoTest.java b/android/app/tests/unit/src/com/android/bluetooth/opp/BluetoothOppSendFileInfoTest.java\nindex 273f6fd8d5..aad8a31170 100644\n--- a/android/app/tests/unit/src/com/android/bluetooth/opp/BluetoothOppSendFileInfoTest.java\n+++ b/android/app/tests/unit/src/com/android/bluetooth/opp/BluetoothOppSendFileInfoTest.java\n@@ -16,6 +16,8 @@\n \n package com.android.bluetooth.opp;\n \n+import static android.os.UserHandle.myUserId;\n+\n import static com.google.common.truth.Truth.assertThat;\n \n import static org.mockito.ArgumentMatchers.any;\n@@ -119,6 +121,110 @@ public class BluetoothOppSendFileInfoTest {\n         assertThat(info).isEqualTo(BluetoothOppSendFileInfo.SEND_FILE_INFO_ERROR);\n     }\n \n+    @Test\n+    public void generateFileInfo_withContentUriForOtherUser_returnsSendFileInfoError()\n+            throws Exception {\n+        String type = \"image/jpeg\";\n+        Uri uri = buildContentUriWithEncodedAuthority((myUserId() + 1) + \"@media\");\n+\n+        long fileLength = 1000;\n+        String fileName = \"pic.jpg\";\n+\n+        FileInputStream fs = mock(FileInputStream.class);\n+        AssetFileDescriptor fd = mock(AssetFileDescriptor.class);\n+        doReturn(fileLength).when(fd).getLength();\n+        doReturn(fs).when(fd).createInputStream();\n+\n+        doReturn(fd).when(mCallProxy).contentResolverOpenAssetFileDescriptor(any(), eq(uri), any());\n+\n+        mCursor =\n+                new MatrixCursor(new String[] {OpenableColumns.DISPLAY_NAME, OpenableColumns.SIZE});\n+        mCursor.addRow(new Object[] {fileName, fileLength});\n+\n+        doReturn(mCursor)\n+                .when(mCallProxy)\n+                .contentResolverQuery(any(), eq(uri), any(), any(), any(), any());\n+\n+        BluetoothOppSendFileInfo info =\n+                BluetoothOppSendFileInfo.generateFileInfo(mContext, uri, type, true);\n+\n+        assertThat(info).isEqualTo(BluetoothOppSendFileInfo.SEND_FILE_INFO_ERROR);\n+    }\n+\n+    @Test\n+    public void generateFileInfo_withContentUriForImplicitUser_returnsInfoWithCorrectLength()\n+            throws Exception {\n+        String type = \"image/jpeg\";\n+        Uri uri = buildContentUriWithEncodedAuthority(\"media\");\n+\n+        long fileLength = 1000;\n+        String fileName = \"pic.jpg\";\n+\n+        FileInputStream fs = mock(FileInputStream.class);\n+        AssetFileDescriptor fd = mock(AssetFileDescriptor.class);\n+        doReturn(fileLength).when(fd).getLength();\n+        doReturn(fs).when(fd).createInputStream();\n+\n+        doReturn(fd).when(mCallProxy).contentResolverOpenAssetFileDescriptor(any(), eq(uri), any());\n+\n+        mCursor =\n+                new MatrixCursor(new String[] {OpenableColumns.DISPLAY_NAME, OpenableColumns.SIZE});\n+        mCursor.addRow(new Object[] {fileName, fileLength});\n+\n+        doReturn(mCursor)\n+                .when(mCallProxy)\n+                .contentResolverQuery(any(), eq(uri), any(), any(), any(), any());\n+\n+        BluetoothOppSendFileInfo info =\n+                BluetoothOppSendFileInfo.generateFileInfo(mContext, uri, type, true);\n+\n+        assertThat(info.mInputStream).isEqualTo(fs);\n+        assertThat(info.mFileName).isEqualTo(fileName);\n+        assertThat(info.mLength).isEqualTo(fileLength);\n+        assertThat(info.mStatus).isEqualTo(0);\n+    }\n+\n+    @Test\n+    public void generateFileInfo_withContentUriForSameUser_returnsInfoWithCorrectLength()\n+            throws Exception {\n+        String type = \"image/jpeg\";\n+        Uri uri = buildContentUriWithEncodedAuthority(myUserId() + \"@media\");\n+\n+        long fileLength = 1000;\n+        String fileName = \"pic.jpg\";\n+\n+        FileInputStream fs = mock(FileInputStream.class);\n+        AssetFileDescriptor fd = mock(AssetFileDescriptor.class);\n+        doReturn(fileLength).when(fd).getLength();\n+        doReturn(fs).when(fd).createInputStream();\n+\n+        doReturn(fd).when(mCallProxy).contentResolverOpenAssetFileDescriptor(any(), eq(uri), any());\n+\n+        mCursor =\n+                new MatrixCursor(new String[] {OpenableColumns.DISPLAY_NAME, OpenableColumns.SIZE});\n+        mCursor.addRow(new Object[] {fileName, fileLength});\n+\n+        doReturn(mCursor)\n+                .when(mCallProxy)\n+                .contentResolverQuery(any(), eq(uri), any(), any(), any(), any());\n+\n+        BluetoothOppSendFileInfo info =\n+                BluetoothOppSendFileInfo.generateFileInfo(mContext, uri, type, true);\n+\n+        assertThat(info.mInputStream).isEqualTo(fs);\n+        assertThat(info.mFileName).isEqualTo(fileName);\n+        assertThat(info.mLength).isEqualTo(fileLength);\n+        assertThat(info.mStatus).isEqualTo(0);\n+    }\n+\n+    private static Uri buildContentUriWithEncodedAuthority(String authority) {\n+        return new Uri.Builder()\n+                .scheme(\"content\")\n+                .encodedAuthority(authority)\n+                .path(\"external/images/media/1\")\n+                .build();\n+    }\n+\n     @Test\n     public void generateFileInfo_withoutPermissionForAccessingUri_returnsSendFileInfoError() {\n         String type = \"text/plain\";\n-- \n2.39.5 (Apple Git-154)\n\n",
        "upstream_commits": [
            "b5d66a17fa296117b44f23ae45ff7338cee6ae85"
        ]
    }
]