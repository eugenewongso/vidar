[
    {
        "id": "ASB-A-281848557",
        "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-281848557",
        "severity": "High",
        "failures": [
            {
                "downstream_version": "12",
                "branch_used": "android12-release",
                "downstream_patch": "73fa082a7202100da107ae14dd7742ecd86da053",
                "repo_path": "android_repos/base",
                "result": "failure",
                "downstream_patch_content": "commit 73fa082a7202100da107ae14dd7742ecd86da053\nAuthor: Tim Yu <yunicorn@google.com>\nDate:   Tue Jun 20 21:24:36 2023 +0000\n\n    [DO NOT MERGE] Verify URI Permissions in Autofill RemoteViews\n    \n    Check permissions of URI inside of FillResponse's RemoteViews. If the\n    current user does not have the required permissions to view the URI, the\n    RemoteView is dropped from displaying.\n    \n    This fixes a security spill in which a user can view content of another\n    user through a malicious Autofill provider.\n    \n    Bug: 283137865\n    Fixes: b/283264674 b/281666022 b/281665050 b/281848557 b/281533566\n    b/281534749 b/283101289\n    Test: Verified by POC app attached in bugs\n    Test: atest CtsAutoFillServiceTestCases (added new tests)\n    Change-Id: I6f4d2a35e89bbed7bd9e07bf5cd3e2d68b20af9a\n\ndiff --git a/services/autofill/java/com/android/server/autofill/Helper.java b/services/autofill/java/com/android/server/autofill/Helper.java\nindex bc5d6457c945..48113a81cca5 100644\n--- a/services/autofill/java/com/android/server/autofill/Helper.java\n+++ b/services/autofill/java/com/android/server/autofill/Helper.java\n@@ -18,6 +18,8 @@ package com.android.server.autofill;\n \n import android.annotation.NonNull;\n import android.annotation.Nullable;\n+import android.annotation.UserIdInt;\n+import android.app.ActivityManager;\n import android.app.assist.AssistStructure;\n import android.app.assist.AssistStructure.ViewNode;\n import android.app.assist.AssistStructure.WindowNode;\n@@ -34,6 +36,7 @@ import android.view.View;\n import android.view.WindowManager;\n import android.view.autofill.AutofillId;\n import android.view.autofill.AutofillValue;\n+import android.widget.RemoteViews;\n \n import com.android.internal.logging.nano.MetricsProto.MetricsEvent;\n import com.android.internal.util.ArrayUtils;\n@@ -42,6 +45,8 @@ import java.io.PrintWriter;\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n \n public final class Helper {\n \n@@ -75,6 +80,44 @@ public final class Helper {\n         throw new UnsupportedOperationException(\"contains static members only\");\n     }\n \n+    private static boolean checkRemoteViewUriPermissions(\n+            @UserIdInt int userId, @NonNull RemoteViews rView) {\n+        final AtomicBoolean permissionsOk = new AtomicBoolean(true);\n+\n+        rView.visitUris(uri -> {\n+            int uriOwnerId = android.content.ContentProvider.getUserIdFromUri(uri);\n+            boolean allowed = uriOwnerId == userId;\n+            permissionsOk.set(allowed && permissionsOk.get());\n+        });\n+\n+        return permissionsOk.get();\n+    }\n+\n+    /**\n+     * Checks the URI permissions of the remote view,\n+     * to see if the current userId is able to access it.\n+     *\n+     * Returns the RemoteView that is passed if user is able, null otherwise.\n+     *\n+     * TODO: instead of returning a null remoteview when\n+     * the current userId cannot access an URI,\n+     * return a new RemoteView with the URI removed.\n+     */\n+    public static @Nullable RemoteViews sanitizeRemoteView(RemoteViews rView) {\n+        if (rView == null) return null;\n+\n+        int userId = ActivityManager.getCurrentUser();\n+\n+        boolean ok = checkRemoteViewUriPermissions(userId, rView);\n+        if (!ok) {\n+            Slog.w(TAG,\n+                    \"sanitizeRemoteView() user: \" + userId\n+                    + \" tried accessing resource that does not belong to them\");\n+        }\n+        return (ok ? rView : null);\n+    }\n+\n+\n     @Nullable\n     static AutofillId[] toArray(@Nullable ArraySet<AutofillId> set) {\n         if (set == null) return null;\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/FillUi.java b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\nindex 27ea3d618afa..af6e38b1d46c 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n@@ -141,8 +141,9 @@ final class FillUi {\n \n         final LayoutInflater inflater = LayoutInflater.from(mContext);\n \n-        final RemoteViews headerPresentation = response.getHeader();\n-        final RemoteViews footerPresentation = response.getFooter();\n+        final RemoteViews headerPresentation = Helper.sanitizeRemoteView(response.getHeader());\n+        final RemoteViews footerPresentation = Helper.sanitizeRemoteView(response.getFooter());\n+\n         final ViewGroup decor;\n         if (mFullScreen) {\n             decor = (ViewGroup) inflater.inflate(R.layout.autofill_dataset_picker_fullscreen, null);\n@@ -220,6 +221,9 @@ final class FillUi {\n             ViewGroup container = decor.findViewById(R.id.autofill_dataset_picker);\n             final View content;\n             try {\n+                if (Helper.sanitizeRemoteView(response.getPresentation()) == null) {\n+                    throw new RuntimeException(\"Permission error accessing RemoteView\");\n+                }\n                 content = response.getPresentation().applyWithTheme(\n                         mContext, decor, interceptionHandler, mThemeId);\n                 container.addView(content);\n@@ -299,7 +303,8 @@ final class FillUi {\n                 final Dataset dataset = response.getDatasets().get(i);\n                 final int index = dataset.getFieldIds().indexOf(focusedViewId);\n                 if (index >= 0) {\n-                    final RemoteViews presentation = dataset.getFieldPresentation(index);\n+                    final RemoteViews presentation = Helper.sanitizeRemoteView(\n+                            dataset.getFieldPresentation(index));\n                     if (presentation == null) {\n                         Slog.w(TAG, \"not displaying UI on field \" + focusedViewId + \" because \"\n                                 + \"service didn't provide a presentation for it on \" + dataset);\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\nindex 826a98afe2f8..49df4a8b66ed 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n@@ -368,8 +368,7 @@ final class SaveUi {\n             return false;\n         }\n         writeLog(MetricsEvent.AUTOFILL_SAVE_CUSTOM_DESCRIPTION);\n-\n-        final RemoteViews template = customDescription.getPresentation();\n+        final RemoteViews template = Helper.sanitizeRemoteView(customDescription.getPresentation());\n         if (template == null) {\n             Slog.w(TAG, \"No remote view on custom description\");\n             return false;\n",
                "file_conflicts": []
            },
            {
                "downstream_version": "12L",
                "branch_used": "android12L-release",
                "downstream_patch": "f7ca136c514dc975c3f46d95c53fd6b3752c577a",
                "repo_path": "android_repos/base",
                "result": "failure",
                "downstream_patch_content": "commit f7ca136c514dc975c3f46d95c53fd6b3752c577a\nAuthor: Tim Yu <yunicorn@google.com>\nDate:   Tue Jun 20 21:24:36 2023 +0000\n\n    [DO NOT MERGE] Verify URI Permissions in Autofill RemoteViews\n    \n    Check permissions of URI inside of FillResponse's RemoteViews. If the\n    current user does not have the required permissions to view the URI, the\n    RemoteView is dropped from displaying.\n    \n    This fixes a security spill in which a user can view content of another\n    user through a malicious Autofill provider.\n    \n    Bug: 283137865\n    Fixes: b/283264674 b/281666022 b/281665050 b/281848557 b/281533566\n    b/281534749 b/283101289\n    Test: Verified by POC app attached in bugs\n    Test: atest CtsAutoFillServiceTestCases (added new tests)\n    Change-Id: I6f4d2a35e89bbed7bd9e07bf5cd3e2d68b20af9a\n\ndiff --git a/services/autofill/java/com/android/server/autofill/Helper.java b/services/autofill/java/com/android/server/autofill/Helper.java\nindex bc5d6457c945..48113a81cca5 100644\n--- a/services/autofill/java/com/android/server/autofill/Helper.java\n+++ b/services/autofill/java/com/android/server/autofill/Helper.java\n@@ -18,6 +18,8 @@ package com.android.server.autofill;\n \n import android.annotation.NonNull;\n import android.annotation.Nullable;\n+import android.annotation.UserIdInt;\n+import android.app.ActivityManager;\n import android.app.assist.AssistStructure;\n import android.app.assist.AssistStructure.ViewNode;\n import android.app.assist.AssistStructure.WindowNode;\n@@ -34,6 +36,7 @@ import android.view.View;\n import android.view.WindowManager;\n import android.view.autofill.AutofillId;\n import android.view.autofill.AutofillValue;\n+import android.widget.RemoteViews;\n \n import com.android.internal.logging.nano.MetricsProto.MetricsEvent;\n import com.android.internal.util.ArrayUtils;\n@@ -42,6 +45,8 @@ import java.io.PrintWriter;\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n \n public final class Helper {\n \n@@ -75,6 +80,44 @@ public final class Helper {\n         throw new UnsupportedOperationException(\"contains static members only\");\n     }\n \n+    private static boolean checkRemoteViewUriPermissions(\n+            @UserIdInt int userId, @NonNull RemoteViews rView) {\n+        final AtomicBoolean permissionsOk = new AtomicBoolean(true);\n+\n+        rView.visitUris(uri -> {\n+            int uriOwnerId = android.content.ContentProvider.getUserIdFromUri(uri);\n+            boolean allowed = uriOwnerId == userId;\n+            permissionsOk.set(allowed && permissionsOk.get());\n+        });\n+\n+        return permissionsOk.get();\n+    }\n+\n+    /**\n+     * Checks the URI permissions of the remote view,\n+     * to see if the current userId is able to access it.\n+     *\n+     * Returns the RemoteView that is passed if user is able, null otherwise.\n+     *\n+     * TODO: instead of returning a null remoteview when\n+     * the current userId cannot access an URI,\n+     * return a new RemoteView with the URI removed.\n+     */\n+    public static @Nullable RemoteViews sanitizeRemoteView(RemoteViews rView) {\n+        if (rView == null) return null;\n+\n+        int userId = ActivityManager.getCurrentUser();\n+\n+        boolean ok = checkRemoteViewUriPermissions(userId, rView);\n+        if (!ok) {\n+            Slog.w(TAG,\n+                    \"sanitizeRemoteView() user: \" + userId\n+                    + \" tried accessing resource that does not belong to them\");\n+        }\n+        return (ok ? rView : null);\n+    }\n+\n+\n     @Nullable\n     static AutofillId[] toArray(@Nullable ArraySet<AutofillId> set) {\n         if (set == null) return null;\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/FillUi.java b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\nindex 27ea3d618afa..af6e38b1d46c 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n@@ -141,8 +141,9 @@ final class FillUi {\n \n         final LayoutInflater inflater = LayoutInflater.from(mContext);\n \n-        final RemoteViews headerPresentation = response.getHeader();\n-        final RemoteViews footerPresentation = response.getFooter();\n+        final RemoteViews headerPresentation = Helper.sanitizeRemoteView(response.getHeader());\n+        final RemoteViews footerPresentation = Helper.sanitizeRemoteView(response.getFooter());\n+\n         final ViewGroup decor;\n         if (mFullScreen) {\n             decor = (ViewGroup) inflater.inflate(R.layout.autofill_dataset_picker_fullscreen, null);\n@@ -220,6 +221,9 @@ final class FillUi {\n             ViewGroup container = decor.findViewById(R.id.autofill_dataset_picker);\n             final View content;\n             try {\n+                if (Helper.sanitizeRemoteView(response.getPresentation()) == null) {\n+                    throw new RuntimeException(\"Permission error accessing RemoteView\");\n+                }\n                 content = response.getPresentation().applyWithTheme(\n                         mContext, decor, interceptionHandler, mThemeId);\n                 container.addView(content);\n@@ -299,7 +303,8 @@ final class FillUi {\n                 final Dataset dataset = response.getDatasets().get(i);\n                 final int index = dataset.getFieldIds().indexOf(focusedViewId);\n                 if (index >= 0) {\n-                    final RemoteViews presentation = dataset.getFieldPresentation(index);\n+                    final RemoteViews presentation = Helper.sanitizeRemoteView(\n+                            dataset.getFieldPresentation(index));\n                     if (presentation == null) {\n                         Slog.w(TAG, \"not displaying UI on field \" + focusedViewId + \" because \"\n                                 + \"service didn't provide a presentation for it on \" + dataset);\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\nindex 826a98afe2f8..49df4a8b66ed 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n@@ -368,8 +368,7 @@ final class SaveUi {\n             return false;\n         }\n         writeLog(MetricsEvent.AUTOFILL_SAVE_CUSTOM_DESCRIPTION);\n-\n-        final RemoteViews template = customDescription.getPresentation();\n+        final RemoteViews template = Helper.sanitizeRemoteView(customDescription.getPresentation());\n         if (template == null) {\n             Slog.w(TAG, \"No remote view on custom description\");\n             return false;\n",
                "file_conflicts": []
            }
        ],
        "upstream_patch_content": "From bf7fbbccd920596e514d1559fb3feaca70e55e78 Mon Sep 17 00:00:00 2001\nFrom: Tim Yu <yunicorn@google.com>\nDate: Tue, 20 Jun 2023 21:24:36 +0000\nSubject: [PATCH] [DO NOT MERGE] Verify URI Permissions in Autofill RemoteViews\n\nCheck permissions of URI inside of FillResponse's RemoteViews. If the\ncurrent user does not have the required permissions to view the URI, the\nRemoteView is dropped from displaying.\n\nThis fixes a security spill in which a user can view content of another\nuser through a malicious Autofill provider.\n\nBug: 283137865\nFixes: b/283264674 b/281666022 b/281665050 b/281848557 b/281533566\nb/281534749 b/283101289\nTest: Verified by POC app attached in bugs\nTest: atest CtsAutoFillServiceTestCases (added new tests)\nChange-Id: I6f4d2a35e89bbed7bd9e07bf5cd3e2d68b20af9a\n---\n .../com/android/server/autofill/Helper.java   | 43 +++++++++++++++++++\n .../server/autofill/ui/DialogFillUi.java      | 12 ++++--\n .../android/server/autofill/ui/FillUi.java    | 11 +++--\n .../android/server/autofill/ui/SaveUi.java    |  3 +-\n 4 files changed, 60 insertions(+), 9 deletions(-)\n\ndiff --git a/services/autofill/java/com/android/server/autofill/Helper.java b/services/autofill/java/com/android/server/autofill/Helper.java\nindex 82af38200166..ad8f5e1481e1 100644\n--- a/services/autofill/java/com/android/server/autofill/Helper.java\n+++ b/services/autofill/java/com/android/server/autofill/Helper.java\n@@ -20,6 +20,8 @@ import static com.android.server.autofill.Helper.sDebug;\n \n import android.annotation.NonNull;\n import android.annotation.Nullable;\n+import android.annotation.UserIdInt;\n+import android.app.ActivityManager;\n import android.app.assist.AssistStructure;\n import android.app.assist.AssistStructure.ViewNode;\n import android.app.assist.AssistStructure.WindowNode;\n@@ -40,6 +42,7 @@ import android.view.View;\n import android.view.WindowManager;\n import android.view.autofill.AutofillId;\n import android.view.autofill.AutofillValue;\n+import android.widget.RemoteViews;\n \n import com.android.internal.logging.nano.MetricsProto.MetricsEvent;\n import com.android.internal.util.ArrayUtils;\n@@ -50,6 +53,8 @@ import java.lang.ref.WeakReference;\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n \n public final class Helper {\n \n@@ -83,6 +88,44 @@ public final class Helper {\n         throw new UnsupportedOperationException(\"contains static members only\");\n     }\n \n+    private static boolean checkRemoteViewUriPermissions(\n+            @UserIdInt int userId, @NonNull RemoteViews rView) {\n+        final AtomicBoolean permissionsOk = new AtomicBoolean(true);\n+\n+        rView.visitUris(uri -> {\n+            int uriOwnerId = android.content.ContentProvider.getUserIdFromUri(uri);\n+            boolean allowed = uriOwnerId == userId;\n+            permissionsOk.set(allowed & permissionsOk.get());\n+        });\n+\n+        return permissionsOk.get();\n+    }\n+\n+    /**\n+     * Checks the URI permissions of the remote view,\n+     * to see if the current userId is able to access it.\n+     *\n+     * Returns the RemoteView that is passed if user is able, null otherwise.\n+     *\n+     * TODO: instead of returning a null remoteview when\n+     * the current userId cannot access an URI,\n+     * return a new RemoteView with the URI removed.\n+     */\n+    public static @Nullable RemoteViews sanitizeRemoteView(RemoteViews rView) {\n+        if (rView == null) return null;\n+\n+        int userId = ActivityManager.getCurrentUser();\n+\n+        boolean ok = checkRemoteViewUriPermissions(userId, rView);\n+        if (!ok) {\n+            Slog.w(TAG,\n+                    \"sanitizeRemoteView() user: \" + userId\n+                    + \" tried accessing resource that does not belong to them\");\n+        }\n+        return (ok ? rView : null);\n+    }\n+\n+\n     @Nullable\n     static AutofillId[] toArray(@Nullable ArraySet<AutofillId> set) {\n         if (set == null) return null;\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java b/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java\nindex dbeb624bd202..fa414e3b172b 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java\n@@ -53,6 +53,7 @@ import android.widget.TextView;\n \n import com.android.internal.R;\n import com.android.server.autofill.AutofillManagerService;\n+import com.android.server.autofill.Helper;\n \n import java.io.PrintWriter;\n import java.util.ArrayList;\n@@ -208,7 +209,8 @@ final class DialogFillUi {\n     }\n \n     private void setHeader(View decor, FillResponse response) {\n-        final RemoteViews presentation = response.getDialogHeader();\n+        final RemoteViews presentation =\n+                Helper.sanitizeRemoteView(response.getDialogHeader());\n         if (presentation == null) {\n             return;\n         }\n@@ -243,9 +245,10 @@ final class DialogFillUi {\n     }\n \n     private void initialAuthenticationLayout(View decor, FillResponse response) {\n-        RemoteViews presentation = response.getDialogPresentation();\n+        RemoteViews presentation = Helper.sanitizeRemoteView(\n+                response.getDialogPresentation());\n         if (presentation == null) {\n-            presentation = response.getPresentation();\n+            presentation = Helper.sanitizeRemoteView(response.getPresentation());\n         }\n         if (presentation == null) {\n             throw new RuntimeException(\"No presentation for fill dialog authentication\");\n@@ -289,7 +292,8 @@ final class DialogFillUi {\n             final Dataset dataset = response.getDatasets().get(i);\n             final int index = dataset.getFieldIds().indexOf(focusedViewId);\n             if (index >= 0) {\n-                RemoteViews presentation = dataset.getFieldDialogPresentation(index);\n+                RemoteViews presentation = Helper.sanitizeRemoteView(\n+                        dataset.getFieldDialogPresentation(index));\n                 if (presentation == null) {\n                     if (sDebug) {\n                         Slog.w(TAG, \"not displaying UI on field \" + focusedViewId + \" because \"\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/FillUi.java b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\nindex 129ce72e037d..cdfe7bb4f4a7 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n@@ -148,8 +148,9 @@ final class FillUi {\n \n         final LayoutInflater inflater = LayoutInflater.from(mContext);\n \n-        final RemoteViews headerPresentation = response.getHeader();\n-        final RemoteViews footerPresentation = response.getFooter();\n+        final RemoteViews headerPresentation = Helper.sanitizeRemoteView(response.getHeader());\n+        final RemoteViews footerPresentation = Helper.sanitizeRemoteView(response.getFooter());\n+\n         final ViewGroup decor;\n         if (mFullScreen) {\n             decor = (ViewGroup) inflater.inflate(R.layout.autofill_dataset_picker_fullscreen, null);\n@@ -227,6 +228,9 @@ final class FillUi {\n             ViewGroup container = decor.findViewById(R.id.autofill_dataset_picker);\n             final View content;\n             try {\n+                if (Helper.sanitizeRemoteView(response.getPresentation()) == null) {\n+                    throw new RuntimeException(\"Permission error accessing RemoteView\");\n+                }\n                 content = response.getPresentation().applyWithTheme(\n                         mContext, decor, interceptionHandler, mThemeId);\n                 container.addView(content);\n@@ -306,7 +310,8 @@ final class FillUi {\n                 final Dataset dataset = response.getDatasets().get(i);\n                 final int index = dataset.getFieldIds().indexOf(focusedViewId);\n                 if (index >= 0) {\n-                    final RemoteViews presentation = dataset.getFieldPresentation(index);\n+                    final RemoteViews presentation = Helper.sanitizeRemoteView(\n+                            dataset.getFieldPresentation(index));\n                     if (presentation == null) {\n                         Slog.w(TAG, \"not displaying UI on field \" + focusedViewId + \" because \"\n                                 + \"service didn't provide a presentation for it on \" + dataset);\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\nindex f035d0764279..70382f1d5274 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n@@ -384,8 +384,7 @@ final class SaveUi {\n             return false;\n         }\n         writeLog(MetricsEvent.AUTOFILL_SAVE_CUSTOM_DESCRIPTION);\n-\n-        final RemoteViews template = customDescription.getPresentation();\n+        final RemoteViews template = Helper.sanitizeRemoteView(customDescription.getPresentation());\n         if (template == null) {\n             Slog.w(TAG, \"No remote view on custom description\");\n             return false;\n-- \n2.39.5 (Apple Git-154)\n\n",
        "upstream_commits": [
            "bf7fbbccd920596e514d1559fb3feaca70e55e78"
        ]
    },
    {
        "id": "ASB-A-360846772",
        "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-360846772",
        "severity": "High",
        "failures": [
            {
                "downstream_version": "12",
                "branch_used": "android12-release",
                "downstream_patch": "185048041e6f9d43c38829c09965e7a4740d2a6a",
                "repo_path": "android_repos/base",
                "result": "failure",
                "downstream_patch_content": "commit 185048041e6f9d43c38829c09965e7a4740d2a6a\nAuthor: Dmitry Dementyev <dementyev@google.com>\nDate:   Wed Oct 16 15:01:59 2024 -0700\n\n    Update checkKeyIntent\n    \n    1) Explicityly set  component after target activity check.\n    2) Update Intent subclass check.\n    \n    Bug: 360846772\n    Test: manual\n    Flag: EXEMPT bugfix\n    \n    Merged-In: Ied7961c73299681aa5b523cf3f00fd905893116f\n    Change-Id: Iafc1e2260107f7ecc18c90ce12f8987b4fc76350\n\ndiff --git a/services/core/java/com/android/server/accounts/AccountManagerService.java b/services/core/java/com/android/server/accounts/AccountManagerService.java\nindex 36ffc40bf5f7..5f434ee267d4 100644\n--- a/services/core/java/com/android/server/accounts/AccountManagerService.java\n+++ b/services/core/java/com/android/server/accounts/AccountManagerService.java\n@@ -4916,6 +4916,8 @@ public class AccountManagerService\n                     Log.e(TAG, String.format(tmpl, activityName, pkgName, mAccountType));\n                     return false;\n                 }\n+                intent.setComponent(targetActivityInfo.getComponentName());\n+                bundle.putParcelable(AccountManager.KEY_INTENT, intent);\n                 return true;\n             } finally {\n                 Binder.restoreCallingIdentity(bid);\n@@ -4937,13 +4939,14 @@ public class AccountManagerService\n             Bundle simulateBundle = p.readBundle();\n             p.recycle();\n             Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT);\n-            if (intent != null && intent.getClass() != Intent.class) {\n-                return false;\n-            }\n             Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT);\n             if (intent == null) {\n                 return (simulateIntent == null);\n             }\n+            if (intent.getClass() != Intent.class || simulateIntent.getClass() != Intent.class) {\n+                return false;\n+            }\n+\n             if (!intent.filterEquals(simulateIntent)) {\n                 return false;\n             }\n",
                "file_conflicts": [
                    {
                        "file_name": "services/core/java/com/android/server/accounts/AccountManagerService.java",
                        "total_hunks": 2,
                        "failed_hunks": [
                            2
                        ],
                        "inline_merge_conflicts": [
                            {
                                "hunk_number": 1,
                                "merge_conflict": "<<<<<<< DOWNSTREAM (version 12)\n\n=======\n                return false;\n            }\n\n            if (!intent.filterEquals(simulateIntent)) {\n>>>>>>> UPSTREAM PATCH (commit cde345a7ee06db716e613e12a2c218ce248ad1c4)"
                            }
                        ],
                        "rej_file_content": "```diff\n--- services/core/java/com/android/server/accounts/AccountManagerService.java\n+++ services/core/java/com/android/server/accounts/AccountManagerService.java\n@@ -5085,14 +5087,15 @@ public class AccountManagerService\n             Bundle simulateBundle = p.readBundle();\n             p.recycle();\n             Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT, Intent.class);\n-            if (intent != null && intent.getClass() != Intent.class) {\n-                return false;\n-            }\n             Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT,\n                     Intent.class);\n             if (intent == null) {\n                 return (simulateIntent == null);\n             }\n+            if (intent.getClass() != Intent.class || simulateIntent.getClass() != Intent.class) {\n+                return false;\n+            }\n+\n             if (!intent.filterEquals(simulateIntent)) {\n                 return false;\n             }\n```",
                        "patch_apply_output": "patching file services/core/java/com/android/server/accounts/AccountManagerService.java\nHunk #1 succeeded at 4916 (offset -146 lines).\nHunk #2 FAILED at 5085.\n1 out of 2 hunks FAILED -- saving rejects to file services/core/java/com/android/server/accounts/AccountManagerService.java.rej",
                        "inline_merge_output": "patching file services/core/java/com/android/server/accounts/AccountManagerService.java\nHunk #1 already applied at 5065-5066.\nHunk #2 already applied at 5088, NOT MERGED at 5094-5100.",
                        "upstream_file_content": "```java\n/*\n * Copyright (C) 2009 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.server.accounts;\n\nimport android.Manifest;\nimport android.accounts.AbstractAccountAuthenticator;\nimport android.accounts.Account;\nimport android.accounts.AccountAndUser;\nimport android.accounts.AccountAuthenticatorResponse;\nimport android.accounts.AccountManager;\nimport android.accounts.AccountManagerInternal;\nimport android.accounts.AccountManagerResponse;\nimport android.accounts.AuthenticatorDescription;\nimport android.accounts.CantAddAccountActivity;\nimport android.accounts.ChooseAccountActivity;\nimport android.accounts.GrantCredentialsPermissionActivity;\nimport android.accounts.IAccountAuthenticator;\nimport android.accounts.IAccountAuthenticatorResponse;\nimport android.accounts.IAccountManager;\nimport android.accounts.IAccountManagerResponse;\nimport android.annotation.IntRange;\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.app.ActivityManager;\nimport android.app.ActivityThread;\nimport android.app.AppOpsManager;\nimport android.app.BroadcastOptions;\nimport android.app.INotificationManager;\nimport android.app.Notification;\nimport android.app.NotificationManager;\nimport android.app.PendingIntent;\nimport android.app.admin.DevicePolicyEventLogger;\nimport android.app.admin.DevicePolicyManager;\nimport android.app.admin.DevicePolicyManagerInternal;\nimport android.app.compat.CompatChanges;\nimport android.compat.annotation.ChangeId;\nimport android.compat.annotation.EnabledAfter;\nimport android.content.BroadcastReceiver;\nimport android.content.ClipData;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.IntentSender;\nimport android.content.ServiceConnection;\nimport android.content.pm.ActivityInfo;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.IPackageManager;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManager.NameNotFoundException;\nimport android.content.pm.PackageManagerInternal;\nimport android.content.pm.RegisteredServicesCache;\nimport android.content.pm.RegisteredServicesCacheListener;\nimport android.content.pm.ResolveInfo;\nimport android.content.pm.Signature;\nimport android.content.pm.SigningDetails.CertCapabilities;\nimport android.content.pm.UserInfo;\nimport android.database.Cursor;\nimport android.database.sqlite.SQLiteCantOpenDatabaseException;\nimport android.database.sqlite.SQLiteException;\nimport android.database.sqlite.SQLiteFullException;\nimport android.database.sqlite.SQLiteStatement;\nimport android.os.Binder;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Environment;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.Parcel;\nimport android.os.Parcelable;\nimport android.os.Process;\nimport android.os.RemoteCallback;\nimport android.os.RemoteException;\nimport android.os.ResultReceiver;\nimport android.os.ShellCallback;\nimport android.os.StrictMode;\nimport android.os.SystemClock;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.provider.Settings;\nimport android.stats.devicepolicy.DevicePolicyEnums;\nimport android.text.TextUtils;\nimport android.util.EventLog;\nimport android.util.Log;\nimport android.util.Pair;\nimport android.util.Slog;\nimport android.util.SparseArray;\nimport android.util.SparseBooleanArray;\n\nimport com.android.internal.R;\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.content.PackageMonitor;\nimport com.android.internal.messages.nano.SystemMessageProto.SystemMessage;\nimport com.android.internal.notification.SystemNotificationChannels;\nimport com.android.internal.util.ArrayUtils;\nimport com.android.internal.util.DumpUtils;\nimport com.android.internal.util.IndentingPrintWriter;\nimport com.android.internal.util.Preconditions;\nimport com.android.modules.expresslog.Histogram;\nimport com.android.server.LocalServices;\nimport com.android.server.ServiceThread;\nimport com.android.server.SystemService;\n\nimport com.google.android.collect.Lists;\nimport com.google.android.collect.Sets;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.PrintWriter;\nimport java.security.GeneralSecurityException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.concurrent.atomic.AtomicReference;\n\n/**\n * A system service that provides  account, password, and authtoken management for all\n * accounts on the device. Some of these calls are implemented with the help of the corresponding\n * {@link IAccountAuthenticator} services. This service is not accessed by users directly,\n * instead one uses an instance of {@link AccountManager}, which can be accessed as follows:\n *    AccountManager accountManager = AccountManager.get(context);\n * @hide\n */\npublic class AccountManagerService\n        extends IAccountManager.Stub\n        implements RegisteredServicesCacheListener<AuthenticatorDescription> {\n    private static final String TAG = \"AccountManagerService\";\n\n    public static class Lifecycle extends SystemService {\n        private AccountManagerService mService;\n\n        public Lifecycle(Context context) {\n            super(context);\n        }\n\n        @Override\n        public void onStart() {\n            mService = new AccountManagerService(new Injector(getContext()));\n            publishBinderService(Context.ACCOUNT_SERVICE, mService);\n        }\n\n        @Override\n        public void onUserUnlocking(@NonNull TargetUser user) {\n            mService.onUnlockUser(user.getUserIdentifier());\n        }\n\n        @Override\n        public void onUserStopped(@NonNull TargetUser user) {\n            Slog.i(TAG, \"onUserStopped \" + user);\n            mService.purgeUserData(user.getUserIdentifier());\n        }\n    }\n\n    final Context mContext;\n\n    private static final int[] INTERESTING_APP_OPS = new int[] {\n        AppOpsManager.OP_GET_ACCOUNTS,\n        AppOpsManager.OP_READ_CONTACTS,\n        AppOpsManager.OP_WRITE_CONTACTS,\n    };\n\n    private final PackageManager mPackageManager;\n    private final AppOpsManager mAppOpsManager;\n    private UserManager mUserManager;\n    private final Injector mInjector;\n\n    final MessageHandler mHandler;\n\n    private static final int TIMEOUT_DELAY_MS = 1000 * 60 * 15;\n    // Messages that can be sent on mHandler\n    private static final int MESSAGE_TIMED_OUT = 3;\n    private static final int MESSAGE_COPY_SHARED_ACCOUNT = 4;\n\n    private final IAccountAuthenticatorCache mAuthenticatorCache;\n    private static final String PRE_N_DATABASE_NAME = \"accounts.db\";\n    private static final Intent ACCOUNTS_CHANGED_INTENT;\n    private static final Bundle ACCOUNTS_CHANGED_OPTIONS = new BroadcastOptions()\n            .setDeliveryGroupPolicy(BroadcastOptions.DELIVERY_GROUP_POLICY_MOST_RECENT)\n            .toBundle();\n\n    private static final int SIGNATURE_CHECK_MISMATCH = 0;\n    private static final int SIGNATURE_CHECK_MATCH = 1;\n    private static final int SIGNATURE_CHECK_UID_MATCH = 2;\n\n    /**\n     * Apps targeting Android U and above need to declare the package visibility needs in the\n     * manifest to access the AccountManager APIs.\n     */\n    @ChangeId\n    @EnabledAfter(targetSdkVersion = Build.VERSION_CODES.TIRAMISU)\n    private static final long ENFORCE_PACKAGE_VISIBILITY_FILTERING = 154726397;\n\n    static {\n        ACCOUNTS_CHANGED_INTENT = new Intent(AccountManager.LOGIN_ACCOUNTS_CHANGED_ACTION);\n        ACCOUNTS_CHANGED_INTENT.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT\n                | Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);\n    }\n\n    private final LinkedHashMap<String, Session> mSessions = new LinkedHashMap<String, Session>();\n\n    static class UserAccounts {\n        private final int userId;\n        final AccountsDb accountsDb;\n        private final HashMap<Pair<Pair<Account, String>, Integer>, NotificationId>\n                credentialsPermissionNotificationIds = new HashMap<>();\n        private final HashMap<Account, NotificationId> signinRequiredNotificationIds\n                = new HashMap<>();\n        final Object cacheLock = new Object();\n        final Object dbLock = new Object(); // if needed, dbLock must be obtained before cacheLock\n        /** protected by the {@link #cacheLock} */\n        final HashMap<String, Account[]> accountCache = new LinkedHashMap<>();\n        /** protected by the {@link #cacheLock} */\n        private final Map<Account, Map<String, String>> userDataCache = new HashMap<>();\n        /** protected by the {@link #cacheLock} */\n        private final Map<Account, Map<String, String>> authTokenCache = new HashMap<>();\n        /** protected by the {@link #cacheLock} */\n        private final TokenCache accountTokenCaches = new TokenCache();\n        /** protected by the {@link #cacheLock} */\n        private final Map<Account, Map<String, Integer>> visibilityCache = new HashMap<>();\n\n        /** protected by the {@link #mReceiversForType},\n         *  type -> (packageName -> number of active receivers)\n         *  type == null is used to get notifications about all account types\n         */\n        private final Map<String, Map<String, Integer>> mReceiversForType = new HashMap<>();\n\n        /**\n         * protected by the {@link #cacheLock}\n         *\n         * Caches the previous names associated with an account. Previous names\n         * should be cached because we expect that when an Account is renamed,\n         * many clients will receive a LOGIN_ACCOUNTS_CHANGED broadcast and\n         * want to know if the accounts they care about have been renamed.\n         *\n         * The previous names are wrapped in an {@link AtomicReference} so that\n         * we can distinguish between those accounts with no previous names and\n         * those whose previous names haven't been cached (yet).\n         */\n        private final HashMap<Account, AtomicReference<String>> previousNameCache =\n                new HashMap<Account, AtomicReference<String>>();\n\n        UserAccounts(Context context, int userId, File preNDbFile, File deDbFile) {\n            this.userId = userId;\n            synchronized (dbLock) {\n                synchronized (cacheLock) {\n                    accountsDb = AccountsDb.create(context, userId, preNDbFile, deDbFile);\n                }\n            }\n        }\n    }\n\n    private final SparseArray<UserAccounts> mUsers = new SparseArray<>();\n    private final SparseBooleanArray mLocalUnlockedUsers = new SparseBooleanArray();\n    // Not thread-safe. Only use in synchronized context\n    private final SimpleDateFormat mDateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n    private CopyOnWriteArrayList<AccountManagerInternal.OnAppPermissionChangeListener>\n            mAppPermissionChangeListeners = new CopyOnWriteArrayList<>();\n\n    private static AtomicReference<AccountManagerService> sThis = new AtomicReference<>();\n    private static final Account[] EMPTY_ACCOUNT_ARRAY = new Account[]{};\n\n    private static Histogram sResponseLatency = new Histogram(\n            \"app.value_high_authenticator_response_latency\",\n            new Histogram.ScaledRangeOptions(20, 10000, 10000, 1.5f)\n    );\n\n    /**\n     * This should only be called by system code. One should only call this after the service\n     * has started.\n     * @return a reference to the AccountManagerService instance\n     * @hide\n     */\n    public static AccountManagerService getSingleton() {\n        return sThis.get();\n    }\n\n    public AccountManagerService(Injector injector) {\n        mInjector = injector;\n        mContext = injector.getContext();\n        mPackageManager = mContext.getPackageManager();\n        mAppOpsManager = mContext.getSystemService(AppOpsManager.class);\n        mHandler = new MessageHandler(injector.getMessageHandlerLooper());\n        mAuthenticatorCache = mInjector.getAccountAuthenticatorCache();\n        mAuthenticatorCache.setListener(this, mHandler);\n\n        sThis.set(this);\n\n        IntentFilter intentFilter = new IntentFilter();\n        intentFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);\n        intentFilter.addDataScheme(\"package\");\n        mContext.registerReceiver(new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context1, Intent intent) {\n                // Don't delete accounts when updating a authenticator's\n                // package.\n                if (!intent.getBooleanExtra(Intent.EXTRA_REPLACING, false)) {\n                    /* Purging data requires file io, don't block the main thread. This is probably\n                     * less than ideal because we are introducing a race condition where old grants\n                     * could be exercised until they are purged. But that race condition existed\n                     * anyway with the broadcast receiver.\n                     *\n                     * Ideally, we would completely clear the cache, purge data from the database,\n                     * and then rebuild the cache. All under the cache lock. But that change is too\n                     * large at this point.\n                     */\n                    final String removedPackageName = intent.getData().getSchemeSpecificPart();\n                    Runnable purgingRunnable = new Runnable() {\n                        @Override\n                        public void run() {\n                            purgeOldGrantsAll();\n                            // Notify authenticator about removed app?\n                            removeVisibilityValuesForPackage(removedPackageName);\n                        }\n                    };\n                    mHandler.post(purgingRunnable);\n                }\n            }\n        }, intentFilter);\n\n        injector.addLocalService(new AccountManagerInternalImpl());\n\n        IntentFilter userFilter = new IntentFilter();\n        userFilter.addAction(Intent.ACTION_USER_REMOVED);\n        mContext.registerReceiverAsUser(new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                String action = intent.getAction();\n                if (Intent.ACTION_USER_REMOVED.equals(action)) {\n                    int userId = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, -1);\n                    if (userId < 1) return;\n                    Slog.i(TAG, \"User \" + userId + \" removed\");\n                    purgeUserData(userId);\n                }\n            }\n        }, UserHandle.ALL, userFilter, null, null);\n\n        // Need to cancel account request notifications if the update/install can access the account\n        new PackageMonitor() {\n            @Override\n            public void onPackageAdded(String packageName, int uid) {\n                // Called on a handler, and running as the system\n                try {\n                    UserAccounts accounts = getUserAccounts(UserHandle.getUserId(uid));\n                    cancelAccountAccessRequestNotificationIfNeeded(uid, true, accounts);\n                } catch (SQLiteCantOpenDatabaseException e) {\n                    Log.w(TAG, \"Can't read accounts database\", e);\n                    return;\n                }\n            }\n\n            @Override\n            public void onPackageUpdateFinished(String packageName, int uid) {\n                // Called on a handler, and running as the system\n                try {\n                    UserAccounts accounts = getUserAccounts(UserHandle.getUserId(uid));\n                    cancelAccountAccessRequestNotificationIfNeeded(uid, true, accounts);\n                } catch (SQLiteCantOpenDatabaseException e) {\n                    Log.w(TAG, \"Can't read accounts database\", e);\n                    return;\n                }\n            }\n        }.register(mContext, mHandler.getLooper(), UserHandle.ALL, true);\n\n        // Cancel account request notification if an app op was preventing the account access\n        for (int i = 0; i < INTERESTING_APP_OPS.length; ++i) {\n            mAppOpsManager.startWatchingMode(INTERESTING_APP_OPS[i], null,\n                    new OnInterestingAppOpChangedListener());\n        }\n\n        // Clear the accounts cache on permission changes.\n        // The specific permissions we care about are backed by AppOps, so just\n        // let the change events on those handle clearing any notifications.\n        mPackageManager.addOnPermissionsChangeListener((int uid) -> {\n            AccountManager.invalidateLocalAccountsDataCaches();\n        });\n    }\n\n    private class OnInterestingAppOpChangedListener\n            extends AppOpsManager.OnOpChangedInternalListener {\n        @Override\n        public void onOpChanged(int op, String packageName) {\n            final int userId = ActivityManager.getCurrentUser();\n            final int packageUid;\n            try {\n                packageUid = mPackageManager.getPackageUidAsUser(packageName, userId);\n            } catch (NameNotFoundException e) {\n                /* ignore */\n                return;\n            }\n\n            final int mode = mAppOpsManager.checkOpNoThrow(op, packageUid, packageName);\n            if (mode != AppOpsManager.MODE_ALLOWED) {\n                return;\n            }\n\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                cancelAccountAccessRequestNotificationIfNeeded(\n                        packageName, packageUid, true, getUserAccounts(userId));\n            } catch (SQLiteCantOpenDatabaseException e) {\n                Log.w(TAG, \"Can't read accounts database\", e);\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        }\n    }\n\n    boolean getBindInstantServiceAllowed(int userId) {\n        return  mAuthenticatorCache.getBindInstantServiceAllowed(userId);\n    }\n\n    void setBindInstantServiceAllowed(int userId, boolean allowed) {\n        mAuthenticatorCache.setBindInstantServiceAllowed(userId, allowed);\n    }\n\n    private void cancelAccountAccessRequestNotificationIfNeeded(int uid,\n            boolean checkAccess, UserAccounts userAccounts) {\n        Account[] accounts = getAccountsOrEmptyArray(null, UserHandle.getUserId(uid), \"android\");\n        for (Account account : accounts) {\n            cancelAccountAccessRequestNotificationIfNeeded(account, uid, checkAccess, userAccounts);\n        }\n    }\n\n    private void cancelAccountAccessRequestNotificationIfNeeded(String packageName, int uid,\n            boolean checkAccess, UserAccounts userAccounts) {\n        Account[] accounts = getAccountsOrEmptyArray(null, UserHandle.getUserId(uid), \"android\");\n        for (Account account : accounts) {\n            cancelAccountAccessRequestNotificationIfNeeded(account,\n                    uid, packageName, checkAccess, userAccounts);\n        }\n    }\n\n    private void cancelAccountAccessRequestNotificationIfNeeded(Account account, int uid,\n            boolean checkAccess, UserAccounts accounts) {\n        String[] packageNames = mPackageManager.getPackagesForUid(uid);\n        if (packageNames != null) {\n            for (String packageName : packageNames) {\n                cancelAccountAccessRequestNotificationIfNeeded(account, uid,\n                        packageName, checkAccess, accounts);\n            }\n        }\n    }\n\n    private void cancelAccountAccessRequestNotificationIfNeeded(Account account,\n            int uid, String packageName, boolean checkAccess, UserAccounts accounts) {\n        if (!checkAccess || hasAccountAccess(account, packageName,\n                UserHandle.getUserHandleForUid(uid))) {\n            cancelNotification(getCredentialPermissionNotificationId(account,\n                    AccountManager.ACCOUNT_ACCESS_TOKEN_TYPE, uid, accounts),\n                    accounts);\n        }\n    }\n\n    @Override\n    public boolean addAccountExplicitlyWithVisibility(Account account, String password,\n            Bundle extras, Map packageToVisibility, String opPackageName) {\n        Bundle.setDefusable(extras, true);\n        int callingUid = Binder.getCallingUid();\n        int userId = UserHandle.getCallingUserId();\n        Objects.requireNonNull(account, \"account cannot be null\");\n        Log.v(TAG, \"addAccountExplicitly: caller's uid=\" + callingUid + \", pid=\"\n                + Binder.getCallingPid() + \", packageName=\" + opPackageName + \", accountType=\"\n                + account.type);\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\"uid=%s, package=%s cannot explicitly add \"\n                    + \"accounts of type: %s\", callingUid, opPackageName, account.type);\n            throw new SecurityException(msg);\n        }\n        /*\n         * Child users are not allowed to add accounts. Only the accounts that are shared by the\n         * parent profile can be added to child profile.\n         *\n         * TODO: Only allow accounts that were shared to be added by a limited user.\n         */\n        // fails if the account already exists\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return addAccountInternal(accounts, account, password, extras, callingUid,\n                    (Map<String, Integer>) packageToVisibility, opPackageName);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public Map<Account, Integer> getAccountsAndVisibilityForPackage(String packageName,\n            String accountType) {\n        int callingUid = Binder.getCallingUid();\n        int userId = UserHandle.getCallingUserId();\n        boolean isSystemUid = UserHandle.isSameApp(callingUid, Process.SYSTEM_UID);\n        List<String> managedTypes = getTypesForCaller(callingUid, userId, isSystemUid);\n\n        if ((accountType != null && !managedTypes.contains(accountType))\n                || (accountType == null && !isSystemUid)) {\n            throw new SecurityException(\n                    \"getAccountsAndVisibilityForPackage() called from unauthorized uid \"\n                            + callingUid + \" with packageName=\" + packageName);\n        }\n        if (accountType != null) {\n            managedTypes = new ArrayList<String>();\n            managedTypes.add(accountType);\n        }\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return getAccountsAndVisibilityForPackage(packageName, managedTypes, callingUid,\n                    accounts);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    /*\n     * accountTypes may not be null\n     */\n    private Map<Account, Integer> getAccountsAndVisibilityForPackage(String packageName,\n            List<String> accountTypes, Integer callingUid, UserAccounts accounts) {\n        if (!canCallerAccessPackage(packageName, callingUid, accounts.userId)) {\n            Log.w(TAG, \"getAccountsAndVisibilityForPackage#Package not found \" + packageName);\n            return new LinkedHashMap<>();\n        }\n\n        Map<Account, Integer> result = new LinkedHashMap<>();\n        for (String accountType : accountTypes) {\n            synchronized (accounts.dbLock) {\n                synchronized (accounts.cacheLock) {\n                    final Account[] accountsOfType = accounts.accountCache.get(accountType);\n                    if (accountsOfType != null) {\n                        for (Account account : accountsOfType) {\n                            result.put(account,\n                                    resolveAccountVisibility(account, packageName, accounts));\n                        }\n                    }\n                }\n            }\n        }\n        return filterSharedAccounts(accounts, result, callingUid, packageName);\n    }\n\n    @Override\n    public Map<String, Integer> getPackagesAndVisibilityForAccount(Account account) {\n        Objects.requireNonNull(account, \"account cannot be null\");\n        int callingUid = Binder.getCallingUid();\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)\n                && !isSystemUid(callingUid)) {\n            String msg =\n                    String.format(\"uid %s cannot get secrets for account %s\", callingUid, account);\n            throw new SecurityException(msg);\n        }\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            synchronized (accounts.dbLock) {\n                synchronized (accounts.cacheLock) {\n                    return getPackagesAndVisibilityForAccountLocked(account, accounts);\n                }\n            }\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n\n    }\n\n    /**\n     * Returns Map with all package names and visibility values for given account.\n     * The method and returned map must be guarded by accounts.cacheLock\n     *\n     * @param account Account to get visibility values.\n     * @param accounts UserAccount that currently hosts the account and application\n     *\n     * @return Map with cache for package names to visibility.\n     */\n    private @NonNull Map<String, Integer> getPackagesAndVisibilityForAccountLocked(Account account,\n            UserAccounts accounts) {\n        Map<String, Integer> accountVisibility = accounts.visibilityCache.get(account);\n        if (accountVisibility == null) {\n            Log.d(TAG, \"Visibility was not initialized\");\n            accountVisibility = new HashMap<>();\n            accounts.visibilityCache.put(account, accountVisibility);\n            AccountManager.invalidateLocalAccountsDataCaches();\n        }\n        return accountVisibility;\n    }\n\n    @Override\n    public int getAccountVisibility(Account account, String packageName) {\n        Objects.requireNonNull(account, \"account cannot be null\");\n        Objects.requireNonNull(packageName, \"packageName cannot be null\");\n        int callingUid = Binder.getCallingUid();\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)\n            && !isSystemUid(callingUid)) {\n            String msg = String.format(\n                    \"uid %s cannot get secrets for accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            if (AccountManager.PACKAGE_NAME_KEY_LEGACY_VISIBLE.equals(packageName)) {\n                int visibility = getAccountVisibilityFromCache(account, packageName, accounts);\n                if (AccountManager.VISIBILITY_UNDEFINED != visibility) {\n                    return visibility;\n                } else {\n                   return AccountManager.VISIBILITY_USER_MANAGED_VISIBLE;\n                }\n            }\n            if (AccountManager.PACKAGE_NAME_KEY_LEGACY_NOT_VISIBLE.equals(packageName)) {\n                int visibility = getAccountVisibilityFromCache(account, packageName, accounts);\n                if (AccountManager.VISIBILITY_UNDEFINED != visibility) {\n                    return visibility;\n                } else {\n                   return AccountManager.VISIBILITY_USER_MANAGED_NOT_VISIBLE;\n                }\n            }\n            if (!canCallerAccessPackage(packageName, callingUid, accounts.userId)) {\n                return AccountManager.VISIBILITY_NOT_VISIBLE;\n            }\n            return resolveAccountVisibility(account, packageName, accounts);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    /**\n     * Method returns visibility for given account and package name.\n     *\n     * @param account The account to check visibility.\n     * @param packageName Package name to check visibility.\n     * @param accounts UserAccount that currently hosts the account and application\n     *\n     * @return Visibility value, AccountManager.VISIBILITY_UNDEFINED if no value was stored.\n     *\n     */\n    private int getAccountVisibilityFromCache(Account account, String packageName,\n            UserAccounts accounts) {\n        synchronized (accounts.cacheLock) {\n            Map<String, Integer> accountVisibility =\n                    getPackagesAndVisibilityForAccountLocked(account, accounts);\n            Integer visibility = accountVisibility.get(packageName);\n            return visibility != null ? visibility : AccountManager.VISIBILITY_UNDEFINED;\n        }\n    }\n\n    /**\n     * Method which handles default values for Account visibility.\n     *\n     * @param account The account to check visibility.\n     * @param packageName Package name to check visibility\n     * @param accounts UserAccount that currently hosts the account and application\n     *\n     * @return Visibility value, the method never returns AccountManager.VISIBILITY_UNDEFINED\n     *\n     */\n    private Integer resolveAccountVisibility(Account account, @NonNull String packageName,\n            UserAccounts accounts) {\n        Objects.requireNonNull(packageName, \"packageName cannot be null\");\n        int uid = -1;\n        try {\n            final long identityToken = clearCallingIdentity();\n            try {\n                uid = mPackageManager.getPackageUidAsUser(packageName, accounts.userId);\n            } finally {\n                restoreCallingIdentity(identityToken);\n            }\n        } catch (NameNotFoundException e) {\n            Log.w(TAG, \"resolveAccountVisibility#Package not found \" + e.getMessage());\n            return AccountManager.VISIBILITY_NOT_VISIBLE;\n        }\n\n        // System visibility can not be restricted.\n        if (UserHandle.isSameApp(uid, Process.SYSTEM_UID)) {\n            return AccountManager.VISIBILITY_VISIBLE;\n        }\n\n        int signatureCheckResult =\n                checkPackageSignature(account.type, uid, accounts.userId);\n\n        // Authenticator can not restrict visibility to itself.\n        if (signatureCheckResult == SIGNATURE_CHECK_UID_MATCH) {\n            return AccountManager.VISIBILITY_VISIBLE; // Authenticator can always see the account\n        }\n\n        // Return stored value if it was set.\n        int visibility = getAccountVisibilityFromCache(account, packageName, accounts);\n\n        if (AccountManager.VISIBILITY_UNDEFINED != visibility) {\n            return visibility;\n        }\n\n        boolean isPrivileged = isPermittedForPackage(packageName, accounts.userId,\n                Manifest.permission.GET_ACCOUNTS_PRIVILEGED);\n\n        // Device/Profile owner gets visibility by default.\n        if (isProfileOwner(uid)) {\n            return AccountManager.VISIBILITY_VISIBLE;\n        }\n\n        boolean preO = isPreOApplication(packageName);\n        if ((signatureCheckResult != SIGNATURE_CHECK_MISMATCH)\n                || (preO && checkGetAccountsPermission(packageName, accounts.userId))\n                || (checkReadContactsPermission(packageName, accounts.userId)\n                    && accountTypeManagesContacts(account.type, accounts.userId))\n                || isPrivileged) {\n            // Use legacy for preO apps with GET_ACCOUNTS permission or pre/postO with signature\n            // match.\n            visibility = getAccountVisibilityFromCache(account,\n                    AccountManager.PACKAGE_NAME_KEY_LEGACY_VISIBLE, accounts);\n            if (AccountManager.VISIBILITY_UNDEFINED == visibility) {\n                visibility = AccountManager.VISIBILITY_USER_MANAGED_VISIBLE;\n            }\n        } else {\n            visibility = getAccountVisibilityFromCache(account,\n                    AccountManager.PACKAGE_NAME_KEY_LEGACY_NOT_VISIBLE, accounts);\n            if (AccountManager.VISIBILITY_UNDEFINED == visibility) {\n                visibility = AccountManager.VISIBILITY_USER_MANAGED_NOT_VISIBLE;\n            }\n        }\n        return visibility;\n    }\n\n    /**\n     * Checks targetSdk for a package;\n     *\n     * @param packageName Package name\n     *\n     * @return True if package's target SDK is below {@link android.os.Build.VERSION_CODES#O}, or\n     *         undefined\n     */\n    private boolean isPreOApplication(String packageName) {\n        try {\n            final long identityToken = clearCallingIdentity();\n            ApplicationInfo applicationInfo;\n            try {\n                applicationInfo = mPackageManager.getApplicationInfo(packageName, 0);\n            } finally {\n                restoreCallingIdentity(identityToken);\n            }\n\n            if (applicationInfo != null) {\n                int version = applicationInfo.targetSdkVersion;\n                return version < android.os.Build.VERSION_CODES.O;\n            }\n            return true;\n        } catch (NameNotFoundException e) {\n            Log.w(TAG, \"isPreOApplication#Package not found \" + e.getMessage());\n            return true;\n        }\n    }\n\n    @Override\n    public boolean setAccountVisibility(Account account, String packageName, int newVisibility) {\n        Objects.requireNonNull(account, \"account cannot be null\");\n        Objects.requireNonNull(packageName, \"packageName cannot be null\");\n        int callingUid = Binder.getCallingUid();\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)\n            && !isSystemUid(callingUid)) {\n            String msg = String.format(\n                    \"uid %s cannot get secrets for accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return setAccountVisibility(account, packageName, newVisibility, true /* notify */,\n                    accounts, callingUid);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private boolean isVisible(int visibility) {\n        return visibility == AccountManager.VISIBILITY_VISIBLE ||\n            visibility == AccountManager.VISIBILITY_USER_MANAGED_VISIBLE;\n    }\n\n    /**\n     * Updates visibility for given account name and package.\n     *\n     * @param account Account to update visibility.\n     * @param packageName Package name for which visibility is updated.\n     * @param newVisibility New visibility calue\n     * @param notify if the flag is set applications will get notification about visibility change\n     * @param accounts UserAccount that currently hosts the account and application\n     * @param callingUid The caller's uid.\n     *\n     * @return True if account visibility was changed.\n     */\n    private boolean setAccountVisibility(Account account, String packageName, int newVisibility,\n            boolean notify, UserAccounts accounts, int callingUid) {\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                Map<String, Integer> packagesToVisibility;\n                List<String> accountRemovedReceivers;\n                if (notify) {\n                    if (isSpecialPackageKey(packageName)) {\n                        packagesToVisibility =\n                                getRequestingPackages(account, accounts);\n                        accountRemovedReceivers = getAccountRemovedReceivers(account, accounts);\n                    } else {\n                        if (!canCallerAccessPackage(packageName, callingUid, accounts.userId)) {\n                            return false; // package is not installed or not visible.\n                        }\n                        packagesToVisibility = new HashMap<>();\n                        packagesToVisibility.put(packageName,\n                                resolveAccountVisibility(account, packageName, accounts));\n                        accountRemovedReceivers = new ArrayList<>();\n                        if (shouldNotifyPackageOnAccountRemoval(account, packageName, accounts)) {\n                            accountRemovedReceivers.add(packageName);\n                        }\n                    }\n                } else {\n                    // Notifications will not be send - only used during add account.\n                    if (!isSpecialPackageKey(packageName)\n                            && !canCallerAccessPackage(packageName, callingUid, accounts.userId)) {\n                        // package is not installed and not meta value.\n                        return false;\n                    }\n                    packagesToVisibility = Collections.emptyMap();\n                    accountRemovedReceivers = Collections.emptyList();\n                }\n                if (notify) {\n                    Integer oldVisibility =\n                            accounts.accountsDb.findAccountVisibility(account, packageName);\n                    if (oldVisibility != null && oldVisibility == newVisibility) {\n                        // Database will not be updated - skip LOGIN_ACCOUNTS_CHANGED broadcast.\n                        notify = false;\n                    }\n                }\n\n                if (!updateAccountVisibilityLocked(account, packageName, newVisibility, accounts)) {\n                    return false;\n                }\n\n                if (notify) {\n                    Log.i(TAG, \"Notifying visibility changed for package=\" + packageName);\n                    for (Entry<String, Integer> packageToVisibility : packagesToVisibility\n                            .entrySet()) {\n                        int oldVisibility = packageToVisibility.getValue();\n                        int currentVisibility =\n                            resolveAccountVisibility(account, packageName, accounts);\n                        if (isVisible(oldVisibility) != isVisible(currentVisibility)) {\n                            notifyPackage(packageToVisibility.getKey(), accounts);\n                        }\n                    }\n                    for (String packageNameToNotify : accountRemovedReceivers) {\n                        int currentVisibility =\n                                resolveAccountVisibility(account, packageNameToNotify, accounts);\n                        if (isVisible(currentVisibility)) {\n                            continue;\n                        }\n                        sendAccountRemovedBroadcast(\n                                account,\n                                packageNameToNotify,\n                                accounts.userId,\n                                /*useCase=*/\"setAccountVisibility\");\n                    }\n                    sendAccountsChangedBroadcast(\n                            accounts.userId, account.type, /*useCase=*/\"setAccountVisibility\");\n                }\n                return true;\n            }\n        }\n    }\n\n    // Update account visibility in cache and database.\n    private boolean updateAccountVisibilityLocked(Account account, String packageName,\n            int newVisibility, UserAccounts accounts) {\n        final long accountId = accounts.accountsDb.findDeAccountId(account);\n        if (accountId < 0) {\n            return false;\n        }\n\n        final StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskWrites();\n        try {\n            if (!accounts.accountsDb.setAccountVisibility(accountId, packageName,\n                    newVisibility)) {\n                return false;\n            }\n        } finally {\n            StrictMode.setThreadPolicy(oldPolicy);\n        }\n        Map<String, Integer> accountVisibility =\n            getPackagesAndVisibilityForAccountLocked(account, accounts);\n        accountVisibility.put(packageName, newVisibility);\n        AccountManager.invalidateLocalAccountsDataCaches();\n        return true;\n    }\n\n    @Override\n    public void registerAccountListener(String[] accountTypes, String opPackageName) {\n        int callingUid = Binder.getCallingUid();\n        mAppOpsManager.checkPackage(callingUid, opPackageName);\n\n        int userId = UserHandle.getCallingUserId();\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            registerAccountListener(accountTypes, opPackageName, accounts);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private void registerAccountListener(String[] accountTypes, String opPackageName,\n            UserAccounts accounts) {\n        synchronized (accounts.mReceiversForType) {\n            if (accountTypes == null) {\n                // null for any type\n                accountTypes = new String[] {null};\n            }\n            for (String type : accountTypes) {\n                Map<String, Integer> receivers = accounts.mReceiversForType.get(type);\n                if (receivers == null) {\n                    receivers = new HashMap<>();\n                    accounts.mReceiversForType.put(type, receivers);\n                }\n                Integer cnt = receivers.get(opPackageName);\n                receivers.put(opPackageName, cnt != null ? cnt + 1 : 1);\n            }\n        }\n    }\n\n    @Override\n    public void unregisterAccountListener(String[] accountTypes, String opPackageName) {\n        int callingUid = Binder.getCallingUid();\n        mAppOpsManager.checkPackage(callingUid, opPackageName);\n        int userId = UserHandle.getCallingUserId();\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            unregisterAccountListener(accountTypes, opPackageName, accounts);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private void unregisterAccountListener(String[] accountTypes, String opPackageName,\n            UserAccounts accounts) {\n        synchronized (accounts.mReceiversForType) {\n            if (accountTypes == null) {\n                // null for any type\n                accountTypes = new String[] {null};\n            }\n            for (String type : accountTypes) {\n                Map<String, Integer> receivers = accounts.mReceiversForType.get(type);\n                if (receivers == null || receivers.get(opPackageName) == null) {\n                    throw new IllegalArgumentException(\"attempt to unregister wrong receiver\");\n                }\n                Integer cnt = receivers.get(opPackageName);\n                if (cnt == 1) {\n                    receivers.remove(opPackageName);\n                } else {\n                    receivers.put(opPackageName, cnt - 1);\n                }\n            }\n        }\n    }\n\n    // Send notification to all packages which can potentially see the account\n    private void sendNotificationAccountUpdated(Account account, UserAccounts accounts) {\n        Map<String, Integer> packagesToVisibility = getRequestingPackages(account, accounts);\n\n        for (Entry<String, Integer> packageToVisibility : packagesToVisibility.entrySet()) {\n            if ((packageToVisibility.getValue() != AccountManager.VISIBILITY_NOT_VISIBLE)\n                    && (packageToVisibility.getValue()\n                        != AccountManager.VISIBILITY_USER_MANAGED_NOT_VISIBLE)) {\n                notifyPackage(packageToVisibility.getKey(), accounts);\n            }\n        }\n    }\n\n    /**\n     * Sends a direct intent to a package, notifying it of account visibility change.\n     *\n     * @param packageName to send Account to\n     * @param accounts UserAccount that currently hosts the account\n     */\n    private void notifyPackage(String packageName, UserAccounts accounts) {\n        Log.i(TAG, \"notifying package=\" + packageName + \" for userId=\" + accounts.userId\n                +\", sending broadcast of \" + AccountManager.ACTION_VISIBLE_ACCOUNTS_CHANGED);\n        Intent intent = new Intent(AccountManager.ACTION_VISIBLE_ACCOUNTS_CHANGED);\n        intent.setPackage(packageName);\n        intent.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);\n        mContext.sendBroadcastAsUser(intent, new UserHandle(accounts.userId));\n    }\n\n    // Returns a map from package name to visibility, for packages subscribed\n    // to notifications about any account type, or type of provided account\n    // account type or all types.\n    private Map<String, Integer> getRequestingPackages(Account account, UserAccounts accounts) {\n        Set<String> packages = new HashSet<>();\n        synchronized (accounts.mReceiversForType) {\n            for (String type : new String[] {account.type, null}) {\n                Map<String, Integer> receivers = accounts.mReceiversForType.get(type);\n                if (receivers != null) {\n                    packages.addAll(receivers.keySet());\n                }\n            }\n        }\n        Map<String, Integer> result = new HashMap<>();\n        for (String packageName : packages) {\n            result.put(packageName, resolveAccountVisibility(account, packageName, accounts));\n        }\n        return result;\n    }\n\n    // Returns a list of packages listening to ACTION_ACCOUNT_REMOVED able to see the account.\n    private List<String> getAccountRemovedReceivers(Account account, UserAccounts accounts) {\n        Intent intent = new Intent(AccountManager.ACTION_ACCOUNT_REMOVED);\n        intent.setFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);\n        List<ResolveInfo> receivers =\n            mPackageManager.queryBroadcastReceiversAsUser(intent, 0, accounts.userId);\n        List<String> result = new ArrayList<>();\n        if (receivers == null) {\n            return result;\n        }\n        for (ResolveInfo resolveInfo: receivers) {\n            String packageName = resolveInfo.activityInfo.applicationInfo.packageName;\n            int visibility = resolveAccountVisibility(account, packageName, accounts);\n            if (visibility == AccountManager.VISIBILITY_VISIBLE\n                || visibility == AccountManager.VISIBILITY_USER_MANAGED_VISIBLE) {\n                result.add(packageName);\n            }\n        }\n        return result;\n    }\n\n    // Returns true if given package is listening to ACTION_ACCOUNT_REMOVED and can see the account.\n    private boolean shouldNotifyPackageOnAccountRemoval(Account account,\n            String packageName, UserAccounts accounts) {\n        int visibility = resolveAccountVisibility(account, packageName, accounts);\n        if (visibility != AccountManager.VISIBILITY_VISIBLE\n            && visibility != AccountManager.VISIBILITY_USER_MANAGED_VISIBLE) {\n            return false;\n        }\n\n        Intent intent = new Intent(AccountManager.ACTION_ACCOUNT_REMOVED);\n        intent.setFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);\n        intent.setPackage(packageName);\n        List<ResolveInfo> receivers =\n            mPackageManager.queryBroadcastReceiversAsUser(intent, 0, accounts.userId);\n        return (receivers != null && receivers.size() > 0);\n    }\n\n    /**\n     * Returns true if packageName is one of special values.\n     */\n    private boolean isSpecialPackageKey(String packageName) {\n        return (AccountManager.PACKAGE_NAME_KEY_LEGACY_VISIBLE.equals(packageName)\n                || AccountManager.PACKAGE_NAME_KEY_LEGACY_NOT_VISIBLE.equals(packageName));\n    }\n\n    private void sendAccountsChangedBroadcast(\n            int userId, String accountType, @NonNull String useCase) {\n        Objects.requireNonNull(useCase, \"useCase can't be null\");\n        Log.i(TAG, \"the accountType= \" + (accountType == null ? \"\" : accountType)\n                + \" changed with useCase=\" + useCase + \" for userId=\" + userId\n                + \", sending broadcast of \" + ACCOUNTS_CHANGED_INTENT.getAction());\n        mContext.sendBroadcastAsUser(ACCOUNTS_CHANGED_INTENT, new UserHandle(userId),\n                null /* receiverPermission */, ACCOUNTS_CHANGED_OPTIONS);\n    }\n\n    private void sendAccountRemovedBroadcast(\n            Account account, String packageName, int userId, @NonNull String useCase) {\n        Objects.requireNonNull(useCase, \"useCase can't be null\");\n        Log.i(TAG, \"the account with type=\" + account.type + \" removed while useCase=\"\n                + useCase + \" for userId=\" + userId + \", sending broadcast of \"\n                + AccountManager.ACTION_ACCOUNT_REMOVED);\n        Intent intent = new Intent(AccountManager.ACTION_ACCOUNT_REMOVED);\n        intent.setFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);\n        intent.setPackage(packageName);\n        intent.putExtra(AccountManager.KEY_ACCOUNT_NAME, account.name);\n        intent.putExtra(AccountManager.KEY_ACCOUNT_TYPE, account.type);\n        mContext.sendBroadcastAsUser(intent, new UserHandle(userId));\n    }\n\n    @Override\n    public boolean onTransact(int code, Parcel data, Parcel reply, int flags)\n            throws RemoteException {\n        try {\n            return super.onTransact(code, data, reply, flags);\n        } catch (RuntimeException e) {\n            // The account manager only throws security exceptions, so let's\n            // log all others.\n            if (!(e instanceof SecurityException || e instanceof IllegalArgumentException)) {\n                Slog.wtf(TAG, \"Account Manager Crash\", e);\n            }\n            throw e;\n        }\n    }\n\n    private UserManager getUserManager() {\n        if (mUserManager == null) {\n            mUserManager = UserManager.get(mContext);\n        }\n        return mUserManager;\n    }\n\n    /**\n     * Validate internal set of accounts against installed authenticators for\n     * given user. Clears cached authenticators before validating.\n     */\n    public void validateAccounts(int userId) {\n        final UserAccounts accounts = getUserAccounts(userId);\n        // Invalidate user-specific cache to make sure we catch any\n        // removed authenticators.\n        validateAccountsInternal(accounts, true /* invalidateAuthenticatorCache */);\n    }\n\n    /**\n     * Validate internal set of accounts against installed authenticators for\n     * given user. Clear cached authenticators before validating when requested.\n     */\n    private void validateAccountsInternal(\n            UserAccounts accounts, boolean invalidateAuthenticatorCache) {\n        if (Log.isLoggable(TAG, Log.DEBUG)) {\n            Log.d(TAG, \"validateAccountsInternal \" + accounts.userId\n                    + \" isCeDatabaseAttached=\" + accounts.accountsDb.isCeDatabaseAttached()\n                    + \" userLocked=\" + mLocalUnlockedUsers.get(accounts.userId));\n        }\n\n        if (invalidateAuthenticatorCache) {\n            mAuthenticatorCache.invalidateCache(accounts.userId);\n        }\n\n        final HashMap<String, Integer> knownAuth = getAuthenticatorTypeAndUIDForUser(\n                mAuthenticatorCache, accounts.userId);\n        boolean userUnlocked = isLocalUnlockedUser(accounts.userId);\n\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                boolean accountDeleted = false;\n\n                // Get a map of stored authenticator types to UID\n                final AccountsDb accountsDb = accounts.accountsDb;\n                Map<String, Integer> metaAuthUid = accountsDb.findMetaAuthUid();\n                // Create a list of authenticator type whose previous uid no longer exists\n                HashSet<String> obsoleteAuthType = Sets.newHashSet();\n                SparseBooleanArray knownUids = null;\n                for (Entry<String, Integer> authToUidEntry : metaAuthUid.entrySet()) {\n                    String type = authToUidEntry.getKey();\n                    int uid = authToUidEntry.getValue();\n                    Integer knownUid = knownAuth.get(type);\n                    if (knownUid != null && uid == knownUid) {\n                        // Remove it from the knownAuth list if it's unchanged.\n                        knownAuth.remove(type);\n                    } else {\n                    /*\n                     * The authenticator is presently not cached and should only be triggered\n                     * when we think an authenticator has been removed (or is being updated).\n                     * But we still want to check if any data with the associated uid is\n                     * around. This is an (imperfect) signal that the package may be updating.\n                     *\n                     * A side effect of this is that an authenticator sharing a uid with\n                     * multiple apps won't get its credentials wiped as long as some app with\n                     * that uid is still on the device. But I suspect that this is a rare case.\n                     * And it isn't clear to me how an attacker could really exploit that\n                     * feature.\n                     *\n                     * The upshot is that we don't have to worry about accounts getting\n                     * uninstalled while the authenticator's package is being updated.\n                     *\n                     */\n                        if (knownUids == null) {\n                            knownUids = getUidsOfInstalledOrUpdatedPackagesAsUser(accounts.userId);\n                        }\n                        if (!knownUids.get(uid)) {\n                            // The authenticator is not presently available to the cache. And the\n                            // package no longer has a data directory (so we surmise it isn't\n                            // updating). So purge its data from the account databases.\n                            obsoleteAuthType.add(type);\n                            // And delete it from the TABLE_META\n                            accountsDb.deleteMetaByAuthTypeAndUid(type, uid);\n                        } else if (knownUid != null && knownUid != uid) {\n                            Slog.w(TAG, \"authenticator no longer exist for type \" + type);\n                            obsoleteAuthType.add(type);\n                            accountsDb.deleteMetaByAuthTypeAndUid(type, uid);\n                        }\n                    }\n                }\n\n                // Add the newly registered authenticator to TABLE_META. If old authenticators have\n                // been re-enabled (after being updated for example), then we just overwrite the old\n                // values.\n                for (Entry<String, Integer> entry : knownAuth.entrySet()) {\n                    accountsDb.insertOrReplaceMetaAuthTypeAndUid(entry.getKey(), entry.getValue());\n                }\n\n                final Map<Long, Account> accountsMap = accountsDb.findAllDeAccounts();\n                try {\n                    accounts.accountCache.clear();\n                    final HashMap<String, ArrayList<String>> accountNamesByType\n                            = new LinkedHashMap<>();\n                    for (Entry<Long, Account> accountEntry : accountsMap.entrySet()) {\n                        final long accountId = accountEntry.getKey();\n                        final Account account = accountEntry.getValue();\n                        if (obsoleteAuthType.contains(account.type)) {\n                            Slog.w(TAG, \"deleting account \" + account.toSafeString()\n                                    + \" because type \" + account.type\n                                    + \"'s registered authenticator no longer exist.\");\n                            Map<String, Integer> packagesToVisibility =\n                                    getRequestingPackages(account, accounts);\n                            List<String> accountRemovedReceivers =\n                                getAccountRemovedReceivers(account, accounts);\n                            accountsDb.beginTransaction();\n                            try {\n                                accountsDb.deleteDeAccount(accountId);\n                                // Also delete from CE table if user is unlocked; if user is\n                                // currently locked the account will be removed later by\n                                // syncDeCeAccountsLocked\n                                if (userUnlocked) {\n                                    accountsDb.deleteCeAccount(accountId);\n                                }\n                                accountsDb.setTransactionSuccessful();\n                            } finally {\n                                accountsDb.endTransaction();\n                            }\n                            accountDeleted = true;\n                            Log.i(TAG, \"validateAccountsInternal#Deleted UserId=\"\n                                    + accounts.userId + \", AccountId=\" + accountId);\n\n                            logRecord(AccountsDb.DEBUG_ACTION_AUTHENTICATOR_REMOVE,\n                                    AccountsDb.TABLE_ACCOUNTS, accountId, accounts);\n\n                            accounts.userDataCache.remove(account);\n                            accounts.authTokenCache.remove(account);\n                            accounts.accountTokenCaches.remove(account);\n                            accounts.visibilityCache.remove(account);\n\n                            for (Entry<String, Integer> packageToVisibility :\n                                    packagesToVisibility.entrySet()) {\n                                if (isVisible(packageToVisibility.getValue())) {\n                                    notifyPackage(packageToVisibility.getKey(), accounts);\n                                }\n                            }\n                            for (String packageName : accountRemovedReceivers) {\n                                sendAccountRemovedBroadcast(\n                                        account,\n                                        packageName,\n                                        accounts.userId,\n                                        /*useCase=*/\"validateAccounts\");\n                            }\n                        } else {\n                            ArrayList<String> accountNames = accountNamesByType.get(account.type);\n                            if (accountNames == null) {\n                                accountNames = new ArrayList<>();\n                                accountNamesByType.put(account.type, accountNames);\n                            }\n                            accountNames.add(account.name);\n                        }\n                    }\n                    for (Map.Entry<String, ArrayList<String>> cur : accountNamesByType.entrySet()) {\n                        final String accountType = cur.getKey();\n                        final ArrayList<String> accountNames = cur.getValue();\n                        final Account[] accountsForType = new Account[accountNames.size()];\n                        for (int i = 0; i < accountsForType.length; i++) {\n                            accountsForType[i] = new Account(accountNames.get(i), accountType,\n                                    UUID.randomUUID().toString());\n                        }\n                        accounts.accountCache.put(accountType, accountsForType);\n                    }\n                    accounts.visibilityCache.putAll(accountsDb.findAllVisibilityValues());\n                    AccountManager.invalidateLocalAccountsDataCaches();\n                } finally {\n                    if (accountDeleted) {\n                        sendAccountsChangedBroadcast(\n                                accounts.userId,\n                                /*accountType=*/\"ambiguous\",\n                                /*useCase=*/\"validateAccounts\");\n                    }\n                }\n            }\n        }\n    }\n\n    private SparseBooleanArray getUidsOfInstalledOrUpdatedPackagesAsUser(int userId) {\n        // Get the UIDs of all apps that might have data on the device. We want\n        // to preserve user data if the app might otherwise be storing data.\n        List<PackageInfo> pkgsWithData =\n                mPackageManager.getInstalledPackagesAsUser(\n                        PackageManager.MATCH_UNINSTALLED_PACKAGES, userId);\n        SparseBooleanArray knownUids = new SparseBooleanArray(pkgsWithData.size());\n        for (PackageInfo pkgInfo : pkgsWithData) {\n            if (pkgInfo.applicationInfo != null\n                    && (pkgInfo.applicationInfo.flags & ApplicationInfo.FLAG_INSTALLED) != 0) {\n                knownUids.put(pkgInfo.applicationInfo.uid, true);\n            }\n        }\n        return knownUids;\n    }\n\n    static HashMap<String, Integer> getAuthenticatorTypeAndUIDForUser(\n            Context context,\n            int userId) {\n        AccountAuthenticatorCache authCache = new AccountAuthenticatorCache(context);\n        return getAuthenticatorTypeAndUIDForUser(authCache, userId);\n    }\n\n    private static HashMap<String, Integer> getAuthenticatorTypeAndUIDForUser(\n            IAccountAuthenticatorCache authCache,\n            int userId) {\n        HashMap<String, Integer> knownAuth = new LinkedHashMap<>();\n        for (RegisteredServicesCache.ServiceInfo<AuthenticatorDescription> service : authCache\n                .getAllServices(userId)) {\n            knownAuth.put(service.type.type, service.uid);\n        }\n        return knownAuth;\n    }\n\n    private UserAccounts getUserAccountsForCaller() {\n        return getUserAccounts(UserHandle.getCallingUserId());\n    }\n\n    protected UserAccounts getUserAccounts(int userId) {\n        try {\n            return getUserAccountsNotChecked(userId);\n        } catch (RuntimeException e) {\n            if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE)) {\n                // Let it go...\n                throw e;\n            }\n            // User accounts database is corrupted, we must wipe out the whole user, otherwise the\n            // system will crash indefinitely\n            Slog.wtf(TAG, \"Removing user \" + userId + \" due to exception (\" + e + \") reading its \"\n                    + \"account database\");\n            if (userId == ActivityManager.getCurrentUser() && userId != UserHandle.USER_SYSTEM) {\n                Slog.i(TAG, \"Switching to system user first\");\n                try {\n                    ActivityManager.getService().switchUser(UserHandle.USER_SYSTEM);\n                } catch (RemoteException re) {\n                    Slog.e(TAG, \"Could not switch to \" + UserHandle.USER_SYSTEM + \": \" + re);\n                }\n            }\n            if (!getUserManager().removeUserEvenWhenDisallowed(userId)) {\n                Slog.e(TAG, \"could not remove user \" + userId);\n            }\n            throw e;\n        }\n    }\n\n    private UserAccounts getUserAccountsNotChecked(int userId) {\n        synchronized (mUsers) {\n            UserAccounts accounts = mUsers.get(userId);\n            boolean validateAccounts = false;\n            if (accounts == null) {\n                File preNDbFile = new File(mInjector.getPreNDatabaseName(userId));\n                File deDbFile = new File(mInjector.getDeDatabaseName(userId));\n                accounts = new UserAccounts(mContext, userId, preNDbFile, deDbFile);\n                mUsers.append(userId, accounts);\n                purgeOldGrants(accounts);\n                AccountManager.invalidateLocalAccountsDataCaches();\n                validateAccounts = true;\n            }\n            // open CE database if necessary\n            if (!accounts.accountsDb.isCeDatabaseAttached() && mLocalUnlockedUsers.get(userId)) {\n                Log.i(TAG, \"User \" + userId + \" is unlocked - opening CE database\");\n                synchronized (accounts.dbLock) {\n                    synchronized (accounts.cacheLock) {\n                        File ceDatabaseFile = new File(mInjector.getCeDatabaseName(userId));\n                        accounts.accountsDb.attachCeDatabase(ceDatabaseFile);\n                    }\n                }\n                syncDeCeAccountsLocked(accounts);\n            }\n            if (validateAccounts) {\n                validateAccountsInternal(accounts, true /* invalidateAuthenticatorCache */);\n            }\n            return accounts;\n        }\n    }\n\n    private void syncDeCeAccountsLocked(UserAccounts accounts) {\n        Preconditions.checkState(Thread.holdsLock(mUsers), \"mUsers lock must be held\");\n        List<Account> accountsToRemove = accounts.accountsDb.findCeAccountsNotInDe();\n        if (!accountsToRemove.isEmpty()) {\n            Slog.i(TAG, accountsToRemove.size()\n                    + \" accounts were previously deleted while user \"\n                    + accounts.userId + \" was locked. Removing accounts from CE tables\");\n            logRecord(accounts, AccountsDb.DEBUG_ACTION_SYNC_DE_CE_ACCOUNTS,\n                    AccountsDb.TABLE_ACCOUNTS);\n\n            for (Account account : accountsToRemove) {\n                removeAccountInternal(accounts, account, Process.SYSTEM_UID);\n            }\n        }\n    }\n\n    private void purgeOldGrantsAll() {\n        synchronized (mUsers) {\n            for (int i = 0; i < mUsers.size(); i++) {\n                purgeOldGrants(mUsers.valueAt(i));\n            }\n        }\n    }\n\n    private void purgeOldGrants(UserAccounts accounts) {\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                List<Integer> uids;\n                try {\n                    uids = accounts.accountsDb.findAllUidGrants();\n                } catch (SQLiteException e) {\n                    Log.w(TAG, \"Could not delete grants for user = \" + accounts.userId, e);\n                    return;\n                }\n                for (int uid : uids) {\n                    final boolean packageExists = mPackageManager.getPackagesForUid(uid) != null;\n                    if (packageExists) {\n                        continue;\n                    }\n                    Log.d(TAG, \"deleting grants for UID \" + uid\n                            + \" because its package is no longer installed\");\n                    accounts.accountsDb.deleteGrantsByUid(uid);\n                }\n            }\n        }\n    }\n\n    private void removeVisibilityValuesForPackage(String packageName) {\n        if (isSpecialPackageKey(packageName)) {\n            return;\n        }\n        synchronized (mUsers) {\n            int numberOfUsers = mUsers.size();\n            for (int i = 0; i < numberOfUsers; i++) {\n                UserAccounts accounts = mUsers.valueAt(i);\n                try {\n                    mPackageManager.getPackageUidAsUser(packageName, accounts.userId);\n                } catch (NameNotFoundException e) {\n                    // package does not exist - remove visibility values\n                    try {\n                        accounts.accountsDb.deleteAccountVisibilityForPackage(packageName);\n                    } catch (SQLiteCantOpenDatabaseException sqlException) {\n                        Log.w(TAG, \"Could not delete account visibility for user = \"\n                                + accounts.userId, sqlException);\n                        continue;\n                    }\n                    synchronized (accounts.dbLock) {\n                        synchronized (accounts.cacheLock) {\n                            for (Account account : accounts.visibilityCache.keySet()) {\n                                Map<String, Integer> accountVisibility =\n                                        getPackagesAndVisibilityForAccountLocked(account, accounts);\n                                accountVisibility.remove(packageName);\n                            }\n                            AccountManager.invalidateLocalAccountsDataCaches();\n                        }\n                    }\n              }\n          }\n        }\n    }\n\n    private void purgeUserData(int userId) {\n        UserAccounts accounts;\n        synchronized (mUsers) {\n            accounts = mUsers.get(userId);\n            mUsers.remove(userId);\n            mLocalUnlockedUsers.delete(userId);\n            AccountManager.invalidateLocalAccountsDataCaches();\n        }\n        if (accounts != null) {\n            synchronized (accounts.dbLock) {\n                synchronized (accounts.cacheLock) {\n                    accounts.accountsDb.closeDebugStatement();\n                    accounts.accountsDb.close();\n                }\n            }\n        }\n    }\n\n    @VisibleForTesting\n    void onUserUnlocked(Intent intent) {\n        onUnlockUser(intent.getIntExtra(Intent.EXTRA_USER_HANDLE, -1));\n    }\n\n    void onUnlockUser(int userId) {\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"onUserUnlocked \" + userId);\n        }\n        synchronized (mUsers) {\n            mLocalUnlockedUsers.put(userId, true);\n        }\n        if (userId < 1) return;\n        mHandler.post(() -> syncSharedAccounts(userId));\n    }\n\n    private void syncSharedAccounts(int userId) {\n        // Check if there's a shared account that needs to be created as an account\n        Account[] sharedAccounts = getSharedAccountsAsUser(userId);\n        if (sharedAccounts == null || sharedAccounts.length == 0) return;\n        Account[] accounts = getAccountsAsUser(null, userId, mContext.getOpPackageName());\n        int parentUserId = UserHandle.USER_SYSTEM;\n        for (Account sa : sharedAccounts) {\n            if (ArrayUtils.contains(accounts, sa)) continue;\n            // Account doesn't exist. Copy it now.\n            copyAccountToUser(null /*no response*/, sa, parentUserId, userId);\n        }\n    }\n\n    @Override\n    public void onServiceChanged(AuthenticatorDescription desc, int userId, boolean removed) {\n        UserInfo user = getUserManager().getUserInfo(userId);\n        if (user == null) {\n            Log.w(TAG, \"onServiceChanged: ignore removed user \" + userId);\n            return;\n        }\n        validateAccountsInternal(getUserAccounts(userId), false /* invalidateAuthenticatorCache */);\n    }\n\n    @Override\n    public String getPassword(Account account) {\n        int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"getPassword: \" + account\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        if (account == null) throw new IllegalArgumentException(\"account is null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot get secrets for accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return readPasswordInternal(accounts, account);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private String readPasswordInternal(UserAccounts accounts, Account account) {\n        if (account == null) {\n            return null;\n        }\n        if (!isLocalUnlockedUser(accounts.userId)) {\n            Log.w(TAG, \"Password is not available - user \" + accounts.userId + \" data is locked\");\n            return null;\n        }\n\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                return accounts.accountsDb\n                        .findAccountPasswordByNameAndType(account.name, account.type);\n            }\n        }\n    }\n\n    @Override\n    public String getPreviousName(Account account) {\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"getPreviousName: \" + account\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        int userId = UserHandle.getCallingUserId();\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return readPreviousNameInternal(accounts, account);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private String readPreviousNameInternal(UserAccounts accounts, Account account) {\n        if  (account == null) {\n            return null;\n        }\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                AtomicReference<String> previousNameRef = accounts.previousNameCache.get(account);\n                if (previousNameRef == null) {\n                    String previousName = accounts.accountsDb.findDeAccountPreviousName(account);\n                    previousNameRef = new AtomicReference<>(previousName);\n                    accounts.previousNameCache.put(account, previousNameRef);\n                    return previousName;\n                } else {\n                    return previousNameRef.get();\n                }\n            }\n        }\n    }\n\n    @Override\n    public String getUserData(Account account, String key) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            String msg = String.format(\"getUserData( account: %s, key: %s, callerUid: %s, pid: %s\",\n                    account, key, callingUid, Binder.getCallingPid());\n            Log.v(TAG, msg);\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        Objects.requireNonNull(key, \"key cannot be null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot get user data for accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        if (!isLocalUnlockedUser(userId)) {\n            Log.w(TAG, \"User \" + userId + \" data is locked. callingUid \" + callingUid);\n            return null;\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            if (!accountExistsCache(accounts, account)) {\n                return null;\n            }\n            return readUserDataInternal(accounts, account, key);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public AuthenticatorDescription[] getAuthenticatorTypes(int userId) {\n        int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"getAuthenticatorTypes: \"\n                    + \"for user id \" + userId\n                    + \" caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        // Only allow the system process to read accounts of other users\n        if (isCrossUser(callingUid, userId)) {\n            throw new SecurityException(\n                    String.format(\n                            \"User %s tying to get authenticator types for %s\" ,\n                            UserHandle.getCallingUserId(),\n                            userId));\n        }\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            return getAuthenticatorTypesInternal(userId, callingUid);\n\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    /**\n     * Should only be called inside of a clearCallingIdentity block.\n     */\n    private AuthenticatorDescription[] getAuthenticatorTypesInternal(int userId, int callingUid) {\n        mAuthenticatorCache.updateServices(userId);\n        Collection<AccountAuthenticatorCache.ServiceInfo<AuthenticatorDescription>>\n                authenticatorCollection = mAuthenticatorCache.getAllServices(userId);\n        final List<AuthenticatorDescription> types =\n                new ArrayList<>(authenticatorCollection.size());\n        for (AccountAuthenticatorCache.ServiceInfo<AuthenticatorDescription> authenticator\n                : authenticatorCollection) {\n            if (canCallerAccessPackage(authenticator.type.packageName, callingUid, userId)) {\n                types.add(authenticator.type);\n            }\n        }\n        return types.toArray(new AuthenticatorDescription[types.size()]);\n    }\n\n    private boolean isCrossUser(int callingUid, int userId) {\n        return (userId != UserHandle.getCallingUserId()\n                && callingUid != Process.SYSTEM_UID\n                && mContext.checkCallingOrSelfPermission(\n                        android.Manifest.permission.INTERACT_ACROSS_USERS_FULL)\n                                != PackageManager.PERMISSION_GRANTED);\n    }\n\n    @Override\n    public boolean addAccountExplicitly(\n            Account account, String password, Bundle extras, String opPackageName) {\n        return addAccountExplicitlyWithVisibility(\n                account, password, extras, /* packageToVisibility= */ null, opPackageName);\n    }\n\n    @Override\n    public void copyAccountToUser(final IAccountManagerResponse response, final Account account,\n            final int userFrom, int userTo) {\n        int callingUid = Binder.getCallingUid();\n        if (isCrossUser(callingUid, UserHandle.USER_ALL)) {\n            throw new SecurityException(\"Calling copyAccountToUser requires \"\n                    + android.Manifest.permission.INTERACT_ACROSS_USERS_FULL);\n        }\n        final UserAccounts fromAccounts = getUserAccounts(userFrom);\n        final UserAccounts toAccounts = getUserAccounts(userTo);\n        if (fromAccounts == null || toAccounts == null) {\n            if (response != null) {\n                Bundle result = new Bundle();\n                result.putBoolean(AccountManager.KEY_BOOLEAN_RESULT, false);\n                try {\n                    response.onResult(result);\n                } catch (RemoteException e) {\n                    Slog.w(TAG, \"Failed to report error back to the client.\" + e);\n                }\n            }\n            return;\n        }\n\n        Slog.d(TAG, \"Copying account \" + account.toSafeString()\n                + \" from user \" + userFrom + \" to user \" + userTo);\n        final long identityToken = clearCallingIdentity();\n        try {\n            new Session(fromAccounts, response, account.type, false,\n                    false /* stripAuthTokenFromResult */, account.name,\n                    false /* authDetailsRequired */) {\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now) + \", getAccountCredentialsForClone\"\n                            + \", \" + account.type;\n                }\n\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.getAccountCredentialsForCloning(this, account);\n                }\n\n                @Override\n                public void onResult(Bundle result) {\n                    Bundle.setDefusable(result, true);\n                    if (result != null\n                            && result.getBoolean(AccountManager.KEY_BOOLEAN_RESULT, false)) {\n                        // Create a Session for the target user and pass in the bundle\n                        completeCloningAccount(response, result, account, toAccounts, userFrom);\n                    } else {\n                        super.onResult(result);\n                    }\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public boolean accountAuthenticated(final Account account) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            String msg = String.format(\n                    \"accountAuthenticated( account: %s, callerUid: %s)\",\n                    account,\n                    callingUid);\n            Log.v(TAG, msg);\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot notify authentication for accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n\n        if (!canUserModifyAccounts(userId, callingUid) ||\n                !canUserModifyAccountsForType(userId, account.type, callingUid)) {\n            return false;\n        }\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return updateLastAuthenticatedTime(account);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private boolean updateLastAuthenticatedTime(Account account) {\n        final UserAccounts accounts = getUserAccountsForCaller();\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                return accounts.accountsDb.updateAccountLastAuthenticatedTime(account);\n            }\n        }\n    }\n\n    private void completeCloningAccount(IAccountManagerResponse response,\n            final Bundle accountCredentials, final Account account, final UserAccounts targetUser,\n            final int parentUserId){\n        Bundle.setDefusable(accountCredentials, true);\n        final long id = clearCallingIdentity();\n        try {\n            new Session(targetUser, response, account.type, false,\n                    false /* stripAuthTokenFromResult */, account.name,\n                    false /* authDetailsRequired */) {\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now) + \", getAccountCredentialsForClone\"\n                            + \", \" + account.type;\n                }\n\n                @Override\n                public void run() throws RemoteException {\n                    // Confirm that the owner's account still exists before this step.\n                    for (Account acc : getAccounts(parentUserId, mContext.getOpPackageName())) {\n                        if (acc.equals(account)) {\n                            mAuthenticator.addAccountFromCredentials(\n                                    this, account, accountCredentials);\n                            break;\n                        }\n                    }\n                }\n\n                @Override\n                public void onResult(Bundle result) {\n                    Bundle.setDefusable(result, true);\n                    // TODO: Anything to do if if succedded?\n                    // TODO: If it failed: Show error notification? Should we remove the shadow\n                    // account to avoid retries?\n                    // TODO: what we do with the visibility?\n\n                    super.onResult(result);\n                }\n\n                @Override\n                public void onError(int errorCode, String errorMessage) {\n                    super.onError(errorCode,  errorMessage);\n                    // TODO: Show error notification to user\n                    // TODO: Should we remove the shadow account so that it doesn't keep trying?\n                }\n\n            }.bind();\n        } finally {\n            restoreCallingIdentity(id);\n        }\n    }\n\n    private boolean addAccountInternal(UserAccounts accounts, Account account, String password,\n            Bundle extras, int callingUid, Map<String, Integer> packageToVisibility,\n            String opPackageName) {\n        Bundle.setDefusable(extras, true);\n        if (account == null) {\n            return false;\n        }\n        if (account.name != null && account.name.length() > 200) {\n            Log.w(TAG, \"Account cannot be added - Name longer than 200 chars\");\n            return false;\n        }\n        if (account.type != null && account.type.length() > 200) {\n            Log.w(TAG, \"Account cannot be added - Name longer than 200 chars\");\n            return false;\n        }\n        if (!isLocalUnlockedUser(accounts.userId)) {\n            Log.w(TAG, \"Account \" + account.toSafeString() + \" cannot be added - user \"\n                    + accounts.userId + \" is locked. callingUid=\" + callingUid);\n            return false;\n        }\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                accounts.accountsDb.beginTransaction();\n                try {\n                    if (accounts.accountsDb.findCeAccountId(account) >= 0) {\n                        Log.w(TAG, \"insertAccountIntoDatabase: \" + account.toSafeString()\n                                + \", skipping since the account already exists\");\n                        return false;\n                    }\n                    if (accounts.accountsDb.findAllDeAccounts().size() > 100) {\n                        Log.w(TAG, \"insertAccountIntoDatabase: \" + account.toSafeString()\n                                + \", skipping since more than 100 accounts on device exist\");\n                        return false;\n                    }\n                    long accountId = accounts.accountsDb.insertCeAccount(account, password);\n                    if (accountId < 0) {\n                        Log.w(TAG, \"insertAccountIntoDatabase: \" + account.toSafeString()\n                                + \", skipping the DB insert failed\");\n                        return false;\n                    }\n                    // Insert into DE table\n                    if (accounts.accountsDb.insertDeAccount(account, accountId) < 0) {\n                        Log.w(TAG, \"insertAccountIntoDatabase: \" + account.toSafeString()\n                                + \", skipping the DB insert failed\");\n                        return false;\n                    }\n                    if (extras != null) {\n                        for (String key : extras.keySet()) {\n                            final String value = extras.getString(key);\n                            if (accounts.accountsDb.insertExtra(accountId, key, value) < 0) {\n                                Log.w(TAG, \"insertAccountIntoDatabase: \"\n                                        + account.toSafeString()\n                                        + \", skipping since insertExtra failed for key \" + key);\n                                return false;\n                            } else {\n                                AccountManager.invalidateLocalAccountUserDataCaches();\n                            }\n                        }\n                    }\n\n                    if (packageToVisibility != null) {\n                        for (Entry<String, Integer> entry : packageToVisibility.entrySet()) {\n                            setAccountVisibility(account, entry.getKey() /* package */,\n                                    entry.getValue() /* visibility */, false /* notify */,\n                                    accounts, callingUid);\n                        }\n                    }\n                    accounts.accountsDb.setTransactionSuccessful();\n\n                    logRecord(AccountsDb.DEBUG_ACTION_ACCOUNT_ADD, AccountsDb.TABLE_ACCOUNTS,\n                            accountId,\n                            accounts, callingUid);\n\n                    insertAccountIntoCacheLocked(accounts, account);\n                } finally {\n                    accounts.accountsDb.endTransaction();\n                }\n            }\n        }\n        if (getUserManager().getUserInfo(accounts.userId).canHaveProfile()) {\n            addAccountToLinkedRestrictedUsers(account, accounts.userId);\n        }\n\n        sendNotificationAccountUpdated(account, accounts);\n        // Only send LOGIN_ACCOUNTS_CHANGED when the database changed.\n        Log.i(TAG, \"callingUid=\" + callingUid + \", userId=\" + accounts.userId\n                + \" added account\");\n        sendAccountsChangedBroadcast(accounts.userId, account.type, /*useCase=*/\"addAccount\");\n\n        logAddAccountExplicitlyMetrics(opPackageName, account.type, packageToVisibility);\n        return true;\n    }\n\n    private void logAddAccountExplicitlyMetrics(\n            String callerPackage, String accountType,\n            @Nullable Map<String, Integer> accountVisibility) {\n        // Although this is not a 'device policy' API, enterprise is the current use case.\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.ADD_ACCOUNT_EXPLICITLY)\n                .setStrings(\n                        TextUtils.emptyIfNull(accountType),\n                        TextUtils.emptyIfNull(callerPackage),\n                        findPackagesPerVisibility(accountVisibility))\n                .write();\n    }\n\n    private String[] findPackagesPerVisibility(@Nullable Map<String, Integer> accountVisibility) {\n        Map<Integer, Set<String>> packagesPerVisibility = new HashMap<>();\n        if (accountVisibility != null) {\n            for (Entry<String, Integer> entry : accountVisibility.entrySet()) {\n                if (!packagesPerVisibility.containsKey(entry.getValue())) {\n                    packagesPerVisibility.put(entry.getValue(), new HashSet<>());\n                }\n                packagesPerVisibility.get(entry.getValue()).add(entry.getKey());\n            }\n        }\n\n        String[] packagesPerVisibilityStr = new String[5];\n        packagesPerVisibilityStr[AccountManager.VISIBILITY_UNDEFINED] = getPackagesForVisibilityStr(\n                AccountManager.VISIBILITY_UNDEFINED, packagesPerVisibility);\n        packagesPerVisibilityStr[AccountManager.VISIBILITY_VISIBLE] = getPackagesForVisibilityStr(\n                AccountManager.VISIBILITY_VISIBLE, packagesPerVisibility);\n        packagesPerVisibilityStr[AccountManager.VISIBILITY_USER_MANAGED_VISIBLE] =\n                getPackagesForVisibilityStr(\n                        AccountManager.VISIBILITY_USER_MANAGED_VISIBLE, packagesPerVisibility);\n        packagesPerVisibilityStr[AccountManager.VISIBILITY_NOT_VISIBLE] =\n                getPackagesForVisibilityStr(\n                        AccountManager.VISIBILITY_NOT_VISIBLE, packagesPerVisibility);\n        packagesPerVisibilityStr[AccountManager.VISIBILITY_USER_MANAGED_NOT_VISIBLE] =\n                getPackagesForVisibilityStr(\n                        AccountManager.VISIBILITY_USER_MANAGED_NOT_VISIBLE, packagesPerVisibility);\n        return packagesPerVisibilityStr;\n    }\n\n    private String getPackagesForVisibilityStr(\n            int visibility, Map<Integer, Set<String>> packagesPerVisibility) {\n        return visibility + \":\"\n                + (packagesPerVisibility.containsKey(visibility)\n                    ? TextUtils.join(\",\", packagesPerVisibility.get(visibility))\n                    : \"\");\n    }\n\n    private boolean isLocalUnlockedUser(int userId) {\n        synchronized (mUsers) {\n            return mLocalUnlockedUsers.get(userId);\n        }\n    }\n\n    /**\n     * Adds the account to all linked restricted users as shared accounts. If the user is currently\n     * running, then clone the account too.\n     * @param account the account to share with limited users\n     *\n     */\n    private void addAccountToLinkedRestrictedUsers(Account account, int parentUserId) {\n        List<UserInfo> users = getUserManager().getUsers();\n        for (UserInfo user : users) {\n            if (user.isRestricted() && (parentUserId == user.restrictedProfileParentId)) {\n                addSharedAccountAsUser(account, user.id);\n                if (isLocalUnlockedUser(user.id)) {\n                    mHandler.sendMessage(mHandler.obtainMessage(\n                            MESSAGE_COPY_SHARED_ACCOUNT, parentUserId, user.id, account));\n                }\n            }\n        }\n    }\n\n    @Override\n    public void hasFeatures(IAccountManagerResponse response,\n            Account account, String[] features, int userId, String opPackageName) {\n        int callingUid = Binder.getCallingUid();\n        mAppOpsManager.checkPackage(callingUid, opPackageName);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"hasFeatures: \" + account\n                    + \", response \" + response\n                    + \", features \" + Arrays.toString(features)\n                    + \", caller's uid \" + callingUid\n                    + \", userId \" + userId\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Preconditions.checkArgument(account != null, \"account cannot be null\");\n        Preconditions.checkArgument(response != null, \"response cannot be null\");\n        Preconditions.checkArgument(features != null, \"features cannot be null\");\n\n        if (userId != UserHandle.getCallingUserId()\n                && callingUid != Process.SYSTEM_UID\n                && mContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.INTERACT_ACROSS_USERS_FULL)\n                != PackageManager.PERMISSION_GRANTED) {\n            throw new SecurityException(\"User \" + UserHandle.getCallingUserId()\n                    + \" trying to check account features for \" + userId);\n        }\n\n        checkReadAccountsPermitted(callingUid, account.type, userId,\n                opPackageName);\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            new TestFeaturesSession(accounts, response, account, features).bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private class TestFeaturesSession extends Session {\n        private final String[] mFeatures;\n        private final Account mAccount;\n\n        public TestFeaturesSession(UserAccounts accounts, IAccountManagerResponse response,\n                Account account, String[] features) {\n            super(accounts, response, account.type, false /* expectActivityLaunch */,\n                    true /* stripAuthTokenFromResult */, account.name,\n                    false /* authDetailsRequired */);\n            mFeatures = features;\n            mAccount = account;\n        }\n\n        @Override\n        public void run() throws RemoteException {\n            try {\n                mAuthenticator.hasFeatures(this, mAccount, mFeatures);\n            } catch (RemoteException e) {\n                onError(AccountManager.ERROR_CODE_REMOTE_EXCEPTION, \"remote exception\");\n            }\n        }\n\n        @Override\n        public void onResult(Bundle result) {\n            Bundle.setDefusable(result, true);\n            IAccountManagerResponse response = getResponseAndClose();\n            if (response != null) {\n                try {\n                    if (result == null) {\n                        response.onError(AccountManager.ERROR_CODE_INVALID_RESPONSE, \"null bundle\");\n                        return;\n                    }\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, getClass().getSimpleName() + \" calling onResult() on response \"\n                                + response);\n                    }\n                    final Bundle newResult = new Bundle();\n                    newResult.putBoolean(AccountManager.KEY_BOOLEAN_RESULT,\n                            result.getBoolean(AccountManager.KEY_BOOLEAN_RESULT, false));\n                    response.onResult(newResult);\n                } catch (RemoteException e) {\n                    // if the caller is dead then there is no one to care about remote exceptions\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, \"failure while notifying response\", e);\n                    }\n                }\n            }\n        }\n\n        @Override\n        protected String toDebugString(long now) {\n            return super.toDebugString(now) + \", hasFeatures\"\n                    + \", \" + mAccount\n                    + \", \" + (mFeatures != null ? TextUtils.join(\",\", mFeatures) : null);\n        }\n    }\n\n    @Override\n    public void renameAccount(\n            IAccountManagerResponse response, Account accountToRename, String newName) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"renameAccount: \" + accountToRename + \" -> \" + newName\n                + \", caller's uid \" + callingUid\n                + \", pid \" + Binder.getCallingPid());\n        }\n        if (accountToRename == null) throw new IllegalArgumentException(\"account is null\");\n        if (newName != null && newName.length() > 200) {\n            Log.e(TAG, \"renameAccount failed - account name longer than 200\");\n            throw new IllegalArgumentException(\"account name longer than 200\");\n        }\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(accountToRename.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot rename accounts of type: %s\",\n                    callingUid,\n                    accountToRename.type);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            Log.i(TAG, \"callingUid=\" + callingUid + \", userId=\" + accounts.userId\n                    + \" performing rename account\");\n            Account resultingAccount = renameAccountInternal(accounts, accountToRename, newName);\n            if (resultingAccount == null) {\n                resultingAccount = accountToRename;\n            }\n            Bundle result = new Bundle();\n            result.putString(AccountManager.KEY_ACCOUNT_NAME, resultingAccount.name);\n            result.putString(AccountManager.KEY_ACCOUNT_TYPE, resultingAccount.type);\n            result.putString(AccountManager.KEY_ACCOUNT_ACCESS_ID,\n                    resultingAccount.getAccessId());\n            try {\n                response.onResult(result);\n            } catch (RemoteException e) {\n                Log.w(TAG, e.getMessage());\n            }\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private Account renameAccountInternal(\n            UserAccounts accounts, Account accountToRename, String newName) {\n        Account resultAccount = null;\n        /*\n         * Cancel existing notifications. Let authenticators\n         * re-post notifications as required. But we don't know if\n         * the authenticators have bound their notifications to\n         * now stale account name data.\n         *\n         * With a rename api, we might not need to do this anymore but it\n         * shouldn't hurt.\n         */\n        cancelNotification(\n                getSigninRequiredNotificationId(accounts, accountToRename),\n                accounts);\n        synchronized(accounts.credentialsPermissionNotificationIds) {\n            for (Pair<Pair<Account, String>, Integer> pair:\n                    accounts.credentialsPermissionNotificationIds.keySet()) {\n                if (accountToRename.equals(pair.first.first)) {\n                    NotificationId id = accounts.credentialsPermissionNotificationIds.get(pair);\n                    cancelNotification(id, accounts);\n                }\n            }\n        }\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                List<String> accountRemovedReceivers =\n                    getAccountRemovedReceivers(accountToRename, accounts);\n                accounts.accountsDb.beginTransaction();\n                Account renamedAccount = new Account(newName, accountToRename.type);\n                try {\n                    if ((accounts.accountsDb.findCeAccountId(renamedAccount) >= 0)) {\n                        Log.e(TAG, \"renameAccount failed - account with new name already exists\");\n                        return null;\n                    }\n                    final long accountId = accounts.accountsDb.findDeAccountId(accountToRename);\n                    if (accountId >= 0) {\n                        accounts.accountsDb.renameCeAccount(accountId, newName);\n                        if (accounts.accountsDb.renameDeAccount(\n                                accountId, newName, accountToRename.name)) {\n                            accounts.accountsDb.setTransactionSuccessful();\n                        } else {\n                            Log.e(TAG, \"renameAccount failed\");\n                            return null;\n                        }\n                    } else {\n                        Log.e(TAG, \"renameAccount failed - old account does not exist\");\n                        return null;\n                    }\n                } finally {\n                    accounts.accountsDb.endTransaction();\n                }\n            /*\n             * Database transaction was successful. Clean up cached\n             * data associated with the account in the user profile.\n             */\n                renamedAccount = insertAccountIntoCacheLocked(accounts, renamedAccount);\n            /*\n             * Extract the data and token caches before removing the\n             * old account to preserve the user data associated with\n             * the account.\n             */\n                Map<String, String> tmpData = accounts.userDataCache.get(accountToRename);\n                Map<String, String> tmpTokens = accounts.authTokenCache.get(accountToRename);\n                Map<String, Integer> tmpVisibility = accounts.visibilityCache.get(accountToRename);\n                removeAccountFromCacheLocked(accounts, accountToRename);\n            /*\n             * Update the cached data associated with the renamed\n             * account.\n             */\n                accounts.userDataCache.put(renamedAccount, tmpData);\n                accounts.authTokenCache.put(renamedAccount, tmpTokens);\n                accounts.visibilityCache.put(renamedAccount, tmpVisibility);\n                accounts.previousNameCache.put(\n                        renamedAccount,\n                        new AtomicReference<>(accountToRename.name));\n                resultAccount = renamedAccount;\n\n                int parentUserId = accounts.userId;\n                if (canHaveProfile(parentUserId)) {\n                /*\n                 * Owner or system user account was renamed, rename the account for\n                 * those users with which the account was shared.\n                 */\n                    List<UserInfo> users = getUserManager().getAliveUsers();\n                    for (UserInfo user : users) {\n                        if (user.isRestricted()\n                                && (user.restrictedProfileParentId == parentUserId)) {\n                            renameSharedAccountAsUser(accountToRename, newName, user.id);\n                        }\n                    }\n                }\n\n                sendNotificationAccountUpdated(resultAccount, accounts);\n                sendAccountsChangedBroadcast(\n                        accounts.userId, accountToRename.type, /*useCase=*/\"renameAccount\");\n                for (String packageName : accountRemovedReceivers) {\n                    sendAccountRemovedBroadcast(\n                            accountToRename,\n                            packageName,\n                            accounts.userId,\n                            /*useCase=*/\"renameAccount\");\n                }\n\n                AccountManager.invalidateLocalAccountsDataCaches();\n                AccountManager.invalidateLocalAccountUserDataCaches();\n            }\n        }\n        return resultAccount;\n    }\n\n    private boolean canHaveProfile(final int parentUserId) {\n        final UserInfo userInfo = getUserManager().getUserInfo(parentUserId);\n        return userInfo != null && userInfo.canHaveProfile();\n    }\n\n    @Override\n    public void removeAccountAsUser(IAccountManagerResponse response, Account account,\n            boolean expectActivityLaunch, int userId) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"removeAccount: \" + account\n                    + \", response \" + response\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid()\n                    + \", for user id \" + userId);\n        }\n        Preconditions.checkArgument(account != null, \"account cannot be null\");\n        Preconditions.checkArgument(response != null, \"response cannot be null\");\n\n        // Only allow the system process to modify accounts of other users\n        if (isCrossUser(callingUid, userId)) {\n            throw new SecurityException(\n                    String.format(\n                            \"User %s tying remove account for %s\" ,\n                            UserHandle.getCallingUserId(),\n                            userId));\n        }\n        /*\n         * Only the system, authenticator or profile owner should be allowed to remove accounts for\n         * that authenticator.  This will let users remove accounts (via Settings in the system) but\n         * not arbitrary applications (like competing authenticators).\n         */\n        UserHandle user = UserHandle.of(userId);\n        if (!isAccountManagedByCaller(account.type, callingUid, user.getIdentifier())\n                && !isSystemUid(callingUid)\n                && !isProfileOwner(callingUid)) {\n            String msg = String.format(\n                    \"uid %s cannot remove accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        if (!canUserModifyAccounts(userId, callingUid)) {\n            try {\n                response.onError(AccountManager.ERROR_CODE_USER_RESTRICTED,\n                        \"User cannot modify accounts\");\n            } catch (RemoteException re) {\n            }\n            return;\n        }\n        if (!canUserModifyAccountsForType(userId, account.type, callingUid)) {\n            try {\n                response.onError(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                        \"User cannot modify accounts of this type (policy).\");\n            } catch (RemoteException re) {\n                Log.w(TAG, \"RemoteException while removing account\", re);\n            }\n            return;\n        }\n        if (isFirstAccountRemovalDisabled(account)) {\n            try {\n                response.onError(\n                        AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                        \"User cannot remove the first \"\n                                + account.type\n                                + \" account on the device.\");\n            } catch (RemoteException re) {\n                Log.w(TAG, \"RemoteException while removing account\", re);\n            }\n            return;\n        }\n        final long identityToken = clearCallingIdentity();\n        UserAccounts accounts = getUserAccounts(userId);\n        cancelNotification(getSigninRequiredNotificationId(accounts, account), accounts);\n        synchronized(accounts.credentialsPermissionNotificationIds) {\n            for (Pair<Pair<Account, String>, Integer> pair:\n                accounts.credentialsPermissionNotificationIds.keySet()) {\n                if (account.equals(pair.first.first)) {\n                    NotificationId id = accounts.credentialsPermissionNotificationIds.get(pair);\n                    cancelNotification(id, accounts);\n                }\n            }\n        }\n        final long accountId = accounts.accountsDb.findDeAccountId(account);\n        logRecord(\n                AccountsDb.DEBUG_ACTION_CALLED_ACCOUNT_REMOVE,\n                AccountsDb.TABLE_ACCOUNTS,\n                accountId,\n                accounts,\n                callingUid);\n        try {\n            new RemoveAccountSession(accounts, response, account, expectActivityLaunch).bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public boolean removeAccountExplicitly(Account account) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"removeAccountExplicitly: \" + account\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        int userId = Binder.getCallingUserHandle().getIdentifier();\n        if (account == null) {\n            /*\n             * Null accounts should result in returning false, as per\n             * AccountManage.addAccountExplicitly(...) java doc.\n             */\n            Log.e(TAG, \"account is null\");\n            return false;\n        } else if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot explicitly remove accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        if (isFirstAccountRemovalDisabled(account)) {\n            Log.e(TAG, \"Cannot remove the first \" + account.type + \" account on the device.\");\n            return false;\n        }\n        UserAccounts accounts = getUserAccountsForCaller();\n        final long accountId = accounts.accountsDb.findDeAccountId(account);\n        logRecord(\n                AccountsDb.DEBUG_ACTION_CALLED_ACCOUNT_REMOVE,\n                AccountsDb.TABLE_ACCOUNTS,\n                accountId,\n                accounts,\n                callingUid);\n        final long identityToken = clearCallingIdentity();\n        try {\n            return removeAccountInternal(accounts, account, callingUid);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private class RemoveAccountSession extends Session {\n        final Account mAccount;\n        public RemoveAccountSession(UserAccounts accounts, IAccountManagerResponse response,\n                Account account, boolean expectActivityLaunch) {\n            super(accounts, response, account.type, expectActivityLaunch,\n                    true /* stripAuthTokenFromResult */, account.name,\n                    false /* authDetailsRequired */);\n            mAccount = account;\n        }\n\n        @Override\n        protected String toDebugString(long now) {\n            return super.toDebugString(now) + \", removeAccount\"\n                    + \", account \" + mAccount;\n        }\n\n        @Override\n        public void run() throws RemoteException {\n            mAuthenticator.getAccountRemovalAllowed(this, mAccount);\n        }\n\n        @Override\n        public void onResult(Bundle result) {\n            Bundle.setDefusable(result, true);\n            if (result != null && result.containsKey(AccountManager.KEY_BOOLEAN_RESULT)\n                    && !result.containsKey(AccountManager.KEY_INTENT)) {\n                final boolean removalAllowed = result.getBoolean(AccountManager.KEY_BOOLEAN_RESULT);\n                if (removalAllowed) {\n                    removeAccountInternal(mAccounts, mAccount, getCallingUid());\n                }\n                IAccountManagerResponse response = getResponseAndClose();\n                if (response != null) {\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, getClass().getSimpleName() + \" calling onResult() on response \"\n                                + response);\n                    }\n                    try {\n                        response.onResult(result);\n                    } catch (RemoteException e) {\n                        Slog.e(TAG, \"Error calling onResult()\", e);\n                    }\n                }\n            }\n            super.onResult(result);\n        }\n    }\n\n    @VisibleForTesting\n    protected void removeAccountInternal(Account account) {\n        removeAccountInternal(getUserAccountsForCaller(), account, getCallingUid());\n    }\n\n    private boolean removeAccountInternal(UserAccounts accounts, Account account, int callingUid) {\n        boolean isChanged = false;\n        boolean userUnlocked = isLocalUnlockedUser(accounts.userId);\n        if (!userUnlocked) {\n            Slog.i(TAG, \"Removing account \" + account.toSafeString()\n                    + \" while user \" + accounts.userId\n                    + \" is still locked. CE data will be removed later\");\n        }\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                Map<String, Integer> packagesToVisibility = getRequestingPackages(account,\n                        accounts);\n                List<String> accountRemovedReceivers =\n                    getAccountRemovedReceivers(account, accounts);\n                accounts.accountsDb.beginTransaction();\n                // Set to a placeholder value, this will only be used if the database\n                // transaction succeeds.\n                long accountId = -1;\n                try {\n                    accountId = accounts.accountsDb.findDeAccountId(account);\n                    if (accountId >= 0) {\n                        isChanged = accounts.accountsDb.deleteDeAccount(accountId);\n                    }\n                    // always delete from CE table if CE storage is available\n                    // DE account could be removed while CE was locked\n                    if (userUnlocked) {\n                        long ceAccountId = accounts.accountsDb.findCeAccountId(account);\n                        if (ceAccountId >= 0) {\n                            accounts.accountsDb.deleteCeAccount(ceAccountId);\n                        }\n                    }\n                    accounts.accountsDb.setTransactionSuccessful();\n                } finally {\n                    accounts.accountsDb.endTransaction();\n                }\n                if (isChanged) {\n                    removeAccountFromCacheLocked(accounts, account);\n                    for (Entry<String, Integer> packageToVisibility : packagesToVisibility\n                            .entrySet()) {\n                        if ((packageToVisibility.getValue() == AccountManager.VISIBILITY_VISIBLE)\n                                || (packageToVisibility.getValue()\n                                    == AccountManager.VISIBILITY_USER_MANAGED_VISIBLE)) {\n                            notifyPackage(packageToVisibility.getKey(), accounts);\n                        }\n                    }\n\n                    // Only broadcast LOGIN_ACCOUNTS_CHANGED if a change occurred.\n                    Log.i(TAG, \"callingUid=\" + callingUid + \", userId=\" + accounts.userId\n                            + \" removed account\");\n                    sendAccountsChangedBroadcast(\n                            accounts.userId, account.type, /*useCase=*/\"removeAccount\");\n                    for (String packageName : accountRemovedReceivers) {\n                        sendAccountRemovedBroadcast(\n                                account, packageName, accounts.userId, /*useCase=*/\"removeAccount\");\n                    }\n                    String action = userUnlocked ? AccountsDb.DEBUG_ACTION_ACCOUNT_REMOVE\n                            : AccountsDb.DEBUG_ACTION_ACCOUNT_REMOVE_DE;\n                    logRecord(action, AccountsDb.TABLE_ACCOUNTS, accountId, accounts);\n                }\n            }\n        }\n        final long id = Binder.clearCallingIdentity();\n        try {\n            int parentUserId = accounts.userId;\n            if (canHaveProfile(parentUserId)) {\n                // Remove from any restricted profiles that are sharing this account.\n                List<UserInfo> users = getUserManager().getAliveUsers();\n                for (UserInfo user : users) {\n                    if (user.isRestricted() && parentUserId == (user.restrictedProfileParentId)) {\n                        removeSharedAccountAsUser(account, user.id, callingUid);\n                    }\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(id);\n        }\n\n        if (isChanged) {\n            synchronized (accounts.credentialsPermissionNotificationIds) {\n                for (Pair<Pair<Account, String>, Integer> key\n                        : accounts.credentialsPermissionNotificationIds.keySet()) {\n                    if (account.equals(key.first.first)\n                            && AccountManager.ACCOUNT_ACCESS_TOKEN_TYPE.equals(key.first.second)) {\n                        final int uid = (Integer) key.second;\n                        mHandler.post(() -> cancelAccountAccessRequestNotificationIfNeeded(\n                                account, uid, false, accounts));\n                    }\n                }\n            }\n        }\n\n        AccountManager.invalidateLocalAccountUserDataCaches();\n\n        return isChanged;\n    }\n\n    @Override\n    public void invalidateAuthToken(String accountType, String authToken) {\n        int callerUid = Binder.getCallingUid();\n        Objects.requireNonNull(accountType, \"accountType cannot be null\");\n        Objects.requireNonNull(authToken, \"authToken cannot be null\");\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"invalidateAuthToken: accountType \" + accountType\n                    + \", caller's uid \" + callerUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        int userId = UserHandle.getCallingUserId();\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            List<Pair<Account, String>> deletedTokens;\n            synchronized (accounts.dbLock) {\n                accounts.accountsDb.beginTransaction();\n                try {\n                    deletedTokens = invalidateAuthTokenLocked(accounts, accountType, authToken);\n                    accounts.accountsDb.setTransactionSuccessful();\n                } finally {\n                    accounts.accountsDb.endTransaction();\n                }\n                synchronized (accounts.cacheLock) {\n                    for (Pair<Account, String> tokenInfo : deletedTokens) {\n                        Account act = tokenInfo.first;\n                        String tokenType = tokenInfo.second;\n                        writeAuthTokenIntoCacheLocked(accounts, act, tokenType, null);\n                    }\n                    // wipe out cached token in memory.\n                    accounts.accountTokenCaches.remove(accountType, authToken);\n                }\n            }\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private List<Pair<Account, String>> invalidateAuthTokenLocked(UserAccounts accounts, String accountType,\n            String authToken) {\n        // TODO Move to AccountsDB\n        List<Pair<Account, String>> results = new ArrayList<>();\n        Cursor cursor = accounts.accountsDb.findAuthtokenForAllAccounts(accountType, authToken);\n\n        try {\n            while (cursor.moveToNext()) {\n                String authTokenId = cursor.getString(0);\n                String accountName = cursor.getString(1);\n                String authTokenType = cursor.getString(2);\n                accounts.accountsDb.deleteAuthToken(authTokenId);\n                results.add(Pair.create(new Account(accountName, accountType), authTokenType));\n            }\n        } finally {\n            cursor.close();\n        }\n        return results;\n    }\n\n    private void saveCachedToken(\n            UserAccounts accounts,\n            Account account,\n            String callerPkg,\n            byte[] callerSigDigest,\n            String tokenType,\n            String token,\n            long expiryMillis) {\n\n        if (account == null || tokenType == null || callerPkg == null || callerSigDigest == null) {\n            return;\n        }\n        cancelNotification(getSigninRequiredNotificationId(accounts, account), accounts);\n        synchronized (accounts.cacheLock) {\n            accounts.accountTokenCaches.put(\n                    account, token, tokenType, callerPkg, callerSigDigest, expiryMillis);\n        }\n    }\n\n    private boolean saveAuthTokenToDatabase(UserAccounts accounts, Account account, String type,\n            String authToken) {\n        if (account == null || type == null) {\n            return false;\n        }\n        cancelNotification(getSigninRequiredNotificationId(accounts, account), accounts);\n        synchronized (accounts.dbLock) {\n            accounts.accountsDb.beginTransaction();\n            boolean updateCache = false;\n            try {\n                long accountId = accounts.accountsDb.findDeAccountId(account);\n                if (accountId < 0) {\n                    return false;\n                }\n                accounts.accountsDb.deleteAuthtokensByAccountIdAndType(accountId, type);\n                if (accounts.accountsDb.insertAuthToken(accountId, type, authToken) >= 0) {\n                    accounts.accountsDb.setTransactionSuccessful();\n                    updateCache = true;\n                    return true;\n                }\n                return false;\n            } finally {\n                accounts.accountsDb.endTransaction();\n                if (updateCache) {\n                    synchronized (accounts.cacheLock) {\n                        writeAuthTokenIntoCacheLocked(accounts, account, type, authToken);\n                    }\n                }\n            }\n        }\n    }\n\n    @Override\n    public String peekAuthToken(Account account, String authTokenType) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"peekAuthToken: \" + account\n                    + \", authTokenType \" + authTokenType\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        Objects.requireNonNull(authTokenType, \"authTokenType cannot be null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot peek the authtokens associated with accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        if (!isLocalUnlockedUser(userId)) {\n            Log.w(TAG, \"Authtoken not available - user \" + userId + \" data is locked. callingUid \"\n                    + callingUid);\n            return null;\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return readAuthTokenInternal(accounts, account, authTokenType);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void setAuthToken(Account account, String authTokenType, String authToken) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"setAuthToken: \" + account\n                    + \", authTokenType \" + authTokenType\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        Objects.requireNonNull(authTokenType, \"authTokenType cannot be null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot set auth tokens associated with accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            saveAuthTokenToDatabase(accounts, account, authTokenType, authToken);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void setPassword(Account account, String password) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"setAuthToken: \" + account\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot set secrets for accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            setPasswordInternal(accounts, account, password, callingUid);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private void setPasswordInternal(UserAccounts accounts, Account account, String password,\n            int callingUid) {\n        if (account == null) {\n            return;\n        }\n        boolean isChanged = false;\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                accounts.accountsDb.beginTransaction();\n                try {\n                    final long accountId = accounts.accountsDb.findDeAccountId(account);\n                    if (accountId >= 0) {\n                        accounts.accountsDb.updateCeAccountPassword(accountId, password);\n                        accounts.accountsDb.deleteAuthTokensByAccountId(accountId);\n                        accounts.authTokenCache.remove(account);\n                        accounts.accountTokenCaches.remove(account);\n                        accounts.accountsDb.setTransactionSuccessful();\n                        // If there is an account whose password will be updated and the database\n                        // transactions succeed, then we say that a change has occured. Even if the\n                        // new password is the same as the old and there were no authtokens to\n                        // delete.\n                        isChanged = true;\n                        String action = (password == null || password.length() == 0) ?\n                                AccountsDb.DEBUG_ACTION_CLEAR_PASSWORD\n                                : AccountsDb.DEBUG_ACTION_SET_PASSWORD;\n                        logRecord(action, AccountsDb.TABLE_ACCOUNTS, accountId, accounts,\n                                callingUid);\n                    }\n                } finally {\n                    accounts.accountsDb.endTransaction();\n                    if (isChanged) {\n                        // Send LOGIN_ACCOUNTS_CHANGED only if the something changed.\n                        sendNotificationAccountUpdated(account, accounts);\n                        Log.i(TAG, \"callingUid=\" + callingUid + \" changed password\");\n                        sendAccountsChangedBroadcast(\n                                accounts.userId, account.type, /*useCase=*/\"setPassword\");\n                    }\n                }\n            }\n        }\n    }\n\n    @Override\n    public void clearPassword(Account account) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"clearPassword: \" + account\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot clear passwords for accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            setPasswordInternal(accounts, account, null, callingUid);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void setUserData(Account account, String key, String value) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"setUserData: \" + account\n                    + \", key \" + key\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        if (key == null) throw new IllegalArgumentException(\"key is null\");\n        if (account == null) throw new IllegalArgumentException(\"account is null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot set user data for accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            if (!accountExistsCache(accounts, account)) {\n                return;\n            }\n            setUserdataInternal(accounts, account, key, value);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private boolean accountExistsCache(UserAccounts accounts, Account account) {\n        synchronized (accounts.cacheLock) {\n            if (accounts.accountCache.containsKey(account.type)) {\n                for (Account acc : accounts.accountCache.get(account.type)) {\n                    if (acc.name.equals(account.name)) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    private void setUserdataInternal(UserAccounts accounts, Account account, String key,\n            String value) {\n        synchronized (accounts.dbLock) {\n            accounts.accountsDb.beginTransaction();\n            try {\n                long accountId = accounts.accountsDb.findDeAccountId(account);\n                if (accountId < 0) {\n                    return;\n                }\n                long extrasId = accounts.accountsDb.findExtrasIdByAccountId(accountId, key);\n                if (extrasId < 0) {\n                    extrasId = accounts.accountsDb.insertExtra(accountId, key, value);\n                    if (extrasId < 0) {\n                        return;\n                    }\n                } else if (!accounts.accountsDb.updateExtra(extrasId, value)) {\n                    return;\n                }\n                accounts.accountsDb.setTransactionSuccessful();\n            } finally {\n                accounts.accountsDb.endTransaction();\n            }\n            synchronized (accounts.cacheLock) {\n                writeUserDataIntoCacheLocked(accounts, account, key, value);\n                AccountManager.invalidateLocalAccountUserDataCaches();\n            }\n        }\n    }\n\n    private void onResult(IAccountManagerResponse response, Bundle result) {\n        if (result == null) {\n            Log.e(TAG, \"the result is unexpectedly null\", new Exception());\n        }\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, getClass().getSimpleName() + \" calling onResult() on response \"\n                    + response);\n        }\n        try {\n            response.onResult(result);\n        } catch (RemoteException e) {\n            // if the caller is dead then there is no one to care about remote\n            // exceptions\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"failure while notifying response\", e);\n            }\n        }\n    }\n\n    @Override\n    public void getAuthTokenLabel(IAccountManagerResponse response, final String accountType,\n                                  final String authTokenType)\n            throws RemoteException {\n        Preconditions.checkArgument(accountType != null, \"accountType cannot be null\");\n        Preconditions.checkArgument(authTokenType != null, \"authTokenType cannot be null\");\n\n        final int callingUid = getCallingUid();\n        clearCallingIdentity();\n        if (UserHandle.getAppId(callingUid) != Process.SYSTEM_UID) {\n            throw new SecurityException(\"can only call from system\");\n        }\n        int userId = UserHandle.getUserId(callingUid);\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            new Session(accounts, response, accountType, false /* expectActivityLaunch */,\n                    false /* stripAuthTokenFromResult */,  null /* accountName */,\n                    false /* authDetailsRequired */) {\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now) + \", getAuthTokenLabel\"\n                            + \", \" + accountType\n                            + \", authTokenType \" + authTokenType;\n                }\n\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.getAuthTokenLabel(this, authTokenType);\n                }\n\n                @Override\n                public void onResult(Bundle result) {\n                    Bundle.setDefusable(result, true);\n                    if (result != null) {\n                        String label = result.getString(AccountManager.KEY_AUTH_TOKEN_LABEL);\n                        Bundle bundle = new Bundle();\n                        bundle.putString(AccountManager.KEY_AUTH_TOKEN_LABEL, label);\n                        super.onResult(bundle);\n                        return;\n                    } else {\n                        super.onResult(result);\n                    }\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void getAuthToken(\n            IAccountManagerResponse response,\n            final Account account,\n            final String authTokenType,\n            final boolean notifyOnAuthFailure,\n            final boolean expectActivityLaunch,\n            final Bundle loginOptions) {\n        Bundle.setDefusable(loginOptions, true);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"getAuthToken: \" + account\n                    + \", response \" + response\n                    + \", authTokenType \" + authTokenType\n                    + \", notifyOnAuthFailure \" + notifyOnAuthFailure\n                    + \", expectActivityLaunch \" + expectActivityLaunch\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Preconditions.checkArgument(response != null, \"response cannot be null\");\n        try {\n            if (account == null) {\n                Slog.w(TAG, \"getAuthToken called with null account\");\n                response.onError(AccountManager.ERROR_CODE_BAD_ARGUMENTS, \"account is null\");\n                return;\n            }\n            if (authTokenType == null) {\n                Slog.w(TAG, \"getAuthToken called with null authTokenType\");\n                response.onError(AccountManager.ERROR_CODE_BAD_ARGUMENTS, \"authTokenType is null\");\n                return;\n            }\n        } catch (RemoteException e) {\n            Slog.w(TAG, \"Failed to report error back to the client.\" + e);\n            return;\n        }\n        int userId = UserHandle.getCallingUserId();\n        final long ident = Binder.clearCallingIdentity();\n        final UserAccounts accounts;\n        final RegisteredServicesCache.ServiceInfo<AuthenticatorDescription> authenticatorInfo;\n        try {\n            accounts = getUserAccounts(userId);\n            authenticatorInfo = mAuthenticatorCache.getServiceInfo(\n                    AuthenticatorDescription.newKey(account.type), accounts.userId);\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n\n        final boolean customTokens =\n                authenticatorInfo != null && authenticatorInfo.type.customTokens;\n\n        // skip the check if customTokens\n        final int callerUid = Binder.getCallingUid();\n        final boolean permissionGranted =\n                customTokens || permissionIsGranted(account, authTokenType, callerUid, userId);\n\n        // Get the calling package. We will use it for the purpose of caching.\n        final String callerPkg = loginOptions.getString(AccountManager.KEY_ANDROID_PACKAGE_NAME);\n        String[] callerOwnedPackageNames;\n        final long ident2 = Binder.clearCallingIdentity();\n        try {\n            callerOwnedPackageNames = mPackageManager.getPackagesForUid(callerUid);\n        } finally {\n            Binder.restoreCallingIdentity(ident2);\n        }\n        if (callerPkg == null || callerOwnedPackageNames == null\n                || !ArrayUtils.contains(callerOwnedPackageNames, callerPkg)) {\n            String msg = String.format(\n                    \"Uid %s is attempting to illegally masquerade as package %s!\",\n                    callerUid,\n                    callerPkg);\n            throw new SecurityException(msg);\n        }\n\n        // let authenticator know the identity of the caller\n        loginOptions.putInt(AccountManager.KEY_CALLER_UID, callerUid);\n        loginOptions.putInt(AccountManager.KEY_CALLER_PID, Binder.getCallingPid());\n\n        if (notifyOnAuthFailure) {\n            loginOptions.putBoolean(AccountManager.KEY_NOTIFY_ON_FAILURE, true);\n        }\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            // Distill the caller's package signatures into a single digest.\n            final byte[] callerPkgSigDigest = calculatePackageSignatureDigest(callerPkg, userId);\n\n            // if the caller has permission, do the peek. otherwise go the more expensive\n            // route of starting a Session\n            if (!customTokens && permissionGranted) {\n                String authToken = readAuthTokenInternal(accounts, account, authTokenType);\n                if (authToken != null) {\n                    logGetAuthTokenMetrics(callerPkg, account.type);\n                    Bundle result = new Bundle();\n                    result.putString(AccountManager.KEY_AUTHTOKEN, authToken);\n                    result.putString(AccountManager.KEY_ACCOUNT_NAME, account.name);\n                    result.putString(AccountManager.KEY_ACCOUNT_TYPE, account.type);\n                    onResult(response, result);\n                    return;\n                }\n            }\n\n            if (customTokens) {\n                /*\n                 * Look up tokens in the new cache only if the loginOptions don't have parameters\n                 * outside of those expected to be injected by the AccountManager, e.g.\n                 * ANDORID_PACKAGE_NAME.\n                 */\n                TokenCache.Value cachedToken = readCachedTokenInternal(\n                        accounts,\n                        account,\n                        authTokenType,\n                        callerPkg,\n                        callerPkgSigDigest);\n                if (cachedToken != null) {\n                    logGetAuthTokenMetrics(callerPkg, account.type);\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, \"getAuthToken: cache hit ofr custom token authenticator.\");\n                    }\n                    Bundle result = new Bundle();\n                    result.putString(AccountManager.KEY_AUTHTOKEN, cachedToken.token);\n                    result.putLong(AbstractAccountAuthenticator.KEY_CUSTOM_TOKEN_EXPIRY,\n                            cachedToken.expiryEpochMillis);\n                    result.putString(AccountManager.KEY_ACCOUNT_NAME, account.name);\n                    result.putString(AccountManager.KEY_ACCOUNT_TYPE, account.type);\n                    onResult(response, result);\n                    return;\n                }\n            }\n\n            new Session(\n                    accounts,\n                    response,\n                    account.type,\n                    expectActivityLaunch,\n                    false /* stripAuthTokenFromResult */,\n                    account.name,\n                    false /* authDetailsRequired */) {\n                @Override\n                protected String toDebugString(long now) {\n                    if (loginOptions != null) loginOptions.keySet();\n                    return super.toDebugString(now) + \", getAuthToken\"\n                            + \", \" + account.toSafeString()\n                            + \", authTokenType \" + authTokenType\n                            + \", loginOptions \" + loginOptions\n                            + \", notifyOnAuthFailure \" + notifyOnAuthFailure;\n                }\n\n                @Override\n                public void run() throws RemoteException {\n                    // If the caller doesn't have permission then create and return the\n                    // \"grant permission\" intent instead of the \"getAuthToken\" intent.\n                    if (!permissionGranted) {\n                        mAuthenticator.getAuthTokenLabel(this, authTokenType);\n                    } else {\n                        mAuthenticator.getAuthToken(this, account, authTokenType, loginOptions);\n                        logGetAuthTokenMetrics(callerPkg, account.type);\n                    }\n                }\n\n                @Override\n                public void onResult(Bundle result) {\n                    Bundle.setDefusable(result, true);\n                    if (result != null) {\n                        if (result.containsKey(AccountManager.KEY_AUTH_TOKEN_LABEL)) {\n                            Intent intent = newGrantCredentialsPermissionIntent(\n                                    account,\n                                    null,\n                                    callerUid,\n                                    new AccountAuthenticatorResponse(this),\n                                    authTokenType,\n                                    true);\n                            mCanStartAccountManagerActivity = true;\n                            Bundle bundle = new Bundle();\n                            bundle.putParcelable(AccountManager.KEY_INTENT, intent);\n                            onResult(bundle);\n                            return;\n                        }\n                        String authToken = result.getString(AccountManager.KEY_AUTHTOKEN);\n                        if (authToken != null) {\n                            String name = result.getString(AccountManager.KEY_ACCOUNT_NAME);\n                            String type = result.getString(AccountManager.KEY_ACCOUNT_TYPE);\n                            if (TextUtils.isEmpty(type) || TextUtils.isEmpty(name)) {\n                                onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                                        \"the type and name should not be empty\");\n                                return;\n                            }\n                            Account resultAccount = new Account(name, type);\n                            if (!customTokens) {\n                                saveAuthTokenToDatabase(\n                                        mAccounts,\n                                        resultAccount,\n                                        authTokenType,\n                                        authToken);\n                            }\n                            long expiryMillis = result.getLong(\n                                    AbstractAccountAuthenticator.KEY_CUSTOM_TOKEN_EXPIRY, 0L);\n                            if (customTokens\n                                    && expiryMillis > System.currentTimeMillis()) {\n                                saveCachedToken(\n                                        mAccounts,\n                                        account,\n                                        callerPkg,\n                                        callerPkgSigDigest,\n                                        authTokenType,\n                                        authToken,\n                                        expiryMillis);\n                            }\n                        }\n\n                        Intent intent = result.getParcelable(AccountManager.KEY_INTENT, android.content.Intent.class);\n                        if (intent != null && notifyOnAuthFailure && !customTokens) {\n                            /*\n                             * Make sure that the supplied intent is owned by the authenticator\n                             * giving it to the system. Otherwise a malicious authenticator could\n                             * have users launching arbitrary activities by tricking users to\n                             * interact with malicious notifications.\n                             */\n                            if (!checkKeyIntent(\n                                    Binder.getCallingUid(),\n                                    result)) {\n                                onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                                        \"invalid intent in bundle returned\");\n                                return;\n                            }\n                            doNotification(\n                                    mAccounts,\n                                    account,\n                                    result.getString(AccountManager.KEY_AUTH_FAILED_MESSAGE),\n                                    intent, \"android\", accounts.userId);\n                        }\n                    }\n                    super.onResult(result);\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private void logGetAuthTokenMetrics(final String callerPackage, String accountType) {\n        // Although this is not a 'device policy' API, enterprise is the current use case.\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.GET_ACCOUNT_AUTH_TOKEN)\n                .setStrings(\n                        TextUtils.emptyIfNull(callerPackage),\n                        TextUtils.emptyIfNull(accountType))\n                .write();\n    }\n\n    private byte[] calculatePackageSignatureDigest(String callerPkg, int userId) {\n        MessageDigest digester;\n        try {\n            digester = MessageDigest.getInstance(\"SHA-256\");\n            PackageInfo pkgInfo = mPackageManager.getPackageInfoAsUser(\n                    callerPkg, PackageManager.GET_SIGNATURES, userId);\n            for (Signature sig : pkgInfo.signatures) {\n                digester.update(sig.toByteArray());\n            }\n        } catch (NoSuchAlgorithmException x) {\n            Log.wtf(TAG, \"SHA-256 should be available\", x);\n            digester = null;\n        } catch (NameNotFoundException e) {\n            Log.w(TAG, \"Could not find packageinfo for: \" + callerPkg);\n            digester = null;\n        }\n        return (digester == null) ? null : digester.digest();\n    }\n\n    private void createNoCredentialsPermissionNotification(Account account, Intent intent,\n            String packageName, UserAccounts accounts) {\n        int userId = accounts.userId;\n        int uid = intent.getIntExtra(\n                GrantCredentialsPermissionActivity.EXTRAS_REQUESTING_UID, -1);\n        String authTokenType = intent.getStringExtra(\n                GrantCredentialsPermissionActivity.EXTRAS_AUTH_TOKEN_TYPE);\n        final String titleAndSubtitle =\n                mContext.getString(R.string.permission_request_notification_for_app_with_subtitle,\n                getApplicationLabel(packageName, userId), account.name);\n        final int index = titleAndSubtitle.indexOf('\\n');\n        String title = titleAndSubtitle;\n        String subtitle = \"\";\n        if (index > 0) {\n            title = titleAndSubtitle.substring(0, index);\n            subtitle = titleAndSubtitle.substring(index + 1);\n        }\n        UserHandle user = UserHandle.of(userId);\n        Context contextForUser = getContextForUser(user);\n        Notification n =\n                new Notification.Builder(contextForUser, SystemNotificationChannels.ACCOUNT)\n                    .setSmallIcon(android.R.drawable.stat_sys_warning)\n                    .setWhen(0)\n                    .setColor(contextForUser.getColor(\n                            com.android.internal.R.color.system_notification_accent_color))\n                    .setContentTitle(title)\n                    .setContentText(subtitle)\n                    .setContentIntent(PendingIntent.getActivityAsUser(mContext, 0, intent,\n                            PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_IMMUTABLE,\n                            null, user))\n                    .build();\n        installNotification(getCredentialPermissionNotificationId(\n                account, authTokenType, uid, accounts), n, \"android\", user.getIdentifier());\n    }\n\n    private String getApplicationLabel(String packageName, int userId) {\n        try {\n            return mPackageManager.getApplicationLabel(\n                    mPackageManager.getApplicationInfoAsUser(packageName, 0, userId)).toString();\n        } catch (PackageManager.NameNotFoundException e) {\n            return packageName;\n        }\n    }\n\n    private Intent newGrantCredentialsPermissionIntent(Account account, String packageName,\n            int uid, AccountAuthenticatorResponse response, String authTokenType,\n            boolean startInNewTask) {\n\n        Intent intent = new Intent(mContext, GrantCredentialsPermissionActivity.class);\n\n        if (startInNewTask) {\n            // See FLAG_ACTIVITY_NEW_TASK docs for limitations and benefits of the flag.\n            // Since it was set in Eclair+ we can't change it without breaking apps using\n            // the intent from a non-Activity context. This is the default behavior.\n            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        }\n        UserAccounts accounts = getUserAccounts(UserHandle.getUserId(uid));\n        intent.addCategory(getCredentialPermissionNotificationId(account,\n                authTokenType, uid, accounts).mTag + (packageName != null ? packageName : \"\"));\n        intent.putExtra(GrantCredentialsPermissionActivity.EXTRAS_ACCOUNT, account);\n        intent.putExtra(GrantCredentialsPermissionActivity.EXTRAS_AUTH_TOKEN_TYPE, authTokenType);\n        intent.putExtra(GrantCredentialsPermissionActivity.EXTRAS_RESPONSE, response);\n        intent.putExtra(GrantCredentialsPermissionActivity.EXTRAS_REQUESTING_UID, uid);\n\n        return intent;\n    }\n\n    private NotificationId getCredentialPermissionNotificationId(Account account,\n            String authTokenType, int uid, UserAccounts accounts) {\n        NotificationId nId;\n        synchronized (accounts.credentialsPermissionNotificationIds) {\n            final Pair<Pair<Account, String>, Integer> key =\n                    new Pair<Pair<Account, String>, Integer>(\n                            new Pair<Account, String>(account, authTokenType), uid);\n            nId = accounts.credentialsPermissionNotificationIds.get(key);\n            if (nId == null) {\n                String tag = TAG + \":\" + SystemMessage.NOTE_ACCOUNT_CREDENTIAL_PERMISSION\n                        + \":\" + account.hashCode() + \":\" + authTokenType.hashCode() + \":\" + uid;\n                int id = SystemMessage.NOTE_ACCOUNT_CREDENTIAL_PERMISSION;\n                nId = new NotificationId(tag, id);\n                accounts.credentialsPermissionNotificationIds.put(key, nId);\n            }\n        }\n        return nId;\n    }\n\n    private NotificationId getSigninRequiredNotificationId(UserAccounts accounts, Account account) {\n        NotificationId nId;\n        synchronized (accounts.signinRequiredNotificationIds) {\n            nId = accounts.signinRequiredNotificationIds.get(account);\n            if (nId == null) {\n                String tag = TAG + \":\" + SystemMessage.NOTE_ACCOUNT_REQUIRE_SIGNIN\n                        + \":\" + account.hashCode();\n                int id = SystemMessage.NOTE_ACCOUNT_REQUIRE_SIGNIN;\n                nId = new NotificationId(tag, id);\n                accounts.signinRequiredNotificationIds.put(account, nId);\n            }\n        }\n        return nId;\n    }\n\n    @Override\n    public void addAccount(final IAccountManagerResponse response, final String accountType,\n            final String authTokenType, final String[] requiredFeatures,\n            final boolean expectActivityLaunch, final Bundle optionsIn) {\n        Bundle.setDefusable(optionsIn, true);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"addAccount: accountType \" + accountType\n                    + \", response \" + response\n                    + \", authTokenType \" + authTokenType\n                    + \", requiredFeatures \" + Arrays.toString(requiredFeatures)\n                    + \", expectActivityLaunch \" + expectActivityLaunch\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        if (response == null) throw new IllegalArgumentException(\"response is null\");\n        if (accountType == null) throw new IllegalArgumentException(\"accountType is null\");\n\n        // Is user disallowed from modifying accounts?\n        final int uid = Binder.getCallingUid();\n        final int userId = UserHandle.getUserId(uid);\n        if (!canUserModifyAccounts(userId, uid)) {\n            try {\n                response.onError(AccountManager.ERROR_CODE_USER_RESTRICTED,\n                        \"User is not allowed to add an account!\");\n            } catch (RemoteException re) {\n            }\n            showCantAddAccount(AccountManager.ERROR_CODE_USER_RESTRICTED, userId);\n            return;\n        }\n        if (!canUserModifyAccountsForType(userId, accountType, uid)) {\n            try {\n                response.onError(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                        \"User cannot modify accounts of this type (policy).\");\n            } catch (RemoteException re) {\n            }\n            showCantAddAccount(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                    userId);\n            return;\n        }\n        addAccountAndLogMetrics(response, accountType, authTokenType, requiredFeatures,\n                expectActivityLaunch, optionsIn, userId);\n    }\n\n    @Override\n    public void addAccountAsUser(final IAccountManagerResponse response, final String accountType,\n            final String authTokenType, final String[] requiredFeatures,\n            final boolean expectActivityLaunch, final Bundle optionsIn, int userId) {\n        Bundle.setDefusable(optionsIn, true);\n        int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"addAccount: accountType \" + accountType\n                    + \", response \" + response\n                    + \", authTokenType \" + authTokenType\n                    + \", requiredFeatures \" + Arrays.toString(requiredFeatures)\n                    + \", expectActivityLaunch \" + expectActivityLaunch\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid()\n                    + \", for user id \" + userId);\n        }\n        Preconditions.checkArgument(response != null, \"response cannot be null\");\n        Preconditions.checkArgument(accountType != null, \"accountType cannot be null\");\n        // Only allow the system process to add accounts of other users\n        if (isCrossUser(callingUid, userId)) {\n            throw new SecurityException(\n                    String.format(\n                            \"User %s trying to add account for %s\" ,\n                            UserHandle.getCallingUserId(),\n                            userId));\n        }\n\n        // Is user disallowed from modifying accounts?\n        if (!canUserModifyAccounts(userId, callingUid)) {\n            try {\n                response.onError(AccountManager.ERROR_CODE_USER_RESTRICTED,\n                        \"User is not allowed to add an account!\");\n            } catch (RemoteException re) {\n            }\n            showCantAddAccount(AccountManager.ERROR_CODE_USER_RESTRICTED, userId);\n            return;\n        }\n        if (!canUserModifyAccountsForType(userId, accountType, callingUid)) {\n            try {\n                response.onError(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                        \"User cannot modify accounts of this type (policy).\");\n            } catch (RemoteException re) {\n            }\n            showCantAddAccount(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                    userId);\n            return;\n        }\n        addAccountAndLogMetrics(response, accountType, authTokenType, requiredFeatures,\n                expectActivityLaunch, optionsIn, userId);\n    }\n\n    private void addAccountAndLogMetrics(\n            IAccountManagerResponse response, String accountType,\n            String authTokenType, String[] requiredFeatures,\n            boolean expectActivityLaunch, Bundle optionsIn, int userId) {\n        final int pid = Binder.getCallingPid();\n        final int uid = Binder.getCallingUid();\n        final Bundle options = (optionsIn == null) ? new Bundle() : optionsIn;\n        options.putInt(AccountManager.KEY_CALLER_UID, uid);\n        options.putInt(AccountManager.KEY_CALLER_PID, pid);\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            logRecordWithUid(\n                    accounts, AccountsDb.DEBUG_ACTION_CALLED_ACCOUNT_ADD, AccountsDb.TABLE_ACCOUNTS,\n                    uid);\n            new Session(accounts, response, accountType, expectActivityLaunch,\n                    true /* stripAuthTokenFromResult */, null /* accountName */,\n                    false /* authDetailsRequired */, true /* updateLastAuthenticationTime */) {\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.addAccount(\n                            this, mAccountType, authTokenType, requiredFeatures, options);\n                    String callerPackage = options.getString(\n                            AccountManager.KEY_ANDROID_PACKAGE_NAME);\n                    logAddAccountMetrics(\n                            callerPackage, accountType, requiredFeatures, authTokenType);\n                }\n\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now) + \", addAccount\"\n                            + \", accountType \" + accountType\n                            + \", requiredFeatures \"\n                            + (requiredFeatures != null\n                            ? TextUtils.join(\",\", requiredFeatures)\n                            : null);\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private void logAddAccountMetrics(\n            String callerPackage, String accountType, String[] requiredFeatures,\n            String authTokenType) {\n        // Although this is not a 'device policy' API, enterprise is the current use case.\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.ADD_ACCOUNT)\n                .setStrings(\n                        TextUtils.emptyIfNull(accountType),\n                        TextUtils.emptyIfNull(callerPackage),\n                        TextUtils.emptyIfNull(authTokenType),\n                        requiredFeatures == null\n                                ? \"\"\n                                : TextUtils.join(\";\", requiredFeatures))\n                .write();\n    }\n\n    @Override\n    public void startAddAccountSession(\n            final IAccountManagerResponse response,\n            final String accountType,\n            final String authTokenType,\n            final String[] requiredFeatures,\n            final boolean expectActivityLaunch,\n            final Bundle optionsIn) {\n        Bundle.setDefusable(optionsIn, true);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG,\n                    \"startAddAccountSession: accountType \" + accountType\n                    + \", response \" + response\n                    + \", authTokenType \" + authTokenType\n                    + \", requiredFeatures \" + Arrays.toString(requiredFeatures)\n                    + \", expectActivityLaunch \" + expectActivityLaunch\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Preconditions.checkArgument(response != null, \"response cannot be null\");\n        Preconditions.checkArgument(accountType != null, \"accountType cannot be null\");\n\n        final int uid = Binder.getCallingUid();\n        final int userId = UserHandle.getUserId(uid);\n        if (!canUserModifyAccounts(userId, uid)) {\n            try {\n                response.onError(AccountManager.ERROR_CODE_USER_RESTRICTED,\n                        \"User is not allowed to add an account!\");\n            } catch (RemoteException re) {\n            }\n            showCantAddAccount(AccountManager.ERROR_CODE_USER_RESTRICTED, userId);\n            return;\n        }\n        if (!canUserModifyAccountsForType(userId, accountType, uid)) {\n            try {\n                response.onError(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                        \"User cannot modify accounts of this type (policy).\");\n            } catch (RemoteException re) {\n            }\n            showCantAddAccount(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                    userId);\n            return;\n        }\n        final int pid = Binder.getCallingPid();\n        final Bundle options = (optionsIn == null) ? new Bundle() : optionsIn;\n        options.putInt(AccountManager.KEY_CALLER_UID, uid);\n        options.putInt(AccountManager.KEY_CALLER_PID, pid);\n\n        // Check to see if the Password should be included to the caller.\n        String callerPkg = options.getString(AccountManager.KEY_ANDROID_PACKAGE_NAME);\n        boolean isPasswordForwardingAllowed = checkPermissionAndNote(\n                callerPkg, uid, Manifest.permission.GET_PASSWORD);\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            logRecordWithUid(accounts, AccountsDb.DEBUG_ACTION_CALLED_START_ACCOUNT_ADD,\n                    AccountsDb.TABLE_ACCOUNTS, uid);\n            new StartAccountSession(\n                    accounts,\n                    response,\n                    accountType,\n                    expectActivityLaunch,\n                    null /* accountName */,\n                    false /* authDetailsRequired */,\n                    true /* updateLastAuthenticationTime */,\n                    isPasswordForwardingAllowed) {\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.startAddAccountSession(this, mAccountType, authTokenType,\n                            requiredFeatures, options);\n                    logAddAccountMetrics(callerPkg, accountType, requiredFeatures, authTokenType);\n                }\n\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now) + \", startAddAccountSession\" + \", accountType \"\n                            + accountType + \", requiredFeatures \"\n                            + (requiredFeatures != null\n                                ? TextUtils.join(\",\", requiredFeatures) : \"null\");\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    /** Session that will encrypt the KEY_ACCOUNT_SESSION_BUNDLE in result. */\n    private abstract class StartAccountSession extends Session {\n\n        private final boolean mIsPasswordForwardingAllowed;\n\n        public StartAccountSession(\n                UserAccounts accounts,\n                IAccountManagerResponse response,\n                String accountType,\n                boolean expectActivityLaunch,\n                String accountName,\n                boolean authDetailsRequired,\n                boolean updateLastAuthenticationTime,\n                boolean isPasswordForwardingAllowed) {\n            super(accounts, response, accountType, expectActivityLaunch,\n                    true /* stripAuthTokenFromResult */, accountName, authDetailsRequired,\n                    updateLastAuthenticationTime);\n            mIsPasswordForwardingAllowed = isPasswordForwardingAllowed;\n        }\n\n        @Override\n        public void onResult(Bundle result) {\n            Bundle.setDefusable(result, true);\n            mNumResults++;\n            Intent intent = null;\n            if (result != null) {\n                if (!checkKeyIntent(\n                        Binder.getCallingUid(),\n                        result)) {\n                    onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                            \"invalid intent in bundle returned\");\n                    return;\n                }\n            }\n            IAccountManagerResponse response;\n            if (mExpectActivityLaunch && result != null\n                    && result.containsKey(AccountManager.KEY_INTENT)) {\n                response = mResponse;\n            } else {\n                response = getResponseAndClose();\n            }\n            if (response == null) {\n                return;\n            }\n            if (result == null) {\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.v(TAG, getClass().getSimpleName() + \" calling onError() on response \"\n                            + response);\n                }\n                sendErrorResponse(response, AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                        \"null bundle returned\");\n                return;\n            }\n\n            if ((result.getInt(AccountManager.KEY_ERROR_CODE, -1) > 0) && (intent == null)) {\n                // All AccountManager error codes are greater\n                // than 0\n                sendErrorResponse(response, result.getInt(AccountManager.KEY_ERROR_CODE),\n                        result.getString(AccountManager.KEY_ERROR_MESSAGE));\n                return;\n            }\n\n            // Omit passwords if the caller isn't permitted to see them.\n            if (!mIsPasswordForwardingAllowed) {\n                result.remove(AccountManager.KEY_PASSWORD);\n            }\n\n            // Strip auth token from result.\n            result.remove(AccountManager.KEY_AUTHTOKEN);\n            if (!checkKeyIntent(Binder.getCallingUid(), result)) {\n                onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                        \"invalid intent in bundle returned\");\n                return;\n            }\n\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG,\n                        getClass().getSimpleName() + \" calling onResult() on response \" + response);\n            }\n\n            // Get the session bundle created by authenticator. The\n            // bundle contains data necessary for finishing the session\n            // later. The session bundle will be encrypted here and\n            // decrypted later when trying to finish the session.\n            Bundle sessionBundle = result.getBundle(AccountManager.KEY_ACCOUNT_SESSION_BUNDLE);\n            if (sessionBundle != null) {\n                String accountType = sessionBundle.getString(AccountManager.KEY_ACCOUNT_TYPE);\n                if (TextUtils.isEmpty(accountType)\n                        || !mAccountType.equalsIgnoreCase(accountType)) {\n                    Log.w(TAG, \"Account type in session bundle doesn't match request.\");\n                }\n                // Add accountType info to session bundle. This will\n                // override any value set by authenticator.\n                sessionBundle.putString(AccountManager.KEY_ACCOUNT_TYPE, mAccountType);\n\n                // Encrypt session bundle before returning to caller.\n                try {\n                    CryptoHelper cryptoHelper = CryptoHelper.getInstance();\n                    Bundle encryptedBundle = cryptoHelper.encryptBundle(sessionBundle);\n                    result.putBundle(AccountManager.KEY_ACCOUNT_SESSION_BUNDLE, encryptedBundle);\n                } catch (GeneralSecurityException e) {\n                    if (Log.isLoggable(TAG, Log.DEBUG)) {\n                        Log.v(TAG, \"Failed to encrypt session bundle!\", e);\n                    }\n                    sendErrorResponse(response, AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                            \"failed to encrypt session bundle\");\n                    return;\n                }\n            }\n\n            sendResponse(response, result);\n        }\n    }\n\n    @Override\n    public void finishSessionAsUser(IAccountManagerResponse response,\n            @NonNull Bundle sessionBundle,\n            boolean expectActivityLaunch,\n            Bundle appInfo,\n            int userId) {\n        Bundle.setDefusable(sessionBundle, true);\n        int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG,\n                    \"finishSession: response \"+ response\n                            + \", expectActivityLaunch \" + expectActivityLaunch\n                            + \", caller's uid \" + callingUid\n                            + \", caller's user id \" + UserHandle.getCallingUserId()\n                            + \", pid \" + Binder.getCallingPid()\n                            + \", for user id \" + userId);\n        }\n        Preconditions.checkArgument(response != null, \"response cannot be null\");\n        // Session bundle is the encrypted bundle of the original bundle created by authenticator.\n        // Account type is added to it before encryption.\n        if (sessionBundle == null || sessionBundle.size() == 0) {\n            throw new IllegalArgumentException(\"sessionBundle is empty\");\n        }\n\n        // Only allow the system process to finish session for other users.\n        if (isCrossUser(callingUid, userId)) {\n            throw new SecurityException(\n                    String.format(\n                            \"User %s trying to finish session for %s without cross user permission\",\n                            UserHandle.getCallingUserId(),\n                            userId));\n        }\n\n        if (!canUserModifyAccounts(userId, callingUid)) {\n            sendErrorResponse(response,\n                    AccountManager.ERROR_CODE_USER_RESTRICTED,\n                    \"User is not allowed to add an account!\");\n            showCantAddAccount(AccountManager.ERROR_CODE_USER_RESTRICTED, userId);\n            return;\n        }\n\n        final int pid = Binder.getCallingPid();\n        final Bundle decryptedBundle;\n        final String accountType;\n        // First decrypt session bundle to get account type for checking permission.\n        try {\n            CryptoHelper cryptoHelper = CryptoHelper.getInstance();\n            decryptedBundle = cryptoHelper.decryptBundle(sessionBundle);\n            if (decryptedBundle == null) {\n                sendErrorResponse(\n                        response,\n                        AccountManager.ERROR_CODE_BAD_REQUEST,\n                        \"failed to decrypt session bundle\");\n                return;\n            }\n            accountType = decryptedBundle.getString(AccountManager.KEY_ACCOUNT_TYPE);\n            // Account type cannot be null. This should not happen if session bundle was created\n            // properly by #StartAccountSession.\n            if (TextUtils.isEmpty(accountType)) {\n                sendErrorResponse(\n                        response,\n                        AccountManager.ERROR_CODE_BAD_ARGUMENTS,\n                        \"accountType is empty\");\n                return;\n            }\n\n            // If by any chances, decryptedBundle contains colliding keys with\n            // system info\n            // such as AccountManager.KEY_ANDROID_PACKAGE_NAME required by the add account flow or\n            // update credentials flow, we should replace with the new values of the current call.\n            if (appInfo != null) {\n                decryptedBundle.putAll(appInfo);\n            }\n\n            // Add info that may be used by add account or update credentials flow.\n            decryptedBundle.putInt(AccountManager.KEY_CALLER_UID, callingUid);\n            decryptedBundle.putInt(AccountManager.KEY_CALLER_PID, pid);\n        } catch (GeneralSecurityException e) {\n            if (Log.isLoggable(TAG, Log.DEBUG)) {\n                Log.v(TAG, \"Failed to decrypt session bundle!\", e);\n            }\n            sendErrorResponse(\n                    response,\n                    AccountManager.ERROR_CODE_BAD_REQUEST,\n                    \"failed to decrypt session bundle\");\n            return;\n        }\n\n        if (!canUserModifyAccountsForType(userId, accountType, callingUid)) {\n            sendErrorResponse(\n                    response,\n                    AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                    \"User cannot modify accounts of this type (policy).\");\n            showCantAddAccount(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                    userId);\n            return;\n        }\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            logRecordWithUid(\n                    accounts,\n                    AccountsDb.DEBUG_ACTION_CALLED_ACCOUNT_SESSION_FINISH,\n                    AccountsDb.TABLE_ACCOUNTS,\n                    callingUid);\n            new Session(\n                    accounts,\n                    response,\n                    accountType,\n                    expectActivityLaunch,\n                    true /* stripAuthTokenFromResult */,\n                    null /* accountName */,\n                    false /* authDetailsRequired */,\n                    true /* updateLastAuthenticationTime */) {\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.finishSession(this, mAccountType, decryptedBundle);\n                }\n\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now)\n                            + \", finishSession\"\n                            + \", accountType \" + accountType;\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private void showCantAddAccount(int errorCode, int userId) {\n        final DevicePolicyManagerInternal dpmi =\n                LocalServices.getService(DevicePolicyManagerInternal.class);\n        Intent intent = null;\n        if (dpmi == null) {\n            intent = getDefaultCantAddAccountIntent(errorCode);\n        } else if (errorCode == AccountManager.ERROR_CODE_USER_RESTRICTED) {\n            intent = dpmi.createUserRestrictionSupportIntent(userId,\n                    UserManager.DISALLOW_MODIFY_ACCOUNTS);\n        } else if (errorCode == AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE) {\n            intent = dpmi.createShowAdminSupportIntent(userId, false);\n        }\n        if (intent == null) {\n            intent = getDefaultCantAddAccountIntent(errorCode);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            mContext.startActivityAsUser(intent, new UserHandle(userId));\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    /**\n     * Called when we don't know precisely who is preventing us from adding an account.\n     */\n    private Intent getDefaultCantAddAccountIntent(int errorCode) {\n        Intent cantAddAccount = new Intent(mContext, CantAddAccountActivity.class);\n        cantAddAccount.putExtra(CantAddAccountActivity.EXTRA_ERROR_CODE, errorCode);\n        cantAddAccount.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        return cantAddAccount;\n    }\n\n    @Override\n    public void confirmCredentialsAsUser(\n            IAccountManagerResponse response,\n            final Account account,\n            final Bundle options,\n            final boolean expectActivityLaunch,\n            int userId) {\n        Bundle.setDefusable(options, true);\n        int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"confirmCredentials: \" + account\n                    + \", response \" + response\n                    + \", expectActivityLaunch \" + expectActivityLaunch\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        // Only allow the system process to read accounts of other users\n        if (isCrossUser(callingUid, userId)) {\n            throw new SecurityException(\n                    String.format(\n                            \"User %s trying to confirm account credentials for %s\" ,\n                            UserHandle.getCallingUserId(),\n                            userId));\n        }\n        if (response == null) throw new IllegalArgumentException(\"response is null\");\n        if (account == null) throw new IllegalArgumentException(\"account is null\");\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            new Session(accounts, response, account.type, expectActivityLaunch,\n                    true /* stripAuthTokenFromResult */, account.name,\n                    true /* authDetailsRequired */, true /* updateLastAuthenticatedTime */) {\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.confirmCredentials(this, account, options);\n                }\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now) + \", confirmCredentials\"\n                            + \", \" + account.toSafeString();\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void updateCredentials(IAccountManagerResponse response, final Account account,\n            final String authTokenType, final boolean expectActivityLaunch,\n            final Bundle loginOptions) {\n        Bundle.setDefusable(loginOptions, true);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"updateCredentials: \" + account\n                    + \", response \" + response\n                    + \", authTokenType \" + authTokenType\n                    + \", expectActivityLaunch \" + expectActivityLaunch\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        if (response == null) throw new IllegalArgumentException(\"response is null\");\n        if (account == null) throw new IllegalArgumentException(\"account is null\");\n        int userId = UserHandle.getCallingUserId();\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            new Session(accounts, response, account.type, expectActivityLaunch,\n                    true /* stripAuthTokenFromResult */, account.name,\n                    false /* authDetailsRequired */, true /* updateLastCredentialTime */) {\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.updateCredentials(this, account, authTokenType, loginOptions);\n                }\n                @Override\n                protected String toDebugString(long now) {\n                    if (loginOptions != null) loginOptions.keySet();\n                    return super.toDebugString(now) + \", updateCredentials\"\n                            + \", \" + account.toSafeString()\n                            + \", authTokenType \" + authTokenType\n                            + \", loginOptions \" + loginOptions;\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void startUpdateCredentialsSession(\n            IAccountManagerResponse response,\n            final Account account,\n            final String authTokenType,\n            final boolean expectActivityLaunch,\n            final Bundle loginOptions) {\n        Bundle.setDefusable(loginOptions, true);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG,\n                    \"startUpdateCredentialsSession: \" + account + \", response \" + response\n                            + \", authTokenType \" + authTokenType + \", expectActivityLaunch \"\n                            + expectActivityLaunch + \", caller's uid \" + Binder.getCallingUid()\n                            + \", pid \" + Binder.getCallingPid());\n        }\n        if (response == null) {\n            throw new IllegalArgumentException(\"response is null\");\n        }\n        if (account == null) {\n            throw new IllegalArgumentException(\"account is null\");\n        }\n\n        final int uid = Binder.getCallingUid();\n        int userId = UserHandle.getCallingUserId();\n\n        // Check to see if the Password should be included to the caller.\n        String callerPkg = loginOptions.getString(AccountManager.KEY_ANDROID_PACKAGE_NAME);\n        boolean isPasswordForwardingAllowed = checkPermissionAndNote(\n                callerPkg, uid, Manifest.permission.GET_PASSWORD);\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            new StartAccountSession(\n                    accounts,\n                    response,\n                    account.type,\n                    expectActivityLaunch,\n                    account.name,\n                    false /* authDetailsRequired */,\n                    true /* updateLastCredentialTime */,\n                    isPasswordForwardingAllowed) {\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.startUpdateCredentialsSession(this, account, authTokenType,\n                            loginOptions);\n                }\n\n                @Override\n                protected String toDebugString(long now) {\n                    if (loginOptions != null)\n                        loginOptions.keySet();\n                    return super.toDebugString(now)\n                            + \", startUpdateCredentialsSession\"\n                            + \", \" + account.toSafeString()\n                            + \", authTokenType \" + authTokenType\n                            + \", loginOptions \" + loginOptions;\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void isCredentialsUpdateSuggested(\n            IAccountManagerResponse response,\n            final Account account,\n            final String statusToken) {\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG,\n                    \"isCredentialsUpdateSuggested: \" + account + \", response \" + response\n                            + \", caller's uid \" + Binder.getCallingUid()\n                            + \", pid \" + Binder.getCallingPid());\n        }\n        if (response == null) {\n            throw new IllegalArgumentException(\"response is null\");\n        }\n        if (account == null) {\n            throw new IllegalArgumentException(\"account is null\");\n        }\n        if (TextUtils.isEmpty(statusToken)) {\n            throw new IllegalArgumentException(\"status token is empty\");\n        }\n\n        int usrId = UserHandle.getCallingUserId();\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(usrId);\n            new Session(accounts, response, account.type, false /* expectActivityLaunch */,\n                    false /* stripAuthTokenFromResult */, account.name,\n                    false /* authDetailsRequired */) {\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now) + \", isCredentialsUpdateSuggested\"\n                            + \", \" + account.toSafeString();\n                }\n\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.isCredentialsUpdateSuggested(this, account, statusToken);\n                }\n\n                @Override\n                public void onResult(Bundle result) {\n                    Bundle.setDefusable(result, true);\n                    IAccountManagerResponse response = getResponseAndClose();\n                    if (response == null) {\n                        return;\n                    }\n\n                    if (result == null) {\n                        sendErrorResponse(\n                                response,\n                                AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                                \"null bundle\");\n                        return;\n                    }\n\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, getClass().getSimpleName() + \" calling onResult() on response \"\n                                + response);\n                    }\n                    // Check to see if an error occurred. We know if an error occurred because all\n                    // error codes are greater than 0.\n                    if ((result.getInt(AccountManager.KEY_ERROR_CODE, -1) > 0)) {\n                        sendErrorResponse(response,\n                                result.getInt(AccountManager.KEY_ERROR_CODE),\n                                result.getString(AccountManager.KEY_ERROR_MESSAGE));\n                        return;\n                    }\n                    if (!result.containsKey(AccountManager.KEY_BOOLEAN_RESULT)) {\n                        sendErrorResponse(\n                                response,\n                                AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                                \"no result in response\");\n                        return;\n                    }\n                    final Bundle newResult = new Bundle();\n                    newResult.putBoolean(AccountManager.KEY_BOOLEAN_RESULT,\n                            result.getBoolean(AccountManager.KEY_BOOLEAN_RESULT, false));\n                    sendResponse(response, newResult);\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void editProperties(IAccountManagerResponse response, final String accountType,\n            final boolean expectActivityLaunch) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"editProperties: accountType \" + accountType\n                    + \", response \" + response\n                    + \", expectActivityLaunch \" + expectActivityLaunch\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        if (response == null) throw new IllegalArgumentException(\"response is null\");\n        if (accountType == null) throw new IllegalArgumentException(\"accountType is null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(accountType, callingUid, userId)\n                && !isSystemUid(callingUid)) {\n            String msg = String.format(\n                    \"uid %s cannot edit authenticator properites for account type: %s\",\n                    callingUid,\n                    accountType);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            new Session(accounts, response, accountType, expectActivityLaunch,\n                    true /* stripAuthTokenFromResult */, null /* accountName */,\n                    false /* authDetailsRequired */) {\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.editProperties(this, mAccountType);\n                }\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now) + \", editProperties\"\n                            + \", accountType \" + accountType;\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public boolean hasAccountAccess(@NonNull Account account,  @NonNull String packageName,\n            @NonNull UserHandle userHandle) {\n        if (UserHandle.getAppId(Binder.getCallingUid()) != Process.SYSTEM_UID) {\n            throw new SecurityException(\"Can be called only by system UID\");\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        Objects.requireNonNull(packageName, \"packageName cannot be null\");\n        Objects.requireNonNull(userHandle, \"userHandle cannot be null\");\n\n        final int userId = userHandle.getIdentifier();\n\n        Preconditions.checkArgumentInRange(userId, 0, Integer.MAX_VALUE, \"user must be concrete\");\n\n        try {\n            int uid = mPackageManager.getPackageUidAsUser(packageName, userId);\n            return hasAccountAccess(account, packageName, uid);\n        } catch (NameNotFoundException e) {\n            Log.w(TAG, \"hasAccountAccess#Package not found \" + e.getMessage());\n            return false;\n        }\n    }\n\n    // Returns package with oldest target SDK for given UID.\n    private String getPackageNameForUid(int uid) {\n        String[] packageNames = mPackageManager.getPackagesForUid(uid);\n        if (ArrayUtils.isEmpty(packageNames)) {\n            return null;\n        }\n        String packageName = packageNames[0];\n        if (packageNames.length == 1) {\n            return packageName;\n        }\n        // Due to visibility changes we want to use package with oldest target SDK\n        int oldestVersion = Integer.MAX_VALUE;\n        for (String name : packageNames) {\n            try {\n                ApplicationInfo applicationInfo = mPackageManager.getApplicationInfo(name, 0);\n                if (applicationInfo != null) {\n                    int version = applicationInfo.targetSdkVersion;\n                    if (version < oldestVersion) {\n                        oldestVersion = version;\n                        packageName = name;\n                    }\n                }\n            } catch (NameNotFoundException e) {\n                // skip\n            }\n        }\n        return packageName;\n    }\n\n    private boolean hasAccountAccess(@NonNull Account account, @Nullable String packageName,\n            int uid) {\n        if (packageName == null) {\n            packageName = getPackageNameForUid(uid);\n            if (packageName == null) {\n                return false;\n            }\n        }\n\n        // Use null token which means any token. Having a token means the package\n        // is trusted by the authenticator, hence it is fine to access the account.\n        if (permissionIsGranted(account, null, uid, UserHandle.getUserId(uid))) {\n            return true;\n        }\n        // In addition to the permissions required to get an auth token we also allow\n        // the account to be accessed by apps for which user or authenticator granted visibility.\n\n        int visibility = resolveAccountVisibility(account, packageName,\n            getUserAccounts(UserHandle.getUserId(uid)));\n        return (visibility == AccountManager.VISIBILITY_VISIBLE\n            || visibility == AccountManager.VISIBILITY_USER_MANAGED_VISIBLE);\n    }\n\n    @Override\n    public IntentSender createRequestAccountAccessIntentSenderAsUser(@NonNull Account account,\n            @NonNull String packageName, @NonNull UserHandle userHandle) {\n        if (UserHandle.getAppId(Binder.getCallingUid()) != Process.SYSTEM_UID) {\n            throw new SecurityException(\"Can be called only by system UID\");\n        }\n\n        Objects.requireNonNull(account, \"account cannot be null\");\n        Objects.requireNonNull(packageName, \"packageName cannot be null\");\n        Objects.requireNonNull(userHandle, \"userHandle cannot be null\");\n\n        final int userId = userHandle.getIdentifier();\n\n        Preconditions.checkArgumentInRange(userId, 0, Integer.MAX_VALUE, \"user must be concrete\");\n\n        final int uid;\n        try {\n            uid = mPackageManager.getPackageUidAsUser(packageName, userId);\n        } catch (NameNotFoundException e) {\n            Slog.e(TAG, \"Unknown package \" + packageName);\n            return null;\n        }\n\n        Intent intent = newRequestAccountAccessIntent(account, packageName, uid, null);\n\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            return PendingIntent.getActivityAsUser(\n                    mContext, 0, intent, PendingIntent.FLAG_ONE_SHOT\n                            | PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_IMMUTABLE,\n                    null, new UserHandle(userId)).getIntentSender();\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    private Intent newRequestAccountAccessIntent(Account account, String packageName,\n            int uid, RemoteCallback callback) {\n        return newGrantCredentialsPermissionIntent(account, packageName, uid,\n                new AccountAuthenticatorResponse(new IAccountAuthenticatorResponse.Stub() {\n            @Override\n            public void onResult(Bundle value) throws RemoteException {\n                handleAuthenticatorResponse(true);\n            }\n\n            @Override\n            public void onRequestContinued() {\n                /* ignore */\n            }\n\n            @Override\n            public void onError(int errorCode, String errorMessage) throws RemoteException {\n                handleAuthenticatorResponse(false);\n            }\n\n            private void handleAuthenticatorResponse(boolean accessGranted) throws RemoteException {\n                UserAccounts userAccounts = getUserAccounts(UserHandle.getUserId(uid));\n                cancelNotification(getCredentialPermissionNotificationId(account,\n                        AccountManager.ACCOUNT_ACCESS_TOKEN_TYPE, uid, userAccounts), userAccounts);\n                if (callback != null) {\n                    Bundle result = new Bundle();\n                    result.putBoolean(AccountManager.KEY_BOOLEAN_RESULT, accessGranted);\n                    callback.sendResult(result);\n                }\n            }\n        }), AccountManager.ACCOUNT_ACCESS_TOKEN_TYPE, false);\n    }\n\n    @Override\n    public boolean someUserHasAccount(@NonNull final Account account) {\n        if (!UserHandle.isSameApp(Process.SYSTEM_UID, Binder.getCallingUid())) {\n            throw new SecurityException(\"Only system can check for accounts across users\");\n        }\n        final long token = Binder.clearCallingIdentity();\n        try {\n            AccountAndUser[] allAccounts = getAllAccountsForSystemProcess();\n            for (int i = allAccounts.length - 1; i >= 0; i--) {\n                if (allAccounts[i].account.equals(account)) {\n                    return true;\n                }\n            }\n            return false;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private class GetAccountsByTypeAndFeatureSession extends Session {\n        private final String[] mFeatures;\n        private volatile Account[] mAccountsOfType = null;\n        private volatile ArrayList<Account> mAccountsWithFeatures = null;\n        private volatile int mCurrentAccount = 0;\n        private final int mCallingUid;\n        private final String mPackageName;\n        private final boolean mIncludeManagedNotVisible;\n\n        public GetAccountsByTypeAndFeatureSession(\n                UserAccounts accounts,\n                IAccountManagerResponse response,\n                String type,\n                String[] features,\n                int callingUid,\n                String packageName,\n                boolean includeManagedNotVisible) {\n            super(accounts, response, type, false /* expectActivityLaunch */,\n                    true /* stripAuthTokenFromResult */, null /* accountName */,\n                    false /* authDetailsRequired */);\n            mCallingUid = callingUid;\n            mFeatures = features;\n            mPackageName = packageName;\n            mIncludeManagedNotVisible = includeManagedNotVisible;\n        }\n\n        @Override\n        public void run() throws RemoteException {\n            mAccountsOfType = getAccountsFromCache(mAccounts, mAccountType,\n                    mCallingUid, mPackageName, mIncludeManagedNotVisible);\n            // check whether each account matches the requested features\n            mAccountsWithFeatures = new ArrayList<>(mAccountsOfType.length);\n            mCurrentAccount = 0;\n\n            checkAccount();\n        }\n\n        public void checkAccount() {\n            if (mCurrentAccount >= mAccountsOfType.length) {\n                sendResult();\n                return;\n            }\n\n            final IAccountAuthenticator accountAuthenticator = mAuthenticator;\n            if (accountAuthenticator == null) {\n                // It is possible that the authenticator has died, which is indicated by\n                // mAuthenticator being set to null. If this happens then just abort.\n                // There is no need to send back a result or error in this case since\n                // that already happened when mAuthenticator was cleared.\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.v(TAG, \"checkAccount: aborting session since we are no longer\"\n                            + \" connected to the authenticator, \" + toDebugString());\n                }\n                return;\n            }\n            try {\n                accountAuthenticator.hasFeatures(this, mAccountsOfType[mCurrentAccount], mFeatures);\n            } catch (RemoteException e) {\n                onError(AccountManager.ERROR_CODE_REMOTE_EXCEPTION, \"remote exception\");\n            }\n        }\n\n        @Override\n        public void onResult(Bundle result) {\n            Bundle.setDefusable(result, true);\n            mNumResults++;\n            if (result == null) {\n                onError(AccountManager.ERROR_CODE_INVALID_RESPONSE, \"null bundle\");\n                return;\n            }\n            if (result.getBoolean(AccountManager.KEY_BOOLEAN_RESULT, false)) {\n                mAccountsWithFeatures.add(mAccountsOfType[mCurrentAccount]);\n            }\n            mCurrentAccount++;\n            checkAccount();\n        }\n\n        public void sendResult() {\n            IAccountManagerResponse response = getResponseAndClose();\n            if (response != null) {\n                try {\n                    Account[] accounts = new Account[mAccountsWithFeatures.size()];\n                    for (int i = 0; i < accounts.length; i++) {\n                        accounts[i] = mAccountsWithFeatures.get(i);\n                    }\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, getClass().getSimpleName() + \" calling onResult() on response \"\n                                + response);\n                    }\n                    Bundle result = new Bundle();\n                    result.putParcelableArray(AccountManager.KEY_ACCOUNTS, accounts);\n                    response.onResult(result);\n                } catch (RemoteException e) {\n                    // if the caller is dead then there is no one to care about remote exceptions\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, \"failure while notifying response\", e);\n                    }\n                }\n            }\n        }\n\n        @Override\n        protected String toDebugString(long now) {\n            return super.toDebugString(now) + \", getAccountsByTypeAndFeatures\"\n                    + \", \" + (mFeatures != null ? TextUtils.join(\",\", mFeatures) : null);\n        }\n    }\n\n    /**\n     * Returns the accounts visible to the client within the context of a specific user\n     * @hide\n     */\n    @NonNull\n    public Account[] getAccounts(int userId, String opPackageName) {\n        int callingUid = Binder.getCallingUid();\n        mAppOpsManager.checkPackage(callingUid, opPackageName);\n        List<String> visibleAccountTypes = getTypesVisibleToCaller(callingUid, userId,\n                opPackageName);\n        if (visibleAccountTypes.isEmpty()) {\n            return EMPTY_ACCOUNT_ARRAY;\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return getAccountsInternal(\n                    accounts,\n                    callingUid,\n                    opPackageName,\n                    visibleAccountTypes,\n                    false /* includeUserManagedNotVisible */);\n        } catch (SQLiteException e) {\n            Log.w(TAG, \"Could not get accounts for user \" + userId, e);\n            return new Account[]{};\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    /**\n     * Returns accounts for all running users, ignores visibility values.\n     *\n     * Should only be called by System process.\n     * @hide\n     */\n    @NonNull\n    public AccountAndUser[] getRunningAccountsForSystem() {\n        final int[] runningUserIds;\n        try {\n            runningUserIds = ActivityManager.getService().getRunningUserIds();\n        } catch (RemoteException e) {\n            // Running in system_server; should never happen\n            throw new RuntimeException(e);\n        }\n        return getAccountsForSystem(runningUserIds);\n    }\n\n    /**\n     * Returns accounts for all users, ignores visibility values.\n     *\n     * Should only be called by system process\n     *\n     * @hide\n     */\n    @NonNull\n    public AccountAndUser[] getAllAccountsForSystemProcess() {\n        final List<UserInfo> users = getUserManager().getAliveUsers();\n        final int[] userIds = new int[users.size()];\n        for (int i = 0; i < userIds.length; i++) {\n            userIds[i] = users.get(i).id;\n        }\n        return getAccountsForSystem(userIds);\n    }\n\n    /**\n     * Returns all accounts for the given user, ignores all visibility checks.\n     * This should only be called by system process.\n     *\n     * @hide\n     */\n    @NonNull\n    private AccountAndUser[] getAccountsForSystem(int[] userIds) {\n        final ArrayList<AccountAndUser> runningAccounts = Lists.newArrayList();\n        for (int userId : userIds) {\n            UserAccounts userAccounts = getUserAccounts(userId);\n            if (userAccounts == null) continue;\n            Account[] accounts = getAccountsFromCache(\n                    userAccounts,\n                    null /* type */,\n                    Binder.getCallingUid(),\n                    \"android\"/* packageName */,\n                    false /* include managed not visible*/);\n            for (Account account : accounts) {\n                runningAccounts.add(new AccountAndUser(account, userId));\n            }\n        }\n\n        AccountAndUser[] accountsArray = new AccountAndUser[runningAccounts.size()];\n        return runningAccounts.toArray(accountsArray);\n    }\n\n    @Override\n    @NonNull\n    public Account[] getAccountsAsUser(String type, int userId, String opPackageName) {\n        int callingUid = Binder.getCallingUid();\n        mAppOpsManager.checkPackage(callingUid, opPackageName);\n        try {\n            return getAccountsAsUserForPackage(type, userId, opPackageName /* callingPackage */, -1,\n                    opPackageName, false /* includeUserManagedNotVisible */);\n        } catch (SQLiteException e) {\n            Log.e(TAG, \"Could not get accounts for user \" + userId, e);\n            return new Account[]{};\n        }\n    }\n\n    @NonNull\n    private Account[] getAccountsOrEmptyArray(String type, int userId, String opPackageName) {\n        try {\n            return getAccountsAsUser(type, userId, opPackageName);\n        } catch (SQLiteException e) {\n            Log.w(TAG, \"Could not get accounts for user \" + userId, e);\n            return new Account[]{};\n        }\n    }\n\n    @NonNull\n    private Account[] getAccountsAsUserForPackage(\n            String type,\n            int userId,\n            String callingPackage,\n            int packageUid,\n            String opPackageName,\n            boolean includeUserManagedNotVisible) {\n        int callingUid = Binder.getCallingUid();\n        // Only allow the system process to read accounts of other users\n        if (userId != UserHandle.getCallingUserId()\n                && callingUid != Process.SYSTEM_UID\n                && mContext.checkCallingOrSelfPermission(\n                    android.Manifest.permission.INTERACT_ACROSS_USERS_FULL)\n                    != PackageManager.PERMISSION_GRANTED) {\n            throw new SecurityException(\"User \" + UserHandle.getCallingUserId()\n                    + \" trying to get account for \" + userId);\n        }\n\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"getAccounts: accountType \" + type\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid());\n        }\n\n        // If the original calling app was using account choosing activity\n        // provided by the framework or authenticator we'll passing in\n        // the original caller's uid here, which is what should be used for filtering.\n        List<String> managedTypes =\n                getTypesManagedByCaller(callingUid, UserHandle.getUserId(callingUid));\n        if (packageUid != -1 &&\n                ((UserHandle.isSameApp(callingUid, Process.SYSTEM_UID)\n                || (type != null && managedTypes.contains(type))))) {\n            callingUid = packageUid;\n            opPackageName = callingPackage;\n        }\n        List<String> visibleAccountTypes = getTypesVisibleToCaller(callingUid, userId,\n                opPackageName);\n        if (visibleAccountTypes.isEmpty()\n                || (type != null && !visibleAccountTypes.contains(type))) {\n            return EMPTY_ACCOUNT_ARRAY;\n        } else if (visibleAccountTypes.contains(type)) {\n            // Prune the list down to just the requested type.\n            visibleAccountTypes = new ArrayList<>();\n            visibleAccountTypes.add(type);\n        } // else aggregate all the visible accounts (it won't matter if the\n          // list is empty).\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return getAccountsInternal(\n                    accounts,\n                    callingUid,\n                    opPackageName,\n                    visibleAccountTypes,\n                    includeUserManagedNotVisible);\n        } catch (SQLiteException e) {\n            Log.w(TAG, \"Could not get accounts for user \" + userId, e);\n            return new Account[]{};\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @NonNull\n    private Account[] getAccountsInternal(\n            UserAccounts userAccounts,\n            int callingUid,\n            String callingPackage,\n            List<String> visibleAccountTypes,\n            boolean includeUserManagedNotVisible) {\n        ArrayList<Account> visibleAccounts = new ArrayList<>();\n        for (String visibleType : visibleAccountTypes) {\n            Account[] accountsForType = getAccountsFromCache(\n                    userAccounts, visibleType, callingUid, callingPackage,\n                    includeUserManagedNotVisible);\n            if (accountsForType != null) {\n                visibleAccounts.addAll(Arrays.asList(accountsForType));\n            }\n        }\n        Account[] result = new Account[visibleAccounts.size()];\n        for (int i = 0; i < visibleAccounts.size(); i++) {\n            result[i] = visibleAccounts.get(i);\n        }\n        return result;\n    }\n\n    @Override\n    public void addSharedAccountsFromParentUser(int parentUserId, int userId,\n            String opPackageName) {\n        checkManageOrCreateUsersPermission(\"addSharedAccountsFromParentUser\");\n        Account[] accounts = getAccountsOrEmptyArray(null, parentUserId, opPackageName);\n        for (Account account : accounts) {\n            addSharedAccountAsUser(account, userId);\n        }\n    }\n\n    private boolean addSharedAccountAsUser(Account account, int userId) {\n        userId = handleIncomingUser(userId);\n        UserAccounts accounts = getUserAccounts(userId);\n        accounts.accountsDb.deleteSharedAccount(account);\n        long accountId = accounts.accountsDb.insertSharedAccount(account);\n        if (accountId < 0) {\n            Log.w(TAG, \"insertAccountIntoDatabase: \" + account.toSafeString()\n                    + \", skipping the DB insert failed\");\n            return false;\n        }\n        logRecord(AccountsDb.DEBUG_ACTION_ACCOUNT_ADD, AccountsDb.TABLE_SHARED_ACCOUNTS, accountId,\n                accounts);\n        return true;\n    }\n\n    public boolean renameSharedAccountAsUser(Account account, String newName, int userId) {\n        userId = handleIncomingUser(userId);\n        UserAccounts accounts = getUserAccounts(userId);\n        long sharedTableAccountId = accounts.accountsDb.findSharedAccountId(account);\n        int r = accounts.accountsDb.renameSharedAccount(account, newName);\n        if (r > 0) {\n            int callingUid = getCallingUid();\n            logRecord(AccountsDb.DEBUG_ACTION_ACCOUNT_RENAME, AccountsDb.TABLE_SHARED_ACCOUNTS,\n                    sharedTableAccountId, accounts, callingUid);\n            // Recursively rename the account.\n            renameAccountInternal(accounts, account, newName);\n        }\n        return r > 0;\n    }\n\n    public boolean removeSharedAccountAsUser(Account account, int userId) {\n        return removeSharedAccountAsUser(account, userId, getCallingUid());\n    }\n\n    private boolean removeSharedAccountAsUser(Account account, int userId, int callingUid) {\n        userId = handleIncomingUser(userId);\n        UserAccounts accounts = getUserAccounts(userId);\n        long sharedTableAccountId = accounts.accountsDb.findSharedAccountId(account);\n        boolean deleted = accounts.accountsDb.deleteSharedAccount(account);\n        if (deleted) {\n            logRecord(AccountsDb.DEBUG_ACTION_ACCOUNT_REMOVE, AccountsDb.TABLE_SHARED_ACCOUNTS,\n                    sharedTableAccountId, accounts, callingUid);\n            removeAccountInternal(accounts, account, callingUid);\n        }\n        return deleted;\n    }\n\n    public Account[] getSharedAccountsAsUser(int userId) {\n        userId = handleIncomingUser(userId);\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            synchronized (accounts.dbLock) {\n                List<Account> accountList = accounts.accountsDb.getSharedAccounts();\n                Account[] accountArray = new Account[accountList.size()];\n                accountList.toArray(accountArray);\n                return accountArray;\n            }\n        } catch (SQLiteException e) {\n            Log.w(TAG, \"Could not get shared accounts for user \" + userId, e);\n            return new Account[]{};\n        }\n    }\n\n    @Override\n    @NonNull\n    public Account[] getAccountsForPackage(String packageName, int uid, String opPackageName) {\n        int callingUid = Binder.getCallingUid();\n        if (!UserHandle.isSameApp(callingUid, Process.SYSTEM_UID)) {\n            // Don't do opPackageName check - caller is system.\n            throw new SecurityException(\"getAccountsForPackage() called from unauthorized uid \"\n                    + callingUid + \" with uid=\" + uid);\n        }\n        return getAccountsAsUserForPackage(null, UserHandle.getCallingUserId(), packageName, uid,\n                opPackageName, true /* includeUserManagedNotVisible */);\n    }\n\n    @Override\n    @NonNull\n    public Account[] getAccountsByTypeForPackage(String type, String packageName,\n            String opPackageName) {\n        int callingUid =  Binder.getCallingUid();\n        int userId = UserHandle.getCallingUserId();\n        mAppOpsManager.checkPackage(callingUid, opPackageName);\n        int packageUid = -1;\n        try {\n            packageUid = mPackageManager.getPackageUidAsUser(packageName, userId);\n        } catch (NameNotFoundException re) {\n            Slog.e(TAG, \"Couldn't determine the packageUid for \" + packageName + re);\n            return EMPTY_ACCOUNT_ARRAY;\n        }\n        if (!UserHandle.isSameApp(callingUid, Process.SYSTEM_UID)\n                && (type != null && !isAccountManagedByCaller(type, callingUid, userId))) {\n                return EMPTY_ACCOUNT_ARRAY;\n        }\n        if (!UserHandle.isSameApp(callingUid, Process.SYSTEM_UID) && type == null) {\n            return getAccountsAsUserForPackage(type, userId,\n                packageName, packageUid, opPackageName, false /* includeUserManagedNotVisible */);\n        }\n        return getAccountsAsUserForPackage(type, userId,\n                packageName, packageUid, opPackageName, true /* includeUserManagedNotVisible */);\n    }\n\n    private boolean needToStartChooseAccountActivity(Account[] accounts, String callingPackage) {\n        if (accounts.length < 1) return false;\n        if (accounts.length > 1) return true;\n        Account account = accounts[0];\n        UserAccounts userAccounts = getUserAccounts(UserHandle.getCallingUserId());\n        int visibility = resolveAccountVisibility(account, callingPackage, userAccounts);\n        if (visibility == AccountManager.VISIBILITY_USER_MANAGED_NOT_VISIBLE) return true;\n        return false;\n    }\n\n    private void startChooseAccountActivityWithAccounts(\n        IAccountManagerResponse response, Account[] accounts, String callingPackage) {\n        Intent intent = new Intent(mContext, ChooseAccountActivity.class);\n        intent.putExtra(AccountManager.KEY_ACCOUNTS, accounts);\n        intent.putExtra(AccountManager.KEY_ACCOUNT_MANAGER_RESPONSE,\n                new AccountManagerResponse(response));\n        intent.putExtra(AccountManager.KEY_ANDROID_PACKAGE_NAME, callingPackage);\n\n        mContext.startActivityAsUser(intent, UserHandle.of(UserHandle.getCallingUserId()));\n    }\n\n    private void handleGetAccountsResult(\n        IAccountManagerResponse response,\n        Account[] accounts,\n        String callingPackage) {\n\n        if (needToStartChooseAccountActivity(accounts, callingPackage)) {\n            startChooseAccountActivityWithAccounts(response, accounts, callingPackage);\n            return;\n        }\n        if (accounts.length == 1) {\n            Bundle bundle = new Bundle();\n            bundle.putString(AccountManager.KEY_ACCOUNT_NAME, accounts[0].name);\n            bundle.putString(AccountManager.KEY_ACCOUNT_TYPE, accounts[0].type);\n            onResult(response, bundle);\n            return;\n        }\n        // No qualified account exists, return an empty Bundle.\n        onResult(response, new Bundle());\n    }\n\n    @Override\n    public void getAccountByTypeAndFeatures(\n        IAccountManagerResponse response,\n        String accountType,\n        String[] features,\n        String opPackageName) {\n\n        int callingUid = Binder.getCallingUid();\n        mAppOpsManager.checkPackage(callingUid, opPackageName);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"getAccount: accountType \" + accountType\n                    + \", response \" + response\n                    + \", features \" + Arrays.toString(features)\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        if (response == null) throw new IllegalArgumentException(\"response is null\");\n        if (accountType == null) throw new IllegalArgumentException(\"accountType is null\");\n\n        int userId = UserHandle.getCallingUserId();\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts userAccounts = getUserAccounts(userId);\n            if (ArrayUtils.isEmpty(features)) {\n                Account[] accountsWithManagedNotVisible = getAccountsFromCache(\n                    userAccounts, accountType, callingUid, opPackageName,\n                    true /* include managed not visible */);\n                handleGetAccountsResult(\n                    response, accountsWithManagedNotVisible, opPackageName);\n                return;\n            }\n\n            IAccountManagerResponse retrieveAccountsResponse =\n                new IAccountManagerResponse.Stub() {\n                @Override\n                public void onResult(Bundle value) throws RemoteException {\n                    Parcelable[] parcelables = value.getParcelableArray(\n                        AccountManager.KEY_ACCOUNTS);\n                    Account[] accounts = new Account[parcelables.length];\n                    for (int i = 0; i < parcelables.length; i++) {\n                        accounts[i] = (Account) parcelables[i];\n                    }\n                    handleGetAccountsResult(\n                        response, accounts, opPackageName);\n                }\n\n                @Override\n                public void onError(int errorCode, String errorMessage)\n                        throws RemoteException {\n                    // Will not be called in this case.\n                }\n            };\n            new GetAccountsByTypeAndFeatureSession(\n                    userAccounts,\n                    retrieveAccountsResponse,\n                    accountType,\n                    features,\n                    callingUid,\n                    opPackageName,\n                    true /* include managed not visible */).bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void getAccountsByFeatures(\n            IAccountManagerResponse response,\n            String type,\n            String[] features,\n            String opPackageName) {\n        int callingUid = Binder.getCallingUid();\n        mAppOpsManager.checkPackage(callingUid, opPackageName);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"getAccounts: accountType \" + type\n                    + \", response \" + response\n                    + \", features \" + Arrays.toString(features)\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        if (response == null) throw new IllegalArgumentException(\"response is null\");\n        if (type == null) throw new IllegalArgumentException(\"accountType is null\");\n        int userId = UserHandle.getCallingUserId();\n\n        List<String> visibleAccountTypes = getTypesVisibleToCaller(callingUid, userId,\n                opPackageName);\n        if (!visibleAccountTypes.contains(type)) {\n            Bundle result = new Bundle();\n            // Need to return just the accounts that are from matching signatures.\n            result.putParcelableArray(AccountManager.KEY_ACCOUNTS, EMPTY_ACCOUNT_ARRAY);\n            try {\n                response.onResult(result);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Cannot respond to caller do to exception.\" , e);\n            }\n            return;\n        }\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts userAccounts = getUserAccounts(userId);\n            if (features == null || features.length == 0) {\n                Account[] accounts = getAccountsFromCache(userAccounts, type, callingUid,\n                        opPackageName, false);\n                Bundle result = new Bundle();\n                result.putParcelableArray(AccountManager.KEY_ACCOUNTS, accounts);\n                onResult(response, result);\n                return;\n            }\n            new GetAccountsByTypeAndFeatureSession(\n                    userAccounts,\n                    response,\n                    type,\n                    features,\n                    callingUid,\n                    opPackageName,\n                    false /* include managed not visible */).bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void onAccountAccessed(String token) throws RemoteException {\n        final int uid = Binder.getCallingUid();\n        if (UserHandle.getAppId(uid) == Process.SYSTEM_UID) {\n            return;\n        }\n        final int userId = UserHandle.getCallingUserId();\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            for (Account account : getAccounts(userId, mContext.getOpPackageName())) {\n                if (Objects.equals(account.getAccessId(), token)) {\n                    // An app just accessed the account. At this point it knows about\n                    // it and there is not need to hide this account from the app.\n                    // Do we need to update account visibility here?\n                    if (!hasAccountAccess(account, null, uid)) {\n                        updateAppPermission(account, AccountManager.ACCOUNT_ACCESS_TOKEN_TYPE,\n                                uid, true);\n                    }\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    @Override\n    public void onShellCommand(FileDescriptor in, FileDescriptor out,\n            FileDescriptor err, String[] args, ShellCallback callback,\n            ResultReceiver resultReceiver) {\n        new AccountManagerServiceShellCommand(this).exec(this, in, out, err, args,\n                callback, resultReceiver);\n    }\n\n    private abstract class Session extends IAccountAuthenticatorResponse.Stub\n            implements IBinder.DeathRecipient, ServiceConnection {\n        private final Object mSessionLock = new Object();\n        IAccountManagerResponse mResponse;\n        final String mAccountType;\n        final boolean mExpectActivityLaunch;\n        final long mCreationTime;\n        final String mAccountName;\n        // Indicates if we need to add auth details(like last credential time)\n        final boolean mAuthDetailsRequired;\n        // If set, we need to update the last authenticated time. This is\n        // currently\n        // used on\n        // successful confirming credentials.\n        final boolean mUpdateLastAuthenticatedTime;\n\n        public int mNumResults = 0;\n        private int mNumRequestContinued = 0;\n        private int mNumErrors = 0;\n\n        IAccountAuthenticator mAuthenticator = null;\n\n        private final boolean mStripAuthTokenFromResult;\n        protected boolean mCanStartAccountManagerActivity = false;\n        protected final UserAccounts mAccounts;\n\n        private int mAuthenticatorUid;\n        private long mBindingStartTime;\n\n        public Session(UserAccounts accounts, IAccountManagerResponse response, String accountType,\n                boolean expectActivityLaunch, boolean stripAuthTokenFromResult, String accountName,\n                boolean authDetailsRequired) {\n            this(accounts, response, accountType, expectActivityLaunch, stripAuthTokenFromResult,\n                    accountName, authDetailsRequired, false /* updateLastAuthenticatedTime */);\n        }\n\n        public Session(UserAccounts accounts, IAccountManagerResponse response, String accountType,\n                boolean expectActivityLaunch, boolean stripAuthTokenFromResult, String accountName,\n                boolean authDetailsRequired, boolean updateLastAuthenticatedTime) {\n            super();\n            //if (response == null) throw new IllegalArgumentException(\"response is null\");\n            if (accountType == null) throw new IllegalArgumentException(\"accountType is null\");\n            mAccounts = accounts;\n            mStripAuthTokenFromResult = stripAuthTokenFromResult;\n            mAccountType = accountType;\n            mExpectActivityLaunch = expectActivityLaunch;\n            mCreationTime = SystemClock.elapsedRealtime();\n            mAccountName = accountName;\n            mAuthDetailsRequired = authDetailsRequired;\n            mUpdateLastAuthenticatedTime = updateLastAuthenticatedTime;\n\n            synchronized (mSessions) {\n                mSessions.put(toString(), this);\n            }\n            scheduleTimeout();\n            if (response != null) {\n                try {\n                    response.asBinder().linkToDeath(this, 0 /* flags */);\n                    mResponse = response;\n                } catch (RemoteException e) {\n                    binderDied();\n                }\n            }\n        }\n\n        IAccountManagerResponse getResponseAndClose() {\n            if (mAuthenticatorUid != 0 && mBindingStartTime > 0) {\n                sResponseLatency.logSampleWithUid(mAuthenticatorUid,\n                        SystemClock.uptimeMillis() - mBindingStartTime);\n            }\n            if (mResponse == null) {\n                close();\n                return null;\n            }\n            IAccountManagerResponse response = mResponse;\n            close(); // this clears mResponse so we need to save the response before this call\n            return response;\n        }\n\n        /**\n         * Checks Intents, supplied via KEY_INTENT, to make sure that they don't violate our\n         * security policy.\n         *\n         * In particular we want to make sure that the Authenticator doesn't try to trick users\n         * into launching arbitrary intents on the device via by tricking to click authenticator\n         * supplied entries in the system Settings app.\n         */\n        protected boolean checkKeyIntent(int authUid, Bundle bundle) {\n            if (!checkKeyIntentParceledCorrectly(bundle)) {\n                EventLog.writeEvent(0x534e4554, \"250588548\", authUid, \"\");\n                return false;\n            }\n            Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT, Intent.class);\n            if (intent == null) {\n                return true;\n            }\n            // Explicitly set an empty ClipData to ensure that we don't offer to\n            // promote any Uris contained inside for granting purposes\n            if (intent.getClipData() == null) {\n                intent.setClipData(ClipData.newPlainText(null, null));\n            }\n            final long bid = Binder.clearCallingIdentity();\n            try {\n                PackageManager pm = mContext.getPackageManager();\n                ResolveInfo resolveInfo = pm.resolveActivityAsUser(intent, 0, mAccounts.userId);\n                if (resolveInfo == null) {\n                    return false;\n                }\n                if (\"content\".equals(intent.getScheme())) {\n                    return false;\n                }\n                ActivityInfo targetActivityInfo = resolveInfo.activityInfo;\n                int targetUid = targetActivityInfo.applicationInfo.uid;\n                PackageManagerInternal pmi = LocalServices.getService(PackageManagerInternal.class);\n                if (!isExportedSystemActivity(targetActivityInfo)\n                        && !pmi.hasSignatureCapability(targetUid, authUid, CertCapabilities.AUTH)) {\n                    String pkgName = targetActivityInfo.packageName;\n                    String activityName = targetActivityInfo.name;\n                    String tmpl = \"KEY_INTENT resolved to an Activity (%s) in a package (%s) that \"\n                            + \"does not share a signature with the supplying authenticator (%s).\";\n                    Log.e(TAG, String.format(tmpl, activityName, pkgName, mAccountType));\n                    return false;\n                }\n                intent.setComponent(targetActivityInfo.getComponentName());\n                bundle.putParcelable(AccountManager.KEY_INTENT, intent);\n                return true;\n            } finally {\n                Binder.restoreCallingIdentity(bid);\n            }\n        }\n\n        /**\n         * Simulate the client side's deserialization of KEY_INTENT value, to make sure they don't\n         * violate our security policy.\n         *\n         * In particular we want to make sure the Authenticator doesn't trick users\n         * into launching arbitrary intents on the device via exploiting any other Parcel read/write\n         * mismatch problems.\n         */\n        private boolean checkKeyIntentParceledCorrectly(Bundle bundle) {\n            Parcel p = Parcel.obtain();\n            p.writeBundle(bundle);\n            p.setDataPosition(0);\n            Bundle simulateBundle = p.readBundle();\n            p.recycle();\n            Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT, Intent.class);\n            Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT,\n                    Intent.class);\n            if (intent == null) {\n                return (simulateIntent == null);\n            }\n            if (intent.getClass() != Intent.class || simulateIntent.getClass() != Intent.class) {\n                return false;\n            }\n\n            if (!intent.filterEquals(simulateIntent)) {\n                return false;\n            }\n\n            if (intent.getSelector() != simulateIntent.getSelector()) {\n                return false;\n            }\n\n            int prohibitedFlags = Intent.FLAG_GRANT_READ_URI_PERMISSION\n                    | Intent.FLAG_GRANT_WRITE_URI_PERMISSION\n                    | Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION\n                    | Intent.FLAG_GRANT_PREFIX_URI_PERMISSION;\n            return (simulateIntent.getFlags() & prohibitedFlags) == 0;\n        }\n\n        private boolean isExportedSystemActivity(ActivityInfo activityInfo) {\n            String className = activityInfo.name;\n            if (!\"android\".equals(activityInfo.packageName)) {\n                return false;\n\n            }\n            return (mCanStartAccountManagerActivity\n                    && GrantCredentialsPermissionActivity.class.getName().equals(className))\n                    || CantAddAccountActivity.class.getName().equals(className);\n        }\n\n        private void close() {\n            synchronized (mSessions) {\n                if (mSessions.remove(toString()) == null) {\n                    // the session was already closed, so bail out now\n                    return;\n                }\n            }\n            if (mResponse != null) {\n                // stop listening for response deaths\n                mResponse.asBinder().unlinkToDeath(this, 0 /* flags */);\n\n                // clear this so that we don't accidentally send any further results\n                mResponse = null;\n            }\n            cancelTimeout();\n            unbind();\n        }\n\n        @Override\n        public void binderDied() {\n            mResponse = null;\n            close();\n        }\n\n        protected String toDebugString() {\n            return toDebugString(SystemClock.elapsedRealtime());\n        }\n\n        protected String toDebugString(long now) {\n            return \"Session: expectLaunch \" + mExpectActivityLaunch\n                    + \", connected \" + (mAuthenticator != null)\n                    + \", stats (\" + mNumResults + \"/\" + mNumRequestContinued\n                    + \"/\" + mNumErrors + \")\"\n                    + \", lifetime \" + ((now - mCreationTime) / 1000.0);\n        }\n\n        void bind() {\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"initiating bind to authenticator type \" + mAccountType);\n            }\n            if (!bindToAuthenticator(mAccountType)) {\n                Log.w(TAG, \"bind attempt failed for \" + toDebugString());\n                onError(AccountManager.ERROR_CODE_REMOTE_EXCEPTION, \"bind failure\");\n            }\n        }\n\n        private void unbind() {\n            synchronized (mSessionLock) {\n                if (mAuthenticator != null) {\n                    mAuthenticator = null;\n                    mContext.unbindService(this);\n                }\n            }\n        }\n\n        private void scheduleTimeout() {\n            mHandler.sendMessageDelayed(\n                    mHandler.obtainMessage(MESSAGE_TIMED_OUT, this), TIMEOUT_DELAY_MS);\n        }\n\n        public void cancelTimeout() {\n            mHandler.removeMessages(MESSAGE_TIMED_OUT, this);\n        }\n\n        @Override\n        public void onServiceConnected(ComponentName name, IBinder service) {\n            synchronized (mSessionLock) {\n                mAuthenticator = IAccountAuthenticator.Stub.asInterface(service);\n                try {\n                    run();\n                } catch (RemoteException e) {\n                    onError(AccountManager.ERROR_CODE_REMOTE_EXCEPTION,\n                            \"remote exception\");\n                }\n            }\n        }\n\n        @Override\n        public void onServiceDisconnected(ComponentName name) {\n            IAccountManagerResponse response = getResponseAndClose();\n            if (response != null) {\n                try {\n                    response.onError(AccountManager.ERROR_CODE_REMOTE_EXCEPTION,\n                            \"disconnected\");\n                } catch (RemoteException e) {\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, \"Session.onServiceDisconnected: \"\n                                + \"caught RemoteException while responding\", e);\n                    }\n                }\n            }\n        }\n\n        public abstract void run() throws RemoteException;\n\n        public void onTimedOut() {\n            IAccountManagerResponse response = getResponseAndClose();\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"Session.onTimedOut\");\n            }\n            if (response != null) {\n                try {\n                    response.onError(AccountManager.ERROR_CODE_REMOTE_EXCEPTION,\n                            \"timeout\");\n                } catch (RemoteException e) {\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, \"Session.onTimedOut: caught RemoteException while responding\",\n                                e);\n                    }\n                }\n            }\n        }\n\n        @Override\n        public void onResult(Bundle result) {\n            Bundle.setDefusable(result, true);\n            mNumResults++;\n            Intent intent = null;\n            if (result != null) {\n                boolean isSuccessfulConfirmCreds = result.getBoolean(\n                        AccountManager.KEY_BOOLEAN_RESULT, false);\n                boolean isSuccessfulUpdateCredsOrAddAccount =\n                        result.containsKey(AccountManager.KEY_ACCOUNT_NAME)\n                        && result.containsKey(AccountManager.KEY_ACCOUNT_TYPE);\n                // We should only update lastAuthenticated time, if\n                // mUpdateLastAuthenticatedTime is true and the confirmRequest\n                // or updateRequest was successful\n                boolean needUpdate = mUpdateLastAuthenticatedTime\n                        && (isSuccessfulConfirmCreds || isSuccessfulUpdateCredsOrAddAccount);\n                if (needUpdate || mAuthDetailsRequired) {\n                    boolean accountPresent = isAccountPresentForCaller(mAccountName, mAccountType);\n                    if (needUpdate && accountPresent) {\n                        updateLastAuthenticatedTime(new Account(mAccountName, mAccountType));\n                    }\n                    if (mAuthDetailsRequired) {\n                        long lastAuthenticatedTime = -1;\n                        if (accountPresent) {\n                            lastAuthenticatedTime = mAccounts.accountsDb\n                                    .findAccountLastAuthenticatedTime(\n                                            new Account(mAccountName, mAccountType));\n                        }\n                        result.putLong(AccountManager.KEY_LAST_AUTHENTICATED_TIME,\n                                lastAuthenticatedTime);\n                    }\n                }\n            }\n            if (result != null) {\n                if (!checkKeyIntent(\n                        Binder.getCallingUid(),\n                        result)) {\n                    onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                            \"invalid intent in bundle returned\");\n                    return;\n                }\n            }\n            if (result != null\n                    && !TextUtils.isEmpty(result.getString(AccountManager.KEY_AUTHTOKEN))) {\n                String accountName = result.getString(AccountManager.KEY_ACCOUNT_NAME);\n                String accountType = result.getString(AccountManager.KEY_ACCOUNT_TYPE);\n                if (!TextUtils.isEmpty(accountName) && !TextUtils.isEmpty(accountType)) {\n                    Account account = new Account(accountName, accountType);\n                    cancelNotification(getSigninRequiredNotificationId(mAccounts, account),\n                            mAccounts);\n                }\n            }\n            IAccountManagerResponse response;\n            if (mExpectActivityLaunch && result != null\n                    && result.containsKey(AccountManager.KEY_INTENT)) {\n                response = mResponse;\n            } else {\n                response = getResponseAndClose();\n            }\n            if (response != null) {\n                try {\n                    if (result == null) {\n                        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                            Log.v(TAG, getClass().getSimpleName()\n                                    + \" calling onError() on response \" + response);\n                        }\n                        response.onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                                \"null bundle returned\");\n                    } else {\n                        if (mStripAuthTokenFromResult) {\n                            result.remove(AccountManager.KEY_AUTHTOKEN);\n                            if (!checkKeyIntent(Binder.getCallingUid(), result)) {\n                                onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                                        \"invalid intent in bundle returned\");\n                                return;\n                            }\n                        }\n                        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                            Log.v(TAG, getClass().getSimpleName()\n                                    + \" calling onResult() on response \" + response);\n                        }\n                        if ((result.getInt(AccountManager.KEY_ERROR_CODE, -1) > 0) &&\n                                (intent == null)) {\n                            // All AccountManager error codes are greater than 0\n                            response.onError(result.getInt(AccountManager.KEY_ERROR_CODE),\n                                    result.getString(AccountManager.KEY_ERROR_MESSAGE));\n                        } else {\n                            response.onResult(result);\n                        }\n                    }\n                } catch (RemoteException e) {\n                    // if the caller is dead then there is no one to care about remote exceptions\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, \"failure while notifying response\", e);\n                    }\n                }\n            }\n        }\n\n        @Override\n        public void onRequestContinued() {\n            mNumRequestContinued++;\n        }\n\n        @Override\n        public void onError(int errorCode, String errorMessage) {\n            mNumErrors++;\n            IAccountManagerResponse response = getResponseAndClose();\n            if (response != null) {\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.v(TAG, getClass().getSimpleName()\n                            + \" calling onError() on response \" + response);\n                }\n                try {\n                    response.onError(errorCode, errorMessage);\n                } catch (RemoteException e) {\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, \"Session.onError: caught RemoteException while responding\", e);\n                    }\n                }\n            } else {\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.v(TAG, \"Session.onError: already closed\");\n                }\n            }\n        }\n\n        /**\n         * find the component name for the authenticator and initiate a bind\n         * if no authenticator or the bind fails then return false, otherwise return true\n         */\n        private boolean bindToAuthenticator(String authenticatorType) {\n            final AccountAuthenticatorCache.ServiceInfo<AuthenticatorDescription> authenticatorInfo;\n            authenticatorInfo = mAuthenticatorCache.getServiceInfo(\n                    AuthenticatorDescription.newKey(authenticatorType), mAccounts.userId);\n            if (authenticatorInfo == null) {\n                Log.w(TAG, \"there is no authenticator for \" + authenticatorType\n                        + \", bailing out\");\n\n                return false;\n            }\n\n            if (!isLocalUnlockedUser(mAccounts.userId)\n                    && !authenticatorInfo.componentInfo.directBootAware) {\n                Slog.w(TAG, \"Blocking binding to authenticator \" + authenticatorInfo.componentName\n                        + \" which isn't encryption aware\");\n                return false;\n            }\n\n            Intent intent = new Intent();\n            intent.setAction(AccountManager.ACTION_AUTHENTICATOR_INTENT);\n            intent.setComponent(authenticatorInfo.componentName);\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"performing bindService to \" + authenticatorInfo.componentName);\n            }\n            long flags = Context.BIND_AUTO_CREATE;\n            if (mAuthenticatorCache.getBindInstantServiceAllowed(mAccounts.userId)) {\n                flags |= Context.BIND_ALLOW_INSTANT;\n            }\n            if (!mContext.bindServiceAsUser(intent, this, Context.BindServiceFlags.of(flags),\n                    UserHandle.of(mAccounts.userId))) {\n                Log.w(TAG, \"bindService to \" + authenticatorInfo.componentName + \" failed\");\n                // Perform unbind as per documentation at Context.bindServiceAsUser\n                mContext.unbindService(this);\n                return false;\n            }\n            mAuthenticatorUid = authenticatorInfo.uid;\n            mBindingStartTime = SystemClock.uptimeMillis();\n            return true;\n        }\n    }\n\n    class MessageHandler extends Handler {\n        MessageHandler(Looper looper) {\n            super(looper);\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MESSAGE_TIMED_OUT:\n                    Session session = (Session)msg.obj;\n                    session.onTimedOut();\n                    break;\n\n                case MESSAGE_COPY_SHARED_ACCOUNT:\n                    copyAccountToUser(/*no response*/ null, (Account) msg.obj, msg.arg1, msg.arg2);\n                    break;\n\n                default:\n                    throw new IllegalStateException(\"unhandled message: \" + msg.what);\n            }\n        }\n    }\n\n    private void logRecord(UserAccounts accounts, String action, String tableName) {\n        logRecord(action, tableName, -1, accounts);\n    }\n\n    private void logRecordWithUid(UserAccounts accounts, String action, String tableName, int uid) {\n        logRecord(action, tableName, -1, accounts, uid);\n    }\n\n    /*\n     * This function receives an opened writable database.\n     */\n    private void logRecord(String action, String tableName, long accountId,\n            UserAccounts userAccount) {\n        logRecord(action, tableName, accountId, userAccount, getCallingUid());\n    }\n\n    /*\n     * This function receives an opened writable database and writes to it in a separate thread.\n     */\n    private void logRecord(String action, String tableName, long accountId,\n            UserAccounts userAccount, int callingUid) {\n\n        class LogRecordTask implements Runnable {\n            private final String action;\n            private final String tableName;\n            private final long accountId;\n            private final UserAccounts userAccount;\n            private final int callingUid;\n            private final long userDebugDbInsertionPoint;\n\n            LogRecordTask(final String action,\n                    final String tableName,\n                    final long accountId,\n                    final UserAccounts userAccount,\n                    final int callingUid,\n                    final long userDebugDbInsertionPoint) {\n                this.action = action;\n                this.tableName = tableName;\n                this.accountId = accountId;\n                this.userAccount = userAccount;\n                this.callingUid = callingUid;\n                this.userDebugDbInsertionPoint = userDebugDbInsertionPoint;\n            }\n\n            @Override\n            public void run() {\n                synchronized (userAccount.accountsDb.mDebugStatementLock) {\n                    SQLiteStatement logStatement = userAccount.accountsDb.getStatementForLogging();\n                    if (logStatement == null) {\n                        return; // Can't log.\n                    }\n                    logStatement.bindLong(1, accountId);\n                    logStatement.bindString(2, action);\n                    logStatement.bindString(3, mDateFormat.format(new Date()));\n                    logStatement.bindLong(4, callingUid);\n                    logStatement.bindString(5, tableName);\n                    logStatement.bindLong(6, userDebugDbInsertionPoint);\n                    try {\n                        logStatement.execute();\n                    } catch (IllegalStateException | SQLiteFullException e) {\n                        // Guard against crash, DB can already be closed\n                        // since this statement is executed on a handler thread\n                        Slog.w(TAG, \"Failed to insert a log record. accountId=\" + accountId\n                                + \" action=\" + action + \" tableName=\" + tableName + \" Error: \" + e);\n                    } finally {\n                        logStatement.clearBindings();\n                    }\n                }\n            }\n        }\n        long insertionPoint = userAccount.accountsDb.reserveDebugDbInsertionPoint();\n        if (insertionPoint != -1) {\n            LogRecordTask logTask = new LogRecordTask(action, tableName, accountId, userAccount,\n                    callingUid, insertionPoint);\n            mHandler.post(logTask);\n        }\n    }\n\n    public IBinder onBind(@SuppressWarnings(\"unused\") Intent intent) {\n        return asBinder();\n    }\n\n    /**\n     * Searches array of arguments for the specified string\n     * @param args array of argument strings\n     * @param value value to search for\n     * @return true if the value is contained in the array\n     */\n    private static boolean scanArgs(String[] args, String value) {\n        if (args != null) {\n            for (String arg : args) {\n                if (value.equals(arg)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    @Override\n    protected void dump(FileDescriptor fd, PrintWriter fout, String[] args) {\n        if (!DumpUtils.checkDumpPermission(mContext, TAG, fout)) return;\n        final boolean isCheckinRequest = scanArgs(args, \"--checkin\") || scanArgs(args, \"-c\");\n        final IndentingPrintWriter ipw = new IndentingPrintWriter(fout, \"  \");\n\n        final List<UserInfo> users = getUserManager().getUsers();\n        for (UserInfo user : users) {\n            ipw.println(\"User \" + user + \":\");\n            ipw.increaseIndent();\n            dumpUser(getUserAccounts(user.id), fd, ipw, args, isCheckinRequest);\n            ipw.println();\n            ipw.decreaseIndent();\n        }\n    }\n\n    private void dumpUser(UserAccounts userAccounts, FileDescriptor fd, PrintWriter fout,\n            String[] args, boolean isCheckinRequest) {\n        if (isCheckinRequest) {\n            // This is a checkin request. *Only* upload the account types and the count of\n            // each.\n            synchronized (userAccounts.dbLock) {\n                userAccounts.accountsDb.dumpDeAccountsTable(fout);\n            }\n        } else {\n            Account[] accounts = getAccountsFromCache(userAccounts, null /* type */,\n                    Process.SYSTEM_UID, \"android\" /* packageName */, false);\n            fout.println(\"Accounts: \" + accounts.length);\n            for (Account account : accounts) {\n                fout.println(\"  \" + account.toString());\n            }\n\n            // Add debug information.\n            fout.println();\n            synchronized (userAccounts.dbLock) {\n                userAccounts.accountsDb.dumpDebugTable(fout);\n            }\n            fout.println();\n            synchronized (mSessions) {\n                final long now = SystemClock.elapsedRealtime();\n                fout.println(\"Active Sessions: \" + mSessions.size());\n                for (Session session : mSessions.values()) {\n                    fout.println(\"  \" + session.toDebugString(now));\n                }\n            }\n\n            fout.println();\n            mAuthenticatorCache.dump(fd, fout, args, userAccounts.userId);\n\n            boolean isUserUnlocked;\n            synchronized (mUsers) {\n                isUserUnlocked = isLocalUnlockedUser(userAccounts.userId);\n            }\n            // Following logs are printed only when user is unlocked.\n            if (!isUserUnlocked) {\n                return;\n            }\n            fout.println();\n            synchronized (userAccounts.dbLock) {\n                Map<Account, Map<String, Integer>> allVisibilityValues =\n                        userAccounts.accountsDb.findAllVisibilityValues();\n                fout.println(\"Account visibility:\");\n                for (Account account : allVisibilityValues.keySet()) {\n                    fout.println(\"  \" + account.name);\n                    Map<String, Integer> visibilities = allVisibilityValues.get(account);\n                    for (Entry<String, Integer> entry : visibilities.entrySet()) {\n                        fout.println(\"    \" + entry.getKey() + \", \" + entry.getValue());\n                    }\n                }\n            }\n        }\n    }\n\n    private void doNotification(UserAccounts accounts, Account account, CharSequence message,\n            Intent intent, String packageName, final int userId) {\n        final long identityToken = clearCallingIdentity();\n        try {\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"doNotification: \" + message + \" intent:\" + intent);\n            }\n\n            if (intent.getComponent() != null &&\n                    GrantCredentialsPermissionActivity.class.getName().equals(\n                            intent.getComponent().getClassName())) {\n                createNoCredentialsPermissionNotification(account, intent, packageName, accounts);\n            } else {\n                Context contextForUser = getContextForUser(new UserHandle(userId));\n                final NotificationId id = getSigninRequiredNotificationId(accounts, account);\n                intent.addCategory(id.mTag);\n\n                final String notificationTitleFormat =\n                        contextForUser.getText(R.string.notification_title).toString();\n                Notification n =\n                        new Notification.Builder(contextForUser, SystemNotificationChannels.ACCOUNT)\n                        .setWhen(0)\n                        .setSmallIcon(android.R.drawable.stat_sys_warning)\n                        .setColor(contextForUser.getColor(\n                                com.android.internal.R.color.system_notification_accent_color))\n                        .setContentTitle(String.format(notificationTitleFormat, account.name))\n                        .setContentText(message)\n                        .setContentIntent(PendingIntent.getActivityAsUser(\n                                mContext, 0, intent,\n                                PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_IMMUTABLE,\n                                null, new UserHandle(userId)))\n                        .build();\n                installNotification(id, n, packageName, userId);\n            }\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private void installNotification(NotificationId id, final Notification notification,\n            String packageName, int userId) {\n        final long token = clearCallingIdentity();\n        try {\n            INotificationManager notificationManager = mInjector.getNotificationManager();\n            try {\n                // The calling uid must match either the package or op package, so use an op\n                // package that matches the cleared calling identity.\n                notificationManager.enqueueNotificationWithTag(packageName, \"android\",\n                        id.mTag, id.mId, notification, userId);\n            } catch (RemoteException e) {\n                /* ignore - local call */\n            }\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private void cancelNotification(NotificationId id, UserAccounts accounts) {\n        cancelNotification(id, mContext.getPackageName(), accounts);\n    }\n\n    private void cancelNotification(NotificationId id, String packageName, UserAccounts accounts) {\n        final long identityToken = clearCallingIdentity();\n        try {\n            INotificationManager service = mInjector.getNotificationManager();\n            service.cancelNotificationWithTag(\n                    packageName, \"android\", id.mTag, id.mId,\n                    UserHandle.of(accounts.userId).getIdentifier());\n        } catch (RemoteException e) {\n            /* ignore - local call */\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private boolean isPermittedForPackage(String packageName, int userId, String... permissions) {\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            final int uid = mPackageManager.getPackageUidAsUser(packageName, userId);\n            IPackageManager pm = ActivityThread.getPackageManager();\n            for (String perm : permissions) {\n                if (pm.checkPermission(perm, packageName, userId)\n                        == PackageManager.PERMISSION_GRANTED) {\n                    // Checks runtime permission revocation.\n                    final int opCode = AppOpsManager.permissionToOpCode(perm);\n                    if (opCode == AppOpsManager.OP_NONE || mAppOpsManager.checkOpNoThrow(\n                            opCode, uid, packageName) == AppOpsManager.MODE_ALLOWED) {\n                        return true;\n                    }\n                }\n            }\n        } catch (NameNotFoundException | RemoteException e) {\n            // Assume permission is not granted if an error accrued.\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n        return false;\n    }\n\n    /**\n     * Checks that package has at least one of given permissions and makes note of app\n     * performing the action.\n     */\n    private boolean checkPermissionAndNote(String opPackageName, int callingUid,\n            String... permissions) {\n        for (String perm : permissions) {\n            if (mContext.checkCallingOrSelfPermission(perm) == PackageManager.PERMISSION_GRANTED) {\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.v(TAG, \"  caller uid \" + callingUid + \" has \" + perm);\n                }\n                final int opCode = AppOpsManager.permissionToOpCode(perm);\n                if (opCode == AppOpsManager.OP_NONE || mAppOpsManager.noteOpNoThrow(\n                        opCode, callingUid, opPackageName) == AppOpsManager.MODE_ALLOWED) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private int handleIncomingUser(int userId) {\n        try {\n            return ActivityManager.getService().handleIncomingUser(\n                    Binder.getCallingPid(), Binder.getCallingUid(), userId, true, true, \"\", null);\n        } catch (RemoteException re) {\n            // Shouldn't happen, local.\n        }\n        return userId;\n    }\n\n    private boolean isPrivileged(int callingUid) {\n        String[] packages;\n        final long identityToken = Binder.clearCallingIdentity();\n        try {\n            packages = mPackageManager.getPackagesForUid(callingUid);\n            if (packages == null) {\n                Log.d(TAG, \"No packages for callingUid \" + callingUid);\n                return false;\n            }\n            for (String name : packages) {\n                try {\n                    PackageInfo packageInfo =\n                        mPackageManager.getPackageInfo(name, 0 /* flags */);\n                    if (packageInfo != null\n                        && (packageInfo.applicationInfo.privateFlags\n                            & ApplicationInfo.PRIVATE_FLAG_PRIVILEGED) != 0) {\n                        return true;\n                    }\n                } catch (PackageManager.NameNotFoundException e) {\n                    Log.w(TAG, \"isPrivileged#Package not found \" + e.getMessage());\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identityToken);\n        }\n        return false;\n    }\n\n    private boolean permissionIsGranted(\n            Account account, String authTokenType, int callerUid, int userId) {\n        if (UserHandle.getAppId(callerUid) == Process.SYSTEM_UID) {\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"Access to \" + account + \" granted calling uid is system\");\n            }\n            return true;\n        }\n\n        if (isPrivileged(callerUid)) {\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"Access to \" + account + \" granted calling uid \"\n                        + callerUid + \" privileged\");\n            }\n            return true;\n        }\n        if (account != null && isAccountManagedByCaller(account.type, callerUid, userId)) {\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"Access to \" + account + \" granted calling uid \"\n                        + callerUid + \" manages the account\");\n            }\n            return true;\n        }\n        if (account != null && hasExplicitlyGrantedPermission(account, authTokenType, callerUid)) {\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"Access to \" + account + \" granted calling uid \"\n                        + callerUid + \" user granted access\");\n            }\n            return true;\n        }\n\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"Access to \" + account + \" not granted for uid \" + callerUid);\n        }\n\n        return false;\n    }\n\n    private boolean isAccountVisibleToCaller(String accountType, int callingUid, int userId,\n            String opPackageName) {\n        if (accountType == null) {\n            return false;\n        } else {\n            return getTypesVisibleToCaller(callingUid, userId,\n                    opPackageName).contains(accountType);\n        }\n    }\n\n    // Method checks visibility for applications targeing API level below {@link\n    // android.os.Build.VERSION_CODES#O},\n    // returns true if the the app has GET_ACCOUNTS or GET_ACCOUNTS_PRIVILEGED permission.\n    private boolean checkGetAccountsPermission(String packageName, int userId) {\n        return isPermittedForPackage(packageName, userId, Manifest.permission.GET_ACCOUNTS,\n                Manifest.permission.GET_ACCOUNTS_PRIVILEGED);\n    }\n\n    private boolean checkReadContactsPermission(String packageName, int userId) {\n        return isPermittedForPackage(packageName, userId, Manifest.permission.READ_CONTACTS);\n    }\n\n    // Heuristic to check that account type may be associated with some contacts data and\n    // therefore READ_CONTACTS permission grants the access to account by default.\n    private boolean accountTypeManagesContacts(String accountType, int userId) {\n        if (accountType == null) {\n            return false;\n        }\n        final long identityToken = Binder.clearCallingIdentity();\n        Collection<RegisteredServicesCache.ServiceInfo<AuthenticatorDescription>> serviceInfos;\n        try {\n            serviceInfos = mAuthenticatorCache.getAllServices(userId);\n        } finally {\n            Binder.restoreCallingIdentity(identityToken);\n        }\n        // Check contacts related permissions for authenticator.\n        for (RegisteredServicesCache.ServiceInfo<AuthenticatorDescription> serviceInfo\n                : serviceInfos) {\n            if (accountType.equals(serviceInfo.type.type)) {\n                return isPermittedForPackage(serviceInfo.type.packageName, userId,\n                    Manifest.permission.WRITE_CONTACTS);\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Method checks package uid and signature with Authenticator which manages accountType.\n     *\n     * @return SIGNATURE_CHECK_UID_MATCH for uid match, SIGNATURE_CHECK_MATCH for signature match,\n     *         SIGNATURE_CHECK_MISMATCH otherwise.\n     */\n    private int checkPackageSignature(String accountType, int callingUid, int userId) {\n        if (accountType == null) {\n            return SIGNATURE_CHECK_MISMATCH;\n        }\n\n        final long identityToken = Binder.clearCallingIdentity();\n        Collection<RegisteredServicesCache.ServiceInfo<AuthenticatorDescription>> serviceInfos;\n        try {\n            serviceInfos = mAuthenticatorCache.getAllServices(userId);\n        } finally {\n            Binder.restoreCallingIdentity(identityToken);\n        }\n        // Check for signature match with Authenticator.LocalServices.getService(PackageManagerInternal.class);\n        PackageManagerInternal pmi = LocalServices.getService(PackageManagerInternal.class);\n        for (RegisteredServicesCache.ServiceInfo<AuthenticatorDescription> serviceInfo\n                : serviceInfos) {\n            if (accountType.equals(serviceInfo.type.type)) {\n                if (serviceInfo.uid == callingUid) {\n                    return SIGNATURE_CHECK_UID_MATCH;\n                }\n                if (pmi.hasSignatureCapability(\n                        serviceInfo.uid, callingUid, CertCapabilities.AUTH)) {\n                    return SIGNATURE_CHECK_MATCH;\n                }\n            }\n        }\n        return SIGNATURE_CHECK_MISMATCH;\n    }\n\n    // returns true for applications with the same signature as authenticator.\n    private boolean isAccountManagedByCaller(String accountType, int callingUid, int userId) {\n        if (accountType == null) {\n            return false;\n        } else {\n            return getTypesManagedByCaller(callingUid, userId).contains(accountType);\n        }\n    }\n\n    private List<String> getTypesVisibleToCaller(int callingUid, int userId,\n            String opPackageName) {\n        return getTypesForCaller(callingUid, userId, true /* isOtherwisePermitted*/);\n    }\n\n    private List<String> getTypesManagedByCaller(int callingUid, int userId) {\n        return getTypesForCaller(callingUid, userId, false);\n    }\n\n    private List<String> getTypesForCaller(\n            int callingUid, int userId, boolean isOtherwisePermitted) {\n        List<String> managedAccountTypes = new ArrayList<>();\n        final long identityToken = Binder.clearCallingIdentity();\n        Collection<RegisteredServicesCache.ServiceInfo<AuthenticatorDescription>> serviceInfos;\n        try {\n            serviceInfos = mAuthenticatorCache.getAllServices(userId);\n        } finally {\n            Binder.restoreCallingIdentity(identityToken);\n        }\n\n        PackageManagerInternal pmi = LocalServices.getService(PackageManagerInternal.class);\n        for (RegisteredServicesCache.ServiceInfo<AuthenticatorDescription> serviceInfo :\n                serviceInfos) {\n            if (isOtherwisePermitted || pmi.hasSignatureCapability(\n                    serviceInfo.uid, callingUid, CertCapabilities.AUTH)) {\n                managedAccountTypes.add(serviceInfo.type.type);\n            }\n        }\n        return managedAccountTypes;\n    }\n\n    private boolean isAccountPresentForCaller(String accountName, String accountType) {\n        if (getUserAccountsForCaller().accountCache.containsKey(accountType)) {\n            for (Account account : getUserAccountsForCaller().accountCache.get(accountType)) {\n                if (account.name.equals(accountName)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private static void checkManageUsersPermission(String message) {\n        if (ActivityManager.checkComponentPermission(\n                android.Manifest.permission.MANAGE_USERS, Binder.getCallingUid(), -1, true)\n                != PackageManager.PERMISSION_GRANTED) {\n            throw new SecurityException(\"You need MANAGE_USERS permission to: \" + message);\n        }\n    }\n\n    private static void checkManageOrCreateUsersPermission(String message) {\n        if (ActivityManager.checkComponentPermission(android.Manifest.permission.MANAGE_USERS,\n                Binder.getCallingUid(), -1, true) != PackageManager.PERMISSION_GRANTED &&\n                ActivityManager.checkComponentPermission(android.Manifest.permission.CREATE_USERS,\n                        Binder.getCallingUid(), -1, true) != PackageManager.PERMISSION_GRANTED) {\n            throw new SecurityException(\"You need MANAGE_USERS or CREATE_USERS permission to: \"\n                    + message);\n        }\n    }\n\n    private boolean hasExplicitlyGrantedPermission(Account account, String authTokenType,\n            int callerUid) {\n        if (UserHandle.getAppId(callerUid) == Process.SYSTEM_UID) {\n            return true;\n        }\n        UserAccounts accounts = getUserAccounts(UserHandle.getUserId(callerUid));\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                long grantsCount;\n                if (authTokenType != null) {\n                    grantsCount = accounts.accountsDb\n                            .findMatchingGrantsCount(callerUid, authTokenType, account);\n                } else {\n                    grantsCount = accounts.accountsDb.findMatchingGrantsCountAnyToken(callerUid,\n                            account);\n                }\n                final boolean permissionGranted = grantsCount > 0;\n\n                if (!permissionGranted && ActivityManager.isRunningInTestHarness()) {\n                    // TODO: Skip this check when running automated tests. Replace this\n                    // with a more general solution.\n                    Log.d(TAG, \"no credentials permission for usage of \"\n                            + account.toSafeString() + \", \"\n                            + authTokenType + \" by uid \" + callerUid\n                            + \" but ignoring since device is in test harness.\");\n                    return true;\n                }\n                return permissionGranted;\n            }\n        }\n    }\n\n    private boolean isSystemUid(int callingUid) {\n        String[] packages = null;\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            packages = mPackageManager.getPackagesForUid(callingUid);\n            if (packages != null) {\n                for (String name : packages) {\n                    try {\n                        PackageInfo packageInfo =\n                                mPackageManager.getPackageInfo(name, 0 /* flags */);\n                        if (packageInfo != null\n                                && (packageInfo.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM)\n                                != 0) {\n                            return true;\n                        }\n                    } catch (NameNotFoundException e) {\n                        Log.w(TAG, String.format(\"Could not find package [%s]\", name), e);\n                    }\n                }\n            } else {\n                Log.w(TAG, \"No known packages with uid \" + callingUid);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n        return false;\n    }\n\n    /** Succeeds if any of the specified permissions are granted. */\n    private void checkReadAccountsPermitted(\n            int callingUid,\n            String accountType,\n            int userId,\n            String opPackageName) {\n        if (!isAccountVisibleToCaller(accountType, callingUid, userId, opPackageName)) {\n            String msg = String.format(\n                    \"caller uid %s cannot access %s accounts\",\n                    callingUid,\n                    accountType);\n            Log.w(TAG, \"  \" + msg);\n            throw new SecurityException(msg);\n        }\n    }\n\n    private boolean canUserModifyAccounts(int userId, int callingUid) {\n        // the managing app can always modify accounts\n        if (isProfileOwner(callingUid)) {\n            return true;\n        }\n        if (getUserManager().getUserRestrictions(new UserHandle(userId))\n                .getBoolean(UserManager.DISALLOW_MODIFY_ACCOUNTS)) {\n            return false;\n        }\n        return true;\n    }\n\n    private boolean canUserModifyAccountsForType(int userId, String accountType, int callingUid) {\n        return Binder.withCleanCallingIdentity(() -> {\n            // the managing app can always modify accounts\n            if (isProfileOwner(callingUid)) {\n                return true;\n            }\n            DevicePolicyManager dpm = (DevicePolicyManager) mContext\n                    .getSystemService(Context.DEVICE_POLICY_SERVICE);\n            String[] typesArray = dpm.getAccountTypesWithManagementDisabledAsUser(userId);\n            if (typesArray == null) {\n                return true;\n            }\n            for (String forbiddenType : typesArray) {\n                if (forbiddenType.equals(accountType)) {\n                    return false;\n                }\n            }\n            return true;\n        });\n    }\n\n    private boolean isProfileOwner(int uid) {\n        final DevicePolicyManagerInternal dpmi =\n                LocalServices.getService(DevicePolicyManagerInternal.class);\n        //TODO(b/169395065) Figure out if this flow makes sense in Device Owner mode.\n        return (dpmi != null) && (dpmi.isActiveProfileOwner(uid) || dpmi.isActiveDeviceOwner(uid));\n    }\n\n    /**\n     * Filter the access to the target package by rules of the package visibility if the caller\n     * targeting API level U and above. Otherwise, returns true if the package is installed on\n     * the device.\n     *\n     * @param targetPkgName The package name to check.\n     * @param callingUid The caller that is going to access the package.\n     * @param userId The user ID where the target package resides.\n     * @return true if the caller is able to access the package.\n     */\n    private boolean canCallerAccessPackage(@NonNull String targetPkgName, int callingUid,\n            int userId) {\n        final PackageManagerInternal pmInternal =\n                LocalServices.getService(PackageManagerInternal.class);\n        if (!CompatChanges.isChangeEnabled(ENFORCE_PACKAGE_VISIBILITY_FILTERING, callingUid)) {\n            return pmInternal.getPackageUid(\n                    targetPkgName, 0 /* flags */, userId) != Process.INVALID_UID;\n        }\n        final boolean canAccess = !pmInternal.filterAppAccess(targetPkgName, callingUid, userId);\n        if (!canAccess && Log.isLoggable(TAG, Log.DEBUG)) {\n            Log.d(TAG, \"Package \" + targetPkgName + \" is not visible to caller \" + callingUid\n                    + \" for user \" + userId);\n        }\n        return canAccess;\n    }\n\n    @Override\n    public void updateAppPermission(Account account, String authTokenType, int uid, boolean value)\n            throws RemoteException {\n        final int callingUid = getCallingUid();\n\n        if (UserHandle.getAppId(callingUid) != Process.SYSTEM_UID) {\n            throw new SecurityException();\n        }\n\n        if (value) {\n            grantAppPermission(account, authTokenType, uid);\n        } else {\n            revokeAppPermission(account, authTokenType, uid);\n        }\n    }\n\n    /**\n     * Allow callers with the given uid permission to get credentials for account/authTokenType.\n     * <p>\n     * Although this is public it can only be accessed via the AccountManagerService object\n     * which is in the system. This means we don't need to protect it with permissions.\n     * @hide\n     */\n    void grantAppPermission(Account account, String authTokenType, int uid) {\n        if (account == null || authTokenType == null) {\n            Log.e(TAG, \"grantAppPermission: called with invalid arguments\", new Exception());\n            return;\n        }\n        UserAccounts accounts = getUserAccounts(UserHandle.getUserId(uid));\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                long accountId = accounts.accountsDb.findDeAccountId(account);\n                if (accountId >= 0) {\n                    accounts.accountsDb.insertGrant(accountId, authTokenType, uid);\n                }\n                cancelNotification(\n                        getCredentialPermissionNotificationId(\n                                account, authTokenType, uid, accounts),\n                        accounts);\n\n                cancelAccountAccessRequestNotificationIfNeeded(account, uid, true, accounts);\n            }\n        }\n\n        // Listeners are a final CopyOnWriteArrayList, hence no lock needed.\n        for (AccountManagerInternal.OnAppPermissionChangeListener listener\n                : mAppPermissionChangeListeners) {\n            mHandler.post(() -> listener.onAppPermissionChanged(account, uid));\n        }\n    }\n\n    /**\n     * Don't allow callers with the given uid permission to get credentials for\n     * account/authTokenType.\n     * <p>\n     * Although this is public it can only be accessed via the AccountManagerService object\n     * which is in the system. This means we don't need to protect it with permissions.\n     * @hide\n     */\n    private void revokeAppPermission(Account account, String authTokenType, int uid) {\n        if (account == null || authTokenType == null) {\n            Log.e(TAG, \"revokeAppPermission: called with invalid arguments\", new Exception());\n            return;\n        }\n        UserAccounts accounts = getUserAccounts(UserHandle.getUserId(uid));\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                accounts.accountsDb.beginTransaction();\n                try {\n                    long accountId = accounts.accountsDb.findDeAccountId(account);\n                    if (accountId >= 0) {\n                        accounts.accountsDb.deleteGrantsByAccountIdAuthTokenTypeAndUid(\n                                accountId, authTokenType, uid);\n                        accounts.accountsDb.setTransactionSuccessful();\n                    }\n                } finally {\n                    accounts.accountsDb.endTransaction();\n                }\n\n                cancelNotification(\n                        getCredentialPermissionNotificationId(\n                                account, authTokenType, uid, accounts),\n                        accounts);\n            }\n        }\n\n        // Listeners are a final CopyOnWriteArrayList, hence no lock needed.\n        for (AccountManagerInternal.OnAppPermissionChangeListener listener\n                : mAppPermissionChangeListeners) {\n            mHandler.post(() -> listener.onAppPermissionChanged(account, uid));\n        }\n    }\n\n    private void removeAccountFromCacheLocked(UserAccounts accounts, Account account) {\n        final Account[] oldAccountsForType = accounts.accountCache.get(account.type);\n        if (oldAccountsForType != null) {\n            ArrayList<Account> newAccountsList = new ArrayList<>();\n            for (Account curAccount : oldAccountsForType) {\n                if (!curAccount.equals(account)) {\n                    newAccountsList.add(curAccount);\n                }\n            }\n            if (newAccountsList.isEmpty()) {\n                accounts.accountCache.remove(account.type);\n            } else {\n                Account[] newAccountsForType = new Account[newAccountsList.size()];\n                newAccountsForType = newAccountsList.toArray(newAccountsForType);\n                accounts.accountCache.put(account.type, newAccountsForType);\n            }\n        }\n        accounts.userDataCache.remove(account);\n        accounts.authTokenCache.remove(account);\n        accounts.previousNameCache.remove(account);\n        accounts.visibilityCache.remove(account);\n\n        AccountManager.invalidateLocalAccountsDataCaches();\n    }\n\n    /**\n     * This assumes that the caller has already checked that the account is not already present.\n     * IMPORTANT: The account being inserted will begin to be tracked for access in remote\n     * processes and if you will return this account to apps you should return the result.\n     * @return The inserted account which is a new instance that is being tracked.\n     */\n    private Account insertAccountIntoCacheLocked(UserAccounts accounts, Account account) {\n        Account[] accountsForType = accounts.accountCache.get(account.type);\n        int oldLength = (accountsForType != null) ? accountsForType.length : 0;\n        Account[] newAccountsForType = new Account[oldLength + 1];\n        if (accountsForType != null) {\n            System.arraycopy(accountsForType, 0, newAccountsForType, 0, oldLength);\n        }\n        String token = account.getAccessId() != null ? account.getAccessId()\n                : UUID.randomUUID().toString();\n        newAccountsForType[oldLength] = new Account(account, token);\n        accounts.accountCache.put(account.type, newAccountsForType);\n        AccountManager.invalidateLocalAccountsDataCaches();\n        return newAccountsForType[oldLength];\n    }\n\n    @NonNull\n    private Account[] filterAccounts(UserAccounts accounts, Account[] unfiltered, int callingUid,\n            @Nullable String callingPackage, boolean includeManagedNotVisible) {\n        String visibilityFilterPackage = callingPackage;\n        if (visibilityFilterPackage == null) {\n            visibilityFilterPackage = getPackageNameForUid(callingUid);\n        }\n        Map<Account, Integer> firstPass = new LinkedHashMap<>();\n        for (Account account : unfiltered) {\n            int visibility = resolveAccountVisibility(account, visibilityFilterPackage, accounts);\n            if ((visibility == AccountManager.VISIBILITY_VISIBLE\n                    || visibility == AccountManager.VISIBILITY_USER_MANAGED_VISIBLE)\n                    || (includeManagedNotVisible\n                            && (visibility\n                                    == AccountManager.VISIBILITY_USER_MANAGED_NOT_VISIBLE))) {\n                firstPass.put(account, visibility);\n            }\n        }\n        Map<Account, Integer> secondPass =\n                filterSharedAccounts(accounts, firstPass, callingUid, callingPackage);\n\n        Account[] filtered = new Account[secondPass.size()];\n        filtered = secondPass.keySet().toArray(filtered);\n        return filtered;\n    }\n\n    @NonNull\n    private Map<Account, Integer> filterSharedAccounts(UserAccounts userAccounts,\n            @NonNull Map<Account, Integer> unfiltered, int callingUid,\n            @Nullable String callingPackage) {\n        // first part is to filter shared accounts.\n        // unfiltered type check is not necessary.\n        if (getUserManager() == null || userAccounts == null || userAccounts.userId < 0\n                || callingUid == Process.SYSTEM_UID) {\n            return unfiltered;\n        }\n        UserInfo user = getUserManager().getUserInfo(userAccounts.userId);\n        if (user != null && user.isRestricted()) {\n            String[] packages = mPackageManager.getPackagesForUid(callingUid);\n            if (packages == null) {\n                packages = new String[] {};\n            }\n            // If any of the packages is a visible listed package, return the full set,\n            // otherwise return non-shared accounts only.\n            // This might be a temporary way to specify a visible list\n            String visibleList = mContext.getResources().getString(\n                    com.android.internal.R.string.config_appsAuthorizedForSharedAccounts);\n            for (String packageName : packages) {\n                if (visibleList.contains(\";\" + packageName + \";\")) {\n                    return unfiltered;\n                }\n            }\n            Account[] sharedAccounts = getSharedAccountsAsUser(userAccounts.userId);\n            if (ArrayUtils.isEmpty(sharedAccounts)) {\n                return unfiltered;\n            }\n            String requiredAccountType = \"\";\n            try {\n                // If there's an explicit callingPackage specified, check if that package\n                // opted in to see restricted accounts.\n                if (callingPackage != null) {\n                    PackageInfo pi = mPackageManager.getPackageInfo(callingPackage, 0);\n                    if (pi != null && pi.restrictedAccountType != null) {\n                        requiredAccountType = pi.restrictedAccountType;\n                    }\n                } else {\n                    // Otherwise check if the callingUid has a package that has opted in\n                    for (String packageName : packages) {\n                        PackageInfo pi = mPackageManager.getPackageInfo(packageName, 0);\n                        if (pi != null && pi.restrictedAccountType != null) {\n                            requiredAccountType = pi.restrictedAccountType;\n                            break;\n                        }\n                    }\n                }\n            } catch (NameNotFoundException e) {\n                Log.w(TAG, \"filterSharedAccounts#Package not found \" + e.getMessage());\n            }\n            Map<Account, Integer> filtered = new LinkedHashMap<>();\n            for (Map.Entry<Account, Integer> entry : unfiltered.entrySet()) {\n                Account account = entry.getKey();\n                if (account.type.equals(requiredAccountType)) {\n                    filtered.put(account, entry.getValue());\n                } else {\n                    boolean found = false;\n                    for (Account shared : sharedAccounts) {\n                        if (shared.equals(account)) {\n                            found = true;\n                            break;\n                        }\n                    }\n                    if (!found) {\n                        filtered.put(account, entry.getValue());\n                    }\n                }\n            }\n            return filtered;\n        } else {\n            return unfiltered;\n        }\n    }\n\n    /*\n     * packageName can be null. If not null, it should be used to filter out restricted accounts\n     * that the package is not allowed to access.\n     *\n     * <p>The method shouldn't be called with UserAccounts#cacheLock held, otherwise it will cause a\n     * deadlock\n     */\n    @NonNull\n    protected Account[] getAccountsFromCache(UserAccounts userAccounts, String accountType,\n            int callingUid, @Nullable String callingPackage, boolean includeManagedNotVisible) {\n        Preconditions.checkState(!Thread.holdsLock(userAccounts.cacheLock),\n                \"Method should not be called with cacheLock\");\n        if (accountType != null) {\n            Account[] accounts;\n            synchronized (userAccounts.cacheLock) {\n                accounts = userAccounts.accountCache.get(accountType);\n            }\n            if (accounts == null) {\n                return EMPTY_ACCOUNT_ARRAY;\n            } else {\n                return filterAccounts(userAccounts, Arrays.copyOf(accounts, accounts.length),\n                        callingUid, callingPackage, includeManagedNotVisible);\n            }\n        } else {\n            int totalLength = 0;\n            Account[] accountsArray;\n            synchronized (userAccounts.cacheLock) {\n                for (Account[] accounts : userAccounts.accountCache.values()) {\n                    totalLength += accounts.length;\n                }\n                if (totalLength == 0) {\n                    return EMPTY_ACCOUNT_ARRAY;\n                }\n                accountsArray = new Account[totalLength];\n                totalLength = 0;\n                for (Account[] accountsOfType : userAccounts.accountCache.values()) {\n                    System.arraycopy(accountsOfType, 0, accountsArray, totalLength,\n                            accountsOfType.length);\n                    totalLength += accountsOfType.length;\n                }\n            }\n            return filterAccounts(userAccounts, accountsArray, callingUid, callingPackage,\n                    includeManagedNotVisible);\n        }\n    }\n\n    /** protected by the {@code dbLock}, {@code cacheLock} */\n    protected void writeUserDataIntoCacheLocked(UserAccounts accounts,\n            Account account, String key, String value) {\n        Map<String, String> userDataForAccount = accounts.userDataCache.get(account);\n        if (userDataForAccount == null) {\n            userDataForAccount = accounts.accountsDb.findUserExtrasForAccount(account);\n            accounts.userDataCache.put(account, userDataForAccount);\n        }\n        if (value == null) {\n            userDataForAccount.remove(key);\n        } else {\n            userDataForAccount.put(key, value);\n        }\n    }\n\n    protected TokenCache.Value readCachedTokenInternal(\n            UserAccounts accounts,\n            Account account,\n            String tokenType,\n            String callingPackage,\n            byte[] pkgSigDigest) {\n        synchronized (accounts.cacheLock) {\n            return accounts.accountTokenCaches.get(\n                    account, tokenType, callingPackage, pkgSigDigest);\n        }\n    }\n\n    /** protected by the {@code dbLock}, {@code cacheLock} */\n    protected void writeAuthTokenIntoCacheLocked(UserAccounts accounts,\n            Account account, String key, String value) {\n        Map<String, String> authTokensForAccount = accounts.authTokenCache.get(account);\n        if (authTokensForAccount == null) {\n            authTokensForAccount = accounts.accountsDb.findAuthTokensByAccount(account);\n            accounts.authTokenCache.put(account, authTokensForAccount);\n        }\n        if (value == null) {\n            authTokensForAccount.remove(key);\n        } else {\n            authTokensForAccount.put(key, value);\n        }\n    }\n\n    protected String readAuthTokenInternal(UserAccounts accounts, Account account,\n            String authTokenType) {\n        // Fast path - check if account is already cached\n        synchronized (accounts.cacheLock) {\n            Map<String, String> authTokensForAccount = accounts.authTokenCache.get(account);\n            if (authTokensForAccount != null) {\n                return authTokensForAccount.get(authTokenType);\n            }\n        }\n        // If not cached yet - do slow path and sync with db if necessary\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                Map<String, String> authTokensForAccount = accounts.authTokenCache.get(account);\n                if (authTokensForAccount == null) {\n                    // need to populate the cache for this account\n                    authTokensForAccount = accounts.accountsDb.findAuthTokensByAccount(account);\n                    accounts.authTokenCache.put(account, authTokensForAccount);\n                }\n                return authTokensForAccount.get(authTokenType);\n            }\n        }\n    }\n\n    private String readUserDataInternal(UserAccounts accounts, Account account, String key) {\n        Map<String, String> userDataForAccount;\n        // Fast path - check if data is already cached\n        synchronized (accounts.cacheLock) {\n            userDataForAccount = accounts.userDataCache.get(account);\n        }\n        // If not cached yet - do slow path and sync with db if necessary\n        if (userDataForAccount == null) {\n            synchronized (accounts.dbLock) {\n                synchronized (accounts.cacheLock) {\n                    userDataForAccount = accounts.userDataCache.get(account);\n                    if (userDataForAccount == null) {\n                        // need to populate the cache for this account\n                        userDataForAccount = accounts.accountsDb.findUserExtrasForAccount(account);\n                        accounts.userDataCache.put(account, userDataForAccount);\n                    }\n                }\n            }\n        }\n        return userDataForAccount.get(key);\n    }\n\n    private Context getContextForUser(UserHandle user) {\n        try {\n            return mContext.createPackageContextAsUser(mContext.getPackageName(), 0, user);\n        } catch (NameNotFoundException e) {\n            // Default to mContext, not finding the package system is running as is unlikely.\n            return mContext;\n        }\n    }\n\n    private void sendResponse(IAccountManagerResponse response, Bundle result) {\n        try {\n            response.onResult(result);\n        } catch (RemoteException e) {\n            // if the caller is dead then there is no one to care about remote\n            // exceptions\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"failure while notifying response\", e);\n            }\n        }\n    }\n\n    private void sendErrorResponse(IAccountManagerResponse response, int errorCode,\n            String errorMessage) {\n        try {\n            response.onError(errorCode, errorMessage);\n        } catch (RemoteException e) {\n            // if the caller is dead then there is no one to care about remote\n            // exceptions\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"failure while notifying response\", e);\n            }\n        }\n    }\n\n    /**\n     * Returns true if the config_canRemoveOrRenameFirstUser is false, and the given account type\n     * matches the one provided by config_accountTypeToKeepFirstUser.\n     */\n    private boolean isFirstAccountRemovalDisabled(Account account) {\n        // Skip if not targeting the first user.\n        int userId = UserHandle.getCallingUserId();\n        if (userId != 0) {\n            return false;\n        }\n\n        // Skip if we are allowed to remove/rename first account.\n        if (mContext.getResources()\n                .getBoolean(com.android.internal.R.bool.config_canRemoveFirstAccount)) {\n            return false;\n        }\n\n        // Skip if needed for testing.\n        if (Settings.Secure.getIntForUser(\n                mContext.getContentResolver(),\n                Settings.Secure.ALLOW_PRIMARY_GAIA_ACCOUNT_REMOVAL_FOR_TESTS,\n                0 /* default */,\n                0 /* userHandle */) != 0) {\n            return false;\n        }\n\n        // Skip if not targeting desired account.\n        String typeToKeep =\n                mContext.getResources()\n                        .getString(\n                                com.android.internal.R.string.config_accountTypeToKeepFirstAccount);\n        if (typeToKeep.isEmpty() || !typeToKeep.equals(account.type)) {\n            return false;\n        }\n\n        // Only restrict first account.\n        UserAccounts accounts = getUserAccounts(0 /* userId */);\n        Account[] accountsOfType = getAccountsFromCache(accounts, typeToKeep,\n                Process.SYSTEM_UID, \"android\" /* packageName */, false);\n        return accountsOfType.length > 0 && accountsOfType[0].equals(account);\n    }\n\n    private final class AccountManagerInternalImpl extends AccountManagerInternal {\n        private final Object mLock = new Object();\n\n        @GuardedBy(\"mLock\")\n        private AccountManagerBackupHelper mBackupHelper;\n\n        @Override\n        public void requestAccountAccess(@NonNull Account account, @NonNull String packageName,\n                @IntRange(from = 0) int userId, @NonNull RemoteCallback callback) {\n            if (account == null) {\n                Slog.w(TAG, \"account cannot be null\");\n                return;\n            }\n            if (packageName == null) {\n                Slog.w(TAG, \"packageName cannot be null\");\n                return;\n            }\n            if (userId < UserHandle.USER_SYSTEM) {\n                Slog.w(TAG, \"user id must be concrete\");\n                return;\n            }\n            if (callback == null) {\n                Slog.w(TAG, \"callback cannot be null\");\n                return;\n            }\n\n            int visibility =\n                resolveAccountVisibility(account, packageName, getUserAccounts(userId));\n            if (visibility == AccountManager.VISIBILITY_NOT_VISIBLE) {\n                Slog.w(TAG, \"requestAccountAccess: account is hidden\");\n                return;\n            }\n\n            if (AccountManagerService.this.hasAccountAccess(account, packageName,\n                    new UserHandle(userId))) {\n                Bundle result = new Bundle();\n                result.putBoolean(AccountManager.KEY_BOOLEAN_RESULT, true);\n                callback.sendResult(result);\n                return;\n            }\n\n            final int uid;\n            try {\n                final long identityToken = clearCallingIdentity();\n                try {\n                    uid = mPackageManager.getPackageUidAsUser(packageName, userId);\n                } finally {\n                    restoreCallingIdentity(identityToken);\n                }\n            } catch (NameNotFoundException e) {\n                Slog.e(TAG, \"Unknown package \" + packageName);\n                return;\n            }\n\n            Intent intent = newRequestAccountAccessIntent(account, packageName, uid, callback);\n            final UserAccounts userAccounts;\n            synchronized (mUsers) {\n                userAccounts = mUsers.get(userId);\n            }\n            SystemNotificationChannels.createAccountChannelForPackage(packageName, uid, mContext);\n            doNotification(userAccounts, account, null, intent, packageName, userId);\n        }\n\n        @Override\n        public void addOnAppPermissionChangeListener(OnAppPermissionChangeListener listener) {\n            // Listeners are a final CopyOnWriteArrayList, hence no lock needed.\n            mAppPermissionChangeListeners.add(listener);\n        }\n\n        @Override\n        public boolean hasAccountAccess(@NonNull Account account, @IntRange(from = 0) int uid) {\n            return AccountManagerService.this.hasAccountAccess(account, null, uid);\n        }\n\n        @Override\n        public byte[] backupAccountAccessPermissions(int userId) {\n            synchronized (mLock) {\n                if (mBackupHelper == null) {\n                    mBackupHelper = new AccountManagerBackupHelper(\n                            AccountManagerService.this, this);\n                }\n                return mBackupHelper.backupAccountAccessPermissions(userId);\n            }\n        }\n\n        @Override\n        public void restoreAccountAccessPermissions(byte[] data, int userId) {\n            synchronized (mLock) {\n                if (mBackupHelper == null) {\n                    mBackupHelper = new AccountManagerBackupHelper(\n                            AccountManagerService.this, this);\n                }\n                mBackupHelper.restoreAccountAccessPermissions(data, userId);\n            }\n        }\n    }\n\n    @VisibleForTesting\n    static class Injector {\n        private final Context mContext;\n\n        public Injector(Context context) {\n            mContext = context;\n        }\n\n        Looper getMessageHandlerLooper() {\n            ServiceThread serviceThread = new ServiceThread(TAG,\n                    android.os.Process.THREAD_PRIORITY_FOREGROUND, true /* allowIo */);\n            serviceThread.start();\n            return serviceThread.getLooper();\n        }\n\n        Context getContext() {\n            return mContext;\n        }\n\n        void addLocalService(AccountManagerInternal service) {\n            LocalServices.addService(AccountManagerInternal.class, service);\n        }\n\n        String getDeDatabaseName(int userId) {\n            File databaseFile = new File(Environment.getDataSystemDeDirectory(userId),\n                    AccountsDb.DE_DATABASE_NAME);\n            return databaseFile.getPath();\n        }\n\n        String getCeDatabaseName(int userId) {\n            File databaseFile = new File(Environment.getDataSystemCeDirectory(userId),\n                    AccountsDb.CE_DATABASE_NAME);\n            return databaseFile.getPath();\n        }\n\n        String getPreNDatabaseName(int userId) {\n            File systemDir = Environment.getDataSystemDirectory();\n            File databaseFile = new File(Environment.getUserSystemDirectory(userId),\n                    PRE_N_DATABASE_NAME);\n            if (userId == 0) {\n                // Migrate old file, if it exists, to the new location.\n                // Make sure the new file doesn't already exist. A placeholder file could have been\n                // accidentally created in the old location,\n                // causing the new one to become corrupted as well.\n                File oldFile = new File(systemDir, PRE_N_DATABASE_NAME);\n                if (oldFile.exists() && !databaseFile.exists()) {\n                    // Check for use directory; create if it doesn't exist, else renameTo will fail\n                    File userDir = Environment.getUserSystemDirectory(userId);\n                    if (!userDir.exists()) {\n                        if (!userDir.mkdirs()) {\n                            throw new IllegalStateException(\n                                    \"User dir cannot be created: \" + userDir);\n                        }\n                    }\n                    if (!oldFile.renameTo(databaseFile)) {\n                        throw new IllegalStateException(\n                                \"User dir cannot be migrated: \" + databaseFile);\n                    }\n                }\n            }\n            return databaseFile.getPath();\n        }\n\n        IAccountAuthenticatorCache getAccountAuthenticatorCache() {\n            return new AccountAuthenticatorCache(mContext);\n        }\n\n        INotificationManager getNotificationManager() {\n            return NotificationManager.getService();\n        }\n    }\n\n    private static class NotificationId {\n        final String mTag;\n        private final int mId;\n\n        NotificationId(String tag, int type) {\n            mTag = tag;\n            mId = type;\n        }\n    }\n}\n```",
                        "downstream_file_content": "```java\n/*\n * Copyright (C) 2009 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.server.accounts;\n\nimport android.Manifest;\nimport android.accounts.AbstractAccountAuthenticator;\nimport android.accounts.Account;\nimport android.accounts.AccountAndUser;\nimport android.accounts.AccountAuthenticatorResponse;\nimport android.accounts.AccountManager;\nimport android.accounts.AccountManagerInternal;\nimport android.accounts.AccountManagerResponse;\nimport android.accounts.AuthenticatorDescription;\nimport android.accounts.CantAddAccountActivity;\nimport android.accounts.ChooseAccountActivity;\nimport android.accounts.GrantCredentialsPermissionActivity;\nimport android.accounts.IAccountAuthenticator;\nimport android.accounts.IAccountAuthenticatorResponse;\nimport android.accounts.IAccountManager;\nimport android.accounts.IAccountManagerResponse;\nimport android.annotation.IntRange;\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.app.ActivityManager;\nimport android.app.ActivityThread;\nimport android.app.AppOpsManager;\nimport android.app.INotificationManager;\nimport android.app.Notification;\nimport android.app.NotificationManager;\nimport android.app.PendingIntent;\nimport android.app.admin.DevicePolicyEventLogger;\nimport android.app.admin.DevicePolicyManager;\nimport android.app.admin.DevicePolicyManagerInternal;\nimport android.content.BroadcastReceiver;\nimport android.content.ClipData;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.IntentSender;\nimport android.content.ServiceConnection;\nimport android.content.pm.ActivityInfo;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.IPackageManager;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManager.NameNotFoundException;\nimport android.content.pm.PackageManagerInternal;\nimport android.content.pm.PackageParser;\nimport android.content.pm.RegisteredServicesCache;\nimport android.content.pm.RegisteredServicesCacheListener;\nimport android.content.pm.ResolveInfo;\nimport android.content.pm.Signature;\nimport android.content.pm.UserInfo;\nimport android.database.Cursor;\nimport android.database.sqlite.SQLiteStatement;\nimport android.os.Binder;\nimport android.os.Bundle;\nimport android.os.Environment;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.Parcel;\nimport android.os.Parcelable;\nimport android.os.Process;\nimport android.os.RemoteCallback;\nimport android.os.RemoteException;\nimport android.os.ResultReceiver;\nimport android.os.ShellCallback;\nimport android.os.StrictMode;\nimport android.os.SystemClock;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.stats.devicepolicy.DevicePolicyEnums;\nimport android.text.TextUtils;\nimport android.util.EventLog;\nimport android.util.Log;\nimport android.util.Pair;\nimport android.util.Slog;\nimport android.util.SparseArray;\nimport android.util.SparseBooleanArray;\n\nimport com.android.internal.R;\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.content.PackageMonitor;\nimport com.android.internal.messages.nano.SystemMessageProto.SystemMessage;\nimport com.android.internal.notification.SystemNotificationChannels;\nimport com.android.internal.util.ArrayUtils;\nimport com.android.internal.util.DumpUtils;\nimport com.android.internal.util.IndentingPrintWriter;\nimport com.android.internal.util.Preconditions;\nimport com.android.server.LocalServices;\nimport com.android.server.ServiceThread;\nimport com.android.server.SystemService;\n\nimport com.google.android.collect.Lists;\nimport com.google.android.collect.Sets;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.PrintWriter;\nimport java.security.GeneralSecurityException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.concurrent.atomic.AtomicReference;\n\n/**\n * A system service that provides  account, password, and authtoken management for all\n * accounts on the device. Some of these calls are implemented with the help of the corresponding\n * {@link IAccountAuthenticator} services. This service is not accessed by users directly,\n * instead one uses an instance of {@link AccountManager}, which can be accessed as follows:\n *    AccountManager accountManager = AccountManager.get(context);\n * @hide\n */\npublic class AccountManagerService\n        extends IAccountManager.Stub\n        implements RegisteredServicesCacheListener<AuthenticatorDescription> {\n    private static final String TAG = \"AccountManagerService\";\n\n    public static class Lifecycle extends SystemService {\n        private AccountManagerService mService;\n\n        public Lifecycle(Context context) {\n            super(context);\n        }\n\n        @Override\n        public void onStart() {\n            mService = new AccountManagerService(new Injector(getContext()));\n            publishBinderService(Context.ACCOUNT_SERVICE, mService);\n        }\n\n        @Override\n        public void onUserUnlocking(@NonNull TargetUser user) {\n            mService.onUnlockUser(user.getUserIdentifier());\n        }\n\n        @Override\n        public void onUserStopping(@NonNull TargetUser user) {\n            Slog.i(TAG, \"onStopUser \" + user);\n            mService.purgeUserData(user.getUserIdentifier());\n        }\n    }\n\n    final Context mContext;\n\n    private final PackageManager mPackageManager;\n    private final AppOpsManager mAppOpsManager;\n    private UserManager mUserManager;\n    private final Injector mInjector;\n\n    final MessageHandler mHandler;\n\n    private static final int TIMEOUT_DELAY_MS = 1000 * 60 * 15;\n    // Messages that can be sent on mHandler\n    private static final int MESSAGE_TIMED_OUT = 3;\n    private static final int MESSAGE_COPY_SHARED_ACCOUNT = 4;\n\n    private final IAccountAuthenticatorCache mAuthenticatorCache;\n    private static final String PRE_N_DATABASE_NAME = \"accounts.db\";\n    private static final Intent ACCOUNTS_CHANGED_INTENT;\n\n    private static final int SIGNATURE_CHECK_MISMATCH = 0;\n    private static final int SIGNATURE_CHECK_MATCH = 1;\n    private static final int SIGNATURE_CHECK_UID_MATCH = 2;\n\n    static {\n        ACCOUNTS_CHANGED_INTENT = new Intent(AccountManager.LOGIN_ACCOUNTS_CHANGED_ACTION);\n        ACCOUNTS_CHANGED_INTENT.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT\n                | Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);\n    }\n\n    private final LinkedHashMap<String, Session> mSessions = new LinkedHashMap<String, Session>();\n\n    static class UserAccounts {\n        private final int userId;\n        final AccountsDb accountsDb;\n        private final HashMap<Pair<Pair<Account, String>, Integer>, NotificationId>\n                credentialsPermissionNotificationIds = new HashMap<>();\n        private final HashMap<Account, NotificationId> signinRequiredNotificationIds\n                = new HashMap<>();\n        final Object cacheLock = new Object();\n        final Object dbLock = new Object(); // if needed, dbLock must be obtained before cacheLock\n        /** protected by the {@link #cacheLock} */\n        final HashMap<String, Account[]> accountCache = new LinkedHashMap<>();\n        /** protected by the {@link #cacheLock} */\n        private final Map<Account, Map<String, String>> userDataCache = new HashMap<>();\n        /** protected by the {@link #cacheLock} */\n        private final Map<Account, Map<String, String>> authTokenCache = new HashMap<>();\n        /** protected by the {@link #cacheLock} */\n        private final TokenCache accountTokenCaches = new TokenCache();\n        /** protected by the {@link #cacheLock} */\n        private final Map<Account, Map<String, Integer>> visibilityCache = new HashMap<>();\n\n        /** protected by the {@link #mReceiversForType},\n         *  type -> (packageName -> number of active receivers)\n         *  type == null is used to get notifications about all account types\n         */\n        private final Map<String, Map<String, Integer>> mReceiversForType = new HashMap<>();\n\n        /**\n         * protected by the {@link #cacheLock}\n         *\n         * Caches the previous names associated with an account. Previous names\n         * should be cached because we expect that when an Account is renamed,\n         * many clients will receive a LOGIN_ACCOUNTS_CHANGED broadcast and\n         * want to know if the accounts they care about have been renamed.\n         *\n         * The previous names are wrapped in an {@link AtomicReference} so that\n         * we can distinguish between those accounts with no previous names and\n         * those whose previous names haven't been cached (yet).\n         */\n        private final HashMap<Account, AtomicReference<String>> previousNameCache =\n                new HashMap<Account, AtomicReference<String>>();\n\n        UserAccounts(Context context, int userId, File preNDbFile, File deDbFile) {\n            this.userId = userId;\n            synchronized (dbLock) {\n                synchronized (cacheLock) {\n                    accountsDb = AccountsDb.create(context, userId, preNDbFile, deDbFile);\n                }\n            }\n        }\n    }\n\n    private final SparseArray<UserAccounts> mUsers = new SparseArray<>();\n    private final SparseBooleanArray mLocalUnlockedUsers = new SparseBooleanArray();\n    // Not thread-safe. Only use in synchronized context\n    private final SimpleDateFormat mDateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n    private CopyOnWriteArrayList<AccountManagerInternal.OnAppPermissionChangeListener>\n            mAppPermissionChangeListeners = new CopyOnWriteArrayList<>();\n\n    private static AtomicReference<AccountManagerService> sThis = new AtomicReference<>();\n    private static final Account[] EMPTY_ACCOUNT_ARRAY = new Account[]{};\n\n    /**\n     * This should only be called by system code. One should only call this after the service\n     * has started.\n     * @return a reference to the AccountManagerService instance\n     * @hide\n     */\n    public static AccountManagerService getSingleton() {\n        return sThis.get();\n    }\n\n    public AccountManagerService(Injector injector) {\n        mInjector = injector;\n        mContext = injector.getContext();\n        mPackageManager = mContext.getPackageManager();\n        mAppOpsManager = mContext.getSystemService(AppOpsManager.class);\n        mHandler = new MessageHandler(injector.getMessageHandlerLooper());\n        mAuthenticatorCache = mInjector.getAccountAuthenticatorCache();\n        mAuthenticatorCache.setListener(this, mHandler);\n\n        sThis.set(this);\n\n        IntentFilter intentFilter = new IntentFilter();\n        intentFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);\n        intentFilter.addDataScheme(\"package\");\n        mContext.registerReceiver(new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context1, Intent intent) {\n                // Don't delete accounts when updating a authenticator's\n                // package.\n                if (!intent.getBooleanExtra(Intent.EXTRA_REPLACING, false)) {\n                    /* Purging data requires file io, don't block the main thread. This is probably\n                     * less than ideal because we are introducing a race condition where old grants\n                     * could be exercised until they are purged. But that race condition existed\n                     * anyway with the broadcast receiver.\n                     *\n                     * Ideally, we would completely clear the cache, purge data from the database,\n                     * and then rebuild the cache. All under the cache lock. But that change is too\n                     * large at this point.\n                     */\n                    final String removedPackageName = intent.getData().getSchemeSpecificPart();\n                    Runnable purgingRunnable = new Runnable() {\n                        @Override\n                        public void run() {\n                            purgeOldGrantsAll();\n                            // Notify authenticator about removed app?\n                            removeVisibilityValuesForPackage(removedPackageName);\n                        }\n                    };\n                    mHandler.post(purgingRunnable);\n                }\n            }\n        }, intentFilter);\n\n        injector.addLocalService(new AccountManagerInternalImpl());\n\n        IntentFilter userFilter = new IntentFilter();\n        userFilter.addAction(Intent.ACTION_USER_REMOVED);\n        mContext.registerReceiverAsUser(new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                String action = intent.getAction();\n                if (Intent.ACTION_USER_REMOVED.equals(action)) {\n                    int userId = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, -1);\n                    if (userId < 1) return;\n                    Slog.i(TAG, \"User \" + userId + \" removed\");\n                    purgeUserData(userId);\n                }\n            }\n        }, UserHandle.ALL, userFilter, null, null);\n\n        // Need to cancel account request notifications if the update/install can access the account\n        new PackageMonitor() {\n            @Override\n            public void onPackageAdded(String packageName, int uid) {\n                // Called on a handler, and running as the system\n                cancelAccountAccessRequestNotificationIfNeeded(uid, true);\n            }\n\n            @Override\n            public void onPackageUpdateFinished(String packageName, int uid) {\n                // Called on a handler, and running as the system\n                cancelAccountAccessRequestNotificationIfNeeded(uid, true);\n            }\n        }.register(mContext, mHandler.getLooper(), UserHandle.ALL, true);\n\n        // Cancel account request notification if an app op was preventing the account access\n        mAppOpsManager.startWatchingMode(AppOpsManager.OP_GET_ACCOUNTS, null,\n                new AppOpsManager.OnOpChangedInternalListener() {\n            @Override\n            public void onOpChanged(int op, String packageName) {\n                try {\n                    final int userId = ActivityManager.getCurrentUser();\n                    final int uid = mPackageManager.getPackageUidAsUser(packageName, userId);\n                    final int mode = mAppOpsManager.checkOpNoThrow(\n                            AppOpsManager.OP_GET_ACCOUNTS, uid, packageName);\n                    if (mode == AppOpsManager.MODE_ALLOWED) {\n                        final long identity = Binder.clearCallingIdentity();\n                        try {\n                            cancelAccountAccessRequestNotificationIfNeeded(packageName, uid, true);\n                        } finally {\n                            Binder.restoreCallingIdentity(identity);\n                        }\n                    }\n                } catch (NameNotFoundException e) {\n                    /* ignore */\n                }\n            }\n        });\n\n        // Cancel account request notification if a permission was preventing the account access\n        mPackageManager.addOnPermissionsChangeListener(\n                (int uid) -> {\n            // Permission changes cause requires updating accounts cache.\n            AccountManager.invalidateLocalAccountsDataCaches();\n\n            Account[] accounts = null;\n            String[] packageNames = mPackageManager.getPackagesForUid(uid);\n            if (packageNames != null) {\n                final int userId = UserHandle.getUserId(uid);\n                final long identity = Binder.clearCallingIdentity();\n                try {\n                    for (String packageName : packageNames) {\n                                // if app asked for permission we need to cancel notification even\n                                // for O+ applications.\n                                if (mPackageManager.checkPermission(\n                                        Manifest.permission.GET_ACCOUNTS,\n                                        packageName) != PackageManager.PERMISSION_GRANTED) {\n                                    continue;\n                                }\n\n                        if (accounts == null) {\n                            accounts = getAccountsAsUser(null, userId, \"android\");\n                            if (ArrayUtils.isEmpty(accounts)) {\n                                return;\n                            }\n                        }\n\n                        for (Account account : accounts) {\n                            cancelAccountAccessRequestNotificationIfNeeded(\n                                    account, uid, packageName, true);\n                        }\n                    }\n                } finally {\n                    Binder.restoreCallingIdentity(identity);\n                }\n            }\n        });\n    }\n\n\n    boolean getBindInstantServiceAllowed(int userId) {\n        return  mAuthenticatorCache.getBindInstantServiceAllowed(userId);\n    }\n\n    void setBindInstantServiceAllowed(int userId, boolean allowed) {\n        mAuthenticatorCache.setBindInstantServiceAllowed(userId, allowed);\n    }\n\n    private void cancelAccountAccessRequestNotificationIfNeeded(int uid,\n            boolean checkAccess) {\n        Account[] accounts = getAccountsAsUser(null, UserHandle.getUserId(uid), \"android\");\n        for (Account account : accounts) {\n            cancelAccountAccessRequestNotificationIfNeeded(account, uid, checkAccess);\n        }\n    }\n\n    private void cancelAccountAccessRequestNotificationIfNeeded(String packageName, int uid,\n            boolean checkAccess) {\n        Account[] accounts = getAccountsAsUser(null, UserHandle.getUserId(uid), \"android\");\n        for (Account account : accounts) {\n            cancelAccountAccessRequestNotificationIfNeeded(account, uid, packageName, checkAccess);\n        }\n    }\n\n    private void cancelAccountAccessRequestNotificationIfNeeded(Account account, int uid,\n            boolean checkAccess) {\n        String[] packageNames = mPackageManager.getPackagesForUid(uid);\n        if (packageNames != null) {\n            for (String packageName : packageNames) {\n                cancelAccountAccessRequestNotificationIfNeeded(account, uid,\n                        packageName, checkAccess);\n            }\n        }\n    }\n\n    private void cancelAccountAccessRequestNotificationIfNeeded(Account account,\n            int uid, String packageName, boolean checkAccess) {\n        if (!checkAccess || hasAccountAccess(account, packageName,\n                UserHandle.getUserHandleForUid(uid))) {\n            cancelNotification(getCredentialPermissionNotificationId(account,\n                    AccountManager.ACCOUNT_ACCESS_TOKEN_TYPE, uid),\n                    UserHandle.getUserHandleForUid(uid));\n        }\n    }\n\n    @Override\n    public boolean addAccountExplicitlyWithVisibility(Account account, String password,\n            Bundle extras, Map packageToVisibility, String opPackageName) {\n        Bundle.setDefusable(extras, true);\n        int callingUid = Binder.getCallingUid();\n        int userId = UserHandle.getCallingUserId();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"addAccountExplicitly: \" + account + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\"uid %s cannot explicitly add accounts of type: %s\",\n                    callingUid, account.type);\n            throw new SecurityException(msg);\n        }\n        /*\n         * Child users are not allowed to add accounts. Only the accounts that are shared by the\n         * parent profile can be added to child profile.\n         *\n         * TODO: Only allow accounts that were shared to be added by a limited user.\n         */\n        // fails if the account already exists\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return addAccountInternal(accounts, account, password, extras, callingUid,\n                    (Map<String, Integer>) packageToVisibility, opPackageName);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public Map<Account, Integer> getAccountsAndVisibilityForPackage(String packageName,\n            String accountType) {\n        int callingUid = Binder.getCallingUid();\n        int userId = UserHandle.getCallingUserId();\n        boolean isSystemUid = UserHandle.isSameApp(callingUid, Process.SYSTEM_UID);\n        List<String> managedTypes = getTypesForCaller(callingUid, userId, isSystemUid);\n\n        if ((accountType != null && !managedTypes.contains(accountType))\n                || (accountType == null && !isSystemUid)) {\n            throw new SecurityException(\n                    \"getAccountsAndVisibilityForPackage() called from unauthorized uid \"\n                            + callingUid + \" with packageName=\" + packageName);\n        }\n        if (accountType != null) {\n            managedTypes = new ArrayList<String>();\n            managedTypes.add(accountType);\n        }\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return getAccountsAndVisibilityForPackage(packageName, managedTypes, callingUid,\n                    accounts);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    /*\n     * accountTypes may not be null\n     */\n    private Map<Account, Integer> getAccountsAndVisibilityForPackage(String packageName,\n            List<String> accountTypes, Integer callingUid, UserAccounts accounts) {\n        if (!packageExistsForUser(packageName, accounts.userId)) {\n            Log.d(TAG, \"Package not found \" + packageName);\n            return new LinkedHashMap<>();\n        }\n\n        Map<Account, Integer> result = new LinkedHashMap<>();\n        for (String accountType : accountTypes) {\n            synchronized (accounts.dbLock) {\n                synchronized (accounts.cacheLock) {\n                    final Account[] accountsOfType = accounts.accountCache.get(accountType);\n                    if (accountsOfType != null) {\n                        for (Account account : accountsOfType) {\n                            result.put(account,\n                                    resolveAccountVisibility(account, packageName, accounts));\n                        }\n                    }\n                }\n            }\n        }\n        return filterSharedAccounts(accounts, result, callingUid, packageName);\n    }\n\n    @Override\n    public Map<String, Integer> getPackagesAndVisibilityForAccount(Account account) {\n        Objects.requireNonNull(account, \"account cannot be null\");\n        int callingUid = Binder.getCallingUid();\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)\n                && !isSystemUid(callingUid)) {\n            String msg =\n                    String.format(\"uid %s cannot get secrets for account %s\", callingUid, account);\n            throw new SecurityException(msg);\n        }\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            synchronized (accounts.dbLock) {\n                synchronized (accounts.cacheLock) {\n                    return getPackagesAndVisibilityForAccountLocked(account, accounts);\n                }\n            }\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n\n    }\n\n    /**\n     * Returns Map with all package names and visibility values for given account.\n     * The method and returned map must be guarded by accounts.cacheLock\n     *\n     * @param account Account to get visibility values.\n     * @param accounts UserAccount that currently hosts the account and application\n     *\n     * @return Map with cache for package names to visibility.\n     */\n    private @NonNull Map<String, Integer> getPackagesAndVisibilityForAccountLocked(Account account,\n            UserAccounts accounts) {\n        Map<String, Integer> accountVisibility = accounts.visibilityCache.get(account);\n        if (accountVisibility == null) {\n            Log.d(TAG, \"Visibility was not initialized\");\n            accountVisibility = new HashMap<>();\n            accounts.visibilityCache.put(account, accountVisibility);\n            AccountManager.invalidateLocalAccountsDataCaches();\n        }\n        return accountVisibility;\n    }\n\n    @Override\n    public int getAccountVisibility(Account account, String packageName) {\n        Objects.requireNonNull(account, \"account cannot be null\");\n        Objects.requireNonNull(packageName, \"packageName cannot be null\");\n        int callingUid = Binder.getCallingUid();\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)\n            && !isSystemUid(callingUid)) {\n            String msg = String.format(\n                    \"uid %s cannot get secrets for accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            if (AccountManager.PACKAGE_NAME_KEY_LEGACY_VISIBLE.equals(packageName)) {\n                int visibility = getAccountVisibilityFromCache(account, packageName, accounts);\n                if (AccountManager.VISIBILITY_UNDEFINED != visibility) {\n                    return visibility;\n                } else {\n                   return AccountManager.VISIBILITY_USER_MANAGED_VISIBLE;\n                }\n            }\n            if (AccountManager.PACKAGE_NAME_KEY_LEGACY_NOT_VISIBLE.equals(packageName)) {\n                int visibility = getAccountVisibilityFromCache(account, packageName, accounts);\n                if (AccountManager.VISIBILITY_UNDEFINED != visibility) {\n                    return visibility;\n                } else {\n                   return AccountManager.VISIBILITY_USER_MANAGED_NOT_VISIBLE;\n                }\n            }\n            return resolveAccountVisibility(account, packageName, accounts);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    /**\n     * Method returns visibility for given account and package name.\n     *\n     * @param account The account to check visibility.\n     * @param packageName Package name to check visibility.\n     * @param accounts UserAccount that currently hosts the account and application\n     *\n     * @return Visibility value, AccountManager.VISIBILITY_UNDEFINED if no value was stored.\n     *\n     */\n    private int getAccountVisibilityFromCache(Account account, String packageName,\n            UserAccounts accounts) {\n        synchronized (accounts.cacheLock) {\n            Map<String, Integer> accountVisibility =\n                    getPackagesAndVisibilityForAccountLocked(account, accounts);\n            Integer visibility = accountVisibility.get(packageName);\n            return visibility != null ? visibility : AccountManager.VISIBILITY_UNDEFINED;\n        }\n    }\n\n    /**\n     * Method which handles default values for Account visibility.\n     *\n     * @param account The account to check visibility.\n     * @param packageName Package name to check visibility\n     * @param accounts UserAccount that currently hosts the account and application\n     *\n     * @return Visibility value, the method never returns AccountManager.VISIBILITY_UNDEFINED\n     *\n     */\n    private Integer resolveAccountVisibility(Account account, @NonNull String packageName,\n            UserAccounts accounts) {\n        Objects.requireNonNull(packageName, \"packageName cannot be null\");\n        int uid = -1;\n        try {\n            final long identityToken = clearCallingIdentity();\n            try {\n                uid = mPackageManager.getPackageUidAsUser(packageName, accounts.userId);\n            } finally {\n                restoreCallingIdentity(identityToken);\n            }\n        } catch (NameNotFoundException e) {\n            Log.d(TAG, \"Package not found \" + e.getMessage());\n            return AccountManager.VISIBILITY_NOT_VISIBLE;\n        }\n\n        // System visibility can not be restricted.\n        if (UserHandle.isSameApp(uid, Process.SYSTEM_UID)) {\n            return AccountManager.VISIBILITY_VISIBLE;\n        }\n\n        int signatureCheckResult =\n                checkPackageSignature(account.type, uid, accounts.userId);\n\n        // Authenticator can not restrict visibility to itself.\n        if (signatureCheckResult == SIGNATURE_CHECK_UID_MATCH) {\n            return AccountManager.VISIBILITY_VISIBLE; // Authenticator can always see the account\n        }\n\n        // Return stored value if it was set.\n        int visibility = getAccountVisibilityFromCache(account, packageName, accounts);\n\n        if (AccountManager.VISIBILITY_UNDEFINED != visibility) {\n            return visibility;\n        }\n\n        boolean isPrivileged = isPermittedForPackage(packageName, accounts.userId,\n                Manifest.permission.GET_ACCOUNTS_PRIVILEGED);\n\n        // Device/Profile owner gets visibility by default.\n        if (isProfileOwner(uid)) {\n            return AccountManager.VISIBILITY_VISIBLE;\n        }\n\n        boolean preO = isPreOApplication(packageName);\n        if ((signatureCheckResult != SIGNATURE_CHECK_MISMATCH)\n                || (preO && checkGetAccountsPermission(packageName, accounts.userId))\n                || (checkReadContactsPermission(packageName, accounts.userId)\n                    && accountTypeManagesContacts(account.type, accounts.userId))\n                || isPrivileged) {\n            // Use legacy for preO apps with GET_ACCOUNTS permission or pre/postO with signature\n            // match.\n            visibility = getAccountVisibilityFromCache(account,\n                    AccountManager.PACKAGE_NAME_KEY_LEGACY_VISIBLE, accounts);\n            if (AccountManager.VISIBILITY_UNDEFINED == visibility) {\n                visibility = AccountManager.VISIBILITY_USER_MANAGED_VISIBLE;\n            }\n        } else {\n            visibility = getAccountVisibilityFromCache(account,\n                    AccountManager.PACKAGE_NAME_KEY_LEGACY_NOT_VISIBLE, accounts);\n            if (AccountManager.VISIBILITY_UNDEFINED == visibility) {\n                visibility = AccountManager.VISIBILITY_USER_MANAGED_NOT_VISIBLE;\n            }\n        }\n        return visibility;\n    }\n\n    /**\n     * Checks targetSdk for a package;\n     *\n     * @param packageName Package name\n     *\n     * @return True if package's target SDK is below {@link android.os.Build.VERSION_CODES#O}, or\n     *         undefined\n     */\n    private boolean isPreOApplication(String packageName) {\n        try {\n            final long identityToken = clearCallingIdentity();\n            ApplicationInfo applicationInfo;\n            try {\n                applicationInfo = mPackageManager.getApplicationInfo(packageName, 0);\n            } finally {\n                restoreCallingIdentity(identityToken);\n            }\n\n            if (applicationInfo != null) {\n                int version = applicationInfo.targetSdkVersion;\n                return version < android.os.Build.VERSION_CODES.O;\n            }\n            return true;\n        } catch (NameNotFoundException e) {\n            Log.d(TAG, \"Package not found \" + e.getMessage());\n            return true;\n        }\n    }\n\n    @Override\n    public boolean setAccountVisibility(Account account, String packageName, int newVisibility) {\n        Objects.requireNonNull(account, \"account cannot be null\");\n        Objects.requireNonNull(packageName, \"packageName cannot be null\");\n        int callingUid = Binder.getCallingUid();\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)\n            && !isSystemUid(callingUid)) {\n            String msg = String.format(\n                    \"uid %s cannot get secrets for accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return setAccountVisibility(account, packageName, newVisibility, true /* notify */,\n                accounts);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private boolean isVisible(int visibility) {\n        return visibility == AccountManager.VISIBILITY_VISIBLE ||\n            visibility == AccountManager.VISIBILITY_USER_MANAGED_VISIBLE;\n    }\n\n    /**\n     * Updates visibility for given account name and package.\n     *\n     * @param account Account to update visibility.\n     * @param packageName Package name for which visibility is updated.\n     * @param newVisibility New visibility calue\n     * @param notify if the flag is set applications will get notification about visibility change\n     * @param accounts UserAccount that currently hosts the account and application\n     *\n     * @return True if account visibility was changed.\n     */\n    private boolean setAccountVisibility(Account account, String packageName, int newVisibility,\n            boolean notify, UserAccounts accounts) {\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                Map<String, Integer> packagesToVisibility;\n                List<String> accountRemovedReceivers;\n                if (notify) {\n                    if (isSpecialPackageKey(packageName)) {\n                        packagesToVisibility =\n                                getRequestingPackages(account, accounts);\n                        accountRemovedReceivers = getAccountRemovedReceivers(account, accounts);\n                    } else {\n                        if (!packageExistsForUser(packageName, accounts.userId)) {\n                            return false; // package is not installed.\n                        }\n                        packagesToVisibility = new HashMap<>();\n                        packagesToVisibility.put(packageName,\n                                resolveAccountVisibility(account, packageName, accounts));\n                        accountRemovedReceivers = new ArrayList<>();\n                        if (shouldNotifyPackageOnAccountRemoval(account, packageName, accounts)) {\n                            accountRemovedReceivers.add(packageName);\n                        }\n                    }\n                } else {\n                    // Notifications will not be send - only used during add account.\n                    if (!isSpecialPackageKey(packageName) &&\n                            !packageExistsForUser(packageName, accounts.userId)) {\n                        // package is not installed and not meta value.\n                        return false;\n                    }\n                    packagesToVisibility = Collections.emptyMap();\n                    accountRemovedReceivers = Collections.emptyList();\n                }\n\n                if (!updateAccountVisibilityLocked(account, packageName, newVisibility, accounts)) {\n                    return false;\n                }\n\n                if (notify) {\n                    for (Entry<String, Integer> packageToVisibility : packagesToVisibility\n                            .entrySet()) {\n                        int oldVisibility = packageToVisibility.getValue();\n                        int currentVisibility =\n                            resolveAccountVisibility(account, packageName, accounts);\n                        if (isVisible(oldVisibility) != isVisible(currentVisibility)) {\n                            notifyPackage(packageToVisibility.getKey(), accounts);\n                        }\n                    }\n                    for (String packageNameToNotify : accountRemovedReceivers) {\n                        sendAccountRemovedBroadcast(account, packageNameToNotify, accounts.userId);\n                    }\n                    sendAccountsChangedBroadcast(accounts.userId);\n                }\n                return true;\n            }\n        }\n    }\n\n    // Update account visibility in cache and database.\n    private boolean updateAccountVisibilityLocked(Account account, String packageName,\n            int newVisibility, UserAccounts accounts) {\n        final long accountId = accounts.accountsDb.findDeAccountId(account);\n        if (accountId < 0) {\n            return false;\n        }\n\n        final StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskWrites();\n        try {\n            if (!accounts.accountsDb.setAccountVisibility(accountId, packageName,\n                    newVisibility)) {\n                return false;\n            }\n        } finally {\n            StrictMode.setThreadPolicy(oldPolicy);\n        }\n        Map<String, Integer> accountVisibility =\n            getPackagesAndVisibilityForAccountLocked(account, accounts);\n        accountVisibility.put(packageName, newVisibility);\n        AccountManager.invalidateLocalAccountsDataCaches();\n        return true;\n    }\n\n    @Override\n    public void registerAccountListener(String[] accountTypes, String opPackageName) {\n        int callingUid = Binder.getCallingUid();\n        mAppOpsManager.checkPackage(callingUid, opPackageName);\n\n        int userId = UserHandle.getCallingUserId();\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            registerAccountListener(accountTypes, opPackageName, accounts);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private void registerAccountListener(String[] accountTypes, String opPackageName,\n            UserAccounts accounts) {\n        synchronized (accounts.mReceiversForType) {\n            if (accountTypes == null) {\n                // null for any type\n                accountTypes = new String[] {null};\n            }\n            for (String type : accountTypes) {\n                Map<String, Integer> receivers = accounts.mReceiversForType.get(type);\n                if (receivers == null) {\n                    receivers = new HashMap<>();\n                    accounts.mReceiversForType.put(type, receivers);\n                }\n                Integer cnt = receivers.get(opPackageName);\n                receivers.put(opPackageName, cnt != null ? cnt + 1 : 1);\n            }\n        }\n    }\n\n    @Override\n    public void unregisterAccountListener(String[] accountTypes, String opPackageName) {\n        int callingUid = Binder.getCallingUid();\n        mAppOpsManager.checkPackage(callingUid, opPackageName);\n        int userId = UserHandle.getCallingUserId();\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            unregisterAccountListener(accountTypes, opPackageName, accounts);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private void unregisterAccountListener(String[] accountTypes, String opPackageName,\n            UserAccounts accounts) {\n        synchronized (accounts.mReceiversForType) {\n            if (accountTypes == null) {\n                // null for any type\n                accountTypes = new String[] {null};\n            }\n            for (String type : accountTypes) {\n                Map<String, Integer> receivers = accounts.mReceiversForType.get(type);\n                if (receivers == null || receivers.get(opPackageName) == null) {\n                    throw new IllegalArgumentException(\"attempt to unregister wrong receiver\");\n                }\n                Integer cnt = receivers.get(opPackageName);\n                if (cnt == 1) {\n                    receivers.remove(opPackageName);\n                } else {\n                    receivers.put(opPackageName, cnt - 1);\n                }\n            }\n        }\n    }\n\n    // Send notification to all packages which can potentially see the account\n    private void sendNotificationAccountUpdated(Account account, UserAccounts accounts) {\n        Map<String, Integer> packagesToVisibility = getRequestingPackages(account, accounts);\n\n        for (Entry<String, Integer> packageToVisibility : packagesToVisibility.entrySet()) {\n            if ((packageToVisibility.getValue() != AccountManager.VISIBILITY_NOT_VISIBLE)\n                    && (packageToVisibility.getValue()\n                        != AccountManager.VISIBILITY_USER_MANAGED_NOT_VISIBLE)) {\n                notifyPackage(packageToVisibility.getKey(), accounts);\n            }\n        }\n    }\n\n    /**\n     * Sends a direct intent to a package, notifying it of account visibility change.\n     *\n     * @param packageName to send Account to\n     * @param accounts UserAccount that currently hosts the account\n     */\n    private void notifyPackage(String packageName, UserAccounts accounts) {\n        Intent intent = new Intent(AccountManager.ACTION_VISIBLE_ACCOUNTS_CHANGED);\n        intent.setPackage(packageName);\n        intent.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);\n        mContext.sendBroadcastAsUser(intent, new UserHandle(accounts.userId));\n    }\n\n    // Returns a map from package name to visibility, for packages subscribed\n    // to notifications about any account type, or type of provided account\n    // account type or all types.\n    private Map<String, Integer> getRequestingPackages(Account account, UserAccounts accounts) {\n        Set<String> packages = new HashSet<>();\n        synchronized (accounts.mReceiversForType) {\n            for (String type : new String[] {account.type, null}) {\n                Map<String, Integer> receivers = accounts.mReceiversForType.get(type);\n                if (receivers != null) {\n                    packages.addAll(receivers.keySet());\n                }\n            }\n        }\n        Map<String, Integer> result = new HashMap<>();\n        for (String packageName : packages) {\n            result.put(packageName, resolveAccountVisibility(account, packageName, accounts));\n        }\n        return result;\n    }\n\n    // Returns a list of packages listening to ACTION_ACCOUNT_REMOVED able to see the account.\n    private List<String> getAccountRemovedReceivers(Account account, UserAccounts accounts) {\n        Intent intent = new Intent(AccountManager.ACTION_ACCOUNT_REMOVED);\n        intent.setFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);\n        List<ResolveInfo> receivers =\n            mPackageManager.queryBroadcastReceiversAsUser(intent, 0, accounts.userId);\n        List<String> result = new ArrayList<>();\n        if (receivers == null) {\n            return result;\n        }\n        for (ResolveInfo resolveInfo: receivers) {\n            String packageName = resolveInfo.activityInfo.applicationInfo.packageName;\n            int visibility = resolveAccountVisibility(account, packageName, accounts);\n            if (visibility == AccountManager.VISIBILITY_VISIBLE\n                || visibility == AccountManager.VISIBILITY_USER_MANAGED_VISIBLE) {\n                result.add(packageName);\n            }\n        }\n        return result;\n    }\n\n    // Returns true if given package is listening to ACTION_ACCOUNT_REMOVED and can see the account.\n    private boolean shouldNotifyPackageOnAccountRemoval(Account account,\n            String packageName, UserAccounts accounts) {\n        int visibility = resolveAccountVisibility(account, packageName, accounts);\n        if (visibility != AccountManager.VISIBILITY_VISIBLE\n            && visibility != AccountManager.VISIBILITY_USER_MANAGED_VISIBLE) {\n            return false;\n        }\n\n        Intent intent = new Intent(AccountManager.ACTION_ACCOUNT_REMOVED);\n        intent.setFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);\n        intent.setPackage(packageName);\n        List<ResolveInfo> receivers =\n            mPackageManager.queryBroadcastReceiversAsUser(intent, 0, accounts.userId);\n        return (receivers != null && receivers.size() > 0);\n    }\n\n    private boolean packageExistsForUser(String packageName, int userId) {\n        try {\n            final long identityToken = clearCallingIdentity();\n            try {\n                mPackageManager.getPackageUidAsUser(packageName, userId);\n                return true;\n            } finally {\n                restoreCallingIdentity(identityToken);\n            }\n        } catch (NameNotFoundException e) {\n            return false;\n        }\n    }\n\n    /**\n     * Returns true if packageName is one of special values.\n     */\n    private boolean isSpecialPackageKey(String packageName) {\n        return (AccountManager.PACKAGE_NAME_KEY_LEGACY_VISIBLE.equals(packageName)\n                || AccountManager.PACKAGE_NAME_KEY_LEGACY_NOT_VISIBLE.equals(packageName));\n    }\n\n    private void sendAccountsChangedBroadcast(int userId) {\n        Log.i(TAG, \"the accounts changed, sending broadcast of \"\n                + ACCOUNTS_CHANGED_INTENT.getAction());\n        mContext.sendBroadcastAsUser(ACCOUNTS_CHANGED_INTENT, new UserHandle(userId));\n    }\n\n    private void sendAccountRemovedBroadcast(Account account, String packageName, int userId) {\n        Intent intent = new Intent(AccountManager.ACTION_ACCOUNT_REMOVED);\n        intent.setFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);\n        intent.setPackage(packageName);\n        intent.putExtra(AccountManager.KEY_ACCOUNT_NAME, account.name);\n        intent.putExtra(AccountManager.KEY_ACCOUNT_TYPE, account.type);\n        mContext.sendBroadcastAsUser(intent, new UserHandle(userId));\n    }\n\n    @Override\n    public boolean onTransact(int code, Parcel data, Parcel reply, int flags)\n            throws RemoteException {\n        try {\n            return super.onTransact(code, data, reply, flags);\n        } catch (RuntimeException e) {\n            // The account manager only throws security exceptions, so let's\n            // log all others.\n            if (!(e instanceof SecurityException || e instanceof IllegalArgumentException)) {\n                Slog.wtf(TAG, \"Account Manager Crash\", e);\n            }\n            throw e;\n        }\n    }\n\n    private UserManager getUserManager() {\n        if (mUserManager == null) {\n            mUserManager = UserManager.get(mContext);\n        }\n        return mUserManager;\n    }\n\n    /**\n     * Validate internal set of accounts against installed authenticators for\n     * given user. Clears cached authenticators before validating.\n     */\n    public void validateAccounts(int userId) {\n        final UserAccounts accounts = getUserAccounts(userId);\n        // Invalidate user-specific cache to make sure we catch any\n        // removed authenticators.\n        validateAccountsInternal(accounts, true /* invalidateAuthenticatorCache */);\n    }\n\n    /**\n     * Validate internal set of accounts against installed authenticators for\n     * given user. Clear cached authenticators before validating when requested.\n     */\n    private void validateAccountsInternal(\n            UserAccounts accounts, boolean invalidateAuthenticatorCache) {\n        if (Log.isLoggable(TAG, Log.DEBUG)) {\n            Log.d(TAG, \"validateAccountsInternal \" + accounts.userId\n                    + \" isCeDatabaseAttached=\" + accounts.accountsDb.isCeDatabaseAttached()\n                    + \" userLocked=\" + mLocalUnlockedUsers.get(accounts.userId));\n        }\n\n        if (invalidateAuthenticatorCache) {\n            mAuthenticatorCache.invalidateCache(accounts.userId);\n        }\n\n        final HashMap<String, Integer> knownAuth = getAuthenticatorTypeAndUIDForUser(\n                mAuthenticatorCache, accounts.userId);\n        boolean userUnlocked = isLocalUnlockedUser(accounts.userId);\n\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                boolean accountDeleted = false;\n\n                // Get a map of stored authenticator types to UID\n                final AccountsDb accountsDb = accounts.accountsDb;\n                Map<String, Integer> metaAuthUid = accountsDb.findMetaAuthUid();\n                // Create a list of authenticator type whose previous uid no longer exists\n                HashSet<String> obsoleteAuthType = Sets.newHashSet();\n                SparseBooleanArray knownUids = null;\n                for (Entry<String, Integer> authToUidEntry : metaAuthUid.entrySet()) {\n                    String type = authToUidEntry.getKey();\n                    int uid = authToUidEntry.getValue();\n                    Integer knownUid = knownAuth.get(type);\n                    if (knownUid != null && uid == knownUid) {\n                        // Remove it from the knownAuth list if it's unchanged.\n                        knownAuth.remove(type);\n                    } else {\n                    /*\n                     * The authenticator is presently not cached and should only be triggered\n                     * when we think an authenticator has been removed (or is being updated).\n                     * But we still want to check if any data with the associated uid is\n                     * around. This is an (imperfect) signal that the package may be updating.\n                     *\n                     * A side effect of this is that an authenticator sharing a uid with\n                     * multiple apps won't get its credentials wiped as long as some app with\n                     * that uid is still on the device. But I suspect that this is a rare case.\n                     * And it isn't clear to me how an attacker could really exploit that\n                     * feature.\n                     *\n                     * The upshot is that we don't have to worry about accounts getting\n                     * uninstalled while the authenticator's package is being updated.\n                     *\n                     */\n                        if (knownUids == null) {\n                            knownUids = getUidsOfInstalledOrUpdatedPackagesAsUser(accounts.userId);\n                        }\n                        if (!knownUids.get(uid)) {\n                            // The authenticator is not presently available to the cache. And the\n                            // package no longer has a data directory (so we surmise it isn't\n                            // updating). So purge its data from the account databases.\n                            obsoleteAuthType.add(type);\n                            // And delete it from the TABLE_META\n                            accountsDb.deleteMetaByAuthTypeAndUid(type, uid);\n                        } else if (knownUid != null && knownUid != uid) {\n                            Slog.w(TAG, \"authenticator no longer exist for type \" + type);\n                            obsoleteAuthType.add(type);\n                            accountsDb.deleteMetaByAuthTypeAndUid(type, uid);\n                        }\n                    }\n                }\n\n                // Add the newly registered authenticator to TABLE_META. If old authenticators have\n                // been re-enabled (after being updated for example), then we just overwrite the old\n                // values.\n                for (Entry<String, Integer> entry : knownAuth.entrySet()) {\n                    accountsDb.insertOrReplaceMetaAuthTypeAndUid(entry.getKey(), entry.getValue());\n                }\n\n                final Map<Long, Account> accountsMap = accountsDb.findAllDeAccounts();\n                try {\n                    accounts.accountCache.clear();\n                    final HashMap<String, ArrayList<String>> accountNamesByType\n                            = new LinkedHashMap<>();\n                    for (Entry<Long, Account> accountEntry : accountsMap.entrySet()) {\n                        final long accountId = accountEntry.getKey();\n                        final Account account = accountEntry.getValue();\n                        if (obsoleteAuthType.contains(account.type)) {\n                            Slog.w(TAG, \"deleting account \" + account.toSafeString()\n                                    + \" because type \" + account.type\n                                    + \"'s registered authenticator no longer exist.\");\n                            Map<String, Integer> packagesToVisibility =\n                                    getRequestingPackages(account, accounts);\n                            List<String> accountRemovedReceivers =\n                                getAccountRemovedReceivers(account, accounts);\n                            accountsDb.beginTransaction();\n                            try {\n                                accountsDb.deleteDeAccount(accountId);\n                                // Also delete from CE table if user is unlocked; if user is\n                                // currently locked the account will be removed later by\n                                // syncDeCeAccountsLocked\n                                if (userUnlocked) {\n                                    accountsDb.deleteCeAccount(accountId);\n                                }\n                                accountsDb.setTransactionSuccessful();\n                            } finally {\n                                accountsDb.endTransaction();\n                            }\n                            accountDeleted = true;\n\n                            logRecord(AccountsDb.DEBUG_ACTION_AUTHENTICATOR_REMOVE,\n                                    AccountsDb.TABLE_ACCOUNTS, accountId, accounts);\n\n                            accounts.userDataCache.remove(account);\n                            accounts.authTokenCache.remove(account);\n                            accounts.accountTokenCaches.remove(account);\n                            accounts.visibilityCache.remove(account);\n\n                            for (Entry<String, Integer> packageToVisibility :\n                                    packagesToVisibility.entrySet()) {\n                                if (isVisible(packageToVisibility.getValue())) {\n                                    notifyPackage(packageToVisibility.getKey(), accounts);\n                                }\n                            }\n                            for (String packageName : accountRemovedReceivers) {\n                                sendAccountRemovedBroadcast(account, packageName, accounts.userId);\n                            }\n                        } else {\n                            ArrayList<String> accountNames = accountNamesByType.get(account.type);\n                            if (accountNames == null) {\n                                accountNames = new ArrayList<>();\n                                accountNamesByType.put(account.type, accountNames);\n                            }\n                            accountNames.add(account.name);\n                        }\n                    }\n                    for (Map.Entry<String, ArrayList<String>> cur : accountNamesByType.entrySet()) {\n                        final String accountType = cur.getKey();\n                        final ArrayList<String> accountNames = cur.getValue();\n                        final Account[] accountsForType = new Account[accountNames.size()];\n                        for (int i = 0; i < accountsForType.length; i++) {\n                            accountsForType[i] = new Account(accountNames.get(i), accountType,\n                                    UUID.randomUUID().toString());\n                        }\n                        accounts.accountCache.put(accountType, accountsForType);\n                    }\n                    accounts.visibilityCache.putAll(accountsDb.findAllVisibilityValues());\n                    AccountManager.invalidateLocalAccountsDataCaches();\n                } finally {\n                    if (accountDeleted) {\n                        sendAccountsChangedBroadcast(accounts.userId);\n                    }\n                }\n            }\n        }\n    }\n\n    private SparseBooleanArray getUidsOfInstalledOrUpdatedPackagesAsUser(int userId) {\n        // Get the UIDs of all apps that might have data on the device. We want\n        // to preserve user data if the app might otherwise be storing data.\n        List<PackageInfo> pkgsWithData =\n                mPackageManager.getInstalledPackagesAsUser(\n                        PackageManager.MATCH_UNINSTALLED_PACKAGES, userId);\n        SparseBooleanArray knownUids = new SparseBooleanArray(pkgsWithData.size());\n        for (PackageInfo pkgInfo : pkgsWithData) {\n            if (pkgInfo.applicationInfo != null\n                    && (pkgInfo.applicationInfo.flags & ApplicationInfo.FLAG_INSTALLED) != 0) {\n                knownUids.put(pkgInfo.applicationInfo.uid, true);\n            }\n        }\n        return knownUids;\n    }\n\n    static HashMap<String, Integer> getAuthenticatorTypeAndUIDForUser(\n            Context context,\n            int userId) {\n        AccountAuthenticatorCache authCache = new AccountAuthenticatorCache(context);\n        return getAuthenticatorTypeAndUIDForUser(authCache, userId);\n    }\n\n    private static HashMap<String, Integer> getAuthenticatorTypeAndUIDForUser(\n            IAccountAuthenticatorCache authCache,\n            int userId) {\n        HashMap<String, Integer> knownAuth = new LinkedHashMap<>();\n        for (RegisteredServicesCache.ServiceInfo<AuthenticatorDescription> service : authCache\n                .getAllServices(userId)) {\n            knownAuth.put(service.type.type, service.uid);\n        }\n        return knownAuth;\n    }\n\n    private UserAccounts getUserAccountsForCaller() {\n        return getUserAccounts(UserHandle.getCallingUserId());\n    }\n\n    protected UserAccounts getUserAccounts(int userId) {\n        try {\n            return getUserAccountsNotChecked(userId);\n        } catch (RuntimeException e) {\n            if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE)) {\n                // Let it go...\n                throw e;\n            }\n            // User accounts database is corrupted, we must wipe out the whole user, otherwise the\n            // system will crash indefinitely\n            Slog.wtf(TAG, \"Removing user \" + userId + \" due to exception (\" + e + \") reading its \"\n                    + \"account database\");\n            if (userId == ActivityManager.getCurrentUser() && userId != UserHandle.USER_SYSTEM) {\n                Slog.i(TAG, \"Switching to system user first\");\n                try {\n                    ActivityManager.getService().switchUser(UserHandle.USER_SYSTEM);\n                } catch (RemoteException re) {\n                    Slog.e(TAG, \"Could not switch to \" + UserHandle.USER_SYSTEM + \": \" + re);\n                }\n            }\n            if (!getUserManager().removeUserEvenWhenDisallowed(userId)) {\n                Slog.e(TAG, \"could not remove user \" + userId);\n            }\n            throw e;\n        }\n    }\n\n    private UserAccounts getUserAccountsNotChecked(int userId) {\n        synchronized (mUsers) {\n            UserAccounts accounts = mUsers.get(userId);\n            boolean validateAccounts = false;\n            if (accounts == null) {\n                File preNDbFile = new File(mInjector.getPreNDatabaseName(userId));\n                File deDbFile = new File(mInjector.getDeDatabaseName(userId));\n                accounts = new UserAccounts(mContext, userId, preNDbFile, deDbFile);\n                mUsers.append(userId, accounts);\n                purgeOldGrants(accounts);\n                AccountManager.invalidateLocalAccountsDataCaches();\n                validateAccounts = true;\n            }\n            // open CE database if necessary\n            if (!accounts.accountsDb.isCeDatabaseAttached() && mLocalUnlockedUsers.get(userId)) {\n                Log.i(TAG, \"User \" + userId + \" is unlocked - opening CE database\");\n                synchronized (accounts.dbLock) {\n                    synchronized (accounts.cacheLock) {\n                        File ceDatabaseFile = new File(mInjector.getCeDatabaseName(userId));\n                        accounts.accountsDb.attachCeDatabase(ceDatabaseFile);\n                    }\n                }\n                syncDeCeAccountsLocked(accounts);\n            }\n            if (validateAccounts) {\n                validateAccountsInternal(accounts, true /* invalidateAuthenticatorCache */);\n            }\n            return accounts;\n        }\n    }\n\n    private void syncDeCeAccountsLocked(UserAccounts accounts) {\n        Preconditions.checkState(Thread.holdsLock(mUsers), \"mUsers lock must be held\");\n        List<Account> accountsToRemove = accounts.accountsDb.findCeAccountsNotInDe();\n        if (!accountsToRemove.isEmpty()) {\n            Slog.i(TAG, accountsToRemove.size()\n                    + \" accounts were previously deleted while user \"\n                    + accounts.userId + \" was locked. Removing accounts from CE tables\");\n            logRecord(accounts, AccountsDb.DEBUG_ACTION_SYNC_DE_CE_ACCOUNTS,\n                    AccountsDb.TABLE_ACCOUNTS);\n\n            for (Account account : accountsToRemove) {\n                removeAccountInternal(accounts, account, Process.SYSTEM_UID);\n            }\n        }\n    }\n\n    private void purgeOldGrantsAll() {\n        synchronized (mUsers) {\n            for (int i = 0; i < mUsers.size(); i++) {\n                purgeOldGrants(mUsers.valueAt(i));\n            }\n        }\n    }\n\n    private void purgeOldGrants(UserAccounts accounts) {\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                List<Integer> uids = accounts.accountsDb.findAllUidGrants();\n                for (int uid : uids) {\n                    final boolean packageExists = mPackageManager.getPackagesForUid(uid) != null;\n                    if (packageExists) {\n                        continue;\n                    }\n                    Log.d(TAG, \"deleting grants for UID \" + uid\n                            + \" because its package is no longer installed\");\n                    accounts.accountsDb.deleteGrantsByUid(uid);\n                }\n            }\n        }\n    }\n\n    private void removeVisibilityValuesForPackage(String packageName) {\n        if (isSpecialPackageKey(packageName)) {\n            return;\n        }\n        synchronized (mUsers) {\n            int numberOfUsers = mUsers.size();\n            for (int i = 0; i < numberOfUsers; i++) {\n                UserAccounts accounts = mUsers.valueAt(i);\n                try {\n                    mPackageManager.getPackageUidAsUser(packageName, accounts.userId);\n                } catch (NameNotFoundException e) {\n                    // package does not exist - remove visibility values\n                    accounts.accountsDb.deleteAccountVisibilityForPackage(packageName);\n                    synchronized (accounts.dbLock) {\n                        synchronized (accounts.cacheLock) {\n                            for (Account account : accounts.visibilityCache.keySet()) {\n                                Map<String, Integer> accountVisibility =\n                                        getPackagesAndVisibilityForAccountLocked(account, accounts);\n                                accountVisibility.remove(packageName);\n                            }\n                            AccountManager.invalidateLocalAccountsDataCaches();\n                        }\n                    }\n              }\n          }\n        }\n    }\n\n    private void purgeUserData(int userId) {\n        UserAccounts accounts;\n        synchronized (mUsers) {\n            accounts = mUsers.get(userId);\n            mUsers.remove(userId);\n            mLocalUnlockedUsers.delete(userId);\n            AccountManager.invalidateLocalAccountsDataCaches();\n        }\n        if (accounts != null) {\n            synchronized (accounts.dbLock) {\n                synchronized (accounts.cacheLock) {\n                    accounts.accountsDb.closeDebugStatement();\n                    accounts.accountsDb.close();\n                }\n            }\n        }\n    }\n\n    @VisibleForTesting\n    void onUserUnlocked(Intent intent) {\n        onUnlockUser(intent.getIntExtra(Intent.EXTRA_USER_HANDLE, -1));\n    }\n\n    void onUnlockUser(int userId) {\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"onUserUnlocked \" + userId);\n        }\n        synchronized (mUsers) {\n            mLocalUnlockedUsers.put(userId, true);\n        }\n        if (userId < 1) return;\n        mHandler.post(() -> syncSharedAccounts(userId));\n    }\n\n    private void syncSharedAccounts(int userId) {\n        // Check if there's a shared account that needs to be created as an account\n        Account[] sharedAccounts = getSharedAccountsAsUser(userId);\n        if (sharedAccounts == null || sharedAccounts.length == 0) return;\n        Account[] accounts = getAccountsAsUser(null, userId, mContext.getOpPackageName());\n        int parentUserId = UserManager.isSplitSystemUser()\n                ? getUserManager().getUserInfo(userId).restrictedProfileParentId\n                : UserHandle.USER_SYSTEM;\n        if (parentUserId < 0) {\n            Log.w(TAG, \"User \" + userId + \" has shared accounts, but no parent user\");\n            return;\n        }\n        for (Account sa : sharedAccounts) {\n            if (ArrayUtils.contains(accounts, sa)) continue;\n            // Account doesn't exist. Copy it now.\n            copyAccountToUser(null /*no response*/, sa, parentUserId, userId);\n        }\n    }\n\n    @Override\n    public void onServiceChanged(AuthenticatorDescription desc, int userId, boolean removed) {\n        UserInfo user = getUserManager().getUserInfo(userId);\n        if (user == null) {\n            Log.w(TAG, \"onServiceChanged: ignore removed user \" + userId);\n            return;\n        }\n        validateAccountsInternal(getUserAccounts(userId), false /* invalidateAuthenticatorCache */);\n    }\n\n    @Override\n    public String getPassword(Account account) {\n        int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"getPassword: \" + account\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        if (account == null) throw new IllegalArgumentException(\"account is null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot get secrets for accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return readPasswordInternal(accounts, account);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private String readPasswordInternal(UserAccounts accounts, Account account) {\n        if (account == null) {\n            return null;\n        }\n        if (!isLocalUnlockedUser(accounts.userId)) {\n            Log.w(TAG, \"Password is not available - user \" + accounts.userId + \" data is locked\");\n            return null;\n        }\n\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                return accounts.accountsDb\n                        .findAccountPasswordByNameAndType(account.name, account.type);\n            }\n        }\n    }\n\n    @Override\n    public String getPreviousName(Account account) {\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"getPreviousName: \" + account\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        int userId = UserHandle.getCallingUserId();\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return readPreviousNameInternal(accounts, account);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private String readPreviousNameInternal(UserAccounts accounts, Account account) {\n        if  (account == null) {\n            return null;\n        }\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                AtomicReference<String> previousNameRef = accounts.previousNameCache.get(account);\n                if (previousNameRef == null) {\n                    String previousName = accounts.accountsDb.findDeAccountPreviousName(account);\n                    previousNameRef = new AtomicReference<>(previousName);\n                    accounts.previousNameCache.put(account, previousNameRef);\n                    return previousName;\n                } else {\n                    return previousNameRef.get();\n                }\n            }\n        }\n    }\n\n    @Override\n    public String getUserData(Account account, String key) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            String msg = String.format(\"getUserData( account: %s, key: %s, callerUid: %s, pid: %s\",\n                    account, key, callingUid, Binder.getCallingPid());\n            Log.v(TAG, msg);\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        Objects.requireNonNull(key, \"key cannot be null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot get user data for accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        if (!isLocalUnlockedUser(userId)) {\n            Log.w(TAG, \"User \" + userId + \" data is locked. callingUid \" + callingUid);\n            return null;\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            if (!accountExistsCache(accounts, account)) {\n                return null;\n            }\n            return readUserDataInternal(accounts, account, key);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public AuthenticatorDescription[] getAuthenticatorTypes(int userId) {\n        int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"getAuthenticatorTypes: \"\n                    + \"for user id \" + userId\n                    + \" caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        // Only allow the system process to read accounts of other users\n        if (isCrossUser(callingUid, userId)) {\n            throw new SecurityException(\n                    String.format(\n                            \"User %s tying to get authenticator types for %s\" ,\n                            UserHandle.getCallingUserId(),\n                            userId));\n        }\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            return getAuthenticatorTypesInternal(userId);\n\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    /**\n     * Should only be called inside of a clearCallingIdentity block.\n     */\n    private AuthenticatorDescription[] getAuthenticatorTypesInternal(int userId) {\n        mAuthenticatorCache.updateServices(userId);\n        Collection<AccountAuthenticatorCache.ServiceInfo<AuthenticatorDescription>>\n                authenticatorCollection = mAuthenticatorCache.getAllServices(userId);\n        AuthenticatorDescription[] types =\n                new AuthenticatorDescription[authenticatorCollection.size()];\n        int i = 0;\n        for (AccountAuthenticatorCache.ServiceInfo<AuthenticatorDescription> authenticator\n                : authenticatorCollection) {\n            types[i] = authenticator.type;\n            i++;\n        }\n        return types;\n    }\n\n    private boolean isCrossUser(int callingUid, int userId) {\n        return (userId != UserHandle.getCallingUserId()\n                && callingUid != Process.SYSTEM_UID\n                && mContext.checkCallingOrSelfPermission(\n                        android.Manifest.permission.INTERACT_ACROSS_USERS_FULL)\n                                != PackageManager.PERMISSION_GRANTED);\n    }\n\n    @Override\n    public boolean addAccountExplicitly(\n            Account account, String password, Bundle extras, String opPackageName) {\n        return addAccountExplicitlyWithVisibility(\n                account, password, extras, /* packageToVisibility= */ null, opPackageName);\n    }\n\n    @Override\n    public void copyAccountToUser(final IAccountManagerResponse response, final Account account,\n            final int userFrom, int userTo) {\n        int callingUid = Binder.getCallingUid();\n        if (isCrossUser(callingUid, UserHandle.USER_ALL)) {\n            throw new SecurityException(\"Calling copyAccountToUser requires \"\n                    + android.Manifest.permission.INTERACT_ACROSS_USERS_FULL);\n        }\n        final UserAccounts fromAccounts = getUserAccounts(userFrom);\n        final UserAccounts toAccounts = getUserAccounts(userTo);\n        if (fromAccounts == null || toAccounts == null) {\n            if (response != null) {\n                Bundle result = new Bundle();\n                result.putBoolean(AccountManager.KEY_BOOLEAN_RESULT, false);\n                try {\n                    response.onResult(result);\n                } catch (RemoteException e) {\n                    Slog.w(TAG, \"Failed to report error back to the client.\" + e);\n                }\n            }\n            return;\n        }\n\n        Slog.d(TAG, \"Copying account \" + account.toSafeString()\n                + \" from user \" + userFrom + \" to user \" + userTo);\n        final long identityToken = clearCallingIdentity();\n        try {\n            new Session(fromAccounts, response, account.type, false,\n                    false /* stripAuthTokenFromResult */, account.name,\n                    false /* authDetailsRequired */) {\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now) + \", getAccountCredentialsForClone\"\n                            + \", \" + account.type;\n                }\n\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.getAccountCredentialsForCloning(this, account);\n                }\n\n                @Override\n                public void onResult(Bundle result) {\n                    Bundle.setDefusable(result, true);\n                    if (result != null\n                            && result.getBoolean(AccountManager.KEY_BOOLEAN_RESULT, false)) {\n                        // Create a Session for the target user and pass in the bundle\n                        completeCloningAccount(response, result, account, toAccounts, userFrom);\n                    } else {\n                        super.onResult(result);\n                    }\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public boolean accountAuthenticated(final Account account) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            String msg = String.format(\n                    \"accountAuthenticated( account: %s, callerUid: %s)\",\n                    account,\n                    callingUid);\n            Log.v(TAG, msg);\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot notify authentication for accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n\n        if (!canUserModifyAccounts(userId, callingUid) ||\n                !canUserModifyAccountsForType(userId, account.type, callingUid)) {\n            return false;\n        }\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return updateLastAuthenticatedTime(account);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private boolean updateLastAuthenticatedTime(Account account) {\n        final UserAccounts accounts = getUserAccountsForCaller();\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                return accounts.accountsDb.updateAccountLastAuthenticatedTime(account);\n            }\n        }\n    }\n\n    private void completeCloningAccount(IAccountManagerResponse response,\n            final Bundle accountCredentials, final Account account, final UserAccounts targetUser,\n            final int parentUserId){\n        Bundle.setDefusable(accountCredentials, true);\n        final long id = clearCallingIdentity();\n        try {\n            new Session(targetUser, response, account.type, false,\n                    false /* stripAuthTokenFromResult */, account.name,\n                    false /* authDetailsRequired */) {\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now) + \", getAccountCredentialsForClone\"\n                            + \", \" + account.type;\n                }\n\n                @Override\n                public void run() throws RemoteException {\n                    // Confirm that the owner's account still exists before this step.\n                    for (Account acc : getAccounts(parentUserId, mContext.getOpPackageName())) {\n                        if (acc.equals(account)) {\n                            mAuthenticator.addAccountFromCredentials(\n                                    this, account, accountCredentials);\n                            break;\n                        }\n                    }\n                }\n\n                @Override\n                public void onResult(Bundle result) {\n                    Bundle.setDefusable(result, true);\n                    // TODO: Anything to do if if succedded?\n                    // TODO: If it failed: Show error notification? Should we remove the shadow\n                    // account to avoid retries?\n                    // TODO: what we do with the visibility?\n\n                    super.onResult(result);\n                }\n\n                @Override\n                public void onError(int errorCode, String errorMessage) {\n                    super.onError(errorCode,  errorMessage);\n                    // TODO: Show error notification to user\n                    // TODO: Should we remove the shadow account so that it doesn't keep trying?\n                }\n\n            }.bind();\n        } finally {\n            restoreCallingIdentity(id);\n        }\n    }\n\n    private boolean addAccountInternal(UserAccounts accounts, Account account, String password,\n            Bundle extras, int callingUid, Map<String, Integer> packageToVisibility,\n            String opPackageName) {\n        Bundle.setDefusable(extras, true);\n        if (account == null) {\n            return false;\n        }\n        if (account.name != null && account.name.length() > 200) {\n            Log.w(TAG, \"Account cannot be added - Name longer than 200 chars\");\n            return false;\n        }\n        if (account.type != null && account.type.length() > 200) {\n            Log.w(TAG, \"Account cannot be added - Name longer than 200 chars\");\n            return false;\n        }\n        if (!isLocalUnlockedUser(accounts.userId)) {\n            Log.w(TAG, \"Account \" + account.toSafeString() + \" cannot be added - user \"\n                    + accounts.userId + \" is locked. callingUid=\" + callingUid);\n            return false;\n        }\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                accounts.accountsDb.beginTransaction();\n                try {\n                    if (accounts.accountsDb.findCeAccountId(account) >= 0) {\n                        Log.w(TAG, \"insertAccountIntoDatabase: \" + account.toSafeString()\n                                + \", skipping since the account already exists\");\n                        return false;\n                    }\n                    if (accounts.accountsDb.findAllDeAccounts().size() > 100) {\n                        Log.w(TAG, \"insertAccountIntoDatabase: \" + account.toSafeString()\n                                + \", skipping since more than 50 accounts on device exist\");\n                        return false;\n                    }\n                    long accountId = accounts.accountsDb.insertCeAccount(account, password);\n                    if (accountId < 0) {\n                        Log.w(TAG, \"insertAccountIntoDatabase: \" + account.toSafeString()\n                                + \", skipping the DB insert failed\");\n                        return false;\n                    }\n                    // Insert into DE table\n                    if (accounts.accountsDb.insertDeAccount(account, accountId) < 0) {\n                        Log.w(TAG, \"insertAccountIntoDatabase: \" + account.toSafeString()\n                                + \", skipping the DB insert failed\");\n                        return false;\n                    }\n                    if (extras != null) {\n                        for (String key : extras.keySet()) {\n                            final String value = extras.getString(key);\n                            if (accounts.accountsDb.insertExtra(accountId, key, value) < 0) {\n                                Log.w(TAG, \"insertAccountIntoDatabase: \"\n                                        + account.toSafeString()\n                                        + \", skipping since insertExtra failed for key \" + key);\n                                return false;\n                            } else {\n                                AccountManager.invalidateLocalAccountUserDataCaches();\n                            }\n                        }\n                    }\n\n                    if (packageToVisibility != null) {\n                        for (Entry<String, Integer> entry : packageToVisibility.entrySet()) {\n                            setAccountVisibility(account, entry.getKey() /* package */,\n                                    entry.getValue() /* visibility */, false /* notify */,\n                                    accounts);\n                        }\n                    }\n                    accounts.accountsDb.setTransactionSuccessful();\n\n                    logRecord(AccountsDb.DEBUG_ACTION_ACCOUNT_ADD, AccountsDb.TABLE_ACCOUNTS,\n                            accountId,\n                            accounts, callingUid);\n\n                    insertAccountIntoCacheLocked(accounts, account);\n                } finally {\n                    accounts.accountsDb.endTransaction();\n                }\n            }\n        }\n        if (getUserManager().getUserInfo(accounts.userId).canHaveProfile()) {\n            addAccountToLinkedRestrictedUsers(account, accounts.userId);\n        }\n\n        sendNotificationAccountUpdated(account, accounts);\n        // Only send LOGIN_ACCOUNTS_CHANGED when the database changed.\n        sendAccountsChangedBroadcast(accounts.userId);\n\n        logAddAccountExplicitlyMetrics(opPackageName, account.type, packageToVisibility);\n        return true;\n    }\n\n    private void logAddAccountExplicitlyMetrics(\n            String callerPackage, String accountType,\n            @Nullable Map<String, Integer> accountVisibility) {\n        // Although this is not a 'device policy' API, enterprise is the current use case.\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.ADD_ACCOUNT_EXPLICITLY)\n                .setStrings(\n                        TextUtils.emptyIfNull(accountType),\n                        TextUtils.emptyIfNull(callerPackage),\n                        findPackagesPerVisibility(accountVisibility))\n                .write();\n    }\n\n    private String[] findPackagesPerVisibility(@Nullable Map<String, Integer> accountVisibility) {\n        Map<Integer, Set<String>> packagesPerVisibility = new HashMap<>();\n        if (accountVisibility != null) {\n            for (Entry<String, Integer> entry : accountVisibility.entrySet()) {\n                if (!packagesPerVisibility.containsKey(entry.getValue())) {\n                    packagesPerVisibility.put(entry.getValue(), new HashSet<>());\n                }\n                packagesPerVisibility.get(entry.getValue()).add(entry.getKey());\n            }\n        }\n\n        String[] packagesPerVisibilityStr = new String[5];\n        packagesPerVisibilityStr[AccountManager.VISIBILITY_UNDEFINED] = getPackagesForVisibilityStr(\n                AccountManager.VISIBILITY_UNDEFINED, packagesPerVisibility);\n        packagesPerVisibilityStr[AccountManager.VISIBILITY_VISIBLE] = getPackagesForVisibilityStr(\n                AccountManager.VISIBILITY_VISIBLE, packagesPerVisibility);\n        packagesPerVisibilityStr[AccountManager.VISIBILITY_USER_MANAGED_VISIBLE] =\n                getPackagesForVisibilityStr(\n                        AccountManager.VISIBILITY_USER_MANAGED_VISIBLE, packagesPerVisibility);\n        packagesPerVisibilityStr[AccountManager.VISIBILITY_NOT_VISIBLE] =\n                getPackagesForVisibilityStr(\n                        AccountManager.VISIBILITY_NOT_VISIBLE, packagesPerVisibility);\n        packagesPerVisibilityStr[AccountManager.VISIBILITY_USER_MANAGED_NOT_VISIBLE] =\n                getPackagesForVisibilityStr(\n                        AccountManager.VISIBILITY_USER_MANAGED_NOT_VISIBLE, packagesPerVisibility);\n        return packagesPerVisibilityStr;\n    }\n\n    private String getPackagesForVisibilityStr(\n            int visibility, Map<Integer, Set<String>> packagesPerVisibility) {\n        return visibility + \":\"\n                + (packagesPerVisibility.containsKey(visibility)\n                    ? TextUtils.join(\",\", packagesPerVisibility.get(visibility))\n                    : \"\");\n    }\n\n    private boolean isLocalUnlockedUser(int userId) {\n        synchronized (mUsers) {\n            return mLocalUnlockedUsers.get(userId);\n        }\n    }\n\n    /**\n     * Adds the account to all linked restricted users as shared accounts. If the user is currently\n     * running, then clone the account too.\n     * @param account the account to share with limited users\n     *\n     */\n    private void addAccountToLinkedRestrictedUsers(Account account, int parentUserId) {\n        List<UserInfo> users = getUserManager().getUsers();\n        for (UserInfo user : users) {\n            if (user.isRestricted() && (parentUserId == user.restrictedProfileParentId)) {\n                addSharedAccountAsUser(account, user.id);\n                if (isLocalUnlockedUser(user.id)) {\n                    mHandler.sendMessage(mHandler.obtainMessage(\n                            MESSAGE_COPY_SHARED_ACCOUNT, parentUserId, user.id, account));\n                }\n            }\n        }\n    }\n\n    @Override\n    public void hasFeatures(IAccountManagerResponse response,\n            Account account, String[] features, String opPackageName) {\n        int callingUid = Binder.getCallingUid();\n        mAppOpsManager.checkPackage(callingUid, opPackageName);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"hasFeatures: \" + account\n                    + \", response \" + response\n                    + \", features \" + Arrays.toString(features)\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Preconditions.checkArgument(account != null, \"account cannot be null\");\n        Preconditions.checkArgument(response != null, \"response cannot be null\");\n        Preconditions.checkArgument(features != null, \"features cannot be null\");\n        int userId = UserHandle.getCallingUserId();\n        checkReadAccountsPermitted(callingUid, account.type, userId,\n                opPackageName);\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            new TestFeaturesSession(accounts, response, account, features).bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private class TestFeaturesSession extends Session {\n        private final String[] mFeatures;\n        private final Account mAccount;\n\n        public TestFeaturesSession(UserAccounts accounts, IAccountManagerResponse response,\n                Account account, String[] features) {\n            super(accounts, response, account.type, false /* expectActivityLaunch */,\n                    true /* stripAuthTokenFromResult */, account.name,\n                    false /* authDetailsRequired */);\n            mFeatures = features;\n            mAccount = account;\n        }\n\n        @Override\n        public void run() throws RemoteException {\n            try {\n                mAuthenticator.hasFeatures(this, mAccount, mFeatures);\n            } catch (RemoteException e) {\n                onError(AccountManager.ERROR_CODE_REMOTE_EXCEPTION, \"remote exception\");\n            }\n        }\n\n        @Override\n        public void onResult(Bundle result) {\n            Bundle.setDefusable(result, true);\n            IAccountManagerResponse response = getResponseAndClose();\n            if (response != null) {\n                try {\n                    if (result == null) {\n                        response.onError(AccountManager.ERROR_CODE_INVALID_RESPONSE, \"null bundle\");\n                        return;\n                    }\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, getClass().getSimpleName() + \" calling onResult() on response \"\n                                + response);\n                    }\n                    final Bundle newResult = new Bundle();\n                    newResult.putBoolean(AccountManager.KEY_BOOLEAN_RESULT,\n                            result.getBoolean(AccountManager.KEY_BOOLEAN_RESULT, false));\n                    response.onResult(newResult);\n                } catch (RemoteException e) {\n                    // if the caller is dead then there is no one to care about remote exceptions\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, \"failure while notifying response\", e);\n                    }\n                }\n            }\n        }\n\n        @Override\n        protected String toDebugString(long now) {\n            return super.toDebugString(now) + \", hasFeatures\"\n                    + \", \" + mAccount\n                    + \", \" + (mFeatures != null ? TextUtils.join(\",\", mFeatures) : null);\n        }\n    }\n\n    @Override\n    public void renameAccount(\n            IAccountManagerResponse response, Account accountToRename, String newName) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"renameAccount: \" + accountToRename + \" -> \" + newName\n                + \", caller's uid \" + callingUid\n                + \", pid \" + Binder.getCallingPid());\n        }\n        if (accountToRename == null) throw new IllegalArgumentException(\"account is null\");\n        if (newName != null && newName.length() > 200) {\n            Log.e(TAG, \"renameAccount failed - account name longer than 200\");\n            throw new IllegalArgumentException(\"account name longer than 200\");\n        }\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(accountToRename.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot rename accounts of type: %s\",\n                    callingUid,\n                    accountToRename.type);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            Account resultingAccount = renameAccountInternal(accounts, accountToRename, newName);\n            Bundle result = new Bundle();\n            result.putString(AccountManager.KEY_ACCOUNT_NAME, resultingAccount.name);\n            result.putString(AccountManager.KEY_ACCOUNT_TYPE, resultingAccount.type);\n            result.putString(AccountManager.KEY_ACCOUNT_ACCESS_ID,\n                    resultingAccount.getAccessId());\n            try {\n                response.onResult(result);\n            } catch (RemoteException e) {\n                Log.w(TAG, e.getMessage());\n            }\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private Account renameAccountInternal(\n            UserAccounts accounts, Account accountToRename, String newName) {\n        Account resultAccount = null;\n        /*\n         * Cancel existing notifications. Let authenticators\n         * re-post notifications as required. But we don't know if\n         * the authenticators have bound their notifications to\n         * now stale account name data.\n         *\n         * With a rename api, we might not need to do this anymore but it\n         * shouldn't hurt.\n         */\n        cancelNotification(\n                getSigninRequiredNotificationId(accounts, accountToRename),\n                new UserHandle(accounts.userId));\n        synchronized(accounts.credentialsPermissionNotificationIds) {\n            for (Pair<Pair<Account, String>, Integer> pair:\n                    accounts.credentialsPermissionNotificationIds.keySet()) {\n                if (accountToRename.equals(pair.first.first)) {\n                    NotificationId id = accounts.credentialsPermissionNotificationIds.get(pair);\n                    cancelNotification(id, new UserHandle(accounts.userId));\n                }\n            }\n        }\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                List<String> accountRemovedReceivers =\n                    getAccountRemovedReceivers(accountToRename, accounts);\n                accounts.accountsDb.beginTransaction();\n                Account renamedAccount = new Account(newName, accountToRename.type);\n                try {\n                    if ((accounts.accountsDb.findCeAccountId(renamedAccount) >= 0)) {\n                        Log.e(TAG, \"renameAccount failed - account with new name already exists\");\n                        return null;\n                    }\n                    final long accountId = accounts.accountsDb.findDeAccountId(accountToRename);\n                    if (accountId >= 0) {\n                        accounts.accountsDb.renameCeAccount(accountId, newName);\n                        if (accounts.accountsDb.renameDeAccount(\n                                accountId, newName, accountToRename.name)) {\n                            accounts.accountsDb.setTransactionSuccessful();\n                        } else {\n                            Log.e(TAG, \"renameAccount failed\");\n                            return null;\n                        }\n                    } else {\n                        Log.e(TAG, \"renameAccount failed - old account does not exist\");\n                        return null;\n                    }\n                } finally {\n                    accounts.accountsDb.endTransaction();\n                }\n            /*\n             * Database transaction was successful. Clean up cached\n             * data associated with the account in the user profile.\n             */\n                renamedAccount = insertAccountIntoCacheLocked(accounts, renamedAccount);\n            /*\n             * Extract the data and token caches before removing the\n             * old account to preserve the user data associated with\n             * the account.\n             */\n                Map<String, String> tmpData = accounts.userDataCache.get(accountToRename);\n                Map<String, String> tmpTokens = accounts.authTokenCache.get(accountToRename);\n                Map<String, Integer> tmpVisibility = accounts.visibilityCache.get(accountToRename);\n                removeAccountFromCacheLocked(accounts, accountToRename);\n            /*\n             * Update the cached data associated with the renamed\n             * account.\n             */\n                accounts.userDataCache.put(renamedAccount, tmpData);\n                accounts.authTokenCache.put(renamedAccount, tmpTokens);\n                accounts.visibilityCache.put(renamedAccount, tmpVisibility);\n                accounts.previousNameCache.put(\n                        renamedAccount,\n                        new AtomicReference<>(accountToRename.name));\n                resultAccount = renamedAccount;\n\n                int parentUserId = accounts.userId;\n                if (canHaveProfile(parentUserId)) {\n                /*\n                 * Owner or system user account was renamed, rename the account for\n                 * those users with which the account was shared.\n                 */\n                    List<UserInfo> users = getUserManager().getAliveUsers();\n                    for (UserInfo user : users) {\n                        if (user.isRestricted()\n                                && (user.restrictedProfileParentId == parentUserId)) {\n                            renameSharedAccountAsUser(accountToRename, newName, user.id);\n                        }\n                    }\n                }\n\n                sendNotificationAccountUpdated(resultAccount, accounts);\n                sendAccountsChangedBroadcast(accounts.userId);\n                for (String packageName : accountRemovedReceivers) {\n                    sendAccountRemovedBroadcast(accountToRename, packageName, accounts.userId);\n                }\n\n                AccountManager.invalidateLocalAccountsDataCaches();\n                AccountManager.invalidateLocalAccountUserDataCaches();\n            }\n        }\n        return resultAccount;\n    }\n\n    private boolean canHaveProfile(final int parentUserId) {\n        final UserInfo userInfo = getUserManager().getUserInfo(parentUserId);\n        return userInfo != null && userInfo.canHaveProfile();\n    }\n\n    @Override\n    public void removeAccountAsUser(IAccountManagerResponse response, Account account,\n            boolean expectActivityLaunch, int userId) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"removeAccount: \" + account\n                    + \", response \" + response\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid()\n                    + \", for user id \" + userId);\n        }\n        Preconditions.checkArgument(account != null, \"account cannot be null\");\n        Preconditions.checkArgument(response != null, \"response cannot be null\");\n\n        // Only allow the system process to modify accounts of other users\n        if (isCrossUser(callingUid, userId)) {\n            throw new SecurityException(\n                    String.format(\n                            \"User %s tying remove account for %s\" ,\n                            UserHandle.getCallingUserId(),\n                            userId));\n        }\n        /*\n         * Only the system, authenticator or profile owner should be allowed to remove accounts for\n         * that authenticator.  This will let users remove accounts (via Settings in the system) but\n         * not arbitrary applications (like competing authenticators).\n         */\n        UserHandle user = UserHandle.of(userId);\n        if (!isAccountManagedByCaller(account.type, callingUid, user.getIdentifier())\n                && !isSystemUid(callingUid)\n                && !isProfileOwner(callingUid)) {\n            String msg = String.format(\n                    \"uid %s cannot remove accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        if (!canUserModifyAccounts(userId, callingUid)) {\n            try {\n                response.onError(AccountManager.ERROR_CODE_USER_RESTRICTED,\n                        \"User cannot modify accounts\");\n            } catch (RemoteException re) {\n            }\n            return;\n        }\n        if (!canUserModifyAccountsForType(userId, account.type, callingUid)) {\n            try {\n                response.onError(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                        \"User cannot modify accounts of this type (policy).\");\n            } catch (RemoteException re) {\n            }\n            return;\n        }\n        final long identityToken = clearCallingIdentity();\n        UserAccounts accounts = getUserAccounts(userId);\n        cancelNotification(getSigninRequiredNotificationId(accounts, account), user);\n        synchronized(accounts.credentialsPermissionNotificationIds) {\n            for (Pair<Pair<Account, String>, Integer> pair:\n                accounts.credentialsPermissionNotificationIds.keySet()) {\n                if (account.equals(pair.first.first)) {\n                    NotificationId id = accounts.credentialsPermissionNotificationIds.get(pair);\n                    cancelNotification(id, user);\n                }\n            }\n        }\n        final long accountId = accounts.accountsDb.findDeAccountId(account);\n        logRecord(\n                AccountsDb.DEBUG_ACTION_CALLED_ACCOUNT_REMOVE,\n                AccountsDb.TABLE_ACCOUNTS,\n                accountId,\n                accounts,\n                callingUid);\n        try {\n            new RemoveAccountSession(accounts, response, account, expectActivityLaunch).bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public boolean removeAccountExplicitly(Account account) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"removeAccountExplicitly: \" + account\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        int userId = Binder.getCallingUserHandle().getIdentifier();\n        if (account == null) {\n            /*\n             * Null accounts should result in returning false, as per\n             * AccountManage.addAccountExplicitly(...) java doc.\n             */\n            Log.e(TAG, \"account is null\");\n            return false;\n        } else if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot explicitly remove accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        UserAccounts accounts = getUserAccountsForCaller();\n        final long accountId = accounts.accountsDb.findDeAccountId(account);\n        logRecord(\n                AccountsDb.DEBUG_ACTION_CALLED_ACCOUNT_REMOVE,\n                AccountsDb.TABLE_ACCOUNTS,\n                accountId,\n                accounts,\n                callingUid);\n        final long identityToken = clearCallingIdentity();\n        try {\n            return removeAccountInternal(accounts, account, callingUid);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private class RemoveAccountSession extends Session {\n        final Account mAccount;\n        public RemoveAccountSession(UserAccounts accounts, IAccountManagerResponse response,\n                Account account, boolean expectActivityLaunch) {\n            super(accounts, response, account.type, expectActivityLaunch,\n                    true /* stripAuthTokenFromResult */, account.name,\n                    false /* authDetailsRequired */);\n            mAccount = account;\n        }\n\n        @Override\n        protected String toDebugString(long now) {\n            return super.toDebugString(now) + \", removeAccount\"\n                    + \", account \" + mAccount;\n        }\n\n        @Override\n        public void run() throws RemoteException {\n            mAuthenticator.getAccountRemovalAllowed(this, mAccount);\n        }\n\n        @Override\n        public void onResult(Bundle result) {\n            Bundle.setDefusable(result, true);\n            if (result != null && result.containsKey(AccountManager.KEY_BOOLEAN_RESULT)\n                    && !result.containsKey(AccountManager.KEY_INTENT)) {\n                final boolean removalAllowed = result.getBoolean(AccountManager.KEY_BOOLEAN_RESULT);\n                if (removalAllowed) {\n                    removeAccountInternal(mAccounts, mAccount, getCallingUid());\n                }\n                IAccountManagerResponse response = getResponseAndClose();\n                if (response != null) {\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, getClass().getSimpleName() + \" calling onResult() on response \"\n                                + response);\n                    }\n                    try {\n                        response.onResult(result);\n                    } catch (RemoteException e) {\n                        Slog.e(TAG, \"Error calling onResult()\", e);\n                    }\n                }\n            }\n            super.onResult(result);\n        }\n    }\n\n    @VisibleForTesting\n    protected void removeAccountInternal(Account account) {\n        removeAccountInternal(getUserAccountsForCaller(), account, getCallingUid());\n    }\n\n    private boolean removeAccountInternal(UserAccounts accounts, Account account, int callingUid) {\n        boolean isChanged = false;\n        boolean userUnlocked = isLocalUnlockedUser(accounts.userId);\n        if (!userUnlocked) {\n            Slog.i(TAG, \"Removing account \" + account.toSafeString()\n                    + \" while user \" + accounts.userId\n                    + \" is still locked. CE data will be removed later\");\n        }\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                Map<String, Integer> packagesToVisibility = getRequestingPackages(account,\n                        accounts);\n                List<String> accountRemovedReceivers =\n                    getAccountRemovedReceivers(account, accounts);\n                accounts.accountsDb.beginTransaction();\n                // Set to a placeholder value, this will only be used if the database\n                // transaction succeeds.\n                long accountId = -1;\n                try {\n                    accountId = accounts.accountsDb.findDeAccountId(account);\n                    if (accountId >= 0) {\n                        isChanged = accounts.accountsDb.deleteDeAccount(accountId);\n                    }\n                    // always delete from CE table if CE storage is available\n                    // DE account could be removed while CE was locked\n                    if (userUnlocked) {\n                        long ceAccountId = accounts.accountsDb.findCeAccountId(account);\n                        if (ceAccountId >= 0) {\n                            accounts.accountsDb.deleteCeAccount(ceAccountId);\n                        }\n                    }\n                    accounts.accountsDb.setTransactionSuccessful();\n                } finally {\n                    accounts.accountsDb.endTransaction();\n                }\n                if (isChanged) {\n                    removeAccountFromCacheLocked(accounts, account);\n                    for (Entry<String, Integer> packageToVisibility : packagesToVisibility\n                            .entrySet()) {\n                        if ((packageToVisibility.getValue() == AccountManager.VISIBILITY_VISIBLE)\n                                || (packageToVisibility.getValue()\n                                    == AccountManager.VISIBILITY_USER_MANAGED_VISIBLE)) {\n                            notifyPackage(packageToVisibility.getKey(), accounts);\n                        }\n                    }\n\n                    // Only broadcast LOGIN_ACCOUNTS_CHANGED if a change occurred.\n                    sendAccountsChangedBroadcast(accounts.userId);\n                    for (String packageName : accountRemovedReceivers) {\n                        sendAccountRemovedBroadcast(account, packageName, accounts.userId);\n                    }\n                    String action = userUnlocked ? AccountsDb.DEBUG_ACTION_ACCOUNT_REMOVE\n                            : AccountsDb.DEBUG_ACTION_ACCOUNT_REMOVE_DE;\n                    logRecord(action, AccountsDb.TABLE_ACCOUNTS, accountId, accounts);\n                }\n            }\n        }\n        final long id = Binder.clearCallingIdentity();\n        try {\n            int parentUserId = accounts.userId;\n            if (canHaveProfile(parentUserId)) {\n                // Remove from any restricted profiles that are sharing this account.\n                List<UserInfo> users = getUserManager().getAliveUsers();\n                for (UserInfo user : users) {\n                    if (user.isRestricted() && parentUserId == (user.restrictedProfileParentId)) {\n                        removeSharedAccountAsUser(account, user.id, callingUid);\n                    }\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(id);\n        }\n\n        if (isChanged) {\n            synchronized (accounts.credentialsPermissionNotificationIds) {\n                for (Pair<Pair<Account, String>, Integer> key\n                        : accounts.credentialsPermissionNotificationIds.keySet()) {\n                    if (account.equals(key.first.first)\n                            && AccountManager.ACCOUNT_ACCESS_TOKEN_TYPE.equals(key.first.second)) {\n                        final int uid = (Integer) key.second;\n                        mHandler.post(() -> cancelAccountAccessRequestNotificationIfNeeded(\n                                account, uid, false));\n                    }\n                }\n            }\n        }\n\n        AccountManager.invalidateLocalAccountUserDataCaches();\n\n        return isChanged;\n    }\n\n    @Override\n    public void invalidateAuthToken(String accountType, String authToken) {\n        int callerUid = Binder.getCallingUid();\n        Objects.requireNonNull(accountType, \"accountType cannot be null\");\n        Objects.requireNonNull(authToken, \"authToken cannot be null\");\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"invalidateAuthToken: accountType \" + accountType\n                    + \", caller's uid \" + callerUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        int userId = UserHandle.getCallingUserId();\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            List<Pair<Account, String>> deletedTokens;\n            synchronized (accounts.dbLock) {\n                accounts.accountsDb.beginTransaction();\n                try {\n                    deletedTokens = invalidateAuthTokenLocked(accounts, accountType, authToken);\n                    accounts.accountsDb.setTransactionSuccessful();\n                } finally {\n                    accounts.accountsDb.endTransaction();\n                }\n                synchronized (accounts.cacheLock) {\n                    for (Pair<Account, String> tokenInfo : deletedTokens) {\n                        Account act = tokenInfo.first;\n                        String tokenType = tokenInfo.second;\n                        writeAuthTokenIntoCacheLocked(accounts, act, tokenType, null);\n                    }\n                    // wipe out cached token in memory.\n                    accounts.accountTokenCaches.remove(accountType, authToken);\n                }\n            }\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private List<Pair<Account, String>> invalidateAuthTokenLocked(UserAccounts accounts, String accountType,\n            String authToken) {\n        // TODO Move to AccountsDB\n        List<Pair<Account, String>> results = new ArrayList<>();\n        Cursor cursor = accounts.accountsDb.findAuthtokenForAllAccounts(accountType, authToken);\n\n        try {\n            while (cursor.moveToNext()) {\n                String authTokenId = cursor.getString(0);\n                String accountName = cursor.getString(1);\n                String authTokenType = cursor.getString(2);\n                accounts.accountsDb.deleteAuthToken(authTokenId);\n                results.add(Pair.create(new Account(accountName, accountType), authTokenType));\n            }\n        } finally {\n            cursor.close();\n        }\n        return results;\n    }\n\n    private void saveCachedToken(\n            UserAccounts accounts,\n            Account account,\n            String callerPkg,\n            byte[] callerSigDigest,\n            String tokenType,\n            String token,\n            long expiryMillis) {\n\n        if (account == null || tokenType == null || callerPkg == null || callerSigDigest == null) {\n            return;\n        }\n        cancelNotification(getSigninRequiredNotificationId(accounts, account),\n                UserHandle.of(accounts.userId));\n        synchronized (accounts.cacheLock) {\n            accounts.accountTokenCaches.put(\n                    account, token, tokenType, callerPkg, callerSigDigest, expiryMillis);\n        }\n    }\n\n    private boolean saveAuthTokenToDatabase(UserAccounts accounts, Account account, String type,\n            String authToken) {\n        if (account == null || type == null) {\n            return false;\n        }\n        cancelNotification(getSigninRequiredNotificationId(accounts, account),\n                UserHandle.of(accounts.userId));\n        synchronized (accounts.dbLock) {\n            accounts.accountsDb.beginTransaction();\n            boolean updateCache = false;\n            try {\n                long accountId = accounts.accountsDb.findDeAccountId(account);\n                if (accountId < 0) {\n                    return false;\n                }\n                accounts.accountsDb.deleteAuthtokensByAccountIdAndType(accountId, type);\n                if (accounts.accountsDb.insertAuthToken(accountId, type, authToken) >= 0) {\n                    accounts.accountsDb.setTransactionSuccessful();\n                    updateCache = true;\n                    return true;\n                }\n                return false;\n            } finally {\n                accounts.accountsDb.endTransaction();\n                if (updateCache) {\n                    synchronized (accounts.cacheLock) {\n                        writeAuthTokenIntoCacheLocked(accounts, account, type, authToken);\n                    }\n                }\n            }\n        }\n    }\n\n    @Override\n    public String peekAuthToken(Account account, String authTokenType) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"peekAuthToken: \" + account\n                    + \", authTokenType \" + authTokenType\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        Objects.requireNonNull(authTokenType, \"authTokenType cannot be null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot peek the authtokens associated with accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        if (!isLocalUnlockedUser(userId)) {\n            Log.w(TAG, \"Authtoken not available - user \" + userId + \" data is locked. callingUid \"\n                    + callingUid);\n            return null;\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return readAuthTokenInternal(accounts, account, authTokenType);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void setAuthToken(Account account, String authTokenType, String authToken) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"setAuthToken: \" + account\n                    + \", authTokenType \" + authTokenType\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        Objects.requireNonNull(authTokenType, \"authTokenType cannot be null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot set auth tokens associated with accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            saveAuthTokenToDatabase(accounts, account, authTokenType, authToken);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void setPassword(Account account, String password) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"setAuthToken: \" + account\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot set secrets for accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            setPasswordInternal(accounts, account, password, callingUid);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private void setPasswordInternal(UserAccounts accounts, Account account, String password,\n            int callingUid) {\n        if (account == null) {\n            return;\n        }\n        boolean isChanged = false;\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                accounts.accountsDb.beginTransaction();\n                try {\n                    final long accountId = accounts.accountsDb.findDeAccountId(account);\n                    if (accountId >= 0) {\n                        accounts.accountsDb.updateCeAccountPassword(accountId, password);\n                        accounts.accountsDb.deleteAuthTokensByAccountId(accountId);\n                        accounts.authTokenCache.remove(account);\n                        accounts.accountTokenCaches.remove(account);\n                        accounts.accountsDb.setTransactionSuccessful();\n                        // If there is an account whose password will be updated and the database\n                        // transactions succeed, then we say that a change has occured. Even if the\n                        // new password is the same as the old and there were no authtokens to\n                        // delete.\n                        isChanged = true;\n                        String action = (password == null || password.length() == 0) ?\n                                AccountsDb.DEBUG_ACTION_CLEAR_PASSWORD\n                                : AccountsDb.DEBUG_ACTION_SET_PASSWORD;\n                        logRecord(action, AccountsDb.TABLE_ACCOUNTS, accountId, accounts,\n                                callingUid);\n                    }\n                } finally {\n                    accounts.accountsDb.endTransaction();\n                    if (isChanged) {\n                        // Send LOGIN_ACCOUNTS_CHANGED only if the something changed.\n                        sendNotificationAccountUpdated(account, accounts);\n                        sendAccountsChangedBroadcast(accounts.userId);\n                    }\n                }\n            }\n        }\n    }\n\n    @Override\n    public void clearPassword(Account account) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"clearPassword: \" + account\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot clear passwords for accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            setPasswordInternal(accounts, account, null, callingUid);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void setUserData(Account account, String key, String value) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"setUserData: \" + account\n                    + \", key \" + key\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        if (key == null) throw new IllegalArgumentException(\"key is null\");\n        if (account == null) throw new IllegalArgumentException(\"account is null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot set user data for accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            if (!accountExistsCache(accounts, account)) {\n                return;\n            }\n            setUserdataInternal(accounts, account, key, value);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private boolean accountExistsCache(UserAccounts accounts, Account account) {\n        synchronized (accounts.cacheLock) {\n            if (accounts.accountCache.containsKey(account.type)) {\n                for (Account acc : accounts.accountCache.get(account.type)) {\n                    if (acc.name.equals(account.name)) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    private void setUserdataInternal(UserAccounts accounts, Account account, String key,\n            String value) {\n        synchronized (accounts.dbLock) {\n            accounts.accountsDb.beginTransaction();\n            try {\n                long accountId = accounts.accountsDb.findDeAccountId(account);\n                if (accountId < 0) {\n                    return;\n                }\n                long extrasId = accounts.accountsDb.findExtrasIdByAccountId(accountId, key);\n                if (extrasId < 0) {\n                    extrasId = accounts.accountsDb.insertExtra(accountId, key, value);\n                    if (extrasId < 0) {\n                        return;\n                    }\n                } else if (!accounts.accountsDb.updateExtra(extrasId, value)) {\n                    return;\n                }\n                accounts.accountsDb.setTransactionSuccessful();\n            } finally {\n                accounts.accountsDb.endTransaction();\n            }\n            synchronized (accounts.cacheLock) {\n                writeUserDataIntoCacheLocked(accounts, account, key, value);\n                AccountManager.invalidateLocalAccountUserDataCaches();\n            }\n        }\n    }\n\n    private void onResult(IAccountManagerResponse response, Bundle result) {\n        if (result == null) {\n            Log.e(TAG, \"the result is unexpectedly null\", new Exception());\n        }\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, getClass().getSimpleName() + \" calling onResult() on response \"\n                    + response);\n        }\n        try {\n            response.onResult(result);\n        } catch (RemoteException e) {\n            // if the caller is dead then there is no one to care about remote\n            // exceptions\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"failure while notifying response\", e);\n            }\n        }\n    }\n\n    @Override\n    public void getAuthTokenLabel(IAccountManagerResponse response, final String accountType,\n                                  final String authTokenType)\n            throws RemoteException {\n        Preconditions.checkArgument(accountType != null, \"accountType cannot be null\");\n        Preconditions.checkArgument(authTokenType != null, \"authTokenType cannot be null\");\n\n        final int callingUid = getCallingUid();\n        clearCallingIdentity();\n        if (UserHandle.getAppId(callingUid) != Process.SYSTEM_UID) {\n            throw new SecurityException(\"can only call from system\");\n        }\n        int userId = UserHandle.getUserId(callingUid);\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            new Session(accounts, response, accountType, false /* expectActivityLaunch */,\n                    false /* stripAuthTokenFromResult */,  null /* accountName */,\n                    false /* authDetailsRequired */) {\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now) + \", getAuthTokenLabel\"\n                            + \", \" + accountType\n                            + \", authTokenType \" + authTokenType;\n                }\n\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.getAuthTokenLabel(this, authTokenType);\n                }\n\n                @Override\n                public void onResult(Bundle result) {\n                    Bundle.setDefusable(result, true);\n                    if (result != null) {\n                        String label = result.getString(AccountManager.KEY_AUTH_TOKEN_LABEL);\n                        Bundle bundle = new Bundle();\n                        bundle.putString(AccountManager.KEY_AUTH_TOKEN_LABEL, label);\n                        super.onResult(bundle);\n                        return;\n                    } else {\n                        super.onResult(result);\n                    }\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void getAuthToken(\n            IAccountManagerResponse response,\n            final Account account,\n            final String authTokenType,\n            final boolean notifyOnAuthFailure,\n            final boolean expectActivityLaunch,\n            final Bundle loginOptions) {\n        Bundle.setDefusable(loginOptions, true);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"getAuthToken: \" + account\n                    + \", response \" + response\n                    + \", authTokenType \" + authTokenType\n                    + \", notifyOnAuthFailure \" + notifyOnAuthFailure\n                    + \", expectActivityLaunch \" + expectActivityLaunch\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Preconditions.checkArgument(response != null, \"response cannot be null\");\n        try {\n            if (account == null) {\n                Slog.w(TAG, \"getAuthToken called with null account\");\n                response.onError(AccountManager.ERROR_CODE_BAD_ARGUMENTS, \"account is null\");\n                return;\n            }\n            if (authTokenType == null) {\n                Slog.w(TAG, \"getAuthToken called with null authTokenType\");\n                response.onError(AccountManager.ERROR_CODE_BAD_ARGUMENTS, \"authTokenType is null\");\n                return;\n            }\n        } catch (RemoteException e) {\n            Slog.w(TAG, \"Failed to report error back to the client.\" + e);\n            return;\n        }\n        int userId = UserHandle.getCallingUserId();\n        final long ident = Binder.clearCallingIdentity();\n        final UserAccounts accounts;\n        final RegisteredServicesCache.ServiceInfo<AuthenticatorDescription> authenticatorInfo;\n        try {\n            accounts = getUserAccounts(userId);\n            authenticatorInfo = mAuthenticatorCache.getServiceInfo(\n                    AuthenticatorDescription.newKey(account.type), accounts.userId);\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n\n        final boolean customTokens =\n                authenticatorInfo != null && authenticatorInfo.type.customTokens;\n\n        // skip the check if customTokens\n        final int callerUid = Binder.getCallingUid();\n        final boolean permissionGranted =\n                customTokens || permissionIsGranted(account, authTokenType, callerUid, userId);\n\n        // Get the calling package. We will use it for the purpose of caching.\n        final String callerPkg = loginOptions.getString(AccountManager.KEY_ANDROID_PACKAGE_NAME);\n        String[] callerOwnedPackageNames;\n        final long ident2 = Binder.clearCallingIdentity();\n        try {\n            callerOwnedPackageNames = mPackageManager.getPackagesForUid(callerUid);\n        } finally {\n            Binder.restoreCallingIdentity(ident2);\n        }\n        if (callerPkg == null || callerOwnedPackageNames == null\n                || !ArrayUtils.contains(callerOwnedPackageNames, callerPkg)) {\n            String msg = String.format(\n                    \"Uid %s is attempting to illegally masquerade as package %s!\",\n                    callerUid,\n                    callerPkg);\n            throw new SecurityException(msg);\n        }\n\n        // let authenticator know the identity of the caller\n        loginOptions.putInt(AccountManager.KEY_CALLER_UID, callerUid);\n        loginOptions.putInt(AccountManager.KEY_CALLER_PID, Binder.getCallingPid());\n\n        if (notifyOnAuthFailure) {\n            loginOptions.putBoolean(AccountManager.KEY_NOTIFY_ON_FAILURE, true);\n        }\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            // Distill the caller's package signatures into a single digest.\n            final byte[] callerPkgSigDigest = calculatePackageSignatureDigest(callerPkg);\n\n            // if the caller has permission, do the peek. otherwise go the more expensive\n            // route of starting a Session\n            if (!customTokens && permissionGranted) {\n                String authToken = readAuthTokenInternal(accounts, account, authTokenType);\n                if (authToken != null) {\n                    logGetAuthTokenMetrics(callerPkg, account.type);\n                    Bundle result = new Bundle();\n                    result.putString(AccountManager.KEY_AUTHTOKEN, authToken);\n                    result.putString(AccountManager.KEY_ACCOUNT_NAME, account.name);\n                    result.putString(AccountManager.KEY_ACCOUNT_TYPE, account.type);\n                    onResult(response, result);\n                    return;\n                }\n            }\n\n            if (customTokens) {\n                /*\n                 * Look up tokens in the new cache only if the loginOptions don't have parameters\n                 * outside of those expected to be injected by the AccountManager, e.g.\n                 * ANDORID_PACKAGE_NAME.\n                 */\n                String token = readCachedTokenInternal(\n                        accounts,\n                        account,\n                        authTokenType,\n                        callerPkg,\n                        callerPkgSigDigest);\n                if (token != null) {\n                    logGetAuthTokenMetrics(callerPkg, account.type);\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, \"getAuthToken: cache hit ofr custom token authenticator.\");\n                    }\n                    Bundle result = new Bundle();\n                    result.putString(AccountManager.KEY_AUTHTOKEN, token);\n                    result.putString(AccountManager.KEY_ACCOUNT_NAME, account.name);\n                    result.putString(AccountManager.KEY_ACCOUNT_TYPE, account.type);\n                    onResult(response, result);\n                    return;\n                }\n            }\n\n            new Session(\n                    accounts,\n                    response,\n                    account.type,\n                    expectActivityLaunch,\n                    false /* stripAuthTokenFromResult */,\n                    account.name,\n                    false /* authDetailsRequired */) {\n                @Override\n                protected String toDebugString(long now) {\n                    if (loginOptions != null) loginOptions.keySet();\n                    return super.toDebugString(now) + \", getAuthToken\"\n                            + \", \" + account.toSafeString()\n                            + \", authTokenType \" + authTokenType\n                            + \", loginOptions \" + loginOptions\n                            + \", notifyOnAuthFailure \" + notifyOnAuthFailure;\n                }\n\n                @Override\n                public void run() throws RemoteException {\n                    // If the caller doesn't have permission then create and return the\n                    // \"grant permission\" intent instead of the \"getAuthToken\" intent.\n                    if (!permissionGranted) {\n                        mAuthenticator.getAuthTokenLabel(this, authTokenType);\n                    } else {\n                        mAuthenticator.getAuthToken(this, account, authTokenType, loginOptions);\n                        logGetAuthTokenMetrics(callerPkg, account.type);\n                    }\n                }\n\n                @Override\n                public void onResult(Bundle result) {\n                    Bundle.setDefusable(result, true);\n                    if (result != null) {\n                        if (result.containsKey(AccountManager.KEY_AUTH_TOKEN_LABEL)) {\n                            Intent intent = newGrantCredentialsPermissionIntent(\n                                    account,\n                                    null,\n                                    callerUid,\n                                    new AccountAuthenticatorResponse(this),\n                                    authTokenType,\n                                    true);\n                            Bundle bundle = new Bundle();\n                            bundle.putParcelable(AccountManager.KEY_INTENT, intent);\n                            onResult(bundle);\n                            return;\n                        }\n                        String authToken = result.getString(AccountManager.KEY_AUTHTOKEN);\n                        if (authToken != null) {\n                            String name = result.getString(AccountManager.KEY_ACCOUNT_NAME);\n                            String type = result.getString(AccountManager.KEY_ACCOUNT_TYPE);\n                            if (TextUtils.isEmpty(type) || TextUtils.isEmpty(name)) {\n                                onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                                        \"the type and name should not be empty\");\n                                return;\n                            }\n                            Account resultAccount = new Account(name, type);\n                            if (!customTokens) {\n                                saveAuthTokenToDatabase(\n                                        mAccounts,\n                                        resultAccount,\n                                        authTokenType,\n                                        authToken);\n                            }\n                            long expiryMillis = result.getLong(\n                                    AbstractAccountAuthenticator.KEY_CUSTOM_TOKEN_EXPIRY, 0L);\n                            if (customTokens\n                                    && expiryMillis > System.currentTimeMillis()) {\n                                saveCachedToken(\n                                        mAccounts,\n                                        account,\n                                        callerPkg,\n                                        callerPkgSigDigest,\n                                        authTokenType,\n                                        authToken,\n                                        expiryMillis);\n                            }\n                        }\n\n                        Intent intent = result.getParcelable(AccountManager.KEY_INTENT);\n                        if (intent != null && notifyOnAuthFailure && !customTokens) {\n                            /*\n                             * Make sure that the supplied intent is owned by the authenticator\n                             * giving it to the system. Otherwise a malicious authenticator could\n                             * have users launching arbitrary activities by tricking users to\n                             * interact with malicious notifications.\n                             */\n                            if (!checkKeyIntent(\n                                    Binder.getCallingUid(),\n                                    result)) {\n                                onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                                        \"invalid intent in bundle returned\");\n                                return;\n                            }\n                            doNotification(\n                                    mAccounts,\n                                    account,\n                                    result.getString(AccountManager.KEY_AUTH_FAILED_MESSAGE),\n                                    intent, \"android\", accounts.userId);\n                        }\n                    }\n                    super.onResult(result);\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private void logGetAuthTokenMetrics(final String callerPackage, String accountType) {\n        // Although this is not a 'device policy' API, enterprise is the current use case.\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.GET_ACCOUNT_AUTH_TOKEN)\n                .setStrings(\n                        TextUtils.emptyIfNull(callerPackage),\n                        TextUtils.emptyIfNull(accountType))\n                .write();\n    }\n\n    private byte[] calculatePackageSignatureDigest(String callerPkg) {\n        MessageDigest digester;\n        try {\n            digester = MessageDigest.getInstance(\"SHA-256\");\n            PackageInfo pkgInfo = mPackageManager.getPackageInfo(\n                    callerPkg, PackageManager.GET_SIGNATURES);\n            for (Signature sig : pkgInfo.signatures) {\n                digester.update(sig.toByteArray());\n            }\n        } catch (NoSuchAlgorithmException x) {\n            Log.wtf(TAG, \"SHA-256 should be available\", x);\n            digester = null;\n        } catch (NameNotFoundException e) {\n            Log.w(TAG, \"Could not find packageinfo for: \" + callerPkg);\n            digester = null;\n        }\n        return (digester == null) ? null : digester.digest();\n    }\n\n    private void createNoCredentialsPermissionNotification(Account account, Intent intent,\n            String packageName, int userId) {\n        int uid = intent.getIntExtra(\n                GrantCredentialsPermissionActivity.EXTRAS_REQUESTING_UID, -1);\n        String authTokenType = intent.getStringExtra(\n                GrantCredentialsPermissionActivity.EXTRAS_AUTH_TOKEN_TYPE);\n        final String titleAndSubtitle =\n                mContext.getString(R.string.permission_request_notification_for_app_with_subtitle,\n                getApplicationLabel(packageName), account.name);\n        final int index = titleAndSubtitle.indexOf('\\n');\n        String title = titleAndSubtitle;\n        String subtitle = \"\";\n        if (index > 0) {\n            title = titleAndSubtitle.substring(0, index);\n            subtitle = titleAndSubtitle.substring(index + 1);\n        }\n        UserHandle user = UserHandle.of(userId);\n        Context contextForUser = getContextForUser(user);\n        Notification n =\n                new Notification.Builder(contextForUser, SystemNotificationChannels.ACCOUNT)\n                    .setSmallIcon(android.R.drawable.stat_sys_warning)\n                    .setWhen(0)\n                    .setColor(contextForUser.getColor(\n                            com.android.internal.R.color.system_notification_accent_color))\n                    .setContentTitle(title)\n                    .setContentText(subtitle)\n                    .setContentIntent(PendingIntent.getActivityAsUser(mContext, 0, intent,\n                            PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_IMMUTABLE,\n                            null, user))\n                    .build();\n        installNotification(getCredentialPermissionNotificationId(\n                account, authTokenType, uid), n, \"android\", user.getIdentifier());\n    }\n\n    private String getApplicationLabel(String packageName) {\n        try {\n            return mPackageManager.getApplicationLabel(\n                    mPackageManager.getApplicationInfo(packageName, 0)).toString();\n        } catch (PackageManager.NameNotFoundException e) {\n            return packageName;\n        }\n    }\n\n    private Intent newGrantCredentialsPermissionIntent(Account account, String packageName,\n            int uid, AccountAuthenticatorResponse response, String authTokenType,\n            boolean startInNewTask) {\n\n        Intent intent = new Intent(mContext, GrantCredentialsPermissionActivity.class);\n\n        if (startInNewTask) {\n            // See FLAG_ACTIVITY_NEW_TASK docs for limitations and benefits of the flag.\n            // Since it was set in Eclair+ we can't change it without breaking apps using\n            // the intent from a non-Activity context. This is the default behavior.\n            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        }\n        intent.addCategory(getCredentialPermissionNotificationId(account,\n                authTokenType, uid).mTag + (packageName != null ? packageName : \"\"));\n        intent.putExtra(GrantCredentialsPermissionActivity.EXTRAS_ACCOUNT, account);\n        intent.putExtra(GrantCredentialsPermissionActivity.EXTRAS_AUTH_TOKEN_TYPE, authTokenType);\n        intent.putExtra(GrantCredentialsPermissionActivity.EXTRAS_RESPONSE, response);\n        intent.putExtra(GrantCredentialsPermissionActivity.EXTRAS_REQUESTING_UID, uid);\n\n        return intent;\n    }\n\n    private NotificationId getCredentialPermissionNotificationId(Account account,\n            String authTokenType, int uid) {\n        NotificationId nId;\n        UserAccounts accounts = getUserAccounts(UserHandle.getUserId(uid));\n        synchronized (accounts.credentialsPermissionNotificationIds) {\n            final Pair<Pair<Account, String>, Integer> key =\n                    new Pair<Pair<Account, String>, Integer>(\n                            new Pair<Account, String>(account, authTokenType), uid);\n            nId = accounts.credentialsPermissionNotificationIds.get(key);\n            if (nId == null) {\n                String tag = TAG + \":\" + SystemMessage.NOTE_ACCOUNT_CREDENTIAL_PERMISSION\n                        + \":\" + account.hashCode() + \":\" + authTokenType.hashCode() + \":\" + uid;\n                int id = SystemMessage.NOTE_ACCOUNT_CREDENTIAL_PERMISSION;\n                nId = new NotificationId(tag, id);\n                accounts.credentialsPermissionNotificationIds.put(key, nId);\n            }\n        }\n        return nId;\n    }\n\n    private NotificationId getSigninRequiredNotificationId(UserAccounts accounts, Account account) {\n        NotificationId nId;\n        synchronized (accounts.signinRequiredNotificationIds) {\n            nId = accounts.signinRequiredNotificationIds.get(account);\n            if (nId == null) {\n                String tag = TAG + \":\" + SystemMessage.NOTE_ACCOUNT_REQUIRE_SIGNIN\n                        + \":\" + account.hashCode();\n                int id = SystemMessage.NOTE_ACCOUNT_REQUIRE_SIGNIN;\n                nId = new NotificationId(tag, id);\n                accounts.signinRequiredNotificationIds.put(account, nId);\n            }\n        }\n        return nId;\n    }\n\n    @Override\n    public void addAccount(final IAccountManagerResponse response, final String accountType,\n            final String authTokenType, final String[] requiredFeatures,\n            final boolean expectActivityLaunch, final Bundle optionsIn) {\n        Bundle.setDefusable(optionsIn, true);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"addAccount: accountType \" + accountType\n                    + \", response \" + response\n                    + \", authTokenType \" + authTokenType\n                    + \", requiredFeatures \" + Arrays.toString(requiredFeatures)\n                    + \", expectActivityLaunch \" + expectActivityLaunch\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        if (response == null) throw new IllegalArgumentException(\"response is null\");\n        if (accountType == null) throw new IllegalArgumentException(\"accountType is null\");\n\n        // Is user disallowed from modifying accounts?\n        final int uid = Binder.getCallingUid();\n        final int userId = UserHandle.getUserId(uid);\n        if (!canUserModifyAccounts(userId, uid)) {\n            try {\n                response.onError(AccountManager.ERROR_CODE_USER_RESTRICTED,\n                        \"User is not allowed to add an account!\");\n            } catch (RemoteException re) {\n            }\n            showCantAddAccount(AccountManager.ERROR_CODE_USER_RESTRICTED, userId);\n            return;\n        }\n        if (!canUserModifyAccountsForType(userId, accountType, uid)) {\n            try {\n                response.onError(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                        \"User cannot modify accounts of this type (policy).\");\n            } catch (RemoteException re) {\n            }\n            showCantAddAccount(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                    userId);\n            return;\n        }\n        addAccountAndLogMetrics(response, accountType, authTokenType, requiredFeatures,\n                expectActivityLaunch, optionsIn, userId);\n    }\n\n    @Override\n    public void addAccountAsUser(final IAccountManagerResponse response, final String accountType,\n            final String authTokenType, final String[] requiredFeatures,\n            final boolean expectActivityLaunch, final Bundle optionsIn, int userId) {\n        Bundle.setDefusable(optionsIn, true);\n        int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"addAccount: accountType \" + accountType\n                    + \", response \" + response\n                    + \", authTokenType \" + authTokenType\n                    + \", requiredFeatures \" + Arrays.toString(requiredFeatures)\n                    + \", expectActivityLaunch \" + expectActivityLaunch\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid()\n                    + \", for user id \" + userId);\n        }\n        Preconditions.checkArgument(response != null, \"response cannot be null\");\n        Preconditions.checkArgument(accountType != null, \"accountType cannot be null\");\n        // Only allow the system process to add accounts of other users\n        if (isCrossUser(callingUid, userId)) {\n            throw new SecurityException(\n                    String.format(\n                            \"User %s trying to add account for %s\" ,\n                            UserHandle.getCallingUserId(),\n                            userId));\n        }\n\n        // Is user disallowed from modifying accounts?\n        if (!canUserModifyAccounts(userId, callingUid)) {\n            try {\n                response.onError(AccountManager.ERROR_CODE_USER_RESTRICTED,\n                        \"User is not allowed to add an account!\");\n            } catch (RemoteException re) {\n            }\n            showCantAddAccount(AccountManager.ERROR_CODE_USER_RESTRICTED, userId);\n            return;\n        }\n        if (!canUserModifyAccountsForType(userId, accountType, callingUid)) {\n            try {\n                response.onError(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                        \"User cannot modify accounts of this type (policy).\");\n            } catch (RemoteException re) {\n            }\n            showCantAddAccount(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                    userId);\n            return;\n        }\n        addAccountAndLogMetrics(response, accountType, authTokenType, requiredFeatures,\n                expectActivityLaunch, optionsIn, userId);\n    }\n\n    private void addAccountAndLogMetrics(\n            IAccountManagerResponse response, String accountType,\n            String authTokenType, String[] requiredFeatures,\n            boolean expectActivityLaunch, Bundle optionsIn, int userId) {\n        final int pid = Binder.getCallingPid();\n        final int uid = Binder.getCallingUid();\n        final Bundle options = (optionsIn == null) ? new Bundle() : optionsIn;\n        options.putInt(AccountManager.KEY_CALLER_UID, uid);\n        options.putInt(AccountManager.KEY_CALLER_PID, pid);\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            logRecordWithUid(\n                    accounts, AccountsDb.DEBUG_ACTION_CALLED_ACCOUNT_ADD, AccountsDb.TABLE_ACCOUNTS,\n                    uid);\n            new Session(accounts, response, accountType, expectActivityLaunch,\n                    true /* stripAuthTokenFromResult */, null /* accountName */,\n                    false /* authDetailsRequired */, true /* updateLastAuthenticationTime */) {\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.addAccount(\n                            this, mAccountType, authTokenType, requiredFeatures, options);\n                    String callerPackage = options.getString(\n                            AccountManager.KEY_ANDROID_PACKAGE_NAME);\n                    logAddAccountMetrics(\n                            callerPackage, accountType, requiredFeatures, authTokenType);\n                }\n\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now) + \", addAccount\"\n                            + \", accountType \" + accountType\n                            + \", requiredFeatures \"\n                            + (requiredFeatures != null\n                            ? TextUtils.join(\",\", requiredFeatures)\n                            : null);\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private void logAddAccountMetrics(\n            String callerPackage, String accountType, String[] requiredFeatures,\n            String authTokenType) {\n        // Although this is not a 'device policy' API, enterprise is the current use case.\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.ADD_ACCOUNT)\n                .setStrings(\n                        TextUtils.emptyIfNull(accountType),\n                        TextUtils.emptyIfNull(callerPackage),\n                        TextUtils.emptyIfNull(authTokenType),\n                        requiredFeatures == null\n                                ? \"\"\n                                : TextUtils.join(\";\", requiredFeatures))\n                .write();\n    }\n\n    @Override\n    public void startAddAccountSession(\n            final IAccountManagerResponse response,\n            final String accountType,\n            final String authTokenType,\n            final String[] requiredFeatures,\n            final boolean expectActivityLaunch,\n            final Bundle optionsIn) {\n        Bundle.setDefusable(optionsIn, true);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG,\n                    \"startAddAccountSession: accountType \" + accountType\n                    + \", response \" + response\n                    + \", authTokenType \" + authTokenType\n                    + \", requiredFeatures \" + Arrays.toString(requiredFeatures)\n                    + \", expectActivityLaunch \" + expectActivityLaunch\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Preconditions.checkArgument(response != null, \"response cannot be null\");\n        Preconditions.checkArgument(accountType != null, \"accountType cannot be null\");\n\n        final int uid = Binder.getCallingUid();\n        final int userId = UserHandle.getUserId(uid);\n        if (!canUserModifyAccounts(userId, uid)) {\n            try {\n                response.onError(AccountManager.ERROR_CODE_USER_RESTRICTED,\n                        \"User is not allowed to add an account!\");\n            } catch (RemoteException re) {\n            }\n            showCantAddAccount(AccountManager.ERROR_CODE_USER_RESTRICTED, userId);\n            return;\n        }\n        if (!canUserModifyAccountsForType(userId, accountType, uid)) {\n            try {\n                response.onError(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                        \"User cannot modify accounts of this type (policy).\");\n            } catch (RemoteException re) {\n            }\n            showCantAddAccount(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                    userId);\n            return;\n        }\n        final int pid = Binder.getCallingPid();\n        final Bundle options = (optionsIn == null) ? new Bundle() : optionsIn;\n        options.putInt(AccountManager.KEY_CALLER_UID, uid);\n        options.putInt(AccountManager.KEY_CALLER_PID, pid);\n\n        // Check to see if the Password should be included to the caller.\n        String callerPkg = options.getString(AccountManager.KEY_ANDROID_PACKAGE_NAME);\n        boolean isPasswordForwardingAllowed = checkPermissionAndNote(\n                callerPkg, uid, Manifest.permission.GET_PASSWORD);\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            logRecordWithUid(accounts, AccountsDb.DEBUG_ACTION_CALLED_START_ACCOUNT_ADD,\n                    AccountsDb.TABLE_ACCOUNTS, uid);\n            new StartAccountSession(\n                    accounts,\n                    response,\n                    accountType,\n                    expectActivityLaunch,\n                    null /* accountName */,\n                    false /* authDetailsRequired */,\n                    true /* updateLastAuthenticationTime */,\n                    isPasswordForwardingAllowed) {\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.startAddAccountSession(this, mAccountType, authTokenType,\n                            requiredFeatures, options);\n                    logAddAccountMetrics(callerPkg, accountType, requiredFeatures, authTokenType);\n                }\n\n                @Override\n                protected String toDebugString(long now) {\n                    String requiredFeaturesStr = TextUtils.join(\",\", requiredFeatures);\n                    return super.toDebugString(now) + \", startAddAccountSession\" + \", accountType \"\n                            + accountType + \", requiredFeatures \"\n                            + (requiredFeatures != null ? requiredFeaturesStr : null);\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    /** Session that will encrypt the KEY_ACCOUNT_SESSION_BUNDLE in result. */\n    private abstract class StartAccountSession extends Session {\n\n        private final boolean mIsPasswordForwardingAllowed;\n\n        public StartAccountSession(\n                UserAccounts accounts,\n                IAccountManagerResponse response,\n                String accountType,\n                boolean expectActivityLaunch,\n                String accountName,\n                boolean authDetailsRequired,\n                boolean updateLastAuthenticationTime,\n                boolean isPasswordForwardingAllowed) {\n            super(accounts, response, accountType, expectActivityLaunch,\n                    true /* stripAuthTokenFromResult */, accountName, authDetailsRequired,\n                    updateLastAuthenticationTime);\n            mIsPasswordForwardingAllowed = isPasswordForwardingAllowed;\n        }\n\n        @Override\n        public void onResult(Bundle result) {\n            Bundle.setDefusable(result, true);\n            mNumResults++;\n            Intent intent = null;\n            if (result != null) {\n                if (!checkKeyIntent(\n                        Binder.getCallingUid(),\n                        result)) {\n                    onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                            \"invalid intent in bundle returned\");\n                    return;\n                }\n            }\n            IAccountManagerResponse response;\n            if (mExpectActivityLaunch && result != null\n                    && result.containsKey(AccountManager.KEY_INTENT)) {\n                response = mResponse;\n            } else {\n                response = getResponseAndClose();\n            }\n            if (response == null) {\n                return;\n            }\n            if (result == null) {\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.v(TAG, getClass().getSimpleName() + \" calling onError() on response \"\n                            + response);\n                }\n                sendErrorResponse(response, AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                        \"null bundle returned\");\n                return;\n            }\n\n            if ((result.getInt(AccountManager.KEY_ERROR_CODE, -1) > 0) && (intent == null)) {\n                // All AccountManager error codes are greater\n                // than 0\n                sendErrorResponse(response, result.getInt(AccountManager.KEY_ERROR_CODE),\n                        result.getString(AccountManager.KEY_ERROR_MESSAGE));\n                return;\n            }\n\n            // Omit passwords if the caller isn't permitted to see them.\n            if (!mIsPasswordForwardingAllowed) {\n                result.remove(AccountManager.KEY_PASSWORD);\n            }\n\n            // Strip auth token from result.\n            result.remove(AccountManager.KEY_AUTHTOKEN);\n            if (!checkKeyIntent(Binder.getCallingUid(), result)) {\n                onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                        \"invalid intent in bundle returned\");\n                return;\n            }\n\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG,\n                        getClass().getSimpleName() + \" calling onResult() on response \" + response);\n            }\n\n            // Get the session bundle created by authenticator. The\n            // bundle contains data necessary for finishing the session\n            // later. The session bundle will be encrypted here and\n            // decrypted later when trying to finish the session.\n            Bundle sessionBundle = result.getBundle(AccountManager.KEY_ACCOUNT_SESSION_BUNDLE);\n            if (sessionBundle != null) {\n                String accountType = sessionBundle.getString(AccountManager.KEY_ACCOUNT_TYPE);\n                if (TextUtils.isEmpty(accountType)\n                        || !mAccountType.equalsIgnoreCase(accountType)) {\n                    Log.w(TAG, \"Account type in session bundle doesn't match request.\");\n                }\n                // Add accountType info to session bundle. This will\n                // override any value set by authenticator.\n                sessionBundle.putString(AccountManager.KEY_ACCOUNT_TYPE, mAccountType);\n\n                // Encrypt session bundle before returning to caller.\n                try {\n                    CryptoHelper cryptoHelper = CryptoHelper.getInstance();\n                    Bundle encryptedBundle = cryptoHelper.encryptBundle(sessionBundle);\n                    result.putBundle(AccountManager.KEY_ACCOUNT_SESSION_BUNDLE, encryptedBundle);\n                } catch (GeneralSecurityException e) {\n                    if (Log.isLoggable(TAG, Log.DEBUG)) {\n                        Log.v(TAG, \"Failed to encrypt session bundle!\", e);\n                    }\n                    sendErrorResponse(response, AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                            \"failed to encrypt session bundle\");\n                    return;\n                }\n            }\n\n            sendResponse(response, result);\n        }\n    }\n\n    @Override\n    public void finishSessionAsUser(IAccountManagerResponse response,\n            @NonNull Bundle sessionBundle,\n            boolean expectActivityLaunch,\n            Bundle appInfo,\n            int userId) {\n        Bundle.setDefusable(sessionBundle, true);\n        int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG,\n                    \"finishSession: response \"+ response\n                            + \", expectActivityLaunch \" + expectActivityLaunch\n                            + \", caller's uid \" + callingUid\n                            + \", caller's user id \" + UserHandle.getCallingUserId()\n                            + \", pid \" + Binder.getCallingPid()\n                            + \", for user id \" + userId);\n        }\n        Preconditions.checkArgument(response != null, \"response cannot be null\");\n        // Session bundle is the encrypted bundle of the original bundle created by authenticator.\n        // Account type is added to it before encryption.\n        if (sessionBundle == null || sessionBundle.size() == 0) {\n            throw new IllegalArgumentException(\"sessionBundle is empty\");\n        }\n\n        // Only allow the system process to finish session for other users.\n        if (isCrossUser(callingUid, userId)) {\n            throw new SecurityException(\n                    String.format(\n                            \"User %s trying to finish session for %s without cross user permission\",\n                            UserHandle.getCallingUserId(),\n                            userId));\n        }\n\n        if (!canUserModifyAccounts(userId, callingUid)) {\n            sendErrorResponse(response,\n                    AccountManager.ERROR_CODE_USER_RESTRICTED,\n                    \"User is not allowed to add an account!\");\n            showCantAddAccount(AccountManager.ERROR_CODE_USER_RESTRICTED, userId);\n            return;\n        }\n\n        final int pid = Binder.getCallingPid();\n        final Bundle decryptedBundle;\n        final String accountType;\n        // First decrypt session bundle to get account type for checking permission.\n        try {\n            CryptoHelper cryptoHelper = CryptoHelper.getInstance();\n            decryptedBundle = cryptoHelper.decryptBundle(sessionBundle);\n            if (decryptedBundle == null) {\n                sendErrorResponse(\n                        response,\n                        AccountManager.ERROR_CODE_BAD_REQUEST,\n                        \"failed to decrypt session bundle\");\n                return;\n            }\n            accountType = decryptedBundle.getString(AccountManager.KEY_ACCOUNT_TYPE);\n            // Account type cannot be null. This should not happen if session bundle was created\n            // properly by #StartAccountSession.\n            if (TextUtils.isEmpty(accountType)) {\n                sendErrorResponse(\n                        response,\n                        AccountManager.ERROR_CODE_BAD_ARGUMENTS,\n                        \"accountType is empty\");\n                return;\n            }\n\n            // If by any chances, decryptedBundle contains colliding keys with\n            // system info\n            // such as AccountManager.KEY_ANDROID_PACKAGE_NAME required by the add account flow or\n            // update credentials flow, we should replace with the new values of the current call.\n            if (appInfo != null) {\n                decryptedBundle.putAll(appInfo);\n            }\n\n            // Add info that may be used by add account or update credentials flow.\n            decryptedBundle.putInt(AccountManager.KEY_CALLER_UID, callingUid);\n            decryptedBundle.putInt(AccountManager.KEY_CALLER_PID, pid);\n        } catch (GeneralSecurityException e) {\n            if (Log.isLoggable(TAG, Log.DEBUG)) {\n                Log.v(TAG, \"Failed to decrypt session bundle!\", e);\n            }\n            sendErrorResponse(\n                    response,\n                    AccountManager.ERROR_CODE_BAD_REQUEST,\n                    \"failed to decrypt session bundle\");\n            return;\n        }\n\n        if (!canUserModifyAccountsForType(userId, accountType, callingUid)) {\n            sendErrorResponse(\n                    response,\n                    AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                    \"User cannot modify accounts of this type (policy).\");\n            showCantAddAccount(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                    userId);\n            return;\n        }\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            logRecordWithUid(\n                    accounts,\n                    AccountsDb.DEBUG_ACTION_CALLED_ACCOUNT_SESSION_FINISH,\n                    AccountsDb.TABLE_ACCOUNTS,\n                    callingUid);\n            new Session(\n                    accounts,\n                    response,\n                    accountType,\n                    expectActivityLaunch,\n                    true /* stripAuthTokenFromResult */,\n                    null /* accountName */,\n                    false /* authDetailsRequired */,\n                    true /* updateLastAuthenticationTime */) {\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.finishSession(this, mAccountType, decryptedBundle);\n                }\n\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now)\n                            + \", finishSession\"\n                            + \", accountType \" + accountType;\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private void showCantAddAccount(int errorCode, int userId) {\n        final DevicePolicyManagerInternal dpmi =\n                LocalServices.getService(DevicePolicyManagerInternal.class);\n        Intent intent = null;\n        if (dpmi == null) {\n            intent = getDefaultCantAddAccountIntent(errorCode);\n        } else if (errorCode == AccountManager.ERROR_CODE_USER_RESTRICTED) {\n            intent = dpmi.createUserRestrictionSupportIntent(userId,\n                    UserManager.DISALLOW_MODIFY_ACCOUNTS);\n        } else if (errorCode == AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE) {\n            intent = dpmi.createShowAdminSupportIntent(userId, false);\n        }\n        if (intent == null) {\n            intent = getDefaultCantAddAccountIntent(errorCode);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            mContext.startActivityAsUser(intent, new UserHandle(userId));\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    /**\n     * Called when we don't know precisely who is preventing us from adding an account.\n     */\n    private Intent getDefaultCantAddAccountIntent(int errorCode) {\n        Intent cantAddAccount = new Intent(mContext, CantAddAccountActivity.class);\n        cantAddAccount.putExtra(CantAddAccountActivity.EXTRA_ERROR_CODE, errorCode);\n        cantAddAccount.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        return cantAddAccount;\n    }\n\n    @Override\n    public void confirmCredentialsAsUser(\n            IAccountManagerResponse response,\n            final Account account,\n            final Bundle options,\n            final boolean expectActivityLaunch,\n            int userId) {\n        Bundle.setDefusable(options, true);\n        int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"confirmCredentials: \" + account\n                    + \", response \" + response\n                    + \", expectActivityLaunch \" + expectActivityLaunch\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        // Only allow the system process to read accounts of other users\n        if (isCrossUser(callingUid, userId)) {\n            throw new SecurityException(\n                    String.format(\n                            \"User %s trying to confirm account credentials for %s\" ,\n                            UserHandle.getCallingUserId(),\n                            userId));\n        }\n        if (response == null) throw new IllegalArgumentException(\"response is null\");\n        if (account == null) throw new IllegalArgumentException(\"account is null\");\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            new Session(accounts, response, account.type, expectActivityLaunch,\n                    true /* stripAuthTokenFromResult */, account.name,\n                    true /* authDetailsRequired */, true /* updateLastAuthenticatedTime */) {\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.confirmCredentials(this, account, options);\n                }\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now) + \", confirmCredentials\"\n                            + \", \" + account.toSafeString();\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void updateCredentials(IAccountManagerResponse response, final Account account,\n            final String authTokenType, final boolean expectActivityLaunch,\n            final Bundle loginOptions) {\n        Bundle.setDefusable(loginOptions, true);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"updateCredentials: \" + account\n                    + \", response \" + response\n                    + \", authTokenType \" + authTokenType\n                    + \", expectActivityLaunch \" + expectActivityLaunch\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        if (response == null) throw new IllegalArgumentException(\"response is null\");\n        if (account == null) throw new IllegalArgumentException(\"account is null\");\n        int userId = UserHandle.getCallingUserId();\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            new Session(accounts, response, account.type, expectActivityLaunch,\n                    true /* stripAuthTokenFromResult */, account.name,\n                    false /* authDetailsRequired */, true /* updateLastCredentialTime */) {\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.updateCredentials(this, account, authTokenType, loginOptions);\n                }\n                @Override\n                protected String toDebugString(long now) {\n                    if (loginOptions != null) loginOptions.keySet();\n                    return super.toDebugString(now) + \", updateCredentials\"\n                            + \", \" + account.toSafeString()\n                            + \", authTokenType \" + authTokenType\n                            + \", loginOptions \" + loginOptions;\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void startUpdateCredentialsSession(\n            IAccountManagerResponse response,\n            final Account account,\n            final String authTokenType,\n            final boolean expectActivityLaunch,\n            final Bundle loginOptions) {\n        Bundle.setDefusable(loginOptions, true);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG,\n                    \"startUpdateCredentialsSession: \" + account + \", response \" + response\n                            + \", authTokenType \" + authTokenType + \", expectActivityLaunch \"\n                            + expectActivityLaunch + \", caller's uid \" + Binder.getCallingUid()\n                            + \", pid \" + Binder.getCallingPid());\n        }\n        if (response == null) {\n            throw new IllegalArgumentException(\"response is null\");\n        }\n        if (account == null) {\n            throw new IllegalArgumentException(\"account is null\");\n        }\n\n        final int uid = Binder.getCallingUid();\n        int userId = UserHandle.getCallingUserId();\n\n        // Check to see if the Password should be included to the caller.\n        String callerPkg = loginOptions.getString(AccountManager.KEY_ANDROID_PACKAGE_NAME);\n        boolean isPasswordForwardingAllowed = checkPermissionAndNote(\n                callerPkg, uid, Manifest.permission.GET_PASSWORD);\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            new StartAccountSession(\n                    accounts,\n                    response,\n                    account.type,\n                    expectActivityLaunch,\n                    account.name,\n                    false /* authDetailsRequired */,\n                    true /* updateLastCredentialTime */,\n                    isPasswordForwardingAllowed) {\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.startUpdateCredentialsSession(this, account, authTokenType,\n                            loginOptions);\n                }\n\n                @Override\n                protected String toDebugString(long now) {\n                    if (loginOptions != null)\n                        loginOptions.keySet();\n                    return super.toDebugString(now)\n                            + \", startUpdateCredentialsSession\"\n                            + \", \" + account.toSafeString()\n                            + \", authTokenType \" + authTokenType\n                            + \", loginOptions \" + loginOptions;\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void isCredentialsUpdateSuggested(\n            IAccountManagerResponse response,\n            final Account account,\n            final String statusToken) {\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG,\n                    \"isCredentialsUpdateSuggested: \" + account + \", response \" + response\n                            + \", caller's uid \" + Binder.getCallingUid()\n                            + \", pid \" + Binder.getCallingPid());\n        }\n        if (response == null) {\n            throw new IllegalArgumentException(\"response is null\");\n        }\n        if (account == null) {\n            throw new IllegalArgumentException(\"account is null\");\n        }\n        if (TextUtils.isEmpty(statusToken)) {\n            throw new IllegalArgumentException(\"status token is empty\");\n        }\n\n        int usrId = UserHandle.getCallingUserId();\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(usrId);\n            new Session(accounts, response, account.type, false /* expectActivityLaunch */,\n                    false /* stripAuthTokenFromResult */, account.name,\n                    false /* authDetailsRequired */) {\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now) + \", isCredentialsUpdateSuggested\"\n                            + \", \" + account.toSafeString();\n                }\n\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.isCredentialsUpdateSuggested(this, account, statusToken);\n                }\n\n                @Override\n                public void onResult(Bundle result) {\n                    Bundle.setDefusable(result, true);\n                    IAccountManagerResponse response = getResponseAndClose();\n                    if (response == null) {\n                        return;\n                    }\n\n                    if (result == null) {\n                        sendErrorResponse(\n                                response,\n                                AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                                \"null bundle\");\n                        return;\n                    }\n\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, getClass().getSimpleName() + \" calling onResult() on response \"\n                                + response);\n                    }\n                    // Check to see if an error occurred. We know if an error occurred because all\n                    // error codes are greater than 0.\n                    if ((result.getInt(AccountManager.KEY_ERROR_CODE, -1) > 0)) {\n                        sendErrorResponse(response,\n                                result.getInt(AccountManager.KEY_ERROR_CODE),\n                                result.getString(AccountManager.KEY_ERROR_MESSAGE));\n                        return;\n                    }\n                    if (!result.containsKey(AccountManager.KEY_BOOLEAN_RESULT)) {\n                        sendErrorResponse(\n                                response,\n                                AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                                \"no result in response\");\n                        return;\n                    }\n                    final Bundle newResult = new Bundle();\n                    newResult.putBoolean(AccountManager.KEY_BOOLEAN_RESULT,\n                            result.getBoolean(AccountManager.KEY_BOOLEAN_RESULT, false));\n                    sendResponse(response, newResult);\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void editProperties(IAccountManagerResponse response, final String accountType,\n            final boolean expectActivityLaunch) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"editProperties: accountType \" + accountType\n                    + \", response \" + response\n                    + \", expectActivityLaunch \" + expectActivityLaunch\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        if (response == null) throw new IllegalArgumentException(\"response is null\");\n        if (accountType == null) throw new IllegalArgumentException(\"accountType is null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(accountType, callingUid, userId)\n                && !isSystemUid(callingUid)) {\n            String msg = String.format(\n                    \"uid %s cannot edit authenticator properites for account type: %s\",\n                    callingUid,\n                    accountType);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            new Session(accounts, response, accountType, expectActivityLaunch,\n                    true /* stripAuthTokenFromResult */, null /* accountName */,\n                    false /* authDetailsRequired */) {\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.editProperties(this, mAccountType);\n                }\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now) + \", editProperties\"\n                            + \", accountType \" + accountType;\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public boolean hasAccountAccess(@NonNull Account account,  @NonNull String packageName,\n            @NonNull UserHandle userHandle) {\n        if (UserHandle.getAppId(Binder.getCallingUid()) != Process.SYSTEM_UID) {\n            throw new SecurityException(\"Can be called only by system UID\");\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        Objects.requireNonNull(packageName, \"packageName cannot be null\");\n        Objects.requireNonNull(userHandle, \"userHandle cannot be null\");\n\n        final int userId = userHandle.getIdentifier();\n\n        Preconditions.checkArgumentInRange(userId, 0, Integer.MAX_VALUE, \"user must be concrete\");\n\n        try {\n            int uid = mPackageManager.getPackageUidAsUser(packageName, userId);\n            return hasAccountAccess(account, packageName, uid);\n        } catch (NameNotFoundException e) {\n            Log.d(TAG, \"Package not found \" + e.getMessage());\n            return false;\n        }\n    }\n\n    // Returns package with oldest target SDK for given UID.\n    private String getPackageNameForUid(int uid) {\n        String[] packageNames = mPackageManager.getPackagesForUid(uid);\n        if (ArrayUtils.isEmpty(packageNames)) {\n            return null;\n        }\n        String packageName = packageNames[0];\n        if (packageNames.length == 1) {\n            return packageName;\n        }\n        // Due to visibility changes we want to use package with oldest target SDK\n        int oldestVersion = Integer.MAX_VALUE;\n        for (String name : packageNames) {\n            try {\n                ApplicationInfo applicationInfo = mPackageManager.getApplicationInfo(name, 0);\n                if (applicationInfo != null) {\n                    int version = applicationInfo.targetSdkVersion;\n                    if (version < oldestVersion) {\n                        oldestVersion = version;\n                        packageName = name;\n                    }\n                }\n            } catch (NameNotFoundException e) {\n                // skip\n            }\n        }\n        return packageName;\n    }\n\n    private boolean hasAccountAccess(@NonNull Account account, @Nullable String packageName,\n            int uid) {\n        if (packageName == null) {\n            packageName = getPackageNameForUid(uid);\n            if (packageName == null) {\n                return false;\n            }\n        }\n\n        // Use null token which means any token. Having a token means the package\n        // is trusted by the authenticator, hence it is fine to access the account.\n        if (permissionIsGranted(account, null, uid, UserHandle.getUserId(uid))) {\n            return true;\n        }\n        // In addition to the permissions required to get an auth token we also allow\n        // the account to be accessed by apps for which user or authenticator granted visibility.\n\n        int visibility = resolveAccountVisibility(account, packageName,\n            getUserAccounts(UserHandle.getUserId(uid)));\n        return (visibility == AccountManager.VISIBILITY_VISIBLE\n            || visibility == AccountManager.VISIBILITY_USER_MANAGED_VISIBLE);\n    }\n\n    @Override\n    public IntentSender createRequestAccountAccessIntentSenderAsUser(@NonNull Account account,\n            @NonNull String packageName, @NonNull UserHandle userHandle) {\n        if (UserHandle.getAppId(Binder.getCallingUid()) != Process.SYSTEM_UID) {\n            throw new SecurityException(\"Can be called only by system UID\");\n        }\n\n        Objects.requireNonNull(account, \"account cannot be null\");\n        Objects.requireNonNull(packageName, \"packageName cannot be null\");\n        Objects.requireNonNull(userHandle, \"userHandle cannot be null\");\n\n        final int userId = userHandle.getIdentifier();\n\n        Preconditions.checkArgumentInRange(userId, 0, Integer.MAX_VALUE, \"user must be concrete\");\n\n        final int uid;\n        try {\n            uid = mPackageManager.getPackageUidAsUser(packageName, userId);\n        } catch (NameNotFoundException e) {\n            Slog.e(TAG, \"Unknown package \" + packageName);\n            return null;\n        }\n\n        Intent intent = newRequestAccountAccessIntent(account, packageName, uid, null);\n\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            return PendingIntent.getActivityAsUser(\n                    mContext, 0, intent, PendingIntent.FLAG_ONE_SHOT\n                            | PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_IMMUTABLE,\n                    null, new UserHandle(userId)).getIntentSender();\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    private Intent newRequestAccountAccessIntent(Account account, String packageName,\n            int uid, RemoteCallback callback) {\n        return newGrantCredentialsPermissionIntent(account, packageName, uid,\n                new AccountAuthenticatorResponse(new IAccountAuthenticatorResponse.Stub() {\n            @Override\n            public void onResult(Bundle value) throws RemoteException {\n                handleAuthenticatorResponse(true);\n            }\n\n            @Override\n            public void onRequestContinued() {\n                /* ignore */\n            }\n\n            @Override\n            public void onError(int errorCode, String errorMessage) throws RemoteException {\n                handleAuthenticatorResponse(false);\n            }\n\n            private void handleAuthenticatorResponse(boolean accessGranted) throws RemoteException {\n                cancelNotification(getCredentialPermissionNotificationId(account,\n                        AccountManager.ACCOUNT_ACCESS_TOKEN_TYPE, uid),\n                        UserHandle.getUserHandleForUid(uid));\n                if (callback != null) {\n                    Bundle result = new Bundle();\n                    result.putBoolean(AccountManager.KEY_BOOLEAN_RESULT, accessGranted);\n                    callback.sendResult(result);\n                }\n            }\n        }), AccountManager.ACCOUNT_ACCESS_TOKEN_TYPE, false);\n    }\n\n    @Override\n    public boolean someUserHasAccount(@NonNull final Account account) {\n        if (!UserHandle.isSameApp(Process.SYSTEM_UID, Binder.getCallingUid())) {\n            throw new SecurityException(\"Only system can check for accounts across users\");\n        }\n        final long token = Binder.clearCallingIdentity();\n        try {\n            AccountAndUser[] allAccounts = getAllAccounts();\n            for (int i = allAccounts.length - 1; i >= 0; i--) {\n                if (allAccounts[i].account.equals(account)) {\n                    return true;\n                }\n            }\n            return false;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private class GetAccountsByTypeAndFeatureSession extends Session {\n        private final String[] mFeatures;\n        private volatile Account[] mAccountsOfType = null;\n        private volatile ArrayList<Account> mAccountsWithFeatures = null;\n        private volatile int mCurrentAccount = 0;\n        private final int mCallingUid;\n        private final String mPackageName;\n        private final boolean mIncludeManagedNotVisible;\n\n        public GetAccountsByTypeAndFeatureSession(\n                UserAccounts accounts,\n                IAccountManagerResponse response,\n                String type,\n                String[] features,\n                int callingUid,\n                String packageName,\n                boolean includeManagedNotVisible) {\n            super(accounts, response, type, false /* expectActivityLaunch */,\n                    true /* stripAuthTokenFromResult */, null /* accountName */,\n                    false /* authDetailsRequired */);\n            mCallingUid = callingUid;\n            mFeatures = features;\n            mPackageName = packageName;\n            mIncludeManagedNotVisible = includeManagedNotVisible;\n        }\n\n        @Override\n        public void run() throws RemoteException {\n            mAccountsOfType = getAccountsFromCache(mAccounts, mAccountType,\n                    mCallingUid, mPackageName, mIncludeManagedNotVisible);\n            // check whether each account matches the requested features\n            mAccountsWithFeatures = new ArrayList<>(mAccountsOfType.length);\n            mCurrentAccount = 0;\n\n            checkAccount();\n        }\n\n        public void checkAccount() {\n            if (mCurrentAccount >= mAccountsOfType.length) {\n                sendResult();\n                return;\n            }\n\n            final IAccountAuthenticator accountAuthenticator = mAuthenticator;\n            if (accountAuthenticator == null) {\n                // It is possible that the authenticator has died, which is indicated by\n                // mAuthenticator being set to null. If this happens then just abort.\n                // There is no need to send back a result or error in this case since\n                // that already happened when mAuthenticator was cleared.\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.v(TAG, \"checkAccount: aborting session since we are no longer\"\n                            + \" connected to the authenticator, \" + toDebugString());\n                }\n                return;\n            }\n            try {\n                accountAuthenticator.hasFeatures(this, mAccountsOfType[mCurrentAccount], mFeatures);\n            } catch (RemoteException e) {\n                onError(AccountManager.ERROR_CODE_REMOTE_EXCEPTION, \"remote exception\");\n            }\n        }\n\n        @Override\n        public void onResult(Bundle result) {\n            Bundle.setDefusable(result, true);\n            mNumResults++;\n            if (result == null) {\n                onError(AccountManager.ERROR_CODE_INVALID_RESPONSE, \"null bundle\");\n                return;\n            }\n            if (result.getBoolean(AccountManager.KEY_BOOLEAN_RESULT, false)) {\n                mAccountsWithFeatures.add(mAccountsOfType[mCurrentAccount]);\n            }\n            mCurrentAccount++;\n            checkAccount();\n        }\n\n        public void sendResult() {\n            IAccountManagerResponse response = getResponseAndClose();\n            if (response != null) {\n                try {\n                    Account[] accounts = new Account[mAccountsWithFeatures.size()];\n                    for (int i = 0; i < accounts.length; i++) {\n                        accounts[i] = mAccountsWithFeatures.get(i);\n                    }\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, getClass().getSimpleName() + \" calling onResult() on response \"\n                                + response);\n                    }\n                    Bundle result = new Bundle();\n                    result.putParcelableArray(AccountManager.KEY_ACCOUNTS, accounts);\n                    response.onResult(result);\n                } catch (RemoteException e) {\n                    // if the caller is dead then there is no one to care about remote exceptions\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, \"failure while notifying response\", e);\n                    }\n                }\n            }\n        }\n\n        @Override\n        protected String toDebugString(long now) {\n            return super.toDebugString(now) + \", getAccountsByTypeAndFeatures\"\n                    + \", \" + (mFeatures != null ? TextUtils.join(\",\", mFeatures) : null);\n        }\n    }\n\n    /**\n     * Returns the accounts visible to the client within the context of a specific user\n     * @hide\n     */\n    @NonNull\n    public Account[] getAccounts(int userId, String opPackageName) {\n        int callingUid = Binder.getCallingUid();\n        mAppOpsManager.checkPackage(callingUid, opPackageName);\n        List<String> visibleAccountTypes = getTypesVisibleToCaller(callingUid, userId,\n                opPackageName);\n        if (visibleAccountTypes.isEmpty()) {\n            return EMPTY_ACCOUNT_ARRAY;\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return getAccountsInternal(\n                    accounts,\n                    callingUid,\n                    opPackageName,\n                    visibleAccountTypes,\n                    false /* includeUserManagedNotVisible */);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    /**\n     * Returns accounts for all running users, ignores visibility values.\n     *\n     * @hide\n     */\n    @NonNull\n    public AccountAndUser[] getRunningAccounts() {\n        final int[] runningUserIds;\n        try {\n            runningUserIds = ActivityManager.getService().getRunningUserIds();\n        } catch (RemoteException e) {\n            // Running in system_server; should never happen\n            throw new RuntimeException(e);\n        }\n        return getAccounts(runningUserIds);\n    }\n\n    /**\n     * Returns accounts for all users, ignores visibility values.\n     *\n     * @hide\n     */\n    @NonNull\n    public AccountAndUser[] getAllAccounts() {\n        final List<UserInfo> users = getUserManager().getAliveUsers();\n        final int[] userIds = new int[users.size()];\n        for (int i = 0; i < userIds.length; i++) {\n            userIds[i] = users.get(i).id;\n        }\n        return getAccounts(userIds);\n    }\n\n    @NonNull\n    private AccountAndUser[] getAccounts(int[] userIds) {\n        final ArrayList<AccountAndUser> runningAccounts = Lists.newArrayList();\n        for (int userId : userIds) {\n            UserAccounts userAccounts = getUserAccounts(userId);\n            if (userAccounts == null) continue;\n            Account[] accounts = getAccountsFromCache(\n                    userAccounts,\n                    null /* type */,\n                    Binder.getCallingUid(),\n                    null /* packageName */,\n                    false /* include managed not visible*/);\n            for (Account account : accounts) {\n                runningAccounts.add(new AccountAndUser(account, userId));\n            }\n        }\n\n        AccountAndUser[] accountsArray = new AccountAndUser[runningAccounts.size()];\n        return runningAccounts.toArray(accountsArray);\n    }\n\n    @Override\n    @NonNull\n    public Account[] getAccountsAsUser(String type, int userId, String opPackageName) {\n        int callingUid = Binder.getCallingUid();\n        mAppOpsManager.checkPackage(callingUid, opPackageName);\n        return getAccountsAsUserForPackage(type, userId, opPackageName /* callingPackage */, -1,\n                opPackageName, false /* includeUserManagedNotVisible */);\n    }\n\n    @NonNull\n    private Account[] getAccountsAsUserForPackage(\n            String type,\n            int userId,\n            String callingPackage,\n            int packageUid,\n            String opPackageName,\n            boolean includeUserManagedNotVisible) {\n        int callingUid = Binder.getCallingUid();\n        // Only allow the system process to read accounts of other users\n        if (userId != UserHandle.getCallingUserId()\n                && callingUid != Process.SYSTEM_UID\n                && mContext.checkCallingOrSelfPermission(\n                    android.Manifest.permission.INTERACT_ACROSS_USERS_FULL)\n                    != PackageManager.PERMISSION_GRANTED) {\n            throw new SecurityException(\"User \" + UserHandle.getCallingUserId()\n                    + \" trying to get account for \" + userId);\n        }\n\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"getAccounts: accountType \" + type\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid());\n        }\n\n        // If the original calling app was using account choosing activity\n        // provided by the framework or authenticator we'll passing in\n        // the original caller's uid here, which is what should be used for filtering.\n        List<String> managedTypes =\n                getTypesManagedByCaller(callingUid, UserHandle.getUserId(callingUid));\n        if (packageUid != -1 &&\n                ((UserHandle.isSameApp(callingUid, Process.SYSTEM_UID)\n                || (type != null && managedTypes.contains(type))))) {\n            callingUid = packageUid;\n            opPackageName = callingPackage;\n        }\n        List<String> visibleAccountTypes = getTypesVisibleToCaller(callingUid, userId,\n                opPackageName);\n        if (visibleAccountTypes.isEmpty()\n                || (type != null && !visibleAccountTypes.contains(type))) {\n            return EMPTY_ACCOUNT_ARRAY;\n        } else if (visibleAccountTypes.contains(type)) {\n            // Prune the list down to just the requested type.\n            visibleAccountTypes = new ArrayList<>();\n            visibleAccountTypes.add(type);\n        } // else aggregate all the visible accounts (it won't matter if the\n          // list is empty).\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return getAccountsInternal(\n                    accounts,\n                    callingUid,\n                    opPackageName,\n                    visibleAccountTypes,\n                    includeUserManagedNotVisible);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @NonNull\n    private Account[] getAccountsInternal(\n            UserAccounts userAccounts,\n            int callingUid,\n            String callingPackage,\n            List<String> visibleAccountTypes,\n            boolean includeUserManagedNotVisible) {\n        ArrayList<Account> visibleAccounts = new ArrayList<>();\n        for (String visibleType : visibleAccountTypes) {\n            Account[] accountsForType = getAccountsFromCache(\n                    userAccounts, visibleType, callingUid, callingPackage,\n                    includeUserManagedNotVisible);\n            if (accountsForType != null) {\n                visibleAccounts.addAll(Arrays.asList(accountsForType));\n            }\n        }\n        Account[] result = new Account[visibleAccounts.size()];\n        for (int i = 0; i < visibleAccounts.size(); i++) {\n            result[i] = visibleAccounts.get(i);\n        }\n        return result;\n    }\n\n    @Override\n    public void addSharedAccountsFromParentUser(int parentUserId, int userId,\n            String opPackageName) {\n        checkManageOrCreateUsersPermission(\"addSharedAccountsFromParentUser\");\n        Account[] accounts = getAccountsAsUser(null, parentUserId, opPackageName);\n        for (Account account : accounts) {\n            addSharedAccountAsUser(account, userId);\n        }\n    }\n\n    private boolean addSharedAccountAsUser(Account account, int userId) {\n        userId = handleIncomingUser(userId);\n        UserAccounts accounts = getUserAccounts(userId);\n        accounts.accountsDb.deleteSharedAccount(account);\n        long accountId = accounts.accountsDb.insertSharedAccount(account);\n        if (accountId < 0) {\n            Log.w(TAG, \"insertAccountIntoDatabase: \" + account.toSafeString()\n                    + \", skipping the DB insert failed\");\n            return false;\n        }\n        logRecord(AccountsDb.DEBUG_ACTION_ACCOUNT_ADD, AccountsDb.TABLE_SHARED_ACCOUNTS, accountId,\n                accounts);\n        return true;\n    }\n\n    public boolean renameSharedAccountAsUser(Account account, String newName, int userId) {\n        userId = handleIncomingUser(userId);\n        UserAccounts accounts = getUserAccounts(userId);\n        long sharedTableAccountId = accounts.accountsDb.findSharedAccountId(account);\n        int r = accounts.accountsDb.renameSharedAccount(account, newName);\n        if (r > 0) {\n            int callingUid = getCallingUid();\n            logRecord(AccountsDb.DEBUG_ACTION_ACCOUNT_RENAME, AccountsDb.TABLE_SHARED_ACCOUNTS,\n                    sharedTableAccountId, accounts, callingUid);\n            // Recursively rename the account.\n            renameAccountInternal(accounts, account, newName);\n        }\n        return r > 0;\n    }\n\n    public boolean removeSharedAccountAsUser(Account account, int userId) {\n        return removeSharedAccountAsUser(account, userId, getCallingUid());\n    }\n\n    private boolean removeSharedAccountAsUser(Account account, int userId, int callingUid) {\n        userId = handleIncomingUser(userId);\n        UserAccounts accounts = getUserAccounts(userId);\n        long sharedTableAccountId = accounts.accountsDb.findSharedAccountId(account);\n        boolean deleted = accounts.accountsDb.deleteSharedAccount(account);\n        if (deleted) {\n            logRecord(AccountsDb.DEBUG_ACTION_ACCOUNT_REMOVE, AccountsDb.TABLE_SHARED_ACCOUNTS,\n                    sharedTableAccountId, accounts, callingUid);\n            removeAccountInternal(accounts, account, callingUid);\n        }\n        return deleted;\n    }\n\n    public Account[] getSharedAccountsAsUser(int userId) {\n        userId = handleIncomingUser(userId);\n        UserAccounts accounts = getUserAccounts(userId);\n        synchronized (accounts.dbLock) {\n            List<Account> accountList = accounts.accountsDb.getSharedAccounts();\n            Account[] accountArray = new Account[accountList.size()];\n            accountList.toArray(accountArray);\n            return accountArray;\n        }\n    }\n\n    @Override\n    @NonNull\n    public Account[] getAccountsForPackage(String packageName, int uid, String opPackageName) {\n        int callingUid = Binder.getCallingUid();\n        if (!UserHandle.isSameApp(callingUid, Process.SYSTEM_UID)) {\n            // Don't do opPackageName check - caller is system.\n            throw new SecurityException(\"getAccountsForPackage() called from unauthorized uid \"\n                    + callingUid + \" with uid=\" + uid);\n        }\n        return getAccountsAsUserForPackage(null, UserHandle.getCallingUserId(), packageName, uid,\n                opPackageName, true /* includeUserManagedNotVisible */);\n    }\n\n    @Override\n    @NonNull\n    public Account[] getAccountsByTypeForPackage(String type, String packageName,\n            String opPackageName) {\n        int callingUid =  Binder.getCallingUid();\n        int userId = UserHandle.getCallingUserId();\n        mAppOpsManager.checkPackage(callingUid, opPackageName);\n        int packageUid = -1;\n        try {\n            packageUid = mPackageManager.getPackageUidAsUser(packageName, userId);\n        } catch (NameNotFoundException re) {\n            Slog.e(TAG, \"Couldn't determine the packageUid for \" + packageName + re);\n            return EMPTY_ACCOUNT_ARRAY;\n        }\n        if (!UserHandle.isSameApp(callingUid, Process.SYSTEM_UID)\n                && (type != null && !isAccountManagedByCaller(type, callingUid, userId))) {\n                return EMPTY_ACCOUNT_ARRAY;\n        }\n        if (!UserHandle.isSameApp(callingUid, Process.SYSTEM_UID) && type == null) {\n            return getAccountsAsUserForPackage(type, userId,\n                packageName, packageUid, opPackageName, false /* includeUserManagedNotVisible */);\n        }\n        return getAccountsAsUserForPackage(type, userId,\n                packageName, packageUid, opPackageName, true /* includeUserManagedNotVisible */);\n    }\n\n    private boolean needToStartChooseAccountActivity(Account[] accounts, String callingPackage) {\n        if (accounts.length < 1) return false;\n        if (accounts.length > 1) return true;\n        Account account = accounts[0];\n        UserAccounts userAccounts = getUserAccounts(UserHandle.getCallingUserId());\n        int visibility = resolveAccountVisibility(account, callingPackage, userAccounts);\n        if (visibility == AccountManager.VISIBILITY_USER_MANAGED_NOT_VISIBLE) return true;\n        return false;\n    }\n\n    private void startChooseAccountActivityWithAccounts(\n        IAccountManagerResponse response, Account[] accounts, String callingPackage) {\n        Intent intent = new Intent(mContext, ChooseAccountActivity.class);\n        intent.putExtra(AccountManager.KEY_ACCOUNTS, accounts);\n        intent.putExtra(AccountManager.KEY_ACCOUNT_MANAGER_RESPONSE,\n                new AccountManagerResponse(response));\n        intent.putExtra(AccountManager.KEY_ANDROID_PACKAGE_NAME, callingPackage);\n\n        mContext.startActivityAsUser(intent, UserHandle.of(UserHandle.getCallingUserId()));\n    }\n\n    private void handleGetAccountsResult(\n        IAccountManagerResponse response,\n        Account[] accounts,\n        String callingPackage) {\n\n        if (needToStartChooseAccountActivity(accounts, callingPackage)) {\n            startChooseAccountActivityWithAccounts(response, accounts, callingPackage);\n            return;\n        }\n        if (accounts.length == 1) {\n            Bundle bundle = new Bundle();\n            bundle.putString(AccountManager.KEY_ACCOUNT_NAME, accounts[0].name);\n            bundle.putString(AccountManager.KEY_ACCOUNT_TYPE, accounts[0].type);\n            onResult(response, bundle);\n            return;\n        }\n        // No qualified account exists, return an empty Bundle.\n        onResult(response, new Bundle());\n    }\n\n    @Override\n    public void getAccountByTypeAndFeatures(\n        IAccountManagerResponse response,\n        String accountType,\n        String[] features,\n        String opPackageName) {\n\n        int callingUid = Binder.getCallingUid();\n        mAppOpsManager.checkPackage(callingUid, opPackageName);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"getAccount: accountType \" + accountType\n                    + \", response \" + response\n                    + \", features \" + Arrays.toString(features)\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        if (response == null) throw new IllegalArgumentException(\"response is null\");\n        if (accountType == null) throw new IllegalArgumentException(\"accountType is null\");\n\n        int userId = UserHandle.getCallingUserId();\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts userAccounts = getUserAccounts(userId);\n            if (ArrayUtils.isEmpty(features)) {\n                Account[] accountsWithManagedNotVisible = getAccountsFromCache(\n                    userAccounts, accountType, callingUid, opPackageName,\n                    true /* include managed not visible */);\n                handleGetAccountsResult(\n                    response, accountsWithManagedNotVisible, opPackageName);\n                return;\n            }\n\n            IAccountManagerResponse retrieveAccountsResponse =\n                new IAccountManagerResponse.Stub() {\n                @Override\n                public void onResult(Bundle value) throws RemoteException {\n                    Parcelable[] parcelables = value.getParcelableArray(\n                        AccountManager.KEY_ACCOUNTS);\n                    Account[] accounts = new Account[parcelables.length];\n                    for (int i = 0; i < parcelables.length; i++) {\n                        accounts[i] = (Account) parcelables[i];\n                    }\n                    handleGetAccountsResult(\n                        response, accounts, opPackageName);\n                }\n\n                @Override\n                public void onError(int errorCode, String errorMessage)\n                        throws RemoteException {\n                    // Will not be called in this case.\n                }\n            };\n            new GetAccountsByTypeAndFeatureSession(\n                    userAccounts,\n                    retrieveAccountsResponse,\n                    accountType,\n                    features,\n                    callingUid,\n                    opPackageName,\n                    true /* include managed not visible */).bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void getAccountsByFeatures(\n            IAccountManagerResponse response,\n            String type,\n            String[] features,\n            String opPackageName) {\n        int callingUid = Binder.getCallingUid();\n        mAppOpsManager.checkPackage(callingUid, opPackageName);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"getAccounts: accountType \" + type\n                    + \", response \" + response\n                    + \", features \" + Arrays.toString(features)\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        if (response == null) throw new IllegalArgumentException(\"response is null\");\n        if (type == null) throw new IllegalArgumentException(\"accountType is null\");\n        int userId = UserHandle.getCallingUserId();\n\n        List<String> visibleAccountTypes = getTypesVisibleToCaller(callingUid, userId,\n                opPackageName);\n        if (!visibleAccountTypes.contains(type)) {\n            Bundle result = new Bundle();\n            // Need to return just the accounts that are from matching signatures.\n            result.putParcelableArray(AccountManager.KEY_ACCOUNTS, EMPTY_ACCOUNT_ARRAY);\n            try {\n                response.onResult(result);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Cannot respond to caller do to exception.\" , e);\n            }\n            return;\n        }\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts userAccounts = getUserAccounts(userId);\n            if (features == null || features.length == 0) {\n                Account[] accounts = getAccountsFromCache(userAccounts, type, callingUid,\n                        opPackageName, false);\n                Bundle result = new Bundle();\n                result.putParcelableArray(AccountManager.KEY_ACCOUNTS, accounts);\n                onResult(response, result);\n                return;\n            }\n            new GetAccountsByTypeAndFeatureSession(\n                    userAccounts,\n                    response,\n                    type,\n                    features,\n                    callingUid,\n                    opPackageName,\n                    false /* include managed not visible */).bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void onAccountAccessed(String token) throws RemoteException {\n        final int uid = Binder.getCallingUid();\n        if (UserHandle.getAppId(uid) == Process.SYSTEM_UID) {\n            return;\n        }\n        final int userId = UserHandle.getCallingUserId();\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            for (Account account : getAccounts(userId, mContext.getOpPackageName())) {\n                if (Objects.equals(account.getAccessId(), token)) {\n                    // An app just accessed the account. At this point it knows about\n                    // it and there is not need to hide this account from the app.\n                    // Do we need to update account visibility here?\n                    if (!hasAccountAccess(account, null, uid)) {\n                        updateAppPermission(account, AccountManager.ACCOUNT_ACCESS_TOKEN_TYPE,\n                                uid, true);\n                    }\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    @Override\n    public void onShellCommand(FileDescriptor in, FileDescriptor out,\n            FileDescriptor err, String[] args, ShellCallback callback,\n            ResultReceiver resultReceiver) {\n        new AccountManagerServiceShellCommand(this).exec(this, in, out, err, args,\n                callback, resultReceiver);\n    }\n\n    private abstract class Session extends IAccountAuthenticatorResponse.Stub\n            implements IBinder.DeathRecipient, ServiceConnection {\n        IAccountManagerResponse mResponse;\n        final String mAccountType;\n        final boolean mExpectActivityLaunch;\n        final long mCreationTime;\n        final String mAccountName;\n        // Indicates if we need to add auth details(like last credential time)\n        final boolean mAuthDetailsRequired;\n        // If set, we need to update the last authenticated time. This is\n        // currently\n        // used on\n        // successful confirming credentials.\n        final boolean mUpdateLastAuthenticatedTime;\n\n        public int mNumResults = 0;\n        private int mNumRequestContinued = 0;\n        private int mNumErrors = 0;\n\n        IAccountAuthenticator mAuthenticator = null;\n\n        private final boolean mStripAuthTokenFromResult;\n        protected final UserAccounts mAccounts;\n\n        public Session(UserAccounts accounts, IAccountManagerResponse response, String accountType,\n                boolean expectActivityLaunch, boolean stripAuthTokenFromResult, String accountName,\n                boolean authDetailsRequired) {\n            this(accounts, response, accountType, expectActivityLaunch, stripAuthTokenFromResult,\n                    accountName, authDetailsRequired, false /* updateLastAuthenticatedTime */);\n        }\n\n        public Session(UserAccounts accounts, IAccountManagerResponse response, String accountType,\n                boolean expectActivityLaunch, boolean stripAuthTokenFromResult, String accountName,\n                boolean authDetailsRequired, boolean updateLastAuthenticatedTime) {\n            super();\n            //if (response == null) throw new IllegalArgumentException(\"response is null\");\n            if (accountType == null) throw new IllegalArgumentException(\"accountType is null\");\n            mAccounts = accounts;\n            mStripAuthTokenFromResult = stripAuthTokenFromResult;\n            mResponse = response;\n            mAccountType = accountType;\n            mExpectActivityLaunch = expectActivityLaunch;\n            mCreationTime = SystemClock.elapsedRealtime();\n            mAccountName = accountName;\n            mAuthDetailsRequired = authDetailsRequired;\n            mUpdateLastAuthenticatedTime = updateLastAuthenticatedTime;\n\n            synchronized (mSessions) {\n                mSessions.put(toString(), this);\n            }\n            scheduleTimeout();\n            if (response != null) {\n                try {\n                    response.asBinder().linkToDeath(this, 0 /* flags */);\n                } catch (RemoteException e) {\n                    mResponse = null;\n                    binderDied();\n                }\n            }\n        }\n\n        IAccountManagerResponse getResponseAndClose() {\n            if (mResponse == null) {\n                close();\n                return null;\n            }\n            IAccountManagerResponse response = mResponse;\n            close(); // this clears mResponse so we need to save the response before this call\n            return response;\n        }\n\n        /**\n         * Checks Intents, supplied via KEY_INTENT, to make sure that they don't violate our\n         * security policy.\n         *\n         * In particular we want to make sure that the Authenticator doesn't try to trick users\n         * into launching arbitrary intents on the device via by tricking to click authenticator\n         * supplied entries in the system Settings app.\n         */\n        protected boolean checkKeyIntent(int authUid, Bundle bundle) {\n            if (!checkKeyIntentParceledCorrectly(bundle)) {\n            \tEventLog.writeEvent(0x534e4554, \"250588548\", authUid, \"\");\n                return false;\n            }\n            Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT);\n            if (intent == null) {\n                return true;\n            }\n            // Explicitly set an empty ClipData to ensure that we don't offer to\n            // promote any Uris contained inside for granting purposes\n            if (intent.getClipData() == null) {\n                intent.setClipData(ClipData.newPlainText(null, null));\n            }\n            final long bid = Binder.clearCallingIdentity();\n            try {\n                PackageManager pm = mContext.getPackageManager();\n                ResolveInfo resolveInfo = pm.resolveActivityAsUser(intent, 0, mAccounts.userId);\n                if (resolveInfo == null) {\n                    return false;\n                }\n                if (\"content\".equals(intent.getScheme())) {\n                    return false;\n                }\n                ActivityInfo targetActivityInfo = resolveInfo.activityInfo;\n                int targetUid = targetActivityInfo.applicationInfo.uid;\n                PackageManagerInternal pmi = LocalServices.getService(PackageManagerInternal.class);\n                if (!isExportedSystemActivity(targetActivityInfo)\n                        && !pmi.hasSignatureCapability(\n                                targetUid, authUid,\n                                PackageParser.SigningDetails.CertCapabilities.AUTH)) {\n                    String pkgName = targetActivityInfo.packageName;\n                    String activityName = targetActivityInfo.name;\n                    String tmpl = \"KEY_INTENT resolved to an Activity (%s) in a package (%s) that \"\n                            + \"does not share a signature with the supplying authenticator (%s).\";\n                    Log.e(TAG, String.format(tmpl, activityName, pkgName, mAccountType));\n                    return false;\n                }\n                intent.setComponent(targetActivityInfo.getComponentName());\n                bundle.putParcelable(AccountManager.KEY_INTENT, intent);\n                return true;\n            } finally {\n                Binder.restoreCallingIdentity(bid);\n            }\n        }\n\n        /**\n         * Simulate the client side's deserialization of KEY_INTENT value, to make sure they don't\n         * violate our security policy.\n         *\n         * In particular we want to make sure the Authenticator doesn't trick users\n         * into launching arbitrary intents on the device via exploiting any other Parcel read/write\n         * mismatch problems.\n         */\n        private boolean checkKeyIntentParceledCorrectly(Bundle bundle) {\n            Parcel p = Parcel.obtain();\n            p.writeBundle(bundle);\n            p.setDataPosition(0);\n            Bundle simulateBundle = p.readBundle();\n            p.recycle();\n            Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT);\n            if (intent != null && intent.getClass() != Intent.class) {\n                return false;\n            }\n            Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT);\n            if (intent == null) {\n                return (simulateIntent == null);\n            }\n            if (!intent.filterEquals(simulateIntent)) {\n                return false;\n            }\n\n            if (intent.getSelector() != simulateIntent.getSelector()) {\n                return false;\n            }\n\n            int prohibitedFlags = Intent.FLAG_GRANT_READ_URI_PERMISSION\n                    | Intent.FLAG_GRANT_WRITE_URI_PERMISSION\n                    | Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION\n                    | Intent.FLAG_GRANT_PREFIX_URI_PERMISSION;\n            return (simulateIntent.getFlags() & prohibitedFlags) == 0;\n        }\n\n        private boolean isExportedSystemActivity(ActivityInfo activityInfo) {\n            String className = activityInfo.name;\n            return \"android\".equals(activityInfo.packageName) &&\n                    (GrantCredentialsPermissionActivity.class.getName().equals(className)\n                    || CantAddAccountActivity.class.getName().equals(className));\n        }\n\n        private void close() {\n            synchronized (mSessions) {\n                if (mSessions.remove(toString()) == null) {\n                    // the session was already closed, so bail out now\n                    return;\n                }\n            }\n            if (mResponse != null) {\n                // stop listening for response deaths\n                mResponse.asBinder().unlinkToDeath(this, 0 /* flags */);\n\n                // clear this so that we don't accidentally send any further results\n                mResponse = null;\n            }\n            cancelTimeout();\n            unbind();\n        }\n\n        @Override\n        public void binderDied() {\n            mResponse = null;\n            close();\n        }\n\n        protected String toDebugString() {\n            return toDebugString(SystemClock.elapsedRealtime());\n        }\n\n        protected String toDebugString(long now) {\n            return \"Session: expectLaunch \" + mExpectActivityLaunch\n                    + \", connected \" + (mAuthenticator != null)\n                    + \", stats (\" + mNumResults + \"/\" + mNumRequestContinued\n                    + \"/\" + mNumErrors + \")\"\n                    + \", lifetime \" + ((now - mCreationTime) / 1000.0);\n        }\n\n        void bind() {\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"initiating bind to authenticator type \" + mAccountType);\n            }\n            if (!bindToAuthenticator(mAccountType)) {\n                Log.d(TAG, \"bind attempt failed for \" + toDebugString());\n                onError(AccountManager.ERROR_CODE_REMOTE_EXCEPTION, \"bind failure\");\n            }\n        }\n\n        private void unbind() {\n            if (mAuthenticator != null) {\n                mAuthenticator = null;\n                mContext.unbindService(this);\n            }\n        }\n\n        private void scheduleTimeout() {\n            mHandler.sendMessageDelayed(\n                    mHandler.obtainMessage(MESSAGE_TIMED_OUT, this), TIMEOUT_DELAY_MS);\n        }\n\n        public void cancelTimeout() {\n            mHandler.removeMessages(MESSAGE_TIMED_OUT, this);\n        }\n\n        @Override\n        public void onServiceConnected(ComponentName name, IBinder service) {\n            mAuthenticator = IAccountAuthenticator.Stub.asInterface(service);\n            try {\n                run();\n            } catch (RemoteException e) {\n                onError(AccountManager.ERROR_CODE_REMOTE_EXCEPTION,\n                        \"remote exception\");\n            }\n        }\n\n        @Override\n        public void onServiceDisconnected(ComponentName name) {\n            mAuthenticator = null;\n            IAccountManagerResponse response = getResponseAndClose();\n            if (response != null) {\n                try {\n                    response.onError(AccountManager.ERROR_CODE_REMOTE_EXCEPTION,\n                            \"disconnected\");\n                } catch (RemoteException e) {\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, \"Session.onServiceDisconnected: \"\n                                + \"caught RemoteException while responding\", e);\n                    }\n                }\n            }\n        }\n\n        public abstract void run() throws RemoteException;\n\n        public void onTimedOut() {\n            IAccountManagerResponse response = getResponseAndClose();\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"Session.onTimedOut\");\n            }\n            if (response != null) {\n                try {\n                    response.onError(AccountManager.ERROR_CODE_REMOTE_EXCEPTION,\n                            \"timeout\");\n                } catch (RemoteException e) {\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, \"Session.onTimedOut: caught RemoteException while responding\",\n                                e);\n                    }\n                }\n            }\n        }\n\n        @Override\n        public void onResult(Bundle result) {\n            Bundle.setDefusable(result, true);\n            mNumResults++;\n            Intent intent = null;\n            if (result != null) {\n                boolean isSuccessfulConfirmCreds = result.getBoolean(\n                        AccountManager.KEY_BOOLEAN_RESULT, false);\n                boolean isSuccessfulUpdateCredsOrAddAccount =\n                        result.containsKey(AccountManager.KEY_ACCOUNT_NAME)\n                        && result.containsKey(AccountManager.KEY_ACCOUNT_TYPE);\n                // We should only update lastAuthenticated time, if\n                // mUpdateLastAuthenticatedTime is true and the confirmRequest\n                // or updateRequest was successful\n                boolean needUpdate = mUpdateLastAuthenticatedTime\n                        && (isSuccessfulConfirmCreds || isSuccessfulUpdateCredsOrAddAccount);\n                if (needUpdate || mAuthDetailsRequired) {\n                    boolean accountPresent = isAccountPresentForCaller(mAccountName, mAccountType);\n                    if (needUpdate && accountPresent) {\n                        updateLastAuthenticatedTime(new Account(mAccountName, mAccountType));\n                    }\n                    if (mAuthDetailsRequired) {\n                        long lastAuthenticatedTime = -1;\n                        if (accountPresent) {\n                            lastAuthenticatedTime = mAccounts.accountsDb\n                                    .findAccountLastAuthenticatedTime(\n                                            new Account(mAccountName, mAccountType));\n                        }\n                        result.putLong(AccountManager.KEY_LAST_AUTHENTICATED_TIME,\n                                lastAuthenticatedTime);\n                    }\n                }\n            }\n            if (result != null) {\n                if (!checkKeyIntent(\n                        Binder.getCallingUid(),\n                        result)) {\n                    onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                            \"invalid intent in bundle returned\");\n                    return;\n                }\n            }\n            if (result != null\n                    && !TextUtils.isEmpty(result.getString(AccountManager.KEY_AUTHTOKEN))) {\n                String accountName = result.getString(AccountManager.KEY_ACCOUNT_NAME);\n                String accountType = result.getString(AccountManager.KEY_ACCOUNT_TYPE);\n                if (!TextUtils.isEmpty(accountName) && !TextUtils.isEmpty(accountType)) {\n                    Account account = new Account(accountName, accountType);\n                    cancelNotification(getSigninRequiredNotificationId(mAccounts, account),\n                            new UserHandle(mAccounts.userId));\n                }\n            }\n            IAccountManagerResponse response;\n            if (mExpectActivityLaunch && result != null\n                    && result.containsKey(AccountManager.KEY_INTENT)) {\n                response = mResponse;\n            } else {\n                response = getResponseAndClose();\n            }\n            if (response != null) {\n                try {\n                    if (result == null) {\n                        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                            Log.v(TAG, getClass().getSimpleName()\n                                    + \" calling onError() on response \" + response);\n                        }\n                        response.onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                                \"null bundle returned\");\n                    } else {\n                        if (mStripAuthTokenFromResult) {\n                            result.remove(AccountManager.KEY_AUTHTOKEN);\n                            if (!checkKeyIntent(Binder.getCallingUid(), result)) {\n                                onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                                        \"invalid intent in bundle returned\");\n                                return;\n                            }\n                        }\n                        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                            Log.v(TAG, getClass().getSimpleName()\n                                    + \" calling onResult() on response \" + response);\n                        }\n                        if ((result.getInt(AccountManager.KEY_ERROR_CODE, -1) > 0) &&\n                                (intent == null)) {\n                            // All AccountManager error codes are greater than 0\n                            response.onError(result.getInt(AccountManager.KEY_ERROR_CODE),\n                                    result.getString(AccountManager.KEY_ERROR_MESSAGE));\n                        } else {\n                            response.onResult(result);\n                        }\n                    }\n                } catch (RemoteException e) {\n                    // if the caller is dead then there is no one to care about remote exceptions\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, \"failure while notifying response\", e);\n                    }\n                }\n            }\n        }\n\n        @Override\n        public void onRequestContinued() {\n            mNumRequestContinued++;\n        }\n\n        @Override\n        public void onError(int errorCode, String errorMessage) {\n            mNumErrors++;\n            IAccountManagerResponse response = getResponseAndClose();\n            if (response != null) {\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.v(TAG, getClass().getSimpleName()\n                            + \" calling onError() on response \" + response);\n                }\n                try {\n                    response.onError(errorCode, errorMessage);\n                } catch (RemoteException e) {\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, \"Session.onError: caught RemoteException while responding\", e);\n                    }\n                }\n            } else {\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.v(TAG, \"Session.onError: already closed\");\n                }\n            }\n        }\n\n        /**\n         * find the component name for the authenticator and initiate a bind\n         * if no authenticator or the bind fails then return false, otherwise return true\n         */\n        private boolean bindToAuthenticator(String authenticatorType) {\n            final AccountAuthenticatorCache.ServiceInfo<AuthenticatorDescription> authenticatorInfo;\n            authenticatorInfo = mAuthenticatorCache.getServiceInfo(\n                    AuthenticatorDescription.newKey(authenticatorType), mAccounts.userId);\n            if (authenticatorInfo == null) {\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.v(TAG, \"there is no authenticator for \" + authenticatorType\n                            + \", bailing out\");\n                }\n                return false;\n            }\n\n            if (!isLocalUnlockedUser(mAccounts.userId)\n                    && !authenticatorInfo.componentInfo.directBootAware) {\n                Slog.w(TAG, \"Blocking binding to authenticator \" + authenticatorInfo.componentName\n                        + \" which isn't encryption aware\");\n                return false;\n            }\n\n            Intent intent = new Intent();\n            intent.setAction(AccountManager.ACTION_AUTHENTICATOR_INTENT);\n            intent.setComponent(authenticatorInfo.componentName);\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"performing bindService to \" + authenticatorInfo.componentName);\n            }\n            int flags = Context.BIND_AUTO_CREATE;\n            if (mAuthenticatorCache.getBindInstantServiceAllowed(mAccounts.userId)) {\n                flags |= Context.BIND_ALLOW_INSTANT;\n            }\n            if (!mContext.bindServiceAsUser(intent, this, flags, UserHandle.of(mAccounts.userId))) {\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.v(TAG, \"bindService to \" + authenticatorInfo.componentName + \" failed\");\n                }\n                return false;\n            }\n\n            return true;\n        }\n    }\n\n    class MessageHandler extends Handler {\n        MessageHandler(Looper looper) {\n            super(looper);\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MESSAGE_TIMED_OUT:\n                    Session session = (Session)msg.obj;\n                    session.onTimedOut();\n                    break;\n\n                case MESSAGE_COPY_SHARED_ACCOUNT:\n                    copyAccountToUser(/*no response*/ null, (Account) msg.obj, msg.arg1, msg.arg2);\n                    break;\n\n                default:\n                    throw new IllegalStateException(\"unhandled message: \" + msg.what);\n            }\n        }\n    }\n\n    private void logRecord(UserAccounts accounts, String action, String tableName) {\n        logRecord(action, tableName, -1, accounts);\n    }\n\n    private void logRecordWithUid(UserAccounts accounts, String action, String tableName, int uid) {\n        logRecord(action, tableName, -1, accounts, uid);\n    }\n\n    /*\n     * This function receives an opened writable database.\n     */\n    private void logRecord(String action, String tableName, long accountId,\n            UserAccounts userAccount) {\n        logRecord(action, tableName, accountId, userAccount, getCallingUid());\n    }\n\n    /*\n     * This function receives an opened writable database and writes to it in a separate thread.\n     */\n    private void logRecord(String action, String tableName, long accountId,\n            UserAccounts userAccount, int callingUid) {\n\n        class LogRecordTask implements Runnable {\n            private final String action;\n            private final String tableName;\n            private final long accountId;\n            private final UserAccounts userAccount;\n            private final int callingUid;\n            private final long userDebugDbInsertionPoint;\n\n            LogRecordTask(final String action,\n                    final String tableName,\n                    final long accountId,\n                    final UserAccounts userAccount,\n                    final int callingUid,\n                    final long userDebugDbInsertionPoint) {\n                this.action = action;\n                this.tableName = tableName;\n                this.accountId = accountId;\n                this.userAccount = userAccount;\n                this.callingUid = callingUid;\n                this.userDebugDbInsertionPoint = userDebugDbInsertionPoint;\n            }\n\n            @Override\n            public void run() {\n                synchronized (userAccount.accountsDb.mDebugStatementLock) {\n                    SQLiteStatement logStatement = userAccount.accountsDb.getStatementForLogging();\n                    if (logStatement == null) {\n                        return; // Can't log.\n                    }\n                    logStatement.bindLong(1, accountId);\n                    logStatement.bindString(2, action);\n                    logStatement.bindString(3, mDateFormat.format(new Date()));\n                    logStatement.bindLong(4, callingUid);\n                    logStatement.bindString(5, tableName);\n                    logStatement.bindLong(6, userDebugDbInsertionPoint);\n                    try {\n                        logStatement.execute();\n                    } catch (IllegalStateException e) {\n                        // Guard against crash, DB can already be closed\n                        // since this statement is executed on a handler thread\n                        Slog.w(TAG, \"Failed to insert a log record. accountId=\" + accountId\n                                + \" action=\" + action + \" tableName=\" + tableName + \" Error: \" + e);\n                    } finally {\n                        logStatement.clearBindings();\n                    }\n                }\n            }\n        }\n        long insertionPoint = userAccount.accountsDb.reserveDebugDbInsertionPoint();\n        if (insertionPoint != -1) {\n            LogRecordTask logTask = new LogRecordTask(action, tableName, accountId, userAccount,\n                    callingUid, insertionPoint);\n            mHandler.post(logTask);\n        }\n    }\n\n    public IBinder onBind(@SuppressWarnings(\"unused\") Intent intent) {\n        return asBinder();\n    }\n\n    /**\n     * Searches array of arguments for the specified string\n     * @param args array of argument strings\n     * @param value value to search for\n     * @return true if the value is contained in the array\n     */\n    private static boolean scanArgs(String[] args, String value) {\n        if (args != null) {\n            for (String arg : args) {\n                if (value.equals(arg)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    @Override\n    protected void dump(FileDescriptor fd, PrintWriter fout, String[] args) {\n        if (!DumpUtils.checkDumpPermission(mContext, TAG, fout)) return;\n        final boolean isCheckinRequest = scanArgs(args, \"--checkin\") || scanArgs(args, \"-c\");\n        final IndentingPrintWriter ipw = new IndentingPrintWriter(fout, \"  \");\n\n        final List<UserInfo> users = getUserManager().getUsers();\n        for (UserInfo user : users) {\n            ipw.println(\"User \" + user + \":\");\n            ipw.increaseIndent();\n            dumpUser(getUserAccounts(user.id), fd, ipw, args, isCheckinRequest);\n            ipw.println();\n            ipw.decreaseIndent();\n        }\n    }\n\n    private void dumpUser(UserAccounts userAccounts, FileDescriptor fd, PrintWriter fout,\n            String[] args, boolean isCheckinRequest) {\n        if (isCheckinRequest) {\n            // This is a checkin request. *Only* upload the account types and the count of\n            // each.\n            synchronized (userAccounts.dbLock) {\n                userAccounts.accountsDb.dumpDeAccountsTable(fout);\n            }\n        } else {\n            Account[] accounts = getAccountsFromCache(userAccounts, null /* type */,\n                    Process.SYSTEM_UID, null /* packageName */, false);\n            fout.println(\"Accounts: \" + accounts.length);\n            for (Account account : accounts) {\n                fout.println(\"  \" + account.toString());\n            }\n\n            // Add debug information.\n            fout.println();\n            synchronized (userAccounts.dbLock) {\n                userAccounts.accountsDb.dumpDebugTable(fout);\n            }\n            fout.println();\n            synchronized (mSessions) {\n                final long now = SystemClock.elapsedRealtime();\n                fout.println(\"Active Sessions: \" + mSessions.size());\n                for (Session session : mSessions.values()) {\n                    fout.println(\"  \" + session.toDebugString(now));\n                }\n            }\n\n            fout.println();\n            mAuthenticatorCache.dump(fd, fout, args, userAccounts.userId);\n\n            boolean isUserUnlocked;\n            synchronized (mUsers) {\n                isUserUnlocked = isLocalUnlockedUser(userAccounts.userId);\n            }\n            // Following logs are printed only when user is unlocked.\n            if (!isUserUnlocked) {\n                return;\n            }\n            fout.println();\n            synchronized (userAccounts.dbLock) {\n                Map<Account, Map<String, Integer>> allVisibilityValues =\n                        userAccounts.accountsDb.findAllVisibilityValues();\n                fout.println(\"Account visibility:\");\n                for (Account account : allVisibilityValues.keySet()) {\n                    fout.println(\"  \" + account.name);\n                    Map<String, Integer> visibilities = allVisibilityValues.get(account);\n                    for (Entry<String, Integer> entry : visibilities.entrySet()) {\n                        fout.println(\"    \" + entry.getKey() + \", \" + entry.getValue());\n                    }\n                }\n            }\n        }\n    }\n\n    private void doNotification(UserAccounts accounts, Account account, CharSequence message,\n            Intent intent, String packageName, final int userId) {\n        final long identityToken = clearCallingIdentity();\n        try {\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"doNotification: \" + message + \" intent:\" + intent);\n            }\n\n            if (intent.getComponent() != null &&\n                    GrantCredentialsPermissionActivity.class.getName().equals(\n                            intent.getComponent().getClassName())) {\n                createNoCredentialsPermissionNotification(account, intent, packageName, userId);\n            } else {\n                Context contextForUser = getContextForUser(new UserHandle(userId));\n                final NotificationId id = getSigninRequiredNotificationId(accounts, account);\n                intent.addCategory(id.mTag);\n\n                final String notificationTitleFormat =\n                        contextForUser.getText(R.string.notification_title).toString();\n                Notification n =\n                        new Notification.Builder(contextForUser, SystemNotificationChannels.ACCOUNT)\n                        .setWhen(0)\n                        .setSmallIcon(android.R.drawable.stat_sys_warning)\n                        .setColor(contextForUser.getColor(\n                                com.android.internal.R.color.system_notification_accent_color))\n                        .setContentTitle(String.format(notificationTitleFormat, account.name))\n                        .setContentText(message)\n                        .setContentIntent(PendingIntent.getActivityAsUser(\n                                mContext, 0, intent,\n                                PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_IMMUTABLE,\n                                null, new UserHandle(userId)))\n                        .build();\n                installNotification(id, n, packageName, userId);\n            }\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private void installNotification(NotificationId id, final Notification notification,\n            String packageName, int userId) {\n        final long token = clearCallingIdentity();\n        try {\n            INotificationManager notificationManager = mInjector.getNotificationManager();\n            try {\n                // The calling uid must match either the package or op package, so use an op\n                // package that matches the cleared calling identity.\n                notificationManager.enqueueNotificationWithTag(packageName, \"android\",\n                        id.mTag, id.mId, notification, userId);\n            } catch (RemoteException e) {\n                /* ignore - local call */\n            }\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private void cancelNotification(NotificationId id, UserHandle user) {\n        cancelNotification(id, mContext.getPackageName(), user);\n    }\n\n    private void cancelNotification(NotificationId id, String packageName, UserHandle user) {\n        final long identityToken = clearCallingIdentity();\n        try {\n            INotificationManager service = mInjector.getNotificationManager();\n            service.cancelNotificationWithTag(\n                    packageName, \"android\", id.mTag, id.mId, user.getIdentifier());\n        } catch (RemoteException e) {\n            /* ignore - local call */\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private boolean isPermittedForPackage(String packageName, int userId, String... permissions) {\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            final int uid = mPackageManager.getPackageUidAsUser(packageName, userId);\n            IPackageManager pm = ActivityThread.getPackageManager();\n            for (String perm : permissions) {\n                if (pm.checkPermission(perm, packageName, userId)\n                        == PackageManager.PERMISSION_GRANTED) {\n                    // Checks runtime permission revocation.\n                    final int opCode = AppOpsManager.permissionToOpCode(perm);\n                    if (opCode == AppOpsManager.OP_NONE || mAppOpsManager.checkOpNoThrow(\n                            opCode, uid, packageName) == AppOpsManager.MODE_ALLOWED) {\n                        return true;\n                    }\n                }\n            }\n        } catch (NameNotFoundException | RemoteException e) {\n            // Assume permission is not granted if an error accrued.\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n        return false;\n    }\n\n    /**\n     * Checks that package has at least one of given permissions and makes note of app\n     * performing the action.\n     */\n    private boolean checkPermissionAndNote(String opPackageName, int callingUid,\n            String... permissions) {\n        for (String perm : permissions) {\n            if (mContext.checkCallingOrSelfPermission(perm) == PackageManager.PERMISSION_GRANTED) {\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.v(TAG, \"  caller uid \" + callingUid + \" has \" + perm);\n                }\n                final int opCode = AppOpsManager.permissionToOpCode(perm);\n                if (opCode == AppOpsManager.OP_NONE || mAppOpsManager.noteOpNoThrow(\n                        opCode, callingUid, opPackageName) == AppOpsManager.MODE_ALLOWED) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private int handleIncomingUser(int userId) {\n        try {\n            return ActivityManager.getService().handleIncomingUser(\n                    Binder.getCallingPid(), Binder.getCallingUid(), userId, true, true, \"\", null);\n        } catch (RemoteException re) {\n            // Shouldn't happen, local.\n        }\n        return userId;\n    }\n\n    private boolean isPrivileged(int callingUid) {\n        String[] packages;\n        final long identityToken = Binder.clearCallingIdentity();\n        try {\n            packages = mPackageManager.getPackagesForUid(callingUid);\n            if (packages == null) {\n                Log.d(TAG, \"No packages for callingUid \" + callingUid);\n                return false;\n            }\n            for (String name : packages) {\n                try {\n                    PackageInfo packageInfo =\n                        mPackageManager.getPackageInfo(name, 0 /* flags */);\n                    if (packageInfo != null\n                        && (packageInfo.applicationInfo.privateFlags\n                            & ApplicationInfo.PRIVATE_FLAG_PRIVILEGED) != 0) {\n                        return true;\n                    }\n                } catch (PackageManager.NameNotFoundException e) {\n                    Log.d(TAG, \"Package not found \" + e.getMessage());\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identityToken);\n        }\n        return false;\n    }\n\n    private boolean permissionIsGranted(\n            Account account, String authTokenType, int callerUid, int userId) {\n        if (UserHandle.getAppId(callerUid) == Process.SYSTEM_UID) {\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"Access to \" + account + \" granted calling uid is system\");\n            }\n            return true;\n        }\n\n        if (isPrivileged(callerUid)) {\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"Access to \" + account + \" granted calling uid \"\n                        + callerUid + \" privileged\");\n            }\n            return true;\n        }\n        if (account != null && isAccountManagedByCaller(account.type, callerUid, userId)) {\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"Access to \" + account + \" granted calling uid \"\n                        + callerUid + \" manages the account\");\n            }\n            return true;\n        }\n        if (account != null && hasExplicitlyGrantedPermission(account, authTokenType, callerUid)) {\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"Access to \" + account + \" granted calling uid \"\n                        + callerUid + \" user granted access\");\n            }\n            return true;\n        }\n\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"Access to \" + account + \" not granted for uid \" + callerUid);\n        }\n\n        return false;\n    }\n\n    private boolean isAccountVisibleToCaller(String accountType, int callingUid, int userId,\n            String opPackageName) {\n        if (accountType == null) {\n            return false;\n        } else {\n            return getTypesVisibleToCaller(callingUid, userId,\n                    opPackageName).contains(accountType);\n        }\n    }\n\n    // Method checks visibility for applications targeing API level below {@link\n    // android.os.Build.VERSION_CODES#O},\n    // returns true if the the app has GET_ACCOUNTS or GET_ACCOUNTS_PRIVILEGED permission.\n    private boolean checkGetAccountsPermission(String packageName, int userId) {\n        return isPermittedForPackage(packageName, userId, Manifest.permission.GET_ACCOUNTS,\n                Manifest.permission.GET_ACCOUNTS_PRIVILEGED);\n    }\n\n    private boolean checkReadContactsPermission(String packageName, int userId) {\n        return isPermittedForPackage(packageName, userId, Manifest.permission.READ_CONTACTS);\n    }\n\n    // Heuristic to check that account type may be associated with some contacts data and\n    // therefore READ_CONTACTS permission grants the access to account by default.\n    private boolean accountTypeManagesContacts(String accountType, int userId) {\n        if (accountType == null) {\n            return false;\n        }\n        final long identityToken = Binder.clearCallingIdentity();\n        Collection<RegisteredServicesCache.ServiceInfo<AuthenticatorDescription>> serviceInfos;\n        try {\n            serviceInfos = mAuthenticatorCache.getAllServices(userId);\n        } finally {\n            Binder.restoreCallingIdentity(identityToken);\n        }\n        // Check contacts related permissions for authenticator.\n        for (RegisteredServicesCache.ServiceInfo<AuthenticatorDescription> serviceInfo\n                : serviceInfos) {\n            if (accountType.equals(serviceInfo.type.type)) {\n                return isPermittedForPackage(serviceInfo.type.packageName, userId,\n                    Manifest.permission.WRITE_CONTACTS);\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Method checks package uid and signature with Authenticator which manages accountType.\n     *\n     * @return SIGNATURE_CHECK_UID_MATCH for uid match, SIGNATURE_CHECK_MATCH for signature match,\n     *         SIGNATURE_CHECK_MISMATCH otherwise.\n     */\n    private int checkPackageSignature(String accountType, int callingUid, int userId) {\n        if (accountType == null) {\n            return SIGNATURE_CHECK_MISMATCH;\n        }\n\n        final long identityToken = Binder.clearCallingIdentity();\n        Collection<RegisteredServicesCache.ServiceInfo<AuthenticatorDescription>> serviceInfos;\n        try {\n            serviceInfos = mAuthenticatorCache.getAllServices(userId);\n        } finally {\n            Binder.restoreCallingIdentity(identityToken);\n        }\n        // Check for signature match with Authenticator.LocalServices.getService(PackageManagerInternal.class);\n        PackageManagerInternal pmi = LocalServices.getService(PackageManagerInternal.class);\n        for (RegisteredServicesCache.ServiceInfo<AuthenticatorDescription> serviceInfo\n                : serviceInfos) {\n            if (accountType.equals(serviceInfo.type.type)) {\n                if (serviceInfo.uid == callingUid) {\n                    return SIGNATURE_CHECK_UID_MATCH;\n                }\n                if (pmi.hasSignatureCapability(\n                        serviceInfo.uid, callingUid,\n                        PackageParser.SigningDetails.CertCapabilities.AUTH)) {\n                    return SIGNATURE_CHECK_MATCH;\n                }\n            }\n        }\n        return SIGNATURE_CHECK_MISMATCH;\n    }\n\n    // returns true for applications with the same signature as authenticator.\n    private boolean isAccountManagedByCaller(String accountType, int callingUid, int userId) {\n        if (accountType == null) {\n            return false;\n        } else {\n            return getTypesManagedByCaller(callingUid, userId).contains(accountType);\n        }\n    }\n\n    private List<String> getTypesVisibleToCaller(int callingUid, int userId,\n            String opPackageName) {\n        return getTypesForCaller(callingUid, userId, true /* isOtherwisePermitted*/);\n    }\n\n    private List<String> getTypesManagedByCaller(int callingUid, int userId) {\n        return getTypesForCaller(callingUid, userId, false);\n    }\n\n    private List<String> getTypesForCaller(\n            int callingUid, int userId, boolean isOtherwisePermitted) {\n        List<String> managedAccountTypes = new ArrayList<>();\n        final long identityToken = Binder.clearCallingIdentity();\n        Collection<RegisteredServicesCache.ServiceInfo<AuthenticatorDescription>> serviceInfos;\n        try {\n            serviceInfos = mAuthenticatorCache.getAllServices(userId);\n        } finally {\n            Binder.restoreCallingIdentity(identityToken);\n        }\n\n        PackageManagerInternal pmi = LocalServices.getService(PackageManagerInternal.class);\n        for (RegisteredServicesCache.ServiceInfo<AuthenticatorDescription> serviceInfo :\n                serviceInfos) {\n            if (isOtherwisePermitted || pmi.hasSignatureCapability(\n                    serviceInfo.uid, callingUid,\n                    PackageParser.SigningDetails.CertCapabilities.AUTH)) {\n                managedAccountTypes.add(serviceInfo.type.type);\n            }\n        }\n        return managedAccountTypes;\n    }\n\n    private boolean isAccountPresentForCaller(String accountName, String accountType) {\n        if (getUserAccountsForCaller().accountCache.containsKey(accountType)) {\n            for (Account account : getUserAccountsForCaller().accountCache.get(accountType)) {\n                if (account.name.equals(accountName)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private static void checkManageUsersPermission(String message) {\n        if (ActivityManager.checkComponentPermission(\n                android.Manifest.permission.MANAGE_USERS, Binder.getCallingUid(), -1, true)\n                != PackageManager.PERMISSION_GRANTED) {\n            throw new SecurityException(\"You need MANAGE_USERS permission to: \" + message);\n        }\n    }\n\n    private static void checkManageOrCreateUsersPermission(String message) {\n        if (ActivityManager.checkComponentPermission(android.Manifest.permission.MANAGE_USERS,\n                Binder.getCallingUid(), -1, true) != PackageManager.PERMISSION_GRANTED &&\n                ActivityManager.checkComponentPermission(android.Manifest.permission.CREATE_USERS,\n                        Binder.getCallingUid(), -1, true) != PackageManager.PERMISSION_GRANTED) {\n            throw new SecurityException(\"You need MANAGE_USERS or CREATE_USERS permission to: \"\n                    + message);\n        }\n    }\n\n    private boolean hasExplicitlyGrantedPermission(Account account, String authTokenType,\n            int callerUid) {\n        if (UserHandle.getAppId(callerUid) == Process.SYSTEM_UID) {\n            return true;\n        }\n        UserAccounts accounts = getUserAccounts(UserHandle.getUserId(callerUid));\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                long grantsCount;\n                if (authTokenType != null) {\n                    grantsCount = accounts.accountsDb\n                            .findMatchingGrantsCount(callerUid, authTokenType, account);\n                } else {\n                    grantsCount = accounts.accountsDb.findMatchingGrantsCountAnyToken(callerUid,\n                            account);\n                }\n                final boolean permissionGranted = grantsCount > 0;\n\n                if (!permissionGranted && ActivityManager.isRunningInTestHarness()) {\n                    // TODO: Skip this check when running automated tests. Replace this\n                    // with a more general solution.\n                    Log.d(TAG, \"no credentials permission for usage of \"\n                            + account.toSafeString() + \", \"\n                            + authTokenType + \" by uid \" + callerUid\n                            + \" but ignoring since device is in test harness.\");\n                    return true;\n                }\n                return permissionGranted;\n            }\n        }\n    }\n\n    private boolean isSystemUid(int callingUid) {\n        String[] packages = null;\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            packages = mPackageManager.getPackagesForUid(callingUid);\n            if (packages != null) {\n                for (String name : packages) {\n                    try {\n                        PackageInfo packageInfo =\n                                mPackageManager.getPackageInfo(name, 0 /* flags */);\n                        if (packageInfo != null\n                                && (packageInfo.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM)\n                                != 0) {\n                            return true;\n                        }\n                    } catch (NameNotFoundException e) {\n                        Log.w(TAG, String.format(\"Could not find package [%s]\", name), e);\n                    }\n                }\n            } else {\n                Log.w(TAG, \"No known packages with uid \" + callingUid);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n        return false;\n    }\n\n    /** Succeeds if any of the specified permissions are granted. */\n    private void checkReadAccountsPermitted(\n            int callingUid,\n            String accountType,\n            int userId,\n            String opPackageName) {\n        if (!isAccountVisibleToCaller(accountType, callingUid, userId, opPackageName)) {\n            String msg = String.format(\n                    \"caller uid %s cannot access %s accounts\",\n                    callingUid,\n                    accountType);\n            Log.w(TAG, \"  \" + msg);\n            throw new SecurityException(msg);\n        }\n    }\n\n    private boolean canUserModifyAccounts(int userId, int callingUid) {\n        // the managing app can always modify accounts\n        if (isProfileOwner(callingUid)) {\n            return true;\n        }\n        if (getUserManager().getUserRestrictions(new UserHandle(userId))\n                .getBoolean(UserManager.DISALLOW_MODIFY_ACCOUNTS)) {\n            return false;\n        }\n        return true;\n    }\n\n    private boolean canUserModifyAccountsForType(int userId, String accountType, int callingUid) {\n        // the managing app can always modify accounts\n        if (isProfileOwner(callingUid)) {\n            return true;\n        }\n        DevicePolicyManager dpm = (DevicePolicyManager) mContext\n                .getSystemService(Context.DEVICE_POLICY_SERVICE);\n        String[] typesArray = dpm.getAccountTypesWithManagementDisabledAsUser(userId);\n        if (typesArray == null) {\n            return true;\n        }\n        for (String forbiddenType : typesArray) {\n            if (forbiddenType.equals(accountType)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private boolean isProfileOwner(int uid) {\n        final DevicePolicyManagerInternal dpmi =\n                LocalServices.getService(DevicePolicyManagerInternal.class);\n        //TODO(b/169395065) Figure out if this flow makes sense in Device Owner mode.\n        return (dpmi != null) && (dpmi.isActiveProfileOwner(uid) || dpmi.isActiveDeviceOwner(uid));\n    }\n\n    @Override\n    public void updateAppPermission(Account account, String authTokenType, int uid, boolean value)\n            throws RemoteException {\n        final int callingUid = getCallingUid();\n\n        if (UserHandle.getAppId(callingUid) != Process.SYSTEM_UID) {\n            throw new SecurityException();\n        }\n\n        if (value) {\n            grantAppPermission(account, authTokenType, uid);\n        } else {\n            revokeAppPermission(account, authTokenType, uid);\n        }\n    }\n\n    /**\n     * Allow callers with the given uid permission to get credentials for account/authTokenType.\n     * <p>\n     * Although this is public it can only be accessed via the AccountManagerService object\n     * which is in the system. This means we don't need to protect it with permissions.\n     * @hide\n     */\n    void grantAppPermission(Account account, String authTokenType, int uid) {\n        if (account == null || authTokenType == null) {\n            Log.e(TAG, \"grantAppPermission: called with invalid arguments\", new Exception());\n            return;\n        }\n        UserAccounts accounts = getUserAccounts(UserHandle.getUserId(uid));\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                long accountId = accounts.accountsDb.findDeAccountId(account);\n                if (accountId >= 0) {\n                    accounts.accountsDb.insertGrant(accountId, authTokenType, uid);\n                }\n                cancelNotification(\n                        getCredentialPermissionNotificationId(account, authTokenType, uid),\n                        UserHandle.of(accounts.userId));\n\n                cancelAccountAccessRequestNotificationIfNeeded(account, uid, true);\n            }\n        }\n\n        // Listeners are a final CopyOnWriteArrayList, hence no lock needed.\n        for (AccountManagerInternal.OnAppPermissionChangeListener listener\n                : mAppPermissionChangeListeners) {\n            mHandler.post(() -> listener.onAppPermissionChanged(account, uid));\n        }\n    }\n\n    /**\n     * Don't allow callers with the given uid permission to get credentials for\n     * account/authTokenType.\n     * <p>\n     * Although this is public it can only be accessed via the AccountManagerService object\n     * which is in the system. This means we don't need to protect it with permissions.\n     * @hide\n     */\n    private void revokeAppPermission(Account account, String authTokenType, int uid) {\n        if (account == null || authTokenType == null) {\n            Log.e(TAG, \"revokeAppPermission: called with invalid arguments\", new Exception());\n            return;\n        }\n        UserAccounts accounts = getUserAccounts(UserHandle.getUserId(uid));\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                accounts.accountsDb.beginTransaction();\n                try {\n                    long accountId = accounts.accountsDb.findDeAccountId(account);\n                    if (accountId >= 0) {\n                        accounts.accountsDb.deleteGrantsByAccountIdAuthTokenTypeAndUid(\n                                accountId, authTokenType, uid);\n                        accounts.accountsDb.setTransactionSuccessful();\n                    }\n                } finally {\n                    accounts.accountsDb.endTransaction();\n                }\n\n                cancelNotification(\n                        getCredentialPermissionNotificationId(account, authTokenType, uid),\n                        UserHandle.of(accounts.userId));\n            }\n        }\n\n        // Listeners are a final CopyOnWriteArrayList, hence no lock needed.\n        for (AccountManagerInternal.OnAppPermissionChangeListener listener\n                : mAppPermissionChangeListeners) {\n            mHandler.post(() -> listener.onAppPermissionChanged(account, uid));\n        }\n    }\n\n    private void removeAccountFromCacheLocked(UserAccounts accounts, Account account) {\n        final Account[] oldAccountsForType = accounts.accountCache.get(account.type);\n        if (oldAccountsForType != null) {\n            ArrayList<Account> newAccountsList = new ArrayList<>();\n            for (Account curAccount : oldAccountsForType) {\n                if (!curAccount.equals(account)) {\n                    newAccountsList.add(curAccount);\n                }\n            }\n            if (newAccountsList.isEmpty()) {\n                accounts.accountCache.remove(account.type);\n            } else {\n                Account[] newAccountsForType = new Account[newAccountsList.size()];\n                newAccountsForType = newAccountsList.toArray(newAccountsForType);\n                accounts.accountCache.put(account.type, newAccountsForType);\n            }\n        }\n        accounts.userDataCache.remove(account);\n        accounts.authTokenCache.remove(account);\n        accounts.previousNameCache.remove(account);\n        accounts.visibilityCache.remove(account);\n\n        AccountManager.invalidateLocalAccountsDataCaches();\n    }\n\n    /**\n     * This assumes that the caller has already checked that the account is not already present.\n     * IMPORTANT: The account being inserted will begin to be tracked for access in remote\n     * processes and if you will return this account to apps you should return the result.\n     * @return The inserted account which is a new instance that is being tracked.\n     */\n    private Account insertAccountIntoCacheLocked(UserAccounts accounts, Account account) {\n        Account[] accountsForType = accounts.accountCache.get(account.type);\n        int oldLength = (accountsForType != null) ? accountsForType.length : 0;\n        Account[] newAccountsForType = new Account[oldLength + 1];\n        if (accountsForType != null) {\n            System.arraycopy(accountsForType, 0, newAccountsForType, 0, oldLength);\n        }\n        String token = account.getAccessId() != null ? account.getAccessId()\n                : UUID.randomUUID().toString();\n        newAccountsForType[oldLength] = new Account(account, token);\n        accounts.accountCache.put(account.type, newAccountsForType);\n        AccountManager.invalidateLocalAccountsDataCaches();\n        return newAccountsForType[oldLength];\n    }\n\n    @NonNull\n    private Account[] filterAccounts(UserAccounts accounts, Account[] unfiltered, int callingUid,\n            @Nullable String callingPackage, boolean includeManagedNotVisible) {\n        String visibilityFilterPackage = callingPackage;\n        if (visibilityFilterPackage == null) {\n            visibilityFilterPackage = getPackageNameForUid(callingUid);\n        }\n        Map<Account, Integer> firstPass = new LinkedHashMap<>();\n        for (Account account : unfiltered) {\n            int visibility = resolveAccountVisibility(account, visibilityFilterPackage, accounts);\n            if ((visibility == AccountManager.VISIBILITY_VISIBLE\n                    || visibility == AccountManager.VISIBILITY_USER_MANAGED_VISIBLE)\n                    || (includeManagedNotVisible\n                            && (visibility\n                                    == AccountManager.VISIBILITY_USER_MANAGED_NOT_VISIBLE))) {\n                firstPass.put(account, visibility);\n            }\n        }\n        Map<Account, Integer> secondPass =\n                filterSharedAccounts(accounts, firstPass, callingUid, callingPackage);\n\n        Account[] filtered = new Account[secondPass.size()];\n        filtered = secondPass.keySet().toArray(filtered);\n        return filtered;\n    }\n\n    @NonNull\n    private Map<Account, Integer> filterSharedAccounts(UserAccounts userAccounts,\n            @NonNull Map<Account, Integer> unfiltered, int callingUid,\n            @Nullable String callingPackage) {\n        // first part is to filter shared accounts.\n        // unfiltered type check is not necessary.\n        if (getUserManager() == null || userAccounts == null || userAccounts.userId < 0\n                || callingUid == Process.SYSTEM_UID) {\n            return unfiltered;\n        }\n        UserInfo user = getUserManager().getUserInfo(userAccounts.userId);\n        if (user != null && user.isRestricted()) {\n            String[] packages = mPackageManager.getPackagesForUid(callingUid);\n            if (packages == null) {\n                packages = new String[] {};\n            }\n            // If any of the packages is a visible listed package, return the full set,\n            // otherwise return non-shared accounts only.\n            // This might be a temporary way to specify a visible list\n            String visibleList = mContext.getResources().getString(\n                    com.android.internal.R.string.config_appsAuthorizedForSharedAccounts);\n            for (String packageName : packages) {\n                if (visibleList.contains(\";\" + packageName + \";\")) {\n                    return unfiltered;\n                }\n            }\n            Account[] sharedAccounts = getSharedAccountsAsUser(userAccounts.userId);\n            if (ArrayUtils.isEmpty(sharedAccounts)) {\n                return unfiltered;\n            }\n            String requiredAccountType = \"\";\n            try {\n                // If there's an explicit callingPackage specified, check if that package\n                // opted in to see restricted accounts.\n                if (callingPackage != null) {\n                    PackageInfo pi = mPackageManager.getPackageInfo(callingPackage, 0);\n                    if (pi != null && pi.restrictedAccountType != null) {\n                        requiredAccountType = pi.restrictedAccountType;\n                    }\n                } else {\n                    // Otherwise check if the callingUid has a package that has opted in\n                    for (String packageName : packages) {\n                        PackageInfo pi = mPackageManager.getPackageInfo(packageName, 0);\n                        if (pi != null && pi.restrictedAccountType != null) {\n                            requiredAccountType = pi.restrictedAccountType;\n                            break;\n                        }\n                    }\n                }\n            } catch (NameNotFoundException e) {\n                Log.d(TAG, \"Package not found \" + e.getMessage());\n            }\n            Map<Account, Integer> filtered = new LinkedHashMap<>();\n            for (Map.Entry<Account, Integer> entry : unfiltered.entrySet()) {\n                Account account = entry.getKey();\n                if (account.type.equals(requiredAccountType)) {\n                    filtered.put(account, entry.getValue());\n                } else {\n                    boolean found = false;\n                    for (Account shared : sharedAccounts) {\n                        if (shared.equals(account)) {\n                            found = true;\n                            break;\n                        }\n                    }\n                    if (!found) {\n                        filtered.put(account, entry.getValue());\n                    }\n                }\n            }\n            return filtered;\n        } else {\n            return unfiltered;\n        }\n    }\n\n    /*\n     * packageName can be null. If not null, it should be used to filter out restricted accounts\n     * that the package is not allowed to access.\n     *\n     * <p>The method shouldn't be called with UserAccounts#cacheLock held, otherwise it will cause a\n     * deadlock\n     */\n    @NonNull\n    protected Account[] getAccountsFromCache(UserAccounts userAccounts, String accountType,\n            int callingUid, @Nullable String callingPackage, boolean includeManagedNotVisible) {\n        Preconditions.checkState(!Thread.holdsLock(userAccounts.cacheLock),\n                \"Method should not be called with cacheLock\");\n        if (accountType != null) {\n            Account[] accounts;\n            synchronized (userAccounts.cacheLock) {\n                accounts = userAccounts.accountCache.get(accountType);\n            }\n            if (accounts == null) {\n                return EMPTY_ACCOUNT_ARRAY;\n            } else {\n                return filterAccounts(userAccounts, Arrays.copyOf(accounts, accounts.length),\n                        callingUid, callingPackage, includeManagedNotVisible);\n            }\n        } else {\n            int totalLength = 0;\n            Account[] accountsArray;\n            synchronized (userAccounts.cacheLock) {\n                for (Account[] accounts : userAccounts.accountCache.values()) {\n                    totalLength += accounts.length;\n                }\n                if (totalLength == 0) {\n                    return EMPTY_ACCOUNT_ARRAY;\n                }\n                accountsArray = new Account[totalLength];\n                totalLength = 0;\n                for (Account[] accountsOfType : userAccounts.accountCache.values()) {\n                    System.arraycopy(accountsOfType, 0, accountsArray, totalLength,\n                            accountsOfType.length);\n                    totalLength += accountsOfType.length;\n                }\n            }\n            return filterAccounts(userAccounts, accountsArray, callingUid, callingPackage,\n                    includeManagedNotVisible);\n        }\n    }\n\n    /** protected by the {@code dbLock}, {@code cacheLock} */\n    protected void writeUserDataIntoCacheLocked(UserAccounts accounts,\n            Account account, String key, String value) {\n        Map<String, String> userDataForAccount = accounts.userDataCache.get(account);\n        if (userDataForAccount == null) {\n            userDataForAccount = accounts.accountsDb.findUserExtrasForAccount(account);\n            accounts.userDataCache.put(account, userDataForAccount);\n        }\n        if (value == null) {\n            userDataForAccount.remove(key);\n        } else {\n            userDataForAccount.put(key, value);\n        }\n    }\n\n    protected String readCachedTokenInternal(\n            UserAccounts accounts,\n            Account account,\n            String tokenType,\n            String callingPackage,\n            byte[] pkgSigDigest) {\n        synchronized (accounts.cacheLock) {\n            return accounts.accountTokenCaches.get(\n                    account, tokenType, callingPackage, pkgSigDigest);\n        }\n    }\n\n    /** protected by the {@code dbLock}, {@code cacheLock} */\n    protected void writeAuthTokenIntoCacheLocked(UserAccounts accounts,\n            Account account, String key, String value) {\n        Map<String, String> authTokensForAccount = accounts.authTokenCache.get(account);\n        if (authTokensForAccount == null) {\n            authTokensForAccount = accounts.accountsDb.findAuthTokensByAccount(account);\n            accounts.authTokenCache.put(account, authTokensForAccount);\n        }\n        if (value == null) {\n            authTokensForAccount.remove(key);\n        } else {\n            authTokensForAccount.put(key, value);\n        }\n    }\n\n    protected String readAuthTokenInternal(UserAccounts accounts, Account account,\n            String authTokenType) {\n        // Fast path - check if account is already cached\n        synchronized (accounts.cacheLock) {\n            Map<String, String> authTokensForAccount = accounts.authTokenCache.get(account);\n            if (authTokensForAccount != null) {\n                return authTokensForAccount.get(authTokenType);\n            }\n        }\n        // If not cached yet - do slow path and sync with db if necessary\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                Map<String, String> authTokensForAccount = accounts.authTokenCache.get(account);\n                if (authTokensForAccount == null) {\n                    // need to populate the cache for this account\n                    authTokensForAccount = accounts.accountsDb.findAuthTokensByAccount(account);\n                    accounts.authTokenCache.put(account, authTokensForAccount);\n                }\n                return authTokensForAccount.get(authTokenType);\n            }\n        }\n    }\n\n    private String readUserDataInternal(UserAccounts accounts, Account account, String key) {\n        Map<String, String> userDataForAccount;\n        // Fast path - check if data is already cached\n        synchronized (accounts.cacheLock) {\n            userDataForAccount = accounts.userDataCache.get(account);\n        }\n        // If not cached yet - do slow path and sync with db if necessary\n        if (userDataForAccount == null) {\n            synchronized (accounts.dbLock) {\n                synchronized (accounts.cacheLock) {\n                    userDataForAccount = accounts.userDataCache.get(account);\n                    if (userDataForAccount == null) {\n                        // need to populate the cache for this account\n                        userDataForAccount = accounts.accountsDb.findUserExtrasForAccount(account);\n                        accounts.userDataCache.put(account, userDataForAccount);\n                    }\n                }\n            }\n        }\n        return userDataForAccount.get(key);\n    }\n\n    private Context getContextForUser(UserHandle user) {\n        try {\n            return mContext.createPackageContextAsUser(mContext.getPackageName(), 0, user);\n        } catch (NameNotFoundException e) {\n            // Default to mContext, not finding the package system is running as is unlikely.\n            return mContext;\n        }\n    }\n\n    private void sendResponse(IAccountManagerResponse response, Bundle result) {\n        try {\n            response.onResult(result);\n        } catch (RemoteException e) {\n            // if the caller is dead then there is no one to care about remote\n            // exceptions\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"failure while notifying response\", e);\n            }\n        }\n    }\n\n    private void sendErrorResponse(IAccountManagerResponse response, int errorCode,\n            String errorMessage) {\n        try {\n            response.onError(errorCode, errorMessage);\n        } catch (RemoteException e) {\n            // if the caller is dead then there is no one to care about remote\n            // exceptions\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"failure while notifying response\", e);\n            }\n        }\n    }\n\n    private final class AccountManagerInternalImpl extends AccountManagerInternal {\n        private final Object mLock = new Object();\n\n        @GuardedBy(\"mLock\")\n        private AccountManagerBackupHelper mBackupHelper;\n\n        @Override\n        public void requestAccountAccess(@NonNull Account account, @NonNull String packageName,\n                @IntRange(from = 0) int userId, @NonNull RemoteCallback callback) {\n            if (account == null) {\n                Slog.w(TAG, \"account cannot be null\");\n                return;\n            }\n            if (packageName == null) {\n                Slog.w(TAG, \"packageName cannot be null\");\n                return;\n            }\n            if (userId < UserHandle.USER_SYSTEM) {\n                Slog.w(TAG, \"user id must be concrete\");\n                return;\n            }\n            if (callback == null) {\n                Slog.w(TAG, \"callback cannot be null\");\n                return;\n            }\n\n            int visibility =\n                resolveAccountVisibility(account, packageName, getUserAccounts(userId));\n            if (visibility == AccountManager.VISIBILITY_NOT_VISIBLE) {\n                Slog.w(TAG, \"requestAccountAccess: account is hidden\");\n                return;\n            }\n\n            if (AccountManagerService.this.hasAccountAccess(account, packageName,\n                    new UserHandle(userId))) {\n                Bundle result = new Bundle();\n                result.putBoolean(AccountManager.KEY_BOOLEAN_RESULT, true);\n                callback.sendResult(result);\n                return;\n            }\n\n            final int uid;\n            try {\n                final long identityToken = clearCallingIdentity();\n                try {\n                    uid = mPackageManager.getPackageUidAsUser(packageName, userId);\n                } finally {\n                    restoreCallingIdentity(identityToken);\n                }\n            } catch (NameNotFoundException e) {\n                Slog.e(TAG, \"Unknown package \" + packageName);\n                return;\n            }\n\n            Intent intent = newRequestAccountAccessIntent(account, packageName, uid, callback);\n            final UserAccounts userAccounts;\n            synchronized (mUsers) {\n                userAccounts = mUsers.get(userId);\n            }\n            SystemNotificationChannels.createAccountChannelForPackage(packageName, uid, mContext);\n            doNotification(userAccounts, account, null, intent, packageName, userId);\n        }\n\n        @Override\n        public void addOnAppPermissionChangeListener(OnAppPermissionChangeListener listener) {\n            // Listeners are a final CopyOnWriteArrayList, hence no lock needed.\n            mAppPermissionChangeListeners.add(listener);\n        }\n\n        @Override\n        public boolean hasAccountAccess(@NonNull Account account, @IntRange(from = 0) int uid) {\n            return AccountManagerService.this.hasAccountAccess(account, null, uid);\n        }\n\n        @Override\n        public byte[] backupAccountAccessPermissions(int userId) {\n            synchronized (mLock) {\n                if (mBackupHelper == null) {\n                    mBackupHelper = new AccountManagerBackupHelper(\n                            AccountManagerService.this, this);\n                }\n                return mBackupHelper.backupAccountAccessPermissions(userId);\n            }\n        }\n\n        @Override\n        public void restoreAccountAccessPermissions(byte[] data, int userId) {\n            synchronized (mLock) {\n                if (mBackupHelper == null) {\n                    mBackupHelper = new AccountManagerBackupHelper(\n                            AccountManagerService.this, this);\n                }\n                mBackupHelper.restoreAccountAccessPermissions(data, userId);\n            }\n        }\n    }\n\n    @VisibleForTesting\n    static class Injector {\n        private final Context mContext;\n\n        public Injector(Context context) {\n            mContext = context;\n        }\n\n        Looper getMessageHandlerLooper() {\n            ServiceThread serviceThread = new ServiceThread(TAG,\n                    android.os.Process.THREAD_PRIORITY_FOREGROUND, true /* allowIo */);\n            serviceThread.start();\n            return serviceThread.getLooper();\n        }\n\n        Context getContext() {\n            return mContext;\n        }\n\n        void addLocalService(AccountManagerInternal service) {\n            LocalServices.addService(AccountManagerInternal.class, service);\n        }\n\n        String getDeDatabaseName(int userId) {\n            File databaseFile = new File(Environment.getDataSystemDeDirectory(userId),\n                    AccountsDb.DE_DATABASE_NAME);\n            return databaseFile.getPath();\n        }\n\n        String getCeDatabaseName(int userId) {\n            File databaseFile = new File(Environment.getDataSystemCeDirectory(userId),\n                    AccountsDb.CE_DATABASE_NAME);\n            return databaseFile.getPath();\n        }\n\n        String getPreNDatabaseName(int userId) {\n            File systemDir = Environment.getDataSystemDirectory();\n            File databaseFile = new File(Environment.getUserSystemDirectory(userId),\n                    PRE_N_DATABASE_NAME);\n            if (userId == 0) {\n                // Migrate old file, if it exists, to the new location.\n                // Make sure the new file doesn't already exist. A placeholder file could have been\n                // accidentally created in the old location,\n                // causing the new one to become corrupted as well.\n                File oldFile = new File(systemDir, PRE_N_DATABASE_NAME);\n                if (oldFile.exists() && !databaseFile.exists()) {\n                    // Check for use directory; create if it doesn't exist, else renameTo will fail\n                    File userDir = Environment.getUserSystemDirectory(userId);\n                    if (!userDir.exists()) {\n                        if (!userDir.mkdirs()) {\n                            throw new IllegalStateException(\n                                    \"User dir cannot be created: \" + userDir);\n                        }\n                    }\n                    if (!oldFile.renameTo(databaseFile)) {\n                        throw new IllegalStateException(\n                                \"User dir cannot be migrated: \" + databaseFile);\n                    }\n                }\n            }\n            return databaseFile.getPath();\n        }\n\n        IAccountAuthenticatorCache getAccountAuthenticatorCache() {\n            return new AccountAuthenticatorCache(mContext);\n        }\n\n        INotificationManager getNotificationManager() {\n            return NotificationManager.getService();\n        }\n    }\n\n    private static class NotificationId {\n        final String mTag;\n        private final int mId;\n\n        NotificationId(String tag, int type) {\n            mTag = tag;\n            mId = type;\n        }\n    }\n}\n```"
                    }
                ]
            },
            {
                "downstream_version": "12L",
                "branch_used": "android12L-release",
                "downstream_patch": "185048041e6f9d43c38829c09965e7a4740d2a6a",
                "repo_path": "android_repos/base",
                "result": "failure",
                "downstream_patch_content": "commit 185048041e6f9d43c38829c09965e7a4740d2a6a\nAuthor: Dmitry Dementyev <dementyev@google.com>\nDate:   Wed Oct 16 15:01:59 2024 -0700\n\n    Update checkKeyIntent\n    \n    1) Explicityly set  component after target activity check.\n    2) Update Intent subclass check.\n    \n    Bug: 360846772\n    Test: manual\n    Flag: EXEMPT bugfix\n    \n    Merged-In: Ied7961c73299681aa5b523cf3f00fd905893116f\n    Change-Id: Iafc1e2260107f7ecc18c90ce12f8987b4fc76350\n\ndiff --git a/services/core/java/com/android/server/accounts/AccountManagerService.java b/services/core/java/com/android/server/accounts/AccountManagerService.java\nindex 36ffc40bf5f7..5f434ee267d4 100644\n--- a/services/core/java/com/android/server/accounts/AccountManagerService.java\n+++ b/services/core/java/com/android/server/accounts/AccountManagerService.java\n@@ -4916,6 +4916,8 @@ public class AccountManagerService\n                     Log.e(TAG, String.format(tmpl, activityName, pkgName, mAccountType));\n                     return false;\n                 }\n+                intent.setComponent(targetActivityInfo.getComponentName());\n+                bundle.putParcelable(AccountManager.KEY_INTENT, intent);\n                 return true;\n             } finally {\n                 Binder.restoreCallingIdentity(bid);\n@@ -4937,13 +4939,14 @@ public class AccountManagerService\n             Bundle simulateBundle = p.readBundle();\n             p.recycle();\n             Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT);\n-            if (intent != null && intent.getClass() != Intent.class) {\n-                return false;\n-            }\n             Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT);\n             if (intent == null) {\n                 return (simulateIntent == null);\n             }\n+            if (intent.getClass() != Intent.class || simulateIntent.getClass() != Intent.class) {\n+                return false;\n+            }\n+\n             if (!intent.filterEquals(simulateIntent)) {\n                 return false;\n             }\n",
                "file_conflicts": [
                    {
                        "file_name": "services/core/java/com/android/server/accounts/AccountManagerService.java",
                        "total_hunks": 2,
                        "failed_hunks": [
                            2
                        ],
                        "inline_merge_conflicts": [
                            {
                                "hunk_number": 1,
                                "merge_conflict": "<<<<<<< DOWNSTREAM (version 12L)\n\n=======\n                return false;\n            }\n\n            if (!intent.filterEquals(simulateIntent)) {\n>>>>>>> UPSTREAM PATCH (commit cde345a7ee06db716e613e12a2c218ce248ad1c4)"
                            }
                        ],
                        "rej_file_content": "```diff\n--- services/core/java/com/android/server/accounts/AccountManagerService.java\n+++ services/core/java/com/android/server/accounts/AccountManagerService.java\n@@ -5085,14 +5087,15 @@ public class AccountManagerService\n             Bundle simulateBundle = p.readBundle();\n             p.recycle();\n             Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT, Intent.class);\n-            if (intent != null && intent.getClass() != Intent.class) {\n-                return false;\n-            }\n             Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT,\n                     Intent.class);\n             if (intent == null) {\n                 return (simulateIntent == null);\n             }\n+            if (intent.getClass() != Intent.class || simulateIntent.getClass() != Intent.class) {\n+                return false;\n+            }\n+\n             if (!intent.filterEquals(simulateIntent)) {\n                 return false;\n             }\n```",
                        "patch_apply_output": "patching file services/core/java/com/android/server/accounts/AccountManagerService.java\nHunk #1 succeeded at 4916 (offset -146 lines).\nHunk #2 FAILED at 5085.\n1 out of 2 hunks FAILED -- saving rejects to file services/core/java/com/android/server/accounts/AccountManagerService.java.rej",
                        "inline_merge_output": "patching file services/core/java/com/android/server/accounts/AccountManagerService.java\nHunk #1 already applied at 5065-5066.\nHunk #2 already applied at 5088, NOT MERGED at 5094-5100.",
                        "upstream_file_content": "```java\n/*\n * Copyright (C) 2009 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.server.accounts;\n\nimport android.Manifest;\nimport android.accounts.AbstractAccountAuthenticator;\nimport android.accounts.Account;\nimport android.accounts.AccountAndUser;\nimport android.accounts.AccountAuthenticatorResponse;\nimport android.accounts.AccountManager;\nimport android.accounts.AccountManagerInternal;\nimport android.accounts.AccountManagerResponse;\nimport android.accounts.AuthenticatorDescription;\nimport android.accounts.CantAddAccountActivity;\nimport android.accounts.ChooseAccountActivity;\nimport android.accounts.GrantCredentialsPermissionActivity;\nimport android.accounts.IAccountAuthenticator;\nimport android.accounts.IAccountAuthenticatorResponse;\nimport android.accounts.IAccountManager;\nimport android.accounts.IAccountManagerResponse;\nimport android.annotation.IntRange;\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.app.ActivityManager;\nimport android.app.ActivityThread;\nimport android.app.AppOpsManager;\nimport android.app.BroadcastOptions;\nimport android.app.INotificationManager;\nimport android.app.Notification;\nimport android.app.NotificationManager;\nimport android.app.PendingIntent;\nimport android.app.admin.DevicePolicyEventLogger;\nimport android.app.admin.DevicePolicyManager;\nimport android.app.admin.DevicePolicyManagerInternal;\nimport android.app.compat.CompatChanges;\nimport android.compat.annotation.ChangeId;\nimport android.compat.annotation.EnabledAfter;\nimport android.content.BroadcastReceiver;\nimport android.content.ClipData;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.IntentSender;\nimport android.content.ServiceConnection;\nimport android.content.pm.ActivityInfo;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.IPackageManager;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManager.NameNotFoundException;\nimport android.content.pm.PackageManagerInternal;\nimport android.content.pm.RegisteredServicesCache;\nimport android.content.pm.RegisteredServicesCacheListener;\nimport android.content.pm.ResolveInfo;\nimport android.content.pm.Signature;\nimport android.content.pm.SigningDetails.CertCapabilities;\nimport android.content.pm.UserInfo;\nimport android.database.Cursor;\nimport android.database.sqlite.SQLiteCantOpenDatabaseException;\nimport android.database.sqlite.SQLiteException;\nimport android.database.sqlite.SQLiteFullException;\nimport android.database.sqlite.SQLiteStatement;\nimport android.os.Binder;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Environment;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.Parcel;\nimport android.os.Parcelable;\nimport android.os.Process;\nimport android.os.RemoteCallback;\nimport android.os.RemoteException;\nimport android.os.ResultReceiver;\nimport android.os.ShellCallback;\nimport android.os.StrictMode;\nimport android.os.SystemClock;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.provider.Settings;\nimport android.stats.devicepolicy.DevicePolicyEnums;\nimport android.text.TextUtils;\nimport android.util.EventLog;\nimport android.util.Log;\nimport android.util.Pair;\nimport android.util.Slog;\nimport android.util.SparseArray;\nimport android.util.SparseBooleanArray;\n\nimport com.android.internal.R;\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.content.PackageMonitor;\nimport com.android.internal.messages.nano.SystemMessageProto.SystemMessage;\nimport com.android.internal.notification.SystemNotificationChannels;\nimport com.android.internal.util.ArrayUtils;\nimport com.android.internal.util.DumpUtils;\nimport com.android.internal.util.IndentingPrintWriter;\nimport com.android.internal.util.Preconditions;\nimport com.android.modules.expresslog.Histogram;\nimport com.android.server.LocalServices;\nimport com.android.server.ServiceThread;\nimport com.android.server.SystemService;\n\nimport com.google.android.collect.Lists;\nimport com.google.android.collect.Sets;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.PrintWriter;\nimport java.security.GeneralSecurityException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.concurrent.atomic.AtomicReference;\n\n/**\n * A system service that provides  account, password, and authtoken management for all\n * accounts on the device. Some of these calls are implemented with the help of the corresponding\n * {@link IAccountAuthenticator} services. This service is not accessed by users directly,\n * instead one uses an instance of {@link AccountManager}, which can be accessed as follows:\n *    AccountManager accountManager = AccountManager.get(context);\n * @hide\n */\npublic class AccountManagerService\n        extends IAccountManager.Stub\n        implements RegisteredServicesCacheListener<AuthenticatorDescription> {\n    private static final String TAG = \"AccountManagerService\";\n\n    public static class Lifecycle extends SystemService {\n        private AccountManagerService mService;\n\n        public Lifecycle(Context context) {\n            super(context);\n        }\n\n        @Override\n        public void onStart() {\n            mService = new AccountManagerService(new Injector(getContext()));\n            publishBinderService(Context.ACCOUNT_SERVICE, mService);\n        }\n\n        @Override\n        public void onUserUnlocking(@NonNull TargetUser user) {\n            mService.onUnlockUser(user.getUserIdentifier());\n        }\n\n        @Override\n        public void onUserStopped(@NonNull TargetUser user) {\n            Slog.i(TAG, \"onUserStopped \" + user);\n            mService.purgeUserData(user.getUserIdentifier());\n        }\n    }\n\n    final Context mContext;\n\n    private static final int[] INTERESTING_APP_OPS = new int[] {\n        AppOpsManager.OP_GET_ACCOUNTS,\n        AppOpsManager.OP_READ_CONTACTS,\n        AppOpsManager.OP_WRITE_CONTACTS,\n    };\n\n    private final PackageManager mPackageManager;\n    private final AppOpsManager mAppOpsManager;\n    private UserManager mUserManager;\n    private final Injector mInjector;\n\n    final MessageHandler mHandler;\n\n    private static final int TIMEOUT_DELAY_MS = 1000 * 60 * 15;\n    // Messages that can be sent on mHandler\n    private static final int MESSAGE_TIMED_OUT = 3;\n    private static final int MESSAGE_COPY_SHARED_ACCOUNT = 4;\n\n    private final IAccountAuthenticatorCache mAuthenticatorCache;\n    private static final String PRE_N_DATABASE_NAME = \"accounts.db\";\n    private static final Intent ACCOUNTS_CHANGED_INTENT;\n    private static final Bundle ACCOUNTS_CHANGED_OPTIONS = new BroadcastOptions()\n            .setDeliveryGroupPolicy(BroadcastOptions.DELIVERY_GROUP_POLICY_MOST_RECENT)\n            .toBundle();\n\n    private static final int SIGNATURE_CHECK_MISMATCH = 0;\n    private static final int SIGNATURE_CHECK_MATCH = 1;\n    private static final int SIGNATURE_CHECK_UID_MATCH = 2;\n\n    /**\n     * Apps targeting Android U and above need to declare the package visibility needs in the\n     * manifest to access the AccountManager APIs.\n     */\n    @ChangeId\n    @EnabledAfter(targetSdkVersion = Build.VERSION_CODES.TIRAMISU)\n    private static final long ENFORCE_PACKAGE_VISIBILITY_FILTERING = 154726397;\n\n    static {\n        ACCOUNTS_CHANGED_INTENT = new Intent(AccountManager.LOGIN_ACCOUNTS_CHANGED_ACTION);\n        ACCOUNTS_CHANGED_INTENT.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT\n                | Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);\n    }\n\n    private final LinkedHashMap<String, Session> mSessions = new LinkedHashMap<String, Session>();\n\n    static class UserAccounts {\n        private final int userId;\n        final AccountsDb accountsDb;\n        private final HashMap<Pair<Pair<Account, String>, Integer>, NotificationId>\n                credentialsPermissionNotificationIds = new HashMap<>();\n        private final HashMap<Account, NotificationId> signinRequiredNotificationIds\n                = new HashMap<>();\n        final Object cacheLock = new Object();\n        final Object dbLock = new Object(); // if needed, dbLock must be obtained before cacheLock\n        /** protected by the {@link #cacheLock} */\n        final HashMap<String, Account[]> accountCache = new LinkedHashMap<>();\n        /** protected by the {@link #cacheLock} */\n        private final Map<Account, Map<String, String>> userDataCache = new HashMap<>();\n        /** protected by the {@link #cacheLock} */\n        private final Map<Account, Map<String, String>> authTokenCache = new HashMap<>();\n        /** protected by the {@link #cacheLock} */\n        private final TokenCache accountTokenCaches = new TokenCache();\n        /** protected by the {@link #cacheLock} */\n        private final Map<Account, Map<String, Integer>> visibilityCache = new HashMap<>();\n\n        /** protected by the {@link #mReceiversForType},\n         *  type -> (packageName -> number of active receivers)\n         *  type == null is used to get notifications about all account types\n         */\n        private final Map<String, Map<String, Integer>> mReceiversForType = new HashMap<>();\n\n        /**\n         * protected by the {@link #cacheLock}\n         *\n         * Caches the previous names associated with an account. Previous names\n         * should be cached because we expect that when an Account is renamed,\n         * many clients will receive a LOGIN_ACCOUNTS_CHANGED broadcast and\n         * want to know if the accounts they care about have been renamed.\n         *\n         * The previous names are wrapped in an {@link AtomicReference} so that\n         * we can distinguish between those accounts with no previous names and\n         * those whose previous names haven't been cached (yet).\n         */\n        private final HashMap<Account, AtomicReference<String>> previousNameCache =\n                new HashMap<Account, AtomicReference<String>>();\n\n        UserAccounts(Context context, int userId, File preNDbFile, File deDbFile) {\n            this.userId = userId;\n            synchronized (dbLock) {\n                synchronized (cacheLock) {\n                    accountsDb = AccountsDb.create(context, userId, preNDbFile, deDbFile);\n                }\n            }\n        }\n    }\n\n    private final SparseArray<UserAccounts> mUsers = new SparseArray<>();\n    private final SparseBooleanArray mLocalUnlockedUsers = new SparseBooleanArray();\n    // Not thread-safe. Only use in synchronized context\n    private final SimpleDateFormat mDateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n    private CopyOnWriteArrayList<AccountManagerInternal.OnAppPermissionChangeListener>\n            mAppPermissionChangeListeners = new CopyOnWriteArrayList<>();\n\n    private static AtomicReference<AccountManagerService> sThis = new AtomicReference<>();\n    private static final Account[] EMPTY_ACCOUNT_ARRAY = new Account[]{};\n\n    private static Histogram sResponseLatency = new Histogram(\n            \"app.value_high_authenticator_response_latency\",\n            new Histogram.ScaledRangeOptions(20, 10000, 10000, 1.5f)\n    );\n\n    /**\n     * This should only be called by system code. One should only call this after the service\n     * has started.\n     * @return a reference to the AccountManagerService instance\n     * @hide\n     */\n    public static AccountManagerService getSingleton() {\n        return sThis.get();\n    }\n\n    public AccountManagerService(Injector injector) {\n        mInjector = injector;\n        mContext = injector.getContext();\n        mPackageManager = mContext.getPackageManager();\n        mAppOpsManager = mContext.getSystemService(AppOpsManager.class);\n        mHandler = new MessageHandler(injector.getMessageHandlerLooper());\n        mAuthenticatorCache = mInjector.getAccountAuthenticatorCache();\n        mAuthenticatorCache.setListener(this, mHandler);\n\n        sThis.set(this);\n\n        IntentFilter intentFilter = new IntentFilter();\n        intentFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);\n        intentFilter.addDataScheme(\"package\");\n        mContext.registerReceiver(new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context1, Intent intent) {\n                // Don't delete accounts when updating a authenticator's\n                // package.\n                if (!intent.getBooleanExtra(Intent.EXTRA_REPLACING, false)) {\n                    /* Purging data requires file io, don't block the main thread. This is probably\n                     * less than ideal because we are introducing a race condition where old grants\n                     * could be exercised until they are purged. But that race condition existed\n                     * anyway with the broadcast receiver.\n                     *\n                     * Ideally, we would completely clear the cache, purge data from the database,\n                     * and then rebuild the cache. All under the cache lock. But that change is too\n                     * large at this point.\n                     */\n                    final String removedPackageName = intent.getData().getSchemeSpecificPart();\n                    Runnable purgingRunnable = new Runnable() {\n                        @Override\n                        public void run() {\n                            purgeOldGrantsAll();\n                            // Notify authenticator about removed app?\n                            removeVisibilityValuesForPackage(removedPackageName);\n                        }\n                    };\n                    mHandler.post(purgingRunnable);\n                }\n            }\n        }, intentFilter);\n\n        injector.addLocalService(new AccountManagerInternalImpl());\n\n        IntentFilter userFilter = new IntentFilter();\n        userFilter.addAction(Intent.ACTION_USER_REMOVED);\n        mContext.registerReceiverAsUser(new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                String action = intent.getAction();\n                if (Intent.ACTION_USER_REMOVED.equals(action)) {\n                    int userId = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, -1);\n                    if (userId < 1) return;\n                    Slog.i(TAG, \"User \" + userId + \" removed\");\n                    purgeUserData(userId);\n                }\n            }\n        }, UserHandle.ALL, userFilter, null, null);\n\n        // Need to cancel account request notifications if the update/install can access the account\n        new PackageMonitor() {\n            @Override\n            public void onPackageAdded(String packageName, int uid) {\n                // Called on a handler, and running as the system\n                try {\n                    UserAccounts accounts = getUserAccounts(UserHandle.getUserId(uid));\n                    cancelAccountAccessRequestNotificationIfNeeded(uid, true, accounts);\n                } catch (SQLiteCantOpenDatabaseException e) {\n                    Log.w(TAG, \"Can't read accounts database\", e);\n                    return;\n                }\n            }\n\n            @Override\n            public void onPackageUpdateFinished(String packageName, int uid) {\n                // Called on a handler, and running as the system\n                try {\n                    UserAccounts accounts = getUserAccounts(UserHandle.getUserId(uid));\n                    cancelAccountAccessRequestNotificationIfNeeded(uid, true, accounts);\n                } catch (SQLiteCantOpenDatabaseException e) {\n                    Log.w(TAG, \"Can't read accounts database\", e);\n                    return;\n                }\n            }\n        }.register(mContext, mHandler.getLooper(), UserHandle.ALL, true);\n\n        // Cancel account request notification if an app op was preventing the account access\n        for (int i = 0; i < INTERESTING_APP_OPS.length; ++i) {\n            mAppOpsManager.startWatchingMode(INTERESTING_APP_OPS[i], null,\n                    new OnInterestingAppOpChangedListener());\n        }\n\n        // Clear the accounts cache on permission changes.\n        // The specific permissions we care about are backed by AppOps, so just\n        // let the change events on those handle clearing any notifications.\n        mPackageManager.addOnPermissionsChangeListener((int uid) -> {\n            AccountManager.invalidateLocalAccountsDataCaches();\n        });\n    }\n\n    private class OnInterestingAppOpChangedListener\n            extends AppOpsManager.OnOpChangedInternalListener {\n        @Override\n        public void onOpChanged(int op, String packageName) {\n            final int userId = ActivityManager.getCurrentUser();\n            final int packageUid;\n            try {\n                packageUid = mPackageManager.getPackageUidAsUser(packageName, userId);\n            } catch (NameNotFoundException e) {\n                /* ignore */\n                return;\n            }\n\n            final int mode = mAppOpsManager.checkOpNoThrow(op, packageUid, packageName);\n            if (mode != AppOpsManager.MODE_ALLOWED) {\n                return;\n            }\n\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                cancelAccountAccessRequestNotificationIfNeeded(\n                        packageName, packageUid, true, getUserAccounts(userId));\n            } catch (SQLiteCantOpenDatabaseException e) {\n                Log.w(TAG, \"Can't read accounts database\", e);\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        }\n    }\n\n    boolean getBindInstantServiceAllowed(int userId) {\n        return  mAuthenticatorCache.getBindInstantServiceAllowed(userId);\n    }\n\n    void setBindInstantServiceAllowed(int userId, boolean allowed) {\n        mAuthenticatorCache.setBindInstantServiceAllowed(userId, allowed);\n    }\n\n    private void cancelAccountAccessRequestNotificationIfNeeded(int uid,\n            boolean checkAccess, UserAccounts userAccounts) {\n        Account[] accounts = getAccountsOrEmptyArray(null, UserHandle.getUserId(uid), \"android\");\n        for (Account account : accounts) {\n            cancelAccountAccessRequestNotificationIfNeeded(account, uid, checkAccess, userAccounts);\n        }\n    }\n\n    private void cancelAccountAccessRequestNotificationIfNeeded(String packageName, int uid,\n            boolean checkAccess, UserAccounts userAccounts) {\n        Account[] accounts = getAccountsOrEmptyArray(null, UserHandle.getUserId(uid), \"android\");\n        for (Account account : accounts) {\n            cancelAccountAccessRequestNotificationIfNeeded(account,\n                    uid, packageName, checkAccess, userAccounts);\n        }\n    }\n\n    private void cancelAccountAccessRequestNotificationIfNeeded(Account account, int uid,\n            boolean checkAccess, UserAccounts accounts) {\n        String[] packageNames = mPackageManager.getPackagesForUid(uid);\n        if (packageNames != null) {\n            for (String packageName : packageNames) {\n                cancelAccountAccessRequestNotificationIfNeeded(account, uid,\n                        packageName, checkAccess, accounts);\n            }\n        }\n    }\n\n    private void cancelAccountAccessRequestNotificationIfNeeded(Account account,\n            int uid, String packageName, boolean checkAccess, UserAccounts accounts) {\n        if (!checkAccess || hasAccountAccess(account, packageName,\n                UserHandle.getUserHandleForUid(uid))) {\n            cancelNotification(getCredentialPermissionNotificationId(account,\n                    AccountManager.ACCOUNT_ACCESS_TOKEN_TYPE, uid, accounts),\n                    accounts);\n        }\n    }\n\n    @Override\n    public boolean addAccountExplicitlyWithVisibility(Account account, String password,\n            Bundle extras, Map packageToVisibility, String opPackageName) {\n        Bundle.setDefusable(extras, true);\n        int callingUid = Binder.getCallingUid();\n        int userId = UserHandle.getCallingUserId();\n        Objects.requireNonNull(account, \"account cannot be null\");\n        Log.v(TAG, \"addAccountExplicitly: caller's uid=\" + callingUid + \", pid=\"\n                + Binder.getCallingPid() + \", packageName=\" + opPackageName + \", accountType=\"\n                + account.type);\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\"uid=%s, package=%s cannot explicitly add \"\n                    + \"accounts of type: %s\", callingUid, opPackageName, account.type);\n            throw new SecurityException(msg);\n        }\n        /*\n         * Child users are not allowed to add accounts. Only the accounts that are shared by the\n         * parent profile can be added to child profile.\n         *\n         * TODO: Only allow accounts that were shared to be added by a limited user.\n         */\n        // fails if the account already exists\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return addAccountInternal(accounts, account, password, extras, callingUid,\n                    (Map<String, Integer>) packageToVisibility, opPackageName);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public Map<Account, Integer> getAccountsAndVisibilityForPackage(String packageName,\n            String accountType) {\n        int callingUid = Binder.getCallingUid();\n        int userId = UserHandle.getCallingUserId();\n        boolean isSystemUid = UserHandle.isSameApp(callingUid, Process.SYSTEM_UID);\n        List<String> managedTypes = getTypesForCaller(callingUid, userId, isSystemUid);\n\n        if ((accountType != null && !managedTypes.contains(accountType))\n                || (accountType == null && !isSystemUid)) {\n            throw new SecurityException(\n                    \"getAccountsAndVisibilityForPackage() called from unauthorized uid \"\n                            + callingUid + \" with packageName=\" + packageName);\n        }\n        if (accountType != null) {\n            managedTypes = new ArrayList<String>();\n            managedTypes.add(accountType);\n        }\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return getAccountsAndVisibilityForPackage(packageName, managedTypes, callingUid,\n                    accounts);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    /*\n     * accountTypes may not be null\n     */\n    private Map<Account, Integer> getAccountsAndVisibilityForPackage(String packageName,\n            List<String> accountTypes, Integer callingUid, UserAccounts accounts) {\n        if (!canCallerAccessPackage(packageName, callingUid, accounts.userId)) {\n            Log.w(TAG, \"getAccountsAndVisibilityForPackage#Package not found \" + packageName);\n            return new LinkedHashMap<>();\n        }\n\n        Map<Account, Integer> result = new LinkedHashMap<>();\n        for (String accountType : accountTypes) {\n            synchronized (accounts.dbLock) {\n                synchronized (accounts.cacheLock) {\n                    final Account[] accountsOfType = accounts.accountCache.get(accountType);\n                    if (accountsOfType != null) {\n                        for (Account account : accountsOfType) {\n                            result.put(account,\n                                    resolveAccountVisibility(account, packageName, accounts));\n                        }\n                    }\n                }\n            }\n        }\n        return filterSharedAccounts(accounts, result, callingUid, packageName);\n    }\n\n    @Override\n    public Map<String, Integer> getPackagesAndVisibilityForAccount(Account account) {\n        Objects.requireNonNull(account, \"account cannot be null\");\n        int callingUid = Binder.getCallingUid();\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)\n                && !isSystemUid(callingUid)) {\n            String msg =\n                    String.format(\"uid %s cannot get secrets for account %s\", callingUid, account);\n            throw new SecurityException(msg);\n        }\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            synchronized (accounts.dbLock) {\n                synchronized (accounts.cacheLock) {\n                    return getPackagesAndVisibilityForAccountLocked(account, accounts);\n                }\n            }\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n\n    }\n\n    /**\n     * Returns Map with all package names and visibility values for given account.\n     * The method and returned map must be guarded by accounts.cacheLock\n     *\n     * @param account Account to get visibility values.\n     * @param accounts UserAccount that currently hosts the account and application\n     *\n     * @return Map with cache for package names to visibility.\n     */\n    private @NonNull Map<String, Integer> getPackagesAndVisibilityForAccountLocked(Account account,\n            UserAccounts accounts) {\n        Map<String, Integer> accountVisibility = accounts.visibilityCache.get(account);\n        if (accountVisibility == null) {\n            Log.d(TAG, \"Visibility was not initialized\");\n            accountVisibility = new HashMap<>();\n            accounts.visibilityCache.put(account, accountVisibility);\n            AccountManager.invalidateLocalAccountsDataCaches();\n        }\n        return accountVisibility;\n    }\n\n    @Override\n    public int getAccountVisibility(Account account, String packageName) {\n        Objects.requireNonNull(account, \"account cannot be null\");\n        Objects.requireNonNull(packageName, \"packageName cannot be null\");\n        int callingUid = Binder.getCallingUid();\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)\n            && !isSystemUid(callingUid)) {\n            String msg = String.format(\n                    \"uid %s cannot get secrets for accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            if (AccountManager.PACKAGE_NAME_KEY_LEGACY_VISIBLE.equals(packageName)) {\n                int visibility = getAccountVisibilityFromCache(account, packageName, accounts);\n                if (AccountManager.VISIBILITY_UNDEFINED != visibility) {\n                    return visibility;\n                } else {\n                   return AccountManager.VISIBILITY_USER_MANAGED_VISIBLE;\n                }\n            }\n            if (AccountManager.PACKAGE_NAME_KEY_LEGACY_NOT_VISIBLE.equals(packageName)) {\n                int visibility = getAccountVisibilityFromCache(account, packageName, accounts);\n                if (AccountManager.VISIBILITY_UNDEFINED != visibility) {\n                    return visibility;\n                } else {\n                   return AccountManager.VISIBILITY_USER_MANAGED_NOT_VISIBLE;\n                }\n            }\n            if (!canCallerAccessPackage(packageName, callingUid, accounts.userId)) {\n                return AccountManager.VISIBILITY_NOT_VISIBLE;\n            }\n            return resolveAccountVisibility(account, packageName, accounts);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    /**\n     * Method returns visibility for given account and package name.\n     *\n     * @param account The account to check visibility.\n     * @param packageName Package name to check visibility.\n     * @param accounts UserAccount that currently hosts the account and application\n     *\n     * @return Visibility value, AccountManager.VISIBILITY_UNDEFINED if no value was stored.\n     *\n     */\n    private int getAccountVisibilityFromCache(Account account, String packageName,\n            UserAccounts accounts) {\n        synchronized (accounts.cacheLock) {\n            Map<String, Integer> accountVisibility =\n                    getPackagesAndVisibilityForAccountLocked(account, accounts);\n            Integer visibility = accountVisibility.get(packageName);\n            return visibility != null ? visibility : AccountManager.VISIBILITY_UNDEFINED;\n        }\n    }\n\n    /**\n     * Method which handles default values for Account visibility.\n     *\n     * @param account The account to check visibility.\n     * @param packageName Package name to check visibility\n     * @param accounts UserAccount that currently hosts the account and application\n     *\n     * @return Visibility value, the method never returns AccountManager.VISIBILITY_UNDEFINED\n     *\n     */\n    private Integer resolveAccountVisibility(Account account, @NonNull String packageName,\n            UserAccounts accounts) {\n        Objects.requireNonNull(packageName, \"packageName cannot be null\");\n        int uid = -1;\n        try {\n            final long identityToken = clearCallingIdentity();\n            try {\n                uid = mPackageManager.getPackageUidAsUser(packageName, accounts.userId);\n            } finally {\n                restoreCallingIdentity(identityToken);\n            }\n        } catch (NameNotFoundException e) {\n            Log.w(TAG, \"resolveAccountVisibility#Package not found \" + e.getMessage());\n            return AccountManager.VISIBILITY_NOT_VISIBLE;\n        }\n\n        // System visibility can not be restricted.\n        if (UserHandle.isSameApp(uid, Process.SYSTEM_UID)) {\n            return AccountManager.VISIBILITY_VISIBLE;\n        }\n\n        int signatureCheckResult =\n                checkPackageSignature(account.type, uid, accounts.userId);\n\n        // Authenticator can not restrict visibility to itself.\n        if (signatureCheckResult == SIGNATURE_CHECK_UID_MATCH) {\n            return AccountManager.VISIBILITY_VISIBLE; // Authenticator can always see the account\n        }\n\n        // Return stored value if it was set.\n        int visibility = getAccountVisibilityFromCache(account, packageName, accounts);\n\n        if (AccountManager.VISIBILITY_UNDEFINED != visibility) {\n            return visibility;\n        }\n\n        boolean isPrivileged = isPermittedForPackage(packageName, accounts.userId,\n                Manifest.permission.GET_ACCOUNTS_PRIVILEGED);\n\n        // Device/Profile owner gets visibility by default.\n        if (isProfileOwner(uid)) {\n            return AccountManager.VISIBILITY_VISIBLE;\n        }\n\n        boolean preO = isPreOApplication(packageName);\n        if ((signatureCheckResult != SIGNATURE_CHECK_MISMATCH)\n                || (preO && checkGetAccountsPermission(packageName, accounts.userId))\n                || (checkReadContactsPermission(packageName, accounts.userId)\n                    && accountTypeManagesContacts(account.type, accounts.userId))\n                || isPrivileged) {\n            // Use legacy for preO apps with GET_ACCOUNTS permission or pre/postO with signature\n            // match.\n            visibility = getAccountVisibilityFromCache(account,\n                    AccountManager.PACKAGE_NAME_KEY_LEGACY_VISIBLE, accounts);\n            if (AccountManager.VISIBILITY_UNDEFINED == visibility) {\n                visibility = AccountManager.VISIBILITY_USER_MANAGED_VISIBLE;\n            }\n        } else {\n            visibility = getAccountVisibilityFromCache(account,\n                    AccountManager.PACKAGE_NAME_KEY_LEGACY_NOT_VISIBLE, accounts);\n            if (AccountManager.VISIBILITY_UNDEFINED == visibility) {\n                visibility = AccountManager.VISIBILITY_USER_MANAGED_NOT_VISIBLE;\n            }\n        }\n        return visibility;\n    }\n\n    /**\n     * Checks targetSdk for a package;\n     *\n     * @param packageName Package name\n     *\n     * @return True if package's target SDK is below {@link android.os.Build.VERSION_CODES#O}, or\n     *         undefined\n     */\n    private boolean isPreOApplication(String packageName) {\n        try {\n            final long identityToken = clearCallingIdentity();\n            ApplicationInfo applicationInfo;\n            try {\n                applicationInfo = mPackageManager.getApplicationInfo(packageName, 0);\n            } finally {\n                restoreCallingIdentity(identityToken);\n            }\n\n            if (applicationInfo != null) {\n                int version = applicationInfo.targetSdkVersion;\n                return version < android.os.Build.VERSION_CODES.O;\n            }\n            return true;\n        } catch (NameNotFoundException e) {\n            Log.w(TAG, \"isPreOApplication#Package not found \" + e.getMessage());\n            return true;\n        }\n    }\n\n    @Override\n    public boolean setAccountVisibility(Account account, String packageName, int newVisibility) {\n        Objects.requireNonNull(account, \"account cannot be null\");\n        Objects.requireNonNull(packageName, \"packageName cannot be null\");\n        int callingUid = Binder.getCallingUid();\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)\n            && !isSystemUid(callingUid)) {\n            String msg = String.format(\n                    \"uid %s cannot get secrets for accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return setAccountVisibility(account, packageName, newVisibility, true /* notify */,\n                    accounts, callingUid);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private boolean isVisible(int visibility) {\n        return visibility == AccountManager.VISIBILITY_VISIBLE ||\n            visibility == AccountManager.VISIBILITY_USER_MANAGED_VISIBLE;\n    }\n\n    /**\n     * Updates visibility for given account name and package.\n     *\n     * @param account Account to update visibility.\n     * @param packageName Package name for which visibility is updated.\n     * @param newVisibility New visibility calue\n     * @param notify if the flag is set applications will get notification about visibility change\n     * @param accounts UserAccount that currently hosts the account and application\n     * @param callingUid The caller's uid.\n     *\n     * @return True if account visibility was changed.\n     */\n    private boolean setAccountVisibility(Account account, String packageName, int newVisibility,\n            boolean notify, UserAccounts accounts, int callingUid) {\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                Map<String, Integer> packagesToVisibility;\n                List<String> accountRemovedReceivers;\n                if (notify) {\n                    if (isSpecialPackageKey(packageName)) {\n                        packagesToVisibility =\n                                getRequestingPackages(account, accounts);\n                        accountRemovedReceivers = getAccountRemovedReceivers(account, accounts);\n                    } else {\n                        if (!canCallerAccessPackage(packageName, callingUid, accounts.userId)) {\n                            return false; // package is not installed or not visible.\n                        }\n                        packagesToVisibility = new HashMap<>();\n                        packagesToVisibility.put(packageName,\n                                resolveAccountVisibility(account, packageName, accounts));\n                        accountRemovedReceivers = new ArrayList<>();\n                        if (shouldNotifyPackageOnAccountRemoval(account, packageName, accounts)) {\n                            accountRemovedReceivers.add(packageName);\n                        }\n                    }\n                } else {\n                    // Notifications will not be send - only used during add account.\n                    if (!isSpecialPackageKey(packageName)\n                            && !canCallerAccessPackage(packageName, callingUid, accounts.userId)) {\n                        // package is not installed and not meta value.\n                        return false;\n                    }\n                    packagesToVisibility = Collections.emptyMap();\n                    accountRemovedReceivers = Collections.emptyList();\n                }\n                if (notify) {\n                    Integer oldVisibility =\n                            accounts.accountsDb.findAccountVisibility(account, packageName);\n                    if (oldVisibility != null && oldVisibility == newVisibility) {\n                        // Database will not be updated - skip LOGIN_ACCOUNTS_CHANGED broadcast.\n                        notify = false;\n                    }\n                }\n\n                if (!updateAccountVisibilityLocked(account, packageName, newVisibility, accounts)) {\n                    return false;\n                }\n\n                if (notify) {\n                    Log.i(TAG, \"Notifying visibility changed for package=\" + packageName);\n                    for (Entry<String, Integer> packageToVisibility : packagesToVisibility\n                            .entrySet()) {\n                        int oldVisibility = packageToVisibility.getValue();\n                        int currentVisibility =\n                            resolveAccountVisibility(account, packageName, accounts);\n                        if (isVisible(oldVisibility) != isVisible(currentVisibility)) {\n                            notifyPackage(packageToVisibility.getKey(), accounts);\n                        }\n                    }\n                    for (String packageNameToNotify : accountRemovedReceivers) {\n                        int currentVisibility =\n                                resolveAccountVisibility(account, packageNameToNotify, accounts);\n                        if (isVisible(currentVisibility)) {\n                            continue;\n                        }\n                        sendAccountRemovedBroadcast(\n                                account,\n                                packageNameToNotify,\n                                accounts.userId,\n                                /*useCase=*/\"setAccountVisibility\");\n                    }\n                    sendAccountsChangedBroadcast(\n                            accounts.userId, account.type, /*useCase=*/\"setAccountVisibility\");\n                }\n                return true;\n            }\n        }\n    }\n\n    // Update account visibility in cache and database.\n    private boolean updateAccountVisibilityLocked(Account account, String packageName,\n            int newVisibility, UserAccounts accounts) {\n        final long accountId = accounts.accountsDb.findDeAccountId(account);\n        if (accountId < 0) {\n            return false;\n        }\n\n        final StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskWrites();\n        try {\n            if (!accounts.accountsDb.setAccountVisibility(accountId, packageName,\n                    newVisibility)) {\n                return false;\n            }\n        } finally {\n            StrictMode.setThreadPolicy(oldPolicy);\n        }\n        Map<String, Integer> accountVisibility =\n            getPackagesAndVisibilityForAccountLocked(account, accounts);\n        accountVisibility.put(packageName, newVisibility);\n        AccountManager.invalidateLocalAccountsDataCaches();\n        return true;\n    }\n\n    @Override\n    public void registerAccountListener(String[] accountTypes, String opPackageName) {\n        int callingUid = Binder.getCallingUid();\n        mAppOpsManager.checkPackage(callingUid, opPackageName);\n\n        int userId = UserHandle.getCallingUserId();\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            registerAccountListener(accountTypes, opPackageName, accounts);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private void registerAccountListener(String[] accountTypes, String opPackageName,\n            UserAccounts accounts) {\n        synchronized (accounts.mReceiversForType) {\n            if (accountTypes == null) {\n                // null for any type\n                accountTypes = new String[] {null};\n            }\n            for (String type : accountTypes) {\n                Map<String, Integer> receivers = accounts.mReceiversForType.get(type);\n                if (receivers == null) {\n                    receivers = new HashMap<>();\n                    accounts.mReceiversForType.put(type, receivers);\n                }\n                Integer cnt = receivers.get(opPackageName);\n                receivers.put(opPackageName, cnt != null ? cnt + 1 : 1);\n            }\n        }\n    }\n\n    @Override\n    public void unregisterAccountListener(String[] accountTypes, String opPackageName) {\n        int callingUid = Binder.getCallingUid();\n        mAppOpsManager.checkPackage(callingUid, opPackageName);\n        int userId = UserHandle.getCallingUserId();\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            unregisterAccountListener(accountTypes, opPackageName, accounts);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private void unregisterAccountListener(String[] accountTypes, String opPackageName,\n            UserAccounts accounts) {\n        synchronized (accounts.mReceiversForType) {\n            if (accountTypes == null) {\n                // null for any type\n                accountTypes = new String[] {null};\n            }\n            for (String type : accountTypes) {\n                Map<String, Integer> receivers = accounts.mReceiversForType.get(type);\n                if (receivers == null || receivers.get(opPackageName) == null) {\n                    throw new IllegalArgumentException(\"attempt to unregister wrong receiver\");\n                }\n                Integer cnt = receivers.get(opPackageName);\n                if (cnt == 1) {\n                    receivers.remove(opPackageName);\n                } else {\n                    receivers.put(opPackageName, cnt - 1);\n                }\n            }\n        }\n    }\n\n    // Send notification to all packages which can potentially see the account\n    private void sendNotificationAccountUpdated(Account account, UserAccounts accounts) {\n        Map<String, Integer> packagesToVisibility = getRequestingPackages(account, accounts);\n\n        for (Entry<String, Integer> packageToVisibility : packagesToVisibility.entrySet()) {\n            if ((packageToVisibility.getValue() != AccountManager.VISIBILITY_NOT_VISIBLE)\n                    && (packageToVisibility.getValue()\n                        != AccountManager.VISIBILITY_USER_MANAGED_NOT_VISIBLE)) {\n                notifyPackage(packageToVisibility.getKey(), accounts);\n            }\n        }\n    }\n\n    /**\n     * Sends a direct intent to a package, notifying it of account visibility change.\n     *\n     * @param packageName to send Account to\n     * @param accounts UserAccount that currently hosts the account\n     */\n    private void notifyPackage(String packageName, UserAccounts accounts) {\n        Log.i(TAG, \"notifying package=\" + packageName + \" for userId=\" + accounts.userId\n                +\", sending broadcast of \" + AccountManager.ACTION_VISIBLE_ACCOUNTS_CHANGED);\n        Intent intent = new Intent(AccountManager.ACTION_VISIBLE_ACCOUNTS_CHANGED);\n        intent.setPackage(packageName);\n        intent.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);\n        mContext.sendBroadcastAsUser(intent, new UserHandle(accounts.userId));\n    }\n\n    // Returns a map from package name to visibility, for packages subscribed\n    // to notifications about any account type, or type of provided account\n    // account type or all types.\n    private Map<String, Integer> getRequestingPackages(Account account, UserAccounts accounts) {\n        Set<String> packages = new HashSet<>();\n        synchronized (accounts.mReceiversForType) {\n            for (String type : new String[] {account.type, null}) {\n                Map<String, Integer> receivers = accounts.mReceiversForType.get(type);\n                if (receivers != null) {\n                    packages.addAll(receivers.keySet());\n                }\n            }\n        }\n        Map<String, Integer> result = new HashMap<>();\n        for (String packageName : packages) {\n            result.put(packageName, resolveAccountVisibility(account, packageName, accounts));\n        }\n        return result;\n    }\n\n    // Returns a list of packages listening to ACTION_ACCOUNT_REMOVED able to see the account.\n    private List<String> getAccountRemovedReceivers(Account account, UserAccounts accounts) {\n        Intent intent = new Intent(AccountManager.ACTION_ACCOUNT_REMOVED);\n        intent.setFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);\n        List<ResolveInfo> receivers =\n            mPackageManager.queryBroadcastReceiversAsUser(intent, 0, accounts.userId);\n        List<String> result = new ArrayList<>();\n        if (receivers == null) {\n            return result;\n        }\n        for (ResolveInfo resolveInfo: receivers) {\n            String packageName = resolveInfo.activityInfo.applicationInfo.packageName;\n            int visibility = resolveAccountVisibility(account, packageName, accounts);\n            if (visibility == AccountManager.VISIBILITY_VISIBLE\n                || visibility == AccountManager.VISIBILITY_USER_MANAGED_VISIBLE) {\n                result.add(packageName);\n            }\n        }\n        return result;\n    }\n\n    // Returns true if given package is listening to ACTION_ACCOUNT_REMOVED and can see the account.\n    private boolean shouldNotifyPackageOnAccountRemoval(Account account,\n            String packageName, UserAccounts accounts) {\n        int visibility = resolveAccountVisibility(account, packageName, accounts);\n        if (visibility != AccountManager.VISIBILITY_VISIBLE\n            && visibility != AccountManager.VISIBILITY_USER_MANAGED_VISIBLE) {\n            return false;\n        }\n\n        Intent intent = new Intent(AccountManager.ACTION_ACCOUNT_REMOVED);\n        intent.setFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);\n        intent.setPackage(packageName);\n        List<ResolveInfo> receivers =\n            mPackageManager.queryBroadcastReceiversAsUser(intent, 0, accounts.userId);\n        return (receivers != null && receivers.size() > 0);\n    }\n\n    /**\n     * Returns true if packageName is one of special values.\n     */\n    private boolean isSpecialPackageKey(String packageName) {\n        return (AccountManager.PACKAGE_NAME_KEY_LEGACY_VISIBLE.equals(packageName)\n                || AccountManager.PACKAGE_NAME_KEY_LEGACY_NOT_VISIBLE.equals(packageName));\n    }\n\n    private void sendAccountsChangedBroadcast(\n            int userId, String accountType, @NonNull String useCase) {\n        Objects.requireNonNull(useCase, \"useCase can't be null\");\n        Log.i(TAG, \"the accountType= \" + (accountType == null ? \"\" : accountType)\n                + \" changed with useCase=\" + useCase + \" for userId=\" + userId\n                + \", sending broadcast of \" + ACCOUNTS_CHANGED_INTENT.getAction());\n        mContext.sendBroadcastAsUser(ACCOUNTS_CHANGED_INTENT, new UserHandle(userId),\n                null /* receiverPermission */, ACCOUNTS_CHANGED_OPTIONS);\n    }\n\n    private void sendAccountRemovedBroadcast(\n            Account account, String packageName, int userId, @NonNull String useCase) {\n        Objects.requireNonNull(useCase, \"useCase can't be null\");\n        Log.i(TAG, \"the account with type=\" + account.type + \" removed while useCase=\"\n                + useCase + \" for userId=\" + userId + \", sending broadcast of \"\n                + AccountManager.ACTION_ACCOUNT_REMOVED);\n        Intent intent = new Intent(AccountManager.ACTION_ACCOUNT_REMOVED);\n        intent.setFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);\n        intent.setPackage(packageName);\n        intent.putExtra(AccountManager.KEY_ACCOUNT_NAME, account.name);\n        intent.putExtra(AccountManager.KEY_ACCOUNT_TYPE, account.type);\n        mContext.sendBroadcastAsUser(intent, new UserHandle(userId));\n    }\n\n    @Override\n    public boolean onTransact(int code, Parcel data, Parcel reply, int flags)\n            throws RemoteException {\n        try {\n            return super.onTransact(code, data, reply, flags);\n        } catch (RuntimeException e) {\n            // The account manager only throws security exceptions, so let's\n            // log all others.\n            if (!(e instanceof SecurityException || e instanceof IllegalArgumentException)) {\n                Slog.wtf(TAG, \"Account Manager Crash\", e);\n            }\n            throw e;\n        }\n    }\n\n    private UserManager getUserManager() {\n        if (mUserManager == null) {\n            mUserManager = UserManager.get(mContext);\n        }\n        return mUserManager;\n    }\n\n    /**\n     * Validate internal set of accounts against installed authenticators for\n     * given user. Clears cached authenticators before validating.\n     */\n    public void validateAccounts(int userId) {\n        final UserAccounts accounts = getUserAccounts(userId);\n        // Invalidate user-specific cache to make sure we catch any\n        // removed authenticators.\n        validateAccountsInternal(accounts, true /* invalidateAuthenticatorCache */);\n    }\n\n    /**\n     * Validate internal set of accounts against installed authenticators for\n     * given user. Clear cached authenticators before validating when requested.\n     */\n    private void validateAccountsInternal(\n            UserAccounts accounts, boolean invalidateAuthenticatorCache) {\n        if (Log.isLoggable(TAG, Log.DEBUG)) {\n            Log.d(TAG, \"validateAccountsInternal \" + accounts.userId\n                    + \" isCeDatabaseAttached=\" + accounts.accountsDb.isCeDatabaseAttached()\n                    + \" userLocked=\" + mLocalUnlockedUsers.get(accounts.userId));\n        }\n\n        if (invalidateAuthenticatorCache) {\n            mAuthenticatorCache.invalidateCache(accounts.userId);\n        }\n\n        final HashMap<String, Integer> knownAuth = getAuthenticatorTypeAndUIDForUser(\n                mAuthenticatorCache, accounts.userId);\n        boolean userUnlocked = isLocalUnlockedUser(accounts.userId);\n\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                boolean accountDeleted = false;\n\n                // Get a map of stored authenticator types to UID\n                final AccountsDb accountsDb = accounts.accountsDb;\n                Map<String, Integer> metaAuthUid = accountsDb.findMetaAuthUid();\n                // Create a list of authenticator type whose previous uid no longer exists\n                HashSet<String> obsoleteAuthType = Sets.newHashSet();\n                SparseBooleanArray knownUids = null;\n                for (Entry<String, Integer> authToUidEntry : metaAuthUid.entrySet()) {\n                    String type = authToUidEntry.getKey();\n                    int uid = authToUidEntry.getValue();\n                    Integer knownUid = knownAuth.get(type);\n                    if (knownUid != null && uid == knownUid) {\n                        // Remove it from the knownAuth list if it's unchanged.\n                        knownAuth.remove(type);\n                    } else {\n                    /*\n                     * The authenticator is presently not cached and should only be triggered\n                     * when we think an authenticator has been removed (or is being updated).\n                     * But we still want to check if any data with the associated uid is\n                     * around. This is an (imperfect) signal that the package may be updating.\n                     *\n                     * A side effect of this is that an authenticator sharing a uid with\n                     * multiple apps won't get its credentials wiped as long as some app with\n                     * that uid is still on the device. But I suspect that this is a rare case.\n                     * And it isn't clear to me how an attacker could really exploit that\n                     * feature.\n                     *\n                     * The upshot is that we don't have to worry about accounts getting\n                     * uninstalled while the authenticator's package is being updated.\n                     *\n                     */\n                        if (knownUids == null) {\n                            knownUids = getUidsOfInstalledOrUpdatedPackagesAsUser(accounts.userId);\n                        }\n                        if (!knownUids.get(uid)) {\n                            // The authenticator is not presently available to the cache. And the\n                            // package no longer has a data directory (so we surmise it isn't\n                            // updating). So purge its data from the account databases.\n                            obsoleteAuthType.add(type);\n                            // And delete it from the TABLE_META\n                            accountsDb.deleteMetaByAuthTypeAndUid(type, uid);\n                        } else if (knownUid != null && knownUid != uid) {\n                            Slog.w(TAG, \"authenticator no longer exist for type \" + type);\n                            obsoleteAuthType.add(type);\n                            accountsDb.deleteMetaByAuthTypeAndUid(type, uid);\n                        }\n                    }\n                }\n\n                // Add the newly registered authenticator to TABLE_META. If old authenticators have\n                // been re-enabled (after being updated for example), then we just overwrite the old\n                // values.\n                for (Entry<String, Integer> entry : knownAuth.entrySet()) {\n                    accountsDb.insertOrReplaceMetaAuthTypeAndUid(entry.getKey(), entry.getValue());\n                }\n\n                final Map<Long, Account> accountsMap = accountsDb.findAllDeAccounts();\n                try {\n                    accounts.accountCache.clear();\n                    final HashMap<String, ArrayList<String>> accountNamesByType\n                            = new LinkedHashMap<>();\n                    for (Entry<Long, Account> accountEntry : accountsMap.entrySet()) {\n                        final long accountId = accountEntry.getKey();\n                        final Account account = accountEntry.getValue();\n                        if (obsoleteAuthType.contains(account.type)) {\n                            Slog.w(TAG, \"deleting account \" + account.toSafeString()\n                                    + \" because type \" + account.type\n                                    + \"'s registered authenticator no longer exist.\");\n                            Map<String, Integer> packagesToVisibility =\n                                    getRequestingPackages(account, accounts);\n                            List<String> accountRemovedReceivers =\n                                getAccountRemovedReceivers(account, accounts);\n                            accountsDb.beginTransaction();\n                            try {\n                                accountsDb.deleteDeAccount(accountId);\n                                // Also delete from CE table if user is unlocked; if user is\n                                // currently locked the account will be removed later by\n                                // syncDeCeAccountsLocked\n                                if (userUnlocked) {\n                                    accountsDb.deleteCeAccount(accountId);\n                                }\n                                accountsDb.setTransactionSuccessful();\n                            } finally {\n                                accountsDb.endTransaction();\n                            }\n                            accountDeleted = true;\n                            Log.i(TAG, \"validateAccountsInternal#Deleted UserId=\"\n                                    + accounts.userId + \", AccountId=\" + accountId);\n\n                            logRecord(AccountsDb.DEBUG_ACTION_AUTHENTICATOR_REMOVE,\n                                    AccountsDb.TABLE_ACCOUNTS, accountId, accounts);\n\n                            accounts.userDataCache.remove(account);\n                            accounts.authTokenCache.remove(account);\n                            accounts.accountTokenCaches.remove(account);\n                            accounts.visibilityCache.remove(account);\n\n                            for (Entry<String, Integer> packageToVisibility :\n                                    packagesToVisibility.entrySet()) {\n                                if (isVisible(packageToVisibility.getValue())) {\n                                    notifyPackage(packageToVisibility.getKey(), accounts);\n                                }\n                            }\n                            for (String packageName : accountRemovedReceivers) {\n                                sendAccountRemovedBroadcast(\n                                        account,\n                                        packageName,\n                                        accounts.userId,\n                                        /*useCase=*/\"validateAccounts\");\n                            }\n                        } else {\n                            ArrayList<String> accountNames = accountNamesByType.get(account.type);\n                            if (accountNames == null) {\n                                accountNames = new ArrayList<>();\n                                accountNamesByType.put(account.type, accountNames);\n                            }\n                            accountNames.add(account.name);\n                        }\n                    }\n                    for (Map.Entry<String, ArrayList<String>> cur : accountNamesByType.entrySet()) {\n                        final String accountType = cur.getKey();\n                        final ArrayList<String> accountNames = cur.getValue();\n                        final Account[] accountsForType = new Account[accountNames.size()];\n                        for (int i = 0; i < accountsForType.length; i++) {\n                            accountsForType[i] = new Account(accountNames.get(i), accountType,\n                                    UUID.randomUUID().toString());\n                        }\n                        accounts.accountCache.put(accountType, accountsForType);\n                    }\n                    accounts.visibilityCache.putAll(accountsDb.findAllVisibilityValues());\n                    AccountManager.invalidateLocalAccountsDataCaches();\n                } finally {\n                    if (accountDeleted) {\n                        sendAccountsChangedBroadcast(\n                                accounts.userId,\n                                /*accountType=*/\"ambiguous\",\n                                /*useCase=*/\"validateAccounts\");\n                    }\n                }\n            }\n        }\n    }\n\n    private SparseBooleanArray getUidsOfInstalledOrUpdatedPackagesAsUser(int userId) {\n        // Get the UIDs of all apps that might have data on the device. We want\n        // to preserve user data if the app might otherwise be storing data.\n        List<PackageInfo> pkgsWithData =\n                mPackageManager.getInstalledPackagesAsUser(\n                        PackageManager.MATCH_UNINSTALLED_PACKAGES, userId);\n        SparseBooleanArray knownUids = new SparseBooleanArray(pkgsWithData.size());\n        for (PackageInfo pkgInfo : pkgsWithData) {\n            if (pkgInfo.applicationInfo != null\n                    && (pkgInfo.applicationInfo.flags & ApplicationInfo.FLAG_INSTALLED) != 0) {\n                knownUids.put(pkgInfo.applicationInfo.uid, true);\n            }\n        }\n        return knownUids;\n    }\n\n    static HashMap<String, Integer> getAuthenticatorTypeAndUIDForUser(\n            Context context,\n            int userId) {\n        AccountAuthenticatorCache authCache = new AccountAuthenticatorCache(context);\n        return getAuthenticatorTypeAndUIDForUser(authCache, userId);\n    }\n\n    private static HashMap<String, Integer> getAuthenticatorTypeAndUIDForUser(\n            IAccountAuthenticatorCache authCache,\n            int userId) {\n        HashMap<String, Integer> knownAuth = new LinkedHashMap<>();\n        for (RegisteredServicesCache.ServiceInfo<AuthenticatorDescription> service : authCache\n                .getAllServices(userId)) {\n            knownAuth.put(service.type.type, service.uid);\n        }\n        return knownAuth;\n    }\n\n    private UserAccounts getUserAccountsForCaller() {\n        return getUserAccounts(UserHandle.getCallingUserId());\n    }\n\n    protected UserAccounts getUserAccounts(int userId) {\n        try {\n            return getUserAccountsNotChecked(userId);\n        } catch (RuntimeException e) {\n            if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE)) {\n                // Let it go...\n                throw e;\n            }\n            // User accounts database is corrupted, we must wipe out the whole user, otherwise the\n            // system will crash indefinitely\n            Slog.wtf(TAG, \"Removing user \" + userId + \" due to exception (\" + e + \") reading its \"\n                    + \"account database\");\n            if (userId == ActivityManager.getCurrentUser() && userId != UserHandle.USER_SYSTEM) {\n                Slog.i(TAG, \"Switching to system user first\");\n                try {\n                    ActivityManager.getService().switchUser(UserHandle.USER_SYSTEM);\n                } catch (RemoteException re) {\n                    Slog.e(TAG, \"Could not switch to \" + UserHandle.USER_SYSTEM + \": \" + re);\n                }\n            }\n            if (!getUserManager().removeUserEvenWhenDisallowed(userId)) {\n                Slog.e(TAG, \"could not remove user \" + userId);\n            }\n            throw e;\n        }\n    }\n\n    private UserAccounts getUserAccountsNotChecked(int userId) {\n        synchronized (mUsers) {\n            UserAccounts accounts = mUsers.get(userId);\n            boolean validateAccounts = false;\n            if (accounts == null) {\n                File preNDbFile = new File(mInjector.getPreNDatabaseName(userId));\n                File deDbFile = new File(mInjector.getDeDatabaseName(userId));\n                accounts = new UserAccounts(mContext, userId, preNDbFile, deDbFile);\n                mUsers.append(userId, accounts);\n                purgeOldGrants(accounts);\n                AccountManager.invalidateLocalAccountsDataCaches();\n                validateAccounts = true;\n            }\n            // open CE database if necessary\n            if (!accounts.accountsDb.isCeDatabaseAttached() && mLocalUnlockedUsers.get(userId)) {\n                Log.i(TAG, \"User \" + userId + \" is unlocked - opening CE database\");\n                synchronized (accounts.dbLock) {\n                    synchronized (accounts.cacheLock) {\n                        File ceDatabaseFile = new File(mInjector.getCeDatabaseName(userId));\n                        accounts.accountsDb.attachCeDatabase(ceDatabaseFile);\n                    }\n                }\n                syncDeCeAccountsLocked(accounts);\n            }\n            if (validateAccounts) {\n                validateAccountsInternal(accounts, true /* invalidateAuthenticatorCache */);\n            }\n            return accounts;\n        }\n    }\n\n    private void syncDeCeAccountsLocked(UserAccounts accounts) {\n        Preconditions.checkState(Thread.holdsLock(mUsers), \"mUsers lock must be held\");\n        List<Account> accountsToRemove = accounts.accountsDb.findCeAccountsNotInDe();\n        if (!accountsToRemove.isEmpty()) {\n            Slog.i(TAG, accountsToRemove.size()\n                    + \" accounts were previously deleted while user \"\n                    + accounts.userId + \" was locked. Removing accounts from CE tables\");\n            logRecord(accounts, AccountsDb.DEBUG_ACTION_SYNC_DE_CE_ACCOUNTS,\n                    AccountsDb.TABLE_ACCOUNTS);\n\n            for (Account account : accountsToRemove) {\n                removeAccountInternal(accounts, account, Process.SYSTEM_UID);\n            }\n        }\n    }\n\n    private void purgeOldGrantsAll() {\n        synchronized (mUsers) {\n            for (int i = 0; i < mUsers.size(); i++) {\n                purgeOldGrants(mUsers.valueAt(i));\n            }\n        }\n    }\n\n    private void purgeOldGrants(UserAccounts accounts) {\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                List<Integer> uids;\n                try {\n                    uids = accounts.accountsDb.findAllUidGrants();\n                } catch (SQLiteException e) {\n                    Log.w(TAG, \"Could not delete grants for user = \" + accounts.userId, e);\n                    return;\n                }\n                for (int uid : uids) {\n                    final boolean packageExists = mPackageManager.getPackagesForUid(uid) != null;\n                    if (packageExists) {\n                        continue;\n                    }\n                    Log.d(TAG, \"deleting grants for UID \" + uid\n                            + \" because its package is no longer installed\");\n                    accounts.accountsDb.deleteGrantsByUid(uid);\n                }\n            }\n        }\n    }\n\n    private void removeVisibilityValuesForPackage(String packageName) {\n        if (isSpecialPackageKey(packageName)) {\n            return;\n        }\n        synchronized (mUsers) {\n            int numberOfUsers = mUsers.size();\n            for (int i = 0; i < numberOfUsers; i++) {\n                UserAccounts accounts = mUsers.valueAt(i);\n                try {\n                    mPackageManager.getPackageUidAsUser(packageName, accounts.userId);\n                } catch (NameNotFoundException e) {\n                    // package does not exist - remove visibility values\n                    try {\n                        accounts.accountsDb.deleteAccountVisibilityForPackage(packageName);\n                    } catch (SQLiteCantOpenDatabaseException sqlException) {\n                        Log.w(TAG, \"Could not delete account visibility for user = \"\n                                + accounts.userId, sqlException);\n                        continue;\n                    }\n                    synchronized (accounts.dbLock) {\n                        synchronized (accounts.cacheLock) {\n                            for (Account account : accounts.visibilityCache.keySet()) {\n                                Map<String, Integer> accountVisibility =\n                                        getPackagesAndVisibilityForAccountLocked(account, accounts);\n                                accountVisibility.remove(packageName);\n                            }\n                            AccountManager.invalidateLocalAccountsDataCaches();\n                        }\n                    }\n              }\n          }\n        }\n    }\n\n    private void purgeUserData(int userId) {\n        UserAccounts accounts;\n        synchronized (mUsers) {\n            accounts = mUsers.get(userId);\n            mUsers.remove(userId);\n            mLocalUnlockedUsers.delete(userId);\n            AccountManager.invalidateLocalAccountsDataCaches();\n        }\n        if (accounts != null) {\n            synchronized (accounts.dbLock) {\n                synchronized (accounts.cacheLock) {\n                    accounts.accountsDb.closeDebugStatement();\n                    accounts.accountsDb.close();\n                }\n            }\n        }\n    }\n\n    @VisibleForTesting\n    void onUserUnlocked(Intent intent) {\n        onUnlockUser(intent.getIntExtra(Intent.EXTRA_USER_HANDLE, -1));\n    }\n\n    void onUnlockUser(int userId) {\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"onUserUnlocked \" + userId);\n        }\n        synchronized (mUsers) {\n            mLocalUnlockedUsers.put(userId, true);\n        }\n        if (userId < 1) return;\n        mHandler.post(() -> syncSharedAccounts(userId));\n    }\n\n    private void syncSharedAccounts(int userId) {\n        // Check if there's a shared account that needs to be created as an account\n        Account[] sharedAccounts = getSharedAccountsAsUser(userId);\n        if (sharedAccounts == null || sharedAccounts.length == 0) return;\n        Account[] accounts = getAccountsAsUser(null, userId, mContext.getOpPackageName());\n        int parentUserId = UserHandle.USER_SYSTEM;\n        for (Account sa : sharedAccounts) {\n            if (ArrayUtils.contains(accounts, sa)) continue;\n            // Account doesn't exist. Copy it now.\n            copyAccountToUser(null /*no response*/, sa, parentUserId, userId);\n        }\n    }\n\n    @Override\n    public void onServiceChanged(AuthenticatorDescription desc, int userId, boolean removed) {\n        UserInfo user = getUserManager().getUserInfo(userId);\n        if (user == null) {\n            Log.w(TAG, \"onServiceChanged: ignore removed user \" + userId);\n            return;\n        }\n        validateAccountsInternal(getUserAccounts(userId), false /* invalidateAuthenticatorCache */);\n    }\n\n    @Override\n    public String getPassword(Account account) {\n        int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"getPassword: \" + account\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        if (account == null) throw new IllegalArgumentException(\"account is null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot get secrets for accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return readPasswordInternal(accounts, account);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private String readPasswordInternal(UserAccounts accounts, Account account) {\n        if (account == null) {\n            return null;\n        }\n        if (!isLocalUnlockedUser(accounts.userId)) {\n            Log.w(TAG, \"Password is not available - user \" + accounts.userId + \" data is locked\");\n            return null;\n        }\n\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                return accounts.accountsDb\n                        .findAccountPasswordByNameAndType(account.name, account.type);\n            }\n        }\n    }\n\n    @Override\n    public String getPreviousName(Account account) {\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"getPreviousName: \" + account\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        int userId = UserHandle.getCallingUserId();\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return readPreviousNameInternal(accounts, account);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private String readPreviousNameInternal(UserAccounts accounts, Account account) {\n        if  (account == null) {\n            return null;\n        }\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                AtomicReference<String> previousNameRef = accounts.previousNameCache.get(account);\n                if (previousNameRef == null) {\n                    String previousName = accounts.accountsDb.findDeAccountPreviousName(account);\n                    previousNameRef = new AtomicReference<>(previousName);\n                    accounts.previousNameCache.put(account, previousNameRef);\n                    return previousName;\n                } else {\n                    return previousNameRef.get();\n                }\n            }\n        }\n    }\n\n    @Override\n    public String getUserData(Account account, String key) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            String msg = String.format(\"getUserData( account: %s, key: %s, callerUid: %s, pid: %s\",\n                    account, key, callingUid, Binder.getCallingPid());\n            Log.v(TAG, msg);\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        Objects.requireNonNull(key, \"key cannot be null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot get user data for accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        if (!isLocalUnlockedUser(userId)) {\n            Log.w(TAG, \"User \" + userId + \" data is locked. callingUid \" + callingUid);\n            return null;\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            if (!accountExistsCache(accounts, account)) {\n                return null;\n            }\n            return readUserDataInternal(accounts, account, key);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public AuthenticatorDescription[] getAuthenticatorTypes(int userId) {\n        int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"getAuthenticatorTypes: \"\n                    + \"for user id \" + userId\n                    + \" caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        // Only allow the system process to read accounts of other users\n        if (isCrossUser(callingUid, userId)) {\n            throw new SecurityException(\n                    String.format(\n                            \"User %s tying to get authenticator types for %s\" ,\n                            UserHandle.getCallingUserId(),\n                            userId));\n        }\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            return getAuthenticatorTypesInternal(userId, callingUid);\n\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    /**\n     * Should only be called inside of a clearCallingIdentity block.\n     */\n    private AuthenticatorDescription[] getAuthenticatorTypesInternal(int userId, int callingUid) {\n        mAuthenticatorCache.updateServices(userId);\n        Collection<AccountAuthenticatorCache.ServiceInfo<AuthenticatorDescription>>\n                authenticatorCollection = mAuthenticatorCache.getAllServices(userId);\n        final List<AuthenticatorDescription> types =\n                new ArrayList<>(authenticatorCollection.size());\n        for (AccountAuthenticatorCache.ServiceInfo<AuthenticatorDescription> authenticator\n                : authenticatorCollection) {\n            if (canCallerAccessPackage(authenticator.type.packageName, callingUid, userId)) {\n                types.add(authenticator.type);\n            }\n        }\n        return types.toArray(new AuthenticatorDescription[types.size()]);\n    }\n\n    private boolean isCrossUser(int callingUid, int userId) {\n        return (userId != UserHandle.getCallingUserId()\n                && callingUid != Process.SYSTEM_UID\n                && mContext.checkCallingOrSelfPermission(\n                        android.Manifest.permission.INTERACT_ACROSS_USERS_FULL)\n                                != PackageManager.PERMISSION_GRANTED);\n    }\n\n    @Override\n    public boolean addAccountExplicitly(\n            Account account, String password, Bundle extras, String opPackageName) {\n        return addAccountExplicitlyWithVisibility(\n                account, password, extras, /* packageToVisibility= */ null, opPackageName);\n    }\n\n    @Override\n    public void copyAccountToUser(final IAccountManagerResponse response, final Account account,\n            final int userFrom, int userTo) {\n        int callingUid = Binder.getCallingUid();\n        if (isCrossUser(callingUid, UserHandle.USER_ALL)) {\n            throw new SecurityException(\"Calling copyAccountToUser requires \"\n                    + android.Manifest.permission.INTERACT_ACROSS_USERS_FULL);\n        }\n        final UserAccounts fromAccounts = getUserAccounts(userFrom);\n        final UserAccounts toAccounts = getUserAccounts(userTo);\n        if (fromAccounts == null || toAccounts == null) {\n            if (response != null) {\n                Bundle result = new Bundle();\n                result.putBoolean(AccountManager.KEY_BOOLEAN_RESULT, false);\n                try {\n                    response.onResult(result);\n                } catch (RemoteException e) {\n                    Slog.w(TAG, \"Failed to report error back to the client.\" + e);\n                }\n            }\n            return;\n        }\n\n        Slog.d(TAG, \"Copying account \" + account.toSafeString()\n                + \" from user \" + userFrom + \" to user \" + userTo);\n        final long identityToken = clearCallingIdentity();\n        try {\n            new Session(fromAccounts, response, account.type, false,\n                    false /* stripAuthTokenFromResult */, account.name,\n                    false /* authDetailsRequired */) {\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now) + \", getAccountCredentialsForClone\"\n                            + \", \" + account.type;\n                }\n\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.getAccountCredentialsForCloning(this, account);\n                }\n\n                @Override\n                public void onResult(Bundle result) {\n                    Bundle.setDefusable(result, true);\n                    if (result != null\n                            && result.getBoolean(AccountManager.KEY_BOOLEAN_RESULT, false)) {\n                        // Create a Session for the target user and pass in the bundle\n                        completeCloningAccount(response, result, account, toAccounts, userFrom);\n                    } else {\n                        super.onResult(result);\n                    }\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public boolean accountAuthenticated(final Account account) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            String msg = String.format(\n                    \"accountAuthenticated( account: %s, callerUid: %s)\",\n                    account,\n                    callingUid);\n            Log.v(TAG, msg);\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot notify authentication for accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n\n        if (!canUserModifyAccounts(userId, callingUid) ||\n                !canUserModifyAccountsForType(userId, account.type, callingUid)) {\n            return false;\n        }\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return updateLastAuthenticatedTime(account);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private boolean updateLastAuthenticatedTime(Account account) {\n        final UserAccounts accounts = getUserAccountsForCaller();\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                return accounts.accountsDb.updateAccountLastAuthenticatedTime(account);\n            }\n        }\n    }\n\n    private void completeCloningAccount(IAccountManagerResponse response,\n            final Bundle accountCredentials, final Account account, final UserAccounts targetUser,\n            final int parentUserId){\n        Bundle.setDefusable(accountCredentials, true);\n        final long id = clearCallingIdentity();\n        try {\n            new Session(targetUser, response, account.type, false,\n                    false /* stripAuthTokenFromResult */, account.name,\n                    false /* authDetailsRequired */) {\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now) + \", getAccountCredentialsForClone\"\n                            + \", \" + account.type;\n                }\n\n                @Override\n                public void run() throws RemoteException {\n                    // Confirm that the owner's account still exists before this step.\n                    for (Account acc : getAccounts(parentUserId, mContext.getOpPackageName())) {\n                        if (acc.equals(account)) {\n                            mAuthenticator.addAccountFromCredentials(\n                                    this, account, accountCredentials);\n                            break;\n                        }\n                    }\n                }\n\n                @Override\n                public void onResult(Bundle result) {\n                    Bundle.setDefusable(result, true);\n                    // TODO: Anything to do if if succedded?\n                    // TODO: If it failed: Show error notification? Should we remove the shadow\n                    // account to avoid retries?\n                    // TODO: what we do with the visibility?\n\n                    super.onResult(result);\n                }\n\n                @Override\n                public void onError(int errorCode, String errorMessage) {\n                    super.onError(errorCode,  errorMessage);\n                    // TODO: Show error notification to user\n                    // TODO: Should we remove the shadow account so that it doesn't keep trying?\n                }\n\n            }.bind();\n        } finally {\n            restoreCallingIdentity(id);\n        }\n    }\n\n    private boolean addAccountInternal(UserAccounts accounts, Account account, String password,\n            Bundle extras, int callingUid, Map<String, Integer> packageToVisibility,\n            String opPackageName) {\n        Bundle.setDefusable(extras, true);\n        if (account == null) {\n            return false;\n        }\n        if (account.name != null && account.name.length() > 200) {\n            Log.w(TAG, \"Account cannot be added - Name longer than 200 chars\");\n            return false;\n        }\n        if (account.type != null && account.type.length() > 200) {\n            Log.w(TAG, \"Account cannot be added - Name longer than 200 chars\");\n            return false;\n        }\n        if (!isLocalUnlockedUser(accounts.userId)) {\n            Log.w(TAG, \"Account \" + account.toSafeString() + \" cannot be added - user \"\n                    + accounts.userId + \" is locked. callingUid=\" + callingUid);\n            return false;\n        }\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                accounts.accountsDb.beginTransaction();\n                try {\n                    if (accounts.accountsDb.findCeAccountId(account) >= 0) {\n                        Log.w(TAG, \"insertAccountIntoDatabase: \" + account.toSafeString()\n                                + \", skipping since the account already exists\");\n                        return false;\n                    }\n                    if (accounts.accountsDb.findAllDeAccounts().size() > 100) {\n                        Log.w(TAG, \"insertAccountIntoDatabase: \" + account.toSafeString()\n                                + \", skipping since more than 100 accounts on device exist\");\n                        return false;\n                    }\n                    long accountId = accounts.accountsDb.insertCeAccount(account, password);\n                    if (accountId < 0) {\n                        Log.w(TAG, \"insertAccountIntoDatabase: \" + account.toSafeString()\n                                + \", skipping the DB insert failed\");\n                        return false;\n                    }\n                    // Insert into DE table\n                    if (accounts.accountsDb.insertDeAccount(account, accountId) < 0) {\n                        Log.w(TAG, \"insertAccountIntoDatabase: \" + account.toSafeString()\n                                + \", skipping the DB insert failed\");\n                        return false;\n                    }\n                    if (extras != null) {\n                        for (String key : extras.keySet()) {\n                            final String value = extras.getString(key);\n                            if (accounts.accountsDb.insertExtra(accountId, key, value) < 0) {\n                                Log.w(TAG, \"insertAccountIntoDatabase: \"\n                                        + account.toSafeString()\n                                        + \", skipping since insertExtra failed for key \" + key);\n                                return false;\n                            } else {\n                                AccountManager.invalidateLocalAccountUserDataCaches();\n                            }\n                        }\n                    }\n\n                    if (packageToVisibility != null) {\n                        for (Entry<String, Integer> entry : packageToVisibility.entrySet()) {\n                            setAccountVisibility(account, entry.getKey() /* package */,\n                                    entry.getValue() /* visibility */, false /* notify */,\n                                    accounts, callingUid);\n                        }\n                    }\n                    accounts.accountsDb.setTransactionSuccessful();\n\n                    logRecord(AccountsDb.DEBUG_ACTION_ACCOUNT_ADD, AccountsDb.TABLE_ACCOUNTS,\n                            accountId,\n                            accounts, callingUid);\n\n                    insertAccountIntoCacheLocked(accounts, account);\n                } finally {\n                    accounts.accountsDb.endTransaction();\n                }\n            }\n        }\n        if (getUserManager().getUserInfo(accounts.userId).canHaveProfile()) {\n            addAccountToLinkedRestrictedUsers(account, accounts.userId);\n        }\n\n        sendNotificationAccountUpdated(account, accounts);\n        // Only send LOGIN_ACCOUNTS_CHANGED when the database changed.\n        Log.i(TAG, \"callingUid=\" + callingUid + \", userId=\" + accounts.userId\n                + \" added account\");\n        sendAccountsChangedBroadcast(accounts.userId, account.type, /*useCase=*/\"addAccount\");\n\n        logAddAccountExplicitlyMetrics(opPackageName, account.type, packageToVisibility);\n        return true;\n    }\n\n    private void logAddAccountExplicitlyMetrics(\n            String callerPackage, String accountType,\n            @Nullable Map<String, Integer> accountVisibility) {\n        // Although this is not a 'device policy' API, enterprise is the current use case.\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.ADD_ACCOUNT_EXPLICITLY)\n                .setStrings(\n                        TextUtils.emptyIfNull(accountType),\n                        TextUtils.emptyIfNull(callerPackage),\n                        findPackagesPerVisibility(accountVisibility))\n                .write();\n    }\n\n    private String[] findPackagesPerVisibility(@Nullable Map<String, Integer> accountVisibility) {\n        Map<Integer, Set<String>> packagesPerVisibility = new HashMap<>();\n        if (accountVisibility != null) {\n            for (Entry<String, Integer> entry : accountVisibility.entrySet()) {\n                if (!packagesPerVisibility.containsKey(entry.getValue())) {\n                    packagesPerVisibility.put(entry.getValue(), new HashSet<>());\n                }\n                packagesPerVisibility.get(entry.getValue()).add(entry.getKey());\n            }\n        }\n\n        String[] packagesPerVisibilityStr = new String[5];\n        packagesPerVisibilityStr[AccountManager.VISIBILITY_UNDEFINED] = getPackagesForVisibilityStr(\n                AccountManager.VISIBILITY_UNDEFINED, packagesPerVisibility);\n        packagesPerVisibilityStr[AccountManager.VISIBILITY_VISIBLE] = getPackagesForVisibilityStr(\n                AccountManager.VISIBILITY_VISIBLE, packagesPerVisibility);\n        packagesPerVisibilityStr[AccountManager.VISIBILITY_USER_MANAGED_VISIBLE] =\n                getPackagesForVisibilityStr(\n                        AccountManager.VISIBILITY_USER_MANAGED_VISIBLE, packagesPerVisibility);\n        packagesPerVisibilityStr[AccountManager.VISIBILITY_NOT_VISIBLE] =\n                getPackagesForVisibilityStr(\n                        AccountManager.VISIBILITY_NOT_VISIBLE, packagesPerVisibility);\n        packagesPerVisibilityStr[AccountManager.VISIBILITY_USER_MANAGED_NOT_VISIBLE] =\n                getPackagesForVisibilityStr(\n                        AccountManager.VISIBILITY_USER_MANAGED_NOT_VISIBLE, packagesPerVisibility);\n        return packagesPerVisibilityStr;\n    }\n\n    private String getPackagesForVisibilityStr(\n            int visibility, Map<Integer, Set<String>> packagesPerVisibility) {\n        return visibility + \":\"\n                + (packagesPerVisibility.containsKey(visibility)\n                    ? TextUtils.join(\",\", packagesPerVisibility.get(visibility))\n                    : \"\");\n    }\n\n    private boolean isLocalUnlockedUser(int userId) {\n        synchronized (mUsers) {\n            return mLocalUnlockedUsers.get(userId);\n        }\n    }\n\n    /**\n     * Adds the account to all linked restricted users as shared accounts. If the user is currently\n     * running, then clone the account too.\n     * @param account the account to share with limited users\n     *\n     */\n    private void addAccountToLinkedRestrictedUsers(Account account, int parentUserId) {\n        List<UserInfo> users = getUserManager().getUsers();\n        for (UserInfo user : users) {\n            if (user.isRestricted() && (parentUserId == user.restrictedProfileParentId)) {\n                addSharedAccountAsUser(account, user.id);\n                if (isLocalUnlockedUser(user.id)) {\n                    mHandler.sendMessage(mHandler.obtainMessage(\n                            MESSAGE_COPY_SHARED_ACCOUNT, parentUserId, user.id, account));\n                }\n            }\n        }\n    }\n\n    @Override\n    public void hasFeatures(IAccountManagerResponse response,\n            Account account, String[] features, int userId, String opPackageName) {\n        int callingUid = Binder.getCallingUid();\n        mAppOpsManager.checkPackage(callingUid, opPackageName);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"hasFeatures: \" + account\n                    + \", response \" + response\n                    + \", features \" + Arrays.toString(features)\n                    + \", caller's uid \" + callingUid\n                    + \", userId \" + userId\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Preconditions.checkArgument(account != null, \"account cannot be null\");\n        Preconditions.checkArgument(response != null, \"response cannot be null\");\n        Preconditions.checkArgument(features != null, \"features cannot be null\");\n\n        if (userId != UserHandle.getCallingUserId()\n                && callingUid != Process.SYSTEM_UID\n                && mContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.INTERACT_ACROSS_USERS_FULL)\n                != PackageManager.PERMISSION_GRANTED) {\n            throw new SecurityException(\"User \" + UserHandle.getCallingUserId()\n                    + \" trying to check account features for \" + userId);\n        }\n\n        checkReadAccountsPermitted(callingUid, account.type, userId,\n                opPackageName);\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            new TestFeaturesSession(accounts, response, account, features).bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private class TestFeaturesSession extends Session {\n        private final String[] mFeatures;\n        private final Account mAccount;\n\n        public TestFeaturesSession(UserAccounts accounts, IAccountManagerResponse response,\n                Account account, String[] features) {\n            super(accounts, response, account.type, false /* expectActivityLaunch */,\n                    true /* stripAuthTokenFromResult */, account.name,\n                    false /* authDetailsRequired */);\n            mFeatures = features;\n            mAccount = account;\n        }\n\n        @Override\n        public void run() throws RemoteException {\n            try {\n                mAuthenticator.hasFeatures(this, mAccount, mFeatures);\n            } catch (RemoteException e) {\n                onError(AccountManager.ERROR_CODE_REMOTE_EXCEPTION, \"remote exception\");\n            }\n        }\n\n        @Override\n        public void onResult(Bundle result) {\n            Bundle.setDefusable(result, true);\n            IAccountManagerResponse response = getResponseAndClose();\n            if (response != null) {\n                try {\n                    if (result == null) {\n                        response.onError(AccountManager.ERROR_CODE_INVALID_RESPONSE, \"null bundle\");\n                        return;\n                    }\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, getClass().getSimpleName() + \" calling onResult() on response \"\n                                + response);\n                    }\n                    final Bundle newResult = new Bundle();\n                    newResult.putBoolean(AccountManager.KEY_BOOLEAN_RESULT,\n                            result.getBoolean(AccountManager.KEY_BOOLEAN_RESULT, false));\n                    response.onResult(newResult);\n                } catch (RemoteException e) {\n                    // if the caller is dead then there is no one to care about remote exceptions\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, \"failure while notifying response\", e);\n                    }\n                }\n            }\n        }\n\n        @Override\n        protected String toDebugString(long now) {\n            return super.toDebugString(now) + \", hasFeatures\"\n                    + \", \" + mAccount\n                    + \", \" + (mFeatures != null ? TextUtils.join(\",\", mFeatures) : null);\n        }\n    }\n\n    @Override\n    public void renameAccount(\n            IAccountManagerResponse response, Account accountToRename, String newName) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"renameAccount: \" + accountToRename + \" -> \" + newName\n                + \", caller's uid \" + callingUid\n                + \", pid \" + Binder.getCallingPid());\n        }\n        if (accountToRename == null) throw new IllegalArgumentException(\"account is null\");\n        if (newName != null && newName.length() > 200) {\n            Log.e(TAG, \"renameAccount failed - account name longer than 200\");\n            throw new IllegalArgumentException(\"account name longer than 200\");\n        }\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(accountToRename.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot rename accounts of type: %s\",\n                    callingUid,\n                    accountToRename.type);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            Log.i(TAG, \"callingUid=\" + callingUid + \", userId=\" + accounts.userId\n                    + \" performing rename account\");\n            Account resultingAccount = renameAccountInternal(accounts, accountToRename, newName);\n            if (resultingAccount == null) {\n                resultingAccount = accountToRename;\n            }\n            Bundle result = new Bundle();\n            result.putString(AccountManager.KEY_ACCOUNT_NAME, resultingAccount.name);\n            result.putString(AccountManager.KEY_ACCOUNT_TYPE, resultingAccount.type);\n            result.putString(AccountManager.KEY_ACCOUNT_ACCESS_ID,\n                    resultingAccount.getAccessId());\n            try {\n                response.onResult(result);\n            } catch (RemoteException e) {\n                Log.w(TAG, e.getMessage());\n            }\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private Account renameAccountInternal(\n            UserAccounts accounts, Account accountToRename, String newName) {\n        Account resultAccount = null;\n        /*\n         * Cancel existing notifications. Let authenticators\n         * re-post notifications as required. But we don't know if\n         * the authenticators have bound their notifications to\n         * now stale account name data.\n         *\n         * With a rename api, we might not need to do this anymore but it\n         * shouldn't hurt.\n         */\n        cancelNotification(\n                getSigninRequiredNotificationId(accounts, accountToRename),\n                accounts);\n        synchronized(accounts.credentialsPermissionNotificationIds) {\n            for (Pair<Pair<Account, String>, Integer> pair:\n                    accounts.credentialsPermissionNotificationIds.keySet()) {\n                if (accountToRename.equals(pair.first.first)) {\n                    NotificationId id = accounts.credentialsPermissionNotificationIds.get(pair);\n                    cancelNotification(id, accounts);\n                }\n            }\n        }\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                List<String> accountRemovedReceivers =\n                    getAccountRemovedReceivers(accountToRename, accounts);\n                accounts.accountsDb.beginTransaction();\n                Account renamedAccount = new Account(newName, accountToRename.type);\n                try {\n                    if ((accounts.accountsDb.findCeAccountId(renamedAccount) >= 0)) {\n                        Log.e(TAG, \"renameAccount failed - account with new name already exists\");\n                        return null;\n                    }\n                    final long accountId = accounts.accountsDb.findDeAccountId(accountToRename);\n                    if (accountId >= 0) {\n                        accounts.accountsDb.renameCeAccount(accountId, newName);\n                        if (accounts.accountsDb.renameDeAccount(\n                                accountId, newName, accountToRename.name)) {\n                            accounts.accountsDb.setTransactionSuccessful();\n                        } else {\n                            Log.e(TAG, \"renameAccount failed\");\n                            return null;\n                        }\n                    } else {\n                        Log.e(TAG, \"renameAccount failed - old account does not exist\");\n                        return null;\n                    }\n                } finally {\n                    accounts.accountsDb.endTransaction();\n                }\n            /*\n             * Database transaction was successful. Clean up cached\n             * data associated with the account in the user profile.\n             */\n                renamedAccount = insertAccountIntoCacheLocked(accounts, renamedAccount);\n            /*\n             * Extract the data and token caches before removing the\n             * old account to preserve the user data associated with\n             * the account.\n             */\n                Map<String, String> tmpData = accounts.userDataCache.get(accountToRename);\n                Map<String, String> tmpTokens = accounts.authTokenCache.get(accountToRename);\n                Map<String, Integer> tmpVisibility = accounts.visibilityCache.get(accountToRename);\n                removeAccountFromCacheLocked(accounts, accountToRename);\n            /*\n             * Update the cached data associated with the renamed\n             * account.\n             */\n                accounts.userDataCache.put(renamedAccount, tmpData);\n                accounts.authTokenCache.put(renamedAccount, tmpTokens);\n                accounts.visibilityCache.put(renamedAccount, tmpVisibility);\n                accounts.previousNameCache.put(\n                        renamedAccount,\n                        new AtomicReference<>(accountToRename.name));\n                resultAccount = renamedAccount;\n\n                int parentUserId = accounts.userId;\n                if (canHaveProfile(parentUserId)) {\n                /*\n                 * Owner or system user account was renamed, rename the account for\n                 * those users with which the account was shared.\n                 */\n                    List<UserInfo> users = getUserManager().getAliveUsers();\n                    for (UserInfo user : users) {\n                        if (user.isRestricted()\n                                && (user.restrictedProfileParentId == parentUserId)) {\n                            renameSharedAccountAsUser(accountToRename, newName, user.id);\n                        }\n                    }\n                }\n\n                sendNotificationAccountUpdated(resultAccount, accounts);\n                sendAccountsChangedBroadcast(\n                        accounts.userId, accountToRename.type, /*useCase=*/\"renameAccount\");\n                for (String packageName : accountRemovedReceivers) {\n                    sendAccountRemovedBroadcast(\n                            accountToRename,\n                            packageName,\n                            accounts.userId,\n                            /*useCase=*/\"renameAccount\");\n                }\n\n                AccountManager.invalidateLocalAccountsDataCaches();\n                AccountManager.invalidateLocalAccountUserDataCaches();\n            }\n        }\n        return resultAccount;\n    }\n\n    private boolean canHaveProfile(final int parentUserId) {\n        final UserInfo userInfo = getUserManager().getUserInfo(parentUserId);\n        return userInfo != null && userInfo.canHaveProfile();\n    }\n\n    @Override\n    public void removeAccountAsUser(IAccountManagerResponse response, Account account,\n            boolean expectActivityLaunch, int userId) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"removeAccount: \" + account\n                    + \", response \" + response\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid()\n                    + \", for user id \" + userId);\n        }\n        Preconditions.checkArgument(account != null, \"account cannot be null\");\n        Preconditions.checkArgument(response != null, \"response cannot be null\");\n\n        // Only allow the system process to modify accounts of other users\n        if (isCrossUser(callingUid, userId)) {\n            throw new SecurityException(\n                    String.format(\n                            \"User %s tying remove account for %s\" ,\n                            UserHandle.getCallingUserId(),\n                            userId));\n        }\n        /*\n         * Only the system, authenticator or profile owner should be allowed to remove accounts for\n         * that authenticator.  This will let users remove accounts (via Settings in the system) but\n         * not arbitrary applications (like competing authenticators).\n         */\n        UserHandle user = UserHandle.of(userId);\n        if (!isAccountManagedByCaller(account.type, callingUid, user.getIdentifier())\n                && !isSystemUid(callingUid)\n                && !isProfileOwner(callingUid)) {\n            String msg = String.format(\n                    \"uid %s cannot remove accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        if (!canUserModifyAccounts(userId, callingUid)) {\n            try {\n                response.onError(AccountManager.ERROR_CODE_USER_RESTRICTED,\n                        \"User cannot modify accounts\");\n            } catch (RemoteException re) {\n            }\n            return;\n        }\n        if (!canUserModifyAccountsForType(userId, account.type, callingUid)) {\n            try {\n                response.onError(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                        \"User cannot modify accounts of this type (policy).\");\n            } catch (RemoteException re) {\n                Log.w(TAG, \"RemoteException while removing account\", re);\n            }\n            return;\n        }\n        if (isFirstAccountRemovalDisabled(account)) {\n            try {\n                response.onError(\n                        AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                        \"User cannot remove the first \"\n                                + account.type\n                                + \" account on the device.\");\n            } catch (RemoteException re) {\n                Log.w(TAG, \"RemoteException while removing account\", re);\n            }\n            return;\n        }\n        final long identityToken = clearCallingIdentity();\n        UserAccounts accounts = getUserAccounts(userId);\n        cancelNotification(getSigninRequiredNotificationId(accounts, account), accounts);\n        synchronized(accounts.credentialsPermissionNotificationIds) {\n            for (Pair<Pair<Account, String>, Integer> pair:\n                accounts.credentialsPermissionNotificationIds.keySet()) {\n                if (account.equals(pair.first.first)) {\n                    NotificationId id = accounts.credentialsPermissionNotificationIds.get(pair);\n                    cancelNotification(id, accounts);\n                }\n            }\n        }\n        final long accountId = accounts.accountsDb.findDeAccountId(account);\n        logRecord(\n                AccountsDb.DEBUG_ACTION_CALLED_ACCOUNT_REMOVE,\n                AccountsDb.TABLE_ACCOUNTS,\n                accountId,\n                accounts,\n                callingUid);\n        try {\n            new RemoveAccountSession(accounts, response, account, expectActivityLaunch).bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public boolean removeAccountExplicitly(Account account) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"removeAccountExplicitly: \" + account\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        int userId = Binder.getCallingUserHandle().getIdentifier();\n        if (account == null) {\n            /*\n             * Null accounts should result in returning false, as per\n             * AccountManage.addAccountExplicitly(...) java doc.\n             */\n            Log.e(TAG, \"account is null\");\n            return false;\n        } else if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot explicitly remove accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        if (isFirstAccountRemovalDisabled(account)) {\n            Log.e(TAG, \"Cannot remove the first \" + account.type + \" account on the device.\");\n            return false;\n        }\n        UserAccounts accounts = getUserAccountsForCaller();\n        final long accountId = accounts.accountsDb.findDeAccountId(account);\n        logRecord(\n                AccountsDb.DEBUG_ACTION_CALLED_ACCOUNT_REMOVE,\n                AccountsDb.TABLE_ACCOUNTS,\n                accountId,\n                accounts,\n                callingUid);\n        final long identityToken = clearCallingIdentity();\n        try {\n            return removeAccountInternal(accounts, account, callingUid);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private class RemoveAccountSession extends Session {\n        final Account mAccount;\n        public RemoveAccountSession(UserAccounts accounts, IAccountManagerResponse response,\n                Account account, boolean expectActivityLaunch) {\n            super(accounts, response, account.type, expectActivityLaunch,\n                    true /* stripAuthTokenFromResult */, account.name,\n                    false /* authDetailsRequired */);\n            mAccount = account;\n        }\n\n        @Override\n        protected String toDebugString(long now) {\n            return super.toDebugString(now) + \", removeAccount\"\n                    + \", account \" + mAccount;\n        }\n\n        @Override\n        public void run() throws RemoteException {\n            mAuthenticator.getAccountRemovalAllowed(this, mAccount);\n        }\n\n        @Override\n        public void onResult(Bundle result) {\n            Bundle.setDefusable(result, true);\n            if (result != null && result.containsKey(AccountManager.KEY_BOOLEAN_RESULT)\n                    && !result.containsKey(AccountManager.KEY_INTENT)) {\n                final boolean removalAllowed = result.getBoolean(AccountManager.KEY_BOOLEAN_RESULT);\n                if (removalAllowed) {\n                    removeAccountInternal(mAccounts, mAccount, getCallingUid());\n                }\n                IAccountManagerResponse response = getResponseAndClose();\n                if (response != null) {\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, getClass().getSimpleName() + \" calling onResult() on response \"\n                                + response);\n                    }\n                    try {\n                        response.onResult(result);\n                    } catch (RemoteException e) {\n                        Slog.e(TAG, \"Error calling onResult()\", e);\n                    }\n                }\n            }\n            super.onResult(result);\n        }\n    }\n\n    @VisibleForTesting\n    protected void removeAccountInternal(Account account) {\n        removeAccountInternal(getUserAccountsForCaller(), account, getCallingUid());\n    }\n\n    private boolean removeAccountInternal(UserAccounts accounts, Account account, int callingUid) {\n        boolean isChanged = false;\n        boolean userUnlocked = isLocalUnlockedUser(accounts.userId);\n        if (!userUnlocked) {\n            Slog.i(TAG, \"Removing account \" + account.toSafeString()\n                    + \" while user \" + accounts.userId\n                    + \" is still locked. CE data will be removed later\");\n        }\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                Map<String, Integer> packagesToVisibility = getRequestingPackages(account,\n                        accounts);\n                List<String> accountRemovedReceivers =\n                    getAccountRemovedReceivers(account, accounts);\n                accounts.accountsDb.beginTransaction();\n                // Set to a placeholder value, this will only be used if the database\n                // transaction succeeds.\n                long accountId = -1;\n                try {\n                    accountId = accounts.accountsDb.findDeAccountId(account);\n                    if (accountId >= 0) {\n                        isChanged = accounts.accountsDb.deleteDeAccount(accountId);\n                    }\n                    // always delete from CE table if CE storage is available\n                    // DE account could be removed while CE was locked\n                    if (userUnlocked) {\n                        long ceAccountId = accounts.accountsDb.findCeAccountId(account);\n                        if (ceAccountId >= 0) {\n                            accounts.accountsDb.deleteCeAccount(ceAccountId);\n                        }\n                    }\n                    accounts.accountsDb.setTransactionSuccessful();\n                } finally {\n                    accounts.accountsDb.endTransaction();\n                }\n                if (isChanged) {\n                    removeAccountFromCacheLocked(accounts, account);\n                    for (Entry<String, Integer> packageToVisibility : packagesToVisibility\n                            .entrySet()) {\n                        if ((packageToVisibility.getValue() == AccountManager.VISIBILITY_VISIBLE)\n                                || (packageToVisibility.getValue()\n                                    == AccountManager.VISIBILITY_USER_MANAGED_VISIBLE)) {\n                            notifyPackage(packageToVisibility.getKey(), accounts);\n                        }\n                    }\n\n                    // Only broadcast LOGIN_ACCOUNTS_CHANGED if a change occurred.\n                    Log.i(TAG, \"callingUid=\" + callingUid + \", userId=\" + accounts.userId\n                            + \" removed account\");\n                    sendAccountsChangedBroadcast(\n                            accounts.userId, account.type, /*useCase=*/\"removeAccount\");\n                    for (String packageName : accountRemovedReceivers) {\n                        sendAccountRemovedBroadcast(\n                                account, packageName, accounts.userId, /*useCase=*/\"removeAccount\");\n                    }\n                    String action = userUnlocked ? AccountsDb.DEBUG_ACTION_ACCOUNT_REMOVE\n                            : AccountsDb.DEBUG_ACTION_ACCOUNT_REMOVE_DE;\n                    logRecord(action, AccountsDb.TABLE_ACCOUNTS, accountId, accounts);\n                }\n            }\n        }\n        final long id = Binder.clearCallingIdentity();\n        try {\n            int parentUserId = accounts.userId;\n            if (canHaveProfile(parentUserId)) {\n                // Remove from any restricted profiles that are sharing this account.\n                List<UserInfo> users = getUserManager().getAliveUsers();\n                for (UserInfo user : users) {\n                    if (user.isRestricted() && parentUserId == (user.restrictedProfileParentId)) {\n                        removeSharedAccountAsUser(account, user.id, callingUid);\n                    }\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(id);\n        }\n\n        if (isChanged) {\n            synchronized (accounts.credentialsPermissionNotificationIds) {\n                for (Pair<Pair<Account, String>, Integer> key\n                        : accounts.credentialsPermissionNotificationIds.keySet()) {\n                    if (account.equals(key.first.first)\n                            && AccountManager.ACCOUNT_ACCESS_TOKEN_TYPE.equals(key.first.second)) {\n                        final int uid = (Integer) key.second;\n                        mHandler.post(() -> cancelAccountAccessRequestNotificationIfNeeded(\n                                account, uid, false, accounts));\n                    }\n                }\n            }\n        }\n\n        AccountManager.invalidateLocalAccountUserDataCaches();\n\n        return isChanged;\n    }\n\n    @Override\n    public void invalidateAuthToken(String accountType, String authToken) {\n        int callerUid = Binder.getCallingUid();\n        Objects.requireNonNull(accountType, \"accountType cannot be null\");\n        Objects.requireNonNull(authToken, \"authToken cannot be null\");\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"invalidateAuthToken: accountType \" + accountType\n                    + \", caller's uid \" + callerUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        int userId = UserHandle.getCallingUserId();\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            List<Pair<Account, String>> deletedTokens;\n            synchronized (accounts.dbLock) {\n                accounts.accountsDb.beginTransaction();\n                try {\n                    deletedTokens = invalidateAuthTokenLocked(accounts, accountType, authToken);\n                    accounts.accountsDb.setTransactionSuccessful();\n                } finally {\n                    accounts.accountsDb.endTransaction();\n                }\n                synchronized (accounts.cacheLock) {\n                    for (Pair<Account, String> tokenInfo : deletedTokens) {\n                        Account act = tokenInfo.first;\n                        String tokenType = tokenInfo.second;\n                        writeAuthTokenIntoCacheLocked(accounts, act, tokenType, null);\n                    }\n                    // wipe out cached token in memory.\n                    accounts.accountTokenCaches.remove(accountType, authToken);\n                }\n            }\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private List<Pair<Account, String>> invalidateAuthTokenLocked(UserAccounts accounts, String accountType,\n            String authToken) {\n        // TODO Move to AccountsDB\n        List<Pair<Account, String>> results = new ArrayList<>();\n        Cursor cursor = accounts.accountsDb.findAuthtokenForAllAccounts(accountType, authToken);\n\n        try {\n            while (cursor.moveToNext()) {\n                String authTokenId = cursor.getString(0);\n                String accountName = cursor.getString(1);\n                String authTokenType = cursor.getString(2);\n                accounts.accountsDb.deleteAuthToken(authTokenId);\n                results.add(Pair.create(new Account(accountName, accountType), authTokenType));\n            }\n        } finally {\n            cursor.close();\n        }\n        return results;\n    }\n\n    private void saveCachedToken(\n            UserAccounts accounts,\n            Account account,\n            String callerPkg,\n            byte[] callerSigDigest,\n            String tokenType,\n            String token,\n            long expiryMillis) {\n\n        if (account == null || tokenType == null || callerPkg == null || callerSigDigest == null) {\n            return;\n        }\n        cancelNotification(getSigninRequiredNotificationId(accounts, account), accounts);\n        synchronized (accounts.cacheLock) {\n            accounts.accountTokenCaches.put(\n                    account, token, tokenType, callerPkg, callerSigDigest, expiryMillis);\n        }\n    }\n\n    private boolean saveAuthTokenToDatabase(UserAccounts accounts, Account account, String type,\n            String authToken) {\n        if (account == null || type == null) {\n            return false;\n        }\n        cancelNotification(getSigninRequiredNotificationId(accounts, account), accounts);\n        synchronized (accounts.dbLock) {\n            accounts.accountsDb.beginTransaction();\n            boolean updateCache = false;\n            try {\n                long accountId = accounts.accountsDb.findDeAccountId(account);\n                if (accountId < 0) {\n                    return false;\n                }\n                accounts.accountsDb.deleteAuthtokensByAccountIdAndType(accountId, type);\n                if (accounts.accountsDb.insertAuthToken(accountId, type, authToken) >= 0) {\n                    accounts.accountsDb.setTransactionSuccessful();\n                    updateCache = true;\n                    return true;\n                }\n                return false;\n            } finally {\n                accounts.accountsDb.endTransaction();\n                if (updateCache) {\n                    synchronized (accounts.cacheLock) {\n                        writeAuthTokenIntoCacheLocked(accounts, account, type, authToken);\n                    }\n                }\n            }\n        }\n    }\n\n    @Override\n    public String peekAuthToken(Account account, String authTokenType) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"peekAuthToken: \" + account\n                    + \", authTokenType \" + authTokenType\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        Objects.requireNonNull(authTokenType, \"authTokenType cannot be null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot peek the authtokens associated with accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        if (!isLocalUnlockedUser(userId)) {\n            Log.w(TAG, \"Authtoken not available - user \" + userId + \" data is locked. callingUid \"\n                    + callingUid);\n            return null;\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return readAuthTokenInternal(accounts, account, authTokenType);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void setAuthToken(Account account, String authTokenType, String authToken) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"setAuthToken: \" + account\n                    + \", authTokenType \" + authTokenType\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        Objects.requireNonNull(authTokenType, \"authTokenType cannot be null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot set auth tokens associated with accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            saveAuthTokenToDatabase(accounts, account, authTokenType, authToken);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void setPassword(Account account, String password) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"setAuthToken: \" + account\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot set secrets for accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            setPasswordInternal(accounts, account, password, callingUid);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private void setPasswordInternal(UserAccounts accounts, Account account, String password,\n            int callingUid) {\n        if (account == null) {\n            return;\n        }\n        boolean isChanged = false;\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                accounts.accountsDb.beginTransaction();\n                try {\n                    final long accountId = accounts.accountsDb.findDeAccountId(account);\n                    if (accountId >= 0) {\n                        accounts.accountsDb.updateCeAccountPassword(accountId, password);\n                        accounts.accountsDb.deleteAuthTokensByAccountId(accountId);\n                        accounts.authTokenCache.remove(account);\n                        accounts.accountTokenCaches.remove(account);\n                        accounts.accountsDb.setTransactionSuccessful();\n                        // If there is an account whose password will be updated and the database\n                        // transactions succeed, then we say that a change has occured. Even if the\n                        // new password is the same as the old and there were no authtokens to\n                        // delete.\n                        isChanged = true;\n                        String action = (password == null || password.length() == 0) ?\n                                AccountsDb.DEBUG_ACTION_CLEAR_PASSWORD\n                                : AccountsDb.DEBUG_ACTION_SET_PASSWORD;\n                        logRecord(action, AccountsDb.TABLE_ACCOUNTS, accountId, accounts,\n                                callingUid);\n                    }\n                } finally {\n                    accounts.accountsDb.endTransaction();\n                    if (isChanged) {\n                        // Send LOGIN_ACCOUNTS_CHANGED only if the something changed.\n                        sendNotificationAccountUpdated(account, accounts);\n                        Log.i(TAG, \"callingUid=\" + callingUid + \" changed password\");\n                        sendAccountsChangedBroadcast(\n                                accounts.userId, account.type, /*useCase=*/\"setPassword\");\n                    }\n                }\n            }\n        }\n    }\n\n    @Override\n    public void clearPassword(Account account) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"clearPassword: \" + account\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot clear passwords for accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            setPasswordInternal(accounts, account, null, callingUid);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void setUserData(Account account, String key, String value) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"setUserData: \" + account\n                    + \", key \" + key\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        if (key == null) throw new IllegalArgumentException(\"key is null\");\n        if (account == null) throw new IllegalArgumentException(\"account is null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot set user data for accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            if (!accountExistsCache(accounts, account)) {\n                return;\n            }\n            setUserdataInternal(accounts, account, key, value);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private boolean accountExistsCache(UserAccounts accounts, Account account) {\n        synchronized (accounts.cacheLock) {\n            if (accounts.accountCache.containsKey(account.type)) {\n                for (Account acc : accounts.accountCache.get(account.type)) {\n                    if (acc.name.equals(account.name)) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    private void setUserdataInternal(UserAccounts accounts, Account account, String key,\n            String value) {\n        synchronized (accounts.dbLock) {\n            accounts.accountsDb.beginTransaction();\n            try {\n                long accountId = accounts.accountsDb.findDeAccountId(account);\n                if (accountId < 0) {\n                    return;\n                }\n                long extrasId = accounts.accountsDb.findExtrasIdByAccountId(accountId, key);\n                if (extrasId < 0) {\n                    extrasId = accounts.accountsDb.insertExtra(accountId, key, value);\n                    if (extrasId < 0) {\n                        return;\n                    }\n                } else if (!accounts.accountsDb.updateExtra(extrasId, value)) {\n                    return;\n                }\n                accounts.accountsDb.setTransactionSuccessful();\n            } finally {\n                accounts.accountsDb.endTransaction();\n            }\n            synchronized (accounts.cacheLock) {\n                writeUserDataIntoCacheLocked(accounts, account, key, value);\n                AccountManager.invalidateLocalAccountUserDataCaches();\n            }\n        }\n    }\n\n    private void onResult(IAccountManagerResponse response, Bundle result) {\n        if (result == null) {\n            Log.e(TAG, \"the result is unexpectedly null\", new Exception());\n        }\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, getClass().getSimpleName() + \" calling onResult() on response \"\n                    + response);\n        }\n        try {\n            response.onResult(result);\n        } catch (RemoteException e) {\n            // if the caller is dead then there is no one to care about remote\n            // exceptions\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"failure while notifying response\", e);\n            }\n        }\n    }\n\n    @Override\n    public void getAuthTokenLabel(IAccountManagerResponse response, final String accountType,\n                                  final String authTokenType)\n            throws RemoteException {\n        Preconditions.checkArgument(accountType != null, \"accountType cannot be null\");\n        Preconditions.checkArgument(authTokenType != null, \"authTokenType cannot be null\");\n\n        final int callingUid = getCallingUid();\n        clearCallingIdentity();\n        if (UserHandle.getAppId(callingUid) != Process.SYSTEM_UID) {\n            throw new SecurityException(\"can only call from system\");\n        }\n        int userId = UserHandle.getUserId(callingUid);\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            new Session(accounts, response, accountType, false /* expectActivityLaunch */,\n                    false /* stripAuthTokenFromResult */,  null /* accountName */,\n                    false /* authDetailsRequired */) {\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now) + \", getAuthTokenLabel\"\n                            + \", \" + accountType\n                            + \", authTokenType \" + authTokenType;\n                }\n\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.getAuthTokenLabel(this, authTokenType);\n                }\n\n                @Override\n                public void onResult(Bundle result) {\n                    Bundle.setDefusable(result, true);\n                    if (result != null) {\n                        String label = result.getString(AccountManager.KEY_AUTH_TOKEN_LABEL);\n                        Bundle bundle = new Bundle();\n                        bundle.putString(AccountManager.KEY_AUTH_TOKEN_LABEL, label);\n                        super.onResult(bundle);\n                        return;\n                    } else {\n                        super.onResult(result);\n                    }\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void getAuthToken(\n            IAccountManagerResponse response,\n            final Account account,\n            final String authTokenType,\n            final boolean notifyOnAuthFailure,\n            final boolean expectActivityLaunch,\n            final Bundle loginOptions) {\n        Bundle.setDefusable(loginOptions, true);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"getAuthToken: \" + account\n                    + \", response \" + response\n                    + \", authTokenType \" + authTokenType\n                    + \", notifyOnAuthFailure \" + notifyOnAuthFailure\n                    + \", expectActivityLaunch \" + expectActivityLaunch\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Preconditions.checkArgument(response != null, \"response cannot be null\");\n        try {\n            if (account == null) {\n                Slog.w(TAG, \"getAuthToken called with null account\");\n                response.onError(AccountManager.ERROR_CODE_BAD_ARGUMENTS, \"account is null\");\n                return;\n            }\n            if (authTokenType == null) {\n                Slog.w(TAG, \"getAuthToken called with null authTokenType\");\n                response.onError(AccountManager.ERROR_CODE_BAD_ARGUMENTS, \"authTokenType is null\");\n                return;\n            }\n        } catch (RemoteException e) {\n            Slog.w(TAG, \"Failed to report error back to the client.\" + e);\n            return;\n        }\n        int userId = UserHandle.getCallingUserId();\n        final long ident = Binder.clearCallingIdentity();\n        final UserAccounts accounts;\n        final RegisteredServicesCache.ServiceInfo<AuthenticatorDescription> authenticatorInfo;\n        try {\n            accounts = getUserAccounts(userId);\n            authenticatorInfo = mAuthenticatorCache.getServiceInfo(\n                    AuthenticatorDescription.newKey(account.type), accounts.userId);\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n\n        final boolean customTokens =\n                authenticatorInfo != null && authenticatorInfo.type.customTokens;\n\n        // skip the check if customTokens\n        final int callerUid = Binder.getCallingUid();\n        final boolean permissionGranted =\n                customTokens || permissionIsGranted(account, authTokenType, callerUid, userId);\n\n        // Get the calling package. We will use it for the purpose of caching.\n        final String callerPkg = loginOptions.getString(AccountManager.KEY_ANDROID_PACKAGE_NAME);\n        String[] callerOwnedPackageNames;\n        final long ident2 = Binder.clearCallingIdentity();\n        try {\n            callerOwnedPackageNames = mPackageManager.getPackagesForUid(callerUid);\n        } finally {\n            Binder.restoreCallingIdentity(ident2);\n        }\n        if (callerPkg == null || callerOwnedPackageNames == null\n                || !ArrayUtils.contains(callerOwnedPackageNames, callerPkg)) {\n            String msg = String.format(\n                    \"Uid %s is attempting to illegally masquerade as package %s!\",\n                    callerUid,\n                    callerPkg);\n            throw new SecurityException(msg);\n        }\n\n        // let authenticator know the identity of the caller\n        loginOptions.putInt(AccountManager.KEY_CALLER_UID, callerUid);\n        loginOptions.putInt(AccountManager.KEY_CALLER_PID, Binder.getCallingPid());\n\n        if (notifyOnAuthFailure) {\n            loginOptions.putBoolean(AccountManager.KEY_NOTIFY_ON_FAILURE, true);\n        }\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            // Distill the caller's package signatures into a single digest.\n            final byte[] callerPkgSigDigest = calculatePackageSignatureDigest(callerPkg, userId);\n\n            // if the caller has permission, do the peek. otherwise go the more expensive\n            // route of starting a Session\n            if (!customTokens && permissionGranted) {\n                String authToken = readAuthTokenInternal(accounts, account, authTokenType);\n                if (authToken != null) {\n                    logGetAuthTokenMetrics(callerPkg, account.type);\n                    Bundle result = new Bundle();\n                    result.putString(AccountManager.KEY_AUTHTOKEN, authToken);\n                    result.putString(AccountManager.KEY_ACCOUNT_NAME, account.name);\n                    result.putString(AccountManager.KEY_ACCOUNT_TYPE, account.type);\n                    onResult(response, result);\n                    return;\n                }\n            }\n\n            if (customTokens) {\n                /*\n                 * Look up tokens in the new cache only if the loginOptions don't have parameters\n                 * outside of those expected to be injected by the AccountManager, e.g.\n                 * ANDORID_PACKAGE_NAME.\n                 */\n                TokenCache.Value cachedToken = readCachedTokenInternal(\n                        accounts,\n                        account,\n                        authTokenType,\n                        callerPkg,\n                        callerPkgSigDigest);\n                if (cachedToken != null) {\n                    logGetAuthTokenMetrics(callerPkg, account.type);\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, \"getAuthToken: cache hit ofr custom token authenticator.\");\n                    }\n                    Bundle result = new Bundle();\n                    result.putString(AccountManager.KEY_AUTHTOKEN, cachedToken.token);\n                    result.putLong(AbstractAccountAuthenticator.KEY_CUSTOM_TOKEN_EXPIRY,\n                            cachedToken.expiryEpochMillis);\n                    result.putString(AccountManager.KEY_ACCOUNT_NAME, account.name);\n                    result.putString(AccountManager.KEY_ACCOUNT_TYPE, account.type);\n                    onResult(response, result);\n                    return;\n                }\n            }\n\n            new Session(\n                    accounts,\n                    response,\n                    account.type,\n                    expectActivityLaunch,\n                    false /* stripAuthTokenFromResult */,\n                    account.name,\n                    false /* authDetailsRequired */) {\n                @Override\n                protected String toDebugString(long now) {\n                    if (loginOptions != null) loginOptions.keySet();\n                    return super.toDebugString(now) + \", getAuthToken\"\n                            + \", \" + account.toSafeString()\n                            + \", authTokenType \" + authTokenType\n                            + \", loginOptions \" + loginOptions\n                            + \", notifyOnAuthFailure \" + notifyOnAuthFailure;\n                }\n\n                @Override\n                public void run() throws RemoteException {\n                    // If the caller doesn't have permission then create and return the\n                    // \"grant permission\" intent instead of the \"getAuthToken\" intent.\n                    if (!permissionGranted) {\n                        mAuthenticator.getAuthTokenLabel(this, authTokenType);\n                    } else {\n                        mAuthenticator.getAuthToken(this, account, authTokenType, loginOptions);\n                        logGetAuthTokenMetrics(callerPkg, account.type);\n                    }\n                }\n\n                @Override\n                public void onResult(Bundle result) {\n                    Bundle.setDefusable(result, true);\n                    if (result != null) {\n                        if (result.containsKey(AccountManager.KEY_AUTH_TOKEN_LABEL)) {\n                            Intent intent = newGrantCredentialsPermissionIntent(\n                                    account,\n                                    null,\n                                    callerUid,\n                                    new AccountAuthenticatorResponse(this),\n                                    authTokenType,\n                                    true);\n                            mCanStartAccountManagerActivity = true;\n                            Bundle bundle = new Bundle();\n                            bundle.putParcelable(AccountManager.KEY_INTENT, intent);\n                            onResult(bundle);\n                            return;\n                        }\n                        String authToken = result.getString(AccountManager.KEY_AUTHTOKEN);\n                        if (authToken != null) {\n                            String name = result.getString(AccountManager.KEY_ACCOUNT_NAME);\n                            String type = result.getString(AccountManager.KEY_ACCOUNT_TYPE);\n                            if (TextUtils.isEmpty(type) || TextUtils.isEmpty(name)) {\n                                onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                                        \"the type and name should not be empty\");\n                                return;\n                            }\n                            Account resultAccount = new Account(name, type);\n                            if (!customTokens) {\n                                saveAuthTokenToDatabase(\n                                        mAccounts,\n                                        resultAccount,\n                                        authTokenType,\n                                        authToken);\n                            }\n                            long expiryMillis = result.getLong(\n                                    AbstractAccountAuthenticator.KEY_CUSTOM_TOKEN_EXPIRY, 0L);\n                            if (customTokens\n                                    && expiryMillis > System.currentTimeMillis()) {\n                                saveCachedToken(\n                                        mAccounts,\n                                        account,\n                                        callerPkg,\n                                        callerPkgSigDigest,\n                                        authTokenType,\n                                        authToken,\n                                        expiryMillis);\n                            }\n                        }\n\n                        Intent intent = result.getParcelable(AccountManager.KEY_INTENT, android.content.Intent.class);\n                        if (intent != null && notifyOnAuthFailure && !customTokens) {\n                            /*\n                             * Make sure that the supplied intent is owned by the authenticator\n                             * giving it to the system. Otherwise a malicious authenticator could\n                             * have users launching arbitrary activities by tricking users to\n                             * interact with malicious notifications.\n                             */\n                            if (!checkKeyIntent(\n                                    Binder.getCallingUid(),\n                                    result)) {\n                                onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                                        \"invalid intent in bundle returned\");\n                                return;\n                            }\n                            doNotification(\n                                    mAccounts,\n                                    account,\n                                    result.getString(AccountManager.KEY_AUTH_FAILED_MESSAGE),\n                                    intent, \"android\", accounts.userId);\n                        }\n                    }\n                    super.onResult(result);\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private void logGetAuthTokenMetrics(final String callerPackage, String accountType) {\n        // Although this is not a 'device policy' API, enterprise is the current use case.\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.GET_ACCOUNT_AUTH_TOKEN)\n                .setStrings(\n                        TextUtils.emptyIfNull(callerPackage),\n                        TextUtils.emptyIfNull(accountType))\n                .write();\n    }\n\n    private byte[] calculatePackageSignatureDigest(String callerPkg, int userId) {\n        MessageDigest digester;\n        try {\n            digester = MessageDigest.getInstance(\"SHA-256\");\n            PackageInfo pkgInfo = mPackageManager.getPackageInfoAsUser(\n                    callerPkg, PackageManager.GET_SIGNATURES, userId);\n            for (Signature sig : pkgInfo.signatures) {\n                digester.update(sig.toByteArray());\n            }\n        } catch (NoSuchAlgorithmException x) {\n            Log.wtf(TAG, \"SHA-256 should be available\", x);\n            digester = null;\n        } catch (NameNotFoundException e) {\n            Log.w(TAG, \"Could not find packageinfo for: \" + callerPkg);\n            digester = null;\n        }\n        return (digester == null) ? null : digester.digest();\n    }\n\n    private void createNoCredentialsPermissionNotification(Account account, Intent intent,\n            String packageName, UserAccounts accounts) {\n        int userId = accounts.userId;\n        int uid = intent.getIntExtra(\n                GrantCredentialsPermissionActivity.EXTRAS_REQUESTING_UID, -1);\n        String authTokenType = intent.getStringExtra(\n                GrantCredentialsPermissionActivity.EXTRAS_AUTH_TOKEN_TYPE);\n        final String titleAndSubtitle =\n                mContext.getString(R.string.permission_request_notification_for_app_with_subtitle,\n                getApplicationLabel(packageName, userId), account.name);\n        final int index = titleAndSubtitle.indexOf('\\n');\n        String title = titleAndSubtitle;\n        String subtitle = \"\";\n        if (index > 0) {\n            title = titleAndSubtitle.substring(0, index);\n            subtitle = titleAndSubtitle.substring(index + 1);\n        }\n        UserHandle user = UserHandle.of(userId);\n        Context contextForUser = getContextForUser(user);\n        Notification n =\n                new Notification.Builder(contextForUser, SystemNotificationChannels.ACCOUNT)\n                    .setSmallIcon(android.R.drawable.stat_sys_warning)\n                    .setWhen(0)\n                    .setColor(contextForUser.getColor(\n                            com.android.internal.R.color.system_notification_accent_color))\n                    .setContentTitle(title)\n                    .setContentText(subtitle)\n                    .setContentIntent(PendingIntent.getActivityAsUser(mContext, 0, intent,\n                            PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_IMMUTABLE,\n                            null, user))\n                    .build();\n        installNotification(getCredentialPermissionNotificationId(\n                account, authTokenType, uid, accounts), n, \"android\", user.getIdentifier());\n    }\n\n    private String getApplicationLabel(String packageName, int userId) {\n        try {\n            return mPackageManager.getApplicationLabel(\n                    mPackageManager.getApplicationInfoAsUser(packageName, 0, userId)).toString();\n        } catch (PackageManager.NameNotFoundException e) {\n            return packageName;\n        }\n    }\n\n    private Intent newGrantCredentialsPermissionIntent(Account account, String packageName,\n            int uid, AccountAuthenticatorResponse response, String authTokenType,\n            boolean startInNewTask) {\n\n        Intent intent = new Intent(mContext, GrantCredentialsPermissionActivity.class);\n\n        if (startInNewTask) {\n            // See FLAG_ACTIVITY_NEW_TASK docs for limitations and benefits of the flag.\n            // Since it was set in Eclair+ we can't change it without breaking apps using\n            // the intent from a non-Activity context. This is the default behavior.\n            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        }\n        UserAccounts accounts = getUserAccounts(UserHandle.getUserId(uid));\n        intent.addCategory(getCredentialPermissionNotificationId(account,\n                authTokenType, uid, accounts).mTag + (packageName != null ? packageName : \"\"));\n        intent.putExtra(GrantCredentialsPermissionActivity.EXTRAS_ACCOUNT, account);\n        intent.putExtra(GrantCredentialsPermissionActivity.EXTRAS_AUTH_TOKEN_TYPE, authTokenType);\n        intent.putExtra(GrantCredentialsPermissionActivity.EXTRAS_RESPONSE, response);\n        intent.putExtra(GrantCredentialsPermissionActivity.EXTRAS_REQUESTING_UID, uid);\n\n        return intent;\n    }\n\n    private NotificationId getCredentialPermissionNotificationId(Account account,\n            String authTokenType, int uid, UserAccounts accounts) {\n        NotificationId nId;\n        synchronized (accounts.credentialsPermissionNotificationIds) {\n            final Pair<Pair<Account, String>, Integer> key =\n                    new Pair<Pair<Account, String>, Integer>(\n                            new Pair<Account, String>(account, authTokenType), uid);\n            nId = accounts.credentialsPermissionNotificationIds.get(key);\n            if (nId == null) {\n                String tag = TAG + \":\" + SystemMessage.NOTE_ACCOUNT_CREDENTIAL_PERMISSION\n                        + \":\" + account.hashCode() + \":\" + authTokenType.hashCode() + \":\" + uid;\n                int id = SystemMessage.NOTE_ACCOUNT_CREDENTIAL_PERMISSION;\n                nId = new NotificationId(tag, id);\n                accounts.credentialsPermissionNotificationIds.put(key, nId);\n            }\n        }\n        return nId;\n    }\n\n    private NotificationId getSigninRequiredNotificationId(UserAccounts accounts, Account account) {\n        NotificationId nId;\n        synchronized (accounts.signinRequiredNotificationIds) {\n            nId = accounts.signinRequiredNotificationIds.get(account);\n            if (nId == null) {\n                String tag = TAG + \":\" + SystemMessage.NOTE_ACCOUNT_REQUIRE_SIGNIN\n                        + \":\" + account.hashCode();\n                int id = SystemMessage.NOTE_ACCOUNT_REQUIRE_SIGNIN;\n                nId = new NotificationId(tag, id);\n                accounts.signinRequiredNotificationIds.put(account, nId);\n            }\n        }\n        return nId;\n    }\n\n    @Override\n    public void addAccount(final IAccountManagerResponse response, final String accountType,\n            final String authTokenType, final String[] requiredFeatures,\n            final boolean expectActivityLaunch, final Bundle optionsIn) {\n        Bundle.setDefusable(optionsIn, true);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"addAccount: accountType \" + accountType\n                    + \", response \" + response\n                    + \", authTokenType \" + authTokenType\n                    + \", requiredFeatures \" + Arrays.toString(requiredFeatures)\n                    + \", expectActivityLaunch \" + expectActivityLaunch\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        if (response == null) throw new IllegalArgumentException(\"response is null\");\n        if (accountType == null) throw new IllegalArgumentException(\"accountType is null\");\n\n        // Is user disallowed from modifying accounts?\n        final int uid = Binder.getCallingUid();\n        final int userId = UserHandle.getUserId(uid);\n        if (!canUserModifyAccounts(userId, uid)) {\n            try {\n                response.onError(AccountManager.ERROR_CODE_USER_RESTRICTED,\n                        \"User is not allowed to add an account!\");\n            } catch (RemoteException re) {\n            }\n            showCantAddAccount(AccountManager.ERROR_CODE_USER_RESTRICTED, userId);\n            return;\n        }\n        if (!canUserModifyAccountsForType(userId, accountType, uid)) {\n            try {\n                response.onError(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                        \"User cannot modify accounts of this type (policy).\");\n            } catch (RemoteException re) {\n            }\n            showCantAddAccount(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                    userId);\n            return;\n        }\n        addAccountAndLogMetrics(response, accountType, authTokenType, requiredFeatures,\n                expectActivityLaunch, optionsIn, userId);\n    }\n\n    @Override\n    public void addAccountAsUser(final IAccountManagerResponse response, final String accountType,\n            final String authTokenType, final String[] requiredFeatures,\n            final boolean expectActivityLaunch, final Bundle optionsIn, int userId) {\n        Bundle.setDefusable(optionsIn, true);\n        int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"addAccount: accountType \" + accountType\n                    + \", response \" + response\n                    + \", authTokenType \" + authTokenType\n                    + \", requiredFeatures \" + Arrays.toString(requiredFeatures)\n                    + \", expectActivityLaunch \" + expectActivityLaunch\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid()\n                    + \", for user id \" + userId);\n        }\n        Preconditions.checkArgument(response != null, \"response cannot be null\");\n        Preconditions.checkArgument(accountType != null, \"accountType cannot be null\");\n        // Only allow the system process to add accounts of other users\n        if (isCrossUser(callingUid, userId)) {\n            throw new SecurityException(\n                    String.format(\n                            \"User %s trying to add account for %s\" ,\n                            UserHandle.getCallingUserId(),\n                            userId));\n        }\n\n        // Is user disallowed from modifying accounts?\n        if (!canUserModifyAccounts(userId, callingUid)) {\n            try {\n                response.onError(AccountManager.ERROR_CODE_USER_RESTRICTED,\n                        \"User is not allowed to add an account!\");\n            } catch (RemoteException re) {\n            }\n            showCantAddAccount(AccountManager.ERROR_CODE_USER_RESTRICTED, userId);\n            return;\n        }\n        if (!canUserModifyAccountsForType(userId, accountType, callingUid)) {\n            try {\n                response.onError(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                        \"User cannot modify accounts of this type (policy).\");\n            } catch (RemoteException re) {\n            }\n            showCantAddAccount(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                    userId);\n            return;\n        }\n        addAccountAndLogMetrics(response, accountType, authTokenType, requiredFeatures,\n                expectActivityLaunch, optionsIn, userId);\n    }\n\n    private void addAccountAndLogMetrics(\n            IAccountManagerResponse response, String accountType,\n            String authTokenType, String[] requiredFeatures,\n            boolean expectActivityLaunch, Bundle optionsIn, int userId) {\n        final int pid = Binder.getCallingPid();\n        final int uid = Binder.getCallingUid();\n        final Bundle options = (optionsIn == null) ? new Bundle() : optionsIn;\n        options.putInt(AccountManager.KEY_CALLER_UID, uid);\n        options.putInt(AccountManager.KEY_CALLER_PID, pid);\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            logRecordWithUid(\n                    accounts, AccountsDb.DEBUG_ACTION_CALLED_ACCOUNT_ADD, AccountsDb.TABLE_ACCOUNTS,\n                    uid);\n            new Session(accounts, response, accountType, expectActivityLaunch,\n                    true /* stripAuthTokenFromResult */, null /* accountName */,\n                    false /* authDetailsRequired */, true /* updateLastAuthenticationTime */) {\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.addAccount(\n                            this, mAccountType, authTokenType, requiredFeatures, options);\n                    String callerPackage = options.getString(\n                            AccountManager.KEY_ANDROID_PACKAGE_NAME);\n                    logAddAccountMetrics(\n                            callerPackage, accountType, requiredFeatures, authTokenType);\n                }\n\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now) + \", addAccount\"\n                            + \", accountType \" + accountType\n                            + \", requiredFeatures \"\n                            + (requiredFeatures != null\n                            ? TextUtils.join(\",\", requiredFeatures)\n                            : null);\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private void logAddAccountMetrics(\n            String callerPackage, String accountType, String[] requiredFeatures,\n            String authTokenType) {\n        // Although this is not a 'device policy' API, enterprise is the current use case.\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.ADD_ACCOUNT)\n                .setStrings(\n                        TextUtils.emptyIfNull(accountType),\n                        TextUtils.emptyIfNull(callerPackage),\n                        TextUtils.emptyIfNull(authTokenType),\n                        requiredFeatures == null\n                                ? \"\"\n                                : TextUtils.join(\";\", requiredFeatures))\n                .write();\n    }\n\n    @Override\n    public void startAddAccountSession(\n            final IAccountManagerResponse response,\n            final String accountType,\n            final String authTokenType,\n            final String[] requiredFeatures,\n            final boolean expectActivityLaunch,\n            final Bundle optionsIn) {\n        Bundle.setDefusable(optionsIn, true);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG,\n                    \"startAddAccountSession: accountType \" + accountType\n                    + \", response \" + response\n                    + \", authTokenType \" + authTokenType\n                    + \", requiredFeatures \" + Arrays.toString(requiredFeatures)\n                    + \", expectActivityLaunch \" + expectActivityLaunch\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Preconditions.checkArgument(response != null, \"response cannot be null\");\n        Preconditions.checkArgument(accountType != null, \"accountType cannot be null\");\n\n        final int uid = Binder.getCallingUid();\n        final int userId = UserHandle.getUserId(uid);\n        if (!canUserModifyAccounts(userId, uid)) {\n            try {\n                response.onError(AccountManager.ERROR_CODE_USER_RESTRICTED,\n                        \"User is not allowed to add an account!\");\n            } catch (RemoteException re) {\n            }\n            showCantAddAccount(AccountManager.ERROR_CODE_USER_RESTRICTED, userId);\n            return;\n        }\n        if (!canUserModifyAccountsForType(userId, accountType, uid)) {\n            try {\n                response.onError(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                        \"User cannot modify accounts of this type (policy).\");\n            } catch (RemoteException re) {\n            }\n            showCantAddAccount(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                    userId);\n            return;\n        }\n        final int pid = Binder.getCallingPid();\n        final Bundle options = (optionsIn == null) ? new Bundle() : optionsIn;\n        options.putInt(AccountManager.KEY_CALLER_UID, uid);\n        options.putInt(AccountManager.KEY_CALLER_PID, pid);\n\n        // Check to see if the Password should be included to the caller.\n        String callerPkg = options.getString(AccountManager.KEY_ANDROID_PACKAGE_NAME);\n        boolean isPasswordForwardingAllowed = checkPermissionAndNote(\n                callerPkg, uid, Manifest.permission.GET_PASSWORD);\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            logRecordWithUid(accounts, AccountsDb.DEBUG_ACTION_CALLED_START_ACCOUNT_ADD,\n                    AccountsDb.TABLE_ACCOUNTS, uid);\n            new StartAccountSession(\n                    accounts,\n                    response,\n                    accountType,\n                    expectActivityLaunch,\n                    null /* accountName */,\n                    false /* authDetailsRequired */,\n                    true /* updateLastAuthenticationTime */,\n                    isPasswordForwardingAllowed) {\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.startAddAccountSession(this, mAccountType, authTokenType,\n                            requiredFeatures, options);\n                    logAddAccountMetrics(callerPkg, accountType, requiredFeatures, authTokenType);\n                }\n\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now) + \", startAddAccountSession\" + \", accountType \"\n                            + accountType + \", requiredFeatures \"\n                            + (requiredFeatures != null\n                                ? TextUtils.join(\",\", requiredFeatures) : \"null\");\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    /** Session that will encrypt the KEY_ACCOUNT_SESSION_BUNDLE in result. */\n    private abstract class StartAccountSession extends Session {\n\n        private final boolean mIsPasswordForwardingAllowed;\n\n        public StartAccountSession(\n                UserAccounts accounts,\n                IAccountManagerResponse response,\n                String accountType,\n                boolean expectActivityLaunch,\n                String accountName,\n                boolean authDetailsRequired,\n                boolean updateLastAuthenticationTime,\n                boolean isPasswordForwardingAllowed) {\n            super(accounts, response, accountType, expectActivityLaunch,\n                    true /* stripAuthTokenFromResult */, accountName, authDetailsRequired,\n                    updateLastAuthenticationTime);\n            mIsPasswordForwardingAllowed = isPasswordForwardingAllowed;\n        }\n\n        @Override\n        public void onResult(Bundle result) {\n            Bundle.setDefusable(result, true);\n            mNumResults++;\n            Intent intent = null;\n            if (result != null) {\n                if (!checkKeyIntent(\n                        Binder.getCallingUid(),\n                        result)) {\n                    onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                            \"invalid intent in bundle returned\");\n                    return;\n                }\n            }\n            IAccountManagerResponse response;\n            if (mExpectActivityLaunch && result != null\n                    && result.containsKey(AccountManager.KEY_INTENT)) {\n                response = mResponse;\n            } else {\n                response = getResponseAndClose();\n            }\n            if (response == null) {\n                return;\n            }\n            if (result == null) {\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.v(TAG, getClass().getSimpleName() + \" calling onError() on response \"\n                            + response);\n                }\n                sendErrorResponse(response, AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                        \"null bundle returned\");\n                return;\n            }\n\n            if ((result.getInt(AccountManager.KEY_ERROR_CODE, -1) > 0) && (intent == null)) {\n                // All AccountManager error codes are greater\n                // than 0\n                sendErrorResponse(response, result.getInt(AccountManager.KEY_ERROR_CODE),\n                        result.getString(AccountManager.KEY_ERROR_MESSAGE));\n                return;\n            }\n\n            // Omit passwords if the caller isn't permitted to see them.\n            if (!mIsPasswordForwardingAllowed) {\n                result.remove(AccountManager.KEY_PASSWORD);\n            }\n\n            // Strip auth token from result.\n            result.remove(AccountManager.KEY_AUTHTOKEN);\n            if (!checkKeyIntent(Binder.getCallingUid(), result)) {\n                onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                        \"invalid intent in bundle returned\");\n                return;\n            }\n\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG,\n                        getClass().getSimpleName() + \" calling onResult() on response \" + response);\n            }\n\n            // Get the session bundle created by authenticator. The\n            // bundle contains data necessary for finishing the session\n            // later. The session bundle will be encrypted here and\n            // decrypted later when trying to finish the session.\n            Bundle sessionBundle = result.getBundle(AccountManager.KEY_ACCOUNT_SESSION_BUNDLE);\n            if (sessionBundle != null) {\n                String accountType = sessionBundle.getString(AccountManager.KEY_ACCOUNT_TYPE);\n                if (TextUtils.isEmpty(accountType)\n                        || !mAccountType.equalsIgnoreCase(accountType)) {\n                    Log.w(TAG, \"Account type in session bundle doesn't match request.\");\n                }\n                // Add accountType info to session bundle. This will\n                // override any value set by authenticator.\n                sessionBundle.putString(AccountManager.KEY_ACCOUNT_TYPE, mAccountType);\n\n                // Encrypt session bundle before returning to caller.\n                try {\n                    CryptoHelper cryptoHelper = CryptoHelper.getInstance();\n                    Bundle encryptedBundle = cryptoHelper.encryptBundle(sessionBundle);\n                    result.putBundle(AccountManager.KEY_ACCOUNT_SESSION_BUNDLE, encryptedBundle);\n                } catch (GeneralSecurityException e) {\n                    if (Log.isLoggable(TAG, Log.DEBUG)) {\n                        Log.v(TAG, \"Failed to encrypt session bundle!\", e);\n                    }\n                    sendErrorResponse(response, AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                            \"failed to encrypt session bundle\");\n                    return;\n                }\n            }\n\n            sendResponse(response, result);\n        }\n    }\n\n    @Override\n    public void finishSessionAsUser(IAccountManagerResponse response,\n            @NonNull Bundle sessionBundle,\n            boolean expectActivityLaunch,\n            Bundle appInfo,\n            int userId) {\n        Bundle.setDefusable(sessionBundle, true);\n        int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG,\n                    \"finishSession: response \"+ response\n                            + \", expectActivityLaunch \" + expectActivityLaunch\n                            + \", caller's uid \" + callingUid\n                            + \", caller's user id \" + UserHandle.getCallingUserId()\n                            + \", pid \" + Binder.getCallingPid()\n                            + \", for user id \" + userId);\n        }\n        Preconditions.checkArgument(response != null, \"response cannot be null\");\n        // Session bundle is the encrypted bundle of the original bundle created by authenticator.\n        // Account type is added to it before encryption.\n        if (sessionBundle == null || sessionBundle.size() == 0) {\n            throw new IllegalArgumentException(\"sessionBundle is empty\");\n        }\n\n        // Only allow the system process to finish session for other users.\n        if (isCrossUser(callingUid, userId)) {\n            throw new SecurityException(\n                    String.format(\n                            \"User %s trying to finish session for %s without cross user permission\",\n                            UserHandle.getCallingUserId(),\n                            userId));\n        }\n\n        if (!canUserModifyAccounts(userId, callingUid)) {\n            sendErrorResponse(response,\n                    AccountManager.ERROR_CODE_USER_RESTRICTED,\n                    \"User is not allowed to add an account!\");\n            showCantAddAccount(AccountManager.ERROR_CODE_USER_RESTRICTED, userId);\n            return;\n        }\n\n        final int pid = Binder.getCallingPid();\n        final Bundle decryptedBundle;\n        final String accountType;\n        // First decrypt session bundle to get account type for checking permission.\n        try {\n            CryptoHelper cryptoHelper = CryptoHelper.getInstance();\n            decryptedBundle = cryptoHelper.decryptBundle(sessionBundle);\n            if (decryptedBundle == null) {\n                sendErrorResponse(\n                        response,\n                        AccountManager.ERROR_CODE_BAD_REQUEST,\n                        \"failed to decrypt session bundle\");\n                return;\n            }\n            accountType = decryptedBundle.getString(AccountManager.KEY_ACCOUNT_TYPE);\n            // Account type cannot be null. This should not happen if session bundle was created\n            // properly by #StartAccountSession.\n            if (TextUtils.isEmpty(accountType)) {\n                sendErrorResponse(\n                        response,\n                        AccountManager.ERROR_CODE_BAD_ARGUMENTS,\n                        \"accountType is empty\");\n                return;\n            }\n\n            // If by any chances, decryptedBundle contains colliding keys with\n            // system info\n            // such as AccountManager.KEY_ANDROID_PACKAGE_NAME required by the add account flow or\n            // update credentials flow, we should replace with the new values of the current call.\n            if (appInfo != null) {\n                decryptedBundle.putAll(appInfo);\n            }\n\n            // Add info that may be used by add account or update credentials flow.\n            decryptedBundle.putInt(AccountManager.KEY_CALLER_UID, callingUid);\n            decryptedBundle.putInt(AccountManager.KEY_CALLER_PID, pid);\n        } catch (GeneralSecurityException e) {\n            if (Log.isLoggable(TAG, Log.DEBUG)) {\n                Log.v(TAG, \"Failed to decrypt session bundle!\", e);\n            }\n            sendErrorResponse(\n                    response,\n                    AccountManager.ERROR_CODE_BAD_REQUEST,\n                    \"failed to decrypt session bundle\");\n            return;\n        }\n\n        if (!canUserModifyAccountsForType(userId, accountType, callingUid)) {\n            sendErrorResponse(\n                    response,\n                    AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                    \"User cannot modify accounts of this type (policy).\");\n            showCantAddAccount(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                    userId);\n            return;\n        }\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            logRecordWithUid(\n                    accounts,\n                    AccountsDb.DEBUG_ACTION_CALLED_ACCOUNT_SESSION_FINISH,\n                    AccountsDb.TABLE_ACCOUNTS,\n                    callingUid);\n            new Session(\n                    accounts,\n                    response,\n                    accountType,\n                    expectActivityLaunch,\n                    true /* stripAuthTokenFromResult */,\n                    null /* accountName */,\n                    false /* authDetailsRequired */,\n                    true /* updateLastAuthenticationTime */) {\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.finishSession(this, mAccountType, decryptedBundle);\n                }\n\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now)\n                            + \", finishSession\"\n                            + \", accountType \" + accountType;\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private void showCantAddAccount(int errorCode, int userId) {\n        final DevicePolicyManagerInternal dpmi =\n                LocalServices.getService(DevicePolicyManagerInternal.class);\n        Intent intent = null;\n        if (dpmi == null) {\n            intent = getDefaultCantAddAccountIntent(errorCode);\n        } else if (errorCode == AccountManager.ERROR_CODE_USER_RESTRICTED) {\n            intent = dpmi.createUserRestrictionSupportIntent(userId,\n                    UserManager.DISALLOW_MODIFY_ACCOUNTS);\n        } else if (errorCode == AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE) {\n            intent = dpmi.createShowAdminSupportIntent(userId, false);\n        }\n        if (intent == null) {\n            intent = getDefaultCantAddAccountIntent(errorCode);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            mContext.startActivityAsUser(intent, new UserHandle(userId));\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    /**\n     * Called when we don't know precisely who is preventing us from adding an account.\n     */\n    private Intent getDefaultCantAddAccountIntent(int errorCode) {\n        Intent cantAddAccount = new Intent(mContext, CantAddAccountActivity.class);\n        cantAddAccount.putExtra(CantAddAccountActivity.EXTRA_ERROR_CODE, errorCode);\n        cantAddAccount.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        return cantAddAccount;\n    }\n\n    @Override\n    public void confirmCredentialsAsUser(\n            IAccountManagerResponse response,\n            final Account account,\n            final Bundle options,\n            final boolean expectActivityLaunch,\n            int userId) {\n        Bundle.setDefusable(options, true);\n        int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"confirmCredentials: \" + account\n                    + \", response \" + response\n                    + \", expectActivityLaunch \" + expectActivityLaunch\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        // Only allow the system process to read accounts of other users\n        if (isCrossUser(callingUid, userId)) {\n            throw new SecurityException(\n                    String.format(\n                            \"User %s trying to confirm account credentials for %s\" ,\n                            UserHandle.getCallingUserId(),\n                            userId));\n        }\n        if (response == null) throw new IllegalArgumentException(\"response is null\");\n        if (account == null) throw new IllegalArgumentException(\"account is null\");\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            new Session(accounts, response, account.type, expectActivityLaunch,\n                    true /* stripAuthTokenFromResult */, account.name,\n                    true /* authDetailsRequired */, true /* updateLastAuthenticatedTime */) {\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.confirmCredentials(this, account, options);\n                }\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now) + \", confirmCredentials\"\n                            + \", \" + account.toSafeString();\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void updateCredentials(IAccountManagerResponse response, final Account account,\n            final String authTokenType, final boolean expectActivityLaunch,\n            final Bundle loginOptions) {\n        Bundle.setDefusable(loginOptions, true);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"updateCredentials: \" + account\n                    + \", response \" + response\n                    + \", authTokenType \" + authTokenType\n                    + \", expectActivityLaunch \" + expectActivityLaunch\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        if (response == null) throw new IllegalArgumentException(\"response is null\");\n        if (account == null) throw new IllegalArgumentException(\"account is null\");\n        int userId = UserHandle.getCallingUserId();\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            new Session(accounts, response, account.type, expectActivityLaunch,\n                    true /* stripAuthTokenFromResult */, account.name,\n                    false /* authDetailsRequired */, true /* updateLastCredentialTime */) {\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.updateCredentials(this, account, authTokenType, loginOptions);\n                }\n                @Override\n                protected String toDebugString(long now) {\n                    if (loginOptions != null) loginOptions.keySet();\n                    return super.toDebugString(now) + \", updateCredentials\"\n                            + \", \" + account.toSafeString()\n                            + \", authTokenType \" + authTokenType\n                            + \", loginOptions \" + loginOptions;\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void startUpdateCredentialsSession(\n            IAccountManagerResponse response,\n            final Account account,\n            final String authTokenType,\n            final boolean expectActivityLaunch,\n            final Bundle loginOptions) {\n        Bundle.setDefusable(loginOptions, true);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG,\n                    \"startUpdateCredentialsSession: \" + account + \", response \" + response\n                            + \", authTokenType \" + authTokenType + \", expectActivityLaunch \"\n                            + expectActivityLaunch + \", caller's uid \" + Binder.getCallingUid()\n                            + \", pid \" + Binder.getCallingPid());\n        }\n        if (response == null) {\n            throw new IllegalArgumentException(\"response is null\");\n        }\n        if (account == null) {\n            throw new IllegalArgumentException(\"account is null\");\n        }\n\n        final int uid = Binder.getCallingUid();\n        int userId = UserHandle.getCallingUserId();\n\n        // Check to see if the Password should be included to the caller.\n        String callerPkg = loginOptions.getString(AccountManager.KEY_ANDROID_PACKAGE_NAME);\n        boolean isPasswordForwardingAllowed = checkPermissionAndNote(\n                callerPkg, uid, Manifest.permission.GET_PASSWORD);\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            new StartAccountSession(\n                    accounts,\n                    response,\n                    account.type,\n                    expectActivityLaunch,\n                    account.name,\n                    false /* authDetailsRequired */,\n                    true /* updateLastCredentialTime */,\n                    isPasswordForwardingAllowed) {\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.startUpdateCredentialsSession(this, account, authTokenType,\n                            loginOptions);\n                }\n\n                @Override\n                protected String toDebugString(long now) {\n                    if (loginOptions != null)\n                        loginOptions.keySet();\n                    return super.toDebugString(now)\n                            + \", startUpdateCredentialsSession\"\n                            + \", \" + account.toSafeString()\n                            + \", authTokenType \" + authTokenType\n                            + \", loginOptions \" + loginOptions;\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void isCredentialsUpdateSuggested(\n            IAccountManagerResponse response,\n            final Account account,\n            final String statusToken) {\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG,\n                    \"isCredentialsUpdateSuggested: \" + account + \", response \" + response\n                            + \", caller's uid \" + Binder.getCallingUid()\n                            + \", pid \" + Binder.getCallingPid());\n        }\n        if (response == null) {\n            throw new IllegalArgumentException(\"response is null\");\n        }\n        if (account == null) {\n            throw new IllegalArgumentException(\"account is null\");\n        }\n        if (TextUtils.isEmpty(statusToken)) {\n            throw new IllegalArgumentException(\"status token is empty\");\n        }\n\n        int usrId = UserHandle.getCallingUserId();\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(usrId);\n            new Session(accounts, response, account.type, false /* expectActivityLaunch */,\n                    false /* stripAuthTokenFromResult */, account.name,\n                    false /* authDetailsRequired */) {\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now) + \", isCredentialsUpdateSuggested\"\n                            + \", \" + account.toSafeString();\n                }\n\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.isCredentialsUpdateSuggested(this, account, statusToken);\n                }\n\n                @Override\n                public void onResult(Bundle result) {\n                    Bundle.setDefusable(result, true);\n                    IAccountManagerResponse response = getResponseAndClose();\n                    if (response == null) {\n                        return;\n                    }\n\n                    if (result == null) {\n                        sendErrorResponse(\n                                response,\n                                AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                                \"null bundle\");\n                        return;\n                    }\n\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, getClass().getSimpleName() + \" calling onResult() on response \"\n                                + response);\n                    }\n                    // Check to see if an error occurred. We know if an error occurred because all\n                    // error codes are greater than 0.\n                    if ((result.getInt(AccountManager.KEY_ERROR_CODE, -1) > 0)) {\n                        sendErrorResponse(response,\n                                result.getInt(AccountManager.KEY_ERROR_CODE),\n                                result.getString(AccountManager.KEY_ERROR_MESSAGE));\n                        return;\n                    }\n                    if (!result.containsKey(AccountManager.KEY_BOOLEAN_RESULT)) {\n                        sendErrorResponse(\n                                response,\n                                AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                                \"no result in response\");\n                        return;\n                    }\n                    final Bundle newResult = new Bundle();\n                    newResult.putBoolean(AccountManager.KEY_BOOLEAN_RESULT,\n                            result.getBoolean(AccountManager.KEY_BOOLEAN_RESULT, false));\n                    sendResponse(response, newResult);\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void editProperties(IAccountManagerResponse response, final String accountType,\n            final boolean expectActivityLaunch) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"editProperties: accountType \" + accountType\n                    + \", response \" + response\n                    + \", expectActivityLaunch \" + expectActivityLaunch\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        if (response == null) throw new IllegalArgumentException(\"response is null\");\n        if (accountType == null) throw new IllegalArgumentException(\"accountType is null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(accountType, callingUid, userId)\n                && !isSystemUid(callingUid)) {\n            String msg = String.format(\n                    \"uid %s cannot edit authenticator properites for account type: %s\",\n                    callingUid,\n                    accountType);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            new Session(accounts, response, accountType, expectActivityLaunch,\n                    true /* stripAuthTokenFromResult */, null /* accountName */,\n                    false /* authDetailsRequired */) {\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.editProperties(this, mAccountType);\n                }\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now) + \", editProperties\"\n                            + \", accountType \" + accountType;\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public boolean hasAccountAccess(@NonNull Account account,  @NonNull String packageName,\n            @NonNull UserHandle userHandle) {\n        if (UserHandle.getAppId(Binder.getCallingUid()) != Process.SYSTEM_UID) {\n            throw new SecurityException(\"Can be called only by system UID\");\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        Objects.requireNonNull(packageName, \"packageName cannot be null\");\n        Objects.requireNonNull(userHandle, \"userHandle cannot be null\");\n\n        final int userId = userHandle.getIdentifier();\n\n        Preconditions.checkArgumentInRange(userId, 0, Integer.MAX_VALUE, \"user must be concrete\");\n\n        try {\n            int uid = mPackageManager.getPackageUidAsUser(packageName, userId);\n            return hasAccountAccess(account, packageName, uid);\n        } catch (NameNotFoundException e) {\n            Log.w(TAG, \"hasAccountAccess#Package not found \" + e.getMessage());\n            return false;\n        }\n    }\n\n    // Returns package with oldest target SDK for given UID.\n    private String getPackageNameForUid(int uid) {\n        String[] packageNames = mPackageManager.getPackagesForUid(uid);\n        if (ArrayUtils.isEmpty(packageNames)) {\n            return null;\n        }\n        String packageName = packageNames[0];\n        if (packageNames.length == 1) {\n            return packageName;\n        }\n        // Due to visibility changes we want to use package with oldest target SDK\n        int oldestVersion = Integer.MAX_VALUE;\n        for (String name : packageNames) {\n            try {\n                ApplicationInfo applicationInfo = mPackageManager.getApplicationInfo(name, 0);\n                if (applicationInfo != null) {\n                    int version = applicationInfo.targetSdkVersion;\n                    if (version < oldestVersion) {\n                        oldestVersion = version;\n                        packageName = name;\n                    }\n                }\n            } catch (NameNotFoundException e) {\n                // skip\n            }\n        }\n        return packageName;\n    }\n\n    private boolean hasAccountAccess(@NonNull Account account, @Nullable String packageName,\n            int uid) {\n        if (packageName == null) {\n            packageName = getPackageNameForUid(uid);\n            if (packageName == null) {\n                return false;\n            }\n        }\n\n        // Use null token which means any token. Having a token means the package\n        // is trusted by the authenticator, hence it is fine to access the account.\n        if (permissionIsGranted(account, null, uid, UserHandle.getUserId(uid))) {\n            return true;\n        }\n        // In addition to the permissions required to get an auth token we also allow\n        // the account to be accessed by apps for which user or authenticator granted visibility.\n\n        int visibility = resolveAccountVisibility(account, packageName,\n            getUserAccounts(UserHandle.getUserId(uid)));\n        return (visibility == AccountManager.VISIBILITY_VISIBLE\n            || visibility == AccountManager.VISIBILITY_USER_MANAGED_VISIBLE);\n    }\n\n    @Override\n    public IntentSender createRequestAccountAccessIntentSenderAsUser(@NonNull Account account,\n            @NonNull String packageName, @NonNull UserHandle userHandle) {\n        if (UserHandle.getAppId(Binder.getCallingUid()) != Process.SYSTEM_UID) {\n            throw new SecurityException(\"Can be called only by system UID\");\n        }\n\n        Objects.requireNonNull(account, \"account cannot be null\");\n        Objects.requireNonNull(packageName, \"packageName cannot be null\");\n        Objects.requireNonNull(userHandle, \"userHandle cannot be null\");\n\n        final int userId = userHandle.getIdentifier();\n\n        Preconditions.checkArgumentInRange(userId, 0, Integer.MAX_VALUE, \"user must be concrete\");\n\n        final int uid;\n        try {\n            uid = mPackageManager.getPackageUidAsUser(packageName, userId);\n        } catch (NameNotFoundException e) {\n            Slog.e(TAG, \"Unknown package \" + packageName);\n            return null;\n        }\n\n        Intent intent = newRequestAccountAccessIntent(account, packageName, uid, null);\n\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            return PendingIntent.getActivityAsUser(\n                    mContext, 0, intent, PendingIntent.FLAG_ONE_SHOT\n                            | PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_IMMUTABLE,\n                    null, new UserHandle(userId)).getIntentSender();\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    private Intent newRequestAccountAccessIntent(Account account, String packageName,\n            int uid, RemoteCallback callback) {\n        return newGrantCredentialsPermissionIntent(account, packageName, uid,\n                new AccountAuthenticatorResponse(new IAccountAuthenticatorResponse.Stub() {\n            @Override\n            public void onResult(Bundle value) throws RemoteException {\n                handleAuthenticatorResponse(true);\n            }\n\n            @Override\n            public void onRequestContinued() {\n                /* ignore */\n            }\n\n            @Override\n            public void onError(int errorCode, String errorMessage) throws RemoteException {\n                handleAuthenticatorResponse(false);\n            }\n\n            private void handleAuthenticatorResponse(boolean accessGranted) throws RemoteException {\n                UserAccounts userAccounts = getUserAccounts(UserHandle.getUserId(uid));\n                cancelNotification(getCredentialPermissionNotificationId(account,\n                        AccountManager.ACCOUNT_ACCESS_TOKEN_TYPE, uid, userAccounts), userAccounts);\n                if (callback != null) {\n                    Bundle result = new Bundle();\n                    result.putBoolean(AccountManager.KEY_BOOLEAN_RESULT, accessGranted);\n                    callback.sendResult(result);\n                }\n            }\n        }), AccountManager.ACCOUNT_ACCESS_TOKEN_TYPE, false);\n    }\n\n    @Override\n    public boolean someUserHasAccount(@NonNull final Account account) {\n        if (!UserHandle.isSameApp(Process.SYSTEM_UID, Binder.getCallingUid())) {\n            throw new SecurityException(\"Only system can check for accounts across users\");\n        }\n        final long token = Binder.clearCallingIdentity();\n        try {\n            AccountAndUser[] allAccounts = getAllAccountsForSystemProcess();\n            for (int i = allAccounts.length - 1; i >= 0; i--) {\n                if (allAccounts[i].account.equals(account)) {\n                    return true;\n                }\n            }\n            return false;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private class GetAccountsByTypeAndFeatureSession extends Session {\n        private final String[] mFeatures;\n        private volatile Account[] mAccountsOfType = null;\n        private volatile ArrayList<Account> mAccountsWithFeatures = null;\n        private volatile int mCurrentAccount = 0;\n        private final int mCallingUid;\n        private final String mPackageName;\n        private final boolean mIncludeManagedNotVisible;\n\n        public GetAccountsByTypeAndFeatureSession(\n                UserAccounts accounts,\n                IAccountManagerResponse response,\n                String type,\n                String[] features,\n                int callingUid,\n                String packageName,\n                boolean includeManagedNotVisible) {\n            super(accounts, response, type, false /* expectActivityLaunch */,\n                    true /* stripAuthTokenFromResult */, null /* accountName */,\n                    false /* authDetailsRequired */);\n            mCallingUid = callingUid;\n            mFeatures = features;\n            mPackageName = packageName;\n            mIncludeManagedNotVisible = includeManagedNotVisible;\n        }\n\n        @Override\n        public void run() throws RemoteException {\n            mAccountsOfType = getAccountsFromCache(mAccounts, mAccountType,\n                    mCallingUid, mPackageName, mIncludeManagedNotVisible);\n            // check whether each account matches the requested features\n            mAccountsWithFeatures = new ArrayList<>(mAccountsOfType.length);\n            mCurrentAccount = 0;\n\n            checkAccount();\n        }\n\n        public void checkAccount() {\n            if (mCurrentAccount >= mAccountsOfType.length) {\n                sendResult();\n                return;\n            }\n\n            final IAccountAuthenticator accountAuthenticator = mAuthenticator;\n            if (accountAuthenticator == null) {\n                // It is possible that the authenticator has died, which is indicated by\n                // mAuthenticator being set to null. If this happens then just abort.\n                // There is no need to send back a result or error in this case since\n                // that already happened when mAuthenticator was cleared.\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.v(TAG, \"checkAccount: aborting session since we are no longer\"\n                            + \" connected to the authenticator, \" + toDebugString());\n                }\n                return;\n            }\n            try {\n                accountAuthenticator.hasFeatures(this, mAccountsOfType[mCurrentAccount], mFeatures);\n            } catch (RemoteException e) {\n                onError(AccountManager.ERROR_CODE_REMOTE_EXCEPTION, \"remote exception\");\n            }\n        }\n\n        @Override\n        public void onResult(Bundle result) {\n            Bundle.setDefusable(result, true);\n            mNumResults++;\n            if (result == null) {\n                onError(AccountManager.ERROR_CODE_INVALID_RESPONSE, \"null bundle\");\n                return;\n            }\n            if (result.getBoolean(AccountManager.KEY_BOOLEAN_RESULT, false)) {\n                mAccountsWithFeatures.add(mAccountsOfType[mCurrentAccount]);\n            }\n            mCurrentAccount++;\n            checkAccount();\n        }\n\n        public void sendResult() {\n            IAccountManagerResponse response = getResponseAndClose();\n            if (response != null) {\n                try {\n                    Account[] accounts = new Account[mAccountsWithFeatures.size()];\n                    for (int i = 0; i < accounts.length; i++) {\n                        accounts[i] = mAccountsWithFeatures.get(i);\n                    }\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, getClass().getSimpleName() + \" calling onResult() on response \"\n                                + response);\n                    }\n                    Bundle result = new Bundle();\n                    result.putParcelableArray(AccountManager.KEY_ACCOUNTS, accounts);\n                    response.onResult(result);\n                } catch (RemoteException e) {\n                    // if the caller is dead then there is no one to care about remote exceptions\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, \"failure while notifying response\", e);\n                    }\n                }\n            }\n        }\n\n        @Override\n        protected String toDebugString(long now) {\n            return super.toDebugString(now) + \", getAccountsByTypeAndFeatures\"\n                    + \", \" + (mFeatures != null ? TextUtils.join(\",\", mFeatures) : null);\n        }\n    }\n\n    /**\n     * Returns the accounts visible to the client within the context of a specific user\n     * @hide\n     */\n    @NonNull\n    public Account[] getAccounts(int userId, String opPackageName) {\n        int callingUid = Binder.getCallingUid();\n        mAppOpsManager.checkPackage(callingUid, opPackageName);\n        List<String> visibleAccountTypes = getTypesVisibleToCaller(callingUid, userId,\n                opPackageName);\n        if (visibleAccountTypes.isEmpty()) {\n            return EMPTY_ACCOUNT_ARRAY;\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return getAccountsInternal(\n                    accounts,\n                    callingUid,\n                    opPackageName,\n                    visibleAccountTypes,\n                    false /* includeUserManagedNotVisible */);\n        } catch (SQLiteException e) {\n            Log.w(TAG, \"Could not get accounts for user \" + userId, e);\n            return new Account[]{};\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    /**\n     * Returns accounts for all running users, ignores visibility values.\n     *\n     * Should only be called by System process.\n     * @hide\n     */\n    @NonNull\n    public AccountAndUser[] getRunningAccountsForSystem() {\n        final int[] runningUserIds;\n        try {\n            runningUserIds = ActivityManager.getService().getRunningUserIds();\n        } catch (RemoteException e) {\n            // Running in system_server; should never happen\n            throw new RuntimeException(e);\n        }\n        return getAccountsForSystem(runningUserIds);\n    }\n\n    /**\n     * Returns accounts for all users, ignores visibility values.\n     *\n     * Should only be called by system process\n     *\n     * @hide\n     */\n    @NonNull\n    public AccountAndUser[] getAllAccountsForSystemProcess() {\n        final List<UserInfo> users = getUserManager().getAliveUsers();\n        final int[] userIds = new int[users.size()];\n        for (int i = 0; i < userIds.length; i++) {\n            userIds[i] = users.get(i).id;\n        }\n        return getAccountsForSystem(userIds);\n    }\n\n    /**\n     * Returns all accounts for the given user, ignores all visibility checks.\n     * This should only be called by system process.\n     *\n     * @hide\n     */\n    @NonNull\n    private AccountAndUser[] getAccountsForSystem(int[] userIds) {\n        final ArrayList<AccountAndUser> runningAccounts = Lists.newArrayList();\n        for (int userId : userIds) {\n            UserAccounts userAccounts = getUserAccounts(userId);\n            if (userAccounts == null) continue;\n            Account[] accounts = getAccountsFromCache(\n                    userAccounts,\n                    null /* type */,\n                    Binder.getCallingUid(),\n                    \"android\"/* packageName */,\n                    false /* include managed not visible*/);\n            for (Account account : accounts) {\n                runningAccounts.add(new AccountAndUser(account, userId));\n            }\n        }\n\n        AccountAndUser[] accountsArray = new AccountAndUser[runningAccounts.size()];\n        return runningAccounts.toArray(accountsArray);\n    }\n\n    @Override\n    @NonNull\n    public Account[] getAccountsAsUser(String type, int userId, String opPackageName) {\n        int callingUid = Binder.getCallingUid();\n        mAppOpsManager.checkPackage(callingUid, opPackageName);\n        try {\n            return getAccountsAsUserForPackage(type, userId, opPackageName /* callingPackage */, -1,\n                    opPackageName, false /* includeUserManagedNotVisible */);\n        } catch (SQLiteException e) {\n            Log.e(TAG, \"Could not get accounts for user \" + userId, e);\n            return new Account[]{};\n        }\n    }\n\n    @NonNull\n    private Account[] getAccountsOrEmptyArray(String type, int userId, String opPackageName) {\n        try {\n            return getAccountsAsUser(type, userId, opPackageName);\n        } catch (SQLiteException e) {\n            Log.w(TAG, \"Could not get accounts for user \" + userId, e);\n            return new Account[]{};\n        }\n    }\n\n    @NonNull\n    private Account[] getAccountsAsUserForPackage(\n            String type,\n            int userId,\n            String callingPackage,\n            int packageUid,\n            String opPackageName,\n            boolean includeUserManagedNotVisible) {\n        int callingUid = Binder.getCallingUid();\n        // Only allow the system process to read accounts of other users\n        if (userId != UserHandle.getCallingUserId()\n                && callingUid != Process.SYSTEM_UID\n                && mContext.checkCallingOrSelfPermission(\n                    android.Manifest.permission.INTERACT_ACROSS_USERS_FULL)\n                    != PackageManager.PERMISSION_GRANTED) {\n            throw new SecurityException(\"User \" + UserHandle.getCallingUserId()\n                    + \" trying to get account for \" + userId);\n        }\n\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"getAccounts: accountType \" + type\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid());\n        }\n\n        // If the original calling app was using account choosing activity\n        // provided by the framework or authenticator we'll passing in\n        // the original caller's uid here, which is what should be used for filtering.\n        List<String> managedTypes =\n                getTypesManagedByCaller(callingUid, UserHandle.getUserId(callingUid));\n        if (packageUid != -1 &&\n                ((UserHandle.isSameApp(callingUid, Process.SYSTEM_UID)\n                || (type != null && managedTypes.contains(type))))) {\n            callingUid = packageUid;\n            opPackageName = callingPackage;\n        }\n        List<String> visibleAccountTypes = getTypesVisibleToCaller(callingUid, userId,\n                opPackageName);\n        if (visibleAccountTypes.isEmpty()\n                || (type != null && !visibleAccountTypes.contains(type))) {\n            return EMPTY_ACCOUNT_ARRAY;\n        } else if (visibleAccountTypes.contains(type)) {\n            // Prune the list down to just the requested type.\n            visibleAccountTypes = new ArrayList<>();\n            visibleAccountTypes.add(type);\n        } // else aggregate all the visible accounts (it won't matter if the\n          // list is empty).\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return getAccountsInternal(\n                    accounts,\n                    callingUid,\n                    opPackageName,\n                    visibleAccountTypes,\n                    includeUserManagedNotVisible);\n        } catch (SQLiteException e) {\n            Log.w(TAG, \"Could not get accounts for user \" + userId, e);\n            return new Account[]{};\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @NonNull\n    private Account[] getAccountsInternal(\n            UserAccounts userAccounts,\n            int callingUid,\n            String callingPackage,\n            List<String> visibleAccountTypes,\n            boolean includeUserManagedNotVisible) {\n        ArrayList<Account> visibleAccounts = new ArrayList<>();\n        for (String visibleType : visibleAccountTypes) {\n            Account[] accountsForType = getAccountsFromCache(\n                    userAccounts, visibleType, callingUid, callingPackage,\n                    includeUserManagedNotVisible);\n            if (accountsForType != null) {\n                visibleAccounts.addAll(Arrays.asList(accountsForType));\n            }\n        }\n        Account[] result = new Account[visibleAccounts.size()];\n        for (int i = 0; i < visibleAccounts.size(); i++) {\n            result[i] = visibleAccounts.get(i);\n        }\n        return result;\n    }\n\n    @Override\n    public void addSharedAccountsFromParentUser(int parentUserId, int userId,\n            String opPackageName) {\n        checkManageOrCreateUsersPermission(\"addSharedAccountsFromParentUser\");\n        Account[] accounts = getAccountsOrEmptyArray(null, parentUserId, opPackageName);\n        for (Account account : accounts) {\n            addSharedAccountAsUser(account, userId);\n        }\n    }\n\n    private boolean addSharedAccountAsUser(Account account, int userId) {\n        userId = handleIncomingUser(userId);\n        UserAccounts accounts = getUserAccounts(userId);\n        accounts.accountsDb.deleteSharedAccount(account);\n        long accountId = accounts.accountsDb.insertSharedAccount(account);\n        if (accountId < 0) {\n            Log.w(TAG, \"insertAccountIntoDatabase: \" + account.toSafeString()\n                    + \", skipping the DB insert failed\");\n            return false;\n        }\n        logRecord(AccountsDb.DEBUG_ACTION_ACCOUNT_ADD, AccountsDb.TABLE_SHARED_ACCOUNTS, accountId,\n                accounts);\n        return true;\n    }\n\n    public boolean renameSharedAccountAsUser(Account account, String newName, int userId) {\n        userId = handleIncomingUser(userId);\n        UserAccounts accounts = getUserAccounts(userId);\n        long sharedTableAccountId = accounts.accountsDb.findSharedAccountId(account);\n        int r = accounts.accountsDb.renameSharedAccount(account, newName);\n        if (r > 0) {\n            int callingUid = getCallingUid();\n            logRecord(AccountsDb.DEBUG_ACTION_ACCOUNT_RENAME, AccountsDb.TABLE_SHARED_ACCOUNTS,\n                    sharedTableAccountId, accounts, callingUid);\n            // Recursively rename the account.\n            renameAccountInternal(accounts, account, newName);\n        }\n        return r > 0;\n    }\n\n    public boolean removeSharedAccountAsUser(Account account, int userId) {\n        return removeSharedAccountAsUser(account, userId, getCallingUid());\n    }\n\n    private boolean removeSharedAccountAsUser(Account account, int userId, int callingUid) {\n        userId = handleIncomingUser(userId);\n        UserAccounts accounts = getUserAccounts(userId);\n        long sharedTableAccountId = accounts.accountsDb.findSharedAccountId(account);\n        boolean deleted = accounts.accountsDb.deleteSharedAccount(account);\n        if (deleted) {\n            logRecord(AccountsDb.DEBUG_ACTION_ACCOUNT_REMOVE, AccountsDb.TABLE_SHARED_ACCOUNTS,\n                    sharedTableAccountId, accounts, callingUid);\n            removeAccountInternal(accounts, account, callingUid);\n        }\n        return deleted;\n    }\n\n    public Account[] getSharedAccountsAsUser(int userId) {\n        userId = handleIncomingUser(userId);\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            synchronized (accounts.dbLock) {\n                List<Account> accountList = accounts.accountsDb.getSharedAccounts();\n                Account[] accountArray = new Account[accountList.size()];\n                accountList.toArray(accountArray);\n                return accountArray;\n            }\n        } catch (SQLiteException e) {\n            Log.w(TAG, \"Could not get shared accounts for user \" + userId, e);\n            return new Account[]{};\n        }\n    }\n\n    @Override\n    @NonNull\n    public Account[] getAccountsForPackage(String packageName, int uid, String opPackageName) {\n        int callingUid = Binder.getCallingUid();\n        if (!UserHandle.isSameApp(callingUid, Process.SYSTEM_UID)) {\n            // Don't do opPackageName check - caller is system.\n            throw new SecurityException(\"getAccountsForPackage() called from unauthorized uid \"\n                    + callingUid + \" with uid=\" + uid);\n        }\n        return getAccountsAsUserForPackage(null, UserHandle.getCallingUserId(), packageName, uid,\n                opPackageName, true /* includeUserManagedNotVisible */);\n    }\n\n    @Override\n    @NonNull\n    public Account[] getAccountsByTypeForPackage(String type, String packageName,\n            String opPackageName) {\n        int callingUid =  Binder.getCallingUid();\n        int userId = UserHandle.getCallingUserId();\n        mAppOpsManager.checkPackage(callingUid, opPackageName);\n        int packageUid = -1;\n        try {\n            packageUid = mPackageManager.getPackageUidAsUser(packageName, userId);\n        } catch (NameNotFoundException re) {\n            Slog.e(TAG, \"Couldn't determine the packageUid for \" + packageName + re);\n            return EMPTY_ACCOUNT_ARRAY;\n        }\n        if (!UserHandle.isSameApp(callingUid, Process.SYSTEM_UID)\n                && (type != null && !isAccountManagedByCaller(type, callingUid, userId))) {\n                return EMPTY_ACCOUNT_ARRAY;\n        }\n        if (!UserHandle.isSameApp(callingUid, Process.SYSTEM_UID) && type == null) {\n            return getAccountsAsUserForPackage(type, userId,\n                packageName, packageUid, opPackageName, false /* includeUserManagedNotVisible */);\n        }\n        return getAccountsAsUserForPackage(type, userId,\n                packageName, packageUid, opPackageName, true /* includeUserManagedNotVisible */);\n    }\n\n    private boolean needToStartChooseAccountActivity(Account[] accounts, String callingPackage) {\n        if (accounts.length < 1) return false;\n        if (accounts.length > 1) return true;\n        Account account = accounts[0];\n        UserAccounts userAccounts = getUserAccounts(UserHandle.getCallingUserId());\n        int visibility = resolveAccountVisibility(account, callingPackage, userAccounts);\n        if (visibility == AccountManager.VISIBILITY_USER_MANAGED_NOT_VISIBLE) return true;\n        return false;\n    }\n\n    private void startChooseAccountActivityWithAccounts(\n        IAccountManagerResponse response, Account[] accounts, String callingPackage) {\n        Intent intent = new Intent(mContext, ChooseAccountActivity.class);\n        intent.putExtra(AccountManager.KEY_ACCOUNTS, accounts);\n        intent.putExtra(AccountManager.KEY_ACCOUNT_MANAGER_RESPONSE,\n                new AccountManagerResponse(response));\n        intent.putExtra(AccountManager.KEY_ANDROID_PACKAGE_NAME, callingPackage);\n\n        mContext.startActivityAsUser(intent, UserHandle.of(UserHandle.getCallingUserId()));\n    }\n\n    private void handleGetAccountsResult(\n        IAccountManagerResponse response,\n        Account[] accounts,\n        String callingPackage) {\n\n        if (needToStartChooseAccountActivity(accounts, callingPackage)) {\n            startChooseAccountActivityWithAccounts(response, accounts, callingPackage);\n            return;\n        }\n        if (accounts.length == 1) {\n            Bundle bundle = new Bundle();\n            bundle.putString(AccountManager.KEY_ACCOUNT_NAME, accounts[0].name);\n            bundle.putString(AccountManager.KEY_ACCOUNT_TYPE, accounts[0].type);\n            onResult(response, bundle);\n            return;\n        }\n        // No qualified account exists, return an empty Bundle.\n        onResult(response, new Bundle());\n    }\n\n    @Override\n    public void getAccountByTypeAndFeatures(\n        IAccountManagerResponse response,\n        String accountType,\n        String[] features,\n        String opPackageName) {\n\n        int callingUid = Binder.getCallingUid();\n        mAppOpsManager.checkPackage(callingUid, opPackageName);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"getAccount: accountType \" + accountType\n                    + \", response \" + response\n                    + \", features \" + Arrays.toString(features)\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        if (response == null) throw new IllegalArgumentException(\"response is null\");\n        if (accountType == null) throw new IllegalArgumentException(\"accountType is null\");\n\n        int userId = UserHandle.getCallingUserId();\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts userAccounts = getUserAccounts(userId);\n            if (ArrayUtils.isEmpty(features)) {\n                Account[] accountsWithManagedNotVisible = getAccountsFromCache(\n                    userAccounts, accountType, callingUid, opPackageName,\n                    true /* include managed not visible */);\n                handleGetAccountsResult(\n                    response, accountsWithManagedNotVisible, opPackageName);\n                return;\n            }\n\n            IAccountManagerResponse retrieveAccountsResponse =\n                new IAccountManagerResponse.Stub() {\n                @Override\n                public void onResult(Bundle value) throws RemoteException {\n                    Parcelable[] parcelables = value.getParcelableArray(\n                        AccountManager.KEY_ACCOUNTS);\n                    Account[] accounts = new Account[parcelables.length];\n                    for (int i = 0; i < parcelables.length; i++) {\n                        accounts[i] = (Account) parcelables[i];\n                    }\n                    handleGetAccountsResult(\n                        response, accounts, opPackageName);\n                }\n\n                @Override\n                public void onError(int errorCode, String errorMessage)\n                        throws RemoteException {\n                    // Will not be called in this case.\n                }\n            };\n            new GetAccountsByTypeAndFeatureSession(\n                    userAccounts,\n                    retrieveAccountsResponse,\n                    accountType,\n                    features,\n                    callingUid,\n                    opPackageName,\n                    true /* include managed not visible */).bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void getAccountsByFeatures(\n            IAccountManagerResponse response,\n            String type,\n            String[] features,\n            String opPackageName) {\n        int callingUid = Binder.getCallingUid();\n        mAppOpsManager.checkPackage(callingUid, opPackageName);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"getAccounts: accountType \" + type\n                    + \", response \" + response\n                    + \", features \" + Arrays.toString(features)\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        if (response == null) throw new IllegalArgumentException(\"response is null\");\n        if (type == null) throw new IllegalArgumentException(\"accountType is null\");\n        int userId = UserHandle.getCallingUserId();\n\n        List<String> visibleAccountTypes = getTypesVisibleToCaller(callingUid, userId,\n                opPackageName);\n        if (!visibleAccountTypes.contains(type)) {\n            Bundle result = new Bundle();\n            // Need to return just the accounts that are from matching signatures.\n            result.putParcelableArray(AccountManager.KEY_ACCOUNTS, EMPTY_ACCOUNT_ARRAY);\n            try {\n                response.onResult(result);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Cannot respond to caller do to exception.\" , e);\n            }\n            return;\n        }\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts userAccounts = getUserAccounts(userId);\n            if (features == null || features.length == 0) {\n                Account[] accounts = getAccountsFromCache(userAccounts, type, callingUid,\n                        opPackageName, false);\n                Bundle result = new Bundle();\n                result.putParcelableArray(AccountManager.KEY_ACCOUNTS, accounts);\n                onResult(response, result);\n                return;\n            }\n            new GetAccountsByTypeAndFeatureSession(\n                    userAccounts,\n                    response,\n                    type,\n                    features,\n                    callingUid,\n                    opPackageName,\n                    false /* include managed not visible */).bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void onAccountAccessed(String token) throws RemoteException {\n        final int uid = Binder.getCallingUid();\n        if (UserHandle.getAppId(uid) == Process.SYSTEM_UID) {\n            return;\n        }\n        final int userId = UserHandle.getCallingUserId();\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            for (Account account : getAccounts(userId, mContext.getOpPackageName())) {\n                if (Objects.equals(account.getAccessId(), token)) {\n                    // An app just accessed the account. At this point it knows about\n                    // it and there is not need to hide this account from the app.\n                    // Do we need to update account visibility here?\n                    if (!hasAccountAccess(account, null, uid)) {\n                        updateAppPermission(account, AccountManager.ACCOUNT_ACCESS_TOKEN_TYPE,\n                                uid, true);\n                    }\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    @Override\n    public void onShellCommand(FileDescriptor in, FileDescriptor out,\n            FileDescriptor err, String[] args, ShellCallback callback,\n            ResultReceiver resultReceiver) {\n        new AccountManagerServiceShellCommand(this).exec(this, in, out, err, args,\n                callback, resultReceiver);\n    }\n\n    private abstract class Session extends IAccountAuthenticatorResponse.Stub\n            implements IBinder.DeathRecipient, ServiceConnection {\n        private final Object mSessionLock = new Object();\n        IAccountManagerResponse mResponse;\n        final String mAccountType;\n        final boolean mExpectActivityLaunch;\n        final long mCreationTime;\n        final String mAccountName;\n        // Indicates if we need to add auth details(like last credential time)\n        final boolean mAuthDetailsRequired;\n        // If set, we need to update the last authenticated time. This is\n        // currently\n        // used on\n        // successful confirming credentials.\n        final boolean mUpdateLastAuthenticatedTime;\n\n        public int mNumResults = 0;\n        private int mNumRequestContinued = 0;\n        private int mNumErrors = 0;\n\n        IAccountAuthenticator mAuthenticator = null;\n\n        private final boolean mStripAuthTokenFromResult;\n        protected boolean mCanStartAccountManagerActivity = false;\n        protected final UserAccounts mAccounts;\n\n        private int mAuthenticatorUid;\n        private long mBindingStartTime;\n\n        public Session(UserAccounts accounts, IAccountManagerResponse response, String accountType,\n                boolean expectActivityLaunch, boolean stripAuthTokenFromResult, String accountName,\n                boolean authDetailsRequired) {\n            this(accounts, response, accountType, expectActivityLaunch, stripAuthTokenFromResult,\n                    accountName, authDetailsRequired, false /* updateLastAuthenticatedTime */);\n        }\n\n        public Session(UserAccounts accounts, IAccountManagerResponse response, String accountType,\n                boolean expectActivityLaunch, boolean stripAuthTokenFromResult, String accountName,\n                boolean authDetailsRequired, boolean updateLastAuthenticatedTime) {\n            super();\n            //if (response == null) throw new IllegalArgumentException(\"response is null\");\n            if (accountType == null) throw new IllegalArgumentException(\"accountType is null\");\n            mAccounts = accounts;\n            mStripAuthTokenFromResult = stripAuthTokenFromResult;\n            mAccountType = accountType;\n            mExpectActivityLaunch = expectActivityLaunch;\n            mCreationTime = SystemClock.elapsedRealtime();\n            mAccountName = accountName;\n            mAuthDetailsRequired = authDetailsRequired;\n            mUpdateLastAuthenticatedTime = updateLastAuthenticatedTime;\n\n            synchronized (mSessions) {\n                mSessions.put(toString(), this);\n            }\n            scheduleTimeout();\n            if (response != null) {\n                try {\n                    response.asBinder().linkToDeath(this, 0 /* flags */);\n                    mResponse = response;\n                } catch (RemoteException e) {\n                    binderDied();\n                }\n            }\n        }\n\n        IAccountManagerResponse getResponseAndClose() {\n            if (mAuthenticatorUid != 0 && mBindingStartTime > 0) {\n                sResponseLatency.logSampleWithUid(mAuthenticatorUid,\n                        SystemClock.uptimeMillis() - mBindingStartTime);\n            }\n            if (mResponse == null) {\n                close();\n                return null;\n            }\n            IAccountManagerResponse response = mResponse;\n            close(); // this clears mResponse so we need to save the response before this call\n            return response;\n        }\n\n        /**\n         * Checks Intents, supplied via KEY_INTENT, to make sure that they don't violate our\n         * security policy.\n         *\n         * In particular we want to make sure that the Authenticator doesn't try to trick users\n         * into launching arbitrary intents on the device via by tricking to click authenticator\n         * supplied entries in the system Settings app.\n         */\n        protected boolean checkKeyIntent(int authUid, Bundle bundle) {\n            if (!checkKeyIntentParceledCorrectly(bundle)) {\n                EventLog.writeEvent(0x534e4554, \"250588548\", authUid, \"\");\n                return false;\n            }\n            Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT, Intent.class);\n            if (intent == null) {\n                return true;\n            }\n            // Explicitly set an empty ClipData to ensure that we don't offer to\n            // promote any Uris contained inside for granting purposes\n            if (intent.getClipData() == null) {\n                intent.setClipData(ClipData.newPlainText(null, null));\n            }\n            final long bid = Binder.clearCallingIdentity();\n            try {\n                PackageManager pm = mContext.getPackageManager();\n                ResolveInfo resolveInfo = pm.resolveActivityAsUser(intent, 0, mAccounts.userId);\n                if (resolveInfo == null) {\n                    return false;\n                }\n                if (\"content\".equals(intent.getScheme())) {\n                    return false;\n                }\n                ActivityInfo targetActivityInfo = resolveInfo.activityInfo;\n                int targetUid = targetActivityInfo.applicationInfo.uid;\n                PackageManagerInternal pmi = LocalServices.getService(PackageManagerInternal.class);\n                if (!isExportedSystemActivity(targetActivityInfo)\n                        && !pmi.hasSignatureCapability(targetUid, authUid, CertCapabilities.AUTH)) {\n                    String pkgName = targetActivityInfo.packageName;\n                    String activityName = targetActivityInfo.name;\n                    String tmpl = \"KEY_INTENT resolved to an Activity (%s) in a package (%s) that \"\n                            + \"does not share a signature with the supplying authenticator (%s).\";\n                    Log.e(TAG, String.format(tmpl, activityName, pkgName, mAccountType));\n                    return false;\n                }\n                intent.setComponent(targetActivityInfo.getComponentName());\n                bundle.putParcelable(AccountManager.KEY_INTENT, intent);\n                return true;\n            } finally {\n                Binder.restoreCallingIdentity(bid);\n            }\n        }\n\n        /**\n         * Simulate the client side's deserialization of KEY_INTENT value, to make sure they don't\n         * violate our security policy.\n         *\n         * In particular we want to make sure the Authenticator doesn't trick users\n         * into launching arbitrary intents on the device via exploiting any other Parcel read/write\n         * mismatch problems.\n         */\n        private boolean checkKeyIntentParceledCorrectly(Bundle bundle) {\n            Parcel p = Parcel.obtain();\n            p.writeBundle(bundle);\n            p.setDataPosition(0);\n            Bundle simulateBundle = p.readBundle();\n            p.recycle();\n            Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT, Intent.class);\n            Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT,\n                    Intent.class);\n            if (intent == null) {\n                return (simulateIntent == null);\n            }\n            if (intent.getClass() != Intent.class || simulateIntent.getClass() != Intent.class) {\n                return false;\n            }\n\n            if (!intent.filterEquals(simulateIntent)) {\n                return false;\n            }\n\n            if (intent.getSelector() != simulateIntent.getSelector()) {\n                return false;\n            }\n\n            int prohibitedFlags = Intent.FLAG_GRANT_READ_URI_PERMISSION\n                    | Intent.FLAG_GRANT_WRITE_URI_PERMISSION\n                    | Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION\n                    | Intent.FLAG_GRANT_PREFIX_URI_PERMISSION;\n            return (simulateIntent.getFlags() & prohibitedFlags) == 0;\n        }\n\n        private boolean isExportedSystemActivity(ActivityInfo activityInfo) {\n            String className = activityInfo.name;\n            if (!\"android\".equals(activityInfo.packageName)) {\n                return false;\n\n            }\n            return (mCanStartAccountManagerActivity\n                    && GrantCredentialsPermissionActivity.class.getName().equals(className))\n                    || CantAddAccountActivity.class.getName().equals(className);\n        }\n\n        private void close() {\n            synchronized (mSessions) {\n                if (mSessions.remove(toString()) == null) {\n                    // the session was already closed, so bail out now\n                    return;\n                }\n            }\n            if (mResponse != null) {\n                // stop listening for response deaths\n                mResponse.asBinder().unlinkToDeath(this, 0 /* flags */);\n\n                // clear this so that we don't accidentally send any further results\n                mResponse = null;\n            }\n            cancelTimeout();\n            unbind();\n        }\n\n        @Override\n        public void binderDied() {\n            mResponse = null;\n            close();\n        }\n\n        protected String toDebugString() {\n            return toDebugString(SystemClock.elapsedRealtime());\n        }\n\n        protected String toDebugString(long now) {\n            return \"Session: expectLaunch \" + mExpectActivityLaunch\n                    + \", connected \" + (mAuthenticator != null)\n                    + \", stats (\" + mNumResults + \"/\" + mNumRequestContinued\n                    + \"/\" + mNumErrors + \")\"\n                    + \", lifetime \" + ((now - mCreationTime) / 1000.0);\n        }\n\n        void bind() {\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"initiating bind to authenticator type \" + mAccountType);\n            }\n            if (!bindToAuthenticator(mAccountType)) {\n                Log.w(TAG, \"bind attempt failed for \" + toDebugString());\n                onError(AccountManager.ERROR_CODE_REMOTE_EXCEPTION, \"bind failure\");\n            }\n        }\n\n        private void unbind() {\n            synchronized (mSessionLock) {\n                if (mAuthenticator != null) {\n                    mAuthenticator = null;\n                    mContext.unbindService(this);\n                }\n            }\n        }\n\n        private void scheduleTimeout() {\n            mHandler.sendMessageDelayed(\n                    mHandler.obtainMessage(MESSAGE_TIMED_OUT, this), TIMEOUT_DELAY_MS);\n        }\n\n        public void cancelTimeout() {\n            mHandler.removeMessages(MESSAGE_TIMED_OUT, this);\n        }\n\n        @Override\n        public void onServiceConnected(ComponentName name, IBinder service) {\n            synchronized (mSessionLock) {\n                mAuthenticator = IAccountAuthenticator.Stub.asInterface(service);\n                try {\n                    run();\n                } catch (RemoteException e) {\n                    onError(AccountManager.ERROR_CODE_REMOTE_EXCEPTION,\n                            \"remote exception\");\n                }\n            }\n        }\n\n        @Override\n        public void onServiceDisconnected(ComponentName name) {\n            IAccountManagerResponse response = getResponseAndClose();\n            if (response != null) {\n                try {\n                    response.onError(AccountManager.ERROR_CODE_REMOTE_EXCEPTION,\n                            \"disconnected\");\n                } catch (RemoteException e) {\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, \"Session.onServiceDisconnected: \"\n                                + \"caught RemoteException while responding\", e);\n                    }\n                }\n            }\n        }\n\n        public abstract void run() throws RemoteException;\n\n        public void onTimedOut() {\n            IAccountManagerResponse response = getResponseAndClose();\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"Session.onTimedOut\");\n            }\n            if (response != null) {\n                try {\n                    response.onError(AccountManager.ERROR_CODE_REMOTE_EXCEPTION,\n                            \"timeout\");\n                } catch (RemoteException e) {\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, \"Session.onTimedOut: caught RemoteException while responding\",\n                                e);\n                    }\n                }\n            }\n        }\n\n        @Override\n        public void onResult(Bundle result) {\n            Bundle.setDefusable(result, true);\n            mNumResults++;\n            Intent intent = null;\n            if (result != null) {\n                boolean isSuccessfulConfirmCreds = result.getBoolean(\n                        AccountManager.KEY_BOOLEAN_RESULT, false);\n                boolean isSuccessfulUpdateCredsOrAddAccount =\n                        result.containsKey(AccountManager.KEY_ACCOUNT_NAME)\n                        && result.containsKey(AccountManager.KEY_ACCOUNT_TYPE);\n                // We should only update lastAuthenticated time, if\n                // mUpdateLastAuthenticatedTime is true and the confirmRequest\n                // or updateRequest was successful\n                boolean needUpdate = mUpdateLastAuthenticatedTime\n                        && (isSuccessfulConfirmCreds || isSuccessfulUpdateCredsOrAddAccount);\n                if (needUpdate || mAuthDetailsRequired) {\n                    boolean accountPresent = isAccountPresentForCaller(mAccountName, mAccountType);\n                    if (needUpdate && accountPresent) {\n                        updateLastAuthenticatedTime(new Account(mAccountName, mAccountType));\n                    }\n                    if (mAuthDetailsRequired) {\n                        long lastAuthenticatedTime = -1;\n                        if (accountPresent) {\n                            lastAuthenticatedTime = mAccounts.accountsDb\n                                    .findAccountLastAuthenticatedTime(\n                                            new Account(mAccountName, mAccountType));\n                        }\n                        result.putLong(AccountManager.KEY_LAST_AUTHENTICATED_TIME,\n                                lastAuthenticatedTime);\n                    }\n                }\n            }\n            if (result != null) {\n                if (!checkKeyIntent(\n                        Binder.getCallingUid(),\n                        result)) {\n                    onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                            \"invalid intent in bundle returned\");\n                    return;\n                }\n            }\n            if (result != null\n                    && !TextUtils.isEmpty(result.getString(AccountManager.KEY_AUTHTOKEN))) {\n                String accountName = result.getString(AccountManager.KEY_ACCOUNT_NAME);\n                String accountType = result.getString(AccountManager.KEY_ACCOUNT_TYPE);\n                if (!TextUtils.isEmpty(accountName) && !TextUtils.isEmpty(accountType)) {\n                    Account account = new Account(accountName, accountType);\n                    cancelNotification(getSigninRequiredNotificationId(mAccounts, account),\n                            mAccounts);\n                }\n            }\n            IAccountManagerResponse response;\n            if (mExpectActivityLaunch && result != null\n                    && result.containsKey(AccountManager.KEY_INTENT)) {\n                response = mResponse;\n            } else {\n                response = getResponseAndClose();\n            }\n            if (response != null) {\n                try {\n                    if (result == null) {\n                        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                            Log.v(TAG, getClass().getSimpleName()\n                                    + \" calling onError() on response \" + response);\n                        }\n                        response.onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                                \"null bundle returned\");\n                    } else {\n                        if (mStripAuthTokenFromResult) {\n                            result.remove(AccountManager.KEY_AUTHTOKEN);\n                            if (!checkKeyIntent(Binder.getCallingUid(), result)) {\n                                onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                                        \"invalid intent in bundle returned\");\n                                return;\n                            }\n                        }\n                        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                            Log.v(TAG, getClass().getSimpleName()\n                                    + \" calling onResult() on response \" + response);\n                        }\n                        if ((result.getInt(AccountManager.KEY_ERROR_CODE, -1) > 0) &&\n                                (intent == null)) {\n                            // All AccountManager error codes are greater than 0\n                            response.onError(result.getInt(AccountManager.KEY_ERROR_CODE),\n                                    result.getString(AccountManager.KEY_ERROR_MESSAGE));\n                        } else {\n                            response.onResult(result);\n                        }\n                    }\n                } catch (RemoteException e) {\n                    // if the caller is dead then there is no one to care about remote exceptions\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, \"failure while notifying response\", e);\n                    }\n                }\n            }\n        }\n\n        @Override\n        public void onRequestContinued() {\n            mNumRequestContinued++;\n        }\n\n        @Override\n        public void onError(int errorCode, String errorMessage) {\n            mNumErrors++;\n            IAccountManagerResponse response = getResponseAndClose();\n            if (response != null) {\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.v(TAG, getClass().getSimpleName()\n                            + \" calling onError() on response \" + response);\n                }\n                try {\n                    response.onError(errorCode, errorMessage);\n                } catch (RemoteException e) {\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, \"Session.onError: caught RemoteException while responding\", e);\n                    }\n                }\n            } else {\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.v(TAG, \"Session.onError: already closed\");\n                }\n            }\n        }\n\n        /**\n         * find the component name for the authenticator and initiate a bind\n         * if no authenticator or the bind fails then return false, otherwise return true\n         */\n        private boolean bindToAuthenticator(String authenticatorType) {\n            final AccountAuthenticatorCache.ServiceInfo<AuthenticatorDescription> authenticatorInfo;\n            authenticatorInfo = mAuthenticatorCache.getServiceInfo(\n                    AuthenticatorDescription.newKey(authenticatorType), mAccounts.userId);\n            if (authenticatorInfo == null) {\n                Log.w(TAG, \"there is no authenticator for \" + authenticatorType\n                        + \", bailing out\");\n\n                return false;\n            }\n\n            if (!isLocalUnlockedUser(mAccounts.userId)\n                    && !authenticatorInfo.componentInfo.directBootAware) {\n                Slog.w(TAG, \"Blocking binding to authenticator \" + authenticatorInfo.componentName\n                        + \" which isn't encryption aware\");\n                return false;\n            }\n\n            Intent intent = new Intent();\n            intent.setAction(AccountManager.ACTION_AUTHENTICATOR_INTENT);\n            intent.setComponent(authenticatorInfo.componentName);\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"performing bindService to \" + authenticatorInfo.componentName);\n            }\n            long flags = Context.BIND_AUTO_CREATE;\n            if (mAuthenticatorCache.getBindInstantServiceAllowed(mAccounts.userId)) {\n                flags |= Context.BIND_ALLOW_INSTANT;\n            }\n            if (!mContext.bindServiceAsUser(intent, this, Context.BindServiceFlags.of(flags),\n                    UserHandle.of(mAccounts.userId))) {\n                Log.w(TAG, \"bindService to \" + authenticatorInfo.componentName + \" failed\");\n                // Perform unbind as per documentation at Context.bindServiceAsUser\n                mContext.unbindService(this);\n                return false;\n            }\n            mAuthenticatorUid = authenticatorInfo.uid;\n            mBindingStartTime = SystemClock.uptimeMillis();\n            return true;\n        }\n    }\n\n    class MessageHandler extends Handler {\n        MessageHandler(Looper looper) {\n            super(looper);\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MESSAGE_TIMED_OUT:\n                    Session session = (Session)msg.obj;\n                    session.onTimedOut();\n                    break;\n\n                case MESSAGE_COPY_SHARED_ACCOUNT:\n                    copyAccountToUser(/*no response*/ null, (Account) msg.obj, msg.arg1, msg.arg2);\n                    break;\n\n                default:\n                    throw new IllegalStateException(\"unhandled message: \" + msg.what);\n            }\n        }\n    }\n\n    private void logRecord(UserAccounts accounts, String action, String tableName) {\n        logRecord(action, tableName, -1, accounts);\n    }\n\n    private void logRecordWithUid(UserAccounts accounts, String action, String tableName, int uid) {\n        logRecord(action, tableName, -1, accounts, uid);\n    }\n\n    /*\n     * This function receives an opened writable database.\n     */\n    private void logRecord(String action, String tableName, long accountId,\n            UserAccounts userAccount) {\n        logRecord(action, tableName, accountId, userAccount, getCallingUid());\n    }\n\n    /*\n     * This function receives an opened writable database and writes to it in a separate thread.\n     */\n    private void logRecord(String action, String tableName, long accountId,\n            UserAccounts userAccount, int callingUid) {\n\n        class LogRecordTask implements Runnable {\n            private final String action;\n            private final String tableName;\n            private final long accountId;\n            private final UserAccounts userAccount;\n            private final int callingUid;\n            private final long userDebugDbInsertionPoint;\n\n            LogRecordTask(final String action,\n                    final String tableName,\n                    final long accountId,\n                    final UserAccounts userAccount,\n                    final int callingUid,\n                    final long userDebugDbInsertionPoint) {\n                this.action = action;\n                this.tableName = tableName;\n                this.accountId = accountId;\n                this.userAccount = userAccount;\n                this.callingUid = callingUid;\n                this.userDebugDbInsertionPoint = userDebugDbInsertionPoint;\n            }\n\n            @Override\n            public void run() {\n                synchronized (userAccount.accountsDb.mDebugStatementLock) {\n                    SQLiteStatement logStatement = userAccount.accountsDb.getStatementForLogging();\n                    if (logStatement == null) {\n                        return; // Can't log.\n                    }\n                    logStatement.bindLong(1, accountId);\n                    logStatement.bindString(2, action);\n                    logStatement.bindString(3, mDateFormat.format(new Date()));\n                    logStatement.bindLong(4, callingUid);\n                    logStatement.bindString(5, tableName);\n                    logStatement.bindLong(6, userDebugDbInsertionPoint);\n                    try {\n                        logStatement.execute();\n                    } catch (IllegalStateException | SQLiteFullException e) {\n                        // Guard against crash, DB can already be closed\n                        // since this statement is executed on a handler thread\n                        Slog.w(TAG, \"Failed to insert a log record. accountId=\" + accountId\n                                + \" action=\" + action + \" tableName=\" + tableName + \" Error: \" + e);\n                    } finally {\n                        logStatement.clearBindings();\n                    }\n                }\n            }\n        }\n        long insertionPoint = userAccount.accountsDb.reserveDebugDbInsertionPoint();\n        if (insertionPoint != -1) {\n            LogRecordTask logTask = new LogRecordTask(action, tableName, accountId, userAccount,\n                    callingUid, insertionPoint);\n            mHandler.post(logTask);\n        }\n    }\n\n    public IBinder onBind(@SuppressWarnings(\"unused\") Intent intent) {\n        return asBinder();\n    }\n\n    /**\n     * Searches array of arguments for the specified string\n     * @param args array of argument strings\n     * @param value value to search for\n     * @return true if the value is contained in the array\n     */\n    private static boolean scanArgs(String[] args, String value) {\n        if (args != null) {\n            for (String arg : args) {\n                if (value.equals(arg)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    @Override\n    protected void dump(FileDescriptor fd, PrintWriter fout, String[] args) {\n        if (!DumpUtils.checkDumpPermission(mContext, TAG, fout)) return;\n        final boolean isCheckinRequest = scanArgs(args, \"--checkin\") || scanArgs(args, \"-c\");\n        final IndentingPrintWriter ipw = new IndentingPrintWriter(fout, \"  \");\n\n        final List<UserInfo> users = getUserManager().getUsers();\n        for (UserInfo user : users) {\n            ipw.println(\"User \" + user + \":\");\n            ipw.increaseIndent();\n            dumpUser(getUserAccounts(user.id), fd, ipw, args, isCheckinRequest);\n            ipw.println();\n            ipw.decreaseIndent();\n        }\n    }\n\n    private void dumpUser(UserAccounts userAccounts, FileDescriptor fd, PrintWriter fout,\n            String[] args, boolean isCheckinRequest) {\n        if (isCheckinRequest) {\n            // This is a checkin request. *Only* upload the account types and the count of\n            // each.\n            synchronized (userAccounts.dbLock) {\n                userAccounts.accountsDb.dumpDeAccountsTable(fout);\n            }\n        } else {\n            Account[] accounts = getAccountsFromCache(userAccounts, null /* type */,\n                    Process.SYSTEM_UID, \"android\" /* packageName */, false);\n            fout.println(\"Accounts: \" + accounts.length);\n            for (Account account : accounts) {\n                fout.println(\"  \" + account.toString());\n            }\n\n            // Add debug information.\n            fout.println();\n            synchronized (userAccounts.dbLock) {\n                userAccounts.accountsDb.dumpDebugTable(fout);\n            }\n            fout.println();\n            synchronized (mSessions) {\n                final long now = SystemClock.elapsedRealtime();\n                fout.println(\"Active Sessions: \" + mSessions.size());\n                for (Session session : mSessions.values()) {\n                    fout.println(\"  \" + session.toDebugString(now));\n                }\n            }\n\n            fout.println();\n            mAuthenticatorCache.dump(fd, fout, args, userAccounts.userId);\n\n            boolean isUserUnlocked;\n            synchronized (mUsers) {\n                isUserUnlocked = isLocalUnlockedUser(userAccounts.userId);\n            }\n            // Following logs are printed only when user is unlocked.\n            if (!isUserUnlocked) {\n                return;\n            }\n            fout.println();\n            synchronized (userAccounts.dbLock) {\n                Map<Account, Map<String, Integer>> allVisibilityValues =\n                        userAccounts.accountsDb.findAllVisibilityValues();\n                fout.println(\"Account visibility:\");\n                for (Account account : allVisibilityValues.keySet()) {\n                    fout.println(\"  \" + account.name);\n                    Map<String, Integer> visibilities = allVisibilityValues.get(account);\n                    for (Entry<String, Integer> entry : visibilities.entrySet()) {\n                        fout.println(\"    \" + entry.getKey() + \", \" + entry.getValue());\n                    }\n                }\n            }\n        }\n    }\n\n    private void doNotification(UserAccounts accounts, Account account, CharSequence message,\n            Intent intent, String packageName, final int userId) {\n        final long identityToken = clearCallingIdentity();\n        try {\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"doNotification: \" + message + \" intent:\" + intent);\n            }\n\n            if (intent.getComponent() != null &&\n                    GrantCredentialsPermissionActivity.class.getName().equals(\n                            intent.getComponent().getClassName())) {\n                createNoCredentialsPermissionNotification(account, intent, packageName, accounts);\n            } else {\n                Context contextForUser = getContextForUser(new UserHandle(userId));\n                final NotificationId id = getSigninRequiredNotificationId(accounts, account);\n                intent.addCategory(id.mTag);\n\n                final String notificationTitleFormat =\n                        contextForUser.getText(R.string.notification_title).toString();\n                Notification n =\n                        new Notification.Builder(contextForUser, SystemNotificationChannels.ACCOUNT)\n                        .setWhen(0)\n                        .setSmallIcon(android.R.drawable.stat_sys_warning)\n                        .setColor(contextForUser.getColor(\n                                com.android.internal.R.color.system_notification_accent_color))\n                        .setContentTitle(String.format(notificationTitleFormat, account.name))\n                        .setContentText(message)\n                        .setContentIntent(PendingIntent.getActivityAsUser(\n                                mContext, 0, intent,\n                                PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_IMMUTABLE,\n                                null, new UserHandle(userId)))\n                        .build();\n                installNotification(id, n, packageName, userId);\n            }\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private void installNotification(NotificationId id, final Notification notification,\n            String packageName, int userId) {\n        final long token = clearCallingIdentity();\n        try {\n            INotificationManager notificationManager = mInjector.getNotificationManager();\n            try {\n                // The calling uid must match either the package or op package, so use an op\n                // package that matches the cleared calling identity.\n                notificationManager.enqueueNotificationWithTag(packageName, \"android\",\n                        id.mTag, id.mId, notification, userId);\n            } catch (RemoteException e) {\n                /* ignore - local call */\n            }\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private void cancelNotification(NotificationId id, UserAccounts accounts) {\n        cancelNotification(id, mContext.getPackageName(), accounts);\n    }\n\n    private void cancelNotification(NotificationId id, String packageName, UserAccounts accounts) {\n        final long identityToken = clearCallingIdentity();\n        try {\n            INotificationManager service = mInjector.getNotificationManager();\n            service.cancelNotificationWithTag(\n                    packageName, \"android\", id.mTag, id.mId,\n                    UserHandle.of(accounts.userId).getIdentifier());\n        } catch (RemoteException e) {\n            /* ignore - local call */\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private boolean isPermittedForPackage(String packageName, int userId, String... permissions) {\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            final int uid = mPackageManager.getPackageUidAsUser(packageName, userId);\n            IPackageManager pm = ActivityThread.getPackageManager();\n            for (String perm : permissions) {\n                if (pm.checkPermission(perm, packageName, userId)\n                        == PackageManager.PERMISSION_GRANTED) {\n                    // Checks runtime permission revocation.\n                    final int opCode = AppOpsManager.permissionToOpCode(perm);\n                    if (opCode == AppOpsManager.OP_NONE || mAppOpsManager.checkOpNoThrow(\n                            opCode, uid, packageName) == AppOpsManager.MODE_ALLOWED) {\n                        return true;\n                    }\n                }\n            }\n        } catch (NameNotFoundException | RemoteException e) {\n            // Assume permission is not granted if an error accrued.\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n        return false;\n    }\n\n    /**\n     * Checks that package has at least one of given permissions and makes note of app\n     * performing the action.\n     */\n    private boolean checkPermissionAndNote(String opPackageName, int callingUid,\n            String... permissions) {\n        for (String perm : permissions) {\n            if (mContext.checkCallingOrSelfPermission(perm) == PackageManager.PERMISSION_GRANTED) {\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.v(TAG, \"  caller uid \" + callingUid + \" has \" + perm);\n                }\n                final int opCode = AppOpsManager.permissionToOpCode(perm);\n                if (opCode == AppOpsManager.OP_NONE || mAppOpsManager.noteOpNoThrow(\n                        opCode, callingUid, opPackageName) == AppOpsManager.MODE_ALLOWED) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private int handleIncomingUser(int userId) {\n        try {\n            return ActivityManager.getService().handleIncomingUser(\n                    Binder.getCallingPid(), Binder.getCallingUid(), userId, true, true, \"\", null);\n        } catch (RemoteException re) {\n            // Shouldn't happen, local.\n        }\n        return userId;\n    }\n\n    private boolean isPrivileged(int callingUid) {\n        String[] packages;\n        final long identityToken = Binder.clearCallingIdentity();\n        try {\n            packages = mPackageManager.getPackagesForUid(callingUid);\n            if (packages == null) {\n                Log.d(TAG, \"No packages for callingUid \" + callingUid);\n                return false;\n            }\n            for (String name : packages) {\n                try {\n                    PackageInfo packageInfo =\n                        mPackageManager.getPackageInfo(name, 0 /* flags */);\n                    if (packageInfo != null\n                        && (packageInfo.applicationInfo.privateFlags\n                            & ApplicationInfo.PRIVATE_FLAG_PRIVILEGED) != 0) {\n                        return true;\n                    }\n                } catch (PackageManager.NameNotFoundException e) {\n                    Log.w(TAG, \"isPrivileged#Package not found \" + e.getMessage());\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identityToken);\n        }\n        return false;\n    }\n\n    private boolean permissionIsGranted(\n            Account account, String authTokenType, int callerUid, int userId) {\n        if (UserHandle.getAppId(callerUid) == Process.SYSTEM_UID) {\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"Access to \" + account + \" granted calling uid is system\");\n            }\n            return true;\n        }\n\n        if (isPrivileged(callerUid)) {\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"Access to \" + account + \" granted calling uid \"\n                        + callerUid + \" privileged\");\n            }\n            return true;\n        }\n        if (account != null && isAccountManagedByCaller(account.type, callerUid, userId)) {\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"Access to \" + account + \" granted calling uid \"\n                        + callerUid + \" manages the account\");\n            }\n            return true;\n        }\n        if (account != null && hasExplicitlyGrantedPermission(account, authTokenType, callerUid)) {\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"Access to \" + account + \" granted calling uid \"\n                        + callerUid + \" user granted access\");\n            }\n            return true;\n        }\n\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"Access to \" + account + \" not granted for uid \" + callerUid);\n        }\n\n        return false;\n    }\n\n    private boolean isAccountVisibleToCaller(String accountType, int callingUid, int userId,\n            String opPackageName) {\n        if (accountType == null) {\n            return false;\n        } else {\n            return getTypesVisibleToCaller(callingUid, userId,\n                    opPackageName).contains(accountType);\n        }\n    }\n\n    // Method checks visibility for applications targeing API level below {@link\n    // android.os.Build.VERSION_CODES#O},\n    // returns true if the the app has GET_ACCOUNTS or GET_ACCOUNTS_PRIVILEGED permission.\n    private boolean checkGetAccountsPermission(String packageName, int userId) {\n        return isPermittedForPackage(packageName, userId, Manifest.permission.GET_ACCOUNTS,\n                Manifest.permission.GET_ACCOUNTS_PRIVILEGED);\n    }\n\n    private boolean checkReadContactsPermission(String packageName, int userId) {\n        return isPermittedForPackage(packageName, userId, Manifest.permission.READ_CONTACTS);\n    }\n\n    // Heuristic to check that account type may be associated with some contacts data and\n    // therefore READ_CONTACTS permission grants the access to account by default.\n    private boolean accountTypeManagesContacts(String accountType, int userId) {\n        if (accountType == null) {\n            return false;\n        }\n        final long identityToken = Binder.clearCallingIdentity();\n        Collection<RegisteredServicesCache.ServiceInfo<AuthenticatorDescription>> serviceInfos;\n        try {\n            serviceInfos = mAuthenticatorCache.getAllServices(userId);\n        } finally {\n            Binder.restoreCallingIdentity(identityToken);\n        }\n        // Check contacts related permissions for authenticator.\n        for (RegisteredServicesCache.ServiceInfo<AuthenticatorDescription> serviceInfo\n                : serviceInfos) {\n            if (accountType.equals(serviceInfo.type.type)) {\n                return isPermittedForPackage(serviceInfo.type.packageName, userId,\n                    Manifest.permission.WRITE_CONTACTS);\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Method checks package uid and signature with Authenticator which manages accountType.\n     *\n     * @return SIGNATURE_CHECK_UID_MATCH for uid match, SIGNATURE_CHECK_MATCH for signature match,\n     *         SIGNATURE_CHECK_MISMATCH otherwise.\n     */\n    private int checkPackageSignature(String accountType, int callingUid, int userId) {\n        if (accountType == null) {\n            return SIGNATURE_CHECK_MISMATCH;\n        }\n\n        final long identityToken = Binder.clearCallingIdentity();\n        Collection<RegisteredServicesCache.ServiceInfo<AuthenticatorDescription>> serviceInfos;\n        try {\n            serviceInfos = mAuthenticatorCache.getAllServices(userId);\n        } finally {\n            Binder.restoreCallingIdentity(identityToken);\n        }\n        // Check for signature match with Authenticator.LocalServices.getService(PackageManagerInternal.class);\n        PackageManagerInternal pmi = LocalServices.getService(PackageManagerInternal.class);\n        for (RegisteredServicesCache.ServiceInfo<AuthenticatorDescription> serviceInfo\n                : serviceInfos) {\n            if (accountType.equals(serviceInfo.type.type)) {\n                if (serviceInfo.uid == callingUid) {\n                    return SIGNATURE_CHECK_UID_MATCH;\n                }\n                if (pmi.hasSignatureCapability(\n                        serviceInfo.uid, callingUid, CertCapabilities.AUTH)) {\n                    return SIGNATURE_CHECK_MATCH;\n                }\n            }\n        }\n        return SIGNATURE_CHECK_MISMATCH;\n    }\n\n    // returns true for applications with the same signature as authenticator.\n    private boolean isAccountManagedByCaller(String accountType, int callingUid, int userId) {\n        if (accountType == null) {\n            return false;\n        } else {\n            return getTypesManagedByCaller(callingUid, userId).contains(accountType);\n        }\n    }\n\n    private List<String> getTypesVisibleToCaller(int callingUid, int userId,\n            String opPackageName) {\n        return getTypesForCaller(callingUid, userId, true /* isOtherwisePermitted*/);\n    }\n\n    private List<String> getTypesManagedByCaller(int callingUid, int userId) {\n        return getTypesForCaller(callingUid, userId, false);\n    }\n\n    private List<String> getTypesForCaller(\n            int callingUid, int userId, boolean isOtherwisePermitted) {\n        List<String> managedAccountTypes = new ArrayList<>();\n        final long identityToken = Binder.clearCallingIdentity();\n        Collection<RegisteredServicesCache.ServiceInfo<AuthenticatorDescription>> serviceInfos;\n        try {\n            serviceInfos = mAuthenticatorCache.getAllServices(userId);\n        } finally {\n            Binder.restoreCallingIdentity(identityToken);\n        }\n\n        PackageManagerInternal pmi = LocalServices.getService(PackageManagerInternal.class);\n        for (RegisteredServicesCache.ServiceInfo<AuthenticatorDescription> serviceInfo :\n                serviceInfos) {\n            if (isOtherwisePermitted || pmi.hasSignatureCapability(\n                    serviceInfo.uid, callingUid, CertCapabilities.AUTH)) {\n                managedAccountTypes.add(serviceInfo.type.type);\n            }\n        }\n        return managedAccountTypes;\n    }\n\n    private boolean isAccountPresentForCaller(String accountName, String accountType) {\n        if (getUserAccountsForCaller().accountCache.containsKey(accountType)) {\n            for (Account account : getUserAccountsForCaller().accountCache.get(accountType)) {\n                if (account.name.equals(accountName)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private static void checkManageUsersPermission(String message) {\n        if (ActivityManager.checkComponentPermission(\n                android.Manifest.permission.MANAGE_USERS, Binder.getCallingUid(), -1, true)\n                != PackageManager.PERMISSION_GRANTED) {\n            throw new SecurityException(\"You need MANAGE_USERS permission to: \" + message);\n        }\n    }\n\n    private static void checkManageOrCreateUsersPermission(String message) {\n        if (ActivityManager.checkComponentPermission(android.Manifest.permission.MANAGE_USERS,\n                Binder.getCallingUid(), -1, true) != PackageManager.PERMISSION_GRANTED &&\n                ActivityManager.checkComponentPermission(android.Manifest.permission.CREATE_USERS,\n                        Binder.getCallingUid(), -1, true) != PackageManager.PERMISSION_GRANTED) {\n            throw new SecurityException(\"You need MANAGE_USERS or CREATE_USERS permission to: \"\n                    + message);\n        }\n    }\n\n    private boolean hasExplicitlyGrantedPermission(Account account, String authTokenType,\n            int callerUid) {\n        if (UserHandle.getAppId(callerUid) == Process.SYSTEM_UID) {\n            return true;\n        }\n        UserAccounts accounts = getUserAccounts(UserHandle.getUserId(callerUid));\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                long grantsCount;\n                if (authTokenType != null) {\n                    grantsCount = accounts.accountsDb\n                            .findMatchingGrantsCount(callerUid, authTokenType, account);\n                } else {\n                    grantsCount = accounts.accountsDb.findMatchingGrantsCountAnyToken(callerUid,\n                            account);\n                }\n                final boolean permissionGranted = grantsCount > 0;\n\n                if (!permissionGranted && ActivityManager.isRunningInTestHarness()) {\n                    // TODO: Skip this check when running automated tests. Replace this\n                    // with a more general solution.\n                    Log.d(TAG, \"no credentials permission for usage of \"\n                            + account.toSafeString() + \", \"\n                            + authTokenType + \" by uid \" + callerUid\n                            + \" but ignoring since device is in test harness.\");\n                    return true;\n                }\n                return permissionGranted;\n            }\n        }\n    }\n\n    private boolean isSystemUid(int callingUid) {\n        String[] packages = null;\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            packages = mPackageManager.getPackagesForUid(callingUid);\n            if (packages != null) {\n                for (String name : packages) {\n                    try {\n                        PackageInfo packageInfo =\n                                mPackageManager.getPackageInfo(name, 0 /* flags */);\n                        if (packageInfo != null\n                                && (packageInfo.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM)\n                                != 0) {\n                            return true;\n                        }\n                    } catch (NameNotFoundException e) {\n                        Log.w(TAG, String.format(\"Could not find package [%s]\", name), e);\n                    }\n                }\n            } else {\n                Log.w(TAG, \"No known packages with uid \" + callingUid);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n        return false;\n    }\n\n    /** Succeeds if any of the specified permissions are granted. */\n    private void checkReadAccountsPermitted(\n            int callingUid,\n            String accountType,\n            int userId,\n            String opPackageName) {\n        if (!isAccountVisibleToCaller(accountType, callingUid, userId, opPackageName)) {\n            String msg = String.format(\n                    \"caller uid %s cannot access %s accounts\",\n                    callingUid,\n                    accountType);\n            Log.w(TAG, \"  \" + msg);\n            throw new SecurityException(msg);\n        }\n    }\n\n    private boolean canUserModifyAccounts(int userId, int callingUid) {\n        // the managing app can always modify accounts\n        if (isProfileOwner(callingUid)) {\n            return true;\n        }\n        if (getUserManager().getUserRestrictions(new UserHandle(userId))\n                .getBoolean(UserManager.DISALLOW_MODIFY_ACCOUNTS)) {\n            return false;\n        }\n        return true;\n    }\n\n    private boolean canUserModifyAccountsForType(int userId, String accountType, int callingUid) {\n        return Binder.withCleanCallingIdentity(() -> {\n            // the managing app can always modify accounts\n            if (isProfileOwner(callingUid)) {\n                return true;\n            }\n            DevicePolicyManager dpm = (DevicePolicyManager) mContext\n                    .getSystemService(Context.DEVICE_POLICY_SERVICE);\n            String[] typesArray = dpm.getAccountTypesWithManagementDisabledAsUser(userId);\n            if (typesArray == null) {\n                return true;\n            }\n            for (String forbiddenType : typesArray) {\n                if (forbiddenType.equals(accountType)) {\n                    return false;\n                }\n            }\n            return true;\n        });\n    }\n\n    private boolean isProfileOwner(int uid) {\n        final DevicePolicyManagerInternal dpmi =\n                LocalServices.getService(DevicePolicyManagerInternal.class);\n        //TODO(b/169395065) Figure out if this flow makes sense in Device Owner mode.\n        return (dpmi != null) && (dpmi.isActiveProfileOwner(uid) || dpmi.isActiveDeviceOwner(uid));\n    }\n\n    /**\n     * Filter the access to the target package by rules of the package visibility if the caller\n     * targeting API level U and above. Otherwise, returns true if the package is installed on\n     * the device.\n     *\n     * @param targetPkgName The package name to check.\n     * @param callingUid The caller that is going to access the package.\n     * @param userId The user ID where the target package resides.\n     * @return true if the caller is able to access the package.\n     */\n    private boolean canCallerAccessPackage(@NonNull String targetPkgName, int callingUid,\n            int userId) {\n        final PackageManagerInternal pmInternal =\n                LocalServices.getService(PackageManagerInternal.class);\n        if (!CompatChanges.isChangeEnabled(ENFORCE_PACKAGE_VISIBILITY_FILTERING, callingUid)) {\n            return pmInternal.getPackageUid(\n                    targetPkgName, 0 /* flags */, userId) != Process.INVALID_UID;\n        }\n        final boolean canAccess = !pmInternal.filterAppAccess(targetPkgName, callingUid, userId);\n        if (!canAccess && Log.isLoggable(TAG, Log.DEBUG)) {\n            Log.d(TAG, \"Package \" + targetPkgName + \" is not visible to caller \" + callingUid\n                    + \" for user \" + userId);\n        }\n        return canAccess;\n    }\n\n    @Override\n    public void updateAppPermission(Account account, String authTokenType, int uid, boolean value)\n            throws RemoteException {\n        final int callingUid = getCallingUid();\n\n        if (UserHandle.getAppId(callingUid) != Process.SYSTEM_UID) {\n            throw new SecurityException();\n        }\n\n        if (value) {\n            grantAppPermission(account, authTokenType, uid);\n        } else {\n            revokeAppPermission(account, authTokenType, uid);\n        }\n    }\n\n    /**\n     * Allow callers with the given uid permission to get credentials for account/authTokenType.\n     * <p>\n     * Although this is public it can only be accessed via the AccountManagerService object\n     * which is in the system. This means we don't need to protect it with permissions.\n     * @hide\n     */\n    void grantAppPermission(Account account, String authTokenType, int uid) {\n        if (account == null || authTokenType == null) {\n            Log.e(TAG, \"grantAppPermission: called with invalid arguments\", new Exception());\n            return;\n        }\n        UserAccounts accounts = getUserAccounts(UserHandle.getUserId(uid));\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                long accountId = accounts.accountsDb.findDeAccountId(account);\n                if (accountId >= 0) {\n                    accounts.accountsDb.insertGrant(accountId, authTokenType, uid);\n                }\n                cancelNotification(\n                        getCredentialPermissionNotificationId(\n                                account, authTokenType, uid, accounts),\n                        accounts);\n\n                cancelAccountAccessRequestNotificationIfNeeded(account, uid, true, accounts);\n            }\n        }\n\n        // Listeners are a final CopyOnWriteArrayList, hence no lock needed.\n        for (AccountManagerInternal.OnAppPermissionChangeListener listener\n                : mAppPermissionChangeListeners) {\n            mHandler.post(() -> listener.onAppPermissionChanged(account, uid));\n        }\n    }\n\n    /**\n     * Don't allow callers with the given uid permission to get credentials for\n     * account/authTokenType.\n     * <p>\n     * Although this is public it can only be accessed via the AccountManagerService object\n     * which is in the system. This means we don't need to protect it with permissions.\n     * @hide\n     */\n    private void revokeAppPermission(Account account, String authTokenType, int uid) {\n        if (account == null || authTokenType == null) {\n            Log.e(TAG, \"revokeAppPermission: called with invalid arguments\", new Exception());\n            return;\n        }\n        UserAccounts accounts = getUserAccounts(UserHandle.getUserId(uid));\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                accounts.accountsDb.beginTransaction();\n                try {\n                    long accountId = accounts.accountsDb.findDeAccountId(account);\n                    if (accountId >= 0) {\n                        accounts.accountsDb.deleteGrantsByAccountIdAuthTokenTypeAndUid(\n                                accountId, authTokenType, uid);\n                        accounts.accountsDb.setTransactionSuccessful();\n                    }\n                } finally {\n                    accounts.accountsDb.endTransaction();\n                }\n\n                cancelNotification(\n                        getCredentialPermissionNotificationId(\n                                account, authTokenType, uid, accounts),\n                        accounts);\n            }\n        }\n\n        // Listeners are a final CopyOnWriteArrayList, hence no lock needed.\n        for (AccountManagerInternal.OnAppPermissionChangeListener listener\n                : mAppPermissionChangeListeners) {\n            mHandler.post(() -> listener.onAppPermissionChanged(account, uid));\n        }\n    }\n\n    private void removeAccountFromCacheLocked(UserAccounts accounts, Account account) {\n        final Account[] oldAccountsForType = accounts.accountCache.get(account.type);\n        if (oldAccountsForType != null) {\n            ArrayList<Account> newAccountsList = new ArrayList<>();\n            for (Account curAccount : oldAccountsForType) {\n                if (!curAccount.equals(account)) {\n                    newAccountsList.add(curAccount);\n                }\n            }\n            if (newAccountsList.isEmpty()) {\n                accounts.accountCache.remove(account.type);\n            } else {\n                Account[] newAccountsForType = new Account[newAccountsList.size()];\n                newAccountsForType = newAccountsList.toArray(newAccountsForType);\n                accounts.accountCache.put(account.type, newAccountsForType);\n            }\n        }\n        accounts.userDataCache.remove(account);\n        accounts.authTokenCache.remove(account);\n        accounts.previousNameCache.remove(account);\n        accounts.visibilityCache.remove(account);\n\n        AccountManager.invalidateLocalAccountsDataCaches();\n    }\n\n    /**\n     * This assumes that the caller has already checked that the account is not already present.\n     * IMPORTANT: The account being inserted will begin to be tracked for access in remote\n     * processes and if you will return this account to apps you should return the result.\n     * @return The inserted account which is a new instance that is being tracked.\n     */\n    private Account insertAccountIntoCacheLocked(UserAccounts accounts, Account account) {\n        Account[] accountsForType = accounts.accountCache.get(account.type);\n        int oldLength = (accountsForType != null) ? accountsForType.length : 0;\n        Account[] newAccountsForType = new Account[oldLength + 1];\n        if (accountsForType != null) {\n            System.arraycopy(accountsForType, 0, newAccountsForType, 0, oldLength);\n        }\n        String token = account.getAccessId() != null ? account.getAccessId()\n                : UUID.randomUUID().toString();\n        newAccountsForType[oldLength] = new Account(account, token);\n        accounts.accountCache.put(account.type, newAccountsForType);\n        AccountManager.invalidateLocalAccountsDataCaches();\n        return newAccountsForType[oldLength];\n    }\n\n    @NonNull\n    private Account[] filterAccounts(UserAccounts accounts, Account[] unfiltered, int callingUid,\n            @Nullable String callingPackage, boolean includeManagedNotVisible) {\n        String visibilityFilterPackage = callingPackage;\n        if (visibilityFilterPackage == null) {\n            visibilityFilterPackage = getPackageNameForUid(callingUid);\n        }\n        Map<Account, Integer> firstPass = new LinkedHashMap<>();\n        for (Account account : unfiltered) {\n            int visibility = resolveAccountVisibility(account, visibilityFilterPackage, accounts);\n            if ((visibility == AccountManager.VISIBILITY_VISIBLE\n                    || visibility == AccountManager.VISIBILITY_USER_MANAGED_VISIBLE)\n                    || (includeManagedNotVisible\n                            && (visibility\n                                    == AccountManager.VISIBILITY_USER_MANAGED_NOT_VISIBLE))) {\n                firstPass.put(account, visibility);\n            }\n        }\n        Map<Account, Integer> secondPass =\n                filterSharedAccounts(accounts, firstPass, callingUid, callingPackage);\n\n        Account[] filtered = new Account[secondPass.size()];\n        filtered = secondPass.keySet().toArray(filtered);\n        return filtered;\n    }\n\n    @NonNull\n    private Map<Account, Integer> filterSharedAccounts(UserAccounts userAccounts,\n            @NonNull Map<Account, Integer> unfiltered, int callingUid,\n            @Nullable String callingPackage) {\n        // first part is to filter shared accounts.\n        // unfiltered type check is not necessary.\n        if (getUserManager() == null || userAccounts == null || userAccounts.userId < 0\n                || callingUid == Process.SYSTEM_UID) {\n            return unfiltered;\n        }\n        UserInfo user = getUserManager().getUserInfo(userAccounts.userId);\n        if (user != null && user.isRestricted()) {\n            String[] packages = mPackageManager.getPackagesForUid(callingUid);\n            if (packages == null) {\n                packages = new String[] {};\n            }\n            // If any of the packages is a visible listed package, return the full set,\n            // otherwise return non-shared accounts only.\n            // This might be a temporary way to specify a visible list\n            String visibleList = mContext.getResources().getString(\n                    com.android.internal.R.string.config_appsAuthorizedForSharedAccounts);\n            for (String packageName : packages) {\n                if (visibleList.contains(\";\" + packageName + \";\")) {\n                    return unfiltered;\n                }\n            }\n            Account[] sharedAccounts = getSharedAccountsAsUser(userAccounts.userId);\n            if (ArrayUtils.isEmpty(sharedAccounts)) {\n                return unfiltered;\n            }\n            String requiredAccountType = \"\";\n            try {\n                // If there's an explicit callingPackage specified, check if that package\n                // opted in to see restricted accounts.\n                if (callingPackage != null) {\n                    PackageInfo pi = mPackageManager.getPackageInfo(callingPackage, 0);\n                    if (pi != null && pi.restrictedAccountType != null) {\n                        requiredAccountType = pi.restrictedAccountType;\n                    }\n                } else {\n                    // Otherwise check if the callingUid has a package that has opted in\n                    for (String packageName : packages) {\n                        PackageInfo pi = mPackageManager.getPackageInfo(packageName, 0);\n                        if (pi != null && pi.restrictedAccountType != null) {\n                            requiredAccountType = pi.restrictedAccountType;\n                            break;\n                        }\n                    }\n                }\n            } catch (NameNotFoundException e) {\n                Log.w(TAG, \"filterSharedAccounts#Package not found \" + e.getMessage());\n            }\n            Map<Account, Integer> filtered = new LinkedHashMap<>();\n            for (Map.Entry<Account, Integer> entry : unfiltered.entrySet()) {\n                Account account = entry.getKey();\n                if (account.type.equals(requiredAccountType)) {\n                    filtered.put(account, entry.getValue());\n                } else {\n                    boolean found = false;\n                    for (Account shared : sharedAccounts) {\n                        if (shared.equals(account)) {\n                            found = true;\n                            break;\n                        }\n                    }\n                    if (!found) {\n                        filtered.put(account, entry.getValue());\n                    }\n                }\n            }\n            return filtered;\n        } else {\n            return unfiltered;\n        }\n    }\n\n    /*\n     * packageName can be null. If not null, it should be used to filter out restricted accounts\n     * that the package is not allowed to access.\n     *\n     * <p>The method shouldn't be called with UserAccounts#cacheLock held, otherwise it will cause a\n     * deadlock\n     */\n    @NonNull\n    protected Account[] getAccountsFromCache(UserAccounts userAccounts, String accountType,\n            int callingUid, @Nullable String callingPackage, boolean includeManagedNotVisible) {\n        Preconditions.checkState(!Thread.holdsLock(userAccounts.cacheLock),\n                \"Method should not be called with cacheLock\");\n        if (accountType != null) {\n            Account[] accounts;\n            synchronized (userAccounts.cacheLock) {\n                accounts = userAccounts.accountCache.get(accountType);\n            }\n            if (accounts == null) {\n                return EMPTY_ACCOUNT_ARRAY;\n            } else {\n                return filterAccounts(userAccounts, Arrays.copyOf(accounts, accounts.length),\n                        callingUid, callingPackage, includeManagedNotVisible);\n            }\n        } else {\n            int totalLength = 0;\n            Account[] accountsArray;\n            synchronized (userAccounts.cacheLock) {\n                for (Account[] accounts : userAccounts.accountCache.values()) {\n                    totalLength += accounts.length;\n                }\n                if (totalLength == 0) {\n                    return EMPTY_ACCOUNT_ARRAY;\n                }\n                accountsArray = new Account[totalLength];\n                totalLength = 0;\n                for (Account[] accountsOfType : userAccounts.accountCache.values()) {\n                    System.arraycopy(accountsOfType, 0, accountsArray, totalLength,\n                            accountsOfType.length);\n                    totalLength += accountsOfType.length;\n                }\n            }\n            return filterAccounts(userAccounts, accountsArray, callingUid, callingPackage,\n                    includeManagedNotVisible);\n        }\n    }\n\n    /** protected by the {@code dbLock}, {@code cacheLock} */\n    protected void writeUserDataIntoCacheLocked(UserAccounts accounts,\n            Account account, String key, String value) {\n        Map<String, String> userDataForAccount = accounts.userDataCache.get(account);\n        if (userDataForAccount == null) {\n            userDataForAccount = accounts.accountsDb.findUserExtrasForAccount(account);\n            accounts.userDataCache.put(account, userDataForAccount);\n        }\n        if (value == null) {\n            userDataForAccount.remove(key);\n        } else {\n            userDataForAccount.put(key, value);\n        }\n    }\n\n    protected TokenCache.Value readCachedTokenInternal(\n            UserAccounts accounts,\n            Account account,\n            String tokenType,\n            String callingPackage,\n            byte[] pkgSigDigest) {\n        synchronized (accounts.cacheLock) {\n            return accounts.accountTokenCaches.get(\n                    account, tokenType, callingPackage, pkgSigDigest);\n        }\n    }\n\n    /** protected by the {@code dbLock}, {@code cacheLock} */\n    protected void writeAuthTokenIntoCacheLocked(UserAccounts accounts,\n            Account account, String key, String value) {\n        Map<String, String> authTokensForAccount = accounts.authTokenCache.get(account);\n        if (authTokensForAccount == null) {\n            authTokensForAccount = accounts.accountsDb.findAuthTokensByAccount(account);\n            accounts.authTokenCache.put(account, authTokensForAccount);\n        }\n        if (value == null) {\n            authTokensForAccount.remove(key);\n        } else {\n            authTokensForAccount.put(key, value);\n        }\n    }\n\n    protected String readAuthTokenInternal(UserAccounts accounts, Account account,\n            String authTokenType) {\n        // Fast path - check if account is already cached\n        synchronized (accounts.cacheLock) {\n            Map<String, String> authTokensForAccount = accounts.authTokenCache.get(account);\n            if (authTokensForAccount != null) {\n                return authTokensForAccount.get(authTokenType);\n            }\n        }\n        // If not cached yet - do slow path and sync with db if necessary\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                Map<String, String> authTokensForAccount = accounts.authTokenCache.get(account);\n                if (authTokensForAccount == null) {\n                    // need to populate the cache for this account\n                    authTokensForAccount = accounts.accountsDb.findAuthTokensByAccount(account);\n                    accounts.authTokenCache.put(account, authTokensForAccount);\n                }\n                return authTokensForAccount.get(authTokenType);\n            }\n        }\n    }\n\n    private String readUserDataInternal(UserAccounts accounts, Account account, String key) {\n        Map<String, String> userDataForAccount;\n        // Fast path - check if data is already cached\n        synchronized (accounts.cacheLock) {\n            userDataForAccount = accounts.userDataCache.get(account);\n        }\n        // If not cached yet - do slow path and sync with db if necessary\n        if (userDataForAccount == null) {\n            synchronized (accounts.dbLock) {\n                synchronized (accounts.cacheLock) {\n                    userDataForAccount = accounts.userDataCache.get(account);\n                    if (userDataForAccount == null) {\n                        // need to populate the cache for this account\n                        userDataForAccount = accounts.accountsDb.findUserExtrasForAccount(account);\n                        accounts.userDataCache.put(account, userDataForAccount);\n                    }\n                }\n            }\n        }\n        return userDataForAccount.get(key);\n    }\n\n    private Context getContextForUser(UserHandle user) {\n        try {\n            return mContext.createPackageContextAsUser(mContext.getPackageName(), 0, user);\n        } catch (NameNotFoundException e) {\n            // Default to mContext, not finding the package system is running as is unlikely.\n            return mContext;\n        }\n    }\n\n    private void sendResponse(IAccountManagerResponse response, Bundle result) {\n        try {\n            response.onResult(result);\n        } catch (RemoteException e) {\n            // if the caller is dead then there is no one to care about remote\n            // exceptions\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"failure while notifying response\", e);\n            }\n        }\n    }\n\n    private void sendErrorResponse(IAccountManagerResponse response, int errorCode,\n            String errorMessage) {\n        try {\n            response.onError(errorCode, errorMessage);\n        } catch (RemoteException e) {\n            // if the caller is dead then there is no one to care about remote\n            // exceptions\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"failure while notifying response\", e);\n            }\n        }\n    }\n\n    /**\n     * Returns true if the config_canRemoveOrRenameFirstUser is false, and the given account type\n     * matches the one provided by config_accountTypeToKeepFirstUser.\n     */\n    private boolean isFirstAccountRemovalDisabled(Account account) {\n        // Skip if not targeting the first user.\n        int userId = UserHandle.getCallingUserId();\n        if (userId != 0) {\n            return false;\n        }\n\n        // Skip if we are allowed to remove/rename first account.\n        if (mContext.getResources()\n                .getBoolean(com.android.internal.R.bool.config_canRemoveFirstAccount)) {\n            return false;\n        }\n\n        // Skip if needed for testing.\n        if (Settings.Secure.getIntForUser(\n                mContext.getContentResolver(),\n                Settings.Secure.ALLOW_PRIMARY_GAIA_ACCOUNT_REMOVAL_FOR_TESTS,\n                0 /* default */,\n                0 /* userHandle */) != 0) {\n            return false;\n        }\n\n        // Skip if not targeting desired account.\n        String typeToKeep =\n                mContext.getResources()\n                        .getString(\n                                com.android.internal.R.string.config_accountTypeToKeepFirstAccount);\n        if (typeToKeep.isEmpty() || !typeToKeep.equals(account.type)) {\n            return false;\n        }\n\n        // Only restrict first account.\n        UserAccounts accounts = getUserAccounts(0 /* userId */);\n        Account[] accountsOfType = getAccountsFromCache(accounts, typeToKeep,\n                Process.SYSTEM_UID, \"android\" /* packageName */, false);\n        return accountsOfType.length > 0 && accountsOfType[0].equals(account);\n    }\n\n    private final class AccountManagerInternalImpl extends AccountManagerInternal {\n        private final Object mLock = new Object();\n\n        @GuardedBy(\"mLock\")\n        private AccountManagerBackupHelper mBackupHelper;\n\n        @Override\n        public void requestAccountAccess(@NonNull Account account, @NonNull String packageName,\n                @IntRange(from = 0) int userId, @NonNull RemoteCallback callback) {\n            if (account == null) {\n                Slog.w(TAG, \"account cannot be null\");\n                return;\n            }\n            if (packageName == null) {\n                Slog.w(TAG, \"packageName cannot be null\");\n                return;\n            }\n            if (userId < UserHandle.USER_SYSTEM) {\n                Slog.w(TAG, \"user id must be concrete\");\n                return;\n            }\n            if (callback == null) {\n                Slog.w(TAG, \"callback cannot be null\");\n                return;\n            }\n\n            int visibility =\n                resolveAccountVisibility(account, packageName, getUserAccounts(userId));\n            if (visibility == AccountManager.VISIBILITY_NOT_VISIBLE) {\n                Slog.w(TAG, \"requestAccountAccess: account is hidden\");\n                return;\n            }\n\n            if (AccountManagerService.this.hasAccountAccess(account, packageName,\n                    new UserHandle(userId))) {\n                Bundle result = new Bundle();\n                result.putBoolean(AccountManager.KEY_BOOLEAN_RESULT, true);\n                callback.sendResult(result);\n                return;\n            }\n\n            final int uid;\n            try {\n                final long identityToken = clearCallingIdentity();\n                try {\n                    uid = mPackageManager.getPackageUidAsUser(packageName, userId);\n                } finally {\n                    restoreCallingIdentity(identityToken);\n                }\n            } catch (NameNotFoundException e) {\n                Slog.e(TAG, \"Unknown package \" + packageName);\n                return;\n            }\n\n            Intent intent = newRequestAccountAccessIntent(account, packageName, uid, callback);\n            final UserAccounts userAccounts;\n            synchronized (mUsers) {\n                userAccounts = mUsers.get(userId);\n            }\n            SystemNotificationChannels.createAccountChannelForPackage(packageName, uid, mContext);\n            doNotification(userAccounts, account, null, intent, packageName, userId);\n        }\n\n        @Override\n        public void addOnAppPermissionChangeListener(OnAppPermissionChangeListener listener) {\n            // Listeners are a final CopyOnWriteArrayList, hence no lock needed.\n            mAppPermissionChangeListeners.add(listener);\n        }\n\n        @Override\n        public boolean hasAccountAccess(@NonNull Account account, @IntRange(from = 0) int uid) {\n            return AccountManagerService.this.hasAccountAccess(account, null, uid);\n        }\n\n        @Override\n        public byte[] backupAccountAccessPermissions(int userId) {\n            synchronized (mLock) {\n                if (mBackupHelper == null) {\n                    mBackupHelper = new AccountManagerBackupHelper(\n                            AccountManagerService.this, this);\n                }\n                return mBackupHelper.backupAccountAccessPermissions(userId);\n            }\n        }\n\n        @Override\n        public void restoreAccountAccessPermissions(byte[] data, int userId) {\n            synchronized (mLock) {\n                if (mBackupHelper == null) {\n                    mBackupHelper = new AccountManagerBackupHelper(\n                            AccountManagerService.this, this);\n                }\n                mBackupHelper.restoreAccountAccessPermissions(data, userId);\n            }\n        }\n    }\n\n    @VisibleForTesting\n    static class Injector {\n        private final Context mContext;\n\n        public Injector(Context context) {\n            mContext = context;\n        }\n\n        Looper getMessageHandlerLooper() {\n            ServiceThread serviceThread = new ServiceThread(TAG,\n                    android.os.Process.THREAD_PRIORITY_FOREGROUND, true /* allowIo */);\n            serviceThread.start();\n            return serviceThread.getLooper();\n        }\n\n        Context getContext() {\n            return mContext;\n        }\n\n        void addLocalService(AccountManagerInternal service) {\n            LocalServices.addService(AccountManagerInternal.class, service);\n        }\n\n        String getDeDatabaseName(int userId) {\n            File databaseFile = new File(Environment.getDataSystemDeDirectory(userId),\n                    AccountsDb.DE_DATABASE_NAME);\n            return databaseFile.getPath();\n        }\n\n        String getCeDatabaseName(int userId) {\n            File databaseFile = new File(Environment.getDataSystemCeDirectory(userId),\n                    AccountsDb.CE_DATABASE_NAME);\n            return databaseFile.getPath();\n        }\n\n        String getPreNDatabaseName(int userId) {\n            File systemDir = Environment.getDataSystemDirectory();\n            File databaseFile = new File(Environment.getUserSystemDirectory(userId),\n                    PRE_N_DATABASE_NAME);\n            if (userId == 0) {\n                // Migrate old file, if it exists, to the new location.\n                // Make sure the new file doesn't already exist. A placeholder file could have been\n                // accidentally created in the old location,\n                // causing the new one to become corrupted as well.\n                File oldFile = new File(systemDir, PRE_N_DATABASE_NAME);\n                if (oldFile.exists() && !databaseFile.exists()) {\n                    // Check for use directory; create if it doesn't exist, else renameTo will fail\n                    File userDir = Environment.getUserSystemDirectory(userId);\n                    if (!userDir.exists()) {\n                        if (!userDir.mkdirs()) {\n                            throw new IllegalStateException(\n                                    \"User dir cannot be created: \" + userDir);\n                        }\n                    }\n                    if (!oldFile.renameTo(databaseFile)) {\n                        throw new IllegalStateException(\n                                \"User dir cannot be migrated: \" + databaseFile);\n                    }\n                }\n            }\n            return databaseFile.getPath();\n        }\n\n        IAccountAuthenticatorCache getAccountAuthenticatorCache() {\n            return new AccountAuthenticatorCache(mContext);\n        }\n\n        INotificationManager getNotificationManager() {\n            return NotificationManager.getService();\n        }\n    }\n\n    private static class NotificationId {\n        final String mTag;\n        private final int mId;\n\n        NotificationId(String tag, int type) {\n            mTag = tag;\n            mId = type;\n        }\n    }\n}\n```",
                        "downstream_file_content": "```java\n/*\n * Copyright (C) 2009 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.server.accounts;\n\nimport android.Manifest;\nimport android.accounts.AbstractAccountAuthenticator;\nimport android.accounts.Account;\nimport android.accounts.AccountAndUser;\nimport android.accounts.AccountAuthenticatorResponse;\nimport android.accounts.AccountManager;\nimport android.accounts.AccountManagerInternal;\nimport android.accounts.AccountManagerResponse;\nimport android.accounts.AuthenticatorDescription;\nimport android.accounts.CantAddAccountActivity;\nimport android.accounts.ChooseAccountActivity;\nimport android.accounts.GrantCredentialsPermissionActivity;\nimport android.accounts.IAccountAuthenticator;\nimport android.accounts.IAccountAuthenticatorResponse;\nimport android.accounts.IAccountManager;\nimport android.accounts.IAccountManagerResponse;\nimport android.annotation.IntRange;\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.app.ActivityManager;\nimport android.app.ActivityThread;\nimport android.app.AppOpsManager;\nimport android.app.INotificationManager;\nimport android.app.Notification;\nimport android.app.NotificationManager;\nimport android.app.PendingIntent;\nimport android.app.admin.DevicePolicyEventLogger;\nimport android.app.admin.DevicePolicyManager;\nimport android.app.admin.DevicePolicyManagerInternal;\nimport android.content.BroadcastReceiver;\nimport android.content.ClipData;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.IntentSender;\nimport android.content.ServiceConnection;\nimport android.content.pm.ActivityInfo;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.IPackageManager;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManager.NameNotFoundException;\nimport android.content.pm.PackageManagerInternal;\nimport android.content.pm.PackageParser;\nimport android.content.pm.RegisteredServicesCache;\nimport android.content.pm.RegisteredServicesCacheListener;\nimport android.content.pm.ResolveInfo;\nimport android.content.pm.Signature;\nimport android.content.pm.UserInfo;\nimport android.database.Cursor;\nimport android.database.sqlite.SQLiteStatement;\nimport android.os.Binder;\nimport android.os.Bundle;\nimport android.os.Environment;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.Parcel;\nimport android.os.Parcelable;\nimport android.os.Process;\nimport android.os.RemoteCallback;\nimport android.os.RemoteException;\nimport android.os.ResultReceiver;\nimport android.os.ShellCallback;\nimport android.os.StrictMode;\nimport android.os.SystemClock;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.stats.devicepolicy.DevicePolicyEnums;\nimport android.text.TextUtils;\nimport android.util.EventLog;\nimport android.util.Log;\nimport android.util.Pair;\nimport android.util.Slog;\nimport android.util.SparseArray;\nimport android.util.SparseBooleanArray;\n\nimport com.android.internal.R;\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.content.PackageMonitor;\nimport com.android.internal.messages.nano.SystemMessageProto.SystemMessage;\nimport com.android.internal.notification.SystemNotificationChannels;\nimport com.android.internal.util.ArrayUtils;\nimport com.android.internal.util.DumpUtils;\nimport com.android.internal.util.IndentingPrintWriter;\nimport com.android.internal.util.Preconditions;\nimport com.android.server.LocalServices;\nimport com.android.server.ServiceThread;\nimport com.android.server.SystemService;\n\nimport com.google.android.collect.Lists;\nimport com.google.android.collect.Sets;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.PrintWriter;\nimport java.security.GeneralSecurityException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.concurrent.atomic.AtomicReference;\n\n/**\n * A system service that provides  account, password, and authtoken management for all\n * accounts on the device. Some of these calls are implemented with the help of the corresponding\n * {@link IAccountAuthenticator} services. This service is not accessed by users directly,\n * instead one uses an instance of {@link AccountManager}, which can be accessed as follows:\n *    AccountManager accountManager = AccountManager.get(context);\n * @hide\n */\npublic class AccountManagerService\n        extends IAccountManager.Stub\n        implements RegisteredServicesCacheListener<AuthenticatorDescription> {\n    private static final String TAG = \"AccountManagerService\";\n\n    public static class Lifecycle extends SystemService {\n        private AccountManagerService mService;\n\n        public Lifecycle(Context context) {\n            super(context);\n        }\n\n        @Override\n        public void onStart() {\n            mService = new AccountManagerService(new Injector(getContext()));\n            publishBinderService(Context.ACCOUNT_SERVICE, mService);\n        }\n\n        @Override\n        public void onUserUnlocking(@NonNull TargetUser user) {\n            mService.onUnlockUser(user.getUserIdentifier());\n        }\n\n        @Override\n        public void onUserStopping(@NonNull TargetUser user) {\n            Slog.i(TAG, \"onStopUser \" + user);\n            mService.purgeUserData(user.getUserIdentifier());\n        }\n    }\n\n    final Context mContext;\n\n    private final PackageManager mPackageManager;\n    private final AppOpsManager mAppOpsManager;\n    private UserManager mUserManager;\n    private final Injector mInjector;\n\n    final MessageHandler mHandler;\n\n    private static final int TIMEOUT_DELAY_MS = 1000 * 60 * 15;\n    // Messages that can be sent on mHandler\n    private static final int MESSAGE_TIMED_OUT = 3;\n    private static final int MESSAGE_COPY_SHARED_ACCOUNT = 4;\n\n    private final IAccountAuthenticatorCache mAuthenticatorCache;\n    private static final String PRE_N_DATABASE_NAME = \"accounts.db\";\n    private static final Intent ACCOUNTS_CHANGED_INTENT;\n\n    private static final int SIGNATURE_CHECK_MISMATCH = 0;\n    private static final int SIGNATURE_CHECK_MATCH = 1;\n    private static final int SIGNATURE_CHECK_UID_MATCH = 2;\n\n    static {\n        ACCOUNTS_CHANGED_INTENT = new Intent(AccountManager.LOGIN_ACCOUNTS_CHANGED_ACTION);\n        ACCOUNTS_CHANGED_INTENT.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT\n                | Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);\n    }\n\n    private final LinkedHashMap<String, Session> mSessions = new LinkedHashMap<String, Session>();\n\n    static class UserAccounts {\n        private final int userId;\n        final AccountsDb accountsDb;\n        private final HashMap<Pair<Pair<Account, String>, Integer>, NotificationId>\n                credentialsPermissionNotificationIds = new HashMap<>();\n        private final HashMap<Account, NotificationId> signinRequiredNotificationIds\n                = new HashMap<>();\n        final Object cacheLock = new Object();\n        final Object dbLock = new Object(); // if needed, dbLock must be obtained before cacheLock\n        /** protected by the {@link #cacheLock} */\n        final HashMap<String, Account[]> accountCache = new LinkedHashMap<>();\n        /** protected by the {@link #cacheLock} */\n        private final Map<Account, Map<String, String>> userDataCache = new HashMap<>();\n        /** protected by the {@link #cacheLock} */\n        private final Map<Account, Map<String, String>> authTokenCache = new HashMap<>();\n        /** protected by the {@link #cacheLock} */\n        private final TokenCache accountTokenCaches = new TokenCache();\n        /** protected by the {@link #cacheLock} */\n        private final Map<Account, Map<String, Integer>> visibilityCache = new HashMap<>();\n\n        /** protected by the {@link #mReceiversForType},\n         *  type -> (packageName -> number of active receivers)\n         *  type == null is used to get notifications about all account types\n         */\n        private final Map<String, Map<String, Integer>> mReceiversForType = new HashMap<>();\n\n        /**\n         * protected by the {@link #cacheLock}\n         *\n         * Caches the previous names associated with an account. Previous names\n         * should be cached because we expect that when an Account is renamed,\n         * many clients will receive a LOGIN_ACCOUNTS_CHANGED broadcast and\n         * want to know if the accounts they care about have been renamed.\n         *\n         * The previous names are wrapped in an {@link AtomicReference} so that\n         * we can distinguish between those accounts with no previous names and\n         * those whose previous names haven't been cached (yet).\n         */\n        private final HashMap<Account, AtomicReference<String>> previousNameCache =\n                new HashMap<Account, AtomicReference<String>>();\n\n        UserAccounts(Context context, int userId, File preNDbFile, File deDbFile) {\n            this.userId = userId;\n            synchronized (dbLock) {\n                synchronized (cacheLock) {\n                    accountsDb = AccountsDb.create(context, userId, preNDbFile, deDbFile);\n                }\n            }\n        }\n    }\n\n    private final SparseArray<UserAccounts> mUsers = new SparseArray<>();\n    private final SparseBooleanArray mLocalUnlockedUsers = new SparseBooleanArray();\n    // Not thread-safe. Only use in synchronized context\n    private final SimpleDateFormat mDateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n    private CopyOnWriteArrayList<AccountManagerInternal.OnAppPermissionChangeListener>\n            mAppPermissionChangeListeners = new CopyOnWriteArrayList<>();\n\n    private static AtomicReference<AccountManagerService> sThis = new AtomicReference<>();\n    private static final Account[] EMPTY_ACCOUNT_ARRAY = new Account[]{};\n\n    /**\n     * This should only be called by system code. One should only call this after the service\n     * has started.\n     * @return a reference to the AccountManagerService instance\n     * @hide\n     */\n    public static AccountManagerService getSingleton() {\n        return sThis.get();\n    }\n\n    public AccountManagerService(Injector injector) {\n        mInjector = injector;\n        mContext = injector.getContext();\n        mPackageManager = mContext.getPackageManager();\n        mAppOpsManager = mContext.getSystemService(AppOpsManager.class);\n        mHandler = new MessageHandler(injector.getMessageHandlerLooper());\n        mAuthenticatorCache = mInjector.getAccountAuthenticatorCache();\n        mAuthenticatorCache.setListener(this, mHandler);\n\n        sThis.set(this);\n\n        IntentFilter intentFilter = new IntentFilter();\n        intentFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);\n        intentFilter.addDataScheme(\"package\");\n        mContext.registerReceiver(new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context1, Intent intent) {\n                // Don't delete accounts when updating a authenticator's\n                // package.\n                if (!intent.getBooleanExtra(Intent.EXTRA_REPLACING, false)) {\n                    /* Purging data requires file io, don't block the main thread. This is probably\n                     * less than ideal because we are introducing a race condition where old grants\n                     * could be exercised until they are purged. But that race condition existed\n                     * anyway with the broadcast receiver.\n                     *\n                     * Ideally, we would completely clear the cache, purge data from the database,\n                     * and then rebuild the cache. All under the cache lock. But that change is too\n                     * large at this point.\n                     */\n                    final String removedPackageName = intent.getData().getSchemeSpecificPart();\n                    Runnable purgingRunnable = new Runnable() {\n                        @Override\n                        public void run() {\n                            purgeOldGrantsAll();\n                            // Notify authenticator about removed app?\n                            removeVisibilityValuesForPackage(removedPackageName);\n                        }\n                    };\n                    mHandler.post(purgingRunnable);\n                }\n            }\n        }, intentFilter);\n\n        injector.addLocalService(new AccountManagerInternalImpl());\n\n        IntentFilter userFilter = new IntentFilter();\n        userFilter.addAction(Intent.ACTION_USER_REMOVED);\n        mContext.registerReceiverAsUser(new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                String action = intent.getAction();\n                if (Intent.ACTION_USER_REMOVED.equals(action)) {\n                    int userId = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, -1);\n                    if (userId < 1) return;\n                    Slog.i(TAG, \"User \" + userId + \" removed\");\n                    purgeUserData(userId);\n                }\n            }\n        }, UserHandle.ALL, userFilter, null, null);\n\n        // Need to cancel account request notifications if the update/install can access the account\n        new PackageMonitor() {\n            @Override\n            public void onPackageAdded(String packageName, int uid) {\n                // Called on a handler, and running as the system\n                cancelAccountAccessRequestNotificationIfNeeded(uid, true);\n            }\n\n            @Override\n            public void onPackageUpdateFinished(String packageName, int uid) {\n                // Called on a handler, and running as the system\n                cancelAccountAccessRequestNotificationIfNeeded(uid, true);\n            }\n        }.register(mContext, mHandler.getLooper(), UserHandle.ALL, true);\n\n        // Cancel account request notification if an app op was preventing the account access\n        mAppOpsManager.startWatchingMode(AppOpsManager.OP_GET_ACCOUNTS, null,\n                new AppOpsManager.OnOpChangedInternalListener() {\n            @Override\n            public void onOpChanged(int op, String packageName) {\n                try {\n                    final int userId = ActivityManager.getCurrentUser();\n                    final int uid = mPackageManager.getPackageUidAsUser(packageName, userId);\n                    final int mode = mAppOpsManager.checkOpNoThrow(\n                            AppOpsManager.OP_GET_ACCOUNTS, uid, packageName);\n                    if (mode == AppOpsManager.MODE_ALLOWED) {\n                        final long identity = Binder.clearCallingIdentity();\n                        try {\n                            cancelAccountAccessRequestNotificationIfNeeded(packageName, uid, true);\n                        } finally {\n                            Binder.restoreCallingIdentity(identity);\n                        }\n                    }\n                } catch (NameNotFoundException e) {\n                    /* ignore */\n                }\n            }\n        });\n\n        // Cancel account request notification if a permission was preventing the account access\n        mPackageManager.addOnPermissionsChangeListener(\n                (int uid) -> {\n            // Permission changes cause requires updating accounts cache.\n            AccountManager.invalidateLocalAccountsDataCaches();\n\n            Account[] accounts = null;\n            String[] packageNames = mPackageManager.getPackagesForUid(uid);\n            if (packageNames != null) {\n                final int userId = UserHandle.getUserId(uid);\n                final long identity = Binder.clearCallingIdentity();\n                try {\n                    for (String packageName : packageNames) {\n                                // if app asked for permission we need to cancel notification even\n                                // for O+ applications.\n                                if (mPackageManager.checkPermission(\n                                        Manifest.permission.GET_ACCOUNTS,\n                                        packageName) != PackageManager.PERMISSION_GRANTED) {\n                                    continue;\n                                }\n\n                        if (accounts == null) {\n                            accounts = getAccountsAsUser(null, userId, \"android\");\n                            if (ArrayUtils.isEmpty(accounts)) {\n                                return;\n                            }\n                        }\n\n                        for (Account account : accounts) {\n                            cancelAccountAccessRequestNotificationIfNeeded(\n                                    account, uid, packageName, true);\n                        }\n                    }\n                } finally {\n                    Binder.restoreCallingIdentity(identity);\n                }\n            }\n        });\n    }\n\n\n    boolean getBindInstantServiceAllowed(int userId) {\n        return  mAuthenticatorCache.getBindInstantServiceAllowed(userId);\n    }\n\n    void setBindInstantServiceAllowed(int userId, boolean allowed) {\n        mAuthenticatorCache.setBindInstantServiceAllowed(userId, allowed);\n    }\n\n    private void cancelAccountAccessRequestNotificationIfNeeded(int uid,\n            boolean checkAccess) {\n        Account[] accounts = getAccountsAsUser(null, UserHandle.getUserId(uid), \"android\");\n        for (Account account : accounts) {\n            cancelAccountAccessRequestNotificationIfNeeded(account, uid, checkAccess);\n        }\n    }\n\n    private void cancelAccountAccessRequestNotificationIfNeeded(String packageName, int uid,\n            boolean checkAccess) {\n        Account[] accounts = getAccountsAsUser(null, UserHandle.getUserId(uid), \"android\");\n        for (Account account : accounts) {\n            cancelAccountAccessRequestNotificationIfNeeded(account, uid, packageName, checkAccess);\n        }\n    }\n\n    private void cancelAccountAccessRequestNotificationIfNeeded(Account account, int uid,\n            boolean checkAccess) {\n        String[] packageNames = mPackageManager.getPackagesForUid(uid);\n        if (packageNames != null) {\n            for (String packageName : packageNames) {\n                cancelAccountAccessRequestNotificationIfNeeded(account, uid,\n                        packageName, checkAccess);\n            }\n        }\n    }\n\n    private void cancelAccountAccessRequestNotificationIfNeeded(Account account,\n            int uid, String packageName, boolean checkAccess) {\n        if (!checkAccess || hasAccountAccess(account, packageName,\n                UserHandle.getUserHandleForUid(uid))) {\n            cancelNotification(getCredentialPermissionNotificationId(account,\n                    AccountManager.ACCOUNT_ACCESS_TOKEN_TYPE, uid),\n                    UserHandle.getUserHandleForUid(uid));\n        }\n    }\n\n    @Override\n    public boolean addAccountExplicitlyWithVisibility(Account account, String password,\n            Bundle extras, Map packageToVisibility, String opPackageName) {\n        Bundle.setDefusable(extras, true);\n        int callingUid = Binder.getCallingUid();\n        int userId = UserHandle.getCallingUserId();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"addAccountExplicitly: \" + account + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\"uid %s cannot explicitly add accounts of type: %s\",\n                    callingUid, account.type);\n            throw new SecurityException(msg);\n        }\n        /*\n         * Child users are not allowed to add accounts. Only the accounts that are shared by the\n         * parent profile can be added to child profile.\n         *\n         * TODO: Only allow accounts that were shared to be added by a limited user.\n         */\n        // fails if the account already exists\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return addAccountInternal(accounts, account, password, extras, callingUid,\n                    (Map<String, Integer>) packageToVisibility, opPackageName);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public Map<Account, Integer> getAccountsAndVisibilityForPackage(String packageName,\n            String accountType) {\n        int callingUid = Binder.getCallingUid();\n        int userId = UserHandle.getCallingUserId();\n        boolean isSystemUid = UserHandle.isSameApp(callingUid, Process.SYSTEM_UID);\n        List<String> managedTypes = getTypesForCaller(callingUid, userId, isSystemUid);\n\n        if ((accountType != null && !managedTypes.contains(accountType))\n                || (accountType == null && !isSystemUid)) {\n            throw new SecurityException(\n                    \"getAccountsAndVisibilityForPackage() called from unauthorized uid \"\n                            + callingUid + \" with packageName=\" + packageName);\n        }\n        if (accountType != null) {\n            managedTypes = new ArrayList<String>();\n            managedTypes.add(accountType);\n        }\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return getAccountsAndVisibilityForPackage(packageName, managedTypes, callingUid,\n                    accounts);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    /*\n     * accountTypes may not be null\n     */\n    private Map<Account, Integer> getAccountsAndVisibilityForPackage(String packageName,\n            List<String> accountTypes, Integer callingUid, UserAccounts accounts) {\n        if (!packageExistsForUser(packageName, accounts.userId)) {\n            Log.d(TAG, \"Package not found \" + packageName);\n            return new LinkedHashMap<>();\n        }\n\n        Map<Account, Integer> result = new LinkedHashMap<>();\n        for (String accountType : accountTypes) {\n            synchronized (accounts.dbLock) {\n                synchronized (accounts.cacheLock) {\n                    final Account[] accountsOfType = accounts.accountCache.get(accountType);\n                    if (accountsOfType != null) {\n                        for (Account account : accountsOfType) {\n                            result.put(account,\n                                    resolveAccountVisibility(account, packageName, accounts));\n                        }\n                    }\n                }\n            }\n        }\n        return filterSharedAccounts(accounts, result, callingUid, packageName);\n    }\n\n    @Override\n    public Map<String, Integer> getPackagesAndVisibilityForAccount(Account account) {\n        Objects.requireNonNull(account, \"account cannot be null\");\n        int callingUid = Binder.getCallingUid();\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)\n                && !isSystemUid(callingUid)) {\n            String msg =\n                    String.format(\"uid %s cannot get secrets for account %s\", callingUid, account);\n            throw new SecurityException(msg);\n        }\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            synchronized (accounts.dbLock) {\n                synchronized (accounts.cacheLock) {\n                    return getPackagesAndVisibilityForAccountLocked(account, accounts);\n                }\n            }\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n\n    }\n\n    /**\n     * Returns Map with all package names and visibility values for given account.\n     * The method and returned map must be guarded by accounts.cacheLock\n     *\n     * @param account Account to get visibility values.\n     * @param accounts UserAccount that currently hosts the account and application\n     *\n     * @return Map with cache for package names to visibility.\n     */\n    private @NonNull Map<String, Integer> getPackagesAndVisibilityForAccountLocked(Account account,\n            UserAccounts accounts) {\n        Map<String, Integer> accountVisibility = accounts.visibilityCache.get(account);\n        if (accountVisibility == null) {\n            Log.d(TAG, \"Visibility was not initialized\");\n            accountVisibility = new HashMap<>();\n            accounts.visibilityCache.put(account, accountVisibility);\n            AccountManager.invalidateLocalAccountsDataCaches();\n        }\n        return accountVisibility;\n    }\n\n    @Override\n    public int getAccountVisibility(Account account, String packageName) {\n        Objects.requireNonNull(account, \"account cannot be null\");\n        Objects.requireNonNull(packageName, \"packageName cannot be null\");\n        int callingUid = Binder.getCallingUid();\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)\n            && !isSystemUid(callingUid)) {\n            String msg = String.format(\n                    \"uid %s cannot get secrets for accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            if (AccountManager.PACKAGE_NAME_KEY_LEGACY_VISIBLE.equals(packageName)) {\n                int visibility = getAccountVisibilityFromCache(account, packageName, accounts);\n                if (AccountManager.VISIBILITY_UNDEFINED != visibility) {\n                    return visibility;\n                } else {\n                   return AccountManager.VISIBILITY_USER_MANAGED_VISIBLE;\n                }\n            }\n            if (AccountManager.PACKAGE_NAME_KEY_LEGACY_NOT_VISIBLE.equals(packageName)) {\n                int visibility = getAccountVisibilityFromCache(account, packageName, accounts);\n                if (AccountManager.VISIBILITY_UNDEFINED != visibility) {\n                    return visibility;\n                } else {\n                   return AccountManager.VISIBILITY_USER_MANAGED_NOT_VISIBLE;\n                }\n            }\n            return resolveAccountVisibility(account, packageName, accounts);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    /**\n     * Method returns visibility for given account and package name.\n     *\n     * @param account The account to check visibility.\n     * @param packageName Package name to check visibility.\n     * @param accounts UserAccount that currently hosts the account and application\n     *\n     * @return Visibility value, AccountManager.VISIBILITY_UNDEFINED if no value was stored.\n     *\n     */\n    private int getAccountVisibilityFromCache(Account account, String packageName,\n            UserAccounts accounts) {\n        synchronized (accounts.cacheLock) {\n            Map<String, Integer> accountVisibility =\n                    getPackagesAndVisibilityForAccountLocked(account, accounts);\n            Integer visibility = accountVisibility.get(packageName);\n            return visibility != null ? visibility : AccountManager.VISIBILITY_UNDEFINED;\n        }\n    }\n\n    /**\n     * Method which handles default values for Account visibility.\n     *\n     * @param account The account to check visibility.\n     * @param packageName Package name to check visibility\n     * @param accounts UserAccount that currently hosts the account and application\n     *\n     * @return Visibility value, the method never returns AccountManager.VISIBILITY_UNDEFINED\n     *\n     */\n    private Integer resolveAccountVisibility(Account account, @NonNull String packageName,\n            UserAccounts accounts) {\n        Objects.requireNonNull(packageName, \"packageName cannot be null\");\n        int uid = -1;\n        try {\n            final long identityToken = clearCallingIdentity();\n            try {\n                uid = mPackageManager.getPackageUidAsUser(packageName, accounts.userId);\n            } finally {\n                restoreCallingIdentity(identityToken);\n            }\n        } catch (NameNotFoundException e) {\n            Log.d(TAG, \"Package not found \" + e.getMessage());\n            return AccountManager.VISIBILITY_NOT_VISIBLE;\n        }\n\n        // System visibility can not be restricted.\n        if (UserHandle.isSameApp(uid, Process.SYSTEM_UID)) {\n            return AccountManager.VISIBILITY_VISIBLE;\n        }\n\n        int signatureCheckResult =\n                checkPackageSignature(account.type, uid, accounts.userId);\n\n        // Authenticator can not restrict visibility to itself.\n        if (signatureCheckResult == SIGNATURE_CHECK_UID_MATCH) {\n            return AccountManager.VISIBILITY_VISIBLE; // Authenticator can always see the account\n        }\n\n        // Return stored value if it was set.\n        int visibility = getAccountVisibilityFromCache(account, packageName, accounts);\n\n        if (AccountManager.VISIBILITY_UNDEFINED != visibility) {\n            return visibility;\n        }\n\n        boolean isPrivileged = isPermittedForPackage(packageName, accounts.userId,\n                Manifest.permission.GET_ACCOUNTS_PRIVILEGED);\n\n        // Device/Profile owner gets visibility by default.\n        if (isProfileOwner(uid)) {\n            return AccountManager.VISIBILITY_VISIBLE;\n        }\n\n        boolean preO = isPreOApplication(packageName);\n        if ((signatureCheckResult != SIGNATURE_CHECK_MISMATCH)\n                || (preO && checkGetAccountsPermission(packageName, accounts.userId))\n                || (checkReadContactsPermission(packageName, accounts.userId)\n                    && accountTypeManagesContacts(account.type, accounts.userId))\n                || isPrivileged) {\n            // Use legacy for preO apps with GET_ACCOUNTS permission or pre/postO with signature\n            // match.\n            visibility = getAccountVisibilityFromCache(account,\n                    AccountManager.PACKAGE_NAME_KEY_LEGACY_VISIBLE, accounts);\n            if (AccountManager.VISIBILITY_UNDEFINED == visibility) {\n                visibility = AccountManager.VISIBILITY_USER_MANAGED_VISIBLE;\n            }\n        } else {\n            visibility = getAccountVisibilityFromCache(account,\n                    AccountManager.PACKAGE_NAME_KEY_LEGACY_NOT_VISIBLE, accounts);\n            if (AccountManager.VISIBILITY_UNDEFINED == visibility) {\n                visibility = AccountManager.VISIBILITY_USER_MANAGED_NOT_VISIBLE;\n            }\n        }\n        return visibility;\n    }\n\n    /**\n     * Checks targetSdk for a package;\n     *\n     * @param packageName Package name\n     *\n     * @return True if package's target SDK is below {@link android.os.Build.VERSION_CODES#O}, or\n     *         undefined\n     */\n    private boolean isPreOApplication(String packageName) {\n        try {\n            final long identityToken = clearCallingIdentity();\n            ApplicationInfo applicationInfo;\n            try {\n                applicationInfo = mPackageManager.getApplicationInfo(packageName, 0);\n            } finally {\n                restoreCallingIdentity(identityToken);\n            }\n\n            if (applicationInfo != null) {\n                int version = applicationInfo.targetSdkVersion;\n                return version < android.os.Build.VERSION_CODES.O;\n            }\n            return true;\n        } catch (NameNotFoundException e) {\n            Log.d(TAG, \"Package not found \" + e.getMessage());\n            return true;\n        }\n    }\n\n    @Override\n    public boolean setAccountVisibility(Account account, String packageName, int newVisibility) {\n        Objects.requireNonNull(account, \"account cannot be null\");\n        Objects.requireNonNull(packageName, \"packageName cannot be null\");\n        int callingUid = Binder.getCallingUid();\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)\n            && !isSystemUid(callingUid)) {\n            String msg = String.format(\n                    \"uid %s cannot get secrets for accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return setAccountVisibility(account, packageName, newVisibility, true /* notify */,\n                accounts);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private boolean isVisible(int visibility) {\n        return visibility == AccountManager.VISIBILITY_VISIBLE ||\n            visibility == AccountManager.VISIBILITY_USER_MANAGED_VISIBLE;\n    }\n\n    /**\n     * Updates visibility for given account name and package.\n     *\n     * @param account Account to update visibility.\n     * @param packageName Package name for which visibility is updated.\n     * @param newVisibility New visibility calue\n     * @param notify if the flag is set applications will get notification about visibility change\n     * @param accounts UserAccount that currently hosts the account and application\n     *\n     * @return True if account visibility was changed.\n     */\n    private boolean setAccountVisibility(Account account, String packageName, int newVisibility,\n            boolean notify, UserAccounts accounts) {\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                Map<String, Integer> packagesToVisibility;\n                List<String> accountRemovedReceivers;\n                if (notify) {\n                    if (isSpecialPackageKey(packageName)) {\n                        packagesToVisibility =\n                                getRequestingPackages(account, accounts);\n                        accountRemovedReceivers = getAccountRemovedReceivers(account, accounts);\n                    } else {\n                        if (!packageExistsForUser(packageName, accounts.userId)) {\n                            return false; // package is not installed.\n                        }\n                        packagesToVisibility = new HashMap<>();\n                        packagesToVisibility.put(packageName,\n                                resolveAccountVisibility(account, packageName, accounts));\n                        accountRemovedReceivers = new ArrayList<>();\n                        if (shouldNotifyPackageOnAccountRemoval(account, packageName, accounts)) {\n                            accountRemovedReceivers.add(packageName);\n                        }\n                    }\n                } else {\n                    // Notifications will not be send - only used during add account.\n                    if (!isSpecialPackageKey(packageName) &&\n                            !packageExistsForUser(packageName, accounts.userId)) {\n                        // package is not installed and not meta value.\n                        return false;\n                    }\n                    packagesToVisibility = Collections.emptyMap();\n                    accountRemovedReceivers = Collections.emptyList();\n                }\n\n                if (!updateAccountVisibilityLocked(account, packageName, newVisibility, accounts)) {\n                    return false;\n                }\n\n                if (notify) {\n                    for (Entry<String, Integer> packageToVisibility : packagesToVisibility\n                            .entrySet()) {\n                        int oldVisibility = packageToVisibility.getValue();\n                        int currentVisibility =\n                            resolveAccountVisibility(account, packageName, accounts);\n                        if (isVisible(oldVisibility) != isVisible(currentVisibility)) {\n                            notifyPackage(packageToVisibility.getKey(), accounts);\n                        }\n                    }\n                    for (String packageNameToNotify : accountRemovedReceivers) {\n                        sendAccountRemovedBroadcast(account, packageNameToNotify, accounts.userId);\n                    }\n                    sendAccountsChangedBroadcast(accounts.userId);\n                }\n                return true;\n            }\n        }\n    }\n\n    // Update account visibility in cache and database.\n    private boolean updateAccountVisibilityLocked(Account account, String packageName,\n            int newVisibility, UserAccounts accounts) {\n        final long accountId = accounts.accountsDb.findDeAccountId(account);\n        if (accountId < 0) {\n            return false;\n        }\n\n        final StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskWrites();\n        try {\n            if (!accounts.accountsDb.setAccountVisibility(accountId, packageName,\n                    newVisibility)) {\n                return false;\n            }\n        } finally {\n            StrictMode.setThreadPolicy(oldPolicy);\n        }\n        Map<String, Integer> accountVisibility =\n            getPackagesAndVisibilityForAccountLocked(account, accounts);\n        accountVisibility.put(packageName, newVisibility);\n        AccountManager.invalidateLocalAccountsDataCaches();\n        return true;\n    }\n\n    @Override\n    public void registerAccountListener(String[] accountTypes, String opPackageName) {\n        int callingUid = Binder.getCallingUid();\n        mAppOpsManager.checkPackage(callingUid, opPackageName);\n\n        int userId = UserHandle.getCallingUserId();\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            registerAccountListener(accountTypes, opPackageName, accounts);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private void registerAccountListener(String[] accountTypes, String opPackageName,\n            UserAccounts accounts) {\n        synchronized (accounts.mReceiversForType) {\n            if (accountTypes == null) {\n                // null for any type\n                accountTypes = new String[] {null};\n            }\n            for (String type : accountTypes) {\n                Map<String, Integer> receivers = accounts.mReceiversForType.get(type);\n                if (receivers == null) {\n                    receivers = new HashMap<>();\n                    accounts.mReceiversForType.put(type, receivers);\n                }\n                Integer cnt = receivers.get(opPackageName);\n                receivers.put(opPackageName, cnt != null ? cnt + 1 : 1);\n            }\n        }\n    }\n\n    @Override\n    public void unregisterAccountListener(String[] accountTypes, String opPackageName) {\n        int callingUid = Binder.getCallingUid();\n        mAppOpsManager.checkPackage(callingUid, opPackageName);\n        int userId = UserHandle.getCallingUserId();\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            unregisterAccountListener(accountTypes, opPackageName, accounts);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private void unregisterAccountListener(String[] accountTypes, String opPackageName,\n            UserAccounts accounts) {\n        synchronized (accounts.mReceiversForType) {\n            if (accountTypes == null) {\n                // null for any type\n                accountTypes = new String[] {null};\n            }\n            for (String type : accountTypes) {\n                Map<String, Integer> receivers = accounts.mReceiversForType.get(type);\n                if (receivers == null || receivers.get(opPackageName) == null) {\n                    throw new IllegalArgumentException(\"attempt to unregister wrong receiver\");\n                }\n                Integer cnt = receivers.get(opPackageName);\n                if (cnt == 1) {\n                    receivers.remove(opPackageName);\n                } else {\n                    receivers.put(opPackageName, cnt - 1);\n                }\n            }\n        }\n    }\n\n    // Send notification to all packages which can potentially see the account\n    private void sendNotificationAccountUpdated(Account account, UserAccounts accounts) {\n        Map<String, Integer> packagesToVisibility = getRequestingPackages(account, accounts);\n\n        for (Entry<String, Integer> packageToVisibility : packagesToVisibility.entrySet()) {\n            if ((packageToVisibility.getValue() != AccountManager.VISIBILITY_NOT_VISIBLE)\n                    && (packageToVisibility.getValue()\n                        != AccountManager.VISIBILITY_USER_MANAGED_NOT_VISIBLE)) {\n                notifyPackage(packageToVisibility.getKey(), accounts);\n            }\n        }\n    }\n\n    /**\n     * Sends a direct intent to a package, notifying it of account visibility change.\n     *\n     * @param packageName to send Account to\n     * @param accounts UserAccount that currently hosts the account\n     */\n    private void notifyPackage(String packageName, UserAccounts accounts) {\n        Intent intent = new Intent(AccountManager.ACTION_VISIBLE_ACCOUNTS_CHANGED);\n        intent.setPackage(packageName);\n        intent.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);\n        mContext.sendBroadcastAsUser(intent, new UserHandle(accounts.userId));\n    }\n\n    // Returns a map from package name to visibility, for packages subscribed\n    // to notifications about any account type, or type of provided account\n    // account type or all types.\n    private Map<String, Integer> getRequestingPackages(Account account, UserAccounts accounts) {\n        Set<String> packages = new HashSet<>();\n        synchronized (accounts.mReceiversForType) {\n            for (String type : new String[] {account.type, null}) {\n                Map<String, Integer> receivers = accounts.mReceiversForType.get(type);\n                if (receivers != null) {\n                    packages.addAll(receivers.keySet());\n                }\n            }\n        }\n        Map<String, Integer> result = new HashMap<>();\n        for (String packageName : packages) {\n            result.put(packageName, resolveAccountVisibility(account, packageName, accounts));\n        }\n        return result;\n    }\n\n    // Returns a list of packages listening to ACTION_ACCOUNT_REMOVED able to see the account.\n    private List<String> getAccountRemovedReceivers(Account account, UserAccounts accounts) {\n        Intent intent = new Intent(AccountManager.ACTION_ACCOUNT_REMOVED);\n        intent.setFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);\n        List<ResolveInfo> receivers =\n            mPackageManager.queryBroadcastReceiversAsUser(intent, 0, accounts.userId);\n        List<String> result = new ArrayList<>();\n        if (receivers == null) {\n            return result;\n        }\n        for (ResolveInfo resolveInfo: receivers) {\n            String packageName = resolveInfo.activityInfo.applicationInfo.packageName;\n            int visibility = resolveAccountVisibility(account, packageName, accounts);\n            if (visibility == AccountManager.VISIBILITY_VISIBLE\n                || visibility == AccountManager.VISIBILITY_USER_MANAGED_VISIBLE) {\n                result.add(packageName);\n            }\n        }\n        return result;\n    }\n\n    // Returns true if given package is listening to ACTION_ACCOUNT_REMOVED and can see the account.\n    private boolean shouldNotifyPackageOnAccountRemoval(Account account,\n            String packageName, UserAccounts accounts) {\n        int visibility = resolveAccountVisibility(account, packageName, accounts);\n        if (visibility != AccountManager.VISIBILITY_VISIBLE\n            && visibility != AccountManager.VISIBILITY_USER_MANAGED_VISIBLE) {\n            return false;\n        }\n\n        Intent intent = new Intent(AccountManager.ACTION_ACCOUNT_REMOVED);\n        intent.setFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);\n        intent.setPackage(packageName);\n        List<ResolveInfo> receivers =\n            mPackageManager.queryBroadcastReceiversAsUser(intent, 0, accounts.userId);\n        return (receivers != null && receivers.size() > 0);\n    }\n\n    private boolean packageExistsForUser(String packageName, int userId) {\n        try {\n            final long identityToken = clearCallingIdentity();\n            try {\n                mPackageManager.getPackageUidAsUser(packageName, userId);\n                return true;\n            } finally {\n                restoreCallingIdentity(identityToken);\n            }\n        } catch (NameNotFoundException e) {\n            return false;\n        }\n    }\n\n    /**\n     * Returns true if packageName is one of special values.\n     */\n    private boolean isSpecialPackageKey(String packageName) {\n        return (AccountManager.PACKAGE_NAME_KEY_LEGACY_VISIBLE.equals(packageName)\n                || AccountManager.PACKAGE_NAME_KEY_LEGACY_NOT_VISIBLE.equals(packageName));\n    }\n\n    private void sendAccountsChangedBroadcast(int userId) {\n        Log.i(TAG, \"the accounts changed, sending broadcast of \"\n                + ACCOUNTS_CHANGED_INTENT.getAction());\n        mContext.sendBroadcastAsUser(ACCOUNTS_CHANGED_INTENT, new UserHandle(userId));\n    }\n\n    private void sendAccountRemovedBroadcast(Account account, String packageName, int userId) {\n        Intent intent = new Intent(AccountManager.ACTION_ACCOUNT_REMOVED);\n        intent.setFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);\n        intent.setPackage(packageName);\n        intent.putExtra(AccountManager.KEY_ACCOUNT_NAME, account.name);\n        intent.putExtra(AccountManager.KEY_ACCOUNT_TYPE, account.type);\n        mContext.sendBroadcastAsUser(intent, new UserHandle(userId));\n    }\n\n    @Override\n    public boolean onTransact(int code, Parcel data, Parcel reply, int flags)\n            throws RemoteException {\n        try {\n            return super.onTransact(code, data, reply, flags);\n        } catch (RuntimeException e) {\n            // The account manager only throws security exceptions, so let's\n            // log all others.\n            if (!(e instanceof SecurityException || e instanceof IllegalArgumentException)) {\n                Slog.wtf(TAG, \"Account Manager Crash\", e);\n            }\n            throw e;\n        }\n    }\n\n    private UserManager getUserManager() {\n        if (mUserManager == null) {\n            mUserManager = UserManager.get(mContext);\n        }\n        return mUserManager;\n    }\n\n    /**\n     * Validate internal set of accounts against installed authenticators for\n     * given user. Clears cached authenticators before validating.\n     */\n    public void validateAccounts(int userId) {\n        final UserAccounts accounts = getUserAccounts(userId);\n        // Invalidate user-specific cache to make sure we catch any\n        // removed authenticators.\n        validateAccountsInternal(accounts, true /* invalidateAuthenticatorCache */);\n    }\n\n    /**\n     * Validate internal set of accounts against installed authenticators for\n     * given user. Clear cached authenticators before validating when requested.\n     */\n    private void validateAccountsInternal(\n            UserAccounts accounts, boolean invalidateAuthenticatorCache) {\n        if (Log.isLoggable(TAG, Log.DEBUG)) {\n            Log.d(TAG, \"validateAccountsInternal \" + accounts.userId\n                    + \" isCeDatabaseAttached=\" + accounts.accountsDb.isCeDatabaseAttached()\n                    + \" userLocked=\" + mLocalUnlockedUsers.get(accounts.userId));\n        }\n\n        if (invalidateAuthenticatorCache) {\n            mAuthenticatorCache.invalidateCache(accounts.userId);\n        }\n\n        final HashMap<String, Integer> knownAuth = getAuthenticatorTypeAndUIDForUser(\n                mAuthenticatorCache, accounts.userId);\n        boolean userUnlocked = isLocalUnlockedUser(accounts.userId);\n\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                boolean accountDeleted = false;\n\n                // Get a map of stored authenticator types to UID\n                final AccountsDb accountsDb = accounts.accountsDb;\n                Map<String, Integer> metaAuthUid = accountsDb.findMetaAuthUid();\n                // Create a list of authenticator type whose previous uid no longer exists\n                HashSet<String> obsoleteAuthType = Sets.newHashSet();\n                SparseBooleanArray knownUids = null;\n                for (Entry<String, Integer> authToUidEntry : metaAuthUid.entrySet()) {\n                    String type = authToUidEntry.getKey();\n                    int uid = authToUidEntry.getValue();\n                    Integer knownUid = knownAuth.get(type);\n                    if (knownUid != null && uid == knownUid) {\n                        // Remove it from the knownAuth list if it's unchanged.\n                        knownAuth.remove(type);\n                    } else {\n                    /*\n                     * The authenticator is presently not cached and should only be triggered\n                     * when we think an authenticator has been removed (or is being updated).\n                     * But we still want to check if any data with the associated uid is\n                     * around. This is an (imperfect) signal that the package may be updating.\n                     *\n                     * A side effect of this is that an authenticator sharing a uid with\n                     * multiple apps won't get its credentials wiped as long as some app with\n                     * that uid is still on the device. But I suspect that this is a rare case.\n                     * And it isn't clear to me how an attacker could really exploit that\n                     * feature.\n                     *\n                     * The upshot is that we don't have to worry about accounts getting\n                     * uninstalled while the authenticator's package is being updated.\n                     *\n                     */\n                        if (knownUids == null) {\n                            knownUids = getUidsOfInstalledOrUpdatedPackagesAsUser(accounts.userId);\n                        }\n                        if (!knownUids.get(uid)) {\n                            // The authenticator is not presently available to the cache. And the\n                            // package no longer has a data directory (so we surmise it isn't\n                            // updating). So purge its data from the account databases.\n                            obsoleteAuthType.add(type);\n                            // And delete it from the TABLE_META\n                            accountsDb.deleteMetaByAuthTypeAndUid(type, uid);\n                        } else if (knownUid != null && knownUid != uid) {\n                            Slog.w(TAG, \"authenticator no longer exist for type \" + type);\n                            obsoleteAuthType.add(type);\n                            accountsDb.deleteMetaByAuthTypeAndUid(type, uid);\n                        }\n                    }\n                }\n\n                // Add the newly registered authenticator to TABLE_META. If old authenticators have\n                // been re-enabled (after being updated for example), then we just overwrite the old\n                // values.\n                for (Entry<String, Integer> entry : knownAuth.entrySet()) {\n                    accountsDb.insertOrReplaceMetaAuthTypeAndUid(entry.getKey(), entry.getValue());\n                }\n\n                final Map<Long, Account> accountsMap = accountsDb.findAllDeAccounts();\n                try {\n                    accounts.accountCache.clear();\n                    final HashMap<String, ArrayList<String>> accountNamesByType\n                            = new LinkedHashMap<>();\n                    for (Entry<Long, Account> accountEntry : accountsMap.entrySet()) {\n                        final long accountId = accountEntry.getKey();\n                        final Account account = accountEntry.getValue();\n                        if (obsoleteAuthType.contains(account.type)) {\n                            Slog.w(TAG, \"deleting account \" + account.toSafeString()\n                                    + \" because type \" + account.type\n                                    + \"'s registered authenticator no longer exist.\");\n                            Map<String, Integer> packagesToVisibility =\n                                    getRequestingPackages(account, accounts);\n                            List<String> accountRemovedReceivers =\n                                getAccountRemovedReceivers(account, accounts);\n                            accountsDb.beginTransaction();\n                            try {\n                                accountsDb.deleteDeAccount(accountId);\n                                // Also delete from CE table if user is unlocked; if user is\n                                // currently locked the account will be removed later by\n                                // syncDeCeAccountsLocked\n                                if (userUnlocked) {\n                                    accountsDb.deleteCeAccount(accountId);\n                                }\n                                accountsDb.setTransactionSuccessful();\n                            } finally {\n                                accountsDb.endTransaction();\n                            }\n                            accountDeleted = true;\n\n                            logRecord(AccountsDb.DEBUG_ACTION_AUTHENTICATOR_REMOVE,\n                                    AccountsDb.TABLE_ACCOUNTS, accountId, accounts);\n\n                            accounts.userDataCache.remove(account);\n                            accounts.authTokenCache.remove(account);\n                            accounts.accountTokenCaches.remove(account);\n                            accounts.visibilityCache.remove(account);\n\n                            for (Entry<String, Integer> packageToVisibility :\n                                    packagesToVisibility.entrySet()) {\n                                if (isVisible(packageToVisibility.getValue())) {\n                                    notifyPackage(packageToVisibility.getKey(), accounts);\n                                }\n                            }\n                            for (String packageName : accountRemovedReceivers) {\n                                sendAccountRemovedBroadcast(account, packageName, accounts.userId);\n                            }\n                        } else {\n                            ArrayList<String> accountNames = accountNamesByType.get(account.type);\n                            if (accountNames == null) {\n                                accountNames = new ArrayList<>();\n                                accountNamesByType.put(account.type, accountNames);\n                            }\n                            accountNames.add(account.name);\n                        }\n                    }\n                    for (Map.Entry<String, ArrayList<String>> cur : accountNamesByType.entrySet()) {\n                        final String accountType = cur.getKey();\n                        final ArrayList<String> accountNames = cur.getValue();\n                        final Account[] accountsForType = new Account[accountNames.size()];\n                        for (int i = 0; i < accountsForType.length; i++) {\n                            accountsForType[i] = new Account(accountNames.get(i), accountType,\n                                    UUID.randomUUID().toString());\n                        }\n                        accounts.accountCache.put(accountType, accountsForType);\n                    }\n                    accounts.visibilityCache.putAll(accountsDb.findAllVisibilityValues());\n                    AccountManager.invalidateLocalAccountsDataCaches();\n                } finally {\n                    if (accountDeleted) {\n                        sendAccountsChangedBroadcast(accounts.userId);\n                    }\n                }\n            }\n        }\n    }\n\n    private SparseBooleanArray getUidsOfInstalledOrUpdatedPackagesAsUser(int userId) {\n        // Get the UIDs of all apps that might have data on the device. We want\n        // to preserve user data if the app might otherwise be storing data.\n        List<PackageInfo> pkgsWithData =\n                mPackageManager.getInstalledPackagesAsUser(\n                        PackageManager.MATCH_UNINSTALLED_PACKAGES, userId);\n        SparseBooleanArray knownUids = new SparseBooleanArray(pkgsWithData.size());\n        for (PackageInfo pkgInfo : pkgsWithData) {\n            if (pkgInfo.applicationInfo != null\n                    && (pkgInfo.applicationInfo.flags & ApplicationInfo.FLAG_INSTALLED) != 0) {\n                knownUids.put(pkgInfo.applicationInfo.uid, true);\n            }\n        }\n        return knownUids;\n    }\n\n    static HashMap<String, Integer> getAuthenticatorTypeAndUIDForUser(\n            Context context,\n            int userId) {\n        AccountAuthenticatorCache authCache = new AccountAuthenticatorCache(context);\n        return getAuthenticatorTypeAndUIDForUser(authCache, userId);\n    }\n\n    private static HashMap<String, Integer> getAuthenticatorTypeAndUIDForUser(\n            IAccountAuthenticatorCache authCache,\n            int userId) {\n        HashMap<String, Integer> knownAuth = new LinkedHashMap<>();\n        for (RegisteredServicesCache.ServiceInfo<AuthenticatorDescription> service : authCache\n                .getAllServices(userId)) {\n            knownAuth.put(service.type.type, service.uid);\n        }\n        return knownAuth;\n    }\n\n    private UserAccounts getUserAccountsForCaller() {\n        return getUserAccounts(UserHandle.getCallingUserId());\n    }\n\n    protected UserAccounts getUserAccounts(int userId) {\n        try {\n            return getUserAccountsNotChecked(userId);\n        } catch (RuntimeException e) {\n            if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE)) {\n                // Let it go...\n                throw e;\n            }\n            // User accounts database is corrupted, we must wipe out the whole user, otherwise the\n            // system will crash indefinitely\n            Slog.wtf(TAG, \"Removing user \" + userId + \" due to exception (\" + e + \") reading its \"\n                    + \"account database\");\n            if (userId == ActivityManager.getCurrentUser() && userId != UserHandle.USER_SYSTEM) {\n                Slog.i(TAG, \"Switching to system user first\");\n                try {\n                    ActivityManager.getService().switchUser(UserHandle.USER_SYSTEM);\n                } catch (RemoteException re) {\n                    Slog.e(TAG, \"Could not switch to \" + UserHandle.USER_SYSTEM + \": \" + re);\n                }\n            }\n            if (!getUserManager().removeUserEvenWhenDisallowed(userId)) {\n                Slog.e(TAG, \"could not remove user \" + userId);\n            }\n            throw e;\n        }\n    }\n\n    private UserAccounts getUserAccountsNotChecked(int userId) {\n        synchronized (mUsers) {\n            UserAccounts accounts = mUsers.get(userId);\n            boolean validateAccounts = false;\n            if (accounts == null) {\n                File preNDbFile = new File(mInjector.getPreNDatabaseName(userId));\n                File deDbFile = new File(mInjector.getDeDatabaseName(userId));\n                accounts = new UserAccounts(mContext, userId, preNDbFile, deDbFile);\n                mUsers.append(userId, accounts);\n                purgeOldGrants(accounts);\n                AccountManager.invalidateLocalAccountsDataCaches();\n                validateAccounts = true;\n            }\n            // open CE database if necessary\n            if (!accounts.accountsDb.isCeDatabaseAttached() && mLocalUnlockedUsers.get(userId)) {\n                Log.i(TAG, \"User \" + userId + \" is unlocked - opening CE database\");\n                synchronized (accounts.dbLock) {\n                    synchronized (accounts.cacheLock) {\n                        File ceDatabaseFile = new File(mInjector.getCeDatabaseName(userId));\n                        accounts.accountsDb.attachCeDatabase(ceDatabaseFile);\n                    }\n                }\n                syncDeCeAccountsLocked(accounts);\n            }\n            if (validateAccounts) {\n                validateAccountsInternal(accounts, true /* invalidateAuthenticatorCache */);\n            }\n            return accounts;\n        }\n    }\n\n    private void syncDeCeAccountsLocked(UserAccounts accounts) {\n        Preconditions.checkState(Thread.holdsLock(mUsers), \"mUsers lock must be held\");\n        List<Account> accountsToRemove = accounts.accountsDb.findCeAccountsNotInDe();\n        if (!accountsToRemove.isEmpty()) {\n            Slog.i(TAG, accountsToRemove.size()\n                    + \" accounts were previously deleted while user \"\n                    + accounts.userId + \" was locked. Removing accounts from CE tables\");\n            logRecord(accounts, AccountsDb.DEBUG_ACTION_SYNC_DE_CE_ACCOUNTS,\n                    AccountsDb.TABLE_ACCOUNTS);\n\n            for (Account account : accountsToRemove) {\n                removeAccountInternal(accounts, account, Process.SYSTEM_UID);\n            }\n        }\n    }\n\n    private void purgeOldGrantsAll() {\n        synchronized (mUsers) {\n            for (int i = 0; i < mUsers.size(); i++) {\n                purgeOldGrants(mUsers.valueAt(i));\n            }\n        }\n    }\n\n    private void purgeOldGrants(UserAccounts accounts) {\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                List<Integer> uids = accounts.accountsDb.findAllUidGrants();\n                for (int uid : uids) {\n                    final boolean packageExists = mPackageManager.getPackagesForUid(uid) != null;\n                    if (packageExists) {\n                        continue;\n                    }\n                    Log.d(TAG, \"deleting grants for UID \" + uid\n                            + \" because its package is no longer installed\");\n                    accounts.accountsDb.deleteGrantsByUid(uid);\n                }\n            }\n        }\n    }\n\n    private void removeVisibilityValuesForPackage(String packageName) {\n        if (isSpecialPackageKey(packageName)) {\n            return;\n        }\n        synchronized (mUsers) {\n            int numberOfUsers = mUsers.size();\n            for (int i = 0; i < numberOfUsers; i++) {\n                UserAccounts accounts = mUsers.valueAt(i);\n                try {\n                    mPackageManager.getPackageUidAsUser(packageName, accounts.userId);\n                } catch (NameNotFoundException e) {\n                    // package does not exist - remove visibility values\n                    accounts.accountsDb.deleteAccountVisibilityForPackage(packageName);\n                    synchronized (accounts.dbLock) {\n                        synchronized (accounts.cacheLock) {\n                            for (Account account : accounts.visibilityCache.keySet()) {\n                                Map<String, Integer> accountVisibility =\n                                        getPackagesAndVisibilityForAccountLocked(account, accounts);\n                                accountVisibility.remove(packageName);\n                            }\n                            AccountManager.invalidateLocalAccountsDataCaches();\n                        }\n                    }\n              }\n          }\n        }\n    }\n\n    private void purgeUserData(int userId) {\n        UserAccounts accounts;\n        synchronized (mUsers) {\n            accounts = mUsers.get(userId);\n            mUsers.remove(userId);\n            mLocalUnlockedUsers.delete(userId);\n            AccountManager.invalidateLocalAccountsDataCaches();\n        }\n        if (accounts != null) {\n            synchronized (accounts.dbLock) {\n                synchronized (accounts.cacheLock) {\n                    accounts.accountsDb.closeDebugStatement();\n                    accounts.accountsDb.close();\n                }\n            }\n        }\n    }\n\n    @VisibleForTesting\n    void onUserUnlocked(Intent intent) {\n        onUnlockUser(intent.getIntExtra(Intent.EXTRA_USER_HANDLE, -1));\n    }\n\n    void onUnlockUser(int userId) {\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"onUserUnlocked \" + userId);\n        }\n        synchronized (mUsers) {\n            mLocalUnlockedUsers.put(userId, true);\n        }\n        if (userId < 1) return;\n        mHandler.post(() -> syncSharedAccounts(userId));\n    }\n\n    private void syncSharedAccounts(int userId) {\n        // Check if there's a shared account that needs to be created as an account\n        Account[] sharedAccounts = getSharedAccountsAsUser(userId);\n        if (sharedAccounts == null || sharedAccounts.length == 0) return;\n        Account[] accounts = getAccountsAsUser(null, userId, mContext.getOpPackageName());\n        int parentUserId = UserManager.isSplitSystemUser()\n                ? getUserManager().getUserInfo(userId).restrictedProfileParentId\n                : UserHandle.USER_SYSTEM;\n        if (parentUserId < 0) {\n            Log.w(TAG, \"User \" + userId + \" has shared accounts, but no parent user\");\n            return;\n        }\n        for (Account sa : sharedAccounts) {\n            if (ArrayUtils.contains(accounts, sa)) continue;\n            // Account doesn't exist. Copy it now.\n            copyAccountToUser(null /*no response*/, sa, parentUserId, userId);\n        }\n    }\n\n    @Override\n    public void onServiceChanged(AuthenticatorDescription desc, int userId, boolean removed) {\n        UserInfo user = getUserManager().getUserInfo(userId);\n        if (user == null) {\n            Log.w(TAG, \"onServiceChanged: ignore removed user \" + userId);\n            return;\n        }\n        validateAccountsInternal(getUserAccounts(userId), false /* invalidateAuthenticatorCache */);\n    }\n\n    @Override\n    public String getPassword(Account account) {\n        int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"getPassword: \" + account\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        if (account == null) throw new IllegalArgumentException(\"account is null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot get secrets for accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return readPasswordInternal(accounts, account);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private String readPasswordInternal(UserAccounts accounts, Account account) {\n        if (account == null) {\n            return null;\n        }\n        if (!isLocalUnlockedUser(accounts.userId)) {\n            Log.w(TAG, \"Password is not available - user \" + accounts.userId + \" data is locked\");\n            return null;\n        }\n\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                return accounts.accountsDb\n                        .findAccountPasswordByNameAndType(account.name, account.type);\n            }\n        }\n    }\n\n    @Override\n    public String getPreviousName(Account account) {\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"getPreviousName: \" + account\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        int userId = UserHandle.getCallingUserId();\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return readPreviousNameInternal(accounts, account);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private String readPreviousNameInternal(UserAccounts accounts, Account account) {\n        if  (account == null) {\n            return null;\n        }\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                AtomicReference<String> previousNameRef = accounts.previousNameCache.get(account);\n                if (previousNameRef == null) {\n                    String previousName = accounts.accountsDb.findDeAccountPreviousName(account);\n                    previousNameRef = new AtomicReference<>(previousName);\n                    accounts.previousNameCache.put(account, previousNameRef);\n                    return previousName;\n                } else {\n                    return previousNameRef.get();\n                }\n            }\n        }\n    }\n\n    @Override\n    public String getUserData(Account account, String key) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            String msg = String.format(\"getUserData( account: %s, key: %s, callerUid: %s, pid: %s\",\n                    account, key, callingUid, Binder.getCallingPid());\n            Log.v(TAG, msg);\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        Objects.requireNonNull(key, \"key cannot be null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot get user data for accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        if (!isLocalUnlockedUser(userId)) {\n            Log.w(TAG, \"User \" + userId + \" data is locked. callingUid \" + callingUid);\n            return null;\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            if (!accountExistsCache(accounts, account)) {\n                return null;\n            }\n            return readUserDataInternal(accounts, account, key);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public AuthenticatorDescription[] getAuthenticatorTypes(int userId) {\n        int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"getAuthenticatorTypes: \"\n                    + \"for user id \" + userId\n                    + \" caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        // Only allow the system process to read accounts of other users\n        if (isCrossUser(callingUid, userId)) {\n            throw new SecurityException(\n                    String.format(\n                            \"User %s tying to get authenticator types for %s\" ,\n                            UserHandle.getCallingUserId(),\n                            userId));\n        }\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            return getAuthenticatorTypesInternal(userId);\n\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    /**\n     * Should only be called inside of a clearCallingIdentity block.\n     */\n    private AuthenticatorDescription[] getAuthenticatorTypesInternal(int userId) {\n        mAuthenticatorCache.updateServices(userId);\n        Collection<AccountAuthenticatorCache.ServiceInfo<AuthenticatorDescription>>\n                authenticatorCollection = mAuthenticatorCache.getAllServices(userId);\n        AuthenticatorDescription[] types =\n                new AuthenticatorDescription[authenticatorCollection.size()];\n        int i = 0;\n        for (AccountAuthenticatorCache.ServiceInfo<AuthenticatorDescription> authenticator\n                : authenticatorCollection) {\n            types[i] = authenticator.type;\n            i++;\n        }\n        return types;\n    }\n\n    private boolean isCrossUser(int callingUid, int userId) {\n        return (userId != UserHandle.getCallingUserId()\n                && callingUid != Process.SYSTEM_UID\n                && mContext.checkCallingOrSelfPermission(\n                        android.Manifest.permission.INTERACT_ACROSS_USERS_FULL)\n                                != PackageManager.PERMISSION_GRANTED);\n    }\n\n    @Override\n    public boolean addAccountExplicitly(\n            Account account, String password, Bundle extras, String opPackageName) {\n        return addAccountExplicitlyWithVisibility(\n                account, password, extras, /* packageToVisibility= */ null, opPackageName);\n    }\n\n    @Override\n    public void copyAccountToUser(final IAccountManagerResponse response, final Account account,\n            final int userFrom, int userTo) {\n        int callingUid = Binder.getCallingUid();\n        if (isCrossUser(callingUid, UserHandle.USER_ALL)) {\n            throw new SecurityException(\"Calling copyAccountToUser requires \"\n                    + android.Manifest.permission.INTERACT_ACROSS_USERS_FULL);\n        }\n        final UserAccounts fromAccounts = getUserAccounts(userFrom);\n        final UserAccounts toAccounts = getUserAccounts(userTo);\n        if (fromAccounts == null || toAccounts == null) {\n            if (response != null) {\n                Bundle result = new Bundle();\n                result.putBoolean(AccountManager.KEY_BOOLEAN_RESULT, false);\n                try {\n                    response.onResult(result);\n                } catch (RemoteException e) {\n                    Slog.w(TAG, \"Failed to report error back to the client.\" + e);\n                }\n            }\n            return;\n        }\n\n        Slog.d(TAG, \"Copying account \" + account.toSafeString()\n                + \" from user \" + userFrom + \" to user \" + userTo);\n        final long identityToken = clearCallingIdentity();\n        try {\n            new Session(fromAccounts, response, account.type, false,\n                    false /* stripAuthTokenFromResult */, account.name,\n                    false /* authDetailsRequired */) {\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now) + \", getAccountCredentialsForClone\"\n                            + \", \" + account.type;\n                }\n\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.getAccountCredentialsForCloning(this, account);\n                }\n\n                @Override\n                public void onResult(Bundle result) {\n                    Bundle.setDefusable(result, true);\n                    if (result != null\n                            && result.getBoolean(AccountManager.KEY_BOOLEAN_RESULT, false)) {\n                        // Create a Session for the target user and pass in the bundle\n                        completeCloningAccount(response, result, account, toAccounts, userFrom);\n                    } else {\n                        super.onResult(result);\n                    }\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public boolean accountAuthenticated(final Account account) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            String msg = String.format(\n                    \"accountAuthenticated( account: %s, callerUid: %s)\",\n                    account,\n                    callingUid);\n            Log.v(TAG, msg);\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot notify authentication for accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n\n        if (!canUserModifyAccounts(userId, callingUid) ||\n                !canUserModifyAccountsForType(userId, account.type, callingUid)) {\n            return false;\n        }\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return updateLastAuthenticatedTime(account);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private boolean updateLastAuthenticatedTime(Account account) {\n        final UserAccounts accounts = getUserAccountsForCaller();\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                return accounts.accountsDb.updateAccountLastAuthenticatedTime(account);\n            }\n        }\n    }\n\n    private void completeCloningAccount(IAccountManagerResponse response,\n            final Bundle accountCredentials, final Account account, final UserAccounts targetUser,\n            final int parentUserId){\n        Bundle.setDefusable(accountCredentials, true);\n        final long id = clearCallingIdentity();\n        try {\n            new Session(targetUser, response, account.type, false,\n                    false /* stripAuthTokenFromResult */, account.name,\n                    false /* authDetailsRequired */) {\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now) + \", getAccountCredentialsForClone\"\n                            + \", \" + account.type;\n                }\n\n                @Override\n                public void run() throws RemoteException {\n                    // Confirm that the owner's account still exists before this step.\n                    for (Account acc : getAccounts(parentUserId, mContext.getOpPackageName())) {\n                        if (acc.equals(account)) {\n                            mAuthenticator.addAccountFromCredentials(\n                                    this, account, accountCredentials);\n                            break;\n                        }\n                    }\n                }\n\n                @Override\n                public void onResult(Bundle result) {\n                    Bundle.setDefusable(result, true);\n                    // TODO: Anything to do if if succedded?\n                    // TODO: If it failed: Show error notification? Should we remove the shadow\n                    // account to avoid retries?\n                    // TODO: what we do with the visibility?\n\n                    super.onResult(result);\n                }\n\n                @Override\n                public void onError(int errorCode, String errorMessage) {\n                    super.onError(errorCode,  errorMessage);\n                    // TODO: Show error notification to user\n                    // TODO: Should we remove the shadow account so that it doesn't keep trying?\n                }\n\n            }.bind();\n        } finally {\n            restoreCallingIdentity(id);\n        }\n    }\n\n    private boolean addAccountInternal(UserAccounts accounts, Account account, String password,\n            Bundle extras, int callingUid, Map<String, Integer> packageToVisibility,\n            String opPackageName) {\n        Bundle.setDefusable(extras, true);\n        if (account == null) {\n            return false;\n        }\n        if (account.name != null && account.name.length() > 200) {\n            Log.w(TAG, \"Account cannot be added - Name longer than 200 chars\");\n            return false;\n        }\n        if (account.type != null && account.type.length() > 200) {\n            Log.w(TAG, \"Account cannot be added - Name longer than 200 chars\");\n            return false;\n        }\n        if (!isLocalUnlockedUser(accounts.userId)) {\n            Log.w(TAG, \"Account \" + account.toSafeString() + \" cannot be added - user \"\n                    + accounts.userId + \" is locked. callingUid=\" + callingUid);\n            return false;\n        }\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                accounts.accountsDb.beginTransaction();\n                try {\n                    if (accounts.accountsDb.findCeAccountId(account) >= 0) {\n                        Log.w(TAG, \"insertAccountIntoDatabase: \" + account.toSafeString()\n                                + \", skipping since the account already exists\");\n                        return false;\n                    }\n                    if (accounts.accountsDb.findAllDeAccounts().size() > 100) {\n                        Log.w(TAG, \"insertAccountIntoDatabase: \" + account.toSafeString()\n                                + \", skipping since more than 50 accounts on device exist\");\n                        return false;\n                    }\n                    long accountId = accounts.accountsDb.insertCeAccount(account, password);\n                    if (accountId < 0) {\n                        Log.w(TAG, \"insertAccountIntoDatabase: \" + account.toSafeString()\n                                + \", skipping the DB insert failed\");\n                        return false;\n                    }\n                    // Insert into DE table\n                    if (accounts.accountsDb.insertDeAccount(account, accountId) < 0) {\n                        Log.w(TAG, \"insertAccountIntoDatabase: \" + account.toSafeString()\n                                + \", skipping the DB insert failed\");\n                        return false;\n                    }\n                    if (extras != null) {\n                        for (String key : extras.keySet()) {\n                            final String value = extras.getString(key);\n                            if (accounts.accountsDb.insertExtra(accountId, key, value) < 0) {\n                                Log.w(TAG, \"insertAccountIntoDatabase: \"\n                                        + account.toSafeString()\n                                        + \", skipping since insertExtra failed for key \" + key);\n                                return false;\n                            } else {\n                                AccountManager.invalidateLocalAccountUserDataCaches();\n                            }\n                        }\n                    }\n\n                    if (packageToVisibility != null) {\n                        for (Entry<String, Integer> entry : packageToVisibility.entrySet()) {\n                            setAccountVisibility(account, entry.getKey() /* package */,\n                                    entry.getValue() /* visibility */, false /* notify */,\n                                    accounts);\n                        }\n                    }\n                    accounts.accountsDb.setTransactionSuccessful();\n\n                    logRecord(AccountsDb.DEBUG_ACTION_ACCOUNT_ADD, AccountsDb.TABLE_ACCOUNTS,\n                            accountId,\n                            accounts, callingUid);\n\n                    insertAccountIntoCacheLocked(accounts, account);\n                } finally {\n                    accounts.accountsDb.endTransaction();\n                }\n            }\n        }\n        if (getUserManager().getUserInfo(accounts.userId).canHaveProfile()) {\n            addAccountToLinkedRestrictedUsers(account, accounts.userId);\n        }\n\n        sendNotificationAccountUpdated(account, accounts);\n        // Only send LOGIN_ACCOUNTS_CHANGED when the database changed.\n        sendAccountsChangedBroadcast(accounts.userId);\n\n        logAddAccountExplicitlyMetrics(opPackageName, account.type, packageToVisibility);\n        return true;\n    }\n\n    private void logAddAccountExplicitlyMetrics(\n            String callerPackage, String accountType,\n            @Nullable Map<String, Integer> accountVisibility) {\n        // Although this is not a 'device policy' API, enterprise is the current use case.\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.ADD_ACCOUNT_EXPLICITLY)\n                .setStrings(\n                        TextUtils.emptyIfNull(accountType),\n                        TextUtils.emptyIfNull(callerPackage),\n                        findPackagesPerVisibility(accountVisibility))\n                .write();\n    }\n\n    private String[] findPackagesPerVisibility(@Nullable Map<String, Integer> accountVisibility) {\n        Map<Integer, Set<String>> packagesPerVisibility = new HashMap<>();\n        if (accountVisibility != null) {\n            for (Entry<String, Integer> entry : accountVisibility.entrySet()) {\n                if (!packagesPerVisibility.containsKey(entry.getValue())) {\n                    packagesPerVisibility.put(entry.getValue(), new HashSet<>());\n                }\n                packagesPerVisibility.get(entry.getValue()).add(entry.getKey());\n            }\n        }\n\n        String[] packagesPerVisibilityStr = new String[5];\n        packagesPerVisibilityStr[AccountManager.VISIBILITY_UNDEFINED] = getPackagesForVisibilityStr(\n                AccountManager.VISIBILITY_UNDEFINED, packagesPerVisibility);\n        packagesPerVisibilityStr[AccountManager.VISIBILITY_VISIBLE] = getPackagesForVisibilityStr(\n                AccountManager.VISIBILITY_VISIBLE, packagesPerVisibility);\n        packagesPerVisibilityStr[AccountManager.VISIBILITY_USER_MANAGED_VISIBLE] =\n                getPackagesForVisibilityStr(\n                        AccountManager.VISIBILITY_USER_MANAGED_VISIBLE, packagesPerVisibility);\n        packagesPerVisibilityStr[AccountManager.VISIBILITY_NOT_VISIBLE] =\n                getPackagesForVisibilityStr(\n                        AccountManager.VISIBILITY_NOT_VISIBLE, packagesPerVisibility);\n        packagesPerVisibilityStr[AccountManager.VISIBILITY_USER_MANAGED_NOT_VISIBLE] =\n                getPackagesForVisibilityStr(\n                        AccountManager.VISIBILITY_USER_MANAGED_NOT_VISIBLE, packagesPerVisibility);\n        return packagesPerVisibilityStr;\n    }\n\n    private String getPackagesForVisibilityStr(\n            int visibility, Map<Integer, Set<String>> packagesPerVisibility) {\n        return visibility + \":\"\n                + (packagesPerVisibility.containsKey(visibility)\n                    ? TextUtils.join(\",\", packagesPerVisibility.get(visibility))\n                    : \"\");\n    }\n\n    private boolean isLocalUnlockedUser(int userId) {\n        synchronized (mUsers) {\n            return mLocalUnlockedUsers.get(userId);\n        }\n    }\n\n    /**\n     * Adds the account to all linked restricted users as shared accounts. If the user is currently\n     * running, then clone the account too.\n     * @param account the account to share with limited users\n     *\n     */\n    private void addAccountToLinkedRestrictedUsers(Account account, int parentUserId) {\n        List<UserInfo> users = getUserManager().getUsers();\n        for (UserInfo user : users) {\n            if (user.isRestricted() && (parentUserId == user.restrictedProfileParentId)) {\n                addSharedAccountAsUser(account, user.id);\n                if (isLocalUnlockedUser(user.id)) {\n                    mHandler.sendMessage(mHandler.obtainMessage(\n                            MESSAGE_COPY_SHARED_ACCOUNT, parentUserId, user.id, account));\n                }\n            }\n        }\n    }\n\n    @Override\n    public void hasFeatures(IAccountManagerResponse response,\n            Account account, String[] features, String opPackageName) {\n        int callingUid = Binder.getCallingUid();\n        mAppOpsManager.checkPackage(callingUid, opPackageName);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"hasFeatures: \" + account\n                    + \", response \" + response\n                    + \", features \" + Arrays.toString(features)\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Preconditions.checkArgument(account != null, \"account cannot be null\");\n        Preconditions.checkArgument(response != null, \"response cannot be null\");\n        Preconditions.checkArgument(features != null, \"features cannot be null\");\n        int userId = UserHandle.getCallingUserId();\n        checkReadAccountsPermitted(callingUid, account.type, userId,\n                opPackageName);\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            new TestFeaturesSession(accounts, response, account, features).bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private class TestFeaturesSession extends Session {\n        private final String[] mFeatures;\n        private final Account mAccount;\n\n        public TestFeaturesSession(UserAccounts accounts, IAccountManagerResponse response,\n                Account account, String[] features) {\n            super(accounts, response, account.type, false /* expectActivityLaunch */,\n                    true /* stripAuthTokenFromResult */, account.name,\n                    false /* authDetailsRequired */);\n            mFeatures = features;\n            mAccount = account;\n        }\n\n        @Override\n        public void run() throws RemoteException {\n            try {\n                mAuthenticator.hasFeatures(this, mAccount, mFeatures);\n            } catch (RemoteException e) {\n                onError(AccountManager.ERROR_CODE_REMOTE_EXCEPTION, \"remote exception\");\n            }\n        }\n\n        @Override\n        public void onResult(Bundle result) {\n            Bundle.setDefusable(result, true);\n            IAccountManagerResponse response = getResponseAndClose();\n            if (response != null) {\n                try {\n                    if (result == null) {\n                        response.onError(AccountManager.ERROR_CODE_INVALID_RESPONSE, \"null bundle\");\n                        return;\n                    }\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, getClass().getSimpleName() + \" calling onResult() on response \"\n                                + response);\n                    }\n                    final Bundle newResult = new Bundle();\n                    newResult.putBoolean(AccountManager.KEY_BOOLEAN_RESULT,\n                            result.getBoolean(AccountManager.KEY_BOOLEAN_RESULT, false));\n                    response.onResult(newResult);\n                } catch (RemoteException e) {\n                    // if the caller is dead then there is no one to care about remote exceptions\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, \"failure while notifying response\", e);\n                    }\n                }\n            }\n        }\n\n        @Override\n        protected String toDebugString(long now) {\n            return super.toDebugString(now) + \", hasFeatures\"\n                    + \", \" + mAccount\n                    + \", \" + (mFeatures != null ? TextUtils.join(\",\", mFeatures) : null);\n        }\n    }\n\n    @Override\n    public void renameAccount(\n            IAccountManagerResponse response, Account accountToRename, String newName) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"renameAccount: \" + accountToRename + \" -> \" + newName\n                + \", caller's uid \" + callingUid\n                + \", pid \" + Binder.getCallingPid());\n        }\n        if (accountToRename == null) throw new IllegalArgumentException(\"account is null\");\n        if (newName != null && newName.length() > 200) {\n            Log.e(TAG, \"renameAccount failed - account name longer than 200\");\n            throw new IllegalArgumentException(\"account name longer than 200\");\n        }\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(accountToRename.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot rename accounts of type: %s\",\n                    callingUid,\n                    accountToRename.type);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            Account resultingAccount = renameAccountInternal(accounts, accountToRename, newName);\n            Bundle result = new Bundle();\n            result.putString(AccountManager.KEY_ACCOUNT_NAME, resultingAccount.name);\n            result.putString(AccountManager.KEY_ACCOUNT_TYPE, resultingAccount.type);\n            result.putString(AccountManager.KEY_ACCOUNT_ACCESS_ID,\n                    resultingAccount.getAccessId());\n            try {\n                response.onResult(result);\n            } catch (RemoteException e) {\n                Log.w(TAG, e.getMessage());\n            }\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private Account renameAccountInternal(\n            UserAccounts accounts, Account accountToRename, String newName) {\n        Account resultAccount = null;\n        /*\n         * Cancel existing notifications. Let authenticators\n         * re-post notifications as required. But we don't know if\n         * the authenticators have bound their notifications to\n         * now stale account name data.\n         *\n         * With a rename api, we might not need to do this anymore but it\n         * shouldn't hurt.\n         */\n        cancelNotification(\n                getSigninRequiredNotificationId(accounts, accountToRename),\n                new UserHandle(accounts.userId));\n        synchronized(accounts.credentialsPermissionNotificationIds) {\n            for (Pair<Pair<Account, String>, Integer> pair:\n                    accounts.credentialsPermissionNotificationIds.keySet()) {\n                if (accountToRename.equals(pair.first.first)) {\n                    NotificationId id = accounts.credentialsPermissionNotificationIds.get(pair);\n                    cancelNotification(id, new UserHandle(accounts.userId));\n                }\n            }\n        }\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                List<String> accountRemovedReceivers =\n                    getAccountRemovedReceivers(accountToRename, accounts);\n                accounts.accountsDb.beginTransaction();\n                Account renamedAccount = new Account(newName, accountToRename.type);\n                try {\n                    if ((accounts.accountsDb.findCeAccountId(renamedAccount) >= 0)) {\n                        Log.e(TAG, \"renameAccount failed - account with new name already exists\");\n                        return null;\n                    }\n                    final long accountId = accounts.accountsDb.findDeAccountId(accountToRename);\n                    if (accountId >= 0) {\n                        accounts.accountsDb.renameCeAccount(accountId, newName);\n                        if (accounts.accountsDb.renameDeAccount(\n                                accountId, newName, accountToRename.name)) {\n                            accounts.accountsDb.setTransactionSuccessful();\n                        } else {\n                            Log.e(TAG, \"renameAccount failed\");\n                            return null;\n                        }\n                    } else {\n                        Log.e(TAG, \"renameAccount failed - old account does not exist\");\n                        return null;\n                    }\n                } finally {\n                    accounts.accountsDb.endTransaction();\n                }\n            /*\n             * Database transaction was successful. Clean up cached\n             * data associated with the account in the user profile.\n             */\n                renamedAccount = insertAccountIntoCacheLocked(accounts, renamedAccount);\n            /*\n             * Extract the data and token caches before removing the\n             * old account to preserve the user data associated with\n             * the account.\n             */\n                Map<String, String> tmpData = accounts.userDataCache.get(accountToRename);\n                Map<String, String> tmpTokens = accounts.authTokenCache.get(accountToRename);\n                Map<String, Integer> tmpVisibility = accounts.visibilityCache.get(accountToRename);\n                removeAccountFromCacheLocked(accounts, accountToRename);\n            /*\n             * Update the cached data associated with the renamed\n             * account.\n             */\n                accounts.userDataCache.put(renamedAccount, tmpData);\n                accounts.authTokenCache.put(renamedAccount, tmpTokens);\n                accounts.visibilityCache.put(renamedAccount, tmpVisibility);\n                accounts.previousNameCache.put(\n                        renamedAccount,\n                        new AtomicReference<>(accountToRename.name));\n                resultAccount = renamedAccount;\n\n                int parentUserId = accounts.userId;\n                if (canHaveProfile(parentUserId)) {\n                /*\n                 * Owner or system user account was renamed, rename the account for\n                 * those users with which the account was shared.\n                 */\n                    List<UserInfo> users = getUserManager().getAliveUsers();\n                    for (UserInfo user : users) {\n                        if (user.isRestricted()\n                                && (user.restrictedProfileParentId == parentUserId)) {\n                            renameSharedAccountAsUser(accountToRename, newName, user.id);\n                        }\n                    }\n                }\n\n                sendNotificationAccountUpdated(resultAccount, accounts);\n                sendAccountsChangedBroadcast(accounts.userId);\n                for (String packageName : accountRemovedReceivers) {\n                    sendAccountRemovedBroadcast(accountToRename, packageName, accounts.userId);\n                }\n\n                AccountManager.invalidateLocalAccountsDataCaches();\n                AccountManager.invalidateLocalAccountUserDataCaches();\n            }\n        }\n        return resultAccount;\n    }\n\n    private boolean canHaveProfile(final int parentUserId) {\n        final UserInfo userInfo = getUserManager().getUserInfo(parentUserId);\n        return userInfo != null && userInfo.canHaveProfile();\n    }\n\n    @Override\n    public void removeAccountAsUser(IAccountManagerResponse response, Account account,\n            boolean expectActivityLaunch, int userId) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"removeAccount: \" + account\n                    + \", response \" + response\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid()\n                    + \", for user id \" + userId);\n        }\n        Preconditions.checkArgument(account != null, \"account cannot be null\");\n        Preconditions.checkArgument(response != null, \"response cannot be null\");\n\n        // Only allow the system process to modify accounts of other users\n        if (isCrossUser(callingUid, userId)) {\n            throw new SecurityException(\n                    String.format(\n                            \"User %s tying remove account for %s\" ,\n                            UserHandle.getCallingUserId(),\n                            userId));\n        }\n        /*\n         * Only the system, authenticator or profile owner should be allowed to remove accounts for\n         * that authenticator.  This will let users remove accounts (via Settings in the system) but\n         * not arbitrary applications (like competing authenticators).\n         */\n        UserHandle user = UserHandle.of(userId);\n        if (!isAccountManagedByCaller(account.type, callingUid, user.getIdentifier())\n                && !isSystemUid(callingUid)\n                && !isProfileOwner(callingUid)) {\n            String msg = String.format(\n                    \"uid %s cannot remove accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        if (!canUserModifyAccounts(userId, callingUid)) {\n            try {\n                response.onError(AccountManager.ERROR_CODE_USER_RESTRICTED,\n                        \"User cannot modify accounts\");\n            } catch (RemoteException re) {\n            }\n            return;\n        }\n        if (!canUserModifyAccountsForType(userId, account.type, callingUid)) {\n            try {\n                response.onError(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                        \"User cannot modify accounts of this type (policy).\");\n            } catch (RemoteException re) {\n            }\n            return;\n        }\n        final long identityToken = clearCallingIdentity();\n        UserAccounts accounts = getUserAccounts(userId);\n        cancelNotification(getSigninRequiredNotificationId(accounts, account), user);\n        synchronized(accounts.credentialsPermissionNotificationIds) {\n            for (Pair<Pair<Account, String>, Integer> pair:\n                accounts.credentialsPermissionNotificationIds.keySet()) {\n                if (account.equals(pair.first.first)) {\n                    NotificationId id = accounts.credentialsPermissionNotificationIds.get(pair);\n                    cancelNotification(id, user);\n                }\n            }\n        }\n        final long accountId = accounts.accountsDb.findDeAccountId(account);\n        logRecord(\n                AccountsDb.DEBUG_ACTION_CALLED_ACCOUNT_REMOVE,\n                AccountsDb.TABLE_ACCOUNTS,\n                accountId,\n                accounts,\n                callingUid);\n        try {\n            new RemoveAccountSession(accounts, response, account, expectActivityLaunch).bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public boolean removeAccountExplicitly(Account account) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"removeAccountExplicitly: \" + account\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        int userId = Binder.getCallingUserHandle().getIdentifier();\n        if (account == null) {\n            /*\n             * Null accounts should result in returning false, as per\n             * AccountManage.addAccountExplicitly(...) java doc.\n             */\n            Log.e(TAG, \"account is null\");\n            return false;\n        } else if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot explicitly remove accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        UserAccounts accounts = getUserAccountsForCaller();\n        final long accountId = accounts.accountsDb.findDeAccountId(account);\n        logRecord(\n                AccountsDb.DEBUG_ACTION_CALLED_ACCOUNT_REMOVE,\n                AccountsDb.TABLE_ACCOUNTS,\n                accountId,\n                accounts,\n                callingUid);\n        final long identityToken = clearCallingIdentity();\n        try {\n            return removeAccountInternal(accounts, account, callingUid);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private class RemoveAccountSession extends Session {\n        final Account mAccount;\n        public RemoveAccountSession(UserAccounts accounts, IAccountManagerResponse response,\n                Account account, boolean expectActivityLaunch) {\n            super(accounts, response, account.type, expectActivityLaunch,\n                    true /* stripAuthTokenFromResult */, account.name,\n                    false /* authDetailsRequired */);\n            mAccount = account;\n        }\n\n        @Override\n        protected String toDebugString(long now) {\n            return super.toDebugString(now) + \", removeAccount\"\n                    + \", account \" + mAccount;\n        }\n\n        @Override\n        public void run() throws RemoteException {\n            mAuthenticator.getAccountRemovalAllowed(this, mAccount);\n        }\n\n        @Override\n        public void onResult(Bundle result) {\n            Bundle.setDefusable(result, true);\n            if (result != null && result.containsKey(AccountManager.KEY_BOOLEAN_RESULT)\n                    && !result.containsKey(AccountManager.KEY_INTENT)) {\n                final boolean removalAllowed = result.getBoolean(AccountManager.KEY_BOOLEAN_RESULT);\n                if (removalAllowed) {\n                    removeAccountInternal(mAccounts, mAccount, getCallingUid());\n                }\n                IAccountManagerResponse response = getResponseAndClose();\n                if (response != null) {\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, getClass().getSimpleName() + \" calling onResult() on response \"\n                                + response);\n                    }\n                    try {\n                        response.onResult(result);\n                    } catch (RemoteException e) {\n                        Slog.e(TAG, \"Error calling onResult()\", e);\n                    }\n                }\n            }\n            super.onResult(result);\n        }\n    }\n\n    @VisibleForTesting\n    protected void removeAccountInternal(Account account) {\n        removeAccountInternal(getUserAccountsForCaller(), account, getCallingUid());\n    }\n\n    private boolean removeAccountInternal(UserAccounts accounts, Account account, int callingUid) {\n        boolean isChanged = false;\n        boolean userUnlocked = isLocalUnlockedUser(accounts.userId);\n        if (!userUnlocked) {\n            Slog.i(TAG, \"Removing account \" + account.toSafeString()\n                    + \" while user \" + accounts.userId\n                    + \" is still locked. CE data will be removed later\");\n        }\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                Map<String, Integer> packagesToVisibility = getRequestingPackages(account,\n                        accounts);\n                List<String> accountRemovedReceivers =\n                    getAccountRemovedReceivers(account, accounts);\n                accounts.accountsDb.beginTransaction();\n                // Set to a placeholder value, this will only be used if the database\n                // transaction succeeds.\n                long accountId = -1;\n                try {\n                    accountId = accounts.accountsDb.findDeAccountId(account);\n                    if (accountId >= 0) {\n                        isChanged = accounts.accountsDb.deleteDeAccount(accountId);\n                    }\n                    // always delete from CE table if CE storage is available\n                    // DE account could be removed while CE was locked\n                    if (userUnlocked) {\n                        long ceAccountId = accounts.accountsDb.findCeAccountId(account);\n                        if (ceAccountId >= 0) {\n                            accounts.accountsDb.deleteCeAccount(ceAccountId);\n                        }\n                    }\n                    accounts.accountsDb.setTransactionSuccessful();\n                } finally {\n                    accounts.accountsDb.endTransaction();\n                }\n                if (isChanged) {\n                    removeAccountFromCacheLocked(accounts, account);\n                    for (Entry<String, Integer> packageToVisibility : packagesToVisibility\n                            .entrySet()) {\n                        if ((packageToVisibility.getValue() == AccountManager.VISIBILITY_VISIBLE)\n                                || (packageToVisibility.getValue()\n                                    == AccountManager.VISIBILITY_USER_MANAGED_VISIBLE)) {\n                            notifyPackage(packageToVisibility.getKey(), accounts);\n                        }\n                    }\n\n                    // Only broadcast LOGIN_ACCOUNTS_CHANGED if a change occurred.\n                    sendAccountsChangedBroadcast(accounts.userId);\n                    for (String packageName : accountRemovedReceivers) {\n                        sendAccountRemovedBroadcast(account, packageName, accounts.userId);\n                    }\n                    String action = userUnlocked ? AccountsDb.DEBUG_ACTION_ACCOUNT_REMOVE\n                            : AccountsDb.DEBUG_ACTION_ACCOUNT_REMOVE_DE;\n                    logRecord(action, AccountsDb.TABLE_ACCOUNTS, accountId, accounts);\n                }\n            }\n        }\n        final long id = Binder.clearCallingIdentity();\n        try {\n            int parentUserId = accounts.userId;\n            if (canHaveProfile(parentUserId)) {\n                // Remove from any restricted profiles that are sharing this account.\n                List<UserInfo> users = getUserManager().getAliveUsers();\n                for (UserInfo user : users) {\n                    if (user.isRestricted() && parentUserId == (user.restrictedProfileParentId)) {\n                        removeSharedAccountAsUser(account, user.id, callingUid);\n                    }\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(id);\n        }\n\n        if (isChanged) {\n            synchronized (accounts.credentialsPermissionNotificationIds) {\n                for (Pair<Pair<Account, String>, Integer> key\n                        : accounts.credentialsPermissionNotificationIds.keySet()) {\n                    if (account.equals(key.first.first)\n                            && AccountManager.ACCOUNT_ACCESS_TOKEN_TYPE.equals(key.first.second)) {\n                        final int uid = (Integer) key.second;\n                        mHandler.post(() -> cancelAccountAccessRequestNotificationIfNeeded(\n                                account, uid, false));\n                    }\n                }\n            }\n        }\n\n        AccountManager.invalidateLocalAccountUserDataCaches();\n\n        return isChanged;\n    }\n\n    @Override\n    public void invalidateAuthToken(String accountType, String authToken) {\n        int callerUid = Binder.getCallingUid();\n        Objects.requireNonNull(accountType, \"accountType cannot be null\");\n        Objects.requireNonNull(authToken, \"authToken cannot be null\");\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"invalidateAuthToken: accountType \" + accountType\n                    + \", caller's uid \" + callerUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        int userId = UserHandle.getCallingUserId();\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            List<Pair<Account, String>> deletedTokens;\n            synchronized (accounts.dbLock) {\n                accounts.accountsDb.beginTransaction();\n                try {\n                    deletedTokens = invalidateAuthTokenLocked(accounts, accountType, authToken);\n                    accounts.accountsDb.setTransactionSuccessful();\n                } finally {\n                    accounts.accountsDb.endTransaction();\n                }\n                synchronized (accounts.cacheLock) {\n                    for (Pair<Account, String> tokenInfo : deletedTokens) {\n                        Account act = tokenInfo.first;\n                        String tokenType = tokenInfo.second;\n                        writeAuthTokenIntoCacheLocked(accounts, act, tokenType, null);\n                    }\n                    // wipe out cached token in memory.\n                    accounts.accountTokenCaches.remove(accountType, authToken);\n                }\n            }\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private List<Pair<Account, String>> invalidateAuthTokenLocked(UserAccounts accounts, String accountType,\n            String authToken) {\n        // TODO Move to AccountsDB\n        List<Pair<Account, String>> results = new ArrayList<>();\n        Cursor cursor = accounts.accountsDb.findAuthtokenForAllAccounts(accountType, authToken);\n\n        try {\n            while (cursor.moveToNext()) {\n                String authTokenId = cursor.getString(0);\n                String accountName = cursor.getString(1);\n                String authTokenType = cursor.getString(2);\n                accounts.accountsDb.deleteAuthToken(authTokenId);\n                results.add(Pair.create(new Account(accountName, accountType), authTokenType));\n            }\n        } finally {\n            cursor.close();\n        }\n        return results;\n    }\n\n    private void saveCachedToken(\n            UserAccounts accounts,\n            Account account,\n            String callerPkg,\n            byte[] callerSigDigest,\n            String tokenType,\n            String token,\n            long expiryMillis) {\n\n        if (account == null || tokenType == null || callerPkg == null || callerSigDigest == null) {\n            return;\n        }\n        cancelNotification(getSigninRequiredNotificationId(accounts, account),\n                UserHandle.of(accounts.userId));\n        synchronized (accounts.cacheLock) {\n            accounts.accountTokenCaches.put(\n                    account, token, tokenType, callerPkg, callerSigDigest, expiryMillis);\n        }\n    }\n\n    private boolean saveAuthTokenToDatabase(UserAccounts accounts, Account account, String type,\n            String authToken) {\n        if (account == null || type == null) {\n            return false;\n        }\n        cancelNotification(getSigninRequiredNotificationId(accounts, account),\n                UserHandle.of(accounts.userId));\n        synchronized (accounts.dbLock) {\n            accounts.accountsDb.beginTransaction();\n            boolean updateCache = false;\n            try {\n                long accountId = accounts.accountsDb.findDeAccountId(account);\n                if (accountId < 0) {\n                    return false;\n                }\n                accounts.accountsDb.deleteAuthtokensByAccountIdAndType(accountId, type);\n                if (accounts.accountsDb.insertAuthToken(accountId, type, authToken) >= 0) {\n                    accounts.accountsDb.setTransactionSuccessful();\n                    updateCache = true;\n                    return true;\n                }\n                return false;\n            } finally {\n                accounts.accountsDb.endTransaction();\n                if (updateCache) {\n                    synchronized (accounts.cacheLock) {\n                        writeAuthTokenIntoCacheLocked(accounts, account, type, authToken);\n                    }\n                }\n            }\n        }\n    }\n\n    @Override\n    public String peekAuthToken(Account account, String authTokenType) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"peekAuthToken: \" + account\n                    + \", authTokenType \" + authTokenType\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        Objects.requireNonNull(authTokenType, \"authTokenType cannot be null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot peek the authtokens associated with accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        if (!isLocalUnlockedUser(userId)) {\n            Log.w(TAG, \"Authtoken not available - user \" + userId + \" data is locked. callingUid \"\n                    + callingUid);\n            return null;\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return readAuthTokenInternal(accounts, account, authTokenType);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void setAuthToken(Account account, String authTokenType, String authToken) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"setAuthToken: \" + account\n                    + \", authTokenType \" + authTokenType\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        Objects.requireNonNull(authTokenType, \"authTokenType cannot be null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot set auth tokens associated with accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            saveAuthTokenToDatabase(accounts, account, authTokenType, authToken);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void setPassword(Account account, String password) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"setAuthToken: \" + account\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot set secrets for accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            setPasswordInternal(accounts, account, password, callingUid);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private void setPasswordInternal(UserAccounts accounts, Account account, String password,\n            int callingUid) {\n        if (account == null) {\n            return;\n        }\n        boolean isChanged = false;\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                accounts.accountsDb.beginTransaction();\n                try {\n                    final long accountId = accounts.accountsDb.findDeAccountId(account);\n                    if (accountId >= 0) {\n                        accounts.accountsDb.updateCeAccountPassword(accountId, password);\n                        accounts.accountsDb.deleteAuthTokensByAccountId(accountId);\n                        accounts.authTokenCache.remove(account);\n                        accounts.accountTokenCaches.remove(account);\n                        accounts.accountsDb.setTransactionSuccessful();\n                        // If there is an account whose password will be updated and the database\n                        // transactions succeed, then we say that a change has occured. Even if the\n                        // new password is the same as the old and there were no authtokens to\n                        // delete.\n                        isChanged = true;\n                        String action = (password == null || password.length() == 0) ?\n                                AccountsDb.DEBUG_ACTION_CLEAR_PASSWORD\n                                : AccountsDb.DEBUG_ACTION_SET_PASSWORD;\n                        logRecord(action, AccountsDb.TABLE_ACCOUNTS, accountId, accounts,\n                                callingUid);\n                    }\n                } finally {\n                    accounts.accountsDb.endTransaction();\n                    if (isChanged) {\n                        // Send LOGIN_ACCOUNTS_CHANGED only if the something changed.\n                        sendNotificationAccountUpdated(account, accounts);\n                        sendAccountsChangedBroadcast(accounts.userId);\n                    }\n                }\n            }\n        }\n    }\n\n    @Override\n    public void clearPassword(Account account) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"clearPassword: \" + account\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot clear passwords for accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            setPasswordInternal(accounts, account, null, callingUid);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void setUserData(Account account, String key, String value) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"setUserData: \" + account\n                    + \", key \" + key\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        if (key == null) throw new IllegalArgumentException(\"key is null\");\n        if (account == null) throw new IllegalArgumentException(\"account is null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot set user data for accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            if (!accountExistsCache(accounts, account)) {\n                return;\n            }\n            setUserdataInternal(accounts, account, key, value);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private boolean accountExistsCache(UserAccounts accounts, Account account) {\n        synchronized (accounts.cacheLock) {\n            if (accounts.accountCache.containsKey(account.type)) {\n                for (Account acc : accounts.accountCache.get(account.type)) {\n                    if (acc.name.equals(account.name)) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    private void setUserdataInternal(UserAccounts accounts, Account account, String key,\n            String value) {\n        synchronized (accounts.dbLock) {\n            accounts.accountsDb.beginTransaction();\n            try {\n                long accountId = accounts.accountsDb.findDeAccountId(account);\n                if (accountId < 0) {\n                    return;\n                }\n                long extrasId = accounts.accountsDb.findExtrasIdByAccountId(accountId, key);\n                if (extrasId < 0) {\n                    extrasId = accounts.accountsDb.insertExtra(accountId, key, value);\n                    if (extrasId < 0) {\n                        return;\n                    }\n                } else if (!accounts.accountsDb.updateExtra(extrasId, value)) {\n                    return;\n                }\n                accounts.accountsDb.setTransactionSuccessful();\n            } finally {\n                accounts.accountsDb.endTransaction();\n            }\n            synchronized (accounts.cacheLock) {\n                writeUserDataIntoCacheLocked(accounts, account, key, value);\n                AccountManager.invalidateLocalAccountUserDataCaches();\n            }\n        }\n    }\n\n    private void onResult(IAccountManagerResponse response, Bundle result) {\n        if (result == null) {\n            Log.e(TAG, \"the result is unexpectedly null\", new Exception());\n        }\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, getClass().getSimpleName() + \" calling onResult() on response \"\n                    + response);\n        }\n        try {\n            response.onResult(result);\n        } catch (RemoteException e) {\n            // if the caller is dead then there is no one to care about remote\n            // exceptions\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"failure while notifying response\", e);\n            }\n        }\n    }\n\n    @Override\n    public void getAuthTokenLabel(IAccountManagerResponse response, final String accountType,\n                                  final String authTokenType)\n            throws RemoteException {\n        Preconditions.checkArgument(accountType != null, \"accountType cannot be null\");\n        Preconditions.checkArgument(authTokenType != null, \"authTokenType cannot be null\");\n\n        final int callingUid = getCallingUid();\n        clearCallingIdentity();\n        if (UserHandle.getAppId(callingUid) != Process.SYSTEM_UID) {\n            throw new SecurityException(\"can only call from system\");\n        }\n        int userId = UserHandle.getUserId(callingUid);\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            new Session(accounts, response, accountType, false /* expectActivityLaunch */,\n                    false /* stripAuthTokenFromResult */,  null /* accountName */,\n                    false /* authDetailsRequired */) {\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now) + \", getAuthTokenLabel\"\n                            + \", \" + accountType\n                            + \", authTokenType \" + authTokenType;\n                }\n\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.getAuthTokenLabel(this, authTokenType);\n                }\n\n                @Override\n                public void onResult(Bundle result) {\n                    Bundle.setDefusable(result, true);\n                    if (result != null) {\n                        String label = result.getString(AccountManager.KEY_AUTH_TOKEN_LABEL);\n                        Bundle bundle = new Bundle();\n                        bundle.putString(AccountManager.KEY_AUTH_TOKEN_LABEL, label);\n                        super.onResult(bundle);\n                        return;\n                    } else {\n                        super.onResult(result);\n                    }\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void getAuthToken(\n            IAccountManagerResponse response,\n            final Account account,\n            final String authTokenType,\n            final boolean notifyOnAuthFailure,\n            final boolean expectActivityLaunch,\n            final Bundle loginOptions) {\n        Bundle.setDefusable(loginOptions, true);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"getAuthToken: \" + account\n                    + \", response \" + response\n                    + \", authTokenType \" + authTokenType\n                    + \", notifyOnAuthFailure \" + notifyOnAuthFailure\n                    + \", expectActivityLaunch \" + expectActivityLaunch\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Preconditions.checkArgument(response != null, \"response cannot be null\");\n        try {\n            if (account == null) {\n                Slog.w(TAG, \"getAuthToken called with null account\");\n                response.onError(AccountManager.ERROR_CODE_BAD_ARGUMENTS, \"account is null\");\n                return;\n            }\n            if (authTokenType == null) {\n                Slog.w(TAG, \"getAuthToken called with null authTokenType\");\n                response.onError(AccountManager.ERROR_CODE_BAD_ARGUMENTS, \"authTokenType is null\");\n                return;\n            }\n        } catch (RemoteException e) {\n            Slog.w(TAG, \"Failed to report error back to the client.\" + e);\n            return;\n        }\n        int userId = UserHandle.getCallingUserId();\n        final long ident = Binder.clearCallingIdentity();\n        final UserAccounts accounts;\n        final RegisteredServicesCache.ServiceInfo<AuthenticatorDescription> authenticatorInfo;\n        try {\n            accounts = getUserAccounts(userId);\n            authenticatorInfo = mAuthenticatorCache.getServiceInfo(\n                    AuthenticatorDescription.newKey(account.type), accounts.userId);\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n\n        final boolean customTokens =\n                authenticatorInfo != null && authenticatorInfo.type.customTokens;\n\n        // skip the check if customTokens\n        final int callerUid = Binder.getCallingUid();\n        final boolean permissionGranted =\n                customTokens || permissionIsGranted(account, authTokenType, callerUid, userId);\n\n        // Get the calling package. We will use it for the purpose of caching.\n        final String callerPkg = loginOptions.getString(AccountManager.KEY_ANDROID_PACKAGE_NAME);\n        String[] callerOwnedPackageNames;\n        final long ident2 = Binder.clearCallingIdentity();\n        try {\n            callerOwnedPackageNames = mPackageManager.getPackagesForUid(callerUid);\n        } finally {\n            Binder.restoreCallingIdentity(ident2);\n        }\n        if (callerPkg == null || callerOwnedPackageNames == null\n                || !ArrayUtils.contains(callerOwnedPackageNames, callerPkg)) {\n            String msg = String.format(\n                    \"Uid %s is attempting to illegally masquerade as package %s!\",\n                    callerUid,\n                    callerPkg);\n            throw new SecurityException(msg);\n        }\n\n        // let authenticator know the identity of the caller\n        loginOptions.putInt(AccountManager.KEY_CALLER_UID, callerUid);\n        loginOptions.putInt(AccountManager.KEY_CALLER_PID, Binder.getCallingPid());\n\n        if (notifyOnAuthFailure) {\n            loginOptions.putBoolean(AccountManager.KEY_NOTIFY_ON_FAILURE, true);\n        }\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            // Distill the caller's package signatures into a single digest.\n            final byte[] callerPkgSigDigest = calculatePackageSignatureDigest(callerPkg);\n\n            // if the caller has permission, do the peek. otherwise go the more expensive\n            // route of starting a Session\n            if (!customTokens && permissionGranted) {\n                String authToken = readAuthTokenInternal(accounts, account, authTokenType);\n                if (authToken != null) {\n                    logGetAuthTokenMetrics(callerPkg, account.type);\n                    Bundle result = new Bundle();\n                    result.putString(AccountManager.KEY_AUTHTOKEN, authToken);\n                    result.putString(AccountManager.KEY_ACCOUNT_NAME, account.name);\n                    result.putString(AccountManager.KEY_ACCOUNT_TYPE, account.type);\n                    onResult(response, result);\n                    return;\n                }\n            }\n\n            if (customTokens) {\n                /*\n                 * Look up tokens in the new cache only if the loginOptions don't have parameters\n                 * outside of those expected to be injected by the AccountManager, e.g.\n                 * ANDORID_PACKAGE_NAME.\n                 */\n                String token = readCachedTokenInternal(\n                        accounts,\n                        account,\n                        authTokenType,\n                        callerPkg,\n                        callerPkgSigDigest);\n                if (token != null) {\n                    logGetAuthTokenMetrics(callerPkg, account.type);\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, \"getAuthToken: cache hit ofr custom token authenticator.\");\n                    }\n                    Bundle result = new Bundle();\n                    result.putString(AccountManager.KEY_AUTHTOKEN, token);\n                    result.putString(AccountManager.KEY_ACCOUNT_NAME, account.name);\n                    result.putString(AccountManager.KEY_ACCOUNT_TYPE, account.type);\n                    onResult(response, result);\n                    return;\n                }\n            }\n\n            new Session(\n                    accounts,\n                    response,\n                    account.type,\n                    expectActivityLaunch,\n                    false /* stripAuthTokenFromResult */,\n                    account.name,\n                    false /* authDetailsRequired */) {\n                @Override\n                protected String toDebugString(long now) {\n                    if (loginOptions != null) loginOptions.keySet();\n                    return super.toDebugString(now) + \", getAuthToken\"\n                            + \", \" + account.toSafeString()\n                            + \", authTokenType \" + authTokenType\n                            + \", loginOptions \" + loginOptions\n                            + \", notifyOnAuthFailure \" + notifyOnAuthFailure;\n                }\n\n                @Override\n                public void run() throws RemoteException {\n                    // If the caller doesn't have permission then create and return the\n                    // \"grant permission\" intent instead of the \"getAuthToken\" intent.\n                    if (!permissionGranted) {\n                        mAuthenticator.getAuthTokenLabel(this, authTokenType);\n                    } else {\n                        mAuthenticator.getAuthToken(this, account, authTokenType, loginOptions);\n                        logGetAuthTokenMetrics(callerPkg, account.type);\n                    }\n                }\n\n                @Override\n                public void onResult(Bundle result) {\n                    Bundle.setDefusable(result, true);\n                    if (result != null) {\n                        if (result.containsKey(AccountManager.KEY_AUTH_TOKEN_LABEL)) {\n                            Intent intent = newGrantCredentialsPermissionIntent(\n                                    account,\n                                    null,\n                                    callerUid,\n                                    new AccountAuthenticatorResponse(this),\n                                    authTokenType,\n                                    true);\n                            Bundle bundle = new Bundle();\n                            bundle.putParcelable(AccountManager.KEY_INTENT, intent);\n                            onResult(bundle);\n                            return;\n                        }\n                        String authToken = result.getString(AccountManager.KEY_AUTHTOKEN);\n                        if (authToken != null) {\n                            String name = result.getString(AccountManager.KEY_ACCOUNT_NAME);\n                            String type = result.getString(AccountManager.KEY_ACCOUNT_TYPE);\n                            if (TextUtils.isEmpty(type) || TextUtils.isEmpty(name)) {\n                                onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                                        \"the type and name should not be empty\");\n                                return;\n                            }\n                            Account resultAccount = new Account(name, type);\n                            if (!customTokens) {\n                                saveAuthTokenToDatabase(\n                                        mAccounts,\n                                        resultAccount,\n                                        authTokenType,\n                                        authToken);\n                            }\n                            long expiryMillis = result.getLong(\n                                    AbstractAccountAuthenticator.KEY_CUSTOM_TOKEN_EXPIRY, 0L);\n                            if (customTokens\n                                    && expiryMillis > System.currentTimeMillis()) {\n                                saveCachedToken(\n                                        mAccounts,\n                                        account,\n                                        callerPkg,\n                                        callerPkgSigDigest,\n                                        authTokenType,\n                                        authToken,\n                                        expiryMillis);\n                            }\n                        }\n\n                        Intent intent = result.getParcelable(AccountManager.KEY_INTENT);\n                        if (intent != null && notifyOnAuthFailure && !customTokens) {\n                            /*\n                             * Make sure that the supplied intent is owned by the authenticator\n                             * giving it to the system. Otherwise a malicious authenticator could\n                             * have users launching arbitrary activities by tricking users to\n                             * interact with malicious notifications.\n                             */\n                            if (!checkKeyIntent(\n                                    Binder.getCallingUid(),\n                                    result)) {\n                                onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                                        \"invalid intent in bundle returned\");\n                                return;\n                            }\n                            doNotification(\n                                    mAccounts,\n                                    account,\n                                    result.getString(AccountManager.KEY_AUTH_FAILED_MESSAGE),\n                                    intent, \"android\", accounts.userId);\n                        }\n                    }\n                    super.onResult(result);\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private void logGetAuthTokenMetrics(final String callerPackage, String accountType) {\n        // Although this is not a 'device policy' API, enterprise is the current use case.\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.GET_ACCOUNT_AUTH_TOKEN)\n                .setStrings(\n                        TextUtils.emptyIfNull(callerPackage),\n                        TextUtils.emptyIfNull(accountType))\n                .write();\n    }\n\n    private byte[] calculatePackageSignatureDigest(String callerPkg) {\n        MessageDigest digester;\n        try {\n            digester = MessageDigest.getInstance(\"SHA-256\");\n            PackageInfo pkgInfo = mPackageManager.getPackageInfo(\n                    callerPkg, PackageManager.GET_SIGNATURES);\n            for (Signature sig : pkgInfo.signatures) {\n                digester.update(sig.toByteArray());\n            }\n        } catch (NoSuchAlgorithmException x) {\n            Log.wtf(TAG, \"SHA-256 should be available\", x);\n            digester = null;\n        } catch (NameNotFoundException e) {\n            Log.w(TAG, \"Could not find packageinfo for: \" + callerPkg);\n            digester = null;\n        }\n        return (digester == null) ? null : digester.digest();\n    }\n\n    private void createNoCredentialsPermissionNotification(Account account, Intent intent,\n            String packageName, int userId) {\n        int uid = intent.getIntExtra(\n                GrantCredentialsPermissionActivity.EXTRAS_REQUESTING_UID, -1);\n        String authTokenType = intent.getStringExtra(\n                GrantCredentialsPermissionActivity.EXTRAS_AUTH_TOKEN_TYPE);\n        final String titleAndSubtitle =\n                mContext.getString(R.string.permission_request_notification_for_app_with_subtitle,\n                getApplicationLabel(packageName), account.name);\n        final int index = titleAndSubtitle.indexOf('\\n');\n        String title = titleAndSubtitle;\n        String subtitle = \"\";\n        if (index > 0) {\n            title = titleAndSubtitle.substring(0, index);\n            subtitle = titleAndSubtitle.substring(index + 1);\n        }\n        UserHandle user = UserHandle.of(userId);\n        Context contextForUser = getContextForUser(user);\n        Notification n =\n                new Notification.Builder(contextForUser, SystemNotificationChannels.ACCOUNT)\n                    .setSmallIcon(android.R.drawable.stat_sys_warning)\n                    .setWhen(0)\n                    .setColor(contextForUser.getColor(\n                            com.android.internal.R.color.system_notification_accent_color))\n                    .setContentTitle(title)\n                    .setContentText(subtitle)\n                    .setContentIntent(PendingIntent.getActivityAsUser(mContext, 0, intent,\n                            PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_IMMUTABLE,\n                            null, user))\n                    .build();\n        installNotification(getCredentialPermissionNotificationId(\n                account, authTokenType, uid), n, \"android\", user.getIdentifier());\n    }\n\n    private String getApplicationLabel(String packageName) {\n        try {\n            return mPackageManager.getApplicationLabel(\n                    mPackageManager.getApplicationInfo(packageName, 0)).toString();\n        } catch (PackageManager.NameNotFoundException e) {\n            return packageName;\n        }\n    }\n\n    private Intent newGrantCredentialsPermissionIntent(Account account, String packageName,\n            int uid, AccountAuthenticatorResponse response, String authTokenType,\n            boolean startInNewTask) {\n\n        Intent intent = new Intent(mContext, GrantCredentialsPermissionActivity.class);\n\n        if (startInNewTask) {\n            // See FLAG_ACTIVITY_NEW_TASK docs for limitations and benefits of the flag.\n            // Since it was set in Eclair+ we can't change it without breaking apps using\n            // the intent from a non-Activity context. This is the default behavior.\n            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        }\n        intent.addCategory(getCredentialPermissionNotificationId(account,\n                authTokenType, uid).mTag + (packageName != null ? packageName : \"\"));\n        intent.putExtra(GrantCredentialsPermissionActivity.EXTRAS_ACCOUNT, account);\n        intent.putExtra(GrantCredentialsPermissionActivity.EXTRAS_AUTH_TOKEN_TYPE, authTokenType);\n        intent.putExtra(GrantCredentialsPermissionActivity.EXTRAS_RESPONSE, response);\n        intent.putExtra(GrantCredentialsPermissionActivity.EXTRAS_REQUESTING_UID, uid);\n\n        return intent;\n    }\n\n    private NotificationId getCredentialPermissionNotificationId(Account account,\n            String authTokenType, int uid) {\n        NotificationId nId;\n        UserAccounts accounts = getUserAccounts(UserHandle.getUserId(uid));\n        synchronized (accounts.credentialsPermissionNotificationIds) {\n            final Pair<Pair<Account, String>, Integer> key =\n                    new Pair<Pair<Account, String>, Integer>(\n                            new Pair<Account, String>(account, authTokenType), uid);\n            nId = accounts.credentialsPermissionNotificationIds.get(key);\n            if (nId == null) {\n                String tag = TAG + \":\" + SystemMessage.NOTE_ACCOUNT_CREDENTIAL_PERMISSION\n                        + \":\" + account.hashCode() + \":\" + authTokenType.hashCode() + \":\" + uid;\n                int id = SystemMessage.NOTE_ACCOUNT_CREDENTIAL_PERMISSION;\n                nId = new NotificationId(tag, id);\n                accounts.credentialsPermissionNotificationIds.put(key, nId);\n            }\n        }\n        return nId;\n    }\n\n    private NotificationId getSigninRequiredNotificationId(UserAccounts accounts, Account account) {\n        NotificationId nId;\n        synchronized (accounts.signinRequiredNotificationIds) {\n            nId = accounts.signinRequiredNotificationIds.get(account);\n            if (nId == null) {\n                String tag = TAG + \":\" + SystemMessage.NOTE_ACCOUNT_REQUIRE_SIGNIN\n                        + \":\" + account.hashCode();\n                int id = SystemMessage.NOTE_ACCOUNT_REQUIRE_SIGNIN;\n                nId = new NotificationId(tag, id);\n                accounts.signinRequiredNotificationIds.put(account, nId);\n            }\n        }\n        return nId;\n    }\n\n    @Override\n    public void addAccount(final IAccountManagerResponse response, final String accountType,\n            final String authTokenType, final String[] requiredFeatures,\n            final boolean expectActivityLaunch, final Bundle optionsIn) {\n        Bundle.setDefusable(optionsIn, true);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"addAccount: accountType \" + accountType\n                    + \", response \" + response\n                    + \", authTokenType \" + authTokenType\n                    + \", requiredFeatures \" + Arrays.toString(requiredFeatures)\n                    + \", expectActivityLaunch \" + expectActivityLaunch\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        if (response == null) throw new IllegalArgumentException(\"response is null\");\n        if (accountType == null) throw new IllegalArgumentException(\"accountType is null\");\n\n        // Is user disallowed from modifying accounts?\n        final int uid = Binder.getCallingUid();\n        final int userId = UserHandle.getUserId(uid);\n        if (!canUserModifyAccounts(userId, uid)) {\n            try {\n                response.onError(AccountManager.ERROR_CODE_USER_RESTRICTED,\n                        \"User is not allowed to add an account!\");\n            } catch (RemoteException re) {\n            }\n            showCantAddAccount(AccountManager.ERROR_CODE_USER_RESTRICTED, userId);\n            return;\n        }\n        if (!canUserModifyAccountsForType(userId, accountType, uid)) {\n            try {\n                response.onError(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                        \"User cannot modify accounts of this type (policy).\");\n            } catch (RemoteException re) {\n            }\n            showCantAddAccount(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                    userId);\n            return;\n        }\n        addAccountAndLogMetrics(response, accountType, authTokenType, requiredFeatures,\n                expectActivityLaunch, optionsIn, userId);\n    }\n\n    @Override\n    public void addAccountAsUser(final IAccountManagerResponse response, final String accountType,\n            final String authTokenType, final String[] requiredFeatures,\n            final boolean expectActivityLaunch, final Bundle optionsIn, int userId) {\n        Bundle.setDefusable(optionsIn, true);\n        int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"addAccount: accountType \" + accountType\n                    + \", response \" + response\n                    + \", authTokenType \" + authTokenType\n                    + \", requiredFeatures \" + Arrays.toString(requiredFeatures)\n                    + \", expectActivityLaunch \" + expectActivityLaunch\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid()\n                    + \", for user id \" + userId);\n        }\n        Preconditions.checkArgument(response != null, \"response cannot be null\");\n        Preconditions.checkArgument(accountType != null, \"accountType cannot be null\");\n        // Only allow the system process to add accounts of other users\n        if (isCrossUser(callingUid, userId)) {\n            throw new SecurityException(\n                    String.format(\n                            \"User %s trying to add account for %s\" ,\n                            UserHandle.getCallingUserId(),\n                            userId));\n        }\n\n        // Is user disallowed from modifying accounts?\n        if (!canUserModifyAccounts(userId, callingUid)) {\n            try {\n                response.onError(AccountManager.ERROR_CODE_USER_RESTRICTED,\n                        \"User is not allowed to add an account!\");\n            } catch (RemoteException re) {\n            }\n            showCantAddAccount(AccountManager.ERROR_CODE_USER_RESTRICTED, userId);\n            return;\n        }\n        if (!canUserModifyAccountsForType(userId, accountType, callingUid)) {\n            try {\n                response.onError(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                        \"User cannot modify accounts of this type (policy).\");\n            } catch (RemoteException re) {\n            }\n            showCantAddAccount(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                    userId);\n            return;\n        }\n        addAccountAndLogMetrics(response, accountType, authTokenType, requiredFeatures,\n                expectActivityLaunch, optionsIn, userId);\n    }\n\n    private void addAccountAndLogMetrics(\n            IAccountManagerResponse response, String accountType,\n            String authTokenType, String[] requiredFeatures,\n            boolean expectActivityLaunch, Bundle optionsIn, int userId) {\n        final int pid = Binder.getCallingPid();\n        final int uid = Binder.getCallingUid();\n        final Bundle options = (optionsIn == null) ? new Bundle() : optionsIn;\n        options.putInt(AccountManager.KEY_CALLER_UID, uid);\n        options.putInt(AccountManager.KEY_CALLER_PID, pid);\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            logRecordWithUid(\n                    accounts, AccountsDb.DEBUG_ACTION_CALLED_ACCOUNT_ADD, AccountsDb.TABLE_ACCOUNTS,\n                    uid);\n            new Session(accounts, response, accountType, expectActivityLaunch,\n                    true /* stripAuthTokenFromResult */, null /* accountName */,\n                    false /* authDetailsRequired */, true /* updateLastAuthenticationTime */) {\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.addAccount(\n                            this, mAccountType, authTokenType, requiredFeatures, options);\n                    String callerPackage = options.getString(\n                            AccountManager.KEY_ANDROID_PACKAGE_NAME);\n                    logAddAccountMetrics(\n                            callerPackage, accountType, requiredFeatures, authTokenType);\n                }\n\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now) + \", addAccount\"\n                            + \", accountType \" + accountType\n                            + \", requiredFeatures \"\n                            + (requiredFeatures != null\n                            ? TextUtils.join(\",\", requiredFeatures)\n                            : null);\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private void logAddAccountMetrics(\n            String callerPackage, String accountType, String[] requiredFeatures,\n            String authTokenType) {\n        // Although this is not a 'device policy' API, enterprise is the current use case.\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.ADD_ACCOUNT)\n                .setStrings(\n                        TextUtils.emptyIfNull(accountType),\n                        TextUtils.emptyIfNull(callerPackage),\n                        TextUtils.emptyIfNull(authTokenType),\n                        requiredFeatures == null\n                                ? \"\"\n                                : TextUtils.join(\";\", requiredFeatures))\n                .write();\n    }\n\n    @Override\n    public void startAddAccountSession(\n            final IAccountManagerResponse response,\n            final String accountType,\n            final String authTokenType,\n            final String[] requiredFeatures,\n            final boolean expectActivityLaunch,\n            final Bundle optionsIn) {\n        Bundle.setDefusable(optionsIn, true);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG,\n                    \"startAddAccountSession: accountType \" + accountType\n                    + \", response \" + response\n                    + \", authTokenType \" + authTokenType\n                    + \", requiredFeatures \" + Arrays.toString(requiredFeatures)\n                    + \", expectActivityLaunch \" + expectActivityLaunch\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Preconditions.checkArgument(response != null, \"response cannot be null\");\n        Preconditions.checkArgument(accountType != null, \"accountType cannot be null\");\n\n        final int uid = Binder.getCallingUid();\n        final int userId = UserHandle.getUserId(uid);\n        if (!canUserModifyAccounts(userId, uid)) {\n            try {\n                response.onError(AccountManager.ERROR_CODE_USER_RESTRICTED,\n                        \"User is not allowed to add an account!\");\n            } catch (RemoteException re) {\n            }\n            showCantAddAccount(AccountManager.ERROR_CODE_USER_RESTRICTED, userId);\n            return;\n        }\n        if (!canUserModifyAccountsForType(userId, accountType, uid)) {\n            try {\n                response.onError(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                        \"User cannot modify accounts of this type (policy).\");\n            } catch (RemoteException re) {\n            }\n            showCantAddAccount(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                    userId);\n            return;\n        }\n        final int pid = Binder.getCallingPid();\n        final Bundle options = (optionsIn == null) ? new Bundle() : optionsIn;\n        options.putInt(AccountManager.KEY_CALLER_UID, uid);\n        options.putInt(AccountManager.KEY_CALLER_PID, pid);\n\n        // Check to see if the Password should be included to the caller.\n        String callerPkg = options.getString(AccountManager.KEY_ANDROID_PACKAGE_NAME);\n        boolean isPasswordForwardingAllowed = checkPermissionAndNote(\n                callerPkg, uid, Manifest.permission.GET_PASSWORD);\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            logRecordWithUid(accounts, AccountsDb.DEBUG_ACTION_CALLED_START_ACCOUNT_ADD,\n                    AccountsDb.TABLE_ACCOUNTS, uid);\n            new StartAccountSession(\n                    accounts,\n                    response,\n                    accountType,\n                    expectActivityLaunch,\n                    null /* accountName */,\n                    false /* authDetailsRequired */,\n                    true /* updateLastAuthenticationTime */,\n                    isPasswordForwardingAllowed) {\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.startAddAccountSession(this, mAccountType, authTokenType,\n                            requiredFeatures, options);\n                    logAddAccountMetrics(callerPkg, accountType, requiredFeatures, authTokenType);\n                }\n\n                @Override\n                protected String toDebugString(long now) {\n                    String requiredFeaturesStr = TextUtils.join(\",\", requiredFeatures);\n                    return super.toDebugString(now) + \", startAddAccountSession\" + \", accountType \"\n                            + accountType + \", requiredFeatures \"\n                            + (requiredFeatures != null ? requiredFeaturesStr : null);\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    /** Session that will encrypt the KEY_ACCOUNT_SESSION_BUNDLE in result. */\n    private abstract class StartAccountSession extends Session {\n\n        private final boolean mIsPasswordForwardingAllowed;\n\n        public StartAccountSession(\n                UserAccounts accounts,\n                IAccountManagerResponse response,\n                String accountType,\n                boolean expectActivityLaunch,\n                String accountName,\n                boolean authDetailsRequired,\n                boolean updateLastAuthenticationTime,\n                boolean isPasswordForwardingAllowed) {\n            super(accounts, response, accountType, expectActivityLaunch,\n                    true /* stripAuthTokenFromResult */, accountName, authDetailsRequired,\n                    updateLastAuthenticationTime);\n            mIsPasswordForwardingAllowed = isPasswordForwardingAllowed;\n        }\n\n        @Override\n        public void onResult(Bundle result) {\n            Bundle.setDefusable(result, true);\n            mNumResults++;\n            Intent intent = null;\n            if (result != null) {\n                if (!checkKeyIntent(\n                        Binder.getCallingUid(),\n                        result)) {\n                    onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                            \"invalid intent in bundle returned\");\n                    return;\n                }\n            }\n            IAccountManagerResponse response;\n            if (mExpectActivityLaunch && result != null\n                    && result.containsKey(AccountManager.KEY_INTENT)) {\n                response = mResponse;\n            } else {\n                response = getResponseAndClose();\n            }\n            if (response == null) {\n                return;\n            }\n            if (result == null) {\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.v(TAG, getClass().getSimpleName() + \" calling onError() on response \"\n                            + response);\n                }\n                sendErrorResponse(response, AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                        \"null bundle returned\");\n                return;\n            }\n\n            if ((result.getInt(AccountManager.KEY_ERROR_CODE, -1) > 0) && (intent == null)) {\n                // All AccountManager error codes are greater\n                // than 0\n                sendErrorResponse(response, result.getInt(AccountManager.KEY_ERROR_CODE),\n                        result.getString(AccountManager.KEY_ERROR_MESSAGE));\n                return;\n            }\n\n            // Omit passwords if the caller isn't permitted to see them.\n            if (!mIsPasswordForwardingAllowed) {\n                result.remove(AccountManager.KEY_PASSWORD);\n            }\n\n            // Strip auth token from result.\n            result.remove(AccountManager.KEY_AUTHTOKEN);\n            if (!checkKeyIntent(Binder.getCallingUid(), result)) {\n                onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                        \"invalid intent in bundle returned\");\n                return;\n            }\n\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG,\n                        getClass().getSimpleName() + \" calling onResult() on response \" + response);\n            }\n\n            // Get the session bundle created by authenticator. The\n            // bundle contains data necessary for finishing the session\n            // later. The session bundle will be encrypted here and\n            // decrypted later when trying to finish the session.\n            Bundle sessionBundle = result.getBundle(AccountManager.KEY_ACCOUNT_SESSION_BUNDLE);\n            if (sessionBundle != null) {\n                String accountType = sessionBundle.getString(AccountManager.KEY_ACCOUNT_TYPE);\n                if (TextUtils.isEmpty(accountType)\n                        || !mAccountType.equalsIgnoreCase(accountType)) {\n                    Log.w(TAG, \"Account type in session bundle doesn't match request.\");\n                }\n                // Add accountType info to session bundle. This will\n                // override any value set by authenticator.\n                sessionBundle.putString(AccountManager.KEY_ACCOUNT_TYPE, mAccountType);\n\n                // Encrypt session bundle before returning to caller.\n                try {\n                    CryptoHelper cryptoHelper = CryptoHelper.getInstance();\n                    Bundle encryptedBundle = cryptoHelper.encryptBundle(sessionBundle);\n                    result.putBundle(AccountManager.KEY_ACCOUNT_SESSION_BUNDLE, encryptedBundle);\n                } catch (GeneralSecurityException e) {\n                    if (Log.isLoggable(TAG, Log.DEBUG)) {\n                        Log.v(TAG, \"Failed to encrypt session bundle!\", e);\n                    }\n                    sendErrorResponse(response, AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                            \"failed to encrypt session bundle\");\n                    return;\n                }\n            }\n\n            sendResponse(response, result);\n        }\n    }\n\n    @Override\n    public void finishSessionAsUser(IAccountManagerResponse response,\n            @NonNull Bundle sessionBundle,\n            boolean expectActivityLaunch,\n            Bundle appInfo,\n            int userId) {\n        Bundle.setDefusable(sessionBundle, true);\n        int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG,\n                    \"finishSession: response \"+ response\n                            + \", expectActivityLaunch \" + expectActivityLaunch\n                            + \", caller's uid \" + callingUid\n                            + \", caller's user id \" + UserHandle.getCallingUserId()\n                            + \", pid \" + Binder.getCallingPid()\n                            + \", for user id \" + userId);\n        }\n        Preconditions.checkArgument(response != null, \"response cannot be null\");\n        // Session bundle is the encrypted bundle of the original bundle created by authenticator.\n        // Account type is added to it before encryption.\n        if (sessionBundle == null || sessionBundle.size() == 0) {\n            throw new IllegalArgumentException(\"sessionBundle is empty\");\n        }\n\n        // Only allow the system process to finish session for other users.\n        if (isCrossUser(callingUid, userId)) {\n            throw new SecurityException(\n                    String.format(\n                            \"User %s trying to finish session for %s without cross user permission\",\n                            UserHandle.getCallingUserId(),\n                            userId));\n        }\n\n        if (!canUserModifyAccounts(userId, callingUid)) {\n            sendErrorResponse(response,\n                    AccountManager.ERROR_CODE_USER_RESTRICTED,\n                    \"User is not allowed to add an account!\");\n            showCantAddAccount(AccountManager.ERROR_CODE_USER_RESTRICTED, userId);\n            return;\n        }\n\n        final int pid = Binder.getCallingPid();\n        final Bundle decryptedBundle;\n        final String accountType;\n        // First decrypt session bundle to get account type for checking permission.\n        try {\n            CryptoHelper cryptoHelper = CryptoHelper.getInstance();\n            decryptedBundle = cryptoHelper.decryptBundle(sessionBundle);\n            if (decryptedBundle == null) {\n                sendErrorResponse(\n                        response,\n                        AccountManager.ERROR_CODE_BAD_REQUEST,\n                        \"failed to decrypt session bundle\");\n                return;\n            }\n            accountType = decryptedBundle.getString(AccountManager.KEY_ACCOUNT_TYPE);\n            // Account type cannot be null. This should not happen if session bundle was created\n            // properly by #StartAccountSession.\n            if (TextUtils.isEmpty(accountType)) {\n                sendErrorResponse(\n                        response,\n                        AccountManager.ERROR_CODE_BAD_ARGUMENTS,\n                        \"accountType is empty\");\n                return;\n            }\n\n            // If by any chances, decryptedBundle contains colliding keys with\n            // system info\n            // such as AccountManager.KEY_ANDROID_PACKAGE_NAME required by the add account flow or\n            // update credentials flow, we should replace with the new values of the current call.\n            if (appInfo != null) {\n                decryptedBundle.putAll(appInfo);\n            }\n\n            // Add info that may be used by add account or update credentials flow.\n            decryptedBundle.putInt(AccountManager.KEY_CALLER_UID, callingUid);\n            decryptedBundle.putInt(AccountManager.KEY_CALLER_PID, pid);\n        } catch (GeneralSecurityException e) {\n            if (Log.isLoggable(TAG, Log.DEBUG)) {\n                Log.v(TAG, \"Failed to decrypt session bundle!\", e);\n            }\n            sendErrorResponse(\n                    response,\n                    AccountManager.ERROR_CODE_BAD_REQUEST,\n                    \"failed to decrypt session bundle\");\n            return;\n        }\n\n        if (!canUserModifyAccountsForType(userId, accountType, callingUid)) {\n            sendErrorResponse(\n                    response,\n                    AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                    \"User cannot modify accounts of this type (policy).\");\n            showCantAddAccount(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                    userId);\n            return;\n        }\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            logRecordWithUid(\n                    accounts,\n                    AccountsDb.DEBUG_ACTION_CALLED_ACCOUNT_SESSION_FINISH,\n                    AccountsDb.TABLE_ACCOUNTS,\n                    callingUid);\n            new Session(\n                    accounts,\n                    response,\n                    accountType,\n                    expectActivityLaunch,\n                    true /* stripAuthTokenFromResult */,\n                    null /* accountName */,\n                    false /* authDetailsRequired */,\n                    true /* updateLastAuthenticationTime */) {\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.finishSession(this, mAccountType, decryptedBundle);\n                }\n\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now)\n                            + \", finishSession\"\n                            + \", accountType \" + accountType;\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private void showCantAddAccount(int errorCode, int userId) {\n        final DevicePolicyManagerInternal dpmi =\n                LocalServices.getService(DevicePolicyManagerInternal.class);\n        Intent intent = null;\n        if (dpmi == null) {\n            intent = getDefaultCantAddAccountIntent(errorCode);\n        } else if (errorCode == AccountManager.ERROR_CODE_USER_RESTRICTED) {\n            intent = dpmi.createUserRestrictionSupportIntent(userId,\n                    UserManager.DISALLOW_MODIFY_ACCOUNTS);\n        } else if (errorCode == AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE) {\n            intent = dpmi.createShowAdminSupportIntent(userId, false);\n        }\n        if (intent == null) {\n            intent = getDefaultCantAddAccountIntent(errorCode);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            mContext.startActivityAsUser(intent, new UserHandle(userId));\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    /**\n     * Called when we don't know precisely who is preventing us from adding an account.\n     */\n    private Intent getDefaultCantAddAccountIntent(int errorCode) {\n        Intent cantAddAccount = new Intent(mContext, CantAddAccountActivity.class);\n        cantAddAccount.putExtra(CantAddAccountActivity.EXTRA_ERROR_CODE, errorCode);\n        cantAddAccount.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        return cantAddAccount;\n    }\n\n    @Override\n    public void confirmCredentialsAsUser(\n            IAccountManagerResponse response,\n            final Account account,\n            final Bundle options,\n            final boolean expectActivityLaunch,\n            int userId) {\n        Bundle.setDefusable(options, true);\n        int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"confirmCredentials: \" + account\n                    + \", response \" + response\n                    + \", expectActivityLaunch \" + expectActivityLaunch\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        // Only allow the system process to read accounts of other users\n        if (isCrossUser(callingUid, userId)) {\n            throw new SecurityException(\n                    String.format(\n                            \"User %s trying to confirm account credentials for %s\" ,\n                            UserHandle.getCallingUserId(),\n                            userId));\n        }\n        if (response == null) throw new IllegalArgumentException(\"response is null\");\n        if (account == null) throw new IllegalArgumentException(\"account is null\");\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            new Session(accounts, response, account.type, expectActivityLaunch,\n                    true /* stripAuthTokenFromResult */, account.name,\n                    true /* authDetailsRequired */, true /* updateLastAuthenticatedTime */) {\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.confirmCredentials(this, account, options);\n                }\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now) + \", confirmCredentials\"\n                            + \", \" + account.toSafeString();\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void updateCredentials(IAccountManagerResponse response, final Account account,\n            final String authTokenType, final boolean expectActivityLaunch,\n            final Bundle loginOptions) {\n        Bundle.setDefusable(loginOptions, true);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"updateCredentials: \" + account\n                    + \", response \" + response\n                    + \", authTokenType \" + authTokenType\n                    + \", expectActivityLaunch \" + expectActivityLaunch\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        if (response == null) throw new IllegalArgumentException(\"response is null\");\n        if (account == null) throw new IllegalArgumentException(\"account is null\");\n        int userId = UserHandle.getCallingUserId();\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            new Session(accounts, response, account.type, expectActivityLaunch,\n                    true /* stripAuthTokenFromResult */, account.name,\n                    false /* authDetailsRequired */, true /* updateLastCredentialTime */) {\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.updateCredentials(this, account, authTokenType, loginOptions);\n                }\n                @Override\n                protected String toDebugString(long now) {\n                    if (loginOptions != null) loginOptions.keySet();\n                    return super.toDebugString(now) + \", updateCredentials\"\n                            + \", \" + account.toSafeString()\n                            + \", authTokenType \" + authTokenType\n                            + \", loginOptions \" + loginOptions;\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void startUpdateCredentialsSession(\n            IAccountManagerResponse response,\n            final Account account,\n            final String authTokenType,\n            final boolean expectActivityLaunch,\n            final Bundle loginOptions) {\n        Bundle.setDefusable(loginOptions, true);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG,\n                    \"startUpdateCredentialsSession: \" + account + \", response \" + response\n                            + \", authTokenType \" + authTokenType + \", expectActivityLaunch \"\n                            + expectActivityLaunch + \", caller's uid \" + Binder.getCallingUid()\n                            + \", pid \" + Binder.getCallingPid());\n        }\n        if (response == null) {\n            throw new IllegalArgumentException(\"response is null\");\n        }\n        if (account == null) {\n            throw new IllegalArgumentException(\"account is null\");\n        }\n\n        final int uid = Binder.getCallingUid();\n        int userId = UserHandle.getCallingUserId();\n\n        // Check to see if the Password should be included to the caller.\n        String callerPkg = loginOptions.getString(AccountManager.KEY_ANDROID_PACKAGE_NAME);\n        boolean isPasswordForwardingAllowed = checkPermissionAndNote(\n                callerPkg, uid, Manifest.permission.GET_PASSWORD);\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            new StartAccountSession(\n                    accounts,\n                    response,\n                    account.type,\n                    expectActivityLaunch,\n                    account.name,\n                    false /* authDetailsRequired */,\n                    true /* updateLastCredentialTime */,\n                    isPasswordForwardingAllowed) {\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.startUpdateCredentialsSession(this, account, authTokenType,\n                            loginOptions);\n                }\n\n                @Override\n                protected String toDebugString(long now) {\n                    if (loginOptions != null)\n                        loginOptions.keySet();\n                    return super.toDebugString(now)\n                            + \", startUpdateCredentialsSession\"\n                            + \", \" + account.toSafeString()\n                            + \", authTokenType \" + authTokenType\n                            + \", loginOptions \" + loginOptions;\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void isCredentialsUpdateSuggested(\n            IAccountManagerResponse response,\n            final Account account,\n            final String statusToken) {\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG,\n                    \"isCredentialsUpdateSuggested: \" + account + \", response \" + response\n                            + \", caller's uid \" + Binder.getCallingUid()\n                            + \", pid \" + Binder.getCallingPid());\n        }\n        if (response == null) {\n            throw new IllegalArgumentException(\"response is null\");\n        }\n        if (account == null) {\n            throw new IllegalArgumentException(\"account is null\");\n        }\n        if (TextUtils.isEmpty(statusToken)) {\n            throw new IllegalArgumentException(\"status token is empty\");\n        }\n\n        int usrId = UserHandle.getCallingUserId();\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(usrId);\n            new Session(accounts, response, account.type, false /* expectActivityLaunch */,\n                    false /* stripAuthTokenFromResult */, account.name,\n                    false /* authDetailsRequired */) {\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now) + \", isCredentialsUpdateSuggested\"\n                            + \", \" + account.toSafeString();\n                }\n\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.isCredentialsUpdateSuggested(this, account, statusToken);\n                }\n\n                @Override\n                public void onResult(Bundle result) {\n                    Bundle.setDefusable(result, true);\n                    IAccountManagerResponse response = getResponseAndClose();\n                    if (response == null) {\n                        return;\n                    }\n\n                    if (result == null) {\n                        sendErrorResponse(\n                                response,\n                                AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                                \"null bundle\");\n                        return;\n                    }\n\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, getClass().getSimpleName() + \" calling onResult() on response \"\n                                + response);\n                    }\n                    // Check to see if an error occurred. We know if an error occurred because all\n                    // error codes are greater than 0.\n                    if ((result.getInt(AccountManager.KEY_ERROR_CODE, -1) > 0)) {\n                        sendErrorResponse(response,\n                                result.getInt(AccountManager.KEY_ERROR_CODE),\n                                result.getString(AccountManager.KEY_ERROR_MESSAGE));\n                        return;\n                    }\n                    if (!result.containsKey(AccountManager.KEY_BOOLEAN_RESULT)) {\n                        sendErrorResponse(\n                                response,\n                                AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                                \"no result in response\");\n                        return;\n                    }\n                    final Bundle newResult = new Bundle();\n                    newResult.putBoolean(AccountManager.KEY_BOOLEAN_RESULT,\n                            result.getBoolean(AccountManager.KEY_BOOLEAN_RESULT, false));\n                    sendResponse(response, newResult);\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void editProperties(IAccountManagerResponse response, final String accountType,\n            final boolean expectActivityLaunch) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"editProperties: accountType \" + accountType\n                    + \", response \" + response\n                    + \", expectActivityLaunch \" + expectActivityLaunch\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        if (response == null) throw new IllegalArgumentException(\"response is null\");\n        if (accountType == null) throw new IllegalArgumentException(\"accountType is null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(accountType, callingUid, userId)\n                && !isSystemUid(callingUid)) {\n            String msg = String.format(\n                    \"uid %s cannot edit authenticator properites for account type: %s\",\n                    callingUid,\n                    accountType);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            new Session(accounts, response, accountType, expectActivityLaunch,\n                    true /* stripAuthTokenFromResult */, null /* accountName */,\n                    false /* authDetailsRequired */) {\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.editProperties(this, mAccountType);\n                }\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now) + \", editProperties\"\n                            + \", accountType \" + accountType;\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public boolean hasAccountAccess(@NonNull Account account,  @NonNull String packageName,\n            @NonNull UserHandle userHandle) {\n        if (UserHandle.getAppId(Binder.getCallingUid()) != Process.SYSTEM_UID) {\n            throw new SecurityException(\"Can be called only by system UID\");\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        Objects.requireNonNull(packageName, \"packageName cannot be null\");\n        Objects.requireNonNull(userHandle, \"userHandle cannot be null\");\n\n        final int userId = userHandle.getIdentifier();\n\n        Preconditions.checkArgumentInRange(userId, 0, Integer.MAX_VALUE, \"user must be concrete\");\n\n        try {\n            int uid = mPackageManager.getPackageUidAsUser(packageName, userId);\n            return hasAccountAccess(account, packageName, uid);\n        } catch (NameNotFoundException e) {\n            Log.d(TAG, \"Package not found \" + e.getMessage());\n            return false;\n        }\n    }\n\n    // Returns package with oldest target SDK for given UID.\n    private String getPackageNameForUid(int uid) {\n        String[] packageNames = mPackageManager.getPackagesForUid(uid);\n        if (ArrayUtils.isEmpty(packageNames)) {\n            return null;\n        }\n        String packageName = packageNames[0];\n        if (packageNames.length == 1) {\n            return packageName;\n        }\n        // Due to visibility changes we want to use package with oldest target SDK\n        int oldestVersion = Integer.MAX_VALUE;\n        for (String name : packageNames) {\n            try {\n                ApplicationInfo applicationInfo = mPackageManager.getApplicationInfo(name, 0);\n                if (applicationInfo != null) {\n                    int version = applicationInfo.targetSdkVersion;\n                    if (version < oldestVersion) {\n                        oldestVersion = version;\n                        packageName = name;\n                    }\n                }\n            } catch (NameNotFoundException e) {\n                // skip\n            }\n        }\n        return packageName;\n    }\n\n    private boolean hasAccountAccess(@NonNull Account account, @Nullable String packageName,\n            int uid) {\n        if (packageName == null) {\n            packageName = getPackageNameForUid(uid);\n            if (packageName == null) {\n                return false;\n            }\n        }\n\n        // Use null token which means any token. Having a token means the package\n        // is trusted by the authenticator, hence it is fine to access the account.\n        if (permissionIsGranted(account, null, uid, UserHandle.getUserId(uid))) {\n            return true;\n        }\n        // In addition to the permissions required to get an auth token we also allow\n        // the account to be accessed by apps for which user or authenticator granted visibility.\n\n        int visibility = resolveAccountVisibility(account, packageName,\n            getUserAccounts(UserHandle.getUserId(uid)));\n        return (visibility == AccountManager.VISIBILITY_VISIBLE\n            || visibility == AccountManager.VISIBILITY_USER_MANAGED_VISIBLE);\n    }\n\n    @Override\n    public IntentSender createRequestAccountAccessIntentSenderAsUser(@NonNull Account account,\n            @NonNull String packageName, @NonNull UserHandle userHandle) {\n        if (UserHandle.getAppId(Binder.getCallingUid()) != Process.SYSTEM_UID) {\n            throw new SecurityException(\"Can be called only by system UID\");\n        }\n\n        Objects.requireNonNull(account, \"account cannot be null\");\n        Objects.requireNonNull(packageName, \"packageName cannot be null\");\n        Objects.requireNonNull(userHandle, \"userHandle cannot be null\");\n\n        final int userId = userHandle.getIdentifier();\n\n        Preconditions.checkArgumentInRange(userId, 0, Integer.MAX_VALUE, \"user must be concrete\");\n\n        final int uid;\n        try {\n            uid = mPackageManager.getPackageUidAsUser(packageName, userId);\n        } catch (NameNotFoundException e) {\n            Slog.e(TAG, \"Unknown package \" + packageName);\n            return null;\n        }\n\n        Intent intent = newRequestAccountAccessIntent(account, packageName, uid, null);\n\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            return PendingIntent.getActivityAsUser(\n                    mContext, 0, intent, PendingIntent.FLAG_ONE_SHOT\n                            | PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_IMMUTABLE,\n                    null, new UserHandle(userId)).getIntentSender();\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    private Intent newRequestAccountAccessIntent(Account account, String packageName,\n            int uid, RemoteCallback callback) {\n        return newGrantCredentialsPermissionIntent(account, packageName, uid,\n                new AccountAuthenticatorResponse(new IAccountAuthenticatorResponse.Stub() {\n            @Override\n            public void onResult(Bundle value) throws RemoteException {\n                handleAuthenticatorResponse(true);\n            }\n\n            @Override\n            public void onRequestContinued() {\n                /* ignore */\n            }\n\n            @Override\n            public void onError(int errorCode, String errorMessage) throws RemoteException {\n                handleAuthenticatorResponse(false);\n            }\n\n            private void handleAuthenticatorResponse(boolean accessGranted) throws RemoteException {\n                cancelNotification(getCredentialPermissionNotificationId(account,\n                        AccountManager.ACCOUNT_ACCESS_TOKEN_TYPE, uid),\n                        UserHandle.getUserHandleForUid(uid));\n                if (callback != null) {\n                    Bundle result = new Bundle();\n                    result.putBoolean(AccountManager.KEY_BOOLEAN_RESULT, accessGranted);\n                    callback.sendResult(result);\n                }\n            }\n        }), AccountManager.ACCOUNT_ACCESS_TOKEN_TYPE, false);\n    }\n\n    @Override\n    public boolean someUserHasAccount(@NonNull final Account account) {\n        if (!UserHandle.isSameApp(Process.SYSTEM_UID, Binder.getCallingUid())) {\n            throw new SecurityException(\"Only system can check for accounts across users\");\n        }\n        final long token = Binder.clearCallingIdentity();\n        try {\n            AccountAndUser[] allAccounts = getAllAccounts();\n            for (int i = allAccounts.length - 1; i >= 0; i--) {\n                if (allAccounts[i].account.equals(account)) {\n                    return true;\n                }\n            }\n            return false;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private class GetAccountsByTypeAndFeatureSession extends Session {\n        private final String[] mFeatures;\n        private volatile Account[] mAccountsOfType = null;\n        private volatile ArrayList<Account> mAccountsWithFeatures = null;\n        private volatile int mCurrentAccount = 0;\n        private final int mCallingUid;\n        private final String mPackageName;\n        private final boolean mIncludeManagedNotVisible;\n\n        public GetAccountsByTypeAndFeatureSession(\n                UserAccounts accounts,\n                IAccountManagerResponse response,\n                String type,\n                String[] features,\n                int callingUid,\n                String packageName,\n                boolean includeManagedNotVisible) {\n            super(accounts, response, type, false /* expectActivityLaunch */,\n                    true /* stripAuthTokenFromResult */, null /* accountName */,\n                    false /* authDetailsRequired */);\n            mCallingUid = callingUid;\n            mFeatures = features;\n            mPackageName = packageName;\n            mIncludeManagedNotVisible = includeManagedNotVisible;\n        }\n\n        @Override\n        public void run() throws RemoteException {\n            mAccountsOfType = getAccountsFromCache(mAccounts, mAccountType,\n                    mCallingUid, mPackageName, mIncludeManagedNotVisible);\n            // check whether each account matches the requested features\n            mAccountsWithFeatures = new ArrayList<>(mAccountsOfType.length);\n            mCurrentAccount = 0;\n\n            checkAccount();\n        }\n\n        public void checkAccount() {\n            if (mCurrentAccount >= mAccountsOfType.length) {\n                sendResult();\n                return;\n            }\n\n            final IAccountAuthenticator accountAuthenticator = mAuthenticator;\n            if (accountAuthenticator == null) {\n                // It is possible that the authenticator has died, which is indicated by\n                // mAuthenticator being set to null. If this happens then just abort.\n                // There is no need to send back a result or error in this case since\n                // that already happened when mAuthenticator was cleared.\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.v(TAG, \"checkAccount: aborting session since we are no longer\"\n                            + \" connected to the authenticator, \" + toDebugString());\n                }\n                return;\n            }\n            try {\n                accountAuthenticator.hasFeatures(this, mAccountsOfType[mCurrentAccount], mFeatures);\n            } catch (RemoteException e) {\n                onError(AccountManager.ERROR_CODE_REMOTE_EXCEPTION, \"remote exception\");\n            }\n        }\n\n        @Override\n        public void onResult(Bundle result) {\n            Bundle.setDefusable(result, true);\n            mNumResults++;\n            if (result == null) {\n                onError(AccountManager.ERROR_CODE_INVALID_RESPONSE, \"null bundle\");\n                return;\n            }\n            if (result.getBoolean(AccountManager.KEY_BOOLEAN_RESULT, false)) {\n                mAccountsWithFeatures.add(mAccountsOfType[mCurrentAccount]);\n            }\n            mCurrentAccount++;\n            checkAccount();\n        }\n\n        public void sendResult() {\n            IAccountManagerResponse response = getResponseAndClose();\n            if (response != null) {\n                try {\n                    Account[] accounts = new Account[mAccountsWithFeatures.size()];\n                    for (int i = 0; i < accounts.length; i++) {\n                        accounts[i] = mAccountsWithFeatures.get(i);\n                    }\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, getClass().getSimpleName() + \" calling onResult() on response \"\n                                + response);\n                    }\n                    Bundle result = new Bundle();\n                    result.putParcelableArray(AccountManager.KEY_ACCOUNTS, accounts);\n                    response.onResult(result);\n                } catch (RemoteException e) {\n                    // if the caller is dead then there is no one to care about remote exceptions\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, \"failure while notifying response\", e);\n                    }\n                }\n            }\n        }\n\n        @Override\n        protected String toDebugString(long now) {\n            return super.toDebugString(now) + \", getAccountsByTypeAndFeatures\"\n                    + \", \" + (mFeatures != null ? TextUtils.join(\",\", mFeatures) : null);\n        }\n    }\n\n    /**\n     * Returns the accounts visible to the client within the context of a specific user\n     * @hide\n     */\n    @NonNull\n    public Account[] getAccounts(int userId, String opPackageName) {\n        int callingUid = Binder.getCallingUid();\n        mAppOpsManager.checkPackage(callingUid, opPackageName);\n        List<String> visibleAccountTypes = getTypesVisibleToCaller(callingUid, userId,\n                opPackageName);\n        if (visibleAccountTypes.isEmpty()) {\n            return EMPTY_ACCOUNT_ARRAY;\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return getAccountsInternal(\n                    accounts,\n                    callingUid,\n                    opPackageName,\n                    visibleAccountTypes,\n                    false /* includeUserManagedNotVisible */);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    /**\n     * Returns accounts for all running users, ignores visibility values.\n     *\n     * @hide\n     */\n    @NonNull\n    public AccountAndUser[] getRunningAccounts() {\n        final int[] runningUserIds;\n        try {\n            runningUserIds = ActivityManager.getService().getRunningUserIds();\n        } catch (RemoteException e) {\n            // Running in system_server; should never happen\n            throw new RuntimeException(e);\n        }\n        return getAccounts(runningUserIds);\n    }\n\n    /**\n     * Returns accounts for all users, ignores visibility values.\n     *\n     * @hide\n     */\n    @NonNull\n    public AccountAndUser[] getAllAccounts() {\n        final List<UserInfo> users = getUserManager().getAliveUsers();\n        final int[] userIds = new int[users.size()];\n        for (int i = 0; i < userIds.length; i++) {\n            userIds[i] = users.get(i).id;\n        }\n        return getAccounts(userIds);\n    }\n\n    @NonNull\n    private AccountAndUser[] getAccounts(int[] userIds) {\n        final ArrayList<AccountAndUser> runningAccounts = Lists.newArrayList();\n        for (int userId : userIds) {\n            UserAccounts userAccounts = getUserAccounts(userId);\n            if (userAccounts == null) continue;\n            Account[] accounts = getAccountsFromCache(\n                    userAccounts,\n                    null /* type */,\n                    Binder.getCallingUid(),\n                    null /* packageName */,\n                    false /* include managed not visible*/);\n            for (Account account : accounts) {\n                runningAccounts.add(new AccountAndUser(account, userId));\n            }\n        }\n\n        AccountAndUser[] accountsArray = new AccountAndUser[runningAccounts.size()];\n        return runningAccounts.toArray(accountsArray);\n    }\n\n    @Override\n    @NonNull\n    public Account[] getAccountsAsUser(String type, int userId, String opPackageName) {\n        int callingUid = Binder.getCallingUid();\n        mAppOpsManager.checkPackage(callingUid, opPackageName);\n        return getAccountsAsUserForPackage(type, userId, opPackageName /* callingPackage */, -1,\n                opPackageName, false /* includeUserManagedNotVisible */);\n    }\n\n    @NonNull\n    private Account[] getAccountsAsUserForPackage(\n            String type,\n            int userId,\n            String callingPackage,\n            int packageUid,\n            String opPackageName,\n            boolean includeUserManagedNotVisible) {\n        int callingUid = Binder.getCallingUid();\n        // Only allow the system process to read accounts of other users\n        if (userId != UserHandle.getCallingUserId()\n                && callingUid != Process.SYSTEM_UID\n                && mContext.checkCallingOrSelfPermission(\n                    android.Manifest.permission.INTERACT_ACROSS_USERS_FULL)\n                    != PackageManager.PERMISSION_GRANTED) {\n            throw new SecurityException(\"User \" + UserHandle.getCallingUserId()\n                    + \" trying to get account for \" + userId);\n        }\n\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"getAccounts: accountType \" + type\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid());\n        }\n\n        // If the original calling app was using account choosing activity\n        // provided by the framework or authenticator we'll passing in\n        // the original caller's uid here, which is what should be used for filtering.\n        List<String> managedTypes =\n                getTypesManagedByCaller(callingUid, UserHandle.getUserId(callingUid));\n        if (packageUid != -1 &&\n                ((UserHandle.isSameApp(callingUid, Process.SYSTEM_UID)\n                || (type != null && managedTypes.contains(type))))) {\n            callingUid = packageUid;\n            opPackageName = callingPackage;\n        }\n        List<String> visibleAccountTypes = getTypesVisibleToCaller(callingUid, userId,\n                opPackageName);\n        if (visibleAccountTypes.isEmpty()\n                || (type != null && !visibleAccountTypes.contains(type))) {\n            return EMPTY_ACCOUNT_ARRAY;\n        } else if (visibleAccountTypes.contains(type)) {\n            // Prune the list down to just the requested type.\n            visibleAccountTypes = new ArrayList<>();\n            visibleAccountTypes.add(type);\n        } // else aggregate all the visible accounts (it won't matter if the\n          // list is empty).\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return getAccountsInternal(\n                    accounts,\n                    callingUid,\n                    opPackageName,\n                    visibleAccountTypes,\n                    includeUserManagedNotVisible);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @NonNull\n    private Account[] getAccountsInternal(\n            UserAccounts userAccounts,\n            int callingUid,\n            String callingPackage,\n            List<String> visibleAccountTypes,\n            boolean includeUserManagedNotVisible) {\n        ArrayList<Account> visibleAccounts = new ArrayList<>();\n        for (String visibleType : visibleAccountTypes) {\n            Account[] accountsForType = getAccountsFromCache(\n                    userAccounts, visibleType, callingUid, callingPackage,\n                    includeUserManagedNotVisible);\n            if (accountsForType != null) {\n                visibleAccounts.addAll(Arrays.asList(accountsForType));\n            }\n        }\n        Account[] result = new Account[visibleAccounts.size()];\n        for (int i = 0; i < visibleAccounts.size(); i++) {\n            result[i] = visibleAccounts.get(i);\n        }\n        return result;\n    }\n\n    @Override\n    public void addSharedAccountsFromParentUser(int parentUserId, int userId,\n            String opPackageName) {\n        checkManageOrCreateUsersPermission(\"addSharedAccountsFromParentUser\");\n        Account[] accounts = getAccountsAsUser(null, parentUserId, opPackageName);\n        for (Account account : accounts) {\n            addSharedAccountAsUser(account, userId);\n        }\n    }\n\n    private boolean addSharedAccountAsUser(Account account, int userId) {\n        userId = handleIncomingUser(userId);\n        UserAccounts accounts = getUserAccounts(userId);\n        accounts.accountsDb.deleteSharedAccount(account);\n        long accountId = accounts.accountsDb.insertSharedAccount(account);\n        if (accountId < 0) {\n            Log.w(TAG, \"insertAccountIntoDatabase: \" + account.toSafeString()\n                    + \", skipping the DB insert failed\");\n            return false;\n        }\n        logRecord(AccountsDb.DEBUG_ACTION_ACCOUNT_ADD, AccountsDb.TABLE_SHARED_ACCOUNTS, accountId,\n                accounts);\n        return true;\n    }\n\n    public boolean renameSharedAccountAsUser(Account account, String newName, int userId) {\n        userId = handleIncomingUser(userId);\n        UserAccounts accounts = getUserAccounts(userId);\n        long sharedTableAccountId = accounts.accountsDb.findSharedAccountId(account);\n        int r = accounts.accountsDb.renameSharedAccount(account, newName);\n        if (r > 0) {\n            int callingUid = getCallingUid();\n            logRecord(AccountsDb.DEBUG_ACTION_ACCOUNT_RENAME, AccountsDb.TABLE_SHARED_ACCOUNTS,\n                    sharedTableAccountId, accounts, callingUid);\n            // Recursively rename the account.\n            renameAccountInternal(accounts, account, newName);\n        }\n        return r > 0;\n    }\n\n    public boolean removeSharedAccountAsUser(Account account, int userId) {\n        return removeSharedAccountAsUser(account, userId, getCallingUid());\n    }\n\n    private boolean removeSharedAccountAsUser(Account account, int userId, int callingUid) {\n        userId = handleIncomingUser(userId);\n        UserAccounts accounts = getUserAccounts(userId);\n        long sharedTableAccountId = accounts.accountsDb.findSharedAccountId(account);\n        boolean deleted = accounts.accountsDb.deleteSharedAccount(account);\n        if (deleted) {\n            logRecord(AccountsDb.DEBUG_ACTION_ACCOUNT_REMOVE, AccountsDb.TABLE_SHARED_ACCOUNTS,\n                    sharedTableAccountId, accounts, callingUid);\n            removeAccountInternal(accounts, account, callingUid);\n        }\n        return deleted;\n    }\n\n    public Account[] getSharedAccountsAsUser(int userId) {\n        userId = handleIncomingUser(userId);\n        UserAccounts accounts = getUserAccounts(userId);\n        synchronized (accounts.dbLock) {\n            List<Account> accountList = accounts.accountsDb.getSharedAccounts();\n            Account[] accountArray = new Account[accountList.size()];\n            accountList.toArray(accountArray);\n            return accountArray;\n        }\n    }\n\n    @Override\n    @NonNull\n    public Account[] getAccountsForPackage(String packageName, int uid, String opPackageName) {\n        int callingUid = Binder.getCallingUid();\n        if (!UserHandle.isSameApp(callingUid, Process.SYSTEM_UID)) {\n            // Don't do opPackageName check - caller is system.\n            throw new SecurityException(\"getAccountsForPackage() called from unauthorized uid \"\n                    + callingUid + \" with uid=\" + uid);\n        }\n        return getAccountsAsUserForPackage(null, UserHandle.getCallingUserId(), packageName, uid,\n                opPackageName, true /* includeUserManagedNotVisible */);\n    }\n\n    @Override\n    @NonNull\n    public Account[] getAccountsByTypeForPackage(String type, String packageName,\n            String opPackageName) {\n        int callingUid =  Binder.getCallingUid();\n        int userId = UserHandle.getCallingUserId();\n        mAppOpsManager.checkPackage(callingUid, opPackageName);\n        int packageUid = -1;\n        try {\n            packageUid = mPackageManager.getPackageUidAsUser(packageName, userId);\n        } catch (NameNotFoundException re) {\n            Slog.e(TAG, \"Couldn't determine the packageUid for \" + packageName + re);\n            return EMPTY_ACCOUNT_ARRAY;\n        }\n        if (!UserHandle.isSameApp(callingUid, Process.SYSTEM_UID)\n                && (type != null && !isAccountManagedByCaller(type, callingUid, userId))) {\n                return EMPTY_ACCOUNT_ARRAY;\n        }\n        if (!UserHandle.isSameApp(callingUid, Process.SYSTEM_UID) && type == null) {\n            return getAccountsAsUserForPackage(type, userId,\n                packageName, packageUid, opPackageName, false /* includeUserManagedNotVisible */);\n        }\n        return getAccountsAsUserForPackage(type, userId,\n                packageName, packageUid, opPackageName, true /* includeUserManagedNotVisible */);\n    }\n\n    private boolean needToStartChooseAccountActivity(Account[] accounts, String callingPackage) {\n        if (accounts.length < 1) return false;\n        if (accounts.length > 1) return true;\n        Account account = accounts[0];\n        UserAccounts userAccounts = getUserAccounts(UserHandle.getCallingUserId());\n        int visibility = resolveAccountVisibility(account, callingPackage, userAccounts);\n        if (visibility == AccountManager.VISIBILITY_USER_MANAGED_NOT_VISIBLE) return true;\n        return false;\n    }\n\n    private void startChooseAccountActivityWithAccounts(\n        IAccountManagerResponse response, Account[] accounts, String callingPackage) {\n        Intent intent = new Intent(mContext, ChooseAccountActivity.class);\n        intent.putExtra(AccountManager.KEY_ACCOUNTS, accounts);\n        intent.putExtra(AccountManager.KEY_ACCOUNT_MANAGER_RESPONSE,\n                new AccountManagerResponse(response));\n        intent.putExtra(AccountManager.KEY_ANDROID_PACKAGE_NAME, callingPackage);\n\n        mContext.startActivityAsUser(intent, UserHandle.of(UserHandle.getCallingUserId()));\n    }\n\n    private void handleGetAccountsResult(\n        IAccountManagerResponse response,\n        Account[] accounts,\n        String callingPackage) {\n\n        if (needToStartChooseAccountActivity(accounts, callingPackage)) {\n            startChooseAccountActivityWithAccounts(response, accounts, callingPackage);\n            return;\n        }\n        if (accounts.length == 1) {\n            Bundle bundle = new Bundle();\n            bundle.putString(AccountManager.KEY_ACCOUNT_NAME, accounts[0].name);\n            bundle.putString(AccountManager.KEY_ACCOUNT_TYPE, accounts[0].type);\n            onResult(response, bundle);\n            return;\n        }\n        // No qualified account exists, return an empty Bundle.\n        onResult(response, new Bundle());\n    }\n\n    @Override\n    public void getAccountByTypeAndFeatures(\n        IAccountManagerResponse response,\n        String accountType,\n        String[] features,\n        String opPackageName) {\n\n        int callingUid = Binder.getCallingUid();\n        mAppOpsManager.checkPackage(callingUid, opPackageName);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"getAccount: accountType \" + accountType\n                    + \", response \" + response\n                    + \", features \" + Arrays.toString(features)\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        if (response == null) throw new IllegalArgumentException(\"response is null\");\n        if (accountType == null) throw new IllegalArgumentException(\"accountType is null\");\n\n        int userId = UserHandle.getCallingUserId();\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts userAccounts = getUserAccounts(userId);\n            if (ArrayUtils.isEmpty(features)) {\n                Account[] accountsWithManagedNotVisible = getAccountsFromCache(\n                    userAccounts, accountType, callingUid, opPackageName,\n                    true /* include managed not visible */);\n                handleGetAccountsResult(\n                    response, accountsWithManagedNotVisible, opPackageName);\n                return;\n            }\n\n            IAccountManagerResponse retrieveAccountsResponse =\n                new IAccountManagerResponse.Stub() {\n                @Override\n                public void onResult(Bundle value) throws RemoteException {\n                    Parcelable[] parcelables = value.getParcelableArray(\n                        AccountManager.KEY_ACCOUNTS);\n                    Account[] accounts = new Account[parcelables.length];\n                    for (int i = 0; i < parcelables.length; i++) {\n                        accounts[i] = (Account) parcelables[i];\n                    }\n                    handleGetAccountsResult(\n                        response, accounts, opPackageName);\n                }\n\n                @Override\n                public void onError(int errorCode, String errorMessage)\n                        throws RemoteException {\n                    // Will not be called in this case.\n                }\n            };\n            new GetAccountsByTypeAndFeatureSession(\n                    userAccounts,\n                    retrieveAccountsResponse,\n                    accountType,\n                    features,\n                    callingUid,\n                    opPackageName,\n                    true /* include managed not visible */).bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void getAccountsByFeatures(\n            IAccountManagerResponse response,\n            String type,\n            String[] features,\n            String opPackageName) {\n        int callingUid = Binder.getCallingUid();\n        mAppOpsManager.checkPackage(callingUid, opPackageName);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"getAccounts: accountType \" + type\n                    + \", response \" + response\n                    + \", features \" + Arrays.toString(features)\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        if (response == null) throw new IllegalArgumentException(\"response is null\");\n        if (type == null) throw new IllegalArgumentException(\"accountType is null\");\n        int userId = UserHandle.getCallingUserId();\n\n        List<String> visibleAccountTypes = getTypesVisibleToCaller(callingUid, userId,\n                opPackageName);\n        if (!visibleAccountTypes.contains(type)) {\n            Bundle result = new Bundle();\n            // Need to return just the accounts that are from matching signatures.\n            result.putParcelableArray(AccountManager.KEY_ACCOUNTS, EMPTY_ACCOUNT_ARRAY);\n            try {\n                response.onResult(result);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Cannot respond to caller do to exception.\" , e);\n            }\n            return;\n        }\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts userAccounts = getUserAccounts(userId);\n            if (features == null || features.length == 0) {\n                Account[] accounts = getAccountsFromCache(userAccounts, type, callingUid,\n                        opPackageName, false);\n                Bundle result = new Bundle();\n                result.putParcelableArray(AccountManager.KEY_ACCOUNTS, accounts);\n                onResult(response, result);\n                return;\n            }\n            new GetAccountsByTypeAndFeatureSession(\n                    userAccounts,\n                    response,\n                    type,\n                    features,\n                    callingUid,\n                    opPackageName,\n                    false /* include managed not visible */).bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void onAccountAccessed(String token) throws RemoteException {\n        final int uid = Binder.getCallingUid();\n        if (UserHandle.getAppId(uid) == Process.SYSTEM_UID) {\n            return;\n        }\n        final int userId = UserHandle.getCallingUserId();\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            for (Account account : getAccounts(userId, mContext.getOpPackageName())) {\n                if (Objects.equals(account.getAccessId(), token)) {\n                    // An app just accessed the account. At this point it knows about\n                    // it and there is not need to hide this account from the app.\n                    // Do we need to update account visibility here?\n                    if (!hasAccountAccess(account, null, uid)) {\n                        updateAppPermission(account, AccountManager.ACCOUNT_ACCESS_TOKEN_TYPE,\n                                uid, true);\n                    }\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    @Override\n    public void onShellCommand(FileDescriptor in, FileDescriptor out,\n            FileDescriptor err, String[] args, ShellCallback callback,\n            ResultReceiver resultReceiver) {\n        new AccountManagerServiceShellCommand(this).exec(this, in, out, err, args,\n                callback, resultReceiver);\n    }\n\n    private abstract class Session extends IAccountAuthenticatorResponse.Stub\n            implements IBinder.DeathRecipient, ServiceConnection {\n        IAccountManagerResponse mResponse;\n        final String mAccountType;\n        final boolean mExpectActivityLaunch;\n        final long mCreationTime;\n        final String mAccountName;\n        // Indicates if we need to add auth details(like last credential time)\n        final boolean mAuthDetailsRequired;\n        // If set, we need to update the last authenticated time. This is\n        // currently\n        // used on\n        // successful confirming credentials.\n        final boolean mUpdateLastAuthenticatedTime;\n\n        public int mNumResults = 0;\n        private int mNumRequestContinued = 0;\n        private int mNumErrors = 0;\n\n        IAccountAuthenticator mAuthenticator = null;\n\n        private final boolean mStripAuthTokenFromResult;\n        protected final UserAccounts mAccounts;\n\n        public Session(UserAccounts accounts, IAccountManagerResponse response, String accountType,\n                boolean expectActivityLaunch, boolean stripAuthTokenFromResult, String accountName,\n                boolean authDetailsRequired) {\n            this(accounts, response, accountType, expectActivityLaunch, stripAuthTokenFromResult,\n                    accountName, authDetailsRequired, false /* updateLastAuthenticatedTime */);\n        }\n\n        public Session(UserAccounts accounts, IAccountManagerResponse response, String accountType,\n                boolean expectActivityLaunch, boolean stripAuthTokenFromResult, String accountName,\n                boolean authDetailsRequired, boolean updateLastAuthenticatedTime) {\n            super();\n            //if (response == null) throw new IllegalArgumentException(\"response is null\");\n            if (accountType == null) throw new IllegalArgumentException(\"accountType is null\");\n            mAccounts = accounts;\n            mStripAuthTokenFromResult = stripAuthTokenFromResult;\n            mResponse = response;\n            mAccountType = accountType;\n            mExpectActivityLaunch = expectActivityLaunch;\n            mCreationTime = SystemClock.elapsedRealtime();\n            mAccountName = accountName;\n            mAuthDetailsRequired = authDetailsRequired;\n            mUpdateLastAuthenticatedTime = updateLastAuthenticatedTime;\n\n            synchronized (mSessions) {\n                mSessions.put(toString(), this);\n            }\n            scheduleTimeout();\n            if (response != null) {\n                try {\n                    response.asBinder().linkToDeath(this, 0 /* flags */);\n                } catch (RemoteException e) {\n                    mResponse = null;\n                    binderDied();\n                }\n            }\n        }\n\n        IAccountManagerResponse getResponseAndClose() {\n            if (mResponse == null) {\n                close();\n                return null;\n            }\n            IAccountManagerResponse response = mResponse;\n            close(); // this clears mResponse so we need to save the response before this call\n            return response;\n        }\n\n        /**\n         * Checks Intents, supplied via KEY_INTENT, to make sure that they don't violate our\n         * security policy.\n         *\n         * In particular we want to make sure that the Authenticator doesn't try to trick users\n         * into launching arbitrary intents on the device via by tricking to click authenticator\n         * supplied entries in the system Settings app.\n         */\n        protected boolean checkKeyIntent(int authUid, Bundle bundle) {\n            if (!checkKeyIntentParceledCorrectly(bundle)) {\n            \tEventLog.writeEvent(0x534e4554, \"250588548\", authUid, \"\");\n                return false;\n            }\n            Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT);\n            if (intent == null) {\n                return true;\n            }\n            // Explicitly set an empty ClipData to ensure that we don't offer to\n            // promote any Uris contained inside for granting purposes\n            if (intent.getClipData() == null) {\n                intent.setClipData(ClipData.newPlainText(null, null));\n            }\n            final long bid = Binder.clearCallingIdentity();\n            try {\n                PackageManager pm = mContext.getPackageManager();\n                ResolveInfo resolveInfo = pm.resolveActivityAsUser(intent, 0, mAccounts.userId);\n                if (resolveInfo == null) {\n                    return false;\n                }\n                if (\"content\".equals(intent.getScheme())) {\n                    return false;\n                }\n                ActivityInfo targetActivityInfo = resolveInfo.activityInfo;\n                int targetUid = targetActivityInfo.applicationInfo.uid;\n                PackageManagerInternal pmi = LocalServices.getService(PackageManagerInternal.class);\n                if (!isExportedSystemActivity(targetActivityInfo)\n                        && !pmi.hasSignatureCapability(\n                                targetUid, authUid,\n                                PackageParser.SigningDetails.CertCapabilities.AUTH)) {\n                    String pkgName = targetActivityInfo.packageName;\n                    String activityName = targetActivityInfo.name;\n                    String tmpl = \"KEY_INTENT resolved to an Activity (%s) in a package (%s) that \"\n                            + \"does not share a signature with the supplying authenticator (%s).\";\n                    Log.e(TAG, String.format(tmpl, activityName, pkgName, mAccountType));\n                    return false;\n                }\n                intent.setComponent(targetActivityInfo.getComponentName());\n                bundle.putParcelable(AccountManager.KEY_INTENT, intent);\n                return true;\n            } finally {\n                Binder.restoreCallingIdentity(bid);\n            }\n        }\n\n        /**\n         * Simulate the client side's deserialization of KEY_INTENT value, to make sure they don't\n         * violate our security policy.\n         *\n         * In particular we want to make sure the Authenticator doesn't trick users\n         * into launching arbitrary intents on the device via exploiting any other Parcel read/write\n         * mismatch problems.\n         */\n        private boolean checkKeyIntentParceledCorrectly(Bundle bundle) {\n            Parcel p = Parcel.obtain();\n            p.writeBundle(bundle);\n            p.setDataPosition(0);\n            Bundle simulateBundle = p.readBundle();\n            p.recycle();\n            Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT);\n            if (intent != null && intent.getClass() != Intent.class) {\n                return false;\n            }\n            Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT);\n            if (intent == null) {\n                return (simulateIntent == null);\n            }\n            if (!intent.filterEquals(simulateIntent)) {\n                return false;\n            }\n\n            if (intent.getSelector() != simulateIntent.getSelector()) {\n                return false;\n            }\n\n            int prohibitedFlags = Intent.FLAG_GRANT_READ_URI_PERMISSION\n                    | Intent.FLAG_GRANT_WRITE_URI_PERMISSION\n                    | Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION\n                    | Intent.FLAG_GRANT_PREFIX_URI_PERMISSION;\n            return (simulateIntent.getFlags() & prohibitedFlags) == 0;\n        }\n\n        private boolean isExportedSystemActivity(ActivityInfo activityInfo) {\n            String className = activityInfo.name;\n            return \"android\".equals(activityInfo.packageName) &&\n                    (GrantCredentialsPermissionActivity.class.getName().equals(className)\n                    || CantAddAccountActivity.class.getName().equals(className));\n        }\n\n        private void close() {\n            synchronized (mSessions) {\n                if (mSessions.remove(toString()) == null) {\n                    // the session was already closed, so bail out now\n                    return;\n                }\n            }\n            if (mResponse != null) {\n                // stop listening for response deaths\n                mResponse.asBinder().unlinkToDeath(this, 0 /* flags */);\n\n                // clear this so that we don't accidentally send any further results\n                mResponse = null;\n            }\n            cancelTimeout();\n            unbind();\n        }\n\n        @Override\n        public void binderDied() {\n            mResponse = null;\n            close();\n        }\n\n        protected String toDebugString() {\n            return toDebugString(SystemClock.elapsedRealtime());\n        }\n\n        protected String toDebugString(long now) {\n            return \"Session: expectLaunch \" + mExpectActivityLaunch\n                    + \", connected \" + (mAuthenticator != null)\n                    + \", stats (\" + mNumResults + \"/\" + mNumRequestContinued\n                    + \"/\" + mNumErrors + \")\"\n                    + \", lifetime \" + ((now - mCreationTime) / 1000.0);\n        }\n\n        void bind() {\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"initiating bind to authenticator type \" + mAccountType);\n            }\n            if (!bindToAuthenticator(mAccountType)) {\n                Log.d(TAG, \"bind attempt failed for \" + toDebugString());\n                onError(AccountManager.ERROR_CODE_REMOTE_EXCEPTION, \"bind failure\");\n            }\n        }\n\n        private void unbind() {\n            if (mAuthenticator != null) {\n                mAuthenticator = null;\n                mContext.unbindService(this);\n            }\n        }\n\n        private void scheduleTimeout() {\n            mHandler.sendMessageDelayed(\n                    mHandler.obtainMessage(MESSAGE_TIMED_OUT, this), TIMEOUT_DELAY_MS);\n        }\n\n        public void cancelTimeout() {\n            mHandler.removeMessages(MESSAGE_TIMED_OUT, this);\n        }\n\n        @Override\n        public void onServiceConnected(ComponentName name, IBinder service) {\n            mAuthenticator = IAccountAuthenticator.Stub.asInterface(service);\n            try {\n                run();\n            } catch (RemoteException e) {\n                onError(AccountManager.ERROR_CODE_REMOTE_EXCEPTION,\n                        \"remote exception\");\n            }\n        }\n\n        @Override\n        public void onServiceDisconnected(ComponentName name) {\n            mAuthenticator = null;\n            IAccountManagerResponse response = getResponseAndClose();\n            if (response != null) {\n                try {\n                    response.onError(AccountManager.ERROR_CODE_REMOTE_EXCEPTION,\n                            \"disconnected\");\n                } catch (RemoteException e) {\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, \"Session.onServiceDisconnected: \"\n                                + \"caught RemoteException while responding\", e);\n                    }\n                }\n            }\n        }\n\n        public abstract void run() throws RemoteException;\n\n        public void onTimedOut() {\n            IAccountManagerResponse response = getResponseAndClose();\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"Session.onTimedOut\");\n            }\n            if (response != null) {\n                try {\n                    response.onError(AccountManager.ERROR_CODE_REMOTE_EXCEPTION,\n                            \"timeout\");\n                } catch (RemoteException e) {\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, \"Session.onTimedOut: caught RemoteException while responding\",\n                                e);\n                    }\n                }\n            }\n        }\n\n        @Override\n        public void onResult(Bundle result) {\n            Bundle.setDefusable(result, true);\n            mNumResults++;\n            Intent intent = null;\n            if (result != null) {\n                boolean isSuccessfulConfirmCreds = result.getBoolean(\n                        AccountManager.KEY_BOOLEAN_RESULT, false);\n                boolean isSuccessfulUpdateCredsOrAddAccount =\n                        result.containsKey(AccountManager.KEY_ACCOUNT_NAME)\n                        && result.containsKey(AccountManager.KEY_ACCOUNT_TYPE);\n                // We should only update lastAuthenticated time, if\n                // mUpdateLastAuthenticatedTime is true and the confirmRequest\n                // or updateRequest was successful\n                boolean needUpdate = mUpdateLastAuthenticatedTime\n                        && (isSuccessfulConfirmCreds || isSuccessfulUpdateCredsOrAddAccount);\n                if (needUpdate || mAuthDetailsRequired) {\n                    boolean accountPresent = isAccountPresentForCaller(mAccountName, mAccountType);\n                    if (needUpdate && accountPresent) {\n                        updateLastAuthenticatedTime(new Account(mAccountName, mAccountType));\n                    }\n                    if (mAuthDetailsRequired) {\n                        long lastAuthenticatedTime = -1;\n                        if (accountPresent) {\n                            lastAuthenticatedTime = mAccounts.accountsDb\n                                    .findAccountLastAuthenticatedTime(\n                                            new Account(mAccountName, mAccountType));\n                        }\n                        result.putLong(AccountManager.KEY_LAST_AUTHENTICATED_TIME,\n                                lastAuthenticatedTime);\n                    }\n                }\n            }\n            if (result != null) {\n                if (!checkKeyIntent(\n                        Binder.getCallingUid(),\n                        result)) {\n                    onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                            \"invalid intent in bundle returned\");\n                    return;\n                }\n            }\n            if (result != null\n                    && !TextUtils.isEmpty(result.getString(AccountManager.KEY_AUTHTOKEN))) {\n                String accountName = result.getString(AccountManager.KEY_ACCOUNT_NAME);\n                String accountType = result.getString(AccountManager.KEY_ACCOUNT_TYPE);\n                if (!TextUtils.isEmpty(accountName) && !TextUtils.isEmpty(accountType)) {\n                    Account account = new Account(accountName, accountType);\n                    cancelNotification(getSigninRequiredNotificationId(mAccounts, account),\n                            new UserHandle(mAccounts.userId));\n                }\n            }\n            IAccountManagerResponse response;\n            if (mExpectActivityLaunch && result != null\n                    && result.containsKey(AccountManager.KEY_INTENT)) {\n                response = mResponse;\n            } else {\n                response = getResponseAndClose();\n            }\n            if (response != null) {\n                try {\n                    if (result == null) {\n                        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                            Log.v(TAG, getClass().getSimpleName()\n                                    + \" calling onError() on response \" + response);\n                        }\n                        response.onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                                \"null bundle returned\");\n                    } else {\n                        if (mStripAuthTokenFromResult) {\n                            result.remove(AccountManager.KEY_AUTHTOKEN);\n                            if (!checkKeyIntent(Binder.getCallingUid(), result)) {\n                                onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                                        \"invalid intent in bundle returned\");\n                                return;\n                            }\n                        }\n                        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                            Log.v(TAG, getClass().getSimpleName()\n                                    + \" calling onResult() on response \" + response);\n                        }\n                        if ((result.getInt(AccountManager.KEY_ERROR_CODE, -1) > 0) &&\n                                (intent == null)) {\n                            // All AccountManager error codes are greater than 0\n                            response.onError(result.getInt(AccountManager.KEY_ERROR_CODE),\n                                    result.getString(AccountManager.KEY_ERROR_MESSAGE));\n                        } else {\n                            response.onResult(result);\n                        }\n                    }\n                } catch (RemoteException e) {\n                    // if the caller is dead then there is no one to care about remote exceptions\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, \"failure while notifying response\", e);\n                    }\n                }\n            }\n        }\n\n        @Override\n        public void onRequestContinued() {\n            mNumRequestContinued++;\n        }\n\n        @Override\n        public void onError(int errorCode, String errorMessage) {\n            mNumErrors++;\n            IAccountManagerResponse response = getResponseAndClose();\n            if (response != null) {\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.v(TAG, getClass().getSimpleName()\n                            + \" calling onError() on response \" + response);\n                }\n                try {\n                    response.onError(errorCode, errorMessage);\n                } catch (RemoteException e) {\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, \"Session.onError: caught RemoteException while responding\", e);\n                    }\n                }\n            } else {\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.v(TAG, \"Session.onError: already closed\");\n                }\n            }\n        }\n\n        /**\n         * find the component name for the authenticator and initiate a bind\n         * if no authenticator or the bind fails then return false, otherwise return true\n         */\n        private boolean bindToAuthenticator(String authenticatorType) {\n            final AccountAuthenticatorCache.ServiceInfo<AuthenticatorDescription> authenticatorInfo;\n            authenticatorInfo = mAuthenticatorCache.getServiceInfo(\n                    AuthenticatorDescription.newKey(authenticatorType), mAccounts.userId);\n            if (authenticatorInfo == null) {\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.v(TAG, \"there is no authenticator for \" + authenticatorType\n                            + \", bailing out\");\n                }\n                return false;\n            }\n\n            if (!isLocalUnlockedUser(mAccounts.userId)\n                    && !authenticatorInfo.componentInfo.directBootAware) {\n                Slog.w(TAG, \"Blocking binding to authenticator \" + authenticatorInfo.componentName\n                        + \" which isn't encryption aware\");\n                return false;\n            }\n\n            Intent intent = new Intent();\n            intent.setAction(AccountManager.ACTION_AUTHENTICATOR_INTENT);\n            intent.setComponent(authenticatorInfo.componentName);\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"performing bindService to \" + authenticatorInfo.componentName);\n            }\n            int flags = Context.BIND_AUTO_CREATE;\n            if (mAuthenticatorCache.getBindInstantServiceAllowed(mAccounts.userId)) {\n                flags |= Context.BIND_ALLOW_INSTANT;\n            }\n            if (!mContext.bindServiceAsUser(intent, this, flags, UserHandle.of(mAccounts.userId))) {\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.v(TAG, \"bindService to \" + authenticatorInfo.componentName + \" failed\");\n                }\n                return false;\n            }\n\n            return true;\n        }\n    }\n\n    class MessageHandler extends Handler {\n        MessageHandler(Looper looper) {\n            super(looper);\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MESSAGE_TIMED_OUT:\n                    Session session = (Session)msg.obj;\n                    session.onTimedOut();\n                    break;\n\n                case MESSAGE_COPY_SHARED_ACCOUNT:\n                    copyAccountToUser(/*no response*/ null, (Account) msg.obj, msg.arg1, msg.arg2);\n                    break;\n\n                default:\n                    throw new IllegalStateException(\"unhandled message: \" + msg.what);\n            }\n        }\n    }\n\n    private void logRecord(UserAccounts accounts, String action, String tableName) {\n        logRecord(action, tableName, -1, accounts);\n    }\n\n    private void logRecordWithUid(UserAccounts accounts, String action, String tableName, int uid) {\n        logRecord(action, tableName, -1, accounts, uid);\n    }\n\n    /*\n     * This function receives an opened writable database.\n     */\n    private void logRecord(String action, String tableName, long accountId,\n            UserAccounts userAccount) {\n        logRecord(action, tableName, accountId, userAccount, getCallingUid());\n    }\n\n    /*\n     * This function receives an opened writable database and writes to it in a separate thread.\n     */\n    private void logRecord(String action, String tableName, long accountId,\n            UserAccounts userAccount, int callingUid) {\n\n        class LogRecordTask implements Runnable {\n            private final String action;\n            private final String tableName;\n            private final long accountId;\n            private final UserAccounts userAccount;\n            private final int callingUid;\n            private final long userDebugDbInsertionPoint;\n\n            LogRecordTask(final String action,\n                    final String tableName,\n                    final long accountId,\n                    final UserAccounts userAccount,\n                    final int callingUid,\n                    final long userDebugDbInsertionPoint) {\n                this.action = action;\n                this.tableName = tableName;\n                this.accountId = accountId;\n                this.userAccount = userAccount;\n                this.callingUid = callingUid;\n                this.userDebugDbInsertionPoint = userDebugDbInsertionPoint;\n            }\n\n            @Override\n            public void run() {\n                synchronized (userAccount.accountsDb.mDebugStatementLock) {\n                    SQLiteStatement logStatement = userAccount.accountsDb.getStatementForLogging();\n                    if (logStatement == null) {\n                        return; // Can't log.\n                    }\n                    logStatement.bindLong(1, accountId);\n                    logStatement.bindString(2, action);\n                    logStatement.bindString(3, mDateFormat.format(new Date()));\n                    logStatement.bindLong(4, callingUid);\n                    logStatement.bindString(5, tableName);\n                    logStatement.bindLong(6, userDebugDbInsertionPoint);\n                    try {\n                        logStatement.execute();\n                    } catch (IllegalStateException e) {\n                        // Guard against crash, DB can already be closed\n                        // since this statement is executed on a handler thread\n                        Slog.w(TAG, \"Failed to insert a log record. accountId=\" + accountId\n                                + \" action=\" + action + \" tableName=\" + tableName + \" Error: \" + e);\n                    } finally {\n                        logStatement.clearBindings();\n                    }\n                }\n            }\n        }\n        long insertionPoint = userAccount.accountsDb.reserveDebugDbInsertionPoint();\n        if (insertionPoint != -1) {\n            LogRecordTask logTask = new LogRecordTask(action, tableName, accountId, userAccount,\n                    callingUid, insertionPoint);\n            mHandler.post(logTask);\n        }\n    }\n\n    public IBinder onBind(@SuppressWarnings(\"unused\") Intent intent) {\n        return asBinder();\n    }\n\n    /**\n     * Searches array of arguments for the specified string\n     * @param args array of argument strings\n     * @param value value to search for\n     * @return true if the value is contained in the array\n     */\n    private static boolean scanArgs(String[] args, String value) {\n        if (args != null) {\n            for (String arg : args) {\n                if (value.equals(arg)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    @Override\n    protected void dump(FileDescriptor fd, PrintWriter fout, String[] args) {\n        if (!DumpUtils.checkDumpPermission(mContext, TAG, fout)) return;\n        final boolean isCheckinRequest = scanArgs(args, \"--checkin\") || scanArgs(args, \"-c\");\n        final IndentingPrintWriter ipw = new IndentingPrintWriter(fout, \"  \");\n\n        final List<UserInfo> users = getUserManager().getUsers();\n        for (UserInfo user : users) {\n            ipw.println(\"User \" + user + \":\");\n            ipw.increaseIndent();\n            dumpUser(getUserAccounts(user.id), fd, ipw, args, isCheckinRequest);\n            ipw.println();\n            ipw.decreaseIndent();\n        }\n    }\n\n    private void dumpUser(UserAccounts userAccounts, FileDescriptor fd, PrintWriter fout,\n            String[] args, boolean isCheckinRequest) {\n        if (isCheckinRequest) {\n            // This is a checkin request. *Only* upload the account types and the count of\n            // each.\n            synchronized (userAccounts.dbLock) {\n                userAccounts.accountsDb.dumpDeAccountsTable(fout);\n            }\n        } else {\n            Account[] accounts = getAccountsFromCache(userAccounts, null /* type */,\n                    Process.SYSTEM_UID, null /* packageName */, false);\n            fout.println(\"Accounts: \" + accounts.length);\n            for (Account account : accounts) {\n                fout.println(\"  \" + account.toString());\n            }\n\n            // Add debug information.\n            fout.println();\n            synchronized (userAccounts.dbLock) {\n                userAccounts.accountsDb.dumpDebugTable(fout);\n            }\n            fout.println();\n            synchronized (mSessions) {\n                final long now = SystemClock.elapsedRealtime();\n                fout.println(\"Active Sessions: \" + mSessions.size());\n                for (Session session : mSessions.values()) {\n                    fout.println(\"  \" + session.toDebugString(now));\n                }\n            }\n\n            fout.println();\n            mAuthenticatorCache.dump(fd, fout, args, userAccounts.userId);\n\n            boolean isUserUnlocked;\n            synchronized (mUsers) {\n                isUserUnlocked = isLocalUnlockedUser(userAccounts.userId);\n            }\n            // Following logs are printed only when user is unlocked.\n            if (!isUserUnlocked) {\n                return;\n            }\n            fout.println();\n            synchronized (userAccounts.dbLock) {\n                Map<Account, Map<String, Integer>> allVisibilityValues =\n                        userAccounts.accountsDb.findAllVisibilityValues();\n                fout.println(\"Account visibility:\");\n                for (Account account : allVisibilityValues.keySet()) {\n                    fout.println(\"  \" + account.name);\n                    Map<String, Integer> visibilities = allVisibilityValues.get(account);\n                    for (Entry<String, Integer> entry : visibilities.entrySet()) {\n                        fout.println(\"    \" + entry.getKey() + \", \" + entry.getValue());\n                    }\n                }\n            }\n        }\n    }\n\n    private void doNotification(UserAccounts accounts, Account account, CharSequence message,\n            Intent intent, String packageName, final int userId) {\n        final long identityToken = clearCallingIdentity();\n        try {\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"doNotification: \" + message + \" intent:\" + intent);\n            }\n\n            if (intent.getComponent() != null &&\n                    GrantCredentialsPermissionActivity.class.getName().equals(\n                            intent.getComponent().getClassName())) {\n                createNoCredentialsPermissionNotification(account, intent, packageName, userId);\n            } else {\n                Context contextForUser = getContextForUser(new UserHandle(userId));\n                final NotificationId id = getSigninRequiredNotificationId(accounts, account);\n                intent.addCategory(id.mTag);\n\n                final String notificationTitleFormat =\n                        contextForUser.getText(R.string.notification_title).toString();\n                Notification n =\n                        new Notification.Builder(contextForUser, SystemNotificationChannels.ACCOUNT)\n                        .setWhen(0)\n                        .setSmallIcon(android.R.drawable.stat_sys_warning)\n                        .setColor(contextForUser.getColor(\n                                com.android.internal.R.color.system_notification_accent_color))\n                        .setContentTitle(String.format(notificationTitleFormat, account.name))\n                        .setContentText(message)\n                        .setContentIntent(PendingIntent.getActivityAsUser(\n                                mContext, 0, intent,\n                                PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_IMMUTABLE,\n                                null, new UserHandle(userId)))\n                        .build();\n                installNotification(id, n, packageName, userId);\n            }\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private void installNotification(NotificationId id, final Notification notification,\n            String packageName, int userId) {\n        final long token = clearCallingIdentity();\n        try {\n            INotificationManager notificationManager = mInjector.getNotificationManager();\n            try {\n                // The calling uid must match either the package or op package, so use an op\n                // package that matches the cleared calling identity.\n                notificationManager.enqueueNotificationWithTag(packageName, \"android\",\n                        id.mTag, id.mId, notification, userId);\n            } catch (RemoteException e) {\n                /* ignore - local call */\n            }\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private void cancelNotification(NotificationId id, UserHandle user) {\n        cancelNotification(id, mContext.getPackageName(), user);\n    }\n\n    private void cancelNotification(NotificationId id, String packageName, UserHandle user) {\n        final long identityToken = clearCallingIdentity();\n        try {\n            INotificationManager service = mInjector.getNotificationManager();\n            service.cancelNotificationWithTag(\n                    packageName, \"android\", id.mTag, id.mId, user.getIdentifier());\n        } catch (RemoteException e) {\n            /* ignore - local call */\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private boolean isPermittedForPackage(String packageName, int userId, String... permissions) {\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            final int uid = mPackageManager.getPackageUidAsUser(packageName, userId);\n            IPackageManager pm = ActivityThread.getPackageManager();\n            for (String perm : permissions) {\n                if (pm.checkPermission(perm, packageName, userId)\n                        == PackageManager.PERMISSION_GRANTED) {\n                    // Checks runtime permission revocation.\n                    final int opCode = AppOpsManager.permissionToOpCode(perm);\n                    if (opCode == AppOpsManager.OP_NONE || mAppOpsManager.checkOpNoThrow(\n                            opCode, uid, packageName) == AppOpsManager.MODE_ALLOWED) {\n                        return true;\n                    }\n                }\n            }\n        } catch (NameNotFoundException | RemoteException e) {\n            // Assume permission is not granted if an error accrued.\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n        return false;\n    }\n\n    /**\n     * Checks that package has at least one of given permissions and makes note of app\n     * performing the action.\n     */\n    private boolean checkPermissionAndNote(String opPackageName, int callingUid,\n            String... permissions) {\n        for (String perm : permissions) {\n            if (mContext.checkCallingOrSelfPermission(perm) == PackageManager.PERMISSION_GRANTED) {\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.v(TAG, \"  caller uid \" + callingUid + \" has \" + perm);\n                }\n                final int opCode = AppOpsManager.permissionToOpCode(perm);\n                if (opCode == AppOpsManager.OP_NONE || mAppOpsManager.noteOpNoThrow(\n                        opCode, callingUid, opPackageName) == AppOpsManager.MODE_ALLOWED) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private int handleIncomingUser(int userId) {\n        try {\n            return ActivityManager.getService().handleIncomingUser(\n                    Binder.getCallingPid(), Binder.getCallingUid(), userId, true, true, \"\", null);\n        } catch (RemoteException re) {\n            // Shouldn't happen, local.\n        }\n        return userId;\n    }\n\n    private boolean isPrivileged(int callingUid) {\n        String[] packages;\n        final long identityToken = Binder.clearCallingIdentity();\n        try {\n            packages = mPackageManager.getPackagesForUid(callingUid);\n            if (packages == null) {\n                Log.d(TAG, \"No packages for callingUid \" + callingUid);\n                return false;\n            }\n            for (String name : packages) {\n                try {\n                    PackageInfo packageInfo =\n                        mPackageManager.getPackageInfo(name, 0 /* flags */);\n                    if (packageInfo != null\n                        && (packageInfo.applicationInfo.privateFlags\n                            & ApplicationInfo.PRIVATE_FLAG_PRIVILEGED) != 0) {\n                        return true;\n                    }\n                } catch (PackageManager.NameNotFoundException e) {\n                    Log.d(TAG, \"Package not found \" + e.getMessage());\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identityToken);\n        }\n        return false;\n    }\n\n    private boolean permissionIsGranted(\n            Account account, String authTokenType, int callerUid, int userId) {\n        if (UserHandle.getAppId(callerUid) == Process.SYSTEM_UID) {\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"Access to \" + account + \" granted calling uid is system\");\n            }\n            return true;\n        }\n\n        if (isPrivileged(callerUid)) {\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"Access to \" + account + \" granted calling uid \"\n                        + callerUid + \" privileged\");\n            }\n            return true;\n        }\n        if (account != null && isAccountManagedByCaller(account.type, callerUid, userId)) {\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"Access to \" + account + \" granted calling uid \"\n                        + callerUid + \" manages the account\");\n            }\n            return true;\n        }\n        if (account != null && hasExplicitlyGrantedPermission(account, authTokenType, callerUid)) {\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"Access to \" + account + \" granted calling uid \"\n                        + callerUid + \" user granted access\");\n            }\n            return true;\n        }\n\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"Access to \" + account + \" not granted for uid \" + callerUid);\n        }\n\n        return false;\n    }\n\n    private boolean isAccountVisibleToCaller(String accountType, int callingUid, int userId,\n            String opPackageName) {\n        if (accountType == null) {\n            return false;\n        } else {\n            return getTypesVisibleToCaller(callingUid, userId,\n                    opPackageName).contains(accountType);\n        }\n    }\n\n    // Method checks visibility for applications targeing API level below {@link\n    // android.os.Build.VERSION_CODES#O},\n    // returns true if the the app has GET_ACCOUNTS or GET_ACCOUNTS_PRIVILEGED permission.\n    private boolean checkGetAccountsPermission(String packageName, int userId) {\n        return isPermittedForPackage(packageName, userId, Manifest.permission.GET_ACCOUNTS,\n                Manifest.permission.GET_ACCOUNTS_PRIVILEGED);\n    }\n\n    private boolean checkReadContactsPermission(String packageName, int userId) {\n        return isPermittedForPackage(packageName, userId, Manifest.permission.READ_CONTACTS);\n    }\n\n    // Heuristic to check that account type may be associated with some contacts data and\n    // therefore READ_CONTACTS permission grants the access to account by default.\n    private boolean accountTypeManagesContacts(String accountType, int userId) {\n        if (accountType == null) {\n            return false;\n        }\n        final long identityToken = Binder.clearCallingIdentity();\n        Collection<RegisteredServicesCache.ServiceInfo<AuthenticatorDescription>> serviceInfos;\n        try {\n            serviceInfos = mAuthenticatorCache.getAllServices(userId);\n        } finally {\n            Binder.restoreCallingIdentity(identityToken);\n        }\n        // Check contacts related permissions for authenticator.\n        for (RegisteredServicesCache.ServiceInfo<AuthenticatorDescription> serviceInfo\n                : serviceInfos) {\n            if (accountType.equals(serviceInfo.type.type)) {\n                return isPermittedForPackage(serviceInfo.type.packageName, userId,\n                    Manifest.permission.WRITE_CONTACTS);\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Method checks package uid and signature with Authenticator which manages accountType.\n     *\n     * @return SIGNATURE_CHECK_UID_MATCH for uid match, SIGNATURE_CHECK_MATCH for signature match,\n     *         SIGNATURE_CHECK_MISMATCH otherwise.\n     */\n    private int checkPackageSignature(String accountType, int callingUid, int userId) {\n        if (accountType == null) {\n            return SIGNATURE_CHECK_MISMATCH;\n        }\n\n        final long identityToken = Binder.clearCallingIdentity();\n        Collection<RegisteredServicesCache.ServiceInfo<AuthenticatorDescription>> serviceInfos;\n        try {\n            serviceInfos = mAuthenticatorCache.getAllServices(userId);\n        } finally {\n            Binder.restoreCallingIdentity(identityToken);\n        }\n        // Check for signature match with Authenticator.LocalServices.getService(PackageManagerInternal.class);\n        PackageManagerInternal pmi = LocalServices.getService(PackageManagerInternal.class);\n        for (RegisteredServicesCache.ServiceInfo<AuthenticatorDescription> serviceInfo\n                : serviceInfos) {\n            if (accountType.equals(serviceInfo.type.type)) {\n                if (serviceInfo.uid == callingUid) {\n                    return SIGNATURE_CHECK_UID_MATCH;\n                }\n                if (pmi.hasSignatureCapability(\n                        serviceInfo.uid, callingUid,\n                        PackageParser.SigningDetails.CertCapabilities.AUTH)) {\n                    return SIGNATURE_CHECK_MATCH;\n                }\n            }\n        }\n        return SIGNATURE_CHECK_MISMATCH;\n    }\n\n    // returns true for applications with the same signature as authenticator.\n    private boolean isAccountManagedByCaller(String accountType, int callingUid, int userId) {\n        if (accountType == null) {\n            return false;\n        } else {\n            return getTypesManagedByCaller(callingUid, userId).contains(accountType);\n        }\n    }\n\n    private List<String> getTypesVisibleToCaller(int callingUid, int userId,\n            String opPackageName) {\n        return getTypesForCaller(callingUid, userId, true /* isOtherwisePermitted*/);\n    }\n\n    private List<String> getTypesManagedByCaller(int callingUid, int userId) {\n        return getTypesForCaller(callingUid, userId, false);\n    }\n\n    private List<String> getTypesForCaller(\n            int callingUid, int userId, boolean isOtherwisePermitted) {\n        List<String> managedAccountTypes = new ArrayList<>();\n        final long identityToken = Binder.clearCallingIdentity();\n        Collection<RegisteredServicesCache.ServiceInfo<AuthenticatorDescription>> serviceInfos;\n        try {\n            serviceInfos = mAuthenticatorCache.getAllServices(userId);\n        } finally {\n            Binder.restoreCallingIdentity(identityToken);\n        }\n\n        PackageManagerInternal pmi = LocalServices.getService(PackageManagerInternal.class);\n        for (RegisteredServicesCache.ServiceInfo<AuthenticatorDescription> serviceInfo :\n                serviceInfos) {\n            if (isOtherwisePermitted || pmi.hasSignatureCapability(\n                    serviceInfo.uid, callingUid,\n                    PackageParser.SigningDetails.CertCapabilities.AUTH)) {\n                managedAccountTypes.add(serviceInfo.type.type);\n            }\n        }\n        return managedAccountTypes;\n    }\n\n    private boolean isAccountPresentForCaller(String accountName, String accountType) {\n        if (getUserAccountsForCaller().accountCache.containsKey(accountType)) {\n            for (Account account : getUserAccountsForCaller().accountCache.get(accountType)) {\n                if (account.name.equals(accountName)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private static void checkManageUsersPermission(String message) {\n        if (ActivityManager.checkComponentPermission(\n                android.Manifest.permission.MANAGE_USERS, Binder.getCallingUid(), -1, true)\n                != PackageManager.PERMISSION_GRANTED) {\n            throw new SecurityException(\"You need MANAGE_USERS permission to: \" + message);\n        }\n    }\n\n    private static void checkManageOrCreateUsersPermission(String message) {\n        if (ActivityManager.checkComponentPermission(android.Manifest.permission.MANAGE_USERS,\n                Binder.getCallingUid(), -1, true) != PackageManager.PERMISSION_GRANTED &&\n                ActivityManager.checkComponentPermission(android.Manifest.permission.CREATE_USERS,\n                        Binder.getCallingUid(), -1, true) != PackageManager.PERMISSION_GRANTED) {\n            throw new SecurityException(\"You need MANAGE_USERS or CREATE_USERS permission to: \"\n                    + message);\n        }\n    }\n\n    private boolean hasExplicitlyGrantedPermission(Account account, String authTokenType,\n            int callerUid) {\n        if (UserHandle.getAppId(callerUid) == Process.SYSTEM_UID) {\n            return true;\n        }\n        UserAccounts accounts = getUserAccounts(UserHandle.getUserId(callerUid));\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                long grantsCount;\n                if (authTokenType != null) {\n                    grantsCount = accounts.accountsDb\n                            .findMatchingGrantsCount(callerUid, authTokenType, account);\n                } else {\n                    grantsCount = accounts.accountsDb.findMatchingGrantsCountAnyToken(callerUid,\n                            account);\n                }\n                final boolean permissionGranted = grantsCount > 0;\n\n                if (!permissionGranted && ActivityManager.isRunningInTestHarness()) {\n                    // TODO: Skip this check when running automated tests. Replace this\n                    // with a more general solution.\n                    Log.d(TAG, \"no credentials permission for usage of \"\n                            + account.toSafeString() + \", \"\n                            + authTokenType + \" by uid \" + callerUid\n                            + \" but ignoring since device is in test harness.\");\n                    return true;\n                }\n                return permissionGranted;\n            }\n        }\n    }\n\n    private boolean isSystemUid(int callingUid) {\n        String[] packages = null;\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            packages = mPackageManager.getPackagesForUid(callingUid);\n            if (packages != null) {\n                for (String name : packages) {\n                    try {\n                        PackageInfo packageInfo =\n                                mPackageManager.getPackageInfo(name, 0 /* flags */);\n                        if (packageInfo != null\n                                && (packageInfo.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM)\n                                != 0) {\n                            return true;\n                        }\n                    } catch (NameNotFoundException e) {\n                        Log.w(TAG, String.format(\"Could not find package [%s]\", name), e);\n                    }\n                }\n            } else {\n                Log.w(TAG, \"No known packages with uid \" + callingUid);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n        return false;\n    }\n\n    /** Succeeds if any of the specified permissions are granted. */\n    private void checkReadAccountsPermitted(\n            int callingUid,\n            String accountType,\n            int userId,\n            String opPackageName) {\n        if (!isAccountVisibleToCaller(accountType, callingUid, userId, opPackageName)) {\n            String msg = String.format(\n                    \"caller uid %s cannot access %s accounts\",\n                    callingUid,\n                    accountType);\n            Log.w(TAG, \"  \" + msg);\n            throw new SecurityException(msg);\n        }\n    }\n\n    private boolean canUserModifyAccounts(int userId, int callingUid) {\n        // the managing app can always modify accounts\n        if (isProfileOwner(callingUid)) {\n            return true;\n        }\n        if (getUserManager().getUserRestrictions(new UserHandle(userId))\n                .getBoolean(UserManager.DISALLOW_MODIFY_ACCOUNTS)) {\n            return false;\n        }\n        return true;\n    }\n\n    private boolean canUserModifyAccountsForType(int userId, String accountType, int callingUid) {\n        // the managing app can always modify accounts\n        if (isProfileOwner(callingUid)) {\n            return true;\n        }\n        DevicePolicyManager dpm = (DevicePolicyManager) mContext\n                .getSystemService(Context.DEVICE_POLICY_SERVICE);\n        String[] typesArray = dpm.getAccountTypesWithManagementDisabledAsUser(userId);\n        if (typesArray == null) {\n            return true;\n        }\n        for (String forbiddenType : typesArray) {\n            if (forbiddenType.equals(accountType)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private boolean isProfileOwner(int uid) {\n        final DevicePolicyManagerInternal dpmi =\n                LocalServices.getService(DevicePolicyManagerInternal.class);\n        //TODO(b/169395065) Figure out if this flow makes sense in Device Owner mode.\n        return (dpmi != null) && (dpmi.isActiveProfileOwner(uid) || dpmi.isActiveDeviceOwner(uid));\n    }\n\n    @Override\n    public void updateAppPermission(Account account, String authTokenType, int uid, boolean value)\n            throws RemoteException {\n        final int callingUid = getCallingUid();\n\n        if (UserHandle.getAppId(callingUid) != Process.SYSTEM_UID) {\n            throw new SecurityException();\n        }\n\n        if (value) {\n            grantAppPermission(account, authTokenType, uid);\n        } else {\n            revokeAppPermission(account, authTokenType, uid);\n        }\n    }\n\n    /**\n     * Allow callers with the given uid permission to get credentials for account/authTokenType.\n     * <p>\n     * Although this is public it can only be accessed via the AccountManagerService object\n     * which is in the system. This means we don't need to protect it with permissions.\n     * @hide\n     */\n    void grantAppPermission(Account account, String authTokenType, int uid) {\n        if (account == null || authTokenType == null) {\n            Log.e(TAG, \"grantAppPermission: called with invalid arguments\", new Exception());\n            return;\n        }\n        UserAccounts accounts = getUserAccounts(UserHandle.getUserId(uid));\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                long accountId = accounts.accountsDb.findDeAccountId(account);\n                if (accountId >= 0) {\n                    accounts.accountsDb.insertGrant(accountId, authTokenType, uid);\n                }\n                cancelNotification(\n                        getCredentialPermissionNotificationId(account, authTokenType, uid),\n                        UserHandle.of(accounts.userId));\n\n                cancelAccountAccessRequestNotificationIfNeeded(account, uid, true);\n            }\n        }\n\n        // Listeners are a final CopyOnWriteArrayList, hence no lock needed.\n        for (AccountManagerInternal.OnAppPermissionChangeListener listener\n                : mAppPermissionChangeListeners) {\n            mHandler.post(() -> listener.onAppPermissionChanged(account, uid));\n        }\n    }\n\n    /**\n     * Don't allow callers with the given uid permission to get credentials for\n     * account/authTokenType.\n     * <p>\n     * Although this is public it can only be accessed via the AccountManagerService object\n     * which is in the system. This means we don't need to protect it with permissions.\n     * @hide\n     */\n    private void revokeAppPermission(Account account, String authTokenType, int uid) {\n        if (account == null || authTokenType == null) {\n            Log.e(TAG, \"revokeAppPermission: called with invalid arguments\", new Exception());\n            return;\n        }\n        UserAccounts accounts = getUserAccounts(UserHandle.getUserId(uid));\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                accounts.accountsDb.beginTransaction();\n                try {\n                    long accountId = accounts.accountsDb.findDeAccountId(account);\n                    if (accountId >= 0) {\n                        accounts.accountsDb.deleteGrantsByAccountIdAuthTokenTypeAndUid(\n                                accountId, authTokenType, uid);\n                        accounts.accountsDb.setTransactionSuccessful();\n                    }\n                } finally {\n                    accounts.accountsDb.endTransaction();\n                }\n\n                cancelNotification(\n                        getCredentialPermissionNotificationId(account, authTokenType, uid),\n                        UserHandle.of(accounts.userId));\n            }\n        }\n\n        // Listeners are a final CopyOnWriteArrayList, hence no lock needed.\n        for (AccountManagerInternal.OnAppPermissionChangeListener listener\n                : mAppPermissionChangeListeners) {\n            mHandler.post(() -> listener.onAppPermissionChanged(account, uid));\n        }\n    }\n\n    private void removeAccountFromCacheLocked(UserAccounts accounts, Account account) {\n        final Account[] oldAccountsForType = accounts.accountCache.get(account.type);\n        if (oldAccountsForType != null) {\n            ArrayList<Account> newAccountsList = new ArrayList<>();\n            for (Account curAccount : oldAccountsForType) {\n                if (!curAccount.equals(account)) {\n                    newAccountsList.add(curAccount);\n                }\n            }\n            if (newAccountsList.isEmpty()) {\n                accounts.accountCache.remove(account.type);\n            } else {\n                Account[] newAccountsForType = new Account[newAccountsList.size()];\n                newAccountsForType = newAccountsList.toArray(newAccountsForType);\n                accounts.accountCache.put(account.type, newAccountsForType);\n            }\n        }\n        accounts.userDataCache.remove(account);\n        accounts.authTokenCache.remove(account);\n        accounts.previousNameCache.remove(account);\n        accounts.visibilityCache.remove(account);\n\n        AccountManager.invalidateLocalAccountsDataCaches();\n    }\n\n    /**\n     * This assumes that the caller has already checked that the account is not already present.\n     * IMPORTANT: The account being inserted will begin to be tracked for access in remote\n     * processes and if you will return this account to apps you should return the result.\n     * @return The inserted account which is a new instance that is being tracked.\n     */\n    private Account insertAccountIntoCacheLocked(UserAccounts accounts, Account account) {\n        Account[] accountsForType = accounts.accountCache.get(account.type);\n        int oldLength = (accountsForType != null) ? accountsForType.length : 0;\n        Account[] newAccountsForType = new Account[oldLength + 1];\n        if (accountsForType != null) {\n            System.arraycopy(accountsForType, 0, newAccountsForType, 0, oldLength);\n        }\n        String token = account.getAccessId() != null ? account.getAccessId()\n                : UUID.randomUUID().toString();\n        newAccountsForType[oldLength] = new Account(account, token);\n        accounts.accountCache.put(account.type, newAccountsForType);\n        AccountManager.invalidateLocalAccountsDataCaches();\n        return newAccountsForType[oldLength];\n    }\n\n    @NonNull\n    private Account[] filterAccounts(UserAccounts accounts, Account[] unfiltered, int callingUid,\n            @Nullable String callingPackage, boolean includeManagedNotVisible) {\n        String visibilityFilterPackage = callingPackage;\n        if (visibilityFilterPackage == null) {\n            visibilityFilterPackage = getPackageNameForUid(callingUid);\n        }\n        Map<Account, Integer> firstPass = new LinkedHashMap<>();\n        for (Account account : unfiltered) {\n            int visibility = resolveAccountVisibility(account, visibilityFilterPackage, accounts);\n            if ((visibility == AccountManager.VISIBILITY_VISIBLE\n                    || visibility == AccountManager.VISIBILITY_USER_MANAGED_VISIBLE)\n                    || (includeManagedNotVisible\n                            && (visibility\n                                    == AccountManager.VISIBILITY_USER_MANAGED_NOT_VISIBLE))) {\n                firstPass.put(account, visibility);\n            }\n        }\n        Map<Account, Integer> secondPass =\n                filterSharedAccounts(accounts, firstPass, callingUid, callingPackage);\n\n        Account[] filtered = new Account[secondPass.size()];\n        filtered = secondPass.keySet().toArray(filtered);\n        return filtered;\n    }\n\n    @NonNull\n    private Map<Account, Integer> filterSharedAccounts(UserAccounts userAccounts,\n            @NonNull Map<Account, Integer> unfiltered, int callingUid,\n            @Nullable String callingPackage) {\n        // first part is to filter shared accounts.\n        // unfiltered type check is not necessary.\n        if (getUserManager() == null || userAccounts == null || userAccounts.userId < 0\n                || callingUid == Process.SYSTEM_UID) {\n            return unfiltered;\n        }\n        UserInfo user = getUserManager().getUserInfo(userAccounts.userId);\n        if (user != null && user.isRestricted()) {\n            String[] packages = mPackageManager.getPackagesForUid(callingUid);\n            if (packages == null) {\n                packages = new String[] {};\n            }\n            // If any of the packages is a visible listed package, return the full set,\n            // otherwise return non-shared accounts only.\n            // This might be a temporary way to specify a visible list\n            String visibleList = mContext.getResources().getString(\n                    com.android.internal.R.string.config_appsAuthorizedForSharedAccounts);\n            for (String packageName : packages) {\n                if (visibleList.contains(\";\" + packageName + \";\")) {\n                    return unfiltered;\n                }\n            }\n            Account[] sharedAccounts = getSharedAccountsAsUser(userAccounts.userId);\n            if (ArrayUtils.isEmpty(sharedAccounts)) {\n                return unfiltered;\n            }\n            String requiredAccountType = \"\";\n            try {\n                // If there's an explicit callingPackage specified, check if that package\n                // opted in to see restricted accounts.\n                if (callingPackage != null) {\n                    PackageInfo pi = mPackageManager.getPackageInfo(callingPackage, 0);\n                    if (pi != null && pi.restrictedAccountType != null) {\n                        requiredAccountType = pi.restrictedAccountType;\n                    }\n                } else {\n                    // Otherwise check if the callingUid has a package that has opted in\n                    for (String packageName : packages) {\n                        PackageInfo pi = mPackageManager.getPackageInfo(packageName, 0);\n                        if (pi != null && pi.restrictedAccountType != null) {\n                            requiredAccountType = pi.restrictedAccountType;\n                            break;\n                        }\n                    }\n                }\n            } catch (NameNotFoundException e) {\n                Log.d(TAG, \"Package not found \" + e.getMessage());\n            }\n            Map<Account, Integer> filtered = new LinkedHashMap<>();\n            for (Map.Entry<Account, Integer> entry : unfiltered.entrySet()) {\n                Account account = entry.getKey();\n                if (account.type.equals(requiredAccountType)) {\n                    filtered.put(account, entry.getValue());\n                } else {\n                    boolean found = false;\n                    for (Account shared : sharedAccounts) {\n                        if (shared.equals(account)) {\n                            found = true;\n                            break;\n                        }\n                    }\n                    if (!found) {\n                        filtered.put(account, entry.getValue());\n                    }\n                }\n            }\n            return filtered;\n        } else {\n            return unfiltered;\n        }\n    }\n\n    /*\n     * packageName can be null. If not null, it should be used to filter out restricted accounts\n     * that the package is not allowed to access.\n     *\n     * <p>The method shouldn't be called with UserAccounts#cacheLock held, otherwise it will cause a\n     * deadlock\n     */\n    @NonNull\n    protected Account[] getAccountsFromCache(UserAccounts userAccounts, String accountType,\n            int callingUid, @Nullable String callingPackage, boolean includeManagedNotVisible) {\n        Preconditions.checkState(!Thread.holdsLock(userAccounts.cacheLock),\n                \"Method should not be called with cacheLock\");\n        if (accountType != null) {\n            Account[] accounts;\n            synchronized (userAccounts.cacheLock) {\n                accounts = userAccounts.accountCache.get(accountType);\n            }\n            if (accounts == null) {\n                return EMPTY_ACCOUNT_ARRAY;\n            } else {\n                return filterAccounts(userAccounts, Arrays.copyOf(accounts, accounts.length),\n                        callingUid, callingPackage, includeManagedNotVisible);\n            }\n        } else {\n            int totalLength = 0;\n            Account[] accountsArray;\n            synchronized (userAccounts.cacheLock) {\n                for (Account[] accounts : userAccounts.accountCache.values()) {\n                    totalLength += accounts.length;\n                }\n                if (totalLength == 0) {\n                    return EMPTY_ACCOUNT_ARRAY;\n                }\n                accountsArray = new Account[totalLength];\n                totalLength = 0;\n                for (Account[] accountsOfType : userAccounts.accountCache.values()) {\n                    System.arraycopy(accountsOfType, 0, accountsArray, totalLength,\n                            accountsOfType.length);\n                    totalLength += accountsOfType.length;\n                }\n            }\n            return filterAccounts(userAccounts, accountsArray, callingUid, callingPackage,\n                    includeManagedNotVisible);\n        }\n    }\n\n    /** protected by the {@code dbLock}, {@code cacheLock} */\n    protected void writeUserDataIntoCacheLocked(UserAccounts accounts,\n            Account account, String key, String value) {\n        Map<String, String> userDataForAccount = accounts.userDataCache.get(account);\n        if (userDataForAccount == null) {\n            userDataForAccount = accounts.accountsDb.findUserExtrasForAccount(account);\n            accounts.userDataCache.put(account, userDataForAccount);\n        }\n        if (value == null) {\n            userDataForAccount.remove(key);\n        } else {\n            userDataForAccount.put(key, value);\n        }\n    }\n\n    protected String readCachedTokenInternal(\n            UserAccounts accounts,\n            Account account,\n            String tokenType,\n            String callingPackage,\n            byte[] pkgSigDigest) {\n        synchronized (accounts.cacheLock) {\n            return accounts.accountTokenCaches.get(\n                    account, tokenType, callingPackage, pkgSigDigest);\n        }\n    }\n\n    /** protected by the {@code dbLock}, {@code cacheLock} */\n    protected void writeAuthTokenIntoCacheLocked(UserAccounts accounts,\n            Account account, String key, String value) {\n        Map<String, String> authTokensForAccount = accounts.authTokenCache.get(account);\n        if (authTokensForAccount == null) {\n            authTokensForAccount = accounts.accountsDb.findAuthTokensByAccount(account);\n            accounts.authTokenCache.put(account, authTokensForAccount);\n        }\n        if (value == null) {\n            authTokensForAccount.remove(key);\n        } else {\n            authTokensForAccount.put(key, value);\n        }\n    }\n\n    protected String readAuthTokenInternal(UserAccounts accounts, Account account,\n            String authTokenType) {\n        // Fast path - check if account is already cached\n        synchronized (accounts.cacheLock) {\n            Map<String, String> authTokensForAccount = accounts.authTokenCache.get(account);\n            if (authTokensForAccount != null) {\n                return authTokensForAccount.get(authTokenType);\n            }\n        }\n        // If not cached yet - do slow path and sync with db if necessary\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                Map<String, String> authTokensForAccount = accounts.authTokenCache.get(account);\n                if (authTokensForAccount == null) {\n                    // need to populate the cache for this account\n                    authTokensForAccount = accounts.accountsDb.findAuthTokensByAccount(account);\n                    accounts.authTokenCache.put(account, authTokensForAccount);\n                }\n                return authTokensForAccount.get(authTokenType);\n            }\n        }\n    }\n\n    private String readUserDataInternal(UserAccounts accounts, Account account, String key) {\n        Map<String, String> userDataForAccount;\n        // Fast path - check if data is already cached\n        synchronized (accounts.cacheLock) {\n            userDataForAccount = accounts.userDataCache.get(account);\n        }\n        // If not cached yet - do slow path and sync with db if necessary\n        if (userDataForAccount == null) {\n            synchronized (accounts.dbLock) {\n                synchronized (accounts.cacheLock) {\n                    userDataForAccount = accounts.userDataCache.get(account);\n                    if (userDataForAccount == null) {\n                        // need to populate the cache for this account\n                        userDataForAccount = accounts.accountsDb.findUserExtrasForAccount(account);\n                        accounts.userDataCache.put(account, userDataForAccount);\n                    }\n                }\n            }\n        }\n        return userDataForAccount.get(key);\n    }\n\n    private Context getContextForUser(UserHandle user) {\n        try {\n            return mContext.createPackageContextAsUser(mContext.getPackageName(), 0, user);\n        } catch (NameNotFoundException e) {\n            // Default to mContext, not finding the package system is running as is unlikely.\n            return mContext;\n        }\n    }\n\n    private void sendResponse(IAccountManagerResponse response, Bundle result) {\n        try {\n            response.onResult(result);\n        } catch (RemoteException e) {\n            // if the caller is dead then there is no one to care about remote\n            // exceptions\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"failure while notifying response\", e);\n            }\n        }\n    }\n\n    private void sendErrorResponse(IAccountManagerResponse response, int errorCode,\n            String errorMessage) {\n        try {\n            response.onError(errorCode, errorMessage);\n        } catch (RemoteException e) {\n            // if the caller is dead then there is no one to care about remote\n            // exceptions\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"failure while notifying response\", e);\n            }\n        }\n    }\n\n    private final class AccountManagerInternalImpl extends AccountManagerInternal {\n        private final Object mLock = new Object();\n\n        @GuardedBy(\"mLock\")\n        private AccountManagerBackupHelper mBackupHelper;\n\n        @Override\n        public void requestAccountAccess(@NonNull Account account, @NonNull String packageName,\n                @IntRange(from = 0) int userId, @NonNull RemoteCallback callback) {\n            if (account == null) {\n                Slog.w(TAG, \"account cannot be null\");\n                return;\n            }\n            if (packageName == null) {\n                Slog.w(TAG, \"packageName cannot be null\");\n                return;\n            }\n            if (userId < UserHandle.USER_SYSTEM) {\n                Slog.w(TAG, \"user id must be concrete\");\n                return;\n            }\n            if (callback == null) {\n                Slog.w(TAG, \"callback cannot be null\");\n                return;\n            }\n\n            int visibility =\n                resolveAccountVisibility(account, packageName, getUserAccounts(userId));\n            if (visibility == AccountManager.VISIBILITY_NOT_VISIBLE) {\n                Slog.w(TAG, \"requestAccountAccess: account is hidden\");\n                return;\n            }\n\n            if (AccountManagerService.this.hasAccountAccess(account, packageName,\n                    new UserHandle(userId))) {\n                Bundle result = new Bundle();\n                result.putBoolean(AccountManager.KEY_BOOLEAN_RESULT, true);\n                callback.sendResult(result);\n                return;\n            }\n\n            final int uid;\n            try {\n                final long identityToken = clearCallingIdentity();\n                try {\n                    uid = mPackageManager.getPackageUidAsUser(packageName, userId);\n                } finally {\n                    restoreCallingIdentity(identityToken);\n                }\n            } catch (NameNotFoundException e) {\n                Slog.e(TAG, \"Unknown package \" + packageName);\n                return;\n            }\n\n            Intent intent = newRequestAccountAccessIntent(account, packageName, uid, callback);\n            final UserAccounts userAccounts;\n            synchronized (mUsers) {\n                userAccounts = mUsers.get(userId);\n            }\n            SystemNotificationChannels.createAccountChannelForPackage(packageName, uid, mContext);\n            doNotification(userAccounts, account, null, intent, packageName, userId);\n        }\n\n        @Override\n        public void addOnAppPermissionChangeListener(OnAppPermissionChangeListener listener) {\n            // Listeners are a final CopyOnWriteArrayList, hence no lock needed.\n            mAppPermissionChangeListeners.add(listener);\n        }\n\n        @Override\n        public boolean hasAccountAccess(@NonNull Account account, @IntRange(from = 0) int uid) {\n            return AccountManagerService.this.hasAccountAccess(account, null, uid);\n        }\n\n        @Override\n        public byte[] backupAccountAccessPermissions(int userId) {\n            synchronized (mLock) {\n                if (mBackupHelper == null) {\n                    mBackupHelper = new AccountManagerBackupHelper(\n                            AccountManagerService.this, this);\n                }\n                return mBackupHelper.backupAccountAccessPermissions(userId);\n            }\n        }\n\n        @Override\n        public void restoreAccountAccessPermissions(byte[] data, int userId) {\n            synchronized (mLock) {\n                if (mBackupHelper == null) {\n                    mBackupHelper = new AccountManagerBackupHelper(\n                            AccountManagerService.this, this);\n                }\n                mBackupHelper.restoreAccountAccessPermissions(data, userId);\n            }\n        }\n    }\n\n    @VisibleForTesting\n    static class Injector {\n        private final Context mContext;\n\n        public Injector(Context context) {\n            mContext = context;\n        }\n\n        Looper getMessageHandlerLooper() {\n            ServiceThread serviceThread = new ServiceThread(TAG,\n                    android.os.Process.THREAD_PRIORITY_FOREGROUND, true /* allowIo */);\n            serviceThread.start();\n            return serviceThread.getLooper();\n        }\n\n        Context getContext() {\n            return mContext;\n        }\n\n        void addLocalService(AccountManagerInternal service) {\n            LocalServices.addService(AccountManagerInternal.class, service);\n        }\n\n        String getDeDatabaseName(int userId) {\n            File databaseFile = new File(Environment.getDataSystemDeDirectory(userId),\n                    AccountsDb.DE_DATABASE_NAME);\n            return databaseFile.getPath();\n        }\n\n        String getCeDatabaseName(int userId) {\n            File databaseFile = new File(Environment.getDataSystemCeDirectory(userId),\n                    AccountsDb.CE_DATABASE_NAME);\n            return databaseFile.getPath();\n        }\n\n        String getPreNDatabaseName(int userId) {\n            File systemDir = Environment.getDataSystemDirectory();\n            File databaseFile = new File(Environment.getUserSystemDirectory(userId),\n                    PRE_N_DATABASE_NAME);\n            if (userId == 0) {\n                // Migrate old file, if it exists, to the new location.\n                // Make sure the new file doesn't already exist. A placeholder file could have been\n                // accidentally created in the old location,\n                // causing the new one to become corrupted as well.\n                File oldFile = new File(systemDir, PRE_N_DATABASE_NAME);\n                if (oldFile.exists() && !databaseFile.exists()) {\n                    // Check for use directory; create if it doesn't exist, else renameTo will fail\n                    File userDir = Environment.getUserSystemDirectory(userId);\n                    if (!userDir.exists()) {\n                        if (!userDir.mkdirs()) {\n                            throw new IllegalStateException(\n                                    \"User dir cannot be created: \" + userDir);\n                        }\n                    }\n                    if (!oldFile.renameTo(databaseFile)) {\n                        throw new IllegalStateException(\n                                \"User dir cannot be migrated: \" + databaseFile);\n                    }\n                }\n            }\n            return databaseFile.getPath();\n        }\n\n        IAccountAuthenticatorCache getAccountAuthenticatorCache() {\n            return new AccountAuthenticatorCache(mContext);\n        }\n\n        INotificationManager getNotificationManager() {\n            return NotificationManager.getService();\n        }\n    }\n\n    private static class NotificationId {\n        final String mTag;\n        private final int mId;\n\n        NotificationId(String tag, int type) {\n            mTag = tag;\n            mId = type;\n        }\n    }\n}\n```"
                    }
                ]
            }
        ],
        "upstream_patch_content": "From cde345a7ee06db716e613e12a2c218ce248ad1c4 Mon Sep 17 00:00:00 2001\nFrom: Dmitry Dementyev <dementyev@google.com>\nDate: Tue, 1 Oct 2024 14:57:44 -0700\nSubject: [PATCH] Update checkKeyIntent\n\n1) Explicityly set  component after target activity check.\n2) Update Intent subclass check.\n\nBug: 360846772\nTest: manual\nFlag: EXEMPT bugfix\nChange-Id: Ied7961c73299681aa5b523cf3f00fd905893116f\n---\n .../android/server/accounts/AccountManagerService.java   | 9 ++++++---\n 1 file changed, 6 insertions(+), 3 deletions(-)\n\ndiff --git a/services/core/java/com/android/server/accounts/AccountManagerService.java b/services/core/java/com/android/server/accounts/AccountManagerService.java\nindex 3499a3a5edde..0ca3b56486e3 100644\n--- a/services/core/java/com/android/server/accounts/AccountManagerService.java\n+++ b/services/core/java/com/android/server/accounts/AccountManagerService.java\n@@ -5062,6 +5062,8 @@ public class AccountManagerService\n                     Log.e(TAG, String.format(tmpl, activityName, pkgName, mAccountType));\n                     return false;\n                 }\n+                intent.setComponent(targetActivityInfo.getComponentName());\n+                bundle.putParcelable(AccountManager.KEY_INTENT, intent);\n                 return true;\n             } finally {\n                 Binder.restoreCallingIdentity(bid);\n@@ -5083,14 +5085,15 @@ public class AccountManagerService\n             Bundle simulateBundle = p.readBundle();\n             p.recycle();\n             Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT, Intent.class);\n-            if (intent != null && intent.getClass() != Intent.class) {\n-                return false;\n-            }\n             Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT,\n                     Intent.class);\n             if (intent == null) {\n                 return (simulateIntent == null);\n             }\n+            if (intent.getClass() != Intent.class || simulateIntent.getClass() != Intent.class) {\n+                return false;\n+            }\n+\n             if (!intent.filterEquals(simulateIntent)) {\n                 return false;\n             }\n-- \n2.39.5 (Apple Git-154)\n\n",
        "upstream_commits": [
            "cde345a7ee06db716e613e12a2c218ce248ad1c4"
        ]
    },
    {
        "id": "ASB-A-281533566",
        "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-281533566",
        "severity": "High",
        "failures": [
            {
                "downstream_version": "12",
                "branch_used": "android12-release",
                "downstream_patch": "73fa082a7202100da107ae14dd7742ecd86da053",
                "repo_path": "android_repos/base",
                "result": "failure",
                "downstream_patch_content": "commit 73fa082a7202100da107ae14dd7742ecd86da053\nAuthor: Tim Yu <yunicorn@google.com>\nDate:   Tue Jun 20 21:24:36 2023 +0000\n\n    [DO NOT MERGE] Verify URI Permissions in Autofill RemoteViews\n    \n    Check permissions of URI inside of FillResponse's RemoteViews. If the\n    current user does not have the required permissions to view the URI, the\n    RemoteView is dropped from displaying.\n    \n    This fixes a security spill in which a user can view content of another\n    user through a malicious Autofill provider.\n    \n    Bug: 283137865\n    Fixes: b/283264674 b/281666022 b/281665050 b/281848557 b/281533566\n    b/281534749 b/283101289\n    Test: Verified by POC app attached in bugs\n    Test: atest CtsAutoFillServiceTestCases (added new tests)\n    Change-Id: I6f4d2a35e89bbed7bd9e07bf5cd3e2d68b20af9a\n\ndiff --git a/services/autofill/java/com/android/server/autofill/Helper.java b/services/autofill/java/com/android/server/autofill/Helper.java\nindex bc5d6457c945..48113a81cca5 100644\n--- a/services/autofill/java/com/android/server/autofill/Helper.java\n+++ b/services/autofill/java/com/android/server/autofill/Helper.java\n@@ -18,6 +18,8 @@ package com.android.server.autofill;\n \n import android.annotation.NonNull;\n import android.annotation.Nullable;\n+import android.annotation.UserIdInt;\n+import android.app.ActivityManager;\n import android.app.assist.AssistStructure;\n import android.app.assist.AssistStructure.ViewNode;\n import android.app.assist.AssistStructure.WindowNode;\n@@ -34,6 +36,7 @@ import android.view.View;\n import android.view.WindowManager;\n import android.view.autofill.AutofillId;\n import android.view.autofill.AutofillValue;\n+import android.widget.RemoteViews;\n \n import com.android.internal.logging.nano.MetricsProto.MetricsEvent;\n import com.android.internal.util.ArrayUtils;\n@@ -42,6 +45,8 @@ import java.io.PrintWriter;\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n \n public final class Helper {\n \n@@ -75,6 +80,44 @@ public final class Helper {\n         throw new UnsupportedOperationException(\"contains static members only\");\n     }\n \n+    private static boolean checkRemoteViewUriPermissions(\n+            @UserIdInt int userId, @NonNull RemoteViews rView) {\n+        final AtomicBoolean permissionsOk = new AtomicBoolean(true);\n+\n+        rView.visitUris(uri -> {\n+            int uriOwnerId = android.content.ContentProvider.getUserIdFromUri(uri);\n+            boolean allowed = uriOwnerId == userId;\n+            permissionsOk.set(allowed && permissionsOk.get());\n+        });\n+\n+        return permissionsOk.get();\n+    }\n+\n+    /**\n+     * Checks the URI permissions of the remote view,\n+     * to see if the current userId is able to access it.\n+     *\n+     * Returns the RemoteView that is passed if user is able, null otherwise.\n+     *\n+     * TODO: instead of returning a null remoteview when\n+     * the current userId cannot access an URI,\n+     * return a new RemoteView with the URI removed.\n+     */\n+    public static @Nullable RemoteViews sanitizeRemoteView(RemoteViews rView) {\n+        if (rView == null) return null;\n+\n+        int userId = ActivityManager.getCurrentUser();\n+\n+        boolean ok = checkRemoteViewUriPermissions(userId, rView);\n+        if (!ok) {\n+            Slog.w(TAG,\n+                    \"sanitizeRemoteView() user: \" + userId\n+                    + \" tried accessing resource that does not belong to them\");\n+        }\n+        return (ok ? rView : null);\n+    }\n+\n+\n     @Nullable\n     static AutofillId[] toArray(@Nullable ArraySet<AutofillId> set) {\n         if (set == null) return null;\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/FillUi.java b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\nindex 27ea3d618afa..af6e38b1d46c 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n@@ -141,8 +141,9 @@ final class FillUi {\n \n         final LayoutInflater inflater = LayoutInflater.from(mContext);\n \n-        final RemoteViews headerPresentation = response.getHeader();\n-        final RemoteViews footerPresentation = response.getFooter();\n+        final RemoteViews headerPresentation = Helper.sanitizeRemoteView(response.getHeader());\n+        final RemoteViews footerPresentation = Helper.sanitizeRemoteView(response.getFooter());\n+\n         final ViewGroup decor;\n         if (mFullScreen) {\n             decor = (ViewGroup) inflater.inflate(R.layout.autofill_dataset_picker_fullscreen, null);\n@@ -220,6 +221,9 @@ final class FillUi {\n             ViewGroup container = decor.findViewById(R.id.autofill_dataset_picker);\n             final View content;\n             try {\n+                if (Helper.sanitizeRemoteView(response.getPresentation()) == null) {\n+                    throw new RuntimeException(\"Permission error accessing RemoteView\");\n+                }\n                 content = response.getPresentation().applyWithTheme(\n                         mContext, decor, interceptionHandler, mThemeId);\n                 container.addView(content);\n@@ -299,7 +303,8 @@ final class FillUi {\n                 final Dataset dataset = response.getDatasets().get(i);\n                 final int index = dataset.getFieldIds().indexOf(focusedViewId);\n                 if (index >= 0) {\n-                    final RemoteViews presentation = dataset.getFieldPresentation(index);\n+                    final RemoteViews presentation = Helper.sanitizeRemoteView(\n+                            dataset.getFieldPresentation(index));\n                     if (presentation == null) {\n                         Slog.w(TAG, \"not displaying UI on field \" + focusedViewId + \" because \"\n                                 + \"service didn't provide a presentation for it on \" + dataset);\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\nindex 826a98afe2f8..49df4a8b66ed 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n@@ -368,8 +368,7 @@ final class SaveUi {\n             return false;\n         }\n         writeLog(MetricsEvent.AUTOFILL_SAVE_CUSTOM_DESCRIPTION);\n-\n-        final RemoteViews template = customDescription.getPresentation();\n+        final RemoteViews template = Helper.sanitizeRemoteView(customDescription.getPresentation());\n         if (template == null) {\n             Slog.w(TAG, \"No remote view on custom description\");\n             return false;\n",
                "file_conflicts": []
            },
            {
                "downstream_version": "12L",
                "branch_used": "android12L-release",
                "downstream_patch": "f7ca136c514dc975c3f46d95c53fd6b3752c577a",
                "repo_path": "android_repos/base",
                "result": "failure",
                "downstream_patch_content": "commit f7ca136c514dc975c3f46d95c53fd6b3752c577a\nAuthor: Tim Yu <yunicorn@google.com>\nDate:   Tue Jun 20 21:24:36 2023 +0000\n\n    [DO NOT MERGE] Verify URI Permissions in Autofill RemoteViews\n    \n    Check permissions of URI inside of FillResponse's RemoteViews. If the\n    current user does not have the required permissions to view the URI, the\n    RemoteView is dropped from displaying.\n    \n    This fixes a security spill in which a user can view content of another\n    user through a malicious Autofill provider.\n    \n    Bug: 283137865\n    Fixes: b/283264674 b/281666022 b/281665050 b/281848557 b/281533566\n    b/281534749 b/283101289\n    Test: Verified by POC app attached in bugs\n    Test: atest CtsAutoFillServiceTestCases (added new tests)\n    Change-Id: I6f4d2a35e89bbed7bd9e07bf5cd3e2d68b20af9a\n\ndiff --git a/services/autofill/java/com/android/server/autofill/Helper.java b/services/autofill/java/com/android/server/autofill/Helper.java\nindex bc5d6457c945..48113a81cca5 100644\n--- a/services/autofill/java/com/android/server/autofill/Helper.java\n+++ b/services/autofill/java/com/android/server/autofill/Helper.java\n@@ -18,6 +18,8 @@ package com.android.server.autofill;\n \n import android.annotation.NonNull;\n import android.annotation.Nullable;\n+import android.annotation.UserIdInt;\n+import android.app.ActivityManager;\n import android.app.assist.AssistStructure;\n import android.app.assist.AssistStructure.ViewNode;\n import android.app.assist.AssistStructure.WindowNode;\n@@ -34,6 +36,7 @@ import android.view.View;\n import android.view.WindowManager;\n import android.view.autofill.AutofillId;\n import android.view.autofill.AutofillValue;\n+import android.widget.RemoteViews;\n \n import com.android.internal.logging.nano.MetricsProto.MetricsEvent;\n import com.android.internal.util.ArrayUtils;\n@@ -42,6 +45,8 @@ import java.io.PrintWriter;\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n \n public final class Helper {\n \n@@ -75,6 +80,44 @@ public final class Helper {\n         throw new UnsupportedOperationException(\"contains static members only\");\n     }\n \n+    private static boolean checkRemoteViewUriPermissions(\n+            @UserIdInt int userId, @NonNull RemoteViews rView) {\n+        final AtomicBoolean permissionsOk = new AtomicBoolean(true);\n+\n+        rView.visitUris(uri -> {\n+            int uriOwnerId = android.content.ContentProvider.getUserIdFromUri(uri);\n+            boolean allowed = uriOwnerId == userId;\n+            permissionsOk.set(allowed && permissionsOk.get());\n+        });\n+\n+        return permissionsOk.get();\n+    }\n+\n+    /**\n+     * Checks the URI permissions of the remote view,\n+     * to see if the current userId is able to access it.\n+     *\n+     * Returns the RemoteView that is passed if user is able, null otherwise.\n+     *\n+     * TODO: instead of returning a null remoteview when\n+     * the current userId cannot access an URI,\n+     * return a new RemoteView with the URI removed.\n+     */\n+    public static @Nullable RemoteViews sanitizeRemoteView(RemoteViews rView) {\n+        if (rView == null) return null;\n+\n+        int userId = ActivityManager.getCurrentUser();\n+\n+        boolean ok = checkRemoteViewUriPermissions(userId, rView);\n+        if (!ok) {\n+            Slog.w(TAG,\n+                    \"sanitizeRemoteView() user: \" + userId\n+                    + \" tried accessing resource that does not belong to them\");\n+        }\n+        return (ok ? rView : null);\n+    }\n+\n+\n     @Nullable\n     static AutofillId[] toArray(@Nullable ArraySet<AutofillId> set) {\n         if (set == null) return null;\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/FillUi.java b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\nindex 27ea3d618afa..af6e38b1d46c 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n@@ -141,8 +141,9 @@ final class FillUi {\n \n         final LayoutInflater inflater = LayoutInflater.from(mContext);\n \n-        final RemoteViews headerPresentation = response.getHeader();\n-        final RemoteViews footerPresentation = response.getFooter();\n+        final RemoteViews headerPresentation = Helper.sanitizeRemoteView(response.getHeader());\n+        final RemoteViews footerPresentation = Helper.sanitizeRemoteView(response.getFooter());\n+\n         final ViewGroup decor;\n         if (mFullScreen) {\n             decor = (ViewGroup) inflater.inflate(R.layout.autofill_dataset_picker_fullscreen, null);\n@@ -220,6 +221,9 @@ final class FillUi {\n             ViewGroup container = decor.findViewById(R.id.autofill_dataset_picker);\n             final View content;\n             try {\n+                if (Helper.sanitizeRemoteView(response.getPresentation()) == null) {\n+                    throw new RuntimeException(\"Permission error accessing RemoteView\");\n+                }\n                 content = response.getPresentation().applyWithTheme(\n                         mContext, decor, interceptionHandler, mThemeId);\n                 container.addView(content);\n@@ -299,7 +303,8 @@ final class FillUi {\n                 final Dataset dataset = response.getDatasets().get(i);\n                 final int index = dataset.getFieldIds().indexOf(focusedViewId);\n                 if (index >= 0) {\n-                    final RemoteViews presentation = dataset.getFieldPresentation(index);\n+                    final RemoteViews presentation = Helper.sanitizeRemoteView(\n+                            dataset.getFieldPresentation(index));\n                     if (presentation == null) {\n                         Slog.w(TAG, \"not displaying UI on field \" + focusedViewId + \" because \"\n                                 + \"service didn't provide a presentation for it on \" + dataset);\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\nindex 826a98afe2f8..49df4a8b66ed 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n@@ -368,8 +368,7 @@ final class SaveUi {\n             return false;\n         }\n         writeLog(MetricsEvent.AUTOFILL_SAVE_CUSTOM_DESCRIPTION);\n-\n-        final RemoteViews template = customDescription.getPresentation();\n+        final RemoteViews template = Helper.sanitizeRemoteView(customDescription.getPresentation());\n         if (template == null) {\n             Slog.w(TAG, \"No remote view on custom description\");\n             return false;\n",
                "file_conflicts": []
            }
        ],
        "upstream_patch_content": "From bf7fbbccd920596e514d1559fb3feaca70e55e78 Mon Sep 17 00:00:00 2001\nFrom: Tim Yu <yunicorn@google.com>\nDate: Tue, 20 Jun 2023 21:24:36 +0000\nSubject: [PATCH] [DO NOT MERGE] Verify URI Permissions in Autofill RemoteViews\n\nCheck permissions of URI inside of FillResponse's RemoteViews. If the\ncurrent user does not have the required permissions to view the URI, the\nRemoteView is dropped from displaying.\n\nThis fixes a security spill in which a user can view content of another\nuser through a malicious Autofill provider.\n\nBug: 283137865\nFixes: b/283264674 b/281666022 b/281665050 b/281848557 b/281533566\nb/281534749 b/283101289\nTest: Verified by POC app attached in bugs\nTest: atest CtsAutoFillServiceTestCases (added new tests)\nChange-Id: I6f4d2a35e89bbed7bd9e07bf5cd3e2d68b20af9a\n---\n .../com/android/server/autofill/Helper.java   | 43 +++++++++++++++++++\n .../server/autofill/ui/DialogFillUi.java      | 12 ++++--\n .../android/server/autofill/ui/FillUi.java    | 11 +++--\n .../android/server/autofill/ui/SaveUi.java    |  3 +-\n 4 files changed, 60 insertions(+), 9 deletions(-)\n\ndiff --git a/services/autofill/java/com/android/server/autofill/Helper.java b/services/autofill/java/com/android/server/autofill/Helper.java\nindex 82af38200166..ad8f5e1481e1 100644\n--- a/services/autofill/java/com/android/server/autofill/Helper.java\n+++ b/services/autofill/java/com/android/server/autofill/Helper.java\n@@ -20,6 +20,8 @@ import static com.android.server.autofill.Helper.sDebug;\n \n import android.annotation.NonNull;\n import android.annotation.Nullable;\n+import android.annotation.UserIdInt;\n+import android.app.ActivityManager;\n import android.app.assist.AssistStructure;\n import android.app.assist.AssistStructure.ViewNode;\n import android.app.assist.AssistStructure.WindowNode;\n@@ -40,6 +42,7 @@ import android.view.View;\n import android.view.WindowManager;\n import android.view.autofill.AutofillId;\n import android.view.autofill.AutofillValue;\n+import android.widget.RemoteViews;\n \n import com.android.internal.logging.nano.MetricsProto.MetricsEvent;\n import com.android.internal.util.ArrayUtils;\n@@ -50,6 +53,8 @@ import java.lang.ref.WeakReference;\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n \n public final class Helper {\n \n@@ -83,6 +88,44 @@ public final class Helper {\n         throw new UnsupportedOperationException(\"contains static members only\");\n     }\n \n+    private static boolean checkRemoteViewUriPermissions(\n+            @UserIdInt int userId, @NonNull RemoteViews rView) {\n+        final AtomicBoolean permissionsOk = new AtomicBoolean(true);\n+\n+        rView.visitUris(uri -> {\n+            int uriOwnerId = android.content.ContentProvider.getUserIdFromUri(uri);\n+            boolean allowed = uriOwnerId == userId;\n+            permissionsOk.set(allowed & permissionsOk.get());\n+        });\n+\n+        return permissionsOk.get();\n+    }\n+\n+    /**\n+     * Checks the URI permissions of the remote view,\n+     * to see if the current userId is able to access it.\n+     *\n+     * Returns the RemoteView that is passed if user is able, null otherwise.\n+     *\n+     * TODO: instead of returning a null remoteview when\n+     * the current userId cannot access an URI,\n+     * return a new RemoteView with the URI removed.\n+     */\n+    public static @Nullable RemoteViews sanitizeRemoteView(RemoteViews rView) {\n+        if (rView == null) return null;\n+\n+        int userId = ActivityManager.getCurrentUser();\n+\n+        boolean ok = checkRemoteViewUriPermissions(userId, rView);\n+        if (!ok) {\n+            Slog.w(TAG,\n+                    \"sanitizeRemoteView() user: \" + userId\n+                    + \" tried accessing resource that does not belong to them\");\n+        }\n+        return (ok ? rView : null);\n+    }\n+\n+\n     @Nullable\n     static AutofillId[] toArray(@Nullable ArraySet<AutofillId> set) {\n         if (set == null) return null;\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java b/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java\nindex dbeb624bd202..fa414e3b172b 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/DialogFillUi.java\n@@ -53,6 +53,7 @@ import android.widget.TextView;\n \n import com.android.internal.R;\n import com.android.server.autofill.AutofillManagerService;\n+import com.android.server.autofill.Helper;\n \n import java.io.PrintWriter;\n import java.util.ArrayList;\n@@ -208,7 +209,8 @@ final class DialogFillUi {\n     }\n \n     private void setHeader(View decor, FillResponse response) {\n-        final RemoteViews presentation = response.getDialogHeader();\n+        final RemoteViews presentation =\n+                Helper.sanitizeRemoteView(response.getDialogHeader());\n         if (presentation == null) {\n             return;\n         }\n@@ -243,9 +245,10 @@ final class DialogFillUi {\n     }\n \n     private void initialAuthenticationLayout(View decor, FillResponse response) {\n-        RemoteViews presentation = response.getDialogPresentation();\n+        RemoteViews presentation = Helper.sanitizeRemoteView(\n+                response.getDialogPresentation());\n         if (presentation == null) {\n-            presentation = response.getPresentation();\n+            presentation = Helper.sanitizeRemoteView(response.getPresentation());\n         }\n         if (presentation == null) {\n             throw new RuntimeException(\"No presentation for fill dialog authentication\");\n@@ -289,7 +292,8 @@ final class DialogFillUi {\n             final Dataset dataset = response.getDatasets().get(i);\n             final int index = dataset.getFieldIds().indexOf(focusedViewId);\n             if (index >= 0) {\n-                RemoteViews presentation = dataset.getFieldDialogPresentation(index);\n+                RemoteViews presentation = Helper.sanitizeRemoteView(\n+                        dataset.getFieldDialogPresentation(index));\n                 if (presentation == null) {\n                     if (sDebug) {\n                         Slog.w(TAG, \"not displaying UI on field \" + focusedViewId + \" because \"\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/FillUi.java b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\nindex 129ce72e037d..cdfe7bb4f4a7 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/FillUi.java\n@@ -148,8 +148,9 @@ final class FillUi {\n \n         final LayoutInflater inflater = LayoutInflater.from(mContext);\n \n-        final RemoteViews headerPresentation = response.getHeader();\n-        final RemoteViews footerPresentation = response.getFooter();\n+        final RemoteViews headerPresentation = Helper.sanitizeRemoteView(response.getHeader());\n+        final RemoteViews footerPresentation = Helper.sanitizeRemoteView(response.getFooter());\n+\n         final ViewGroup decor;\n         if (mFullScreen) {\n             decor = (ViewGroup) inflater.inflate(R.layout.autofill_dataset_picker_fullscreen, null);\n@@ -227,6 +228,9 @@ final class FillUi {\n             ViewGroup container = decor.findViewById(R.id.autofill_dataset_picker);\n             final View content;\n             try {\n+                if (Helper.sanitizeRemoteView(response.getPresentation()) == null) {\n+                    throw new RuntimeException(\"Permission error accessing RemoteView\");\n+                }\n                 content = response.getPresentation().applyWithTheme(\n                         mContext, decor, interceptionHandler, mThemeId);\n                 container.addView(content);\n@@ -306,7 +310,8 @@ final class FillUi {\n                 final Dataset dataset = response.getDatasets().get(i);\n                 final int index = dataset.getFieldIds().indexOf(focusedViewId);\n                 if (index >= 0) {\n-                    final RemoteViews presentation = dataset.getFieldPresentation(index);\n+                    final RemoteViews presentation = Helper.sanitizeRemoteView(\n+                            dataset.getFieldPresentation(index));\n                     if (presentation == null) {\n                         Slog.w(TAG, \"not displaying UI on field \" + focusedViewId + \" because \"\n                                 + \"service didn't provide a presentation for it on \" + dataset);\ndiff --git a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\nindex f035d0764279..70382f1d5274 100644\n--- a/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n+++ b/services/autofill/java/com/android/server/autofill/ui/SaveUi.java\n@@ -384,8 +384,7 @@ final class SaveUi {\n             return false;\n         }\n         writeLog(MetricsEvent.AUTOFILL_SAVE_CUSTOM_DESCRIPTION);\n-\n-        final RemoteViews template = customDescription.getPresentation();\n+        final RemoteViews template = Helper.sanitizeRemoteView(customDescription.getPresentation());\n         if (template == null) {\n             Slog.w(TAG, \"No remote view on custom description\");\n             return false;\n-- \n2.39.5 (Apple Git-154)\n\n",
        "upstream_commits": [
            "bf7fbbccd920596e514d1559fb3feaca70e55e78"
        ]
    },
    {
        "id": "ASB-A-369351375",
        "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-369351375",
        "severity": "High",
        "failures": [
            {
                "downstream_version": "12",
                "branch_used": "android12-release",
                "downstream_patch": "185048041e6f9d43c38829c09965e7a4740d2a6a",
                "repo_path": "android_repos/base",
                "result": "failure",
                "downstream_patch_content": "commit 185048041e6f9d43c38829c09965e7a4740d2a6a\nAuthor: Dmitry Dementyev <dementyev@google.com>\nDate:   Wed Oct 16 15:01:59 2024 -0700\n\n    Update checkKeyIntent\n    \n    1) Explicityly set  component after target activity check.\n    2) Update Intent subclass check.\n    \n    Bug: 360846772\n    Test: manual\n    Flag: EXEMPT bugfix\n    \n    Merged-In: Ied7961c73299681aa5b523cf3f00fd905893116f\n    Change-Id: Iafc1e2260107f7ecc18c90ce12f8987b4fc76350\n\ndiff --git a/services/core/java/com/android/server/accounts/AccountManagerService.java b/services/core/java/com/android/server/accounts/AccountManagerService.java\nindex 36ffc40bf5f7..5f434ee267d4 100644\n--- a/services/core/java/com/android/server/accounts/AccountManagerService.java\n+++ b/services/core/java/com/android/server/accounts/AccountManagerService.java\n@@ -4916,6 +4916,8 @@ public class AccountManagerService\n                     Log.e(TAG, String.format(tmpl, activityName, pkgName, mAccountType));\n                     return false;\n                 }\n+                intent.setComponent(targetActivityInfo.getComponentName());\n+                bundle.putParcelable(AccountManager.KEY_INTENT, intent);\n                 return true;\n             } finally {\n                 Binder.restoreCallingIdentity(bid);\n@@ -4937,13 +4939,14 @@ public class AccountManagerService\n             Bundle simulateBundle = p.readBundle();\n             p.recycle();\n             Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT);\n-            if (intent != null && intent.getClass() != Intent.class) {\n-                return false;\n-            }\n             Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT);\n             if (intent == null) {\n                 return (simulateIntent == null);\n             }\n+            if (intent.getClass() != Intent.class || simulateIntent.getClass() != Intent.class) {\n+                return false;\n+            }\n+\n             if (!intent.filterEquals(simulateIntent)) {\n                 return false;\n             }\n",
                "file_conflicts": [
                    {
                        "file_name": "services/core/java/com/android/server/accounts/AccountManagerService.java",
                        "total_hunks": 2,
                        "failed_hunks": [
                            2
                        ],
                        "inline_merge_conflicts": [
                            {
                                "hunk_number": 1,
                                "merge_conflict": "<<<<<<< DOWNSTREAM (version 12)\n\n=======\n                return false;\n            }\n\n            if (!intent.filterEquals(simulateIntent)) {\n>>>>>>> UPSTREAM PATCH (commit cde345a7ee06db716e613e12a2c218ce248ad1c4)"
                            }
                        ],
                        "rej_file_content": "```diff\n--- services/core/java/com/android/server/accounts/AccountManagerService.java\n+++ services/core/java/com/android/server/accounts/AccountManagerService.java\n@@ -5085,14 +5087,15 @@ public class AccountManagerService\n             Bundle simulateBundle = p.readBundle();\n             p.recycle();\n             Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT, Intent.class);\n-            if (intent != null && intent.getClass() != Intent.class) {\n-                return false;\n-            }\n             Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT,\n                     Intent.class);\n             if (intent == null) {\n                 return (simulateIntent == null);\n             }\n+            if (intent.getClass() != Intent.class || simulateIntent.getClass() != Intent.class) {\n+                return false;\n+            }\n+\n             if (!intent.filterEquals(simulateIntent)) {\n                 return false;\n             }\n```",
                        "patch_apply_output": "patching file services/core/java/com/android/server/accounts/AccountManagerService.java\nHunk #1 succeeded at 4916 (offset -146 lines).\nHunk #2 FAILED at 5085.\n1 out of 2 hunks FAILED -- saving rejects to file services/core/java/com/android/server/accounts/AccountManagerService.java.rej",
                        "inline_merge_output": "patching file services/core/java/com/android/server/accounts/AccountManagerService.java\nHunk #1 already applied at 5065-5066.\nHunk #2 already applied at 5088, NOT MERGED at 5094-5100.",
                        "upstream_file_content": "```java\n/*\n * Copyright (C) 2009 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.server.accounts;\n\nimport android.Manifest;\nimport android.accounts.AbstractAccountAuthenticator;\nimport android.accounts.Account;\nimport android.accounts.AccountAndUser;\nimport android.accounts.AccountAuthenticatorResponse;\nimport android.accounts.AccountManager;\nimport android.accounts.AccountManagerInternal;\nimport android.accounts.AccountManagerResponse;\nimport android.accounts.AuthenticatorDescription;\nimport android.accounts.CantAddAccountActivity;\nimport android.accounts.ChooseAccountActivity;\nimport android.accounts.GrantCredentialsPermissionActivity;\nimport android.accounts.IAccountAuthenticator;\nimport android.accounts.IAccountAuthenticatorResponse;\nimport android.accounts.IAccountManager;\nimport android.accounts.IAccountManagerResponse;\nimport android.annotation.IntRange;\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.app.ActivityManager;\nimport android.app.ActivityThread;\nimport android.app.AppOpsManager;\nimport android.app.BroadcastOptions;\nimport android.app.INotificationManager;\nimport android.app.Notification;\nimport android.app.NotificationManager;\nimport android.app.PendingIntent;\nimport android.app.admin.DevicePolicyEventLogger;\nimport android.app.admin.DevicePolicyManager;\nimport android.app.admin.DevicePolicyManagerInternal;\nimport android.app.compat.CompatChanges;\nimport android.compat.annotation.ChangeId;\nimport android.compat.annotation.EnabledAfter;\nimport android.content.BroadcastReceiver;\nimport android.content.ClipData;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.IntentSender;\nimport android.content.ServiceConnection;\nimport android.content.pm.ActivityInfo;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.IPackageManager;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManager.NameNotFoundException;\nimport android.content.pm.PackageManagerInternal;\nimport android.content.pm.RegisteredServicesCache;\nimport android.content.pm.RegisteredServicesCacheListener;\nimport android.content.pm.ResolveInfo;\nimport android.content.pm.Signature;\nimport android.content.pm.SigningDetails.CertCapabilities;\nimport android.content.pm.UserInfo;\nimport android.database.Cursor;\nimport android.database.sqlite.SQLiteCantOpenDatabaseException;\nimport android.database.sqlite.SQLiteException;\nimport android.database.sqlite.SQLiteFullException;\nimport android.database.sqlite.SQLiteStatement;\nimport android.os.Binder;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Environment;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.Parcel;\nimport android.os.Parcelable;\nimport android.os.Process;\nimport android.os.RemoteCallback;\nimport android.os.RemoteException;\nimport android.os.ResultReceiver;\nimport android.os.ShellCallback;\nimport android.os.StrictMode;\nimport android.os.SystemClock;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.provider.Settings;\nimport android.stats.devicepolicy.DevicePolicyEnums;\nimport android.text.TextUtils;\nimport android.util.EventLog;\nimport android.util.Log;\nimport android.util.Pair;\nimport android.util.Slog;\nimport android.util.SparseArray;\nimport android.util.SparseBooleanArray;\n\nimport com.android.internal.R;\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.content.PackageMonitor;\nimport com.android.internal.messages.nano.SystemMessageProto.SystemMessage;\nimport com.android.internal.notification.SystemNotificationChannels;\nimport com.android.internal.util.ArrayUtils;\nimport com.android.internal.util.DumpUtils;\nimport com.android.internal.util.IndentingPrintWriter;\nimport com.android.internal.util.Preconditions;\nimport com.android.modules.expresslog.Histogram;\nimport com.android.server.LocalServices;\nimport com.android.server.ServiceThread;\nimport com.android.server.SystemService;\n\nimport com.google.android.collect.Lists;\nimport com.google.android.collect.Sets;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.PrintWriter;\nimport java.security.GeneralSecurityException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.concurrent.atomic.AtomicReference;\n\n/**\n * A system service that provides  account, password, and authtoken management for all\n * accounts on the device. Some of these calls are implemented with the help of the corresponding\n * {@link IAccountAuthenticator} services. This service is not accessed by users directly,\n * instead one uses an instance of {@link AccountManager}, which can be accessed as follows:\n *    AccountManager accountManager = AccountManager.get(context);\n * @hide\n */\npublic class AccountManagerService\n        extends IAccountManager.Stub\n        implements RegisteredServicesCacheListener<AuthenticatorDescription> {\n    private static final String TAG = \"AccountManagerService\";\n\n    public static class Lifecycle extends SystemService {\n        private AccountManagerService mService;\n\n        public Lifecycle(Context context) {\n            super(context);\n        }\n\n        @Override\n        public void onStart() {\n            mService = new AccountManagerService(new Injector(getContext()));\n            publishBinderService(Context.ACCOUNT_SERVICE, mService);\n        }\n\n        @Override\n        public void onUserUnlocking(@NonNull TargetUser user) {\n            mService.onUnlockUser(user.getUserIdentifier());\n        }\n\n        @Override\n        public void onUserStopped(@NonNull TargetUser user) {\n            Slog.i(TAG, \"onUserStopped \" + user);\n            mService.purgeUserData(user.getUserIdentifier());\n        }\n    }\n\n    final Context mContext;\n\n    private static final int[] INTERESTING_APP_OPS = new int[] {\n        AppOpsManager.OP_GET_ACCOUNTS,\n        AppOpsManager.OP_READ_CONTACTS,\n        AppOpsManager.OP_WRITE_CONTACTS,\n    };\n\n    private final PackageManager mPackageManager;\n    private final AppOpsManager mAppOpsManager;\n    private UserManager mUserManager;\n    private final Injector mInjector;\n\n    final MessageHandler mHandler;\n\n    private static final int TIMEOUT_DELAY_MS = 1000 * 60 * 15;\n    // Messages that can be sent on mHandler\n    private static final int MESSAGE_TIMED_OUT = 3;\n    private static final int MESSAGE_COPY_SHARED_ACCOUNT = 4;\n\n    private final IAccountAuthenticatorCache mAuthenticatorCache;\n    private static final String PRE_N_DATABASE_NAME = \"accounts.db\";\n    private static final Intent ACCOUNTS_CHANGED_INTENT;\n    private static final Bundle ACCOUNTS_CHANGED_OPTIONS = new BroadcastOptions()\n            .setDeliveryGroupPolicy(BroadcastOptions.DELIVERY_GROUP_POLICY_MOST_RECENT)\n            .toBundle();\n\n    private static final int SIGNATURE_CHECK_MISMATCH = 0;\n    private static final int SIGNATURE_CHECK_MATCH = 1;\n    private static final int SIGNATURE_CHECK_UID_MATCH = 2;\n\n    /**\n     * Apps targeting Android U and above need to declare the package visibility needs in the\n     * manifest to access the AccountManager APIs.\n     */\n    @ChangeId\n    @EnabledAfter(targetSdkVersion = Build.VERSION_CODES.TIRAMISU)\n    private static final long ENFORCE_PACKAGE_VISIBILITY_FILTERING = 154726397;\n\n    static {\n        ACCOUNTS_CHANGED_INTENT = new Intent(AccountManager.LOGIN_ACCOUNTS_CHANGED_ACTION);\n        ACCOUNTS_CHANGED_INTENT.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT\n                | Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);\n    }\n\n    private final LinkedHashMap<String, Session> mSessions = new LinkedHashMap<String, Session>();\n\n    static class UserAccounts {\n        private final int userId;\n        final AccountsDb accountsDb;\n        private final HashMap<Pair<Pair<Account, String>, Integer>, NotificationId>\n                credentialsPermissionNotificationIds = new HashMap<>();\n        private final HashMap<Account, NotificationId> signinRequiredNotificationIds\n                = new HashMap<>();\n        final Object cacheLock = new Object();\n        final Object dbLock = new Object(); // if needed, dbLock must be obtained before cacheLock\n        /** protected by the {@link #cacheLock} */\n        final HashMap<String, Account[]> accountCache = new LinkedHashMap<>();\n        /** protected by the {@link #cacheLock} */\n        private final Map<Account, Map<String, String>> userDataCache = new HashMap<>();\n        /** protected by the {@link #cacheLock} */\n        private final Map<Account, Map<String, String>> authTokenCache = new HashMap<>();\n        /** protected by the {@link #cacheLock} */\n        private final TokenCache accountTokenCaches = new TokenCache();\n        /** protected by the {@link #cacheLock} */\n        private final Map<Account, Map<String, Integer>> visibilityCache = new HashMap<>();\n\n        /** protected by the {@link #mReceiversForType},\n         *  type -> (packageName -> number of active receivers)\n         *  type == null is used to get notifications about all account types\n         */\n        private final Map<String, Map<String, Integer>> mReceiversForType = new HashMap<>();\n\n        /**\n         * protected by the {@link #cacheLock}\n         *\n         * Caches the previous names associated with an account. Previous names\n         * should be cached because we expect that when an Account is renamed,\n         * many clients will receive a LOGIN_ACCOUNTS_CHANGED broadcast and\n         * want to know if the accounts they care about have been renamed.\n         *\n         * The previous names are wrapped in an {@link AtomicReference} so that\n         * we can distinguish between those accounts with no previous names and\n         * those whose previous names haven't been cached (yet).\n         */\n        private final HashMap<Account, AtomicReference<String>> previousNameCache =\n                new HashMap<Account, AtomicReference<String>>();\n\n        UserAccounts(Context context, int userId, File preNDbFile, File deDbFile) {\n            this.userId = userId;\n            synchronized (dbLock) {\n                synchronized (cacheLock) {\n                    accountsDb = AccountsDb.create(context, userId, preNDbFile, deDbFile);\n                }\n            }\n        }\n    }\n\n    private final SparseArray<UserAccounts> mUsers = new SparseArray<>();\n    private final SparseBooleanArray mLocalUnlockedUsers = new SparseBooleanArray();\n    // Not thread-safe. Only use in synchronized context\n    private final SimpleDateFormat mDateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n    private CopyOnWriteArrayList<AccountManagerInternal.OnAppPermissionChangeListener>\n            mAppPermissionChangeListeners = new CopyOnWriteArrayList<>();\n\n    private static AtomicReference<AccountManagerService> sThis = new AtomicReference<>();\n    private static final Account[] EMPTY_ACCOUNT_ARRAY = new Account[]{};\n\n    private static Histogram sResponseLatency = new Histogram(\n            \"app.value_high_authenticator_response_latency\",\n            new Histogram.ScaledRangeOptions(20, 10000, 10000, 1.5f)\n    );\n\n    /**\n     * This should only be called by system code. One should only call this after the service\n     * has started.\n     * @return a reference to the AccountManagerService instance\n     * @hide\n     */\n    public static AccountManagerService getSingleton() {\n        return sThis.get();\n    }\n\n    public AccountManagerService(Injector injector) {\n        mInjector = injector;\n        mContext = injector.getContext();\n        mPackageManager = mContext.getPackageManager();\n        mAppOpsManager = mContext.getSystemService(AppOpsManager.class);\n        mHandler = new MessageHandler(injector.getMessageHandlerLooper());\n        mAuthenticatorCache = mInjector.getAccountAuthenticatorCache();\n        mAuthenticatorCache.setListener(this, mHandler);\n\n        sThis.set(this);\n\n        IntentFilter intentFilter = new IntentFilter();\n        intentFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);\n        intentFilter.addDataScheme(\"package\");\n        mContext.registerReceiver(new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context1, Intent intent) {\n                // Don't delete accounts when updating a authenticator's\n                // package.\n                if (!intent.getBooleanExtra(Intent.EXTRA_REPLACING, false)) {\n                    /* Purging data requires file io, don't block the main thread. This is probably\n                     * less than ideal because we are introducing a race condition where old grants\n                     * could be exercised until they are purged. But that race condition existed\n                     * anyway with the broadcast receiver.\n                     *\n                     * Ideally, we would completely clear the cache, purge data from the database,\n                     * and then rebuild the cache. All under the cache lock. But that change is too\n                     * large at this point.\n                     */\n                    final String removedPackageName = intent.getData().getSchemeSpecificPart();\n                    Runnable purgingRunnable = new Runnable() {\n                        @Override\n                        public void run() {\n                            purgeOldGrantsAll();\n                            // Notify authenticator about removed app?\n                            removeVisibilityValuesForPackage(removedPackageName);\n                        }\n                    };\n                    mHandler.post(purgingRunnable);\n                }\n            }\n        }, intentFilter);\n\n        injector.addLocalService(new AccountManagerInternalImpl());\n\n        IntentFilter userFilter = new IntentFilter();\n        userFilter.addAction(Intent.ACTION_USER_REMOVED);\n        mContext.registerReceiverAsUser(new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                String action = intent.getAction();\n                if (Intent.ACTION_USER_REMOVED.equals(action)) {\n                    int userId = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, -1);\n                    if (userId < 1) return;\n                    Slog.i(TAG, \"User \" + userId + \" removed\");\n                    purgeUserData(userId);\n                }\n            }\n        }, UserHandle.ALL, userFilter, null, null);\n\n        // Need to cancel account request notifications if the update/install can access the account\n        new PackageMonitor() {\n            @Override\n            public void onPackageAdded(String packageName, int uid) {\n                // Called on a handler, and running as the system\n                try {\n                    UserAccounts accounts = getUserAccounts(UserHandle.getUserId(uid));\n                    cancelAccountAccessRequestNotificationIfNeeded(uid, true, accounts);\n                } catch (SQLiteCantOpenDatabaseException e) {\n                    Log.w(TAG, \"Can't read accounts database\", e);\n                    return;\n                }\n            }\n\n            @Override\n            public void onPackageUpdateFinished(String packageName, int uid) {\n                // Called on a handler, and running as the system\n                try {\n                    UserAccounts accounts = getUserAccounts(UserHandle.getUserId(uid));\n                    cancelAccountAccessRequestNotificationIfNeeded(uid, true, accounts);\n                } catch (SQLiteCantOpenDatabaseException e) {\n                    Log.w(TAG, \"Can't read accounts database\", e);\n                    return;\n                }\n            }\n        }.register(mContext, mHandler.getLooper(), UserHandle.ALL, true);\n\n        // Cancel account request notification if an app op was preventing the account access\n        for (int i = 0; i < INTERESTING_APP_OPS.length; ++i) {\n            mAppOpsManager.startWatchingMode(INTERESTING_APP_OPS[i], null,\n                    new OnInterestingAppOpChangedListener());\n        }\n\n        // Clear the accounts cache on permission changes.\n        // The specific permissions we care about are backed by AppOps, so just\n        // let the change events on those handle clearing any notifications.\n        mPackageManager.addOnPermissionsChangeListener((int uid) -> {\n            AccountManager.invalidateLocalAccountsDataCaches();\n        });\n    }\n\n    private class OnInterestingAppOpChangedListener\n            extends AppOpsManager.OnOpChangedInternalListener {\n        @Override\n        public void onOpChanged(int op, String packageName) {\n            final int userId = ActivityManager.getCurrentUser();\n            final int packageUid;\n            try {\n                packageUid = mPackageManager.getPackageUidAsUser(packageName, userId);\n            } catch (NameNotFoundException e) {\n                /* ignore */\n                return;\n            }\n\n            final int mode = mAppOpsManager.checkOpNoThrow(op, packageUid, packageName);\n            if (mode != AppOpsManager.MODE_ALLOWED) {\n                return;\n            }\n\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                cancelAccountAccessRequestNotificationIfNeeded(\n                        packageName, packageUid, true, getUserAccounts(userId));\n            } catch (SQLiteCantOpenDatabaseException e) {\n                Log.w(TAG, \"Can't read accounts database\", e);\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        }\n    }\n\n    boolean getBindInstantServiceAllowed(int userId) {\n        return  mAuthenticatorCache.getBindInstantServiceAllowed(userId);\n    }\n\n    void setBindInstantServiceAllowed(int userId, boolean allowed) {\n        mAuthenticatorCache.setBindInstantServiceAllowed(userId, allowed);\n    }\n\n    private void cancelAccountAccessRequestNotificationIfNeeded(int uid,\n            boolean checkAccess, UserAccounts userAccounts) {\n        Account[] accounts = getAccountsOrEmptyArray(null, UserHandle.getUserId(uid), \"android\");\n        for (Account account : accounts) {\n            cancelAccountAccessRequestNotificationIfNeeded(account, uid, checkAccess, userAccounts);\n        }\n    }\n\n    private void cancelAccountAccessRequestNotificationIfNeeded(String packageName, int uid,\n            boolean checkAccess, UserAccounts userAccounts) {\n        Account[] accounts = getAccountsOrEmptyArray(null, UserHandle.getUserId(uid), \"android\");\n        for (Account account : accounts) {\n            cancelAccountAccessRequestNotificationIfNeeded(account,\n                    uid, packageName, checkAccess, userAccounts);\n        }\n    }\n\n    private void cancelAccountAccessRequestNotificationIfNeeded(Account account, int uid,\n            boolean checkAccess, UserAccounts accounts) {\n        String[] packageNames = mPackageManager.getPackagesForUid(uid);\n        if (packageNames != null) {\n            for (String packageName : packageNames) {\n                cancelAccountAccessRequestNotificationIfNeeded(account, uid,\n                        packageName, checkAccess, accounts);\n            }\n        }\n    }\n\n    private void cancelAccountAccessRequestNotificationIfNeeded(Account account,\n            int uid, String packageName, boolean checkAccess, UserAccounts accounts) {\n        if (!checkAccess || hasAccountAccess(account, packageName,\n                UserHandle.getUserHandleForUid(uid))) {\n            cancelNotification(getCredentialPermissionNotificationId(account,\n                    AccountManager.ACCOUNT_ACCESS_TOKEN_TYPE, uid, accounts),\n                    accounts);\n        }\n    }\n\n    @Override\n    public boolean addAccountExplicitlyWithVisibility(Account account, String password,\n            Bundle extras, Map packageToVisibility, String opPackageName) {\n        Bundle.setDefusable(extras, true);\n        int callingUid = Binder.getCallingUid();\n        int userId = UserHandle.getCallingUserId();\n        Objects.requireNonNull(account, \"account cannot be null\");\n        Log.v(TAG, \"addAccountExplicitly: caller's uid=\" + callingUid + \", pid=\"\n                + Binder.getCallingPid() + \", packageName=\" + opPackageName + \", accountType=\"\n                + account.type);\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\"uid=%s, package=%s cannot explicitly add \"\n                    + \"accounts of type: %s\", callingUid, opPackageName, account.type);\n            throw new SecurityException(msg);\n        }\n        /*\n         * Child users are not allowed to add accounts. Only the accounts that are shared by the\n         * parent profile can be added to child profile.\n         *\n         * TODO: Only allow accounts that were shared to be added by a limited user.\n         */\n        // fails if the account already exists\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return addAccountInternal(accounts, account, password, extras, callingUid,\n                    (Map<String, Integer>) packageToVisibility, opPackageName);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public Map<Account, Integer> getAccountsAndVisibilityForPackage(String packageName,\n            String accountType) {\n        int callingUid = Binder.getCallingUid();\n        int userId = UserHandle.getCallingUserId();\n        boolean isSystemUid = UserHandle.isSameApp(callingUid, Process.SYSTEM_UID);\n        List<String> managedTypes = getTypesForCaller(callingUid, userId, isSystemUid);\n\n        if ((accountType != null && !managedTypes.contains(accountType))\n                || (accountType == null && !isSystemUid)) {\n            throw new SecurityException(\n                    \"getAccountsAndVisibilityForPackage() called from unauthorized uid \"\n                            + callingUid + \" with packageName=\" + packageName);\n        }\n        if (accountType != null) {\n            managedTypes = new ArrayList<String>();\n            managedTypes.add(accountType);\n        }\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return getAccountsAndVisibilityForPackage(packageName, managedTypes, callingUid,\n                    accounts);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    /*\n     * accountTypes may not be null\n     */\n    private Map<Account, Integer> getAccountsAndVisibilityForPackage(String packageName,\n            List<String> accountTypes, Integer callingUid, UserAccounts accounts) {\n        if (!canCallerAccessPackage(packageName, callingUid, accounts.userId)) {\n            Log.w(TAG, \"getAccountsAndVisibilityForPackage#Package not found \" + packageName);\n            return new LinkedHashMap<>();\n        }\n\n        Map<Account, Integer> result = new LinkedHashMap<>();\n        for (String accountType : accountTypes) {\n            synchronized (accounts.dbLock) {\n                synchronized (accounts.cacheLock) {\n                    final Account[] accountsOfType = accounts.accountCache.get(accountType);\n                    if (accountsOfType != null) {\n                        for (Account account : accountsOfType) {\n                            result.put(account,\n                                    resolveAccountVisibility(account, packageName, accounts));\n                        }\n                    }\n                }\n            }\n        }\n        return filterSharedAccounts(accounts, result, callingUid, packageName);\n    }\n\n    @Override\n    public Map<String, Integer> getPackagesAndVisibilityForAccount(Account account) {\n        Objects.requireNonNull(account, \"account cannot be null\");\n        int callingUid = Binder.getCallingUid();\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)\n                && !isSystemUid(callingUid)) {\n            String msg =\n                    String.format(\"uid %s cannot get secrets for account %s\", callingUid, account);\n            throw new SecurityException(msg);\n        }\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            synchronized (accounts.dbLock) {\n                synchronized (accounts.cacheLock) {\n                    return getPackagesAndVisibilityForAccountLocked(account, accounts);\n                }\n            }\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n\n    }\n\n    /**\n     * Returns Map with all package names and visibility values for given account.\n     * The method and returned map must be guarded by accounts.cacheLock\n     *\n     * @param account Account to get visibility values.\n     * @param accounts UserAccount that currently hosts the account and application\n     *\n     * @return Map with cache for package names to visibility.\n     */\n    private @NonNull Map<String, Integer> getPackagesAndVisibilityForAccountLocked(Account account,\n            UserAccounts accounts) {\n        Map<String, Integer> accountVisibility = accounts.visibilityCache.get(account);\n        if (accountVisibility == null) {\n            Log.d(TAG, \"Visibility was not initialized\");\n            accountVisibility = new HashMap<>();\n            accounts.visibilityCache.put(account, accountVisibility);\n            AccountManager.invalidateLocalAccountsDataCaches();\n        }\n        return accountVisibility;\n    }\n\n    @Override\n    public int getAccountVisibility(Account account, String packageName) {\n        Objects.requireNonNull(account, \"account cannot be null\");\n        Objects.requireNonNull(packageName, \"packageName cannot be null\");\n        int callingUid = Binder.getCallingUid();\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)\n            && !isSystemUid(callingUid)) {\n            String msg = String.format(\n                    \"uid %s cannot get secrets for accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            if (AccountManager.PACKAGE_NAME_KEY_LEGACY_VISIBLE.equals(packageName)) {\n                int visibility = getAccountVisibilityFromCache(account, packageName, accounts);\n                if (AccountManager.VISIBILITY_UNDEFINED != visibility) {\n                    return visibility;\n                } else {\n                   return AccountManager.VISIBILITY_USER_MANAGED_VISIBLE;\n                }\n            }\n            if (AccountManager.PACKAGE_NAME_KEY_LEGACY_NOT_VISIBLE.equals(packageName)) {\n                int visibility = getAccountVisibilityFromCache(account, packageName, accounts);\n                if (AccountManager.VISIBILITY_UNDEFINED != visibility) {\n                    return visibility;\n                } else {\n                   return AccountManager.VISIBILITY_USER_MANAGED_NOT_VISIBLE;\n                }\n            }\n            if (!canCallerAccessPackage(packageName, callingUid, accounts.userId)) {\n                return AccountManager.VISIBILITY_NOT_VISIBLE;\n            }\n            return resolveAccountVisibility(account, packageName, accounts);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    /**\n     * Method returns visibility for given account and package name.\n     *\n     * @param account The account to check visibility.\n     * @param packageName Package name to check visibility.\n     * @param accounts UserAccount that currently hosts the account and application\n     *\n     * @return Visibility value, AccountManager.VISIBILITY_UNDEFINED if no value was stored.\n     *\n     */\n    private int getAccountVisibilityFromCache(Account account, String packageName,\n            UserAccounts accounts) {\n        synchronized (accounts.cacheLock) {\n            Map<String, Integer> accountVisibility =\n                    getPackagesAndVisibilityForAccountLocked(account, accounts);\n            Integer visibility = accountVisibility.get(packageName);\n            return visibility != null ? visibility : AccountManager.VISIBILITY_UNDEFINED;\n        }\n    }\n\n    /**\n     * Method which handles default values for Account visibility.\n     *\n     * @param account The account to check visibility.\n     * @param packageName Package name to check visibility\n     * @param accounts UserAccount that currently hosts the account and application\n     *\n     * @return Visibility value, the method never returns AccountManager.VISIBILITY_UNDEFINED\n     *\n     */\n    private Integer resolveAccountVisibility(Account account, @NonNull String packageName,\n            UserAccounts accounts) {\n        Objects.requireNonNull(packageName, \"packageName cannot be null\");\n        int uid = -1;\n        try {\n            final long identityToken = clearCallingIdentity();\n            try {\n                uid = mPackageManager.getPackageUidAsUser(packageName, accounts.userId);\n            } finally {\n                restoreCallingIdentity(identityToken);\n            }\n        } catch (NameNotFoundException e) {\n            Log.w(TAG, \"resolveAccountVisibility#Package not found \" + e.getMessage());\n            return AccountManager.VISIBILITY_NOT_VISIBLE;\n        }\n\n        // System visibility can not be restricted.\n        if (UserHandle.isSameApp(uid, Process.SYSTEM_UID)) {\n            return AccountManager.VISIBILITY_VISIBLE;\n        }\n\n        int signatureCheckResult =\n                checkPackageSignature(account.type, uid, accounts.userId);\n\n        // Authenticator can not restrict visibility to itself.\n        if (signatureCheckResult == SIGNATURE_CHECK_UID_MATCH) {\n            return AccountManager.VISIBILITY_VISIBLE; // Authenticator can always see the account\n        }\n\n        // Return stored value if it was set.\n        int visibility = getAccountVisibilityFromCache(account, packageName, accounts);\n\n        if (AccountManager.VISIBILITY_UNDEFINED != visibility) {\n            return visibility;\n        }\n\n        boolean isPrivileged = isPermittedForPackage(packageName, accounts.userId,\n                Manifest.permission.GET_ACCOUNTS_PRIVILEGED);\n\n        // Device/Profile owner gets visibility by default.\n        if (isProfileOwner(uid)) {\n            return AccountManager.VISIBILITY_VISIBLE;\n        }\n\n        boolean preO = isPreOApplication(packageName);\n        if ((signatureCheckResult != SIGNATURE_CHECK_MISMATCH)\n                || (preO && checkGetAccountsPermission(packageName, accounts.userId))\n                || (checkReadContactsPermission(packageName, accounts.userId)\n                    && accountTypeManagesContacts(account.type, accounts.userId))\n                || isPrivileged) {\n            // Use legacy for preO apps with GET_ACCOUNTS permission or pre/postO with signature\n            // match.\n            visibility = getAccountVisibilityFromCache(account,\n                    AccountManager.PACKAGE_NAME_KEY_LEGACY_VISIBLE, accounts);\n            if (AccountManager.VISIBILITY_UNDEFINED == visibility) {\n                visibility = AccountManager.VISIBILITY_USER_MANAGED_VISIBLE;\n            }\n        } else {\n            visibility = getAccountVisibilityFromCache(account,\n                    AccountManager.PACKAGE_NAME_KEY_LEGACY_NOT_VISIBLE, accounts);\n            if (AccountManager.VISIBILITY_UNDEFINED == visibility) {\n                visibility = AccountManager.VISIBILITY_USER_MANAGED_NOT_VISIBLE;\n            }\n        }\n        return visibility;\n    }\n\n    /**\n     * Checks targetSdk for a package;\n     *\n     * @param packageName Package name\n     *\n     * @return True if package's target SDK is below {@link android.os.Build.VERSION_CODES#O}, or\n     *         undefined\n     */\n    private boolean isPreOApplication(String packageName) {\n        try {\n            final long identityToken = clearCallingIdentity();\n            ApplicationInfo applicationInfo;\n            try {\n                applicationInfo = mPackageManager.getApplicationInfo(packageName, 0);\n            } finally {\n                restoreCallingIdentity(identityToken);\n            }\n\n            if (applicationInfo != null) {\n                int version = applicationInfo.targetSdkVersion;\n                return version < android.os.Build.VERSION_CODES.O;\n            }\n            return true;\n        } catch (NameNotFoundException e) {\n            Log.w(TAG, \"isPreOApplication#Package not found \" + e.getMessage());\n            return true;\n        }\n    }\n\n    @Override\n    public boolean setAccountVisibility(Account account, String packageName, int newVisibility) {\n        Objects.requireNonNull(account, \"account cannot be null\");\n        Objects.requireNonNull(packageName, \"packageName cannot be null\");\n        int callingUid = Binder.getCallingUid();\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)\n            && !isSystemUid(callingUid)) {\n            String msg = String.format(\n                    \"uid %s cannot get secrets for accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return setAccountVisibility(account, packageName, newVisibility, true /* notify */,\n                    accounts, callingUid);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private boolean isVisible(int visibility) {\n        return visibility == AccountManager.VISIBILITY_VISIBLE ||\n            visibility == AccountManager.VISIBILITY_USER_MANAGED_VISIBLE;\n    }\n\n    /**\n     * Updates visibility for given account name and package.\n     *\n     * @param account Account to update visibility.\n     * @param packageName Package name for which visibility is updated.\n     * @param newVisibility New visibility calue\n     * @param notify if the flag is set applications will get notification about visibility change\n     * @param accounts UserAccount that currently hosts the account and application\n     * @param callingUid The caller's uid.\n     *\n     * @return True if account visibility was changed.\n     */\n    private boolean setAccountVisibility(Account account, String packageName, int newVisibility,\n            boolean notify, UserAccounts accounts, int callingUid) {\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                Map<String, Integer> packagesToVisibility;\n                List<String> accountRemovedReceivers;\n                if (notify) {\n                    if (isSpecialPackageKey(packageName)) {\n                        packagesToVisibility =\n                                getRequestingPackages(account, accounts);\n                        accountRemovedReceivers = getAccountRemovedReceivers(account, accounts);\n                    } else {\n                        if (!canCallerAccessPackage(packageName, callingUid, accounts.userId)) {\n                            return false; // package is not installed or not visible.\n                        }\n                        packagesToVisibility = new HashMap<>();\n                        packagesToVisibility.put(packageName,\n                                resolveAccountVisibility(account, packageName, accounts));\n                        accountRemovedReceivers = new ArrayList<>();\n                        if (shouldNotifyPackageOnAccountRemoval(account, packageName, accounts)) {\n                            accountRemovedReceivers.add(packageName);\n                        }\n                    }\n                } else {\n                    // Notifications will not be send - only used during add account.\n                    if (!isSpecialPackageKey(packageName)\n                            && !canCallerAccessPackage(packageName, callingUid, accounts.userId)) {\n                        // package is not installed and not meta value.\n                        return false;\n                    }\n                    packagesToVisibility = Collections.emptyMap();\n                    accountRemovedReceivers = Collections.emptyList();\n                }\n                if (notify) {\n                    Integer oldVisibility =\n                            accounts.accountsDb.findAccountVisibility(account, packageName);\n                    if (oldVisibility != null && oldVisibility == newVisibility) {\n                        // Database will not be updated - skip LOGIN_ACCOUNTS_CHANGED broadcast.\n                        notify = false;\n                    }\n                }\n\n                if (!updateAccountVisibilityLocked(account, packageName, newVisibility, accounts)) {\n                    return false;\n                }\n\n                if (notify) {\n                    Log.i(TAG, \"Notifying visibility changed for package=\" + packageName);\n                    for (Entry<String, Integer> packageToVisibility : packagesToVisibility\n                            .entrySet()) {\n                        int oldVisibility = packageToVisibility.getValue();\n                        int currentVisibility =\n                            resolveAccountVisibility(account, packageName, accounts);\n                        if (isVisible(oldVisibility) != isVisible(currentVisibility)) {\n                            notifyPackage(packageToVisibility.getKey(), accounts);\n                        }\n                    }\n                    for (String packageNameToNotify : accountRemovedReceivers) {\n                        int currentVisibility =\n                                resolveAccountVisibility(account, packageNameToNotify, accounts);\n                        if (isVisible(currentVisibility)) {\n                            continue;\n                        }\n                        sendAccountRemovedBroadcast(\n                                account,\n                                packageNameToNotify,\n                                accounts.userId,\n                                /*useCase=*/\"setAccountVisibility\");\n                    }\n                    sendAccountsChangedBroadcast(\n                            accounts.userId, account.type, /*useCase=*/\"setAccountVisibility\");\n                }\n                return true;\n            }\n        }\n    }\n\n    // Update account visibility in cache and database.\n    private boolean updateAccountVisibilityLocked(Account account, String packageName,\n            int newVisibility, UserAccounts accounts) {\n        final long accountId = accounts.accountsDb.findDeAccountId(account);\n        if (accountId < 0) {\n            return false;\n        }\n\n        final StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskWrites();\n        try {\n            if (!accounts.accountsDb.setAccountVisibility(accountId, packageName,\n                    newVisibility)) {\n                return false;\n            }\n        } finally {\n            StrictMode.setThreadPolicy(oldPolicy);\n        }\n        Map<String, Integer> accountVisibility =\n            getPackagesAndVisibilityForAccountLocked(account, accounts);\n        accountVisibility.put(packageName, newVisibility);\n        AccountManager.invalidateLocalAccountsDataCaches();\n        return true;\n    }\n\n    @Override\n    public void registerAccountListener(String[] accountTypes, String opPackageName) {\n        int callingUid = Binder.getCallingUid();\n        mAppOpsManager.checkPackage(callingUid, opPackageName);\n\n        int userId = UserHandle.getCallingUserId();\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            registerAccountListener(accountTypes, opPackageName, accounts);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private void registerAccountListener(String[] accountTypes, String opPackageName,\n            UserAccounts accounts) {\n        synchronized (accounts.mReceiversForType) {\n            if (accountTypes == null) {\n                // null for any type\n                accountTypes = new String[] {null};\n            }\n            for (String type : accountTypes) {\n                Map<String, Integer> receivers = accounts.mReceiversForType.get(type);\n                if (receivers == null) {\n                    receivers = new HashMap<>();\n                    accounts.mReceiversForType.put(type, receivers);\n                }\n                Integer cnt = receivers.get(opPackageName);\n                receivers.put(opPackageName, cnt != null ? cnt + 1 : 1);\n            }\n        }\n    }\n\n    @Override\n    public void unregisterAccountListener(String[] accountTypes, String opPackageName) {\n        int callingUid = Binder.getCallingUid();\n        mAppOpsManager.checkPackage(callingUid, opPackageName);\n        int userId = UserHandle.getCallingUserId();\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            unregisterAccountListener(accountTypes, opPackageName, accounts);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private void unregisterAccountListener(String[] accountTypes, String opPackageName,\n            UserAccounts accounts) {\n        synchronized (accounts.mReceiversForType) {\n            if (accountTypes == null) {\n                // null for any type\n                accountTypes = new String[] {null};\n            }\n            for (String type : accountTypes) {\n                Map<String, Integer> receivers = accounts.mReceiversForType.get(type);\n                if (receivers == null || receivers.get(opPackageName) == null) {\n                    throw new IllegalArgumentException(\"attempt to unregister wrong receiver\");\n                }\n                Integer cnt = receivers.get(opPackageName);\n                if (cnt == 1) {\n                    receivers.remove(opPackageName);\n                } else {\n                    receivers.put(opPackageName, cnt - 1);\n                }\n            }\n        }\n    }\n\n    // Send notification to all packages which can potentially see the account\n    private void sendNotificationAccountUpdated(Account account, UserAccounts accounts) {\n        Map<String, Integer> packagesToVisibility = getRequestingPackages(account, accounts);\n\n        for (Entry<String, Integer> packageToVisibility : packagesToVisibility.entrySet()) {\n            if ((packageToVisibility.getValue() != AccountManager.VISIBILITY_NOT_VISIBLE)\n                    && (packageToVisibility.getValue()\n                        != AccountManager.VISIBILITY_USER_MANAGED_NOT_VISIBLE)) {\n                notifyPackage(packageToVisibility.getKey(), accounts);\n            }\n        }\n    }\n\n    /**\n     * Sends a direct intent to a package, notifying it of account visibility change.\n     *\n     * @param packageName to send Account to\n     * @param accounts UserAccount that currently hosts the account\n     */\n    private void notifyPackage(String packageName, UserAccounts accounts) {\n        Log.i(TAG, \"notifying package=\" + packageName + \" for userId=\" + accounts.userId\n                +\", sending broadcast of \" + AccountManager.ACTION_VISIBLE_ACCOUNTS_CHANGED);\n        Intent intent = new Intent(AccountManager.ACTION_VISIBLE_ACCOUNTS_CHANGED);\n        intent.setPackage(packageName);\n        intent.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);\n        mContext.sendBroadcastAsUser(intent, new UserHandle(accounts.userId));\n    }\n\n    // Returns a map from package name to visibility, for packages subscribed\n    // to notifications about any account type, or type of provided account\n    // account type or all types.\n    private Map<String, Integer> getRequestingPackages(Account account, UserAccounts accounts) {\n        Set<String> packages = new HashSet<>();\n        synchronized (accounts.mReceiversForType) {\n            for (String type : new String[] {account.type, null}) {\n                Map<String, Integer> receivers = accounts.mReceiversForType.get(type);\n                if (receivers != null) {\n                    packages.addAll(receivers.keySet());\n                }\n            }\n        }\n        Map<String, Integer> result = new HashMap<>();\n        for (String packageName : packages) {\n            result.put(packageName, resolveAccountVisibility(account, packageName, accounts));\n        }\n        return result;\n    }\n\n    // Returns a list of packages listening to ACTION_ACCOUNT_REMOVED able to see the account.\n    private List<String> getAccountRemovedReceivers(Account account, UserAccounts accounts) {\n        Intent intent = new Intent(AccountManager.ACTION_ACCOUNT_REMOVED);\n        intent.setFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);\n        List<ResolveInfo> receivers =\n            mPackageManager.queryBroadcastReceiversAsUser(intent, 0, accounts.userId);\n        List<String> result = new ArrayList<>();\n        if (receivers == null) {\n            return result;\n        }\n        for (ResolveInfo resolveInfo: receivers) {\n            String packageName = resolveInfo.activityInfo.applicationInfo.packageName;\n            int visibility = resolveAccountVisibility(account, packageName, accounts);\n            if (visibility == AccountManager.VISIBILITY_VISIBLE\n                || visibility == AccountManager.VISIBILITY_USER_MANAGED_VISIBLE) {\n                result.add(packageName);\n            }\n        }\n        return result;\n    }\n\n    // Returns true if given package is listening to ACTION_ACCOUNT_REMOVED and can see the account.\n    private boolean shouldNotifyPackageOnAccountRemoval(Account account,\n            String packageName, UserAccounts accounts) {\n        int visibility = resolveAccountVisibility(account, packageName, accounts);\n        if (visibility != AccountManager.VISIBILITY_VISIBLE\n            && visibility != AccountManager.VISIBILITY_USER_MANAGED_VISIBLE) {\n            return false;\n        }\n\n        Intent intent = new Intent(AccountManager.ACTION_ACCOUNT_REMOVED);\n        intent.setFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);\n        intent.setPackage(packageName);\n        List<ResolveInfo> receivers =\n            mPackageManager.queryBroadcastReceiversAsUser(intent, 0, accounts.userId);\n        return (receivers != null && receivers.size() > 0);\n    }\n\n    /**\n     * Returns true if packageName is one of special values.\n     */\n    private boolean isSpecialPackageKey(String packageName) {\n        return (AccountManager.PACKAGE_NAME_KEY_LEGACY_VISIBLE.equals(packageName)\n                || AccountManager.PACKAGE_NAME_KEY_LEGACY_NOT_VISIBLE.equals(packageName));\n    }\n\n    private void sendAccountsChangedBroadcast(\n            int userId, String accountType, @NonNull String useCase) {\n        Objects.requireNonNull(useCase, \"useCase can't be null\");\n        Log.i(TAG, \"the accountType= \" + (accountType == null ? \"\" : accountType)\n                + \" changed with useCase=\" + useCase + \" for userId=\" + userId\n                + \", sending broadcast of \" + ACCOUNTS_CHANGED_INTENT.getAction());\n        mContext.sendBroadcastAsUser(ACCOUNTS_CHANGED_INTENT, new UserHandle(userId),\n                null /* receiverPermission */, ACCOUNTS_CHANGED_OPTIONS);\n    }\n\n    private void sendAccountRemovedBroadcast(\n            Account account, String packageName, int userId, @NonNull String useCase) {\n        Objects.requireNonNull(useCase, \"useCase can't be null\");\n        Log.i(TAG, \"the account with type=\" + account.type + \" removed while useCase=\"\n                + useCase + \" for userId=\" + userId + \", sending broadcast of \"\n                + AccountManager.ACTION_ACCOUNT_REMOVED);\n        Intent intent = new Intent(AccountManager.ACTION_ACCOUNT_REMOVED);\n        intent.setFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);\n        intent.setPackage(packageName);\n        intent.putExtra(AccountManager.KEY_ACCOUNT_NAME, account.name);\n        intent.putExtra(AccountManager.KEY_ACCOUNT_TYPE, account.type);\n        mContext.sendBroadcastAsUser(intent, new UserHandle(userId));\n    }\n\n    @Override\n    public boolean onTransact(int code, Parcel data, Parcel reply, int flags)\n            throws RemoteException {\n        try {\n            return super.onTransact(code, data, reply, flags);\n        } catch (RuntimeException e) {\n            // The account manager only throws security exceptions, so let's\n            // log all others.\n            if (!(e instanceof SecurityException || e instanceof IllegalArgumentException)) {\n                Slog.wtf(TAG, \"Account Manager Crash\", e);\n            }\n            throw e;\n        }\n    }\n\n    private UserManager getUserManager() {\n        if (mUserManager == null) {\n            mUserManager = UserManager.get(mContext);\n        }\n        return mUserManager;\n    }\n\n    /**\n     * Validate internal set of accounts against installed authenticators for\n     * given user. Clears cached authenticators before validating.\n     */\n    public void validateAccounts(int userId) {\n        final UserAccounts accounts = getUserAccounts(userId);\n        // Invalidate user-specific cache to make sure we catch any\n        // removed authenticators.\n        validateAccountsInternal(accounts, true /* invalidateAuthenticatorCache */);\n    }\n\n    /**\n     * Validate internal set of accounts against installed authenticators for\n     * given user. Clear cached authenticators before validating when requested.\n     */\n    private void validateAccountsInternal(\n            UserAccounts accounts, boolean invalidateAuthenticatorCache) {\n        if (Log.isLoggable(TAG, Log.DEBUG)) {\n            Log.d(TAG, \"validateAccountsInternal \" + accounts.userId\n                    + \" isCeDatabaseAttached=\" + accounts.accountsDb.isCeDatabaseAttached()\n                    + \" userLocked=\" + mLocalUnlockedUsers.get(accounts.userId));\n        }\n\n        if (invalidateAuthenticatorCache) {\n            mAuthenticatorCache.invalidateCache(accounts.userId);\n        }\n\n        final HashMap<String, Integer> knownAuth = getAuthenticatorTypeAndUIDForUser(\n                mAuthenticatorCache, accounts.userId);\n        boolean userUnlocked = isLocalUnlockedUser(accounts.userId);\n\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                boolean accountDeleted = false;\n\n                // Get a map of stored authenticator types to UID\n                final AccountsDb accountsDb = accounts.accountsDb;\n                Map<String, Integer> metaAuthUid = accountsDb.findMetaAuthUid();\n                // Create a list of authenticator type whose previous uid no longer exists\n                HashSet<String> obsoleteAuthType = Sets.newHashSet();\n                SparseBooleanArray knownUids = null;\n                for (Entry<String, Integer> authToUidEntry : metaAuthUid.entrySet()) {\n                    String type = authToUidEntry.getKey();\n                    int uid = authToUidEntry.getValue();\n                    Integer knownUid = knownAuth.get(type);\n                    if (knownUid != null && uid == knownUid) {\n                        // Remove it from the knownAuth list if it's unchanged.\n                        knownAuth.remove(type);\n                    } else {\n                    /*\n                     * The authenticator is presently not cached and should only be triggered\n                     * when we think an authenticator has been removed (or is being updated).\n                     * But we still want to check if any data with the associated uid is\n                     * around. This is an (imperfect) signal that the package may be updating.\n                     *\n                     * A side effect of this is that an authenticator sharing a uid with\n                     * multiple apps won't get its credentials wiped as long as some app with\n                     * that uid is still on the device. But I suspect that this is a rare case.\n                     * And it isn't clear to me how an attacker could really exploit that\n                     * feature.\n                     *\n                     * The upshot is that we don't have to worry about accounts getting\n                     * uninstalled while the authenticator's package is being updated.\n                     *\n                     */\n                        if (knownUids == null) {\n                            knownUids = getUidsOfInstalledOrUpdatedPackagesAsUser(accounts.userId);\n                        }\n                        if (!knownUids.get(uid)) {\n                            // The authenticator is not presently available to the cache. And the\n                            // package no longer has a data directory (so we surmise it isn't\n                            // updating). So purge its data from the account databases.\n                            obsoleteAuthType.add(type);\n                            // And delete it from the TABLE_META\n                            accountsDb.deleteMetaByAuthTypeAndUid(type, uid);\n                        } else if (knownUid != null && knownUid != uid) {\n                            Slog.w(TAG, \"authenticator no longer exist for type \" + type);\n                            obsoleteAuthType.add(type);\n                            accountsDb.deleteMetaByAuthTypeAndUid(type, uid);\n                        }\n                    }\n                }\n\n                // Add the newly registered authenticator to TABLE_META. If old authenticators have\n                // been re-enabled (after being updated for example), then we just overwrite the old\n                // values.\n                for (Entry<String, Integer> entry : knownAuth.entrySet()) {\n                    accountsDb.insertOrReplaceMetaAuthTypeAndUid(entry.getKey(), entry.getValue());\n                }\n\n                final Map<Long, Account> accountsMap = accountsDb.findAllDeAccounts();\n                try {\n                    accounts.accountCache.clear();\n                    final HashMap<String, ArrayList<String>> accountNamesByType\n                            = new LinkedHashMap<>();\n                    for (Entry<Long, Account> accountEntry : accountsMap.entrySet()) {\n                        final long accountId = accountEntry.getKey();\n                        final Account account = accountEntry.getValue();\n                        if (obsoleteAuthType.contains(account.type)) {\n                            Slog.w(TAG, \"deleting account \" + account.toSafeString()\n                                    + \" because type \" + account.type\n                                    + \"'s registered authenticator no longer exist.\");\n                            Map<String, Integer> packagesToVisibility =\n                                    getRequestingPackages(account, accounts);\n                            List<String> accountRemovedReceivers =\n                                getAccountRemovedReceivers(account, accounts);\n                            accountsDb.beginTransaction();\n                            try {\n                                accountsDb.deleteDeAccount(accountId);\n                                // Also delete from CE table if user is unlocked; if user is\n                                // currently locked the account will be removed later by\n                                // syncDeCeAccountsLocked\n                                if (userUnlocked) {\n                                    accountsDb.deleteCeAccount(accountId);\n                                }\n                                accountsDb.setTransactionSuccessful();\n                            } finally {\n                                accountsDb.endTransaction();\n                            }\n                            accountDeleted = true;\n                            Log.i(TAG, \"validateAccountsInternal#Deleted UserId=\"\n                                    + accounts.userId + \", AccountId=\" + accountId);\n\n                            logRecord(AccountsDb.DEBUG_ACTION_AUTHENTICATOR_REMOVE,\n                                    AccountsDb.TABLE_ACCOUNTS, accountId, accounts);\n\n                            accounts.userDataCache.remove(account);\n                            accounts.authTokenCache.remove(account);\n                            accounts.accountTokenCaches.remove(account);\n                            accounts.visibilityCache.remove(account);\n\n                            for (Entry<String, Integer> packageToVisibility :\n                                    packagesToVisibility.entrySet()) {\n                                if (isVisible(packageToVisibility.getValue())) {\n                                    notifyPackage(packageToVisibility.getKey(), accounts);\n                                }\n                            }\n                            for (String packageName : accountRemovedReceivers) {\n                                sendAccountRemovedBroadcast(\n                                        account,\n                                        packageName,\n                                        accounts.userId,\n                                        /*useCase=*/\"validateAccounts\");\n                            }\n                        } else {\n                            ArrayList<String> accountNames = accountNamesByType.get(account.type);\n                            if (accountNames == null) {\n                                accountNames = new ArrayList<>();\n                                accountNamesByType.put(account.type, accountNames);\n                            }\n                            accountNames.add(account.name);\n                        }\n                    }\n                    for (Map.Entry<String, ArrayList<String>> cur : accountNamesByType.entrySet()) {\n                        final String accountType = cur.getKey();\n                        final ArrayList<String> accountNames = cur.getValue();\n                        final Account[] accountsForType = new Account[accountNames.size()];\n                        for (int i = 0; i < accountsForType.length; i++) {\n                            accountsForType[i] = new Account(accountNames.get(i), accountType,\n                                    UUID.randomUUID().toString());\n                        }\n                        accounts.accountCache.put(accountType, accountsForType);\n                    }\n                    accounts.visibilityCache.putAll(accountsDb.findAllVisibilityValues());\n                    AccountManager.invalidateLocalAccountsDataCaches();\n                } finally {\n                    if (accountDeleted) {\n                        sendAccountsChangedBroadcast(\n                                accounts.userId,\n                                /*accountType=*/\"ambiguous\",\n                                /*useCase=*/\"validateAccounts\");\n                    }\n                }\n            }\n        }\n    }\n\n    private SparseBooleanArray getUidsOfInstalledOrUpdatedPackagesAsUser(int userId) {\n        // Get the UIDs of all apps that might have data on the device. We want\n        // to preserve user data if the app might otherwise be storing data.\n        List<PackageInfo> pkgsWithData =\n                mPackageManager.getInstalledPackagesAsUser(\n                        PackageManager.MATCH_UNINSTALLED_PACKAGES, userId);\n        SparseBooleanArray knownUids = new SparseBooleanArray(pkgsWithData.size());\n        for (PackageInfo pkgInfo : pkgsWithData) {\n            if (pkgInfo.applicationInfo != null\n                    && (pkgInfo.applicationInfo.flags & ApplicationInfo.FLAG_INSTALLED) != 0) {\n                knownUids.put(pkgInfo.applicationInfo.uid, true);\n            }\n        }\n        return knownUids;\n    }\n\n    static HashMap<String, Integer> getAuthenticatorTypeAndUIDForUser(\n            Context context,\n            int userId) {\n        AccountAuthenticatorCache authCache = new AccountAuthenticatorCache(context);\n        return getAuthenticatorTypeAndUIDForUser(authCache, userId);\n    }\n\n    private static HashMap<String, Integer> getAuthenticatorTypeAndUIDForUser(\n            IAccountAuthenticatorCache authCache,\n            int userId) {\n        HashMap<String, Integer> knownAuth = new LinkedHashMap<>();\n        for (RegisteredServicesCache.ServiceInfo<AuthenticatorDescription> service : authCache\n                .getAllServices(userId)) {\n            knownAuth.put(service.type.type, service.uid);\n        }\n        return knownAuth;\n    }\n\n    private UserAccounts getUserAccountsForCaller() {\n        return getUserAccounts(UserHandle.getCallingUserId());\n    }\n\n    protected UserAccounts getUserAccounts(int userId) {\n        try {\n            return getUserAccountsNotChecked(userId);\n        } catch (RuntimeException e) {\n            if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE)) {\n                // Let it go...\n                throw e;\n            }\n            // User accounts database is corrupted, we must wipe out the whole user, otherwise the\n            // system will crash indefinitely\n            Slog.wtf(TAG, \"Removing user \" + userId + \" due to exception (\" + e + \") reading its \"\n                    + \"account database\");\n            if (userId == ActivityManager.getCurrentUser() && userId != UserHandle.USER_SYSTEM) {\n                Slog.i(TAG, \"Switching to system user first\");\n                try {\n                    ActivityManager.getService().switchUser(UserHandle.USER_SYSTEM);\n                } catch (RemoteException re) {\n                    Slog.e(TAG, \"Could not switch to \" + UserHandle.USER_SYSTEM + \": \" + re);\n                }\n            }\n            if (!getUserManager().removeUserEvenWhenDisallowed(userId)) {\n                Slog.e(TAG, \"could not remove user \" + userId);\n            }\n            throw e;\n        }\n    }\n\n    private UserAccounts getUserAccountsNotChecked(int userId) {\n        synchronized (mUsers) {\n            UserAccounts accounts = mUsers.get(userId);\n            boolean validateAccounts = false;\n            if (accounts == null) {\n                File preNDbFile = new File(mInjector.getPreNDatabaseName(userId));\n                File deDbFile = new File(mInjector.getDeDatabaseName(userId));\n                accounts = new UserAccounts(mContext, userId, preNDbFile, deDbFile);\n                mUsers.append(userId, accounts);\n                purgeOldGrants(accounts);\n                AccountManager.invalidateLocalAccountsDataCaches();\n                validateAccounts = true;\n            }\n            // open CE database if necessary\n            if (!accounts.accountsDb.isCeDatabaseAttached() && mLocalUnlockedUsers.get(userId)) {\n                Log.i(TAG, \"User \" + userId + \" is unlocked - opening CE database\");\n                synchronized (accounts.dbLock) {\n                    synchronized (accounts.cacheLock) {\n                        File ceDatabaseFile = new File(mInjector.getCeDatabaseName(userId));\n                        accounts.accountsDb.attachCeDatabase(ceDatabaseFile);\n                    }\n                }\n                syncDeCeAccountsLocked(accounts);\n            }\n            if (validateAccounts) {\n                validateAccountsInternal(accounts, true /* invalidateAuthenticatorCache */);\n            }\n            return accounts;\n        }\n    }\n\n    private void syncDeCeAccountsLocked(UserAccounts accounts) {\n        Preconditions.checkState(Thread.holdsLock(mUsers), \"mUsers lock must be held\");\n        List<Account> accountsToRemove = accounts.accountsDb.findCeAccountsNotInDe();\n        if (!accountsToRemove.isEmpty()) {\n            Slog.i(TAG, accountsToRemove.size()\n                    + \" accounts were previously deleted while user \"\n                    + accounts.userId + \" was locked. Removing accounts from CE tables\");\n            logRecord(accounts, AccountsDb.DEBUG_ACTION_SYNC_DE_CE_ACCOUNTS,\n                    AccountsDb.TABLE_ACCOUNTS);\n\n            for (Account account : accountsToRemove) {\n                removeAccountInternal(accounts, account, Process.SYSTEM_UID);\n            }\n        }\n    }\n\n    private void purgeOldGrantsAll() {\n        synchronized (mUsers) {\n            for (int i = 0; i < mUsers.size(); i++) {\n                purgeOldGrants(mUsers.valueAt(i));\n            }\n        }\n    }\n\n    private void purgeOldGrants(UserAccounts accounts) {\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                List<Integer> uids;\n                try {\n                    uids = accounts.accountsDb.findAllUidGrants();\n                } catch (SQLiteException e) {\n                    Log.w(TAG, \"Could not delete grants for user = \" + accounts.userId, e);\n                    return;\n                }\n                for (int uid : uids) {\n                    final boolean packageExists = mPackageManager.getPackagesForUid(uid) != null;\n                    if (packageExists) {\n                        continue;\n                    }\n                    Log.d(TAG, \"deleting grants for UID \" + uid\n                            + \" because its package is no longer installed\");\n                    accounts.accountsDb.deleteGrantsByUid(uid);\n                }\n            }\n        }\n    }\n\n    private void removeVisibilityValuesForPackage(String packageName) {\n        if (isSpecialPackageKey(packageName)) {\n            return;\n        }\n        synchronized (mUsers) {\n            int numberOfUsers = mUsers.size();\n            for (int i = 0; i < numberOfUsers; i++) {\n                UserAccounts accounts = mUsers.valueAt(i);\n                try {\n                    mPackageManager.getPackageUidAsUser(packageName, accounts.userId);\n                } catch (NameNotFoundException e) {\n                    // package does not exist - remove visibility values\n                    try {\n                        accounts.accountsDb.deleteAccountVisibilityForPackage(packageName);\n                    } catch (SQLiteCantOpenDatabaseException sqlException) {\n                        Log.w(TAG, \"Could not delete account visibility for user = \"\n                                + accounts.userId, sqlException);\n                        continue;\n                    }\n                    synchronized (accounts.dbLock) {\n                        synchronized (accounts.cacheLock) {\n                            for (Account account : accounts.visibilityCache.keySet()) {\n                                Map<String, Integer> accountVisibility =\n                                        getPackagesAndVisibilityForAccountLocked(account, accounts);\n                                accountVisibility.remove(packageName);\n                            }\n                            AccountManager.invalidateLocalAccountsDataCaches();\n                        }\n                    }\n              }\n          }\n        }\n    }\n\n    private void purgeUserData(int userId) {\n        UserAccounts accounts;\n        synchronized (mUsers) {\n            accounts = mUsers.get(userId);\n            mUsers.remove(userId);\n            mLocalUnlockedUsers.delete(userId);\n            AccountManager.invalidateLocalAccountsDataCaches();\n        }\n        if (accounts != null) {\n            synchronized (accounts.dbLock) {\n                synchronized (accounts.cacheLock) {\n                    accounts.accountsDb.closeDebugStatement();\n                    accounts.accountsDb.close();\n                }\n            }\n        }\n    }\n\n    @VisibleForTesting\n    void onUserUnlocked(Intent intent) {\n        onUnlockUser(intent.getIntExtra(Intent.EXTRA_USER_HANDLE, -1));\n    }\n\n    void onUnlockUser(int userId) {\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"onUserUnlocked \" + userId);\n        }\n        synchronized (mUsers) {\n            mLocalUnlockedUsers.put(userId, true);\n        }\n        if (userId < 1) return;\n        mHandler.post(() -> syncSharedAccounts(userId));\n    }\n\n    private void syncSharedAccounts(int userId) {\n        // Check if there's a shared account that needs to be created as an account\n        Account[] sharedAccounts = getSharedAccountsAsUser(userId);\n        if (sharedAccounts == null || sharedAccounts.length == 0) return;\n        Account[] accounts = getAccountsAsUser(null, userId, mContext.getOpPackageName());\n        int parentUserId = UserHandle.USER_SYSTEM;\n        for (Account sa : sharedAccounts) {\n            if (ArrayUtils.contains(accounts, sa)) continue;\n            // Account doesn't exist. Copy it now.\n            copyAccountToUser(null /*no response*/, sa, parentUserId, userId);\n        }\n    }\n\n    @Override\n    public void onServiceChanged(AuthenticatorDescription desc, int userId, boolean removed) {\n        UserInfo user = getUserManager().getUserInfo(userId);\n        if (user == null) {\n            Log.w(TAG, \"onServiceChanged: ignore removed user \" + userId);\n            return;\n        }\n        validateAccountsInternal(getUserAccounts(userId), false /* invalidateAuthenticatorCache */);\n    }\n\n    @Override\n    public String getPassword(Account account) {\n        int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"getPassword: \" + account\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        if (account == null) throw new IllegalArgumentException(\"account is null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot get secrets for accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return readPasswordInternal(accounts, account);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private String readPasswordInternal(UserAccounts accounts, Account account) {\n        if (account == null) {\n            return null;\n        }\n        if (!isLocalUnlockedUser(accounts.userId)) {\n            Log.w(TAG, \"Password is not available - user \" + accounts.userId + \" data is locked\");\n            return null;\n        }\n\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                return accounts.accountsDb\n                        .findAccountPasswordByNameAndType(account.name, account.type);\n            }\n        }\n    }\n\n    @Override\n    public String getPreviousName(Account account) {\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"getPreviousName: \" + account\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        int userId = UserHandle.getCallingUserId();\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return readPreviousNameInternal(accounts, account);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private String readPreviousNameInternal(UserAccounts accounts, Account account) {\n        if  (account == null) {\n            return null;\n        }\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                AtomicReference<String> previousNameRef = accounts.previousNameCache.get(account);\n                if (previousNameRef == null) {\n                    String previousName = accounts.accountsDb.findDeAccountPreviousName(account);\n                    previousNameRef = new AtomicReference<>(previousName);\n                    accounts.previousNameCache.put(account, previousNameRef);\n                    return previousName;\n                } else {\n                    return previousNameRef.get();\n                }\n            }\n        }\n    }\n\n    @Override\n    public String getUserData(Account account, String key) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            String msg = String.format(\"getUserData( account: %s, key: %s, callerUid: %s, pid: %s\",\n                    account, key, callingUid, Binder.getCallingPid());\n            Log.v(TAG, msg);\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        Objects.requireNonNull(key, \"key cannot be null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot get user data for accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        if (!isLocalUnlockedUser(userId)) {\n            Log.w(TAG, \"User \" + userId + \" data is locked. callingUid \" + callingUid);\n            return null;\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            if (!accountExistsCache(accounts, account)) {\n                return null;\n            }\n            return readUserDataInternal(accounts, account, key);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public AuthenticatorDescription[] getAuthenticatorTypes(int userId) {\n        int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"getAuthenticatorTypes: \"\n                    + \"for user id \" + userId\n                    + \" caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        // Only allow the system process to read accounts of other users\n        if (isCrossUser(callingUid, userId)) {\n            throw new SecurityException(\n                    String.format(\n                            \"User %s tying to get authenticator types for %s\" ,\n                            UserHandle.getCallingUserId(),\n                            userId));\n        }\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            return getAuthenticatorTypesInternal(userId, callingUid);\n\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    /**\n     * Should only be called inside of a clearCallingIdentity block.\n     */\n    private AuthenticatorDescription[] getAuthenticatorTypesInternal(int userId, int callingUid) {\n        mAuthenticatorCache.updateServices(userId);\n        Collection<AccountAuthenticatorCache.ServiceInfo<AuthenticatorDescription>>\n                authenticatorCollection = mAuthenticatorCache.getAllServices(userId);\n        final List<AuthenticatorDescription> types =\n                new ArrayList<>(authenticatorCollection.size());\n        for (AccountAuthenticatorCache.ServiceInfo<AuthenticatorDescription> authenticator\n                : authenticatorCollection) {\n            if (canCallerAccessPackage(authenticator.type.packageName, callingUid, userId)) {\n                types.add(authenticator.type);\n            }\n        }\n        return types.toArray(new AuthenticatorDescription[types.size()]);\n    }\n\n    private boolean isCrossUser(int callingUid, int userId) {\n        return (userId != UserHandle.getCallingUserId()\n                && callingUid != Process.SYSTEM_UID\n                && mContext.checkCallingOrSelfPermission(\n                        android.Manifest.permission.INTERACT_ACROSS_USERS_FULL)\n                                != PackageManager.PERMISSION_GRANTED);\n    }\n\n    @Override\n    public boolean addAccountExplicitly(\n            Account account, String password, Bundle extras, String opPackageName) {\n        return addAccountExplicitlyWithVisibility(\n                account, password, extras, /* packageToVisibility= */ null, opPackageName);\n    }\n\n    @Override\n    public void copyAccountToUser(final IAccountManagerResponse response, final Account account,\n            final int userFrom, int userTo) {\n        int callingUid = Binder.getCallingUid();\n        if (isCrossUser(callingUid, UserHandle.USER_ALL)) {\n            throw new SecurityException(\"Calling copyAccountToUser requires \"\n                    + android.Manifest.permission.INTERACT_ACROSS_USERS_FULL);\n        }\n        final UserAccounts fromAccounts = getUserAccounts(userFrom);\n        final UserAccounts toAccounts = getUserAccounts(userTo);\n        if (fromAccounts == null || toAccounts == null) {\n            if (response != null) {\n                Bundle result = new Bundle();\n                result.putBoolean(AccountManager.KEY_BOOLEAN_RESULT, false);\n                try {\n                    response.onResult(result);\n                } catch (RemoteException e) {\n                    Slog.w(TAG, \"Failed to report error back to the client.\" + e);\n                }\n            }\n            return;\n        }\n\n        Slog.d(TAG, \"Copying account \" + account.toSafeString()\n                + \" from user \" + userFrom + \" to user \" + userTo);\n        final long identityToken = clearCallingIdentity();\n        try {\n            new Session(fromAccounts, response, account.type, false,\n                    false /* stripAuthTokenFromResult */, account.name,\n                    false /* authDetailsRequired */) {\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now) + \", getAccountCredentialsForClone\"\n                            + \", \" + account.type;\n                }\n\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.getAccountCredentialsForCloning(this, account);\n                }\n\n                @Override\n                public void onResult(Bundle result) {\n                    Bundle.setDefusable(result, true);\n                    if (result != null\n                            && result.getBoolean(AccountManager.KEY_BOOLEAN_RESULT, false)) {\n                        // Create a Session for the target user and pass in the bundle\n                        completeCloningAccount(response, result, account, toAccounts, userFrom);\n                    } else {\n                        super.onResult(result);\n                    }\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public boolean accountAuthenticated(final Account account) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            String msg = String.format(\n                    \"accountAuthenticated( account: %s, callerUid: %s)\",\n                    account,\n                    callingUid);\n            Log.v(TAG, msg);\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot notify authentication for accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n\n        if (!canUserModifyAccounts(userId, callingUid) ||\n                !canUserModifyAccountsForType(userId, account.type, callingUid)) {\n            return false;\n        }\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return updateLastAuthenticatedTime(account);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private boolean updateLastAuthenticatedTime(Account account) {\n        final UserAccounts accounts = getUserAccountsForCaller();\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                return accounts.accountsDb.updateAccountLastAuthenticatedTime(account);\n            }\n        }\n    }\n\n    private void completeCloningAccount(IAccountManagerResponse response,\n            final Bundle accountCredentials, final Account account, final UserAccounts targetUser,\n            final int parentUserId){\n        Bundle.setDefusable(accountCredentials, true);\n        final long id = clearCallingIdentity();\n        try {\n            new Session(targetUser, response, account.type, false,\n                    false /* stripAuthTokenFromResult */, account.name,\n                    false /* authDetailsRequired */) {\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now) + \", getAccountCredentialsForClone\"\n                            + \", \" + account.type;\n                }\n\n                @Override\n                public void run() throws RemoteException {\n                    // Confirm that the owner's account still exists before this step.\n                    for (Account acc : getAccounts(parentUserId, mContext.getOpPackageName())) {\n                        if (acc.equals(account)) {\n                            mAuthenticator.addAccountFromCredentials(\n                                    this, account, accountCredentials);\n                            break;\n                        }\n                    }\n                }\n\n                @Override\n                public void onResult(Bundle result) {\n                    Bundle.setDefusable(result, true);\n                    // TODO: Anything to do if if succedded?\n                    // TODO: If it failed: Show error notification? Should we remove the shadow\n                    // account to avoid retries?\n                    // TODO: what we do with the visibility?\n\n                    super.onResult(result);\n                }\n\n                @Override\n                public void onError(int errorCode, String errorMessage) {\n                    super.onError(errorCode,  errorMessage);\n                    // TODO: Show error notification to user\n                    // TODO: Should we remove the shadow account so that it doesn't keep trying?\n                }\n\n            }.bind();\n        } finally {\n            restoreCallingIdentity(id);\n        }\n    }\n\n    private boolean addAccountInternal(UserAccounts accounts, Account account, String password,\n            Bundle extras, int callingUid, Map<String, Integer> packageToVisibility,\n            String opPackageName) {\n        Bundle.setDefusable(extras, true);\n        if (account == null) {\n            return false;\n        }\n        if (account.name != null && account.name.length() > 200) {\n            Log.w(TAG, \"Account cannot be added - Name longer than 200 chars\");\n            return false;\n        }\n        if (account.type != null && account.type.length() > 200) {\n            Log.w(TAG, \"Account cannot be added - Name longer than 200 chars\");\n            return false;\n        }\n        if (!isLocalUnlockedUser(accounts.userId)) {\n            Log.w(TAG, \"Account \" + account.toSafeString() + \" cannot be added - user \"\n                    + accounts.userId + \" is locked. callingUid=\" + callingUid);\n            return false;\n        }\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                accounts.accountsDb.beginTransaction();\n                try {\n                    if (accounts.accountsDb.findCeAccountId(account) >= 0) {\n                        Log.w(TAG, \"insertAccountIntoDatabase: \" + account.toSafeString()\n                                + \", skipping since the account already exists\");\n                        return false;\n                    }\n                    if (accounts.accountsDb.findAllDeAccounts().size() > 100) {\n                        Log.w(TAG, \"insertAccountIntoDatabase: \" + account.toSafeString()\n                                + \", skipping since more than 100 accounts on device exist\");\n                        return false;\n                    }\n                    long accountId = accounts.accountsDb.insertCeAccount(account, password);\n                    if (accountId < 0) {\n                        Log.w(TAG, \"insertAccountIntoDatabase: \" + account.toSafeString()\n                                + \", skipping the DB insert failed\");\n                        return false;\n                    }\n                    // Insert into DE table\n                    if (accounts.accountsDb.insertDeAccount(account, accountId) < 0) {\n                        Log.w(TAG, \"insertAccountIntoDatabase: \" + account.toSafeString()\n                                + \", skipping the DB insert failed\");\n                        return false;\n                    }\n                    if (extras != null) {\n                        for (String key : extras.keySet()) {\n                            final String value = extras.getString(key);\n                            if (accounts.accountsDb.insertExtra(accountId, key, value) < 0) {\n                                Log.w(TAG, \"insertAccountIntoDatabase: \"\n                                        + account.toSafeString()\n                                        + \", skipping since insertExtra failed for key \" + key);\n                                return false;\n                            } else {\n                                AccountManager.invalidateLocalAccountUserDataCaches();\n                            }\n                        }\n                    }\n\n                    if (packageToVisibility != null) {\n                        for (Entry<String, Integer> entry : packageToVisibility.entrySet()) {\n                            setAccountVisibility(account, entry.getKey() /* package */,\n                                    entry.getValue() /* visibility */, false /* notify */,\n                                    accounts, callingUid);\n                        }\n                    }\n                    accounts.accountsDb.setTransactionSuccessful();\n\n                    logRecord(AccountsDb.DEBUG_ACTION_ACCOUNT_ADD, AccountsDb.TABLE_ACCOUNTS,\n                            accountId,\n                            accounts, callingUid);\n\n                    insertAccountIntoCacheLocked(accounts, account);\n                } finally {\n                    accounts.accountsDb.endTransaction();\n                }\n            }\n        }\n        if (getUserManager().getUserInfo(accounts.userId).canHaveProfile()) {\n            addAccountToLinkedRestrictedUsers(account, accounts.userId);\n        }\n\n        sendNotificationAccountUpdated(account, accounts);\n        // Only send LOGIN_ACCOUNTS_CHANGED when the database changed.\n        Log.i(TAG, \"callingUid=\" + callingUid + \", userId=\" + accounts.userId\n                + \" added account\");\n        sendAccountsChangedBroadcast(accounts.userId, account.type, /*useCase=*/\"addAccount\");\n\n        logAddAccountExplicitlyMetrics(opPackageName, account.type, packageToVisibility);\n        return true;\n    }\n\n    private void logAddAccountExplicitlyMetrics(\n            String callerPackage, String accountType,\n            @Nullable Map<String, Integer> accountVisibility) {\n        // Although this is not a 'device policy' API, enterprise is the current use case.\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.ADD_ACCOUNT_EXPLICITLY)\n                .setStrings(\n                        TextUtils.emptyIfNull(accountType),\n                        TextUtils.emptyIfNull(callerPackage),\n                        findPackagesPerVisibility(accountVisibility))\n                .write();\n    }\n\n    private String[] findPackagesPerVisibility(@Nullable Map<String, Integer> accountVisibility) {\n        Map<Integer, Set<String>> packagesPerVisibility = new HashMap<>();\n        if (accountVisibility != null) {\n            for (Entry<String, Integer> entry : accountVisibility.entrySet()) {\n                if (!packagesPerVisibility.containsKey(entry.getValue())) {\n                    packagesPerVisibility.put(entry.getValue(), new HashSet<>());\n                }\n                packagesPerVisibility.get(entry.getValue()).add(entry.getKey());\n            }\n        }\n\n        String[] packagesPerVisibilityStr = new String[5];\n        packagesPerVisibilityStr[AccountManager.VISIBILITY_UNDEFINED] = getPackagesForVisibilityStr(\n                AccountManager.VISIBILITY_UNDEFINED, packagesPerVisibility);\n        packagesPerVisibilityStr[AccountManager.VISIBILITY_VISIBLE] = getPackagesForVisibilityStr(\n                AccountManager.VISIBILITY_VISIBLE, packagesPerVisibility);\n        packagesPerVisibilityStr[AccountManager.VISIBILITY_USER_MANAGED_VISIBLE] =\n                getPackagesForVisibilityStr(\n                        AccountManager.VISIBILITY_USER_MANAGED_VISIBLE, packagesPerVisibility);\n        packagesPerVisibilityStr[AccountManager.VISIBILITY_NOT_VISIBLE] =\n                getPackagesForVisibilityStr(\n                        AccountManager.VISIBILITY_NOT_VISIBLE, packagesPerVisibility);\n        packagesPerVisibilityStr[AccountManager.VISIBILITY_USER_MANAGED_NOT_VISIBLE] =\n                getPackagesForVisibilityStr(\n                        AccountManager.VISIBILITY_USER_MANAGED_NOT_VISIBLE, packagesPerVisibility);\n        return packagesPerVisibilityStr;\n    }\n\n    private String getPackagesForVisibilityStr(\n            int visibility, Map<Integer, Set<String>> packagesPerVisibility) {\n        return visibility + \":\"\n                + (packagesPerVisibility.containsKey(visibility)\n                    ? TextUtils.join(\",\", packagesPerVisibility.get(visibility))\n                    : \"\");\n    }\n\n    private boolean isLocalUnlockedUser(int userId) {\n        synchronized (mUsers) {\n            return mLocalUnlockedUsers.get(userId);\n        }\n    }\n\n    /**\n     * Adds the account to all linked restricted users as shared accounts. If the user is currently\n     * running, then clone the account too.\n     * @param account the account to share with limited users\n     *\n     */\n    private void addAccountToLinkedRestrictedUsers(Account account, int parentUserId) {\n        List<UserInfo> users = getUserManager().getUsers();\n        for (UserInfo user : users) {\n            if (user.isRestricted() && (parentUserId == user.restrictedProfileParentId)) {\n                addSharedAccountAsUser(account, user.id);\n                if (isLocalUnlockedUser(user.id)) {\n                    mHandler.sendMessage(mHandler.obtainMessage(\n                            MESSAGE_COPY_SHARED_ACCOUNT, parentUserId, user.id, account));\n                }\n            }\n        }\n    }\n\n    @Override\n    public void hasFeatures(IAccountManagerResponse response,\n            Account account, String[] features, int userId, String opPackageName) {\n        int callingUid = Binder.getCallingUid();\n        mAppOpsManager.checkPackage(callingUid, opPackageName);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"hasFeatures: \" + account\n                    + \", response \" + response\n                    + \", features \" + Arrays.toString(features)\n                    + \", caller's uid \" + callingUid\n                    + \", userId \" + userId\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Preconditions.checkArgument(account != null, \"account cannot be null\");\n        Preconditions.checkArgument(response != null, \"response cannot be null\");\n        Preconditions.checkArgument(features != null, \"features cannot be null\");\n\n        if (userId != UserHandle.getCallingUserId()\n                && callingUid != Process.SYSTEM_UID\n                && mContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.INTERACT_ACROSS_USERS_FULL)\n                != PackageManager.PERMISSION_GRANTED) {\n            throw new SecurityException(\"User \" + UserHandle.getCallingUserId()\n                    + \" trying to check account features for \" + userId);\n        }\n\n        checkReadAccountsPermitted(callingUid, account.type, userId,\n                opPackageName);\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            new TestFeaturesSession(accounts, response, account, features).bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private class TestFeaturesSession extends Session {\n        private final String[] mFeatures;\n        private final Account mAccount;\n\n        public TestFeaturesSession(UserAccounts accounts, IAccountManagerResponse response,\n                Account account, String[] features) {\n            super(accounts, response, account.type, false /* expectActivityLaunch */,\n                    true /* stripAuthTokenFromResult */, account.name,\n                    false /* authDetailsRequired */);\n            mFeatures = features;\n            mAccount = account;\n        }\n\n        @Override\n        public void run() throws RemoteException {\n            try {\n                mAuthenticator.hasFeatures(this, mAccount, mFeatures);\n            } catch (RemoteException e) {\n                onError(AccountManager.ERROR_CODE_REMOTE_EXCEPTION, \"remote exception\");\n            }\n        }\n\n        @Override\n        public void onResult(Bundle result) {\n            Bundle.setDefusable(result, true);\n            IAccountManagerResponse response = getResponseAndClose();\n            if (response != null) {\n                try {\n                    if (result == null) {\n                        response.onError(AccountManager.ERROR_CODE_INVALID_RESPONSE, \"null bundle\");\n                        return;\n                    }\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, getClass().getSimpleName() + \" calling onResult() on response \"\n                                + response);\n                    }\n                    final Bundle newResult = new Bundle();\n                    newResult.putBoolean(AccountManager.KEY_BOOLEAN_RESULT,\n                            result.getBoolean(AccountManager.KEY_BOOLEAN_RESULT, false));\n                    response.onResult(newResult);\n                } catch (RemoteException e) {\n                    // if the caller is dead then there is no one to care about remote exceptions\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, \"failure while notifying response\", e);\n                    }\n                }\n            }\n        }\n\n        @Override\n        protected String toDebugString(long now) {\n            return super.toDebugString(now) + \", hasFeatures\"\n                    + \", \" + mAccount\n                    + \", \" + (mFeatures != null ? TextUtils.join(\",\", mFeatures) : null);\n        }\n    }\n\n    @Override\n    public void renameAccount(\n            IAccountManagerResponse response, Account accountToRename, String newName) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"renameAccount: \" + accountToRename + \" -> \" + newName\n                + \", caller's uid \" + callingUid\n                + \", pid \" + Binder.getCallingPid());\n        }\n        if (accountToRename == null) throw new IllegalArgumentException(\"account is null\");\n        if (newName != null && newName.length() > 200) {\n            Log.e(TAG, \"renameAccount failed - account name longer than 200\");\n            throw new IllegalArgumentException(\"account name longer than 200\");\n        }\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(accountToRename.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot rename accounts of type: %s\",\n                    callingUid,\n                    accountToRename.type);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            Log.i(TAG, \"callingUid=\" + callingUid + \", userId=\" + accounts.userId\n                    + \" performing rename account\");\n            Account resultingAccount = renameAccountInternal(accounts, accountToRename, newName);\n            if (resultingAccount == null) {\n                resultingAccount = accountToRename;\n            }\n            Bundle result = new Bundle();\n            result.putString(AccountManager.KEY_ACCOUNT_NAME, resultingAccount.name);\n            result.putString(AccountManager.KEY_ACCOUNT_TYPE, resultingAccount.type);\n            result.putString(AccountManager.KEY_ACCOUNT_ACCESS_ID,\n                    resultingAccount.getAccessId());\n            try {\n                response.onResult(result);\n            } catch (RemoteException e) {\n                Log.w(TAG, e.getMessage());\n            }\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private Account renameAccountInternal(\n            UserAccounts accounts, Account accountToRename, String newName) {\n        Account resultAccount = null;\n        /*\n         * Cancel existing notifications. Let authenticators\n         * re-post notifications as required. But we don't know if\n         * the authenticators have bound their notifications to\n         * now stale account name data.\n         *\n         * With a rename api, we might not need to do this anymore but it\n         * shouldn't hurt.\n         */\n        cancelNotification(\n                getSigninRequiredNotificationId(accounts, accountToRename),\n                accounts);\n        synchronized(accounts.credentialsPermissionNotificationIds) {\n            for (Pair<Pair<Account, String>, Integer> pair:\n                    accounts.credentialsPermissionNotificationIds.keySet()) {\n                if (accountToRename.equals(pair.first.first)) {\n                    NotificationId id = accounts.credentialsPermissionNotificationIds.get(pair);\n                    cancelNotification(id, accounts);\n                }\n            }\n        }\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                List<String> accountRemovedReceivers =\n                    getAccountRemovedReceivers(accountToRename, accounts);\n                accounts.accountsDb.beginTransaction();\n                Account renamedAccount = new Account(newName, accountToRename.type);\n                try {\n                    if ((accounts.accountsDb.findCeAccountId(renamedAccount) >= 0)) {\n                        Log.e(TAG, \"renameAccount failed - account with new name already exists\");\n                        return null;\n                    }\n                    final long accountId = accounts.accountsDb.findDeAccountId(accountToRename);\n                    if (accountId >= 0) {\n                        accounts.accountsDb.renameCeAccount(accountId, newName);\n                        if (accounts.accountsDb.renameDeAccount(\n                                accountId, newName, accountToRename.name)) {\n                            accounts.accountsDb.setTransactionSuccessful();\n                        } else {\n                            Log.e(TAG, \"renameAccount failed\");\n                            return null;\n                        }\n                    } else {\n                        Log.e(TAG, \"renameAccount failed - old account does not exist\");\n                        return null;\n                    }\n                } finally {\n                    accounts.accountsDb.endTransaction();\n                }\n            /*\n             * Database transaction was successful. Clean up cached\n             * data associated with the account in the user profile.\n             */\n                renamedAccount = insertAccountIntoCacheLocked(accounts, renamedAccount);\n            /*\n             * Extract the data and token caches before removing the\n             * old account to preserve the user data associated with\n             * the account.\n             */\n                Map<String, String> tmpData = accounts.userDataCache.get(accountToRename);\n                Map<String, String> tmpTokens = accounts.authTokenCache.get(accountToRename);\n                Map<String, Integer> tmpVisibility = accounts.visibilityCache.get(accountToRename);\n                removeAccountFromCacheLocked(accounts, accountToRename);\n            /*\n             * Update the cached data associated with the renamed\n             * account.\n             */\n                accounts.userDataCache.put(renamedAccount, tmpData);\n                accounts.authTokenCache.put(renamedAccount, tmpTokens);\n                accounts.visibilityCache.put(renamedAccount, tmpVisibility);\n                accounts.previousNameCache.put(\n                        renamedAccount,\n                        new AtomicReference<>(accountToRename.name));\n                resultAccount = renamedAccount;\n\n                int parentUserId = accounts.userId;\n                if (canHaveProfile(parentUserId)) {\n                /*\n                 * Owner or system user account was renamed, rename the account for\n                 * those users with which the account was shared.\n                 */\n                    List<UserInfo> users = getUserManager().getAliveUsers();\n                    for (UserInfo user : users) {\n                        if (user.isRestricted()\n                                && (user.restrictedProfileParentId == parentUserId)) {\n                            renameSharedAccountAsUser(accountToRename, newName, user.id);\n                        }\n                    }\n                }\n\n                sendNotificationAccountUpdated(resultAccount, accounts);\n                sendAccountsChangedBroadcast(\n                        accounts.userId, accountToRename.type, /*useCase=*/\"renameAccount\");\n                for (String packageName : accountRemovedReceivers) {\n                    sendAccountRemovedBroadcast(\n                            accountToRename,\n                            packageName,\n                            accounts.userId,\n                            /*useCase=*/\"renameAccount\");\n                }\n\n                AccountManager.invalidateLocalAccountsDataCaches();\n                AccountManager.invalidateLocalAccountUserDataCaches();\n            }\n        }\n        return resultAccount;\n    }\n\n    private boolean canHaveProfile(final int parentUserId) {\n        final UserInfo userInfo = getUserManager().getUserInfo(parentUserId);\n        return userInfo != null && userInfo.canHaveProfile();\n    }\n\n    @Override\n    public void removeAccountAsUser(IAccountManagerResponse response, Account account,\n            boolean expectActivityLaunch, int userId) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"removeAccount: \" + account\n                    + \", response \" + response\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid()\n                    + \", for user id \" + userId);\n        }\n        Preconditions.checkArgument(account != null, \"account cannot be null\");\n        Preconditions.checkArgument(response != null, \"response cannot be null\");\n\n        // Only allow the system process to modify accounts of other users\n        if (isCrossUser(callingUid, userId)) {\n            throw new SecurityException(\n                    String.format(\n                            \"User %s tying remove account for %s\" ,\n                            UserHandle.getCallingUserId(),\n                            userId));\n        }\n        /*\n         * Only the system, authenticator or profile owner should be allowed to remove accounts for\n         * that authenticator.  This will let users remove accounts (via Settings in the system) but\n         * not arbitrary applications (like competing authenticators).\n         */\n        UserHandle user = UserHandle.of(userId);\n        if (!isAccountManagedByCaller(account.type, callingUid, user.getIdentifier())\n                && !isSystemUid(callingUid)\n                && !isProfileOwner(callingUid)) {\n            String msg = String.format(\n                    \"uid %s cannot remove accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        if (!canUserModifyAccounts(userId, callingUid)) {\n            try {\n                response.onError(AccountManager.ERROR_CODE_USER_RESTRICTED,\n                        \"User cannot modify accounts\");\n            } catch (RemoteException re) {\n            }\n            return;\n        }\n        if (!canUserModifyAccountsForType(userId, account.type, callingUid)) {\n            try {\n                response.onError(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                        \"User cannot modify accounts of this type (policy).\");\n            } catch (RemoteException re) {\n                Log.w(TAG, \"RemoteException while removing account\", re);\n            }\n            return;\n        }\n        if (isFirstAccountRemovalDisabled(account)) {\n            try {\n                response.onError(\n                        AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                        \"User cannot remove the first \"\n                                + account.type\n                                + \" account on the device.\");\n            } catch (RemoteException re) {\n                Log.w(TAG, \"RemoteException while removing account\", re);\n            }\n            return;\n        }\n        final long identityToken = clearCallingIdentity();\n        UserAccounts accounts = getUserAccounts(userId);\n        cancelNotification(getSigninRequiredNotificationId(accounts, account), accounts);\n        synchronized(accounts.credentialsPermissionNotificationIds) {\n            for (Pair<Pair<Account, String>, Integer> pair:\n                accounts.credentialsPermissionNotificationIds.keySet()) {\n                if (account.equals(pair.first.first)) {\n                    NotificationId id = accounts.credentialsPermissionNotificationIds.get(pair);\n                    cancelNotification(id, accounts);\n                }\n            }\n        }\n        final long accountId = accounts.accountsDb.findDeAccountId(account);\n        logRecord(\n                AccountsDb.DEBUG_ACTION_CALLED_ACCOUNT_REMOVE,\n                AccountsDb.TABLE_ACCOUNTS,\n                accountId,\n                accounts,\n                callingUid);\n        try {\n            new RemoveAccountSession(accounts, response, account, expectActivityLaunch).bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public boolean removeAccountExplicitly(Account account) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"removeAccountExplicitly: \" + account\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        int userId = Binder.getCallingUserHandle().getIdentifier();\n        if (account == null) {\n            /*\n             * Null accounts should result in returning false, as per\n             * AccountManage.addAccountExplicitly(...) java doc.\n             */\n            Log.e(TAG, \"account is null\");\n            return false;\n        } else if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot explicitly remove accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        if (isFirstAccountRemovalDisabled(account)) {\n            Log.e(TAG, \"Cannot remove the first \" + account.type + \" account on the device.\");\n            return false;\n        }\n        UserAccounts accounts = getUserAccountsForCaller();\n        final long accountId = accounts.accountsDb.findDeAccountId(account);\n        logRecord(\n                AccountsDb.DEBUG_ACTION_CALLED_ACCOUNT_REMOVE,\n                AccountsDb.TABLE_ACCOUNTS,\n                accountId,\n                accounts,\n                callingUid);\n        final long identityToken = clearCallingIdentity();\n        try {\n            return removeAccountInternal(accounts, account, callingUid);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private class RemoveAccountSession extends Session {\n        final Account mAccount;\n        public RemoveAccountSession(UserAccounts accounts, IAccountManagerResponse response,\n                Account account, boolean expectActivityLaunch) {\n            super(accounts, response, account.type, expectActivityLaunch,\n                    true /* stripAuthTokenFromResult */, account.name,\n                    false /* authDetailsRequired */);\n            mAccount = account;\n        }\n\n        @Override\n        protected String toDebugString(long now) {\n            return super.toDebugString(now) + \", removeAccount\"\n                    + \", account \" + mAccount;\n        }\n\n        @Override\n        public void run() throws RemoteException {\n            mAuthenticator.getAccountRemovalAllowed(this, mAccount);\n        }\n\n        @Override\n        public void onResult(Bundle result) {\n            Bundle.setDefusable(result, true);\n            if (result != null && result.containsKey(AccountManager.KEY_BOOLEAN_RESULT)\n                    && !result.containsKey(AccountManager.KEY_INTENT)) {\n                final boolean removalAllowed = result.getBoolean(AccountManager.KEY_BOOLEAN_RESULT);\n                if (removalAllowed) {\n                    removeAccountInternal(mAccounts, mAccount, getCallingUid());\n                }\n                IAccountManagerResponse response = getResponseAndClose();\n                if (response != null) {\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, getClass().getSimpleName() + \" calling onResult() on response \"\n                                + response);\n                    }\n                    try {\n                        response.onResult(result);\n                    } catch (RemoteException e) {\n                        Slog.e(TAG, \"Error calling onResult()\", e);\n                    }\n                }\n            }\n            super.onResult(result);\n        }\n    }\n\n    @VisibleForTesting\n    protected void removeAccountInternal(Account account) {\n        removeAccountInternal(getUserAccountsForCaller(), account, getCallingUid());\n    }\n\n    private boolean removeAccountInternal(UserAccounts accounts, Account account, int callingUid) {\n        boolean isChanged = false;\n        boolean userUnlocked = isLocalUnlockedUser(accounts.userId);\n        if (!userUnlocked) {\n            Slog.i(TAG, \"Removing account \" + account.toSafeString()\n                    + \" while user \" + accounts.userId\n                    + \" is still locked. CE data will be removed later\");\n        }\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                Map<String, Integer> packagesToVisibility = getRequestingPackages(account,\n                        accounts);\n                List<String> accountRemovedReceivers =\n                    getAccountRemovedReceivers(account, accounts);\n                accounts.accountsDb.beginTransaction();\n                // Set to a placeholder value, this will only be used if the database\n                // transaction succeeds.\n                long accountId = -1;\n                try {\n                    accountId = accounts.accountsDb.findDeAccountId(account);\n                    if (accountId >= 0) {\n                        isChanged = accounts.accountsDb.deleteDeAccount(accountId);\n                    }\n                    // always delete from CE table if CE storage is available\n                    // DE account could be removed while CE was locked\n                    if (userUnlocked) {\n                        long ceAccountId = accounts.accountsDb.findCeAccountId(account);\n                        if (ceAccountId >= 0) {\n                            accounts.accountsDb.deleteCeAccount(ceAccountId);\n                        }\n                    }\n                    accounts.accountsDb.setTransactionSuccessful();\n                } finally {\n                    accounts.accountsDb.endTransaction();\n                }\n                if (isChanged) {\n                    removeAccountFromCacheLocked(accounts, account);\n                    for (Entry<String, Integer> packageToVisibility : packagesToVisibility\n                            .entrySet()) {\n                        if ((packageToVisibility.getValue() == AccountManager.VISIBILITY_VISIBLE)\n                                || (packageToVisibility.getValue()\n                                    == AccountManager.VISIBILITY_USER_MANAGED_VISIBLE)) {\n                            notifyPackage(packageToVisibility.getKey(), accounts);\n                        }\n                    }\n\n                    // Only broadcast LOGIN_ACCOUNTS_CHANGED if a change occurred.\n                    Log.i(TAG, \"callingUid=\" + callingUid + \", userId=\" + accounts.userId\n                            + \" removed account\");\n                    sendAccountsChangedBroadcast(\n                            accounts.userId, account.type, /*useCase=*/\"removeAccount\");\n                    for (String packageName : accountRemovedReceivers) {\n                        sendAccountRemovedBroadcast(\n                                account, packageName, accounts.userId, /*useCase=*/\"removeAccount\");\n                    }\n                    String action = userUnlocked ? AccountsDb.DEBUG_ACTION_ACCOUNT_REMOVE\n                            : AccountsDb.DEBUG_ACTION_ACCOUNT_REMOVE_DE;\n                    logRecord(action, AccountsDb.TABLE_ACCOUNTS, accountId, accounts);\n                }\n            }\n        }\n        final long id = Binder.clearCallingIdentity();\n        try {\n            int parentUserId = accounts.userId;\n            if (canHaveProfile(parentUserId)) {\n                // Remove from any restricted profiles that are sharing this account.\n                List<UserInfo> users = getUserManager().getAliveUsers();\n                for (UserInfo user : users) {\n                    if (user.isRestricted() && parentUserId == (user.restrictedProfileParentId)) {\n                        removeSharedAccountAsUser(account, user.id, callingUid);\n                    }\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(id);\n        }\n\n        if (isChanged) {\n            synchronized (accounts.credentialsPermissionNotificationIds) {\n                for (Pair<Pair<Account, String>, Integer> key\n                        : accounts.credentialsPermissionNotificationIds.keySet()) {\n                    if (account.equals(key.first.first)\n                            && AccountManager.ACCOUNT_ACCESS_TOKEN_TYPE.equals(key.first.second)) {\n                        final int uid = (Integer) key.second;\n                        mHandler.post(() -> cancelAccountAccessRequestNotificationIfNeeded(\n                                account, uid, false, accounts));\n                    }\n                }\n            }\n        }\n\n        AccountManager.invalidateLocalAccountUserDataCaches();\n\n        return isChanged;\n    }\n\n    @Override\n    public void invalidateAuthToken(String accountType, String authToken) {\n        int callerUid = Binder.getCallingUid();\n        Objects.requireNonNull(accountType, \"accountType cannot be null\");\n        Objects.requireNonNull(authToken, \"authToken cannot be null\");\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"invalidateAuthToken: accountType \" + accountType\n                    + \", caller's uid \" + callerUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        int userId = UserHandle.getCallingUserId();\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            List<Pair<Account, String>> deletedTokens;\n            synchronized (accounts.dbLock) {\n                accounts.accountsDb.beginTransaction();\n                try {\n                    deletedTokens = invalidateAuthTokenLocked(accounts, accountType, authToken);\n                    accounts.accountsDb.setTransactionSuccessful();\n                } finally {\n                    accounts.accountsDb.endTransaction();\n                }\n                synchronized (accounts.cacheLock) {\n                    for (Pair<Account, String> tokenInfo : deletedTokens) {\n                        Account act = tokenInfo.first;\n                        String tokenType = tokenInfo.second;\n                        writeAuthTokenIntoCacheLocked(accounts, act, tokenType, null);\n                    }\n                    // wipe out cached token in memory.\n                    accounts.accountTokenCaches.remove(accountType, authToken);\n                }\n            }\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private List<Pair<Account, String>> invalidateAuthTokenLocked(UserAccounts accounts, String accountType,\n            String authToken) {\n        // TODO Move to AccountsDB\n        List<Pair<Account, String>> results = new ArrayList<>();\n        Cursor cursor = accounts.accountsDb.findAuthtokenForAllAccounts(accountType, authToken);\n\n        try {\n            while (cursor.moveToNext()) {\n                String authTokenId = cursor.getString(0);\n                String accountName = cursor.getString(1);\n                String authTokenType = cursor.getString(2);\n                accounts.accountsDb.deleteAuthToken(authTokenId);\n                results.add(Pair.create(new Account(accountName, accountType), authTokenType));\n            }\n        } finally {\n            cursor.close();\n        }\n        return results;\n    }\n\n    private void saveCachedToken(\n            UserAccounts accounts,\n            Account account,\n            String callerPkg,\n            byte[] callerSigDigest,\n            String tokenType,\n            String token,\n            long expiryMillis) {\n\n        if (account == null || tokenType == null || callerPkg == null || callerSigDigest == null) {\n            return;\n        }\n        cancelNotification(getSigninRequiredNotificationId(accounts, account), accounts);\n        synchronized (accounts.cacheLock) {\n            accounts.accountTokenCaches.put(\n                    account, token, tokenType, callerPkg, callerSigDigest, expiryMillis);\n        }\n    }\n\n    private boolean saveAuthTokenToDatabase(UserAccounts accounts, Account account, String type,\n            String authToken) {\n        if (account == null || type == null) {\n            return false;\n        }\n        cancelNotification(getSigninRequiredNotificationId(accounts, account), accounts);\n        synchronized (accounts.dbLock) {\n            accounts.accountsDb.beginTransaction();\n            boolean updateCache = false;\n            try {\n                long accountId = accounts.accountsDb.findDeAccountId(account);\n                if (accountId < 0) {\n                    return false;\n                }\n                accounts.accountsDb.deleteAuthtokensByAccountIdAndType(accountId, type);\n                if (accounts.accountsDb.insertAuthToken(accountId, type, authToken) >= 0) {\n                    accounts.accountsDb.setTransactionSuccessful();\n                    updateCache = true;\n                    return true;\n                }\n                return false;\n            } finally {\n                accounts.accountsDb.endTransaction();\n                if (updateCache) {\n                    synchronized (accounts.cacheLock) {\n                        writeAuthTokenIntoCacheLocked(accounts, account, type, authToken);\n                    }\n                }\n            }\n        }\n    }\n\n    @Override\n    public String peekAuthToken(Account account, String authTokenType) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"peekAuthToken: \" + account\n                    + \", authTokenType \" + authTokenType\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        Objects.requireNonNull(authTokenType, \"authTokenType cannot be null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot peek the authtokens associated with accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        if (!isLocalUnlockedUser(userId)) {\n            Log.w(TAG, \"Authtoken not available - user \" + userId + \" data is locked. callingUid \"\n                    + callingUid);\n            return null;\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return readAuthTokenInternal(accounts, account, authTokenType);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void setAuthToken(Account account, String authTokenType, String authToken) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"setAuthToken: \" + account\n                    + \", authTokenType \" + authTokenType\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        Objects.requireNonNull(authTokenType, \"authTokenType cannot be null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot set auth tokens associated with accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            saveAuthTokenToDatabase(accounts, account, authTokenType, authToken);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void setPassword(Account account, String password) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"setAuthToken: \" + account\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot set secrets for accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            setPasswordInternal(accounts, account, password, callingUid);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private void setPasswordInternal(UserAccounts accounts, Account account, String password,\n            int callingUid) {\n        if (account == null) {\n            return;\n        }\n        boolean isChanged = false;\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                accounts.accountsDb.beginTransaction();\n                try {\n                    final long accountId = accounts.accountsDb.findDeAccountId(account);\n                    if (accountId >= 0) {\n                        accounts.accountsDb.updateCeAccountPassword(accountId, password);\n                        accounts.accountsDb.deleteAuthTokensByAccountId(accountId);\n                        accounts.authTokenCache.remove(account);\n                        accounts.accountTokenCaches.remove(account);\n                        accounts.accountsDb.setTransactionSuccessful();\n                        // If there is an account whose password will be updated and the database\n                        // transactions succeed, then we say that a change has occured. Even if the\n                        // new password is the same as the old and there were no authtokens to\n                        // delete.\n                        isChanged = true;\n                        String action = (password == null || password.length() == 0) ?\n                                AccountsDb.DEBUG_ACTION_CLEAR_PASSWORD\n                                : AccountsDb.DEBUG_ACTION_SET_PASSWORD;\n                        logRecord(action, AccountsDb.TABLE_ACCOUNTS, accountId, accounts,\n                                callingUid);\n                    }\n                } finally {\n                    accounts.accountsDb.endTransaction();\n                    if (isChanged) {\n                        // Send LOGIN_ACCOUNTS_CHANGED only if the something changed.\n                        sendNotificationAccountUpdated(account, accounts);\n                        Log.i(TAG, \"callingUid=\" + callingUid + \" changed password\");\n                        sendAccountsChangedBroadcast(\n                                accounts.userId, account.type, /*useCase=*/\"setPassword\");\n                    }\n                }\n            }\n        }\n    }\n\n    @Override\n    public void clearPassword(Account account) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"clearPassword: \" + account\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot clear passwords for accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            setPasswordInternal(accounts, account, null, callingUid);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void setUserData(Account account, String key, String value) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"setUserData: \" + account\n                    + \", key \" + key\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        if (key == null) throw new IllegalArgumentException(\"key is null\");\n        if (account == null) throw new IllegalArgumentException(\"account is null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot set user data for accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            if (!accountExistsCache(accounts, account)) {\n                return;\n            }\n            setUserdataInternal(accounts, account, key, value);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private boolean accountExistsCache(UserAccounts accounts, Account account) {\n        synchronized (accounts.cacheLock) {\n            if (accounts.accountCache.containsKey(account.type)) {\n                for (Account acc : accounts.accountCache.get(account.type)) {\n                    if (acc.name.equals(account.name)) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    private void setUserdataInternal(UserAccounts accounts, Account account, String key,\n            String value) {\n        synchronized (accounts.dbLock) {\n            accounts.accountsDb.beginTransaction();\n            try {\n                long accountId = accounts.accountsDb.findDeAccountId(account);\n                if (accountId < 0) {\n                    return;\n                }\n                long extrasId = accounts.accountsDb.findExtrasIdByAccountId(accountId, key);\n                if (extrasId < 0) {\n                    extrasId = accounts.accountsDb.insertExtra(accountId, key, value);\n                    if (extrasId < 0) {\n                        return;\n                    }\n                } else if (!accounts.accountsDb.updateExtra(extrasId, value)) {\n                    return;\n                }\n                accounts.accountsDb.setTransactionSuccessful();\n            } finally {\n                accounts.accountsDb.endTransaction();\n            }\n            synchronized (accounts.cacheLock) {\n                writeUserDataIntoCacheLocked(accounts, account, key, value);\n                AccountManager.invalidateLocalAccountUserDataCaches();\n            }\n        }\n    }\n\n    private void onResult(IAccountManagerResponse response, Bundle result) {\n        if (result == null) {\n            Log.e(TAG, \"the result is unexpectedly null\", new Exception());\n        }\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, getClass().getSimpleName() + \" calling onResult() on response \"\n                    + response);\n        }\n        try {\n            response.onResult(result);\n        } catch (RemoteException e) {\n            // if the caller is dead then there is no one to care about remote\n            // exceptions\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"failure while notifying response\", e);\n            }\n        }\n    }\n\n    @Override\n    public void getAuthTokenLabel(IAccountManagerResponse response, final String accountType,\n                                  final String authTokenType)\n            throws RemoteException {\n        Preconditions.checkArgument(accountType != null, \"accountType cannot be null\");\n        Preconditions.checkArgument(authTokenType != null, \"authTokenType cannot be null\");\n\n        final int callingUid = getCallingUid();\n        clearCallingIdentity();\n        if (UserHandle.getAppId(callingUid) != Process.SYSTEM_UID) {\n            throw new SecurityException(\"can only call from system\");\n        }\n        int userId = UserHandle.getUserId(callingUid);\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            new Session(accounts, response, accountType, false /* expectActivityLaunch */,\n                    false /* stripAuthTokenFromResult */,  null /* accountName */,\n                    false /* authDetailsRequired */) {\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now) + \", getAuthTokenLabel\"\n                            + \", \" + accountType\n                            + \", authTokenType \" + authTokenType;\n                }\n\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.getAuthTokenLabel(this, authTokenType);\n                }\n\n                @Override\n                public void onResult(Bundle result) {\n                    Bundle.setDefusable(result, true);\n                    if (result != null) {\n                        String label = result.getString(AccountManager.KEY_AUTH_TOKEN_LABEL);\n                        Bundle bundle = new Bundle();\n                        bundle.putString(AccountManager.KEY_AUTH_TOKEN_LABEL, label);\n                        super.onResult(bundle);\n                        return;\n                    } else {\n                        super.onResult(result);\n                    }\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void getAuthToken(\n            IAccountManagerResponse response,\n            final Account account,\n            final String authTokenType,\n            final boolean notifyOnAuthFailure,\n            final boolean expectActivityLaunch,\n            final Bundle loginOptions) {\n        Bundle.setDefusable(loginOptions, true);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"getAuthToken: \" + account\n                    + \", response \" + response\n                    + \", authTokenType \" + authTokenType\n                    + \", notifyOnAuthFailure \" + notifyOnAuthFailure\n                    + \", expectActivityLaunch \" + expectActivityLaunch\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Preconditions.checkArgument(response != null, \"response cannot be null\");\n        try {\n            if (account == null) {\n                Slog.w(TAG, \"getAuthToken called with null account\");\n                response.onError(AccountManager.ERROR_CODE_BAD_ARGUMENTS, \"account is null\");\n                return;\n            }\n            if (authTokenType == null) {\n                Slog.w(TAG, \"getAuthToken called with null authTokenType\");\n                response.onError(AccountManager.ERROR_CODE_BAD_ARGUMENTS, \"authTokenType is null\");\n                return;\n            }\n        } catch (RemoteException e) {\n            Slog.w(TAG, \"Failed to report error back to the client.\" + e);\n            return;\n        }\n        int userId = UserHandle.getCallingUserId();\n        final long ident = Binder.clearCallingIdentity();\n        final UserAccounts accounts;\n        final RegisteredServicesCache.ServiceInfo<AuthenticatorDescription> authenticatorInfo;\n        try {\n            accounts = getUserAccounts(userId);\n            authenticatorInfo = mAuthenticatorCache.getServiceInfo(\n                    AuthenticatorDescription.newKey(account.type), accounts.userId);\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n\n        final boolean customTokens =\n                authenticatorInfo != null && authenticatorInfo.type.customTokens;\n\n        // skip the check if customTokens\n        final int callerUid = Binder.getCallingUid();\n        final boolean permissionGranted =\n                customTokens || permissionIsGranted(account, authTokenType, callerUid, userId);\n\n        // Get the calling package. We will use it for the purpose of caching.\n        final String callerPkg = loginOptions.getString(AccountManager.KEY_ANDROID_PACKAGE_NAME);\n        String[] callerOwnedPackageNames;\n        final long ident2 = Binder.clearCallingIdentity();\n        try {\n            callerOwnedPackageNames = mPackageManager.getPackagesForUid(callerUid);\n        } finally {\n            Binder.restoreCallingIdentity(ident2);\n        }\n        if (callerPkg == null || callerOwnedPackageNames == null\n                || !ArrayUtils.contains(callerOwnedPackageNames, callerPkg)) {\n            String msg = String.format(\n                    \"Uid %s is attempting to illegally masquerade as package %s!\",\n                    callerUid,\n                    callerPkg);\n            throw new SecurityException(msg);\n        }\n\n        // let authenticator know the identity of the caller\n        loginOptions.putInt(AccountManager.KEY_CALLER_UID, callerUid);\n        loginOptions.putInt(AccountManager.KEY_CALLER_PID, Binder.getCallingPid());\n\n        if (notifyOnAuthFailure) {\n            loginOptions.putBoolean(AccountManager.KEY_NOTIFY_ON_FAILURE, true);\n        }\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            // Distill the caller's package signatures into a single digest.\n            final byte[] callerPkgSigDigest = calculatePackageSignatureDigest(callerPkg, userId);\n\n            // if the caller has permission, do the peek. otherwise go the more expensive\n            // route of starting a Session\n            if (!customTokens && permissionGranted) {\n                String authToken = readAuthTokenInternal(accounts, account, authTokenType);\n                if (authToken != null) {\n                    logGetAuthTokenMetrics(callerPkg, account.type);\n                    Bundle result = new Bundle();\n                    result.putString(AccountManager.KEY_AUTHTOKEN, authToken);\n                    result.putString(AccountManager.KEY_ACCOUNT_NAME, account.name);\n                    result.putString(AccountManager.KEY_ACCOUNT_TYPE, account.type);\n                    onResult(response, result);\n                    return;\n                }\n            }\n\n            if (customTokens) {\n                /*\n                 * Look up tokens in the new cache only if the loginOptions don't have parameters\n                 * outside of those expected to be injected by the AccountManager, e.g.\n                 * ANDORID_PACKAGE_NAME.\n                 */\n                TokenCache.Value cachedToken = readCachedTokenInternal(\n                        accounts,\n                        account,\n                        authTokenType,\n                        callerPkg,\n                        callerPkgSigDigest);\n                if (cachedToken != null) {\n                    logGetAuthTokenMetrics(callerPkg, account.type);\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, \"getAuthToken: cache hit ofr custom token authenticator.\");\n                    }\n                    Bundle result = new Bundle();\n                    result.putString(AccountManager.KEY_AUTHTOKEN, cachedToken.token);\n                    result.putLong(AbstractAccountAuthenticator.KEY_CUSTOM_TOKEN_EXPIRY,\n                            cachedToken.expiryEpochMillis);\n                    result.putString(AccountManager.KEY_ACCOUNT_NAME, account.name);\n                    result.putString(AccountManager.KEY_ACCOUNT_TYPE, account.type);\n                    onResult(response, result);\n                    return;\n                }\n            }\n\n            new Session(\n                    accounts,\n                    response,\n                    account.type,\n                    expectActivityLaunch,\n                    false /* stripAuthTokenFromResult */,\n                    account.name,\n                    false /* authDetailsRequired */) {\n                @Override\n                protected String toDebugString(long now) {\n                    if (loginOptions != null) loginOptions.keySet();\n                    return super.toDebugString(now) + \", getAuthToken\"\n                            + \", \" + account.toSafeString()\n                            + \", authTokenType \" + authTokenType\n                            + \", loginOptions \" + loginOptions\n                            + \", notifyOnAuthFailure \" + notifyOnAuthFailure;\n                }\n\n                @Override\n                public void run() throws RemoteException {\n                    // If the caller doesn't have permission then create and return the\n                    // \"grant permission\" intent instead of the \"getAuthToken\" intent.\n                    if (!permissionGranted) {\n                        mAuthenticator.getAuthTokenLabel(this, authTokenType);\n                    } else {\n                        mAuthenticator.getAuthToken(this, account, authTokenType, loginOptions);\n                        logGetAuthTokenMetrics(callerPkg, account.type);\n                    }\n                }\n\n                @Override\n                public void onResult(Bundle result) {\n                    Bundle.setDefusable(result, true);\n                    if (result != null) {\n                        if (result.containsKey(AccountManager.KEY_AUTH_TOKEN_LABEL)) {\n                            Intent intent = newGrantCredentialsPermissionIntent(\n                                    account,\n                                    null,\n                                    callerUid,\n                                    new AccountAuthenticatorResponse(this),\n                                    authTokenType,\n                                    true);\n                            mCanStartAccountManagerActivity = true;\n                            Bundle bundle = new Bundle();\n                            bundle.putParcelable(AccountManager.KEY_INTENT, intent);\n                            onResult(bundle);\n                            return;\n                        }\n                        String authToken = result.getString(AccountManager.KEY_AUTHTOKEN);\n                        if (authToken != null) {\n                            String name = result.getString(AccountManager.KEY_ACCOUNT_NAME);\n                            String type = result.getString(AccountManager.KEY_ACCOUNT_TYPE);\n                            if (TextUtils.isEmpty(type) || TextUtils.isEmpty(name)) {\n                                onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                                        \"the type and name should not be empty\");\n                                return;\n                            }\n                            Account resultAccount = new Account(name, type);\n                            if (!customTokens) {\n                                saveAuthTokenToDatabase(\n                                        mAccounts,\n                                        resultAccount,\n                                        authTokenType,\n                                        authToken);\n                            }\n                            long expiryMillis = result.getLong(\n                                    AbstractAccountAuthenticator.KEY_CUSTOM_TOKEN_EXPIRY, 0L);\n                            if (customTokens\n                                    && expiryMillis > System.currentTimeMillis()) {\n                                saveCachedToken(\n                                        mAccounts,\n                                        account,\n                                        callerPkg,\n                                        callerPkgSigDigest,\n                                        authTokenType,\n                                        authToken,\n                                        expiryMillis);\n                            }\n                        }\n\n                        Intent intent = result.getParcelable(AccountManager.KEY_INTENT, android.content.Intent.class);\n                        if (intent != null && notifyOnAuthFailure && !customTokens) {\n                            /*\n                             * Make sure that the supplied intent is owned by the authenticator\n                             * giving it to the system. Otherwise a malicious authenticator could\n                             * have users launching arbitrary activities by tricking users to\n                             * interact with malicious notifications.\n                             */\n                            if (!checkKeyIntent(\n                                    Binder.getCallingUid(),\n                                    result)) {\n                                onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                                        \"invalid intent in bundle returned\");\n                                return;\n                            }\n                            doNotification(\n                                    mAccounts,\n                                    account,\n                                    result.getString(AccountManager.KEY_AUTH_FAILED_MESSAGE),\n                                    intent, \"android\", accounts.userId);\n                        }\n                    }\n                    super.onResult(result);\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private void logGetAuthTokenMetrics(final String callerPackage, String accountType) {\n        // Although this is not a 'device policy' API, enterprise is the current use case.\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.GET_ACCOUNT_AUTH_TOKEN)\n                .setStrings(\n                        TextUtils.emptyIfNull(callerPackage),\n                        TextUtils.emptyIfNull(accountType))\n                .write();\n    }\n\n    private byte[] calculatePackageSignatureDigest(String callerPkg, int userId) {\n        MessageDigest digester;\n        try {\n            digester = MessageDigest.getInstance(\"SHA-256\");\n            PackageInfo pkgInfo = mPackageManager.getPackageInfoAsUser(\n                    callerPkg, PackageManager.GET_SIGNATURES, userId);\n            for (Signature sig : pkgInfo.signatures) {\n                digester.update(sig.toByteArray());\n            }\n        } catch (NoSuchAlgorithmException x) {\n            Log.wtf(TAG, \"SHA-256 should be available\", x);\n            digester = null;\n        } catch (NameNotFoundException e) {\n            Log.w(TAG, \"Could not find packageinfo for: \" + callerPkg);\n            digester = null;\n        }\n        return (digester == null) ? null : digester.digest();\n    }\n\n    private void createNoCredentialsPermissionNotification(Account account, Intent intent,\n            String packageName, UserAccounts accounts) {\n        int userId = accounts.userId;\n        int uid = intent.getIntExtra(\n                GrantCredentialsPermissionActivity.EXTRAS_REQUESTING_UID, -1);\n        String authTokenType = intent.getStringExtra(\n                GrantCredentialsPermissionActivity.EXTRAS_AUTH_TOKEN_TYPE);\n        final String titleAndSubtitle =\n                mContext.getString(R.string.permission_request_notification_for_app_with_subtitle,\n                getApplicationLabel(packageName, userId), account.name);\n        final int index = titleAndSubtitle.indexOf('\\n');\n        String title = titleAndSubtitle;\n        String subtitle = \"\";\n        if (index > 0) {\n            title = titleAndSubtitle.substring(0, index);\n            subtitle = titleAndSubtitle.substring(index + 1);\n        }\n        UserHandle user = UserHandle.of(userId);\n        Context contextForUser = getContextForUser(user);\n        Notification n =\n                new Notification.Builder(contextForUser, SystemNotificationChannels.ACCOUNT)\n                    .setSmallIcon(android.R.drawable.stat_sys_warning)\n                    .setWhen(0)\n                    .setColor(contextForUser.getColor(\n                            com.android.internal.R.color.system_notification_accent_color))\n                    .setContentTitle(title)\n                    .setContentText(subtitle)\n                    .setContentIntent(PendingIntent.getActivityAsUser(mContext, 0, intent,\n                            PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_IMMUTABLE,\n                            null, user))\n                    .build();\n        installNotification(getCredentialPermissionNotificationId(\n                account, authTokenType, uid, accounts), n, \"android\", user.getIdentifier());\n    }\n\n    private String getApplicationLabel(String packageName, int userId) {\n        try {\n            return mPackageManager.getApplicationLabel(\n                    mPackageManager.getApplicationInfoAsUser(packageName, 0, userId)).toString();\n        } catch (PackageManager.NameNotFoundException e) {\n            return packageName;\n        }\n    }\n\n    private Intent newGrantCredentialsPermissionIntent(Account account, String packageName,\n            int uid, AccountAuthenticatorResponse response, String authTokenType,\n            boolean startInNewTask) {\n\n        Intent intent = new Intent(mContext, GrantCredentialsPermissionActivity.class);\n\n        if (startInNewTask) {\n            // See FLAG_ACTIVITY_NEW_TASK docs for limitations and benefits of the flag.\n            // Since it was set in Eclair+ we can't change it without breaking apps using\n            // the intent from a non-Activity context. This is the default behavior.\n            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        }\n        UserAccounts accounts = getUserAccounts(UserHandle.getUserId(uid));\n        intent.addCategory(getCredentialPermissionNotificationId(account,\n                authTokenType, uid, accounts).mTag + (packageName != null ? packageName : \"\"));\n        intent.putExtra(GrantCredentialsPermissionActivity.EXTRAS_ACCOUNT, account);\n        intent.putExtra(GrantCredentialsPermissionActivity.EXTRAS_AUTH_TOKEN_TYPE, authTokenType);\n        intent.putExtra(GrantCredentialsPermissionActivity.EXTRAS_RESPONSE, response);\n        intent.putExtra(GrantCredentialsPermissionActivity.EXTRAS_REQUESTING_UID, uid);\n\n        return intent;\n    }\n\n    private NotificationId getCredentialPermissionNotificationId(Account account,\n            String authTokenType, int uid, UserAccounts accounts) {\n        NotificationId nId;\n        synchronized (accounts.credentialsPermissionNotificationIds) {\n            final Pair<Pair<Account, String>, Integer> key =\n                    new Pair<Pair<Account, String>, Integer>(\n                            new Pair<Account, String>(account, authTokenType), uid);\n            nId = accounts.credentialsPermissionNotificationIds.get(key);\n            if (nId == null) {\n                String tag = TAG + \":\" + SystemMessage.NOTE_ACCOUNT_CREDENTIAL_PERMISSION\n                        + \":\" + account.hashCode() + \":\" + authTokenType.hashCode() + \":\" + uid;\n                int id = SystemMessage.NOTE_ACCOUNT_CREDENTIAL_PERMISSION;\n                nId = new NotificationId(tag, id);\n                accounts.credentialsPermissionNotificationIds.put(key, nId);\n            }\n        }\n        return nId;\n    }\n\n    private NotificationId getSigninRequiredNotificationId(UserAccounts accounts, Account account) {\n        NotificationId nId;\n        synchronized (accounts.signinRequiredNotificationIds) {\n            nId = accounts.signinRequiredNotificationIds.get(account);\n            if (nId == null) {\n                String tag = TAG + \":\" + SystemMessage.NOTE_ACCOUNT_REQUIRE_SIGNIN\n                        + \":\" + account.hashCode();\n                int id = SystemMessage.NOTE_ACCOUNT_REQUIRE_SIGNIN;\n                nId = new NotificationId(tag, id);\n                accounts.signinRequiredNotificationIds.put(account, nId);\n            }\n        }\n        return nId;\n    }\n\n    @Override\n    public void addAccount(final IAccountManagerResponse response, final String accountType,\n            final String authTokenType, final String[] requiredFeatures,\n            final boolean expectActivityLaunch, final Bundle optionsIn) {\n        Bundle.setDefusable(optionsIn, true);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"addAccount: accountType \" + accountType\n                    + \", response \" + response\n                    + \", authTokenType \" + authTokenType\n                    + \", requiredFeatures \" + Arrays.toString(requiredFeatures)\n                    + \", expectActivityLaunch \" + expectActivityLaunch\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        if (response == null) throw new IllegalArgumentException(\"response is null\");\n        if (accountType == null) throw new IllegalArgumentException(\"accountType is null\");\n\n        // Is user disallowed from modifying accounts?\n        final int uid = Binder.getCallingUid();\n        final int userId = UserHandle.getUserId(uid);\n        if (!canUserModifyAccounts(userId, uid)) {\n            try {\n                response.onError(AccountManager.ERROR_CODE_USER_RESTRICTED,\n                        \"User is not allowed to add an account!\");\n            } catch (RemoteException re) {\n            }\n            showCantAddAccount(AccountManager.ERROR_CODE_USER_RESTRICTED, userId);\n            return;\n        }\n        if (!canUserModifyAccountsForType(userId, accountType, uid)) {\n            try {\n                response.onError(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                        \"User cannot modify accounts of this type (policy).\");\n            } catch (RemoteException re) {\n            }\n            showCantAddAccount(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                    userId);\n            return;\n        }\n        addAccountAndLogMetrics(response, accountType, authTokenType, requiredFeatures,\n                expectActivityLaunch, optionsIn, userId);\n    }\n\n    @Override\n    public void addAccountAsUser(final IAccountManagerResponse response, final String accountType,\n            final String authTokenType, final String[] requiredFeatures,\n            final boolean expectActivityLaunch, final Bundle optionsIn, int userId) {\n        Bundle.setDefusable(optionsIn, true);\n        int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"addAccount: accountType \" + accountType\n                    + \", response \" + response\n                    + \", authTokenType \" + authTokenType\n                    + \", requiredFeatures \" + Arrays.toString(requiredFeatures)\n                    + \", expectActivityLaunch \" + expectActivityLaunch\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid()\n                    + \", for user id \" + userId);\n        }\n        Preconditions.checkArgument(response != null, \"response cannot be null\");\n        Preconditions.checkArgument(accountType != null, \"accountType cannot be null\");\n        // Only allow the system process to add accounts of other users\n        if (isCrossUser(callingUid, userId)) {\n            throw new SecurityException(\n                    String.format(\n                            \"User %s trying to add account for %s\" ,\n                            UserHandle.getCallingUserId(),\n                            userId));\n        }\n\n        // Is user disallowed from modifying accounts?\n        if (!canUserModifyAccounts(userId, callingUid)) {\n            try {\n                response.onError(AccountManager.ERROR_CODE_USER_RESTRICTED,\n                        \"User is not allowed to add an account!\");\n            } catch (RemoteException re) {\n            }\n            showCantAddAccount(AccountManager.ERROR_CODE_USER_RESTRICTED, userId);\n            return;\n        }\n        if (!canUserModifyAccountsForType(userId, accountType, callingUid)) {\n            try {\n                response.onError(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                        \"User cannot modify accounts of this type (policy).\");\n            } catch (RemoteException re) {\n            }\n            showCantAddAccount(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                    userId);\n            return;\n        }\n        addAccountAndLogMetrics(response, accountType, authTokenType, requiredFeatures,\n                expectActivityLaunch, optionsIn, userId);\n    }\n\n    private void addAccountAndLogMetrics(\n            IAccountManagerResponse response, String accountType,\n            String authTokenType, String[] requiredFeatures,\n            boolean expectActivityLaunch, Bundle optionsIn, int userId) {\n        final int pid = Binder.getCallingPid();\n        final int uid = Binder.getCallingUid();\n        final Bundle options = (optionsIn == null) ? new Bundle() : optionsIn;\n        options.putInt(AccountManager.KEY_CALLER_UID, uid);\n        options.putInt(AccountManager.KEY_CALLER_PID, pid);\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            logRecordWithUid(\n                    accounts, AccountsDb.DEBUG_ACTION_CALLED_ACCOUNT_ADD, AccountsDb.TABLE_ACCOUNTS,\n                    uid);\n            new Session(accounts, response, accountType, expectActivityLaunch,\n                    true /* stripAuthTokenFromResult */, null /* accountName */,\n                    false /* authDetailsRequired */, true /* updateLastAuthenticationTime */) {\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.addAccount(\n                            this, mAccountType, authTokenType, requiredFeatures, options);\n                    String callerPackage = options.getString(\n                            AccountManager.KEY_ANDROID_PACKAGE_NAME);\n                    logAddAccountMetrics(\n                            callerPackage, accountType, requiredFeatures, authTokenType);\n                }\n\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now) + \", addAccount\"\n                            + \", accountType \" + accountType\n                            + \", requiredFeatures \"\n                            + (requiredFeatures != null\n                            ? TextUtils.join(\",\", requiredFeatures)\n                            : null);\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private void logAddAccountMetrics(\n            String callerPackage, String accountType, String[] requiredFeatures,\n            String authTokenType) {\n        // Although this is not a 'device policy' API, enterprise is the current use case.\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.ADD_ACCOUNT)\n                .setStrings(\n                        TextUtils.emptyIfNull(accountType),\n                        TextUtils.emptyIfNull(callerPackage),\n                        TextUtils.emptyIfNull(authTokenType),\n                        requiredFeatures == null\n                                ? \"\"\n                                : TextUtils.join(\";\", requiredFeatures))\n                .write();\n    }\n\n    @Override\n    public void startAddAccountSession(\n            final IAccountManagerResponse response,\n            final String accountType,\n            final String authTokenType,\n            final String[] requiredFeatures,\n            final boolean expectActivityLaunch,\n            final Bundle optionsIn) {\n        Bundle.setDefusable(optionsIn, true);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG,\n                    \"startAddAccountSession: accountType \" + accountType\n                    + \", response \" + response\n                    + \", authTokenType \" + authTokenType\n                    + \", requiredFeatures \" + Arrays.toString(requiredFeatures)\n                    + \", expectActivityLaunch \" + expectActivityLaunch\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Preconditions.checkArgument(response != null, \"response cannot be null\");\n        Preconditions.checkArgument(accountType != null, \"accountType cannot be null\");\n\n        final int uid = Binder.getCallingUid();\n        final int userId = UserHandle.getUserId(uid);\n        if (!canUserModifyAccounts(userId, uid)) {\n            try {\n                response.onError(AccountManager.ERROR_CODE_USER_RESTRICTED,\n                        \"User is not allowed to add an account!\");\n            } catch (RemoteException re) {\n            }\n            showCantAddAccount(AccountManager.ERROR_CODE_USER_RESTRICTED, userId);\n            return;\n        }\n        if (!canUserModifyAccountsForType(userId, accountType, uid)) {\n            try {\n                response.onError(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                        \"User cannot modify accounts of this type (policy).\");\n            } catch (RemoteException re) {\n            }\n            showCantAddAccount(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                    userId);\n            return;\n        }\n        final int pid = Binder.getCallingPid();\n        final Bundle options = (optionsIn == null) ? new Bundle() : optionsIn;\n        options.putInt(AccountManager.KEY_CALLER_UID, uid);\n        options.putInt(AccountManager.KEY_CALLER_PID, pid);\n\n        // Check to see if the Password should be included to the caller.\n        String callerPkg = options.getString(AccountManager.KEY_ANDROID_PACKAGE_NAME);\n        boolean isPasswordForwardingAllowed = checkPermissionAndNote(\n                callerPkg, uid, Manifest.permission.GET_PASSWORD);\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            logRecordWithUid(accounts, AccountsDb.DEBUG_ACTION_CALLED_START_ACCOUNT_ADD,\n                    AccountsDb.TABLE_ACCOUNTS, uid);\n            new StartAccountSession(\n                    accounts,\n                    response,\n                    accountType,\n                    expectActivityLaunch,\n                    null /* accountName */,\n                    false /* authDetailsRequired */,\n                    true /* updateLastAuthenticationTime */,\n                    isPasswordForwardingAllowed) {\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.startAddAccountSession(this, mAccountType, authTokenType,\n                            requiredFeatures, options);\n                    logAddAccountMetrics(callerPkg, accountType, requiredFeatures, authTokenType);\n                }\n\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now) + \", startAddAccountSession\" + \", accountType \"\n                            + accountType + \", requiredFeatures \"\n                            + (requiredFeatures != null\n                                ? TextUtils.join(\",\", requiredFeatures) : \"null\");\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    /** Session that will encrypt the KEY_ACCOUNT_SESSION_BUNDLE in result. */\n    private abstract class StartAccountSession extends Session {\n\n        private final boolean mIsPasswordForwardingAllowed;\n\n        public StartAccountSession(\n                UserAccounts accounts,\n                IAccountManagerResponse response,\n                String accountType,\n                boolean expectActivityLaunch,\n                String accountName,\n                boolean authDetailsRequired,\n                boolean updateLastAuthenticationTime,\n                boolean isPasswordForwardingAllowed) {\n            super(accounts, response, accountType, expectActivityLaunch,\n                    true /* stripAuthTokenFromResult */, accountName, authDetailsRequired,\n                    updateLastAuthenticationTime);\n            mIsPasswordForwardingAllowed = isPasswordForwardingAllowed;\n        }\n\n        @Override\n        public void onResult(Bundle result) {\n            Bundle.setDefusable(result, true);\n            mNumResults++;\n            Intent intent = null;\n            if (result != null) {\n                if (!checkKeyIntent(\n                        Binder.getCallingUid(),\n                        result)) {\n                    onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                            \"invalid intent in bundle returned\");\n                    return;\n                }\n            }\n            IAccountManagerResponse response;\n            if (mExpectActivityLaunch && result != null\n                    && result.containsKey(AccountManager.KEY_INTENT)) {\n                response = mResponse;\n            } else {\n                response = getResponseAndClose();\n            }\n            if (response == null) {\n                return;\n            }\n            if (result == null) {\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.v(TAG, getClass().getSimpleName() + \" calling onError() on response \"\n                            + response);\n                }\n                sendErrorResponse(response, AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                        \"null bundle returned\");\n                return;\n            }\n\n            if ((result.getInt(AccountManager.KEY_ERROR_CODE, -1) > 0) && (intent == null)) {\n                // All AccountManager error codes are greater\n                // than 0\n                sendErrorResponse(response, result.getInt(AccountManager.KEY_ERROR_CODE),\n                        result.getString(AccountManager.KEY_ERROR_MESSAGE));\n                return;\n            }\n\n            // Omit passwords if the caller isn't permitted to see them.\n            if (!mIsPasswordForwardingAllowed) {\n                result.remove(AccountManager.KEY_PASSWORD);\n            }\n\n            // Strip auth token from result.\n            result.remove(AccountManager.KEY_AUTHTOKEN);\n            if (!checkKeyIntent(Binder.getCallingUid(), result)) {\n                onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                        \"invalid intent in bundle returned\");\n                return;\n            }\n\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG,\n                        getClass().getSimpleName() + \" calling onResult() on response \" + response);\n            }\n\n            // Get the session bundle created by authenticator. The\n            // bundle contains data necessary for finishing the session\n            // later. The session bundle will be encrypted here and\n            // decrypted later when trying to finish the session.\n            Bundle sessionBundle = result.getBundle(AccountManager.KEY_ACCOUNT_SESSION_BUNDLE);\n            if (sessionBundle != null) {\n                String accountType = sessionBundle.getString(AccountManager.KEY_ACCOUNT_TYPE);\n                if (TextUtils.isEmpty(accountType)\n                        || !mAccountType.equalsIgnoreCase(accountType)) {\n                    Log.w(TAG, \"Account type in session bundle doesn't match request.\");\n                }\n                // Add accountType info to session bundle. This will\n                // override any value set by authenticator.\n                sessionBundle.putString(AccountManager.KEY_ACCOUNT_TYPE, mAccountType);\n\n                // Encrypt session bundle before returning to caller.\n                try {\n                    CryptoHelper cryptoHelper = CryptoHelper.getInstance();\n                    Bundle encryptedBundle = cryptoHelper.encryptBundle(sessionBundle);\n                    result.putBundle(AccountManager.KEY_ACCOUNT_SESSION_BUNDLE, encryptedBundle);\n                } catch (GeneralSecurityException e) {\n                    if (Log.isLoggable(TAG, Log.DEBUG)) {\n                        Log.v(TAG, \"Failed to encrypt session bundle!\", e);\n                    }\n                    sendErrorResponse(response, AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                            \"failed to encrypt session bundle\");\n                    return;\n                }\n            }\n\n            sendResponse(response, result);\n        }\n    }\n\n    @Override\n    public void finishSessionAsUser(IAccountManagerResponse response,\n            @NonNull Bundle sessionBundle,\n            boolean expectActivityLaunch,\n            Bundle appInfo,\n            int userId) {\n        Bundle.setDefusable(sessionBundle, true);\n        int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG,\n                    \"finishSession: response \"+ response\n                            + \", expectActivityLaunch \" + expectActivityLaunch\n                            + \", caller's uid \" + callingUid\n                            + \", caller's user id \" + UserHandle.getCallingUserId()\n                            + \", pid \" + Binder.getCallingPid()\n                            + \", for user id \" + userId);\n        }\n        Preconditions.checkArgument(response != null, \"response cannot be null\");\n        // Session bundle is the encrypted bundle of the original bundle created by authenticator.\n        // Account type is added to it before encryption.\n        if (sessionBundle == null || sessionBundle.size() == 0) {\n            throw new IllegalArgumentException(\"sessionBundle is empty\");\n        }\n\n        // Only allow the system process to finish session for other users.\n        if (isCrossUser(callingUid, userId)) {\n            throw new SecurityException(\n                    String.format(\n                            \"User %s trying to finish session for %s without cross user permission\",\n                            UserHandle.getCallingUserId(),\n                            userId));\n        }\n\n        if (!canUserModifyAccounts(userId, callingUid)) {\n            sendErrorResponse(response,\n                    AccountManager.ERROR_CODE_USER_RESTRICTED,\n                    \"User is not allowed to add an account!\");\n            showCantAddAccount(AccountManager.ERROR_CODE_USER_RESTRICTED, userId);\n            return;\n        }\n\n        final int pid = Binder.getCallingPid();\n        final Bundle decryptedBundle;\n        final String accountType;\n        // First decrypt session bundle to get account type for checking permission.\n        try {\n            CryptoHelper cryptoHelper = CryptoHelper.getInstance();\n            decryptedBundle = cryptoHelper.decryptBundle(sessionBundle);\n            if (decryptedBundle == null) {\n                sendErrorResponse(\n                        response,\n                        AccountManager.ERROR_CODE_BAD_REQUEST,\n                        \"failed to decrypt session bundle\");\n                return;\n            }\n            accountType = decryptedBundle.getString(AccountManager.KEY_ACCOUNT_TYPE);\n            // Account type cannot be null. This should not happen if session bundle was created\n            // properly by #StartAccountSession.\n            if (TextUtils.isEmpty(accountType)) {\n                sendErrorResponse(\n                        response,\n                        AccountManager.ERROR_CODE_BAD_ARGUMENTS,\n                        \"accountType is empty\");\n                return;\n            }\n\n            // If by any chances, decryptedBundle contains colliding keys with\n            // system info\n            // such as AccountManager.KEY_ANDROID_PACKAGE_NAME required by the add account flow or\n            // update credentials flow, we should replace with the new values of the current call.\n            if (appInfo != null) {\n                decryptedBundle.putAll(appInfo);\n            }\n\n            // Add info that may be used by add account or update credentials flow.\n            decryptedBundle.putInt(AccountManager.KEY_CALLER_UID, callingUid);\n            decryptedBundle.putInt(AccountManager.KEY_CALLER_PID, pid);\n        } catch (GeneralSecurityException e) {\n            if (Log.isLoggable(TAG, Log.DEBUG)) {\n                Log.v(TAG, \"Failed to decrypt session bundle!\", e);\n            }\n            sendErrorResponse(\n                    response,\n                    AccountManager.ERROR_CODE_BAD_REQUEST,\n                    \"failed to decrypt session bundle\");\n            return;\n        }\n\n        if (!canUserModifyAccountsForType(userId, accountType, callingUid)) {\n            sendErrorResponse(\n                    response,\n                    AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                    \"User cannot modify accounts of this type (policy).\");\n            showCantAddAccount(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                    userId);\n            return;\n        }\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            logRecordWithUid(\n                    accounts,\n                    AccountsDb.DEBUG_ACTION_CALLED_ACCOUNT_SESSION_FINISH,\n                    AccountsDb.TABLE_ACCOUNTS,\n                    callingUid);\n            new Session(\n                    accounts,\n                    response,\n                    accountType,\n                    expectActivityLaunch,\n                    true /* stripAuthTokenFromResult */,\n                    null /* accountName */,\n                    false /* authDetailsRequired */,\n                    true /* updateLastAuthenticationTime */) {\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.finishSession(this, mAccountType, decryptedBundle);\n                }\n\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now)\n                            + \", finishSession\"\n                            + \", accountType \" + accountType;\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private void showCantAddAccount(int errorCode, int userId) {\n        final DevicePolicyManagerInternal dpmi =\n                LocalServices.getService(DevicePolicyManagerInternal.class);\n        Intent intent = null;\n        if (dpmi == null) {\n            intent = getDefaultCantAddAccountIntent(errorCode);\n        } else if (errorCode == AccountManager.ERROR_CODE_USER_RESTRICTED) {\n            intent = dpmi.createUserRestrictionSupportIntent(userId,\n                    UserManager.DISALLOW_MODIFY_ACCOUNTS);\n        } else if (errorCode == AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE) {\n            intent = dpmi.createShowAdminSupportIntent(userId, false);\n        }\n        if (intent == null) {\n            intent = getDefaultCantAddAccountIntent(errorCode);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            mContext.startActivityAsUser(intent, new UserHandle(userId));\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    /**\n     * Called when we don't know precisely who is preventing us from adding an account.\n     */\n    private Intent getDefaultCantAddAccountIntent(int errorCode) {\n        Intent cantAddAccount = new Intent(mContext, CantAddAccountActivity.class);\n        cantAddAccount.putExtra(CantAddAccountActivity.EXTRA_ERROR_CODE, errorCode);\n        cantAddAccount.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        return cantAddAccount;\n    }\n\n    @Override\n    public void confirmCredentialsAsUser(\n            IAccountManagerResponse response,\n            final Account account,\n            final Bundle options,\n            final boolean expectActivityLaunch,\n            int userId) {\n        Bundle.setDefusable(options, true);\n        int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"confirmCredentials: \" + account\n                    + \", response \" + response\n                    + \", expectActivityLaunch \" + expectActivityLaunch\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        // Only allow the system process to read accounts of other users\n        if (isCrossUser(callingUid, userId)) {\n            throw new SecurityException(\n                    String.format(\n                            \"User %s trying to confirm account credentials for %s\" ,\n                            UserHandle.getCallingUserId(),\n                            userId));\n        }\n        if (response == null) throw new IllegalArgumentException(\"response is null\");\n        if (account == null) throw new IllegalArgumentException(\"account is null\");\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            new Session(accounts, response, account.type, expectActivityLaunch,\n                    true /* stripAuthTokenFromResult */, account.name,\n                    true /* authDetailsRequired */, true /* updateLastAuthenticatedTime */) {\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.confirmCredentials(this, account, options);\n                }\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now) + \", confirmCredentials\"\n                            + \", \" + account.toSafeString();\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void updateCredentials(IAccountManagerResponse response, final Account account,\n            final String authTokenType, final boolean expectActivityLaunch,\n            final Bundle loginOptions) {\n        Bundle.setDefusable(loginOptions, true);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"updateCredentials: \" + account\n                    + \", response \" + response\n                    + \", authTokenType \" + authTokenType\n                    + \", expectActivityLaunch \" + expectActivityLaunch\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        if (response == null) throw new IllegalArgumentException(\"response is null\");\n        if (account == null) throw new IllegalArgumentException(\"account is null\");\n        int userId = UserHandle.getCallingUserId();\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            new Session(accounts, response, account.type, expectActivityLaunch,\n                    true /* stripAuthTokenFromResult */, account.name,\n                    false /* authDetailsRequired */, true /* updateLastCredentialTime */) {\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.updateCredentials(this, account, authTokenType, loginOptions);\n                }\n                @Override\n                protected String toDebugString(long now) {\n                    if (loginOptions != null) loginOptions.keySet();\n                    return super.toDebugString(now) + \", updateCredentials\"\n                            + \", \" + account.toSafeString()\n                            + \", authTokenType \" + authTokenType\n                            + \", loginOptions \" + loginOptions;\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void startUpdateCredentialsSession(\n            IAccountManagerResponse response,\n            final Account account,\n            final String authTokenType,\n            final boolean expectActivityLaunch,\n            final Bundle loginOptions) {\n        Bundle.setDefusable(loginOptions, true);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG,\n                    \"startUpdateCredentialsSession: \" + account + \", response \" + response\n                            + \", authTokenType \" + authTokenType + \", expectActivityLaunch \"\n                            + expectActivityLaunch + \", caller's uid \" + Binder.getCallingUid()\n                            + \", pid \" + Binder.getCallingPid());\n        }\n        if (response == null) {\n            throw new IllegalArgumentException(\"response is null\");\n        }\n        if (account == null) {\n            throw new IllegalArgumentException(\"account is null\");\n        }\n\n        final int uid = Binder.getCallingUid();\n        int userId = UserHandle.getCallingUserId();\n\n        // Check to see if the Password should be included to the caller.\n        String callerPkg = loginOptions.getString(AccountManager.KEY_ANDROID_PACKAGE_NAME);\n        boolean isPasswordForwardingAllowed = checkPermissionAndNote(\n                callerPkg, uid, Manifest.permission.GET_PASSWORD);\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            new StartAccountSession(\n                    accounts,\n                    response,\n                    account.type,\n                    expectActivityLaunch,\n                    account.name,\n                    false /* authDetailsRequired */,\n                    true /* updateLastCredentialTime */,\n                    isPasswordForwardingAllowed) {\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.startUpdateCredentialsSession(this, account, authTokenType,\n                            loginOptions);\n                }\n\n                @Override\n                protected String toDebugString(long now) {\n                    if (loginOptions != null)\n                        loginOptions.keySet();\n                    return super.toDebugString(now)\n                            + \", startUpdateCredentialsSession\"\n                            + \", \" + account.toSafeString()\n                            + \", authTokenType \" + authTokenType\n                            + \", loginOptions \" + loginOptions;\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void isCredentialsUpdateSuggested(\n            IAccountManagerResponse response,\n            final Account account,\n            final String statusToken) {\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG,\n                    \"isCredentialsUpdateSuggested: \" + account + \", response \" + response\n                            + \", caller's uid \" + Binder.getCallingUid()\n                            + \", pid \" + Binder.getCallingPid());\n        }\n        if (response == null) {\n            throw new IllegalArgumentException(\"response is null\");\n        }\n        if (account == null) {\n            throw new IllegalArgumentException(\"account is null\");\n        }\n        if (TextUtils.isEmpty(statusToken)) {\n            throw new IllegalArgumentException(\"status token is empty\");\n        }\n\n        int usrId = UserHandle.getCallingUserId();\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(usrId);\n            new Session(accounts, response, account.type, false /* expectActivityLaunch */,\n                    false /* stripAuthTokenFromResult */, account.name,\n                    false /* authDetailsRequired */) {\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now) + \", isCredentialsUpdateSuggested\"\n                            + \", \" + account.toSafeString();\n                }\n\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.isCredentialsUpdateSuggested(this, account, statusToken);\n                }\n\n                @Override\n                public void onResult(Bundle result) {\n                    Bundle.setDefusable(result, true);\n                    IAccountManagerResponse response = getResponseAndClose();\n                    if (response == null) {\n                        return;\n                    }\n\n                    if (result == null) {\n                        sendErrorResponse(\n                                response,\n                                AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                                \"null bundle\");\n                        return;\n                    }\n\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, getClass().getSimpleName() + \" calling onResult() on response \"\n                                + response);\n                    }\n                    // Check to see if an error occurred. We know if an error occurred because all\n                    // error codes are greater than 0.\n                    if ((result.getInt(AccountManager.KEY_ERROR_CODE, -1) > 0)) {\n                        sendErrorResponse(response,\n                                result.getInt(AccountManager.KEY_ERROR_CODE),\n                                result.getString(AccountManager.KEY_ERROR_MESSAGE));\n                        return;\n                    }\n                    if (!result.containsKey(AccountManager.KEY_BOOLEAN_RESULT)) {\n                        sendErrorResponse(\n                                response,\n                                AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                                \"no result in response\");\n                        return;\n                    }\n                    final Bundle newResult = new Bundle();\n                    newResult.putBoolean(AccountManager.KEY_BOOLEAN_RESULT,\n                            result.getBoolean(AccountManager.KEY_BOOLEAN_RESULT, false));\n                    sendResponse(response, newResult);\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void editProperties(IAccountManagerResponse response, final String accountType,\n            final boolean expectActivityLaunch) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"editProperties: accountType \" + accountType\n                    + \", response \" + response\n                    + \", expectActivityLaunch \" + expectActivityLaunch\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        if (response == null) throw new IllegalArgumentException(\"response is null\");\n        if (accountType == null) throw new IllegalArgumentException(\"accountType is null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(accountType, callingUid, userId)\n                && !isSystemUid(callingUid)) {\n            String msg = String.format(\n                    \"uid %s cannot edit authenticator properites for account type: %s\",\n                    callingUid,\n                    accountType);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            new Session(accounts, response, accountType, expectActivityLaunch,\n                    true /* stripAuthTokenFromResult */, null /* accountName */,\n                    false /* authDetailsRequired */) {\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.editProperties(this, mAccountType);\n                }\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now) + \", editProperties\"\n                            + \", accountType \" + accountType;\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public boolean hasAccountAccess(@NonNull Account account,  @NonNull String packageName,\n            @NonNull UserHandle userHandle) {\n        if (UserHandle.getAppId(Binder.getCallingUid()) != Process.SYSTEM_UID) {\n            throw new SecurityException(\"Can be called only by system UID\");\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        Objects.requireNonNull(packageName, \"packageName cannot be null\");\n        Objects.requireNonNull(userHandle, \"userHandle cannot be null\");\n\n        final int userId = userHandle.getIdentifier();\n\n        Preconditions.checkArgumentInRange(userId, 0, Integer.MAX_VALUE, \"user must be concrete\");\n\n        try {\n            int uid = mPackageManager.getPackageUidAsUser(packageName, userId);\n            return hasAccountAccess(account, packageName, uid);\n        } catch (NameNotFoundException e) {\n            Log.w(TAG, \"hasAccountAccess#Package not found \" + e.getMessage());\n            return false;\n        }\n    }\n\n    // Returns package with oldest target SDK for given UID.\n    private String getPackageNameForUid(int uid) {\n        String[] packageNames = mPackageManager.getPackagesForUid(uid);\n        if (ArrayUtils.isEmpty(packageNames)) {\n            return null;\n        }\n        String packageName = packageNames[0];\n        if (packageNames.length == 1) {\n            return packageName;\n        }\n        // Due to visibility changes we want to use package with oldest target SDK\n        int oldestVersion = Integer.MAX_VALUE;\n        for (String name : packageNames) {\n            try {\n                ApplicationInfo applicationInfo = mPackageManager.getApplicationInfo(name, 0);\n                if (applicationInfo != null) {\n                    int version = applicationInfo.targetSdkVersion;\n                    if (version < oldestVersion) {\n                        oldestVersion = version;\n                        packageName = name;\n                    }\n                }\n            } catch (NameNotFoundException e) {\n                // skip\n            }\n        }\n        return packageName;\n    }\n\n    private boolean hasAccountAccess(@NonNull Account account, @Nullable String packageName,\n            int uid) {\n        if (packageName == null) {\n            packageName = getPackageNameForUid(uid);\n            if (packageName == null) {\n                return false;\n            }\n        }\n\n        // Use null token which means any token. Having a token means the package\n        // is trusted by the authenticator, hence it is fine to access the account.\n        if (permissionIsGranted(account, null, uid, UserHandle.getUserId(uid))) {\n            return true;\n        }\n        // In addition to the permissions required to get an auth token we also allow\n        // the account to be accessed by apps for which user or authenticator granted visibility.\n\n        int visibility = resolveAccountVisibility(account, packageName,\n            getUserAccounts(UserHandle.getUserId(uid)));\n        return (visibility == AccountManager.VISIBILITY_VISIBLE\n            || visibility == AccountManager.VISIBILITY_USER_MANAGED_VISIBLE);\n    }\n\n    @Override\n    public IntentSender createRequestAccountAccessIntentSenderAsUser(@NonNull Account account,\n            @NonNull String packageName, @NonNull UserHandle userHandle) {\n        if (UserHandle.getAppId(Binder.getCallingUid()) != Process.SYSTEM_UID) {\n            throw new SecurityException(\"Can be called only by system UID\");\n        }\n\n        Objects.requireNonNull(account, \"account cannot be null\");\n        Objects.requireNonNull(packageName, \"packageName cannot be null\");\n        Objects.requireNonNull(userHandle, \"userHandle cannot be null\");\n\n        final int userId = userHandle.getIdentifier();\n\n        Preconditions.checkArgumentInRange(userId, 0, Integer.MAX_VALUE, \"user must be concrete\");\n\n        final int uid;\n        try {\n            uid = mPackageManager.getPackageUidAsUser(packageName, userId);\n        } catch (NameNotFoundException e) {\n            Slog.e(TAG, \"Unknown package \" + packageName);\n            return null;\n        }\n\n        Intent intent = newRequestAccountAccessIntent(account, packageName, uid, null);\n\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            return PendingIntent.getActivityAsUser(\n                    mContext, 0, intent, PendingIntent.FLAG_ONE_SHOT\n                            | PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_IMMUTABLE,\n                    null, new UserHandle(userId)).getIntentSender();\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    private Intent newRequestAccountAccessIntent(Account account, String packageName,\n            int uid, RemoteCallback callback) {\n        return newGrantCredentialsPermissionIntent(account, packageName, uid,\n                new AccountAuthenticatorResponse(new IAccountAuthenticatorResponse.Stub() {\n            @Override\n            public void onResult(Bundle value) throws RemoteException {\n                handleAuthenticatorResponse(true);\n            }\n\n            @Override\n            public void onRequestContinued() {\n                /* ignore */\n            }\n\n            @Override\n            public void onError(int errorCode, String errorMessage) throws RemoteException {\n                handleAuthenticatorResponse(false);\n            }\n\n            private void handleAuthenticatorResponse(boolean accessGranted) throws RemoteException {\n                UserAccounts userAccounts = getUserAccounts(UserHandle.getUserId(uid));\n                cancelNotification(getCredentialPermissionNotificationId(account,\n                        AccountManager.ACCOUNT_ACCESS_TOKEN_TYPE, uid, userAccounts), userAccounts);\n                if (callback != null) {\n                    Bundle result = new Bundle();\n                    result.putBoolean(AccountManager.KEY_BOOLEAN_RESULT, accessGranted);\n                    callback.sendResult(result);\n                }\n            }\n        }), AccountManager.ACCOUNT_ACCESS_TOKEN_TYPE, false);\n    }\n\n    @Override\n    public boolean someUserHasAccount(@NonNull final Account account) {\n        if (!UserHandle.isSameApp(Process.SYSTEM_UID, Binder.getCallingUid())) {\n            throw new SecurityException(\"Only system can check for accounts across users\");\n        }\n        final long token = Binder.clearCallingIdentity();\n        try {\n            AccountAndUser[] allAccounts = getAllAccountsForSystemProcess();\n            for (int i = allAccounts.length - 1; i >= 0; i--) {\n                if (allAccounts[i].account.equals(account)) {\n                    return true;\n                }\n            }\n            return false;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private class GetAccountsByTypeAndFeatureSession extends Session {\n        private final String[] mFeatures;\n        private volatile Account[] mAccountsOfType = null;\n        private volatile ArrayList<Account> mAccountsWithFeatures = null;\n        private volatile int mCurrentAccount = 0;\n        private final int mCallingUid;\n        private final String mPackageName;\n        private final boolean mIncludeManagedNotVisible;\n\n        public GetAccountsByTypeAndFeatureSession(\n                UserAccounts accounts,\n                IAccountManagerResponse response,\n                String type,\n                String[] features,\n                int callingUid,\n                String packageName,\n                boolean includeManagedNotVisible) {\n            super(accounts, response, type, false /* expectActivityLaunch */,\n                    true /* stripAuthTokenFromResult */, null /* accountName */,\n                    false /* authDetailsRequired */);\n            mCallingUid = callingUid;\n            mFeatures = features;\n            mPackageName = packageName;\n            mIncludeManagedNotVisible = includeManagedNotVisible;\n        }\n\n        @Override\n        public void run() throws RemoteException {\n            mAccountsOfType = getAccountsFromCache(mAccounts, mAccountType,\n                    mCallingUid, mPackageName, mIncludeManagedNotVisible);\n            // check whether each account matches the requested features\n            mAccountsWithFeatures = new ArrayList<>(mAccountsOfType.length);\n            mCurrentAccount = 0;\n\n            checkAccount();\n        }\n\n        public void checkAccount() {\n            if (mCurrentAccount >= mAccountsOfType.length) {\n                sendResult();\n                return;\n            }\n\n            final IAccountAuthenticator accountAuthenticator = mAuthenticator;\n            if (accountAuthenticator == null) {\n                // It is possible that the authenticator has died, which is indicated by\n                // mAuthenticator being set to null. If this happens then just abort.\n                // There is no need to send back a result or error in this case since\n                // that already happened when mAuthenticator was cleared.\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.v(TAG, \"checkAccount: aborting session since we are no longer\"\n                            + \" connected to the authenticator, \" + toDebugString());\n                }\n                return;\n            }\n            try {\n                accountAuthenticator.hasFeatures(this, mAccountsOfType[mCurrentAccount], mFeatures);\n            } catch (RemoteException e) {\n                onError(AccountManager.ERROR_CODE_REMOTE_EXCEPTION, \"remote exception\");\n            }\n        }\n\n        @Override\n        public void onResult(Bundle result) {\n            Bundle.setDefusable(result, true);\n            mNumResults++;\n            if (result == null) {\n                onError(AccountManager.ERROR_CODE_INVALID_RESPONSE, \"null bundle\");\n                return;\n            }\n            if (result.getBoolean(AccountManager.KEY_BOOLEAN_RESULT, false)) {\n                mAccountsWithFeatures.add(mAccountsOfType[mCurrentAccount]);\n            }\n            mCurrentAccount++;\n            checkAccount();\n        }\n\n        public void sendResult() {\n            IAccountManagerResponse response = getResponseAndClose();\n            if (response != null) {\n                try {\n                    Account[] accounts = new Account[mAccountsWithFeatures.size()];\n                    for (int i = 0; i < accounts.length; i++) {\n                        accounts[i] = mAccountsWithFeatures.get(i);\n                    }\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, getClass().getSimpleName() + \" calling onResult() on response \"\n                                + response);\n                    }\n                    Bundle result = new Bundle();\n                    result.putParcelableArray(AccountManager.KEY_ACCOUNTS, accounts);\n                    response.onResult(result);\n                } catch (RemoteException e) {\n                    // if the caller is dead then there is no one to care about remote exceptions\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, \"failure while notifying response\", e);\n                    }\n                }\n            }\n        }\n\n        @Override\n        protected String toDebugString(long now) {\n            return super.toDebugString(now) + \", getAccountsByTypeAndFeatures\"\n                    + \", \" + (mFeatures != null ? TextUtils.join(\",\", mFeatures) : null);\n        }\n    }\n\n    /**\n     * Returns the accounts visible to the client within the context of a specific user\n     * @hide\n     */\n    @NonNull\n    public Account[] getAccounts(int userId, String opPackageName) {\n        int callingUid = Binder.getCallingUid();\n        mAppOpsManager.checkPackage(callingUid, opPackageName);\n        List<String> visibleAccountTypes = getTypesVisibleToCaller(callingUid, userId,\n                opPackageName);\n        if (visibleAccountTypes.isEmpty()) {\n            return EMPTY_ACCOUNT_ARRAY;\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return getAccountsInternal(\n                    accounts,\n                    callingUid,\n                    opPackageName,\n                    visibleAccountTypes,\n                    false /* includeUserManagedNotVisible */);\n        } catch (SQLiteException e) {\n            Log.w(TAG, \"Could not get accounts for user \" + userId, e);\n            return new Account[]{};\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    /**\n     * Returns accounts for all running users, ignores visibility values.\n     *\n     * Should only be called by System process.\n     * @hide\n     */\n    @NonNull\n    public AccountAndUser[] getRunningAccountsForSystem() {\n        final int[] runningUserIds;\n        try {\n            runningUserIds = ActivityManager.getService().getRunningUserIds();\n        } catch (RemoteException e) {\n            // Running in system_server; should never happen\n            throw new RuntimeException(e);\n        }\n        return getAccountsForSystem(runningUserIds);\n    }\n\n    /**\n     * Returns accounts for all users, ignores visibility values.\n     *\n     * Should only be called by system process\n     *\n     * @hide\n     */\n    @NonNull\n    public AccountAndUser[] getAllAccountsForSystemProcess() {\n        final List<UserInfo> users = getUserManager().getAliveUsers();\n        final int[] userIds = new int[users.size()];\n        for (int i = 0; i < userIds.length; i++) {\n            userIds[i] = users.get(i).id;\n        }\n        return getAccountsForSystem(userIds);\n    }\n\n    /**\n     * Returns all accounts for the given user, ignores all visibility checks.\n     * This should only be called by system process.\n     *\n     * @hide\n     */\n    @NonNull\n    private AccountAndUser[] getAccountsForSystem(int[] userIds) {\n        final ArrayList<AccountAndUser> runningAccounts = Lists.newArrayList();\n        for (int userId : userIds) {\n            UserAccounts userAccounts = getUserAccounts(userId);\n            if (userAccounts == null) continue;\n            Account[] accounts = getAccountsFromCache(\n                    userAccounts,\n                    null /* type */,\n                    Binder.getCallingUid(),\n                    \"android\"/* packageName */,\n                    false /* include managed not visible*/);\n            for (Account account : accounts) {\n                runningAccounts.add(new AccountAndUser(account, userId));\n            }\n        }\n\n        AccountAndUser[] accountsArray = new AccountAndUser[runningAccounts.size()];\n        return runningAccounts.toArray(accountsArray);\n    }\n\n    @Override\n    @NonNull\n    public Account[] getAccountsAsUser(String type, int userId, String opPackageName) {\n        int callingUid = Binder.getCallingUid();\n        mAppOpsManager.checkPackage(callingUid, opPackageName);\n        try {\n            return getAccountsAsUserForPackage(type, userId, opPackageName /* callingPackage */, -1,\n                    opPackageName, false /* includeUserManagedNotVisible */);\n        } catch (SQLiteException e) {\n            Log.e(TAG, \"Could not get accounts for user \" + userId, e);\n            return new Account[]{};\n        }\n    }\n\n    @NonNull\n    private Account[] getAccountsOrEmptyArray(String type, int userId, String opPackageName) {\n        try {\n            return getAccountsAsUser(type, userId, opPackageName);\n        } catch (SQLiteException e) {\n            Log.w(TAG, \"Could not get accounts for user \" + userId, e);\n            return new Account[]{};\n        }\n    }\n\n    @NonNull\n    private Account[] getAccountsAsUserForPackage(\n            String type,\n            int userId,\n            String callingPackage,\n            int packageUid,\n            String opPackageName,\n            boolean includeUserManagedNotVisible) {\n        int callingUid = Binder.getCallingUid();\n        // Only allow the system process to read accounts of other users\n        if (userId != UserHandle.getCallingUserId()\n                && callingUid != Process.SYSTEM_UID\n                && mContext.checkCallingOrSelfPermission(\n                    android.Manifest.permission.INTERACT_ACROSS_USERS_FULL)\n                    != PackageManager.PERMISSION_GRANTED) {\n            throw new SecurityException(\"User \" + UserHandle.getCallingUserId()\n                    + \" trying to get account for \" + userId);\n        }\n\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"getAccounts: accountType \" + type\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid());\n        }\n\n        // If the original calling app was using account choosing activity\n        // provided by the framework or authenticator we'll passing in\n        // the original caller's uid here, which is what should be used for filtering.\n        List<String> managedTypes =\n                getTypesManagedByCaller(callingUid, UserHandle.getUserId(callingUid));\n        if (packageUid != -1 &&\n                ((UserHandle.isSameApp(callingUid, Process.SYSTEM_UID)\n                || (type != null && managedTypes.contains(type))))) {\n            callingUid = packageUid;\n            opPackageName = callingPackage;\n        }\n        List<String> visibleAccountTypes = getTypesVisibleToCaller(callingUid, userId,\n                opPackageName);\n        if (visibleAccountTypes.isEmpty()\n                || (type != null && !visibleAccountTypes.contains(type))) {\n            return EMPTY_ACCOUNT_ARRAY;\n        } else if (visibleAccountTypes.contains(type)) {\n            // Prune the list down to just the requested type.\n            visibleAccountTypes = new ArrayList<>();\n            visibleAccountTypes.add(type);\n        } // else aggregate all the visible accounts (it won't matter if the\n          // list is empty).\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return getAccountsInternal(\n                    accounts,\n                    callingUid,\n                    opPackageName,\n                    visibleAccountTypes,\n                    includeUserManagedNotVisible);\n        } catch (SQLiteException e) {\n            Log.w(TAG, \"Could not get accounts for user \" + userId, e);\n            return new Account[]{};\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @NonNull\n    private Account[] getAccountsInternal(\n            UserAccounts userAccounts,\n            int callingUid,\n            String callingPackage,\n            List<String> visibleAccountTypes,\n            boolean includeUserManagedNotVisible) {\n        ArrayList<Account> visibleAccounts = new ArrayList<>();\n        for (String visibleType : visibleAccountTypes) {\n            Account[] accountsForType = getAccountsFromCache(\n                    userAccounts, visibleType, callingUid, callingPackage,\n                    includeUserManagedNotVisible);\n            if (accountsForType != null) {\n                visibleAccounts.addAll(Arrays.asList(accountsForType));\n            }\n        }\n        Account[] result = new Account[visibleAccounts.size()];\n        for (int i = 0; i < visibleAccounts.size(); i++) {\n            result[i] = visibleAccounts.get(i);\n        }\n        return result;\n    }\n\n    @Override\n    public void addSharedAccountsFromParentUser(int parentUserId, int userId,\n            String opPackageName) {\n        checkManageOrCreateUsersPermission(\"addSharedAccountsFromParentUser\");\n        Account[] accounts = getAccountsOrEmptyArray(null, parentUserId, opPackageName);\n        for (Account account : accounts) {\n            addSharedAccountAsUser(account, userId);\n        }\n    }\n\n    private boolean addSharedAccountAsUser(Account account, int userId) {\n        userId = handleIncomingUser(userId);\n        UserAccounts accounts = getUserAccounts(userId);\n        accounts.accountsDb.deleteSharedAccount(account);\n        long accountId = accounts.accountsDb.insertSharedAccount(account);\n        if (accountId < 0) {\n            Log.w(TAG, \"insertAccountIntoDatabase: \" + account.toSafeString()\n                    + \", skipping the DB insert failed\");\n            return false;\n        }\n        logRecord(AccountsDb.DEBUG_ACTION_ACCOUNT_ADD, AccountsDb.TABLE_SHARED_ACCOUNTS, accountId,\n                accounts);\n        return true;\n    }\n\n    public boolean renameSharedAccountAsUser(Account account, String newName, int userId) {\n        userId = handleIncomingUser(userId);\n        UserAccounts accounts = getUserAccounts(userId);\n        long sharedTableAccountId = accounts.accountsDb.findSharedAccountId(account);\n        int r = accounts.accountsDb.renameSharedAccount(account, newName);\n        if (r > 0) {\n            int callingUid = getCallingUid();\n            logRecord(AccountsDb.DEBUG_ACTION_ACCOUNT_RENAME, AccountsDb.TABLE_SHARED_ACCOUNTS,\n                    sharedTableAccountId, accounts, callingUid);\n            // Recursively rename the account.\n            renameAccountInternal(accounts, account, newName);\n        }\n        return r > 0;\n    }\n\n    public boolean removeSharedAccountAsUser(Account account, int userId) {\n        return removeSharedAccountAsUser(account, userId, getCallingUid());\n    }\n\n    private boolean removeSharedAccountAsUser(Account account, int userId, int callingUid) {\n        userId = handleIncomingUser(userId);\n        UserAccounts accounts = getUserAccounts(userId);\n        long sharedTableAccountId = accounts.accountsDb.findSharedAccountId(account);\n        boolean deleted = accounts.accountsDb.deleteSharedAccount(account);\n        if (deleted) {\n            logRecord(AccountsDb.DEBUG_ACTION_ACCOUNT_REMOVE, AccountsDb.TABLE_SHARED_ACCOUNTS,\n                    sharedTableAccountId, accounts, callingUid);\n            removeAccountInternal(accounts, account, callingUid);\n        }\n        return deleted;\n    }\n\n    public Account[] getSharedAccountsAsUser(int userId) {\n        userId = handleIncomingUser(userId);\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            synchronized (accounts.dbLock) {\n                List<Account> accountList = accounts.accountsDb.getSharedAccounts();\n                Account[] accountArray = new Account[accountList.size()];\n                accountList.toArray(accountArray);\n                return accountArray;\n            }\n        } catch (SQLiteException e) {\n            Log.w(TAG, \"Could not get shared accounts for user \" + userId, e);\n            return new Account[]{};\n        }\n    }\n\n    @Override\n    @NonNull\n    public Account[] getAccountsForPackage(String packageName, int uid, String opPackageName) {\n        int callingUid = Binder.getCallingUid();\n        if (!UserHandle.isSameApp(callingUid, Process.SYSTEM_UID)) {\n            // Don't do opPackageName check - caller is system.\n            throw new SecurityException(\"getAccountsForPackage() called from unauthorized uid \"\n                    + callingUid + \" with uid=\" + uid);\n        }\n        return getAccountsAsUserForPackage(null, UserHandle.getCallingUserId(), packageName, uid,\n                opPackageName, true /* includeUserManagedNotVisible */);\n    }\n\n    @Override\n    @NonNull\n    public Account[] getAccountsByTypeForPackage(String type, String packageName,\n            String opPackageName) {\n        int callingUid =  Binder.getCallingUid();\n        int userId = UserHandle.getCallingUserId();\n        mAppOpsManager.checkPackage(callingUid, opPackageName);\n        int packageUid = -1;\n        try {\n            packageUid = mPackageManager.getPackageUidAsUser(packageName, userId);\n        } catch (NameNotFoundException re) {\n            Slog.e(TAG, \"Couldn't determine the packageUid for \" + packageName + re);\n            return EMPTY_ACCOUNT_ARRAY;\n        }\n        if (!UserHandle.isSameApp(callingUid, Process.SYSTEM_UID)\n                && (type != null && !isAccountManagedByCaller(type, callingUid, userId))) {\n                return EMPTY_ACCOUNT_ARRAY;\n        }\n        if (!UserHandle.isSameApp(callingUid, Process.SYSTEM_UID) && type == null) {\n            return getAccountsAsUserForPackage(type, userId,\n                packageName, packageUid, opPackageName, false /* includeUserManagedNotVisible */);\n        }\n        return getAccountsAsUserForPackage(type, userId,\n                packageName, packageUid, opPackageName, true /* includeUserManagedNotVisible */);\n    }\n\n    private boolean needToStartChooseAccountActivity(Account[] accounts, String callingPackage) {\n        if (accounts.length < 1) return false;\n        if (accounts.length > 1) return true;\n        Account account = accounts[0];\n        UserAccounts userAccounts = getUserAccounts(UserHandle.getCallingUserId());\n        int visibility = resolveAccountVisibility(account, callingPackage, userAccounts);\n        if (visibility == AccountManager.VISIBILITY_USER_MANAGED_NOT_VISIBLE) return true;\n        return false;\n    }\n\n    private void startChooseAccountActivityWithAccounts(\n        IAccountManagerResponse response, Account[] accounts, String callingPackage) {\n        Intent intent = new Intent(mContext, ChooseAccountActivity.class);\n        intent.putExtra(AccountManager.KEY_ACCOUNTS, accounts);\n        intent.putExtra(AccountManager.KEY_ACCOUNT_MANAGER_RESPONSE,\n                new AccountManagerResponse(response));\n        intent.putExtra(AccountManager.KEY_ANDROID_PACKAGE_NAME, callingPackage);\n\n        mContext.startActivityAsUser(intent, UserHandle.of(UserHandle.getCallingUserId()));\n    }\n\n    private void handleGetAccountsResult(\n        IAccountManagerResponse response,\n        Account[] accounts,\n        String callingPackage) {\n\n        if (needToStartChooseAccountActivity(accounts, callingPackage)) {\n            startChooseAccountActivityWithAccounts(response, accounts, callingPackage);\n            return;\n        }\n        if (accounts.length == 1) {\n            Bundle bundle = new Bundle();\n            bundle.putString(AccountManager.KEY_ACCOUNT_NAME, accounts[0].name);\n            bundle.putString(AccountManager.KEY_ACCOUNT_TYPE, accounts[0].type);\n            onResult(response, bundle);\n            return;\n        }\n        // No qualified account exists, return an empty Bundle.\n        onResult(response, new Bundle());\n    }\n\n    @Override\n    public void getAccountByTypeAndFeatures(\n        IAccountManagerResponse response,\n        String accountType,\n        String[] features,\n        String opPackageName) {\n\n        int callingUid = Binder.getCallingUid();\n        mAppOpsManager.checkPackage(callingUid, opPackageName);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"getAccount: accountType \" + accountType\n                    + \", response \" + response\n                    + \", features \" + Arrays.toString(features)\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        if (response == null) throw new IllegalArgumentException(\"response is null\");\n        if (accountType == null) throw new IllegalArgumentException(\"accountType is null\");\n\n        int userId = UserHandle.getCallingUserId();\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts userAccounts = getUserAccounts(userId);\n            if (ArrayUtils.isEmpty(features)) {\n                Account[] accountsWithManagedNotVisible = getAccountsFromCache(\n                    userAccounts, accountType, callingUid, opPackageName,\n                    true /* include managed not visible */);\n                handleGetAccountsResult(\n                    response, accountsWithManagedNotVisible, opPackageName);\n                return;\n            }\n\n            IAccountManagerResponse retrieveAccountsResponse =\n                new IAccountManagerResponse.Stub() {\n                @Override\n                public void onResult(Bundle value) throws RemoteException {\n                    Parcelable[] parcelables = value.getParcelableArray(\n                        AccountManager.KEY_ACCOUNTS);\n                    Account[] accounts = new Account[parcelables.length];\n                    for (int i = 0; i < parcelables.length; i++) {\n                        accounts[i] = (Account) parcelables[i];\n                    }\n                    handleGetAccountsResult(\n                        response, accounts, opPackageName);\n                }\n\n                @Override\n                public void onError(int errorCode, String errorMessage)\n                        throws RemoteException {\n                    // Will not be called in this case.\n                }\n            };\n            new GetAccountsByTypeAndFeatureSession(\n                    userAccounts,\n                    retrieveAccountsResponse,\n                    accountType,\n                    features,\n                    callingUid,\n                    opPackageName,\n                    true /* include managed not visible */).bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void getAccountsByFeatures(\n            IAccountManagerResponse response,\n            String type,\n            String[] features,\n            String opPackageName) {\n        int callingUid = Binder.getCallingUid();\n        mAppOpsManager.checkPackage(callingUid, opPackageName);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"getAccounts: accountType \" + type\n                    + \", response \" + response\n                    + \", features \" + Arrays.toString(features)\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        if (response == null) throw new IllegalArgumentException(\"response is null\");\n        if (type == null) throw new IllegalArgumentException(\"accountType is null\");\n        int userId = UserHandle.getCallingUserId();\n\n        List<String> visibleAccountTypes = getTypesVisibleToCaller(callingUid, userId,\n                opPackageName);\n        if (!visibleAccountTypes.contains(type)) {\n            Bundle result = new Bundle();\n            // Need to return just the accounts that are from matching signatures.\n            result.putParcelableArray(AccountManager.KEY_ACCOUNTS, EMPTY_ACCOUNT_ARRAY);\n            try {\n                response.onResult(result);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Cannot respond to caller do to exception.\" , e);\n            }\n            return;\n        }\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts userAccounts = getUserAccounts(userId);\n            if (features == null || features.length == 0) {\n                Account[] accounts = getAccountsFromCache(userAccounts, type, callingUid,\n                        opPackageName, false);\n                Bundle result = new Bundle();\n                result.putParcelableArray(AccountManager.KEY_ACCOUNTS, accounts);\n                onResult(response, result);\n                return;\n            }\n            new GetAccountsByTypeAndFeatureSession(\n                    userAccounts,\n                    response,\n                    type,\n                    features,\n                    callingUid,\n                    opPackageName,\n                    false /* include managed not visible */).bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void onAccountAccessed(String token) throws RemoteException {\n        final int uid = Binder.getCallingUid();\n        if (UserHandle.getAppId(uid) == Process.SYSTEM_UID) {\n            return;\n        }\n        final int userId = UserHandle.getCallingUserId();\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            for (Account account : getAccounts(userId, mContext.getOpPackageName())) {\n                if (Objects.equals(account.getAccessId(), token)) {\n                    // An app just accessed the account. At this point it knows about\n                    // it and there is not need to hide this account from the app.\n                    // Do we need to update account visibility here?\n                    if (!hasAccountAccess(account, null, uid)) {\n                        updateAppPermission(account, AccountManager.ACCOUNT_ACCESS_TOKEN_TYPE,\n                                uid, true);\n                    }\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    @Override\n    public void onShellCommand(FileDescriptor in, FileDescriptor out,\n            FileDescriptor err, String[] args, ShellCallback callback,\n            ResultReceiver resultReceiver) {\n        new AccountManagerServiceShellCommand(this).exec(this, in, out, err, args,\n                callback, resultReceiver);\n    }\n\n    private abstract class Session extends IAccountAuthenticatorResponse.Stub\n            implements IBinder.DeathRecipient, ServiceConnection {\n        private final Object mSessionLock = new Object();\n        IAccountManagerResponse mResponse;\n        final String mAccountType;\n        final boolean mExpectActivityLaunch;\n        final long mCreationTime;\n        final String mAccountName;\n        // Indicates if we need to add auth details(like last credential time)\n        final boolean mAuthDetailsRequired;\n        // If set, we need to update the last authenticated time. This is\n        // currently\n        // used on\n        // successful confirming credentials.\n        final boolean mUpdateLastAuthenticatedTime;\n\n        public int mNumResults = 0;\n        private int mNumRequestContinued = 0;\n        private int mNumErrors = 0;\n\n        IAccountAuthenticator mAuthenticator = null;\n\n        private final boolean mStripAuthTokenFromResult;\n        protected boolean mCanStartAccountManagerActivity = false;\n        protected final UserAccounts mAccounts;\n\n        private int mAuthenticatorUid;\n        private long mBindingStartTime;\n\n        public Session(UserAccounts accounts, IAccountManagerResponse response, String accountType,\n                boolean expectActivityLaunch, boolean stripAuthTokenFromResult, String accountName,\n                boolean authDetailsRequired) {\n            this(accounts, response, accountType, expectActivityLaunch, stripAuthTokenFromResult,\n                    accountName, authDetailsRequired, false /* updateLastAuthenticatedTime */);\n        }\n\n        public Session(UserAccounts accounts, IAccountManagerResponse response, String accountType,\n                boolean expectActivityLaunch, boolean stripAuthTokenFromResult, String accountName,\n                boolean authDetailsRequired, boolean updateLastAuthenticatedTime) {\n            super();\n            //if (response == null) throw new IllegalArgumentException(\"response is null\");\n            if (accountType == null) throw new IllegalArgumentException(\"accountType is null\");\n            mAccounts = accounts;\n            mStripAuthTokenFromResult = stripAuthTokenFromResult;\n            mAccountType = accountType;\n            mExpectActivityLaunch = expectActivityLaunch;\n            mCreationTime = SystemClock.elapsedRealtime();\n            mAccountName = accountName;\n            mAuthDetailsRequired = authDetailsRequired;\n            mUpdateLastAuthenticatedTime = updateLastAuthenticatedTime;\n\n            synchronized (mSessions) {\n                mSessions.put(toString(), this);\n            }\n            scheduleTimeout();\n            if (response != null) {\n                try {\n                    response.asBinder().linkToDeath(this, 0 /* flags */);\n                    mResponse = response;\n                } catch (RemoteException e) {\n                    binderDied();\n                }\n            }\n        }\n\n        IAccountManagerResponse getResponseAndClose() {\n            if (mAuthenticatorUid != 0 && mBindingStartTime > 0) {\n                sResponseLatency.logSampleWithUid(mAuthenticatorUid,\n                        SystemClock.uptimeMillis() - mBindingStartTime);\n            }\n            if (mResponse == null) {\n                close();\n                return null;\n            }\n            IAccountManagerResponse response = mResponse;\n            close(); // this clears mResponse so we need to save the response before this call\n            return response;\n        }\n\n        /**\n         * Checks Intents, supplied via KEY_INTENT, to make sure that they don't violate our\n         * security policy.\n         *\n         * In particular we want to make sure that the Authenticator doesn't try to trick users\n         * into launching arbitrary intents on the device via by tricking to click authenticator\n         * supplied entries in the system Settings app.\n         */\n        protected boolean checkKeyIntent(int authUid, Bundle bundle) {\n            if (!checkKeyIntentParceledCorrectly(bundle)) {\n                EventLog.writeEvent(0x534e4554, \"250588548\", authUid, \"\");\n                return false;\n            }\n            Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT, Intent.class);\n            if (intent == null) {\n                return true;\n            }\n            // Explicitly set an empty ClipData to ensure that we don't offer to\n            // promote any Uris contained inside for granting purposes\n            if (intent.getClipData() == null) {\n                intent.setClipData(ClipData.newPlainText(null, null));\n            }\n            final long bid = Binder.clearCallingIdentity();\n            try {\n                PackageManager pm = mContext.getPackageManager();\n                ResolveInfo resolveInfo = pm.resolveActivityAsUser(intent, 0, mAccounts.userId);\n                if (resolveInfo == null) {\n                    return false;\n                }\n                if (\"content\".equals(intent.getScheme())) {\n                    return false;\n                }\n                ActivityInfo targetActivityInfo = resolveInfo.activityInfo;\n                int targetUid = targetActivityInfo.applicationInfo.uid;\n                PackageManagerInternal pmi = LocalServices.getService(PackageManagerInternal.class);\n                if (!isExportedSystemActivity(targetActivityInfo)\n                        && !pmi.hasSignatureCapability(targetUid, authUid, CertCapabilities.AUTH)) {\n                    String pkgName = targetActivityInfo.packageName;\n                    String activityName = targetActivityInfo.name;\n                    String tmpl = \"KEY_INTENT resolved to an Activity (%s) in a package (%s) that \"\n                            + \"does not share a signature with the supplying authenticator (%s).\";\n                    Log.e(TAG, String.format(tmpl, activityName, pkgName, mAccountType));\n                    return false;\n                }\n                intent.setComponent(targetActivityInfo.getComponentName());\n                bundle.putParcelable(AccountManager.KEY_INTENT, intent);\n                return true;\n            } finally {\n                Binder.restoreCallingIdentity(bid);\n            }\n        }\n\n        /**\n         * Simulate the client side's deserialization of KEY_INTENT value, to make sure they don't\n         * violate our security policy.\n         *\n         * In particular we want to make sure the Authenticator doesn't trick users\n         * into launching arbitrary intents on the device via exploiting any other Parcel read/write\n         * mismatch problems.\n         */\n        private boolean checkKeyIntentParceledCorrectly(Bundle bundle) {\n            Parcel p = Parcel.obtain();\n            p.writeBundle(bundle);\n            p.setDataPosition(0);\n            Bundle simulateBundle = p.readBundle();\n            p.recycle();\n            Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT, Intent.class);\n            Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT,\n                    Intent.class);\n            if (intent == null) {\n                return (simulateIntent == null);\n            }\n            if (intent.getClass() != Intent.class || simulateIntent.getClass() != Intent.class) {\n                return false;\n            }\n\n            if (!intent.filterEquals(simulateIntent)) {\n                return false;\n            }\n\n            if (intent.getSelector() != simulateIntent.getSelector()) {\n                return false;\n            }\n\n            int prohibitedFlags = Intent.FLAG_GRANT_READ_URI_PERMISSION\n                    | Intent.FLAG_GRANT_WRITE_URI_PERMISSION\n                    | Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION\n                    | Intent.FLAG_GRANT_PREFIX_URI_PERMISSION;\n            return (simulateIntent.getFlags() & prohibitedFlags) == 0;\n        }\n\n        private boolean isExportedSystemActivity(ActivityInfo activityInfo) {\n            String className = activityInfo.name;\n            if (!\"android\".equals(activityInfo.packageName)) {\n                return false;\n\n            }\n            return (mCanStartAccountManagerActivity\n                    && GrantCredentialsPermissionActivity.class.getName().equals(className))\n                    || CantAddAccountActivity.class.getName().equals(className);\n        }\n\n        private void close() {\n            synchronized (mSessions) {\n                if (mSessions.remove(toString()) == null) {\n                    // the session was already closed, so bail out now\n                    return;\n                }\n            }\n            if (mResponse != null) {\n                // stop listening for response deaths\n                mResponse.asBinder().unlinkToDeath(this, 0 /* flags */);\n\n                // clear this so that we don't accidentally send any further results\n                mResponse = null;\n            }\n            cancelTimeout();\n            unbind();\n        }\n\n        @Override\n        public void binderDied() {\n            mResponse = null;\n            close();\n        }\n\n        protected String toDebugString() {\n            return toDebugString(SystemClock.elapsedRealtime());\n        }\n\n        protected String toDebugString(long now) {\n            return \"Session: expectLaunch \" + mExpectActivityLaunch\n                    + \", connected \" + (mAuthenticator != null)\n                    + \", stats (\" + mNumResults + \"/\" + mNumRequestContinued\n                    + \"/\" + mNumErrors + \")\"\n                    + \", lifetime \" + ((now - mCreationTime) / 1000.0);\n        }\n\n        void bind() {\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"initiating bind to authenticator type \" + mAccountType);\n            }\n            if (!bindToAuthenticator(mAccountType)) {\n                Log.w(TAG, \"bind attempt failed for \" + toDebugString());\n                onError(AccountManager.ERROR_CODE_REMOTE_EXCEPTION, \"bind failure\");\n            }\n        }\n\n        private void unbind() {\n            synchronized (mSessionLock) {\n                if (mAuthenticator != null) {\n                    mAuthenticator = null;\n                    mContext.unbindService(this);\n                }\n            }\n        }\n\n        private void scheduleTimeout() {\n            mHandler.sendMessageDelayed(\n                    mHandler.obtainMessage(MESSAGE_TIMED_OUT, this), TIMEOUT_DELAY_MS);\n        }\n\n        public void cancelTimeout() {\n            mHandler.removeMessages(MESSAGE_TIMED_OUT, this);\n        }\n\n        @Override\n        public void onServiceConnected(ComponentName name, IBinder service) {\n            synchronized (mSessionLock) {\n                mAuthenticator = IAccountAuthenticator.Stub.asInterface(service);\n                try {\n                    run();\n                } catch (RemoteException e) {\n                    onError(AccountManager.ERROR_CODE_REMOTE_EXCEPTION,\n                            \"remote exception\");\n                }\n            }\n        }\n\n        @Override\n        public void onServiceDisconnected(ComponentName name) {\n            IAccountManagerResponse response = getResponseAndClose();\n            if (response != null) {\n                try {\n                    response.onError(AccountManager.ERROR_CODE_REMOTE_EXCEPTION,\n                            \"disconnected\");\n                } catch (RemoteException e) {\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, \"Session.onServiceDisconnected: \"\n                                + \"caught RemoteException while responding\", e);\n                    }\n                }\n            }\n        }\n\n        public abstract void run() throws RemoteException;\n\n        public void onTimedOut() {\n            IAccountManagerResponse response = getResponseAndClose();\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"Session.onTimedOut\");\n            }\n            if (response != null) {\n                try {\n                    response.onError(AccountManager.ERROR_CODE_REMOTE_EXCEPTION,\n                            \"timeout\");\n                } catch (RemoteException e) {\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, \"Session.onTimedOut: caught RemoteException while responding\",\n                                e);\n                    }\n                }\n            }\n        }\n\n        @Override\n        public void onResult(Bundle result) {\n            Bundle.setDefusable(result, true);\n            mNumResults++;\n            Intent intent = null;\n            if (result != null) {\n                boolean isSuccessfulConfirmCreds = result.getBoolean(\n                        AccountManager.KEY_BOOLEAN_RESULT, false);\n                boolean isSuccessfulUpdateCredsOrAddAccount =\n                        result.containsKey(AccountManager.KEY_ACCOUNT_NAME)\n                        && result.containsKey(AccountManager.KEY_ACCOUNT_TYPE);\n                // We should only update lastAuthenticated time, if\n                // mUpdateLastAuthenticatedTime is true and the confirmRequest\n                // or updateRequest was successful\n                boolean needUpdate = mUpdateLastAuthenticatedTime\n                        && (isSuccessfulConfirmCreds || isSuccessfulUpdateCredsOrAddAccount);\n                if (needUpdate || mAuthDetailsRequired) {\n                    boolean accountPresent = isAccountPresentForCaller(mAccountName, mAccountType);\n                    if (needUpdate && accountPresent) {\n                        updateLastAuthenticatedTime(new Account(mAccountName, mAccountType));\n                    }\n                    if (mAuthDetailsRequired) {\n                        long lastAuthenticatedTime = -1;\n                        if (accountPresent) {\n                            lastAuthenticatedTime = mAccounts.accountsDb\n                                    .findAccountLastAuthenticatedTime(\n                                            new Account(mAccountName, mAccountType));\n                        }\n                        result.putLong(AccountManager.KEY_LAST_AUTHENTICATED_TIME,\n                                lastAuthenticatedTime);\n                    }\n                }\n            }\n            if (result != null) {\n                if (!checkKeyIntent(\n                        Binder.getCallingUid(),\n                        result)) {\n                    onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                            \"invalid intent in bundle returned\");\n                    return;\n                }\n            }\n            if (result != null\n                    && !TextUtils.isEmpty(result.getString(AccountManager.KEY_AUTHTOKEN))) {\n                String accountName = result.getString(AccountManager.KEY_ACCOUNT_NAME);\n                String accountType = result.getString(AccountManager.KEY_ACCOUNT_TYPE);\n                if (!TextUtils.isEmpty(accountName) && !TextUtils.isEmpty(accountType)) {\n                    Account account = new Account(accountName, accountType);\n                    cancelNotification(getSigninRequiredNotificationId(mAccounts, account),\n                            mAccounts);\n                }\n            }\n            IAccountManagerResponse response;\n            if (mExpectActivityLaunch && result != null\n                    && result.containsKey(AccountManager.KEY_INTENT)) {\n                response = mResponse;\n            } else {\n                response = getResponseAndClose();\n            }\n            if (response != null) {\n                try {\n                    if (result == null) {\n                        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                            Log.v(TAG, getClass().getSimpleName()\n                                    + \" calling onError() on response \" + response);\n                        }\n                        response.onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                                \"null bundle returned\");\n                    } else {\n                        if (mStripAuthTokenFromResult) {\n                            result.remove(AccountManager.KEY_AUTHTOKEN);\n                            if (!checkKeyIntent(Binder.getCallingUid(), result)) {\n                                onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                                        \"invalid intent in bundle returned\");\n                                return;\n                            }\n                        }\n                        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                            Log.v(TAG, getClass().getSimpleName()\n                                    + \" calling onResult() on response \" + response);\n                        }\n                        if ((result.getInt(AccountManager.KEY_ERROR_CODE, -1) > 0) &&\n                                (intent == null)) {\n                            // All AccountManager error codes are greater than 0\n                            response.onError(result.getInt(AccountManager.KEY_ERROR_CODE),\n                                    result.getString(AccountManager.KEY_ERROR_MESSAGE));\n                        } else {\n                            response.onResult(result);\n                        }\n                    }\n                } catch (RemoteException e) {\n                    // if the caller is dead then there is no one to care about remote exceptions\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, \"failure while notifying response\", e);\n                    }\n                }\n            }\n        }\n\n        @Override\n        public void onRequestContinued() {\n            mNumRequestContinued++;\n        }\n\n        @Override\n        public void onError(int errorCode, String errorMessage) {\n            mNumErrors++;\n            IAccountManagerResponse response = getResponseAndClose();\n            if (response != null) {\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.v(TAG, getClass().getSimpleName()\n                            + \" calling onError() on response \" + response);\n                }\n                try {\n                    response.onError(errorCode, errorMessage);\n                } catch (RemoteException e) {\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, \"Session.onError: caught RemoteException while responding\", e);\n                    }\n                }\n            } else {\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.v(TAG, \"Session.onError: already closed\");\n                }\n            }\n        }\n\n        /**\n         * find the component name for the authenticator and initiate a bind\n         * if no authenticator or the bind fails then return false, otherwise return true\n         */\n        private boolean bindToAuthenticator(String authenticatorType) {\n            final AccountAuthenticatorCache.ServiceInfo<AuthenticatorDescription> authenticatorInfo;\n            authenticatorInfo = mAuthenticatorCache.getServiceInfo(\n                    AuthenticatorDescription.newKey(authenticatorType), mAccounts.userId);\n            if (authenticatorInfo == null) {\n                Log.w(TAG, \"there is no authenticator for \" + authenticatorType\n                        + \", bailing out\");\n\n                return false;\n            }\n\n            if (!isLocalUnlockedUser(mAccounts.userId)\n                    && !authenticatorInfo.componentInfo.directBootAware) {\n                Slog.w(TAG, \"Blocking binding to authenticator \" + authenticatorInfo.componentName\n                        + \" which isn't encryption aware\");\n                return false;\n            }\n\n            Intent intent = new Intent();\n            intent.setAction(AccountManager.ACTION_AUTHENTICATOR_INTENT);\n            intent.setComponent(authenticatorInfo.componentName);\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"performing bindService to \" + authenticatorInfo.componentName);\n            }\n            long flags = Context.BIND_AUTO_CREATE;\n            if (mAuthenticatorCache.getBindInstantServiceAllowed(mAccounts.userId)) {\n                flags |= Context.BIND_ALLOW_INSTANT;\n            }\n            if (!mContext.bindServiceAsUser(intent, this, Context.BindServiceFlags.of(flags),\n                    UserHandle.of(mAccounts.userId))) {\n                Log.w(TAG, \"bindService to \" + authenticatorInfo.componentName + \" failed\");\n                // Perform unbind as per documentation at Context.bindServiceAsUser\n                mContext.unbindService(this);\n                return false;\n            }\n            mAuthenticatorUid = authenticatorInfo.uid;\n            mBindingStartTime = SystemClock.uptimeMillis();\n            return true;\n        }\n    }\n\n    class MessageHandler extends Handler {\n        MessageHandler(Looper looper) {\n            super(looper);\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MESSAGE_TIMED_OUT:\n                    Session session = (Session)msg.obj;\n                    session.onTimedOut();\n                    break;\n\n                case MESSAGE_COPY_SHARED_ACCOUNT:\n                    copyAccountToUser(/*no response*/ null, (Account) msg.obj, msg.arg1, msg.arg2);\n                    break;\n\n                default:\n                    throw new IllegalStateException(\"unhandled message: \" + msg.what);\n            }\n        }\n    }\n\n    private void logRecord(UserAccounts accounts, String action, String tableName) {\n        logRecord(action, tableName, -1, accounts);\n    }\n\n    private void logRecordWithUid(UserAccounts accounts, String action, String tableName, int uid) {\n        logRecord(action, tableName, -1, accounts, uid);\n    }\n\n    /*\n     * This function receives an opened writable database.\n     */\n    private void logRecord(String action, String tableName, long accountId,\n            UserAccounts userAccount) {\n        logRecord(action, tableName, accountId, userAccount, getCallingUid());\n    }\n\n    /*\n     * This function receives an opened writable database and writes to it in a separate thread.\n     */\n    private void logRecord(String action, String tableName, long accountId,\n            UserAccounts userAccount, int callingUid) {\n\n        class LogRecordTask implements Runnable {\n            private final String action;\n            private final String tableName;\n            private final long accountId;\n            private final UserAccounts userAccount;\n            private final int callingUid;\n            private final long userDebugDbInsertionPoint;\n\n            LogRecordTask(final String action,\n                    final String tableName,\n                    final long accountId,\n                    final UserAccounts userAccount,\n                    final int callingUid,\n                    final long userDebugDbInsertionPoint) {\n                this.action = action;\n                this.tableName = tableName;\n                this.accountId = accountId;\n                this.userAccount = userAccount;\n                this.callingUid = callingUid;\n                this.userDebugDbInsertionPoint = userDebugDbInsertionPoint;\n            }\n\n            @Override\n            public void run() {\n                synchronized (userAccount.accountsDb.mDebugStatementLock) {\n                    SQLiteStatement logStatement = userAccount.accountsDb.getStatementForLogging();\n                    if (logStatement == null) {\n                        return; // Can't log.\n                    }\n                    logStatement.bindLong(1, accountId);\n                    logStatement.bindString(2, action);\n                    logStatement.bindString(3, mDateFormat.format(new Date()));\n                    logStatement.bindLong(4, callingUid);\n                    logStatement.bindString(5, tableName);\n                    logStatement.bindLong(6, userDebugDbInsertionPoint);\n                    try {\n                        logStatement.execute();\n                    } catch (IllegalStateException | SQLiteFullException e) {\n                        // Guard against crash, DB can already be closed\n                        // since this statement is executed on a handler thread\n                        Slog.w(TAG, \"Failed to insert a log record. accountId=\" + accountId\n                                + \" action=\" + action + \" tableName=\" + tableName + \" Error: \" + e);\n                    } finally {\n                        logStatement.clearBindings();\n                    }\n                }\n            }\n        }\n        long insertionPoint = userAccount.accountsDb.reserveDebugDbInsertionPoint();\n        if (insertionPoint != -1) {\n            LogRecordTask logTask = new LogRecordTask(action, tableName, accountId, userAccount,\n                    callingUid, insertionPoint);\n            mHandler.post(logTask);\n        }\n    }\n\n    public IBinder onBind(@SuppressWarnings(\"unused\") Intent intent) {\n        return asBinder();\n    }\n\n    /**\n     * Searches array of arguments for the specified string\n     * @param args array of argument strings\n     * @param value value to search for\n     * @return true if the value is contained in the array\n     */\n    private static boolean scanArgs(String[] args, String value) {\n        if (args != null) {\n            for (String arg : args) {\n                if (value.equals(arg)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    @Override\n    protected void dump(FileDescriptor fd, PrintWriter fout, String[] args) {\n        if (!DumpUtils.checkDumpPermission(mContext, TAG, fout)) return;\n        final boolean isCheckinRequest = scanArgs(args, \"--checkin\") || scanArgs(args, \"-c\");\n        final IndentingPrintWriter ipw = new IndentingPrintWriter(fout, \"  \");\n\n        final List<UserInfo> users = getUserManager().getUsers();\n        for (UserInfo user : users) {\n            ipw.println(\"User \" + user + \":\");\n            ipw.increaseIndent();\n            dumpUser(getUserAccounts(user.id), fd, ipw, args, isCheckinRequest);\n            ipw.println();\n            ipw.decreaseIndent();\n        }\n    }\n\n    private void dumpUser(UserAccounts userAccounts, FileDescriptor fd, PrintWriter fout,\n            String[] args, boolean isCheckinRequest) {\n        if (isCheckinRequest) {\n            // This is a checkin request. *Only* upload the account types and the count of\n            // each.\n            synchronized (userAccounts.dbLock) {\n                userAccounts.accountsDb.dumpDeAccountsTable(fout);\n            }\n        } else {\n            Account[] accounts = getAccountsFromCache(userAccounts, null /* type */,\n                    Process.SYSTEM_UID, \"android\" /* packageName */, false);\n            fout.println(\"Accounts: \" + accounts.length);\n            for (Account account : accounts) {\n                fout.println(\"  \" + account.toString());\n            }\n\n            // Add debug information.\n            fout.println();\n            synchronized (userAccounts.dbLock) {\n                userAccounts.accountsDb.dumpDebugTable(fout);\n            }\n            fout.println();\n            synchronized (mSessions) {\n                final long now = SystemClock.elapsedRealtime();\n                fout.println(\"Active Sessions: \" + mSessions.size());\n                for (Session session : mSessions.values()) {\n                    fout.println(\"  \" + session.toDebugString(now));\n                }\n            }\n\n            fout.println();\n            mAuthenticatorCache.dump(fd, fout, args, userAccounts.userId);\n\n            boolean isUserUnlocked;\n            synchronized (mUsers) {\n                isUserUnlocked = isLocalUnlockedUser(userAccounts.userId);\n            }\n            // Following logs are printed only when user is unlocked.\n            if (!isUserUnlocked) {\n                return;\n            }\n            fout.println();\n            synchronized (userAccounts.dbLock) {\n                Map<Account, Map<String, Integer>> allVisibilityValues =\n                        userAccounts.accountsDb.findAllVisibilityValues();\n                fout.println(\"Account visibility:\");\n                for (Account account : allVisibilityValues.keySet()) {\n                    fout.println(\"  \" + account.name);\n                    Map<String, Integer> visibilities = allVisibilityValues.get(account);\n                    for (Entry<String, Integer> entry : visibilities.entrySet()) {\n                        fout.println(\"    \" + entry.getKey() + \", \" + entry.getValue());\n                    }\n                }\n            }\n        }\n    }\n\n    private void doNotification(UserAccounts accounts, Account account, CharSequence message,\n            Intent intent, String packageName, final int userId) {\n        final long identityToken = clearCallingIdentity();\n        try {\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"doNotification: \" + message + \" intent:\" + intent);\n            }\n\n            if (intent.getComponent() != null &&\n                    GrantCredentialsPermissionActivity.class.getName().equals(\n                            intent.getComponent().getClassName())) {\n                createNoCredentialsPermissionNotification(account, intent, packageName, accounts);\n            } else {\n                Context contextForUser = getContextForUser(new UserHandle(userId));\n                final NotificationId id = getSigninRequiredNotificationId(accounts, account);\n                intent.addCategory(id.mTag);\n\n                final String notificationTitleFormat =\n                        contextForUser.getText(R.string.notification_title).toString();\n                Notification n =\n                        new Notification.Builder(contextForUser, SystemNotificationChannels.ACCOUNT)\n                        .setWhen(0)\n                        .setSmallIcon(android.R.drawable.stat_sys_warning)\n                        .setColor(contextForUser.getColor(\n                                com.android.internal.R.color.system_notification_accent_color))\n                        .setContentTitle(String.format(notificationTitleFormat, account.name))\n                        .setContentText(message)\n                        .setContentIntent(PendingIntent.getActivityAsUser(\n                                mContext, 0, intent,\n                                PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_IMMUTABLE,\n                                null, new UserHandle(userId)))\n                        .build();\n                installNotification(id, n, packageName, userId);\n            }\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private void installNotification(NotificationId id, final Notification notification,\n            String packageName, int userId) {\n        final long token = clearCallingIdentity();\n        try {\n            INotificationManager notificationManager = mInjector.getNotificationManager();\n            try {\n                // The calling uid must match either the package or op package, so use an op\n                // package that matches the cleared calling identity.\n                notificationManager.enqueueNotificationWithTag(packageName, \"android\",\n                        id.mTag, id.mId, notification, userId);\n            } catch (RemoteException e) {\n                /* ignore - local call */\n            }\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private void cancelNotification(NotificationId id, UserAccounts accounts) {\n        cancelNotification(id, mContext.getPackageName(), accounts);\n    }\n\n    private void cancelNotification(NotificationId id, String packageName, UserAccounts accounts) {\n        final long identityToken = clearCallingIdentity();\n        try {\n            INotificationManager service = mInjector.getNotificationManager();\n            service.cancelNotificationWithTag(\n                    packageName, \"android\", id.mTag, id.mId,\n                    UserHandle.of(accounts.userId).getIdentifier());\n        } catch (RemoteException e) {\n            /* ignore - local call */\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private boolean isPermittedForPackage(String packageName, int userId, String... permissions) {\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            final int uid = mPackageManager.getPackageUidAsUser(packageName, userId);\n            IPackageManager pm = ActivityThread.getPackageManager();\n            for (String perm : permissions) {\n                if (pm.checkPermission(perm, packageName, userId)\n                        == PackageManager.PERMISSION_GRANTED) {\n                    // Checks runtime permission revocation.\n                    final int opCode = AppOpsManager.permissionToOpCode(perm);\n                    if (opCode == AppOpsManager.OP_NONE || mAppOpsManager.checkOpNoThrow(\n                            opCode, uid, packageName) == AppOpsManager.MODE_ALLOWED) {\n                        return true;\n                    }\n                }\n            }\n        } catch (NameNotFoundException | RemoteException e) {\n            // Assume permission is not granted if an error accrued.\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n        return false;\n    }\n\n    /**\n     * Checks that package has at least one of given permissions and makes note of app\n     * performing the action.\n     */\n    private boolean checkPermissionAndNote(String opPackageName, int callingUid,\n            String... permissions) {\n        for (String perm : permissions) {\n            if (mContext.checkCallingOrSelfPermission(perm) == PackageManager.PERMISSION_GRANTED) {\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.v(TAG, \"  caller uid \" + callingUid + \" has \" + perm);\n                }\n                final int opCode = AppOpsManager.permissionToOpCode(perm);\n                if (opCode == AppOpsManager.OP_NONE || mAppOpsManager.noteOpNoThrow(\n                        opCode, callingUid, opPackageName) == AppOpsManager.MODE_ALLOWED) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private int handleIncomingUser(int userId) {\n        try {\n            return ActivityManager.getService().handleIncomingUser(\n                    Binder.getCallingPid(), Binder.getCallingUid(), userId, true, true, \"\", null);\n        } catch (RemoteException re) {\n            // Shouldn't happen, local.\n        }\n        return userId;\n    }\n\n    private boolean isPrivileged(int callingUid) {\n        String[] packages;\n        final long identityToken = Binder.clearCallingIdentity();\n        try {\n            packages = mPackageManager.getPackagesForUid(callingUid);\n            if (packages == null) {\n                Log.d(TAG, \"No packages for callingUid \" + callingUid);\n                return false;\n            }\n            for (String name : packages) {\n                try {\n                    PackageInfo packageInfo =\n                        mPackageManager.getPackageInfo(name, 0 /* flags */);\n                    if (packageInfo != null\n                        && (packageInfo.applicationInfo.privateFlags\n                            & ApplicationInfo.PRIVATE_FLAG_PRIVILEGED) != 0) {\n                        return true;\n                    }\n                } catch (PackageManager.NameNotFoundException e) {\n                    Log.w(TAG, \"isPrivileged#Package not found \" + e.getMessage());\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identityToken);\n        }\n        return false;\n    }\n\n    private boolean permissionIsGranted(\n            Account account, String authTokenType, int callerUid, int userId) {\n        if (UserHandle.getAppId(callerUid) == Process.SYSTEM_UID) {\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"Access to \" + account + \" granted calling uid is system\");\n            }\n            return true;\n        }\n\n        if (isPrivileged(callerUid)) {\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"Access to \" + account + \" granted calling uid \"\n                        + callerUid + \" privileged\");\n            }\n            return true;\n        }\n        if (account != null && isAccountManagedByCaller(account.type, callerUid, userId)) {\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"Access to \" + account + \" granted calling uid \"\n                        + callerUid + \" manages the account\");\n            }\n            return true;\n        }\n        if (account != null && hasExplicitlyGrantedPermission(account, authTokenType, callerUid)) {\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"Access to \" + account + \" granted calling uid \"\n                        + callerUid + \" user granted access\");\n            }\n            return true;\n        }\n\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"Access to \" + account + \" not granted for uid \" + callerUid);\n        }\n\n        return false;\n    }\n\n    private boolean isAccountVisibleToCaller(String accountType, int callingUid, int userId,\n            String opPackageName) {\n        if (accountType == null) {\n            return false;\n        } else {\n            return getTypesVisibleToCaller(callingUid, userId,\n                    opPackageName).contains(accountType);\n        }\n    }\n\n    // Method checks visibility for applications targeing API level below {@link\n    // android.os.Build.VERSION_CODES#O},\n    // returns true if the the app has GET_ACCOUNTS or GET_ACCOUNTS_PRIVILEGED permission.\n    private boolean checkGetAccountsPermission(String packageName, int userId) {\n        return isPermittedForPackage(packageName, userId, Manifest.permission.GET_ACCOUNTS,\n                Manifest.permission.GET_ACCOUNTS_PRIVILEGED);\n    }\n\n    private boolean checkReadContactsPermission(String packageName, int userId) {\n        return isPermittedForPackage(packageName, userId, Manifest.permission.READ_CONTACTS);\n    }\n\n    // Heuristic to check that account type may be associated with some contacts data and\n    // therefore READ_CONTACTS permission grants the access to account by default.\n    private boolean accountTypeManagesContacts(String accountType, int userId) {\n        if (accountType == null) {\n            return false;\n        }\n        final long identityToken = Binder.clearCallingIdentity();\n        Collection<RegisteredServicesCache.ServiceInfo<AuthenticatorDescription>> serviceInfos;\n        try {\n            serviceInfos = mAuthenticatorCache.getAllServices(userId);\n        } finally {\n            Binder.restoreCallingIdentity(identityToken);\n        }\n        // Check contacts related permissions for authenticator.\n        for (RegisteredServicesCache.ServiceInfo<AuthenticatorDescription> serviceInfo\n                : serviceInfos) {\n            if (accountType.equals(serviceInfo.type.type)) {\n                return isPermittedForPackage(serviceInfo.type.packageName, userId,\n                    Manifest.permission.WRITE_CONTACTS);\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Method checks package uid and signature with Authenticator which manages accountType.\n     *\n     * @return SIGNATURE_CHECK_UID_MATCH for uid match, SIGNATURE_CHECK_MATCH for signature match,\n     *         SIGNATURE_CHECK_MISMATCH otherwise.\n     */\n    private int checkPackageSignature(String accountType, int callingUid, int userId) {\n        if (accountType == null) {\n            return SIGNATURE_CHECK_MISMATCH;\n        }\n\n        final long identityToken = Binder.clearCallingIdentity();\n        Collection<RegisteredServicesCache.ServiceInfo<AuthenticatorDescription>> serviceInfos;\n        try {\n            serviceInfos = mAuthenticatorCache.getAllServices(userId);\n        } finally {\n            Binder.restoreCallingIdentity(identityToken);\n        }\n        // Check for signature match with Authenticator.LocalServices.getService(PackageManagerInternal.class);\n        PackageManagerInternal pmi = LocalServices.getService(PackageManagerInternal.class);\n        for (RegisteredServicesCache.ServiceInfo<AuthenticatorDescription> serviceInfo\n                : serviceInfos) {\n            if (accountType.equals(serviceInfo.type.type)) {\n                if (serviceInfo.uid == callingUid) {\n                    return SIGNATURE_CHECK_UID_MATCH;\n                }\n                if (pmi.hasSignatureCapability(\n                        serviceInfo.uid, callingUid, CertCapabilities.AUTH)) {\n                    return SIGNATURE_CHECK_MATCH;\n                }\n            }\n        }\n        return SIGNATURE_CHECK_MISMATCH;\n    }\n\n    // returns true for applications with the same signature as authenticator.\n    private boolean isAccountManagedByCaller(String accountType, int callingUid, int userId) {\n        if (accountType == null) {\n            return false;\n        } else {\n            return getTypesManagedByCaller(callingUid, userId).contains(accountType);\n        }\n    }\n\n    private List<String> getTypesVisibleToCaller(int callingUid, int userId,\n            String opPackageName) {\n        return getTypesForCaller(callingUid, userId, true /* isOtherwisePermitted*/);\n    }\n\n    private List<String> getTypesManagedByCaller(int callingUid, int userId) {\n        return getTypesForCaller(callingUid, userId, false);\n    }\n\n    private List<String> getTypesForCaller(\n            int callingUid, int userId, boolean isOtherwisePermitted) {\n        List<String> managedAccountTypes = new ArrayList<>();\n        final long identityToken = Binder.clearCallingIdentity();\n        Collection<RegisteredServicesCache.ServiceInfo<AuthenticatorDescription>> serviceInfos;\n        try {\n            serviceInfos = mAuthenticatorCache.getAllServices(userId);\n        } finally {\n            Binder.restoreCallingIdentity(identityToken);\n        }\n\n        PackageManagerInternal pmi = LocalServices.getService(PackageManagerInternal.class);\n        for (RegisteredServicesCache.ServiceInfo<AuthenticatorDescription> serviceInfo :\n                serviceInfos) {\n            if (isOtherwisePermitted || pmi.hasSignatureCapability(\n                    serviceInfo.uid, callingUid, CertCapabilities.AUTH)) {\n                managedAccountTypes.add(serviceInfo.type.type);\n            }\n        }\n        return managedAccountTypes;\n    }\n\n    private boolean isAccountPresentForCaller(String accountName, String accountType) {\n        if (getUserAccountsForCaller().accountCache.containsKey(accountType)) {\n            for (Account account : getUserAccountsForCaller().accountCache.get(accountType)) {\n                if (account.name.equals(accountName)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private static void checkManageUsersPermission(String message) {\n        if (ActivityManager.checkComponentPermission(\n                android.Manifest.permission.MANAGE_USERS, Binder.getCallingUid(), -1, true)\n                != PackageManager.PERMISSION_GRANTED) {\n            throw new SecurityException(\"You need MANAGE_USERS permission to: \" + message);\n        }\n    }\n\n    private static void checkManageOrCreateUsersPermission(String message) {\n        if (ActivityManager.checkComponentPermission(android.Manifest.permission.MANAGE_USERS,\n                Binder.getCallingUid(), -1, true) != PackageManager.PERMISSION_GRANTED &&\n                ActivityManager.checkComponentPermission(android.Manifest.permission.CREATE_USERS,\n                        Binder.getCallingUid(), -1, true) != PackageManager.PERMISSION_GRANTED) {\n            throw new SecurityException(\"You need MANAGE_USERS or CREATE_USERS permission to: \"\n                    + message);\n        }\n    }\n\n    private boolean hasExplicitlyGrantedPermission(Account account, String authTokenType,\n            int callerUid) {\n        if (UserHandle.getAppId(callerUid) == Process.SYSTEM_UID) {\n            return true;\n        }\n        UserAccounts accounts = getUserAccounts(UserHandle.getUserId(callerUid));\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                long grantsCount;\n                if (authTokenType != null) {\n                    grantsCount = accounts.accountsDb\n                            .findMatchingGrantsCount(callerUid, authTokenType, account);\n                } else {\n                    grantsCount = accounts.accountsDb.findMatchingGrantsCountAnyToken(callerUid,\n                            account);\n                }\n                final boolean permissionGranted = grantsCount > 0;\n\n                if (!permissionGranted && ActivityManager.isRunningInTestHarness()) {\n                    // TODO: Skip this check when running automated tests. Replace this\n                    // with a more general solution.\n                    Log.d(TAG, \"no credentials permission for usage of \"\n                            + account.toSafeString() + \", \"\n                            + authTokenType + \" by uid \" + callerUid\n                            + \" but ignoring since device is in test harness.\");\n                    return true;\n                }\n                return permissionGranted;\n            }\n        }\n    }\n\n    private boolean isSystemUid(int callingUid) {\n        String[] packages = null;\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            packages = mPackageManager.getPackagesForUid(callingUid);\n            if (packages != null) {\n                for (String name : packages) {\n                    try {\n                        PackageInfo packageInfo =\n                                mPackageManager.getPackageInfo(name, 0 /* flags */);\n                        if (packageInfo != null\n                                && (packageInfo.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM)\n                                != 0) {\n                            return true;\n                        }\n                    } catch (NameNotFoundException e) {\n                        Log.w(TAG, String.format(\"Could not find package [%s]\", name), e);\n                    }\n                }\n            } else {\n                Log.w(TAG, \"No known packages with uid \" + callingUid);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n        return false;\n    }\n\n    /** Succeeds if any of the specified permissions are granted. */\n    private void checkReadAccountsPermitted(\n            int callingUid,\n            String accountType,\n            int userId,\n            String opPackageName) {\n        if (!isAccountVisibleToCaller(accountType, callingUid, userId, opPackageName)) {\n            String msg = String.format(\n                    \"caller uid %s cannot access %s accounts\",\n                    callingUid,\n                    accountType);\n            Log.w(TAG, \"  \" + msg);\n            throw new SecurityException(msg);\n        }\n    }\n\n    private boolean canUserModifyAccounts(int userId, int callingUid) {\n        // the managing app can always modify accounts\n        if (isProfileOwner(callingUid)) {\n            return true;\n        }\n        if (getUserManager().getUserRestrictions(new UserHandle(userId))\n                .getBoolean(UserManager.DISALLOW_MODIFY_ACCOUNTS)) {\n            return false;\n        }\n        return true;\n    }\n\n    private boolean canUserModifyAccountsForType(int userId, String accountType, int callingUid) {\n        return Binder.withCleanCallingIdentity(() -> {\n            // the managing app can always modify accounts\n            if (isProfileOwner(callingUid)) {\n                return true;\n            }\n            DevicePolicyManager dpm = (DevicePolicyManager) mContext\n                    .getSystemService(Context.DEVICE_POLICY_SERVICE);\n            String[] typesArray = dpm.getAccountTypesWithManagementDisabledAsUser(userId);\n            if (typesArray == null) {\n                return true;\n            }\n            for (String forbiddenType : typesArray) {\n                if (forbiddenType.equals(accountType)) {\n                    return false;\n                }\n            }\n            return true;\n        });\n    }\n\n    private boolean isProfileOwner(int uid) {\n        final DevicePolicyManagerInternal dpmi =\n                LocalServices.getService(DevicePolicyManagerInternal.class);\n        //TODO(b/169395065) Figure out if this flow makes sense in Device Owner mode.\n        return (dpmi != null) && (dpmi.isActiveProfileOwner(uid) || dpmi.isActiveDeviceOwner(uid));\n    }\n\n    /**\n     * Filter the access to the target package by rules of the package visibility if the caller\n     * targeting API level U and above. Otherwise, returns true if the package is installed on\n     * the device.\n     *\n     * @param targetPkgName The package name to check.\n     * @param callingUid The caller that is going to access the package.\n     * @param userId The user ID where the target package resides.\n     * @return true if the caller is able to access the package.\n     */\n    private boolean canCallerAccessPackage(@NonNull String targetPkgName, int callingUid,\n            int userId) {\n        final PackageManagerInternal pmInternal =\n                LocalServices.getService(PackageManagerInternal.class);\n        if (!CompatChanges.isChangeEnabled(ENFORCE_PACKAGE_VISIBILITY_FILTERING, callingUid)) {\n            return pmInternal.getPackageUid(\n                    targetPkgName, 0 /* flags */, userId) != Process.INVALID_UID;\n        }\n        final boolean canAccess = !pmInternal.filterAppAccess(targetPkgName, callingUid, userId);\n        if (!canAccess && Log.isLoggable(TAG, Log.DEBUG)) {\n            Log.d(TAG, \"Package \" + targetPkgName + \" is not visible to caller \" + callingUid\n                    + \" for user \" + userId);\n        }\n        return canAccess;\n    }\n\n    @Override\n    public void updateAppPermission(Account account, String authTokenType, int uid, boolean value)\n            throws RemoteException {\n        final int callingUid = getCallingUid();\n\n        if (UserHandle.getAppId(callingUid) != Process.SYSTEM_UID) {\n            throw new SecurityException();\n        }\n\n        if (value) {\n            grantAppPermission(account, authTokenType, uid);\n        } else {\n            revokeAppPermission(account, authTokenType, uid);\n        }\n    }\n\n    /**\n     * Allow callers with the given uid permission to get credentials for account/authTokenType.\n     * <p>\n     * Although this is public it can only be accessed via the AccountManagerService object\n     * which is in the system. This means we don't need to protect it with permissions.\n     * @hide\n     */\n    void grantAppPermission(Account account, String authTokenType, int uid) {\n        if (account == null || authTokenType == null) {\n            Log.e(TAG, \"grantAppPermission: called with invalid arguments\", new Exception());\n            return;\n        }\n        UserAccounts accounts = getUserAccounts(UserHandle.getUserId(uid));\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                long accountId = accounts.accountsDb.findDeAccountId(account);\n                if (accountId >= 0) {\n                    accounts.accountsDb.insertGrant(accountId, authTokenType, uid);\n                }\n                cancelNotification(\n                        getCredentialPermissionNotificationId(\n                                account, authTokenType, uid, accounts),\n                        accounts);\n\n                cancelAccountAccessRequestNotificationIfNeeded(account, uid, true, accounts);\n            }\n        }\n\n        // Listeners are a final CopyOnWriteArrayList, hence no lock needed.\n        for (AccountManagerInternal.OnAppPermissionChangeListener listener\n                : mAppPermissionChangeListeners) {\n            mHandler.post(() -> listener.onAppPermissionChanged(account, uid));\n        }\n    }\n\n    /**\n     * Don't allow callers with the given uid permission to get credentials for\n     * account/authTokenType.\n     * <p>\n     * Although this is public it can only be accessed via the AccountManagerService object\n     * which is in the system. This means we don't need to protect it with permissions.\n     * @hide\n     */\n    private void revokeAppPermission(Account account, String authTokenType, int uid) {\n        if (account == null || authTokenType == null) {\n            Log.e(TAG, \"revokeAppPermission: called with invalid arguments\", new Exception());\n            return;\n        }\n        UserAccounts accounts = getUserAccounts(UserHandle.getUserId(uid));\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                accounts.accountsDb.beginTransaction();\n                try {\n                    long accountId = accounts.accountsDb.findDeAccountId(account);\n                    if (accountId >= 0) {\n                        accounts.accountsDb.deleteGrantsByAccountIdAuthTokenTypeAndUid(\n                                accountId, authTokenType, uid);\n                        accounts.accountsDb.setTransactionSuccessful();\n                    }\n                } finally {\n                    accounts.accountsDb.endTransaction();\n                }\n\n                cancelNotification(\n                        getCredentialPermissionNotificationId(\n                                account, authTokenType, uid, accounts),\n                        accounts);\n            }\n        }\n\n        // Listeners are a final CopyOnWriteArrayList, hence no lock needed.\n        for (AccountManagerInternal.OnAppPermissionChangeListener listener\n                : mAppPermissionChangeListeners) {\n            mHandler.post(() -> listener.onAppPermissionChanged(account, uid));\n        }\n    }\n\n    private void removeAccountFromCacheLocked(UserAccounts accounts, Account account) {\n        final Account[] oldAccountsForType = accounts.accountCache.get(account.type);\n        if (oldAccountsForType != null) {\n            ArrayList<Account> newAccountsList = new ArrayList<>();\n            for (Account curAccount : oldAccountsForType) {\n                if (!curAccount.equals(account)) {\n                    newAccountsList.add(curAccount);\n                }\n            }\n            if (newAccountsList.isEmpty()) {\n                accounts.accountCache.remove(account.type);\n            } else {\n                Account[] newAccountsForType = new Account[newAccountsList.size()];\n                newAccountsForType = newAccountsList.toArray(newAccountsForType);\n                accounts.accountCache.put(account.type, newAccountsForType);\n            }\n        }\n        accounts.userDataCache.remove(account);\n        accounts.authTokenCache.remove(account);\n        accounts.previousNameCache.remove(account);\n        accounts.visibilityCache.remove(account);\n\n        AccountManager.invalidateLocalAccountsDataCaches();\n    }\n\n    /**\n     * This assumes that the caller has already checked that the account is not already present.\n     * IMPORTANT: The account being inserted will begin to be tracked for access in remote\n     * processes and if you will return this account to apps you should return the result.\n     * @return The inserted account which is a new instance that is being tracked.\n     */\n    private Account insertAccountIntoCacheLocked(UserAccounts accounts, Account account) {\n        Account[] accountsForType = accounts.accountCache.get(account.type);\n        int oldLength = (accountsForType != null) ? accountsForType.length : 0;\n        Account[] newAccountsForType = new Account[oldLength + 1];\n        if (accountsForType != null) {\n            System.arraycopy(accountsForType, 0, newAccountsForType, 0, oldLength);\n        }\n        String token = account.getAccessId() != null ? account.getAccessId()\n                : UUID.randomUUID().toString();\n        newAccountsForType[oldLength] = new Account(account, token);\n        accounts.accountCache.put(account.type, newAccountsForType);\n        AccountManager.invalidateLocalAccountsDataCaches();\n        return newAccountsForType[oldLength];\n    }\n\n    @NonNull\n    private Account[] filterAccounts(UserAccounts accounts, Account[] unfiltered, int callingUid,\n            @Nullable String callingPackage, boolean includeManagedNotVisible) {\n        String visibilityFilterPackage = callingPackage;\n        if (visibilityFilterPackage == null) {\n            visibilityFilterPackage = getPackageNameForUid(callingUid);\n        }\n        Map<Account, Integer> firstPass = new LinkedHashMap<>();\n        for (Account account : unfiltered) {\n            int visibility = resolveAccountVisibility(account, visibilityFilterPackage, accounts);\n            if ((visibility == AccountManager.VISIBILITY_VISIBLE\n                    || visibility == AccountManager.VISIBILITY_USER_MANAGED_VISIBLE)\n                    || (includeManagedNotVisible\n                            && (visibility\n                                    == AccountManager.VISIBILITY_USER_MANAGED_NOT_VISIBLE))) {\n                firstPass.put(account, visibility);\n            }\n        }\n        Map<Account, Integer> secondPass =\n                filterSharedAccounts(accounts, firstPass, callingUid, callingPackage);\n\n        Account[] filtered = new Account[secondPass.size()];\n        filtered = secondPass.keySet().toArray(filtered);\n        return filtered;\n    }\n\n    @NonNull\n    private Map<Account, Integer> filterSharedAccounts(UserAccounts userAccounts,\n            @NonNull Map<Account, Integer> unfiltered, int callingUid,\n            @Nullable String callingPackage) {\n        // first part is to filter shared accounts.\n        // unfiltered type check is not necessary.\n        if (getUserManager() == null || userAccounts == null || userAccounts.userId < 0\n                || callingUid == Process.SYSTEM_UID) {\n            return unfiltered;\n        }\n        UserInfo user = getUserManager().getUserInfo(userAccounts.userId);\n        if (user != null && user.isRestricted()) {\n            String[] packages = mPackageManager.getPackagesForUid(callingUid);\n            if (packages == null) {\n                packages = new String[] {};\n            }\n            // If any of the packages is a visible listed package, return the full set,\n            // otherwise return non-shared accounts only.\n            // This might be a temporary way to specify a visible list\n            String visibleList = mContext.getResources().getString(\n                    com.android.internal.R.string.config_appsAuthorizedForSharedAccounts);\n            for (String packageName : packages) {\n                if (visibleList.contains(\";\" + packageName + \";\")) {\n                    return unfiltered;\n                }\n            }\n            Account[] sharedAccounts = getSharedAccountsAsUser(userAccounts.userId);\n            if (ArrayUtils.isEmpty(sharedAccounts)) {\n                return unfiltered;\n            }\n            String requiredAccountType = \"\";\n            try {\n                // If there's an explicit callingPackage specified, check if that package\n                // opted in to see restricted accounts.\n                if (callingPackage != null) {\n                    PackageInfo pi = mPackageManager.getPackageInfo(callingPackage, 0);\n                    if (pi != null && pi.restrictedAccountType != null) {\n                        requiredAccountType = pi.restrictedAccountType;\n                    }\n                } else {\n                    // Otherwise check if the callingUid has a package that has opted in\n                    for (String packageName : packages) {\n                        PackageInfo pi = mPackageManager.getPackageInfo(packageName, 0);\n                        if (pi != null && pi.restrictedAccountType != null) {\n                            requiredAccountType = pi.restrictedAccountType;\n                            break;\n                        }\n                    }\n                }\n            } catch (NameNotFoundException e) {\n                Log.w(TAG, \"filterSharedAccounts#Package not found \" + e.getMessage());\n            }\n            Map<Account, Integer> filtered = new LinkedHashMap<>();\n            for (Map.Entry<Account, Integer> entry : unfiltered.entrySet()) {\n                Account account = entry.getKey();\n                if (account.type.equals(requiredAccountType)) {\n                    filtered.put(account, entry.getValue());\n                } else {\n                    boolean found = false;\n                    for (Account shared : sharedAccounts) {\n                        if (shared.equals(account)) {\n                            found = true;\n                            break;\n                        }\n                    }\n                    if (!found) {\n                        filtered.put(account, entry.getValue());\n                    }\n                }\n            }\n            return filtered;\n        } else {\n            return unfiltered;\n        }\n    }\n\n    /*\n     * packageName can be null. If not null, it should be used to filter out restricted accounts\n     * that the package is not allowed to access.\n     *\n     * <p>The method shouldn't be called with UserAccounts#cacheLock held, otherwise it will cause a\n     * deadlock\n     */\n    @NonNull\n    protected Account[] getAccountsFromCache(UserAccounts userAccounts, String accountType,\n            int callingUid, @Nullable String callingPackage, boolean includeManagedNotVisible) {\n        Preconditions.checkState(!Thread.holdsLock(userAccounts.cacheLock),\n                \"Method should not be called with cacheLock\");\n        if (accountType != null) {\n            Account[] accounts;\n            synchronized (userAccounts.cacheLock) {\n                accounts = userAccounts.accountCache.get(accountType);\n            }\n            if (accounts == null) {\n                return EMPTY_ACCOUNT_ARRAY;\n            } else {\n                return filterAccounts(userAccounts, Arrays.copyOf(accounts, accounts.length),\n                        callingUid, callingPackage, includeManagedNotVisible);\n            }\n        } else {\n            int totalLength = 0;\n            Account[] accountsArray;\n            synchronized (userAccounts.cacheLock) {\n                for (Account[] accounts : userAccounts.accountCache.values()) {\n                    totalLength += accounts.length;\n                }\n                if (totalLength == 0) {\n                    return EMPTY_ACCOUNT_ARRAY;\n                }\n                accountsArray = new Account[totalLength];\n                totalLength = 0;\n                for (Account[] accountsOfType : userAccounts.accountCache.values()) {\n                    System.arraycopy(accountsOfType, 0, accountsArray, totalLength,\n                            accountsOfType.length);\n                    totalLength += accountsOfType.length;\n                }\n            }\n            return filterAccounts(userAccounts, accountsArray, callingUid, callingPackage,\n                    includeManagedNotVisible);\n        }\n    }\n\n    /** protected by the {@code dbLock}, {@code cacheLock} */\n    protected void writeUserDataIntoCacheLocked(UserAccounts accounts,\n            Account account, String key, String value) {\n        Map<String, String> userDataForAccount = accounts.userDataCache.get(account);\n        if (userDataForAccount == null) {\n            userDataForAccount = accounts.accountsDb.findUserExtrasForAccount(account);\n            accounts.userDataCache.put(account, userDataForAccount);\n        }\n        if (value == null) {\n            userDataForAccount.remove(key);\n        } else {\n            userDataForAccount.put(key, value);\n        }\n    }\n\n    protected TokenCache.Value readCachedTokenInternal(\n            UserAccounts accounts,\n            Account account,\n            String tokenType,\n            String callingPackage,\n            byte[] pkgSigDigest) {\n        synchronized (accounts.cacheLock) {\n            return accounts.accountTokenCaches.get(\n                    account, tokenType, callingPackage, pkgSigDigest);\n        }\n    }\n\n    /** protected by the {@code dbLock}, {@code cacheLock} */\n    protected void writeAuthTokenIntoCacheLocked(UserAccounts accounts,\n            Account account, String key, String value) {\n        Map<String, String> authTokensForAccount = accounts.authTokenCache.get(account);\n        if (authTokensForAccount == null) {\n            authTokensForAccount = accounts.accountsDb.findAuthTokensByAccount(account);\n            accounts.authTokenCache.put(account, authTokensForAccount);\n        }\n        if (value == null) {\n            authTokensForAccount.remove(key);\n        } else {\n            authTokensForAccount.put(key, value);\n        }\n    }\n\n    protected String readAuthTokenInternal(UserAccounts accounts, Account account,\n            String authTokenType) {\n        // Fast path - check if account is already cached\n        synchronized (accounts.cacheLock) {\n            Map<String, String> authTokensForAccount = accounts.authTokenCache.get(account);\n            if (authTokensForAccount != null) {\n                return authTokensForAccount.get(authTokenType);\n            }\n        }\n        // If not cached yet - do slow path and sync with db if necessary\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                Map<String, String> authTokensForAccount = accounts.authTokenCache.get(account);\n                if (authTokensForAccount == null) {\n                    // need to populate the cache for this account\n                    authTokensForAccount = accounts.accountsDb.findAuthTokensByAccount(account);\n                    accounts.authTokenCache.put(account, authTokensForAccount);\n                }\n                return authTokensForAccount.get(authTokenType);\n            }\n        }\n    }\n\n    private String readUserDataInternal(UserAccounts accounts, Account account, String key) {\n        Map<String, String> userDataForAccount;\n        // Fast path - check if data is already cached\n        synchronized (accounts.cacheLock) {\n            userDataForAccount = accounts.userDataCache.get(account);\n        }\n        // If not cached yet - do slow path and sync with db if necessary\n        if (userDataForAccount == null) {\n            synchronized (accounts.dbLock) {\n                synchronized (accounts.cacheLock) {\n                    userDataForAccount = accounts.userDataCache.get(account);\n                    if (userDataForAccount == null) {\n                        // need to populate the cache for this account\n                        userDataForAccount = accounts.accountsDb.findUserExtrasForAccount(account);\n                        accounts.userDataCache.put(account, userDataForAccount);\n                    }\n                }\n            }\n        }\n        return userDataForAccount.get(key);\n    }\n\n    private Context getContextForUser(UserHandle user) {\n        try {\n            return mContext.createPackageContextAsUser(mContext.getPackageName(), 0, user);\n        } catch (NameNotFoundException e) {\n            // Default to mContext, not finding the package system is running as is unlikely.\n            return mContext;\n        }\n    }\n\n    private void sendResponse(IAccountManagerResponse response, Bundle result) {\n        try {\n            response.onResult(result);\n        } catch (RemoteException e) {\n            // if the caller is dead then there is no one to care about remote\n            // exceptions\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"failure while notifying response\", e);\n            }\n        }\n    }\n\n    private void sendErrorResponse(IAccountManagerResponse response, int errorCode,\n            String errorMessage) {\n        try {\n            response.onError(errorCode, errorMessage);\n        } catch (RemoteException e) {\n            // if the caller is dead then there is no one to care about remote\n            // exceptions\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"failure while notifying response\", e);\n            }\n        }\n    }\n\n    /**\n     * Returns true if the config_canRemoveOrRenameFirstUser is false, and the given account type\n     * matches the one provided by config_accountTypeToKeepFirstUser.\n     */\n    private boolean isFirstAccountRemovalDisabled(Account account) {\n        // Skip if not targeting the first user.\n        int userId = UserHandle.getCallingUserId();\n        if (userId != 0) {\n            return false;\n        }\n\n        // Skip if we are allowed to remove/rename first account.\n        if (mContext.getResources()\n                .getBoolean(com.android.internal.R.bool.config_canRemoveFirstAccount)) {\n            return false;\n        }\n\n        // Skip if needed for testing.\n        if (Settings.Secure.getIntForUser(\n                mContext.getContentResolver(),\n                Settings.Secure.ALLOW_PRIMARY_GAIA_ACCOUNT_REMOVAL_FOR_TESTS,\n                0 /* default */,\n                0 /* userHandle */) != 0) {\n            return false;\n        }\n\n        // Skip if not targeting desired account.\n        String typeToKeep =\n                mContext.getResources()\n                        .getString(\n                                com.android.internal.R.string.config_accountTypeToKeepFirstAccount);\n        if (typeToKeep.isEmpty() || !typeToKeep.equals(account.type)) {\n            return false;\n        }\n\n        // Only restrict first account.\n        UserAccounts accounts = getUserAccounts(0 /* userId */);\n        Account[] accountsOfType = getAccountsFromCache(accounts, typeToKeep,\n                Process.SYSTEM_UID, \"android\" /* packageName */, false);\n        return accountsOfType.length > 0 && accountsOfType[0].equals(account);\n    }\n\n    private final class AccountManagerInternalImpl extends AccountManagerInternal {\n        private final Object mLock = new Object();\n\n        @GuardedBy(\"mLock\")\n        private AccountManagerBackupHelper mBackupHelper;\n\n        @Override\n        public void requestAccountAccess(@NonNull Account account, @NonNull String packageName,\n                @IntRange(from = 0) int userId, @NonNull RemoteCallback callback) {\n            if (account == null) {\n                Slog.w(TAG, \"account cannot be null\");\n                return;\n            }\n            if (packageName == null) {\n                Slog.w(TAG, \"packageName cannot be null\");\n                return;\n            }\n            if (userId < UserHandle.USER_SYSTEM) {\n                Slog.w(TAG, \"user id must be concrete\");\n                return;\n            }\n            if (callback == null) {\n                Slog.w(TAG, \"callback cannot be null\");\n                return;\n            }\n\n            int visibility =\n                resolveAccountVisibility(account, packageName, getUserAccounts(userId));\n            if (visibility == AccountManager.VISIBILITY_NOT_VISIBLE) {\n                Slog.w(TAG, \"requestAccountAccess: account is hidden\");\n                return;\n            }\n\n            if (AccountManagerService.this.hasAccountAccess(account, packageName,\n                    new UserHandle(userId))) {\n                Bundle result = new Bundle();\n                result.putBoolean(AccountManager.KEY_BOOLEAN_RESULT, true);\n                callback.sendResult(result);\n                return;\n            }\n\n            final int uid;\n            try {\n                final long identityToken = clearCallingIdentity();\n                try {\n                    uid = mPackageManager.getPackageUidAsUser(packageName, userId);\n                } finally {\n                    restoreCallingIdentity(identityToken);\n                }\n            } catch (NameNotFoundException e) {\n                Slog.e(TAG, \"Unknown package \" + packageName);\n                return;\n            }\n\n            Intent intent = newRequestAccountAccessIntent(account, packageName, uid, callback);\n            final UserAccounts userAccounts;\n            synchronized (mUsers) {\n                userAccounts = mUsers.get(userId);\n            }\n            SystemNotificationChannels.createAccountChannelForPackage(packageName, uid, mContext);\n            doNotification(userAccounts, account, null, intent, packageName, userId);\n        }\n\n        @Override\n        public void addOnAppPermissionChangeListener(OnAppPermissionChangeListener listener) {\n            // Listeners are a final CopyOnWriteArrayList, hence no lock needed.\n            mAppPermissionChangeListeners.add(listener);\n        }\n\n        @Override\n        public boolean hasAccountAccess(@NonNull Account account, @IntRange(from = 0) int uid) {\n            return AccountManagerService.this.hasAccountAccess(account, null, uid);\n        }\n\n        @Override\n        public byte[] backupAccountAccessPermissions(int userId) {\n            synchronized (mLock) {\n                if (mBackupHelper == null) {\n                    mBackupHelper = new AccountManagerBackupHelper(\n                            AccountManagerService.this, this);\n                }\n                return mBackupHelper.backupAccountAccessPermissions(userId);\n            }\n        }\n\n        @Override\n        public void restoreAccountAccessPermissions(byte[] data, int userId) {\n            synchronized (mLock) {\n                if (mBackupHelper == null) {\n                    mBackupHelper = new AccountManagerBackupHelper(\n                            AccountManagerService.this, this);\n                }\n                mBackupHelper.restoreAccountAccessPermissions(data, userId);\n            }\n        }\n    }\n\n    @VisibleForTesting\n    static class Injector {\n        private final Context mContext;\n\n        public Injector(Context context) {\n            mContext = context;\n        }\n\n        Looper getMessageHandlerLooper() {\n            ServiceThread serviceThread = new ServiceThread(TAG,\n                    android.os.Process.THREAD_PRIORITY_FOREGROUND, true /* allowIo */);\n            serviceThread.start();\n            return serviceThread.getLooper();\n        }\n\n        Context getContext() {\n            return mContext;\n        }\n\n        void addLocalService(AccountManagerInternal service) {\n            LocalServices.addService(AccountManagerInternal.class, service);\n        }\n\n        String getDeDatabaseName(int userId) {\n            File databaseFile = new File(Environment.getDataSystemDeDirectory(userId),\n                    AccountsDb.DE_DATABASE_NAME);\n            return databaseFile.getPath();\n        }\n\n        String getCeDatabaseName(int userId) {\n            File databaseFile = new File(Environment.getDataSystemCeDirectory(userId),\n                    AccountsDb.CE_DATABASE_NAME);\n            return databaseFile.getPath();\n        }\n\n        String getPreNDatabaseName(int userId) {\n            File systemDir = Environment.getDataSystemDirectory();\n            File databaseFile = new File(Environment.getUserSystemDirectory(userId),\n                    PRE_N_DATABASE_NAME);\n            if (userId == 0) {\n                // Migrate old file, if it exists, to the new location.\n                // Make sure the new file doesn't already exist. A placeholder file could have been\n                // accidentally created in the old location,\n                // causing the new one to become corrupted as well.\n                File oldFile = new File(systemDir, PRE_N_DATABASE_NAME);\n                if (oldFile.exists() && !databaseFile.exists()) {\n                    // Check for use directory; create if it doesn't exist, else renameTo will fail\n                    File userDir = Environment.getUserSystemDirectory(userId);\n                    if (!userDir.exists()) {\n                        if (!userDir.mkdirs()) {\n                            throw new IllegalStateException(\n                                    \"User dir cannot be created: \" + userDir);\n                        }\n                    }\n                    if (!oldFile.renameTo(databaseFile)) {\n                        throw new IllegalStateException(\n                                \"User dir cannot be migrated: \" + databaseFile);\n                    }\n                }\n            }\n            return databaseFile.getPath();\n        }\n\n        IAccountAuthenticatorCache getAccountAuthenticatorCache() {\n            return new AccountAuthenticatorCache(mContext);\n        }\n\n        INotificationManager getNotificationManager() {\n            return NotificationManager.getService();\n        }\n    }\n\n    private static class NotificationId {\n        final String mTag;\n        private final int mId;\n\n        NotificationId(String tag, int type) {\n            mTag = tag;\n            mId = type;\n        }\n    }\n}\n```",
                        "downstream_file_content": "```java\n/*\n * Copyright (C) 2009 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.server.accounts;\n\nimport android.Manifest;\nimport android.accounts.AbstractAccountAuthenticator;\nimport android.accounts.Account;\nimport android.accounts.AccountAndUser;\nimport android.accounts.AccountAuthenticatorResponse;\nimport android.accounts.AccountManager;\nimport android.accounts.AccountManagerInternal;\nimport android.accounts.AccountManagerResponse;\nimport android.accounts.AuthenticatorDescription;\nimport android.accounts.CantAddAccountActivity;\nimport android.accounts.ChooseAccountActivity;\nimport android.accounts.GrantCredentialsPermissionActivity;\nimport android.accounts.IAccountAuthenticator;\nimport android.accounts.IAccountAuthenticatorResponse;\nimport android.accounts.IAccountManager;\nimport android.accounts.IAccountManagerResponse;\nimport android.annotation.IntRange;\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.app.ActivityManager;\nimport android.app.ActivityThread;\nimport android.app.AppOpsManager;\nimport android.app.INotificationManager;\nimport android.app.Notification;\nimport android.app.NotificationManager;\nimport android.app.PendingIntent;\nimport android.app.admin.DevicePolicyEventLogger;\nimport android.app.admin.DevicePolicyManager;\nimport android.app.admin.DevicePolicyManagerInternal;\nimport android.content.BroadcastReceiver;\nimport android.content.ClipData;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.IntentSender;\nimport android.content.ServiceConnection;\nimport android.content.pm.ActivityInfo;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.IPackageManager;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManager.NameNotFoundException;\nimport android.content.pm.PackageManagerInternal;\nimport android.content.pm.PackageParser;\nimport android.content.pm.RegisteredServicesCache;\nimport android.content.pm.RegisteredServicesCacheListener;\nimport android.content.pm.ResolveInfo;\nimport android.content.pm.Signature;\nimport android.content.pm.UserInfo;\nimport android.database.Cursor;\nimport android.database.sqlite.SQLiteStatement;\nimport android.os.Binder;\nimport android.os.Bundle;\nimport android.os.Environment;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.Parcel;\nimport android.os.Parcelable;\nimport android.os.Process;\nimport android.os.RemoteCallback;\nimport android.os.RemoteException;\nimport android.os.ResultReceiver;\nimport android.os.ShellCallback;\nimport android.os.StrictMode;\nimport android.os.SystemClock;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.stats.devicepolicy.DevicePolicyEnums;\nimport android.text.TextUtils;\nimport android.util.EventLog;\nimport android.util.Log;\nimport android.util.Pair;\nimport android.util.Slog;\nimport android.util.SparseArray;\nimport android.util.SparseBooleanArray;\n\nimport com.android.internal.R;\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.content.PackageMonitor;\nimport com.android.internal.messages.nano.SystemMessageProto.SystemMessage;\nimport com.android.internal.notification.SystemNotificationChannels;\nimport com.android.internal.util.ArrayUtils;\nimport com.android.internal.util.DumpUtils;\nimport com.android.internal.util.IndentingPrintWriter;\nimport com.android.internal.util.Preconditions;\nimport com.android.server.LocalServices;\nimport com.android.server.ServiceThread;\nimport com.android.server.SystemService;\n\nimport com.google.android.collect.Lists;\nimport com.google.android.collect.Sets;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.PrintWriter;\nimport java.security.GeneralSecurityException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.concurrent.atomic.AtomicReference;\n\n/**\n * A system service that provides  account, password, and authtoken management for all\n * accounts on the device. Some of these calls are implemented with the help of the corresponding\n * {@link IAccountAuthenticator} services. This service is not accessed by users directly,\n * instead one uses an instance of {@link AccountManager}, which can be accessed as follows:\n *    AccountManager accountManager = AccountManager.get(context);\n * @hide\n */\npublic class AccountManagerService\n        extends IAccountManager.Stub\n        implements RegisteredServicesCacheListener<AuthenticatorDescription> {\n    private static final String TAG = \"AccountManagerService\";\n\n    public static class Lifecycle extends SystemService {\n        private AccountManagerService mService;\n\n        public Lifecycle(Context context) {\n            super(context);\n        }\n\n        @Override\n        public void onStart() {\n            mService = new AccountManagerService(new Injector(getContext()));\n            publishBinderService(Context.ACCOUNT_SERVICE, mService);\n        }\n\n        @Override\n        public void onUserUnlocking(@NonNull TargetUser user) {\n            mService.onUnlockUser(user.getUserIdentifier());\n        }\n\n        @Override\n        public void onUserStopping(@NonNull TargetUser user) {\n            Slog.i(TAG, \"onStopUser \" + user);\n            mService.purgeUserData(user.getUserIdentifier());\n        }\n    }\n\n    final Context mContext;\n\n    private final PackageManager mPackageManager;\n    private final AppOpsManager mAppOpsManager;\n    private UserManager mUserManager;\n    private final Injector mInjector;\n\n    final MessageHandler mHandler;\n\n    private static final int TIMEOUT_DELAY_MS = 1000 * 60 * 15;\n    // Messages that can be sent on mHandler\n    private static final int MESSAGE_TIMED_OUT = 3;\n    private static final int MESSAGE_COPY_SHARED_ACCOUNT = 4;\n\n    private final IAccountAuthenticatorCache mAuthenticatorCache;\n    private static final String PRE_N_DATABASE_NAME = \"accounts.db\";\n    private static final Intent ACCOUNTS_CHANGED_INTENT;\n\n    private static final int SIGNATURE_CHECK_MISMATCH = 0;\n    private static final int SIGNATURE_CHECK_MATCH = 1;\n    private static final int SIGNATURE_CHECK_UID_MATCH = 2;\n\n    static {\n        ACCOUNTS_CHANGED_INTENT = new Intent(AccountManager.LOGIN_ACCOUNTS_CHANGED_ACTION);\n        ACCOUNTS_CHANGED_INTENT.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT\n                | Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);\n    }\n\n    private final LinkedHashMap<String, Session> mSessions = new LinkedHashMap<String, Session>();\n\n    static class UserAccounts {\n        private final int userId;\n        final AccountsDb accountsDb;\n        private final HashMap<Pair<Pair<Account, String>, Integer>, NotificationId>\n                credentialsPermissionNotificationIds = new HashMap<>();\n        private final HashMap<Account, NotificationId> signinRequiredNotificationIds\n                = new HashMap<>();\n        final Object cacheLock = new Object();\n        final Object dbLock = new Object(); // if needed, dbLock must be obtained before cacheLock\n        /** protected by the {@link #cacheLock} */\n        final HashMap<String, Account[]> accountCache = new LinkedHashMap<>();\n        /** protected by the {@link #cacheLock} */\n        private final Map<Account, Map<String, String>> userDataCache = new HashMap<>();\n        /** protected by the {@link #cacheLock} */\n        private final Map<Account, Map<String, String>> authTokenCache = new HashMap<>();\n        /** protected by the {@link #cacheLock} */\n        private final TokenCache accountTokenCaches = new TokenCache();\n        /** protected by the {@link #cacheLock} */\n        private final Map<Account, Map<String, Integer>> visibilityCache = new HashMap<>();\n\n        /** protected by the {@link #mReceiversForType},\n         *  type -> (packageName -> number of active receivers)\n         *  type == null is used to get notifications about all account types\n         */\n        private final Map<String, Map<String, Integer>> mReceiversForType = new HashMap<>();\n\n        /**\n         * protected by the {@link #cacheLock}\n         *\n         * Caches the previous names associated with an account. Previous names\n         * should be cached because we expect that when an Account is renamed,\n         * many clients will receive a LOGIN_ACCOUNTS_CHANGED broadcast and\n         * want to know if the accounts they care about have been renamed.\n         *\n         * The previous names are wrapped in an {@link AtomicReference} so that\n         * we can distinguish between those accounts with no previous names and\n         * those whose previous names haven't been cached (yet).\n         */\n        private final HashMap<Account, AtomicReference<String>> previousNameCache =\n                new HashMap<Account, AtomicReference<String>>();\n\n        UserAccounts(Context context, int userId, File preNDbFile, File deDbFile) {\n            this.userId = userId;\n            synchronized (dbLock) {\n                synchronized (cacheLock) {\n                    accountsDb = AccountsDb.create(context, userId, preNDbFile, deDbFile);\n                }\n            }\n        }\n    }\n\n    private final SparseArray<UserAccounts> mUsers = new SparseArray<>();\n    private final SparseBooleanArray mLocalUnlockedUsers = new SparseBooleanArray();\n    // Not thread-safe. Only use in synchronized context\n    private final SimpleDateFormat mDateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n    private CopyOnWriteArrayList<AccountManagerInternal.OnAppPermissionChangeListener>\n            mAppPermissionChangeListeners = new CopyOnWriteArrayList<>();\n\n    private static AtomicReference<AccountManagerService> sThis = new AtomicReference<>();\n    private static final Account[] EMPTY_ACCOUNT_ARRAY = new Account[]{};\n\n    /**\n     * This should only be called by system code. One should only call this after the service\n     * has started.\n     * @return a reference to the AccountManagerService instance\n     * @hide\n     */\n    public static AccountManagerService getSingleton() {\n        return sThis.get();\n    }\n\n    public AccountManagerService(Injector injector) {\n        mInjector = injector;\n        mContext = injector.getContext();\n        mPackageManager = mContext.getPackageManager();\n        mAppOpsManager = mContext.getSystemService(AppOpsManager.class);\n        mHandler = new MessageHandler(injector.getMessageHandlerLooper());\n        mAuthenticatorCache = mInjector.getAccountAuthenticatorCache();\n        mAuthenticatorCache.setListener(this, mHandler);\n\n        sThis.set(this);\n\n        IntentFilter intentFilter = new IntentFilter();\n        intentFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);\n        intentFilter.addDataScheme(\"package\");\n        mContext.registerReceiver(new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context1, Intent intent) {\n                // Don't delete accounts when updating a authenticator's\n                // package.\n                if (!intent.getBooleanExtra(Intent.EXTRA_REPLACING, false)) {\n                    /* Purging data requires file io, don't block the main thread. This is probably\n                     * less than ideal because we are introducing a race condition where old grants\n                     * could be exercised until they are purged. But that race condition existed\n                     * anyway with the broadcast receiver.\n                     *\n                     * Ideally, we would completely clear the cache, purge data from the database,\n                     * and then rebuild the cache. All under the cache lock. But that change is too\n                     * large at this point.\n                     */\n                    final String removedPackageName = intent.getData().getSchemeSpecificPart();\n                    Runnable purgingRunnable = new Runnable() {\n                        @Override\n                        public void run() {\n                            purgeOldGrantsAll();\n                            // Notify authenticator about removed app?\n                            removeVisibilityValuesForPackage(removedPackageName);\n                        }\n                    };\n                    mHandler.post(purgingRunnable);\n                }\n            }\n        }, intentFilter);\n\n        injector.addLocalService(new AccountManagerInternalImpl());\n\n        IntentFilter userFilter = new IntentFilter();\n        userFilter.addAction(Intent.ACTION_USER_REMOVED);\n        mContext.registerReceiverAsUser(new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                String action = intent.getAction();\n                if (Intent.ACTION_USER_REMOVED.equals(action)) {\n                    int userId = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, -1);\n                    if (userId < 1) return;\n                    Slog.i(TAG, \"User \" + userId + \" removed\");\n                    purgeUserData(userId);\n                }\n            }\n        }, UserHandle.ALL, userFilter, null, null);\n\n        // Need to cancel account request notifications if the update/install can access the account\n        new PackageMonitor() {\n            @Override\n            public void onPackageAdded(String packageName, int uid) {\n                // Called on a handler, and running as the system\n                cancelAccountAccessRequestNotificationIfNeeded(uid, true);\n            }\n\n            @Override\n            public void onPackageUpdateFinished(String packageName, int uid) {\n                // Called on a handler, and running as the system\n                cancelAccountAccessRequestNotificationIfNeeded(uid, true);\n            }\n        }.register(mContext, mHandler.getLooper(), UserHandle.ALL, true);\n\n        // Cancel account request notification if an app op was preventing the account access\n        mAppOpsManager.startWatchingMode(AppOpsManager.OP_GET_ACCOUNTS, null,\n                new AppOpsManager.OnOpChangedInternalListener() {\n            @Override\n            public void onOpChanged(int op, String packageName) {\n                try {\n                    final int userId = ActivityManager.getCurrentUser();\n                    final int uid = mPackageManager.getPackageUidAsUser(packageName, userId);\n                    final int mode = mAppOpsManager.checkOpNoThrow(\n                            AppOpsManager.OP_GET_ACCOUNTS, uid, packageName);\n                    if (mode == AppOpsManager.MODE_ALLOWED) {\n                        final long identity = Binder.clearCallingIdentity();\n                        try {\n                            cancelAccountAccessRequestNotificationIfNeeded(packageName, uid, true);\n                        } finally {\n                            Binder.restoreCallingIdentity(identity);\n                        }\n                    }\n                } catch (NameNotFoundException e) {\n                    /* ignore */\n                }\n            }\n        });\n\n        // Cancel account request notification if a permission was preventing the account access\n        mPackageManager.addOnPermissionsChangeListener(\n                (int uid) -> {\n            // Permission changes cause requires updating accounts cache.\n            AccountManager.invalidateLocalAccountsDataCaches();\n\n            Account[] accounts = null;\n            String[] packageNames = mPackageManager.getPackagesForUid(uid);\n            if (packageNames != null) {\n                final int userId = UserHandle.getUserId(uid);\n                final long identity = Binder.clearCallingIdentity();\n                try {\n                    for (String packageName : packageNames) {\n                                // if app asked for permission we need to cancel notification even\n                                // for O+ applications.\n                                if (mPackageManager.checkPermission(\n                                        Manifest.permission.GET_ACCOUNTS,\n                                        packageName) != PackageManager.PERMISSION_GRANTED) {\n                                    continue;\n                                }\n\n                        if (accounts == null) {\n                            accounts = getAccountsAsUser(null, userId, \"android\");\n                            if (ArrayUtils.isEmpty(accounts)) {\n                                return;\n                            }\n                        }\n\n                        for (Account account : accounts) {\n                            cancelAccountAccessRequestNotificationIfNeeded(\n                                    account, uid, packageName, true);\n                        }\n                    }\n                } finally {\n                    Binder.restoreCallingIdentity(identity);\n                }\n            }\n        });\n    }\n\n\n    boolean getBindInstantServiceAllowed(int userId) {\n        return  mAuthenticatorCache.getBindInstantServiceAllowed(userId);\n    }\n\n    void setBindInstantServiceAllowed(int userId, boolean allowed) {\n        mAuthenticatorCache.setBindInstantServiceAllowed(userId, allowed);\n    }\n\n    private void cancelAccountAccessRequestNotificationIfNeeded(int uid,\n            boolean checkAccess) {\n        Account[] accounts = getAccountsAsUser(null, UserHandle.getUserId(uid), \"android\");\n        for (Account account : accounts) {\n            cancelAccountAccessRequestNotificationIfNeeded(account, uid, checkAccess);\n        }\n    }\n\n    private void cancelAccountAccessRequestNotificationIfNeeded(String packageName, int uid,\n            boolean checkAccess) {\n        Account[] accounts = getAccountsAsUser(null, UserHandle.getUserId(uid), \"android\");\n        for (Account account : accounts) {\n            cancelAccountAccessRequestNotificationIfNeeded(account, uid, packageName, checkAccess);\n        }\n    }\n\n    private void cancelAccountAccessRequestNotificationIfNeeded(Account account, int uid,\n            boolean checkAccess) {\n        String[] packageNames = mPackageManager.getPackagesForUid(uid);\n        if (packageNames != null) {\n            for (String packageName : packageNames) {\n                cancelAccountAccessRequestNotificationIfNeeded(account, uid,\n                        packageName, checkAccess);\n            }\n        }\n    }\n\n    private void cancelAccountAccessRequestNotificationIfNeeded(Account account,\n            int uid, String packageName, boolean checkAccess) {\n        if (!checkAccess || hasAccountAccess(account, packageName,\n                UserHandle.getUserHandleForUid(uid))) {\n            cancelNotification(getCredentialPermissionNotificationId(account,\n                    AccountManager.ACCOUNT_ACCESS_TOKEN_TYPE, uid),\n                    UserHandle.getUserHandleForUid(uid));\n        }\n    }\n\n    @Override\n    public boolean addAccountExplicitlyWithVisibility(Account account, String password,\n            Bundle extras, Map packageToVisibility, String opPackageName) {\n        Bundle.setDefusable(extras, true);\n        int callingUid = Binder.getCallingUid();\n        int userId = UserHandle.getCallingUserId();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"addAccountExplicitly: \" + account + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\"uid %s cannot explicitly add accounts of type: %s\",\n                    callingUid, account.type);\n            throw new SecurityException(msg);\n        }\n        /*\n         * Child users are not allowed to add accounts. Only the accounts that are shared by the\n         * parent profile can be added to child profile.\n         *\n         * TODO: Only allow accounts that were shared to be added by a limited user.\n         */\n        // fails if the account already exists\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return addAccountInternal(accounts, account, password, extras, callingUid,\n                    (Map<String, Integer>) packageToVisibility, opPackageName);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public Map<Account, Integer> getAccountsAndVisibilityForPackage(String packageName,\n            String accountType) {\n        int callingUid = Binder.getCallingUid();\n        int userId = UserHandle.getCallingUserId();\n        boolean isSystemUid = UserHandle.isSameApp(callingUid, Process.SYSTEM_UID);\n        List<String> managedTypes = getTypesForCaller(callingUid, userId, isSystemUid);\n\n        if ((accountType != null && !managedTypes.contains(accountType))\n                || (accountType == null && !isSystemUid)) {\n            throw new SecurityException(\n                    \"getAccountsAndVisibilityForPackage() called from unauthorized uid \"\n                            + callingUid + \" with packageName=\" + packageName);\n        }\n        if (accountType != null) {\n            managedTypes = new ArrayList<String>();\n            managedTypes.add(accountType);\n        }\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return getAccountsAndVisibilityForPackage(packageName, managedTypes, callingUid,\n                    accounts);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    /*\n     * accountTypes may not be null\n     */\n    private Map<Account, Integer> getAccountsAndVisibilityForPackage(String packageName,\n            List<String> accountTypes, Integer callingUid, UserAccounts accounts) {\n        if (!packageExistsForUser(packageName, accounts.userId)) {\n            Log.d(TAG, \"Package not found \" + packageName);\n            return new LinkedHashMap<>();\n        }\n\n        Map<Account, Integer> result = new LinkedHashMap<>();\n        for (String accountType : accountTypes) {\n            synchronized (accounts.dbLock) {\n                synchronized (accounts.cacheLock) {\n                    final Account[] accountsOfType = accounts.accountCache.get(accountType);\n                    if (accountsOfType != null) {\n                        for (Account account : accountsOfType) {\n                            result.put(account,\n                                    resolveAccountVisibility(account, packageName, accounts));\n                        }\n                    }\n                }\n            }\n        }\n        return filterSharedAccounts(accounts, result, callingUid, packageName);\n    }\n\n    @Override\n    public Map<String, Integer> getPackagesAndVisibilityForAccount(Account account) {\n        Objects.requireNonNull(account, \"account cannot be null\");\n        int callingUid = Binder.getCallingUid();\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)\n                && !isSystemUid(callingUid)) {\n            String msg =\n                    String.format(\"uid %s cannot get secrets for account %s\", callingUid, account);\n            throw new SecurityException(msg);\n        }\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            synchronized (accounts.dbLock) {\n                synchronized (accounts.cacheLock) {\n                    return getPackagesAndVisibilityForAccountLocked(account, accounts);\n                }\n            }\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n\n    }\n\n    /**\n     * Returns Map with all package names and visibility values for given account.\n     * The method and returned map must be guarded by accounts.cacheLock\n     *\n     * @param account Account to get visibility values.\n     * @param accounts UserAccount that currently hosts the account and application\n     *\n     * @return Map with cache for package names to visibility.\n     */\n    private @NonNull Map<String, Integer> getPackagesAndVisibilityForAccountLocked(Account account,\n            UserAccounts accounts) {\n        Map<String, Integer> accountVisibility = accounts.visibilityCache.get(account);\n        if (accountVisibility == null) {\n            Log.d(TAG, \"Visibility was not initialized\");\n            accountVisibility = new HashMap<>();\n            accounts.visibilityCache.put(account, accountVisibility);\n            AccountManager.invalidateLocalAccountsDataCaches();\n        }\n        return accountVisibility;\n    }\n\n    @Override\n    public int getAccountVisibility(Account account, String packageName) {\n        Objects.requireNonNull(account, \"account cannot be null\");\n        Objects.requireNonNull(packageName, \"packageName cannot be null\");\n        int callingUid = Binder.getCallingUid();\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)\n            && !isSystemUid(callingUid)) {\n            String msg = String.format(\n                    \"uid %s cannot get secrets for accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            if (AccountManager.PACKAGE_NAME_KEY_LEGACY_VISIBLE.equals(packageName)) {\n                int visibility = getAccountVisibilityFromCache(account, packageName, accounts);\n                if (AccountManager.VISIBILITY_UNDEFINED != visibility) {\n                    return visibility;\n                } else {\n                   return AccountManager.VISIBILITY_USER_MANAGED_VISIBLE;\n                }\n            }\n            if (AccountManager.PACKAGE_NAME_KEY_LEGACY_NOT_VISIBLE.equals(packageName)) {\n                int visibility = getAccountVisibilityFromCache(account, packageName, accounts);\n                if (AccountManager.VISIBILITY_UNDEFINED != visibility) {\n                    return visibility;\n                } else {\n                   return AccountManager.VISIBILITY_USER_MANAGED_NOT_VISIBLE;\n                }\n            }\n            return resolveAccountVisibility(account, packageName, accounts);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    /**\n     * Method returns visibility for given account and package name.\n     *\n     * @param account The account to check visibility.\n     * @param packageName Package name to check visibility.\n     * @param accounts UserAccount that currently hosts the account and application\n     *\n     * @return Visibility value, AccountManager.VISIBILITY_UNDEFINED if no value was stored.\n     *\n     */\n    private int getAccountVisibilityFromCache(Account account, String packageName,\n            UserAccounts accounts) {\n        synchronized (accounts.cacheLock) {\n            Map<String, Integer> accountVisibility =\n                    getPackagesAndVisibilityForAccountLocked(account, accounts);\n            Integer visibility = accountVisibility.get(packageName);\n            return visibility != null ? visibility : AccountManager.VISIBILITY_UNDEFINED;\n        }\n    }\n\n    /**\n     * Method which handles default values for Account visibility.\n     *\n     * @param account The account to check visibility.\n     * @param packageName Package name to check visibility\n     * @param accounts UserAccount that currently hosts the account and application\n     *\n     * @return Visibility value, the method never returns AccountManager.VISIBILITY_UNDEFINED\n     *\n     */\n    private Integer resolveAccountVisibility(Account account, @NonNull String packageName,\n            UserAccounts accounts) {\n        Objects.requireNonNull(packageName, \"packageName cannot be null\");\n        int uid = -1;\n        try {\n            final long identityToken = clearCallingIdentity();\n            try {\n                uid = mPackageManager.getPackageUidAsUser(packageName, accounts.userId);\n            } finally {\n                restoreCallingIdentity(identityToken);\n            }\n        } catch (NameNotFoundException e) {\n            Log.d(TAG, \"Package not found \" + e.getMessage());\n            return AccountManager.VISIBILITY_NOT_VISIBLE;\n        }\n\n        // System visibility can not be restricted.\n        if (UserHandle.isSameApp(uid, Process.SYSTEM_UID)) {\n            return AccountManager.VISIBILITY_VISIBLE;\n        }\n\n        int signatureCheckResult =\n                checkPackageSignature(account.type, uid, accounts.userId);\n\n        // Authenticator can not restrict visibility to itself.\n        if (signatureCheckResult == SIGNATURE_CHECK_UID_MATCH) {\n            return AccountManager.VISIBILITY_VISIBLE; // Authenticator can always see the account\n        }\n\n        // Return stored value if it was set.\n        int visibility = getAccountVisibilityFromCache(account, packageName, accounts);\n\n        if (AccountManager.VISIBILITY_UNDEFINED != visibility) {\n            return visibility;\n        }\n\n        boolean isPrivileged = isPermittedForPackage(packageName, accounts.userId,\n                Manifest.permission.GET_ACCOUNTS_PRIVILEGED);\n\n        // Device/Profile owner gets visibility by default.\n        if (isProfileOwner(uid)) {\n            return AccountManager.VISIBILITY_VISIBLE;\n        }\n\n        boolean preO = isPreOApplication(packageName);\n        if ((signatureCheckResult != SIGNATURE_CHECK_MISMATCH)\n                || (preO && checkGetAccountsPermission(packageName, accounts.userId))\n                || (checkReadContactsPermission(packageName, accounts.userId)\n                    && accountTypeManagesContacts(account.type, accounts.userId))\n                || isPrivileged) {\n            // Use legacy for preO apps with GET_ACCOUNTS permission or pre/postO with signature\n            // match.\n            visibility = getAccountVisibilityFromCache(account,\n                    AccountManager.PACKAGE_NAME_KEY_LEGACY_VISIBLE, accounts);\n            if (AccountManager.VISIBILITY_UNDEFINED == visibility) {\n                visibility = AccountManager.VISIBILITY_USER_MANAGED_VISIBLE;\n            }\n        } else {\n            visibility = getAccountVisibilityFromCache(account,\n                    AccountManager.PACKAGE_NAME_KEY_LEGACY_NOT_VISIBLE, accounts);\n            if (AccountManager.VISIBILITY_UNDEFINED == visibility) {\n                visibility = AccountManager.VISIBILITY_USER_MANAGED_NOT_VISIBLE;\n            }\n        }\n        return visibility;\n    }\n\n    /**\n     * Checks targetSdk for a package;\n     *\n     * @param packageName Package name\n     *\n     * @return True if package's target SDK is below {@link android.os.Build.VERSION_CODES#O}, or\n     *         undefined\n     */\n    private boolean isPreOApplication(String packageName) {\n        try {\n            final long identityToken = clearCallingIdentity();\n            ApplicationInfo applicationInfo;\n            try {\n                applicationInfo = mPackageManager.getApplicationInfo(packageName, 0);\n            } finally {\n                restoreCallingIdentity(identityToken);\n            }\n\n            if (applicationInfo != null) {\n                int version = applicationInfo.targetSdkVersion;\n                return version < android.os.Build.VERSION_CODES.O;\n            }\n            return true;\n        } catch (NameNotFoundException e) {\n            Log.d(TAG, \"Package not found \" + e.getMessage());\n            return true;\n        }\n    }\n\n    @Override\n    public boolean setAccountVisibility(Account account, String packageName, int newVisibility) {\n        Objects.requireNonNull(account, \"account cannot be null\");\n        Objects.requireNonNull(packageName, \"packageName cannot be null\");\n        int callingUid = Binder.getCallingUid();\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)\n            && !isSystemUid(callingUid)) {\n            String msg = String.format(\n                    \"uid %s cannot get secrets for accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return setAccountVisibility(account, packageName, newVisibility, true /* notify */,\n                accounts);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private boolean isVisible(int visibility) {\n        return visibility == AccountManager.VISIBILITY_VISIBLE ||\n            visibility == AccountManager.VISIBILITY_USER_MANAGED_VISIBLE;\n    }\n\n    /**\n     * Updates visibility for given account name and package.\n     *\n     * @param account Account to update visibility.\n     * @param packageName Package name for which visibility is updated.\n     * @param newVisibility New visibility calue\n     * @param notify if the flag is set applications will get notification about visibility change\n     * @param accounts UserAccount that currently hosts the account and application\n     *\n     * @return True if account visibility was changed.\n     */\n    private boolean setAccountVisibility(Account account, String packageName, int newVisibility,\n            boolean notify, UserAccounts accounts) {\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                Map<String, Integer> packagesToVisibility;\n                List<String> accountRemovedReceivers;\n                if (notify) {\n                    if (isSpecialPackageKey(packageName)) {\n                        packagesToVisibility =\n                                getRequestingPackages(account, accounts);\n                        accountRemovedReceivers = getAccountRemovedReceivers(account, accounts);\n                    } else {\n                        if (!packageExistsForUser(packageName, accounts.userId)) {\n                            return false; // package is not installed.\n                        }\n                        packagesToVisibility = new HashMap<>();\n                        packagesToVisibility.put(packageName,\n                                resolveAccountVisibility(account, packageName, accounts));\n                        accountRemovedReceivers = new ArrayList<>();\n                        if (shouldNotifyPackageOnAccountRemoval(account, packageName, accounts)) {\n                            accountRemovedReceivers.add(packageName);\n                        }\n                    }\n                } else {\n                    // Notifications will not be send - only used during add account.\n                    if (!isSpecialPackageKey(packageName) &&\n                            !packageExistsForUser(packageName, accounts.userId)) {\n                        // package is not installed and not meta value.\n                        return false;\n                    }\n                    packagesToVisibility = Collections.emptyMap();\n                    accountRemovedReceivers = Collections.emptyList();\n                }\n\n                if (!updateAccountVisibilityLocked(account, packageName, newVisibility, accounts)) {\n                    return false;\n                }\n\n                if (notify) {\n                    for (Entry<String, Integer> packageToVisibility : packagesToVisibility\n                            .entrySet()) {\n                        int oldVisibility = packageToVisibility.getValue();\n                        int currentVisibility =\n                            resolveAccountVisibility(account, packageName, accounts);\n                        if (isVisible(oldVisibility) != isVisible(currentVisibility)) {\n                            notifyPackage(packageToVisibility.getKey(), accounts);\n                        }\n                    }\n                    for (String packageNameToNotify : accountRemovedReceivers) {\n                        sendAccountRemovedBroadcast(account, packageNameToNotify, accounts.userId);\n                    }\n                    sendAccountsChangedBroadcast(accounts.userId);\n                }\n                return true;\n            }\n        }\n    }\n\n    // Update account visibility in cache and database.\n    private boolean updateAccountVisibilityLocked(Account account, String packageName,\n            int newVisibility, UserAccounts accounts) {\n        final long accountId = accounts.accountsDb.findDeAccountId(account);\n        if (accountId < 0) {\n            return false;\n        }\n\n        final StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskWrites();\n        try {\n            if (!accounts.accountsDb.setAccountVisibility(accountId, packageName,\n                    newVisibility)) {\n                return false;\n            }\n        } finally {\n            StrictMode.setThreadPolicy(oldPolicy);\n        }\n        Map<String, Integer> accountVisibility =\n            getPackagesAndVisibilityForAccountLocked(account, accounts);\n        accountVisibility.put(packageName, newVisibility);\n        AccountManager.invalidateLocalAccountsDataCaches();\n        return true;\n    }\n\n    @Override\n    public void registerAccountListener(String[] accountTypes, String opPackageName) {\n        int callingUid = Binder.getCallingUid();\n        mAppOpsManager.checkPackage(callingUid, opPackageName);\n\n        int userId = UserHandle.getCallingUserId();\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            registerAccountListener(accountTypes, opPackageName, accounts);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private void registerAccountListener(String[] accountTypes, String opPackageName,\n            UserAccounts accounts) {\n        synchronized (accounts.mReceiversForType) {\n            if (accountTypes == null) {\n                // null for any type\n                accountTypes = new String[] {null};\n            }\n            for (String type : accountTypes) {\n                Map<String, Integer> receivers = accounts.mReceiversForType.get(type);\n                if (receivers == null) {\n                    receivers = new HashMap<>();\n                    accounts.mReceiversForType.put(type, receivers);\n                }\n                Integer cnt = receivers.get(opPackageName);\n                receivers.put(opPackageName, cnt != null ? cnt + 1 : 1);\n            }\n        }\n    }\n\n    @Override\n    public void unregisterAccountListener(String[] accountTypes, String opPackageName) {\n        int callingUid = Binder.getCallingUid();\n        mAppOpsManager.checkPackage(callingUid, opPackageName);\n        int userId = UserHandle.getCallingUserId();\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            unregisterAccountListener(accountTypes, opPackageName, accounts);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private void unregisterAccountListener(String[] accountTypes, String opPackageName,\n            UserAccounts accounts) {\n        synchronized (accounts.mReceiversForType) {\n            if (accountTypes == null) {\n                // null for any type\n                accountTypes = new String[] {null};\n            }\n            for (String type : accountTypes) {\n                Map<String, Integer> receivers = accounts.mReceiversForType.get(type);\n                if (receivers == null || receivers.get(opPackageName) == null) {\n                    throw new IllegalArgumentException(\"attempt to unregister wrong receiver\");\n                }\n                Integer cnt = receivers.get(opPackageName);\n                if (cnt == 1) {\n                    receivers.remove(opPackageName);\n                } else {\n                    receivers.put(opPackageName, cnt - 1);\n                }\n            }\n        }\n    }\n\n    // Send notification to all packages which can potentially see the account\n    private void sendNotificationAccountUpdated(Account account, UserAccounts accounts) {\n        Map<String, Integer> packagesToVisibility = getRequestingPackages(account, accounts);\n\n        for (Entry<String, Integer> packageToVisibility : packagesToVisibility.entrySet()) {\n            if ((packageToVisibility.getValue() != AccountManager.VISIBILITY_NOT_VISIBLE)\n                    && (packageToVisibility.getValue()\n                        != AccountManager.VISIBILITY_USER_MANAGED_NOT_VISIBLE)) {\n                notifyPackage(packageToVisibility.getKey(), accounts);\n            }\n        }\n    }\n\n    /**\n     * Sends a direct intent to a package, notifying it of account visibility change.\n     *\n     * @param packageName to send Account to\n     * @param accounts UserAccount that currently hosts the account\n     */\n    private void notifyPackage(String packageName, UserAccounts accounts) {\n        Intent intent = new Intent(AccountManager.ACTION_VISIBLE_ACCOUNTS_CHANGED);\n        intent.setPackage(packageName);\n        intent.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);\n        mContext.sendBroadcastAsUser(intent, new UserHandle(accounts.userId));\n    }\n\n    // Returns a map from package name to visibility, for packages subscribed\n    // to notifications about any account type, or type of provided account\n    // account type or all types.\n    private Map<String, Integer> getRequestingPackages(Account account, UserAccounts accounts) {\n        Set<String> packages = new HashSet<>();\n        synchronized (accounts.mReceiversForType) {\n            for (String type : new String[] {account.type, null}) {\n                Map<String, Integer> receivers = accounts.mReceiversForType.get(type);\n                if (receivers != null) {\n                    packages.addAll(receivers.keySet());\n                }\n            }\n        }\n        Map<String, Integer> result = new HashMap<>();\n        for (String packageName : packages) {\n            result.put(packageName, resolveAccountVisibility(account, packageName, accounts));\n        }\n        return result;\n    }\n\n    // Returns a list of packages listening to ACTION_ACCOUNT_REMOVED able to see the account.\n    private List<String> getAccountRemovedReceivers(Account account, UserAccounts accounts) {\n        Intent intent = new Intent(AccountManager.ACTION_ACCOUNT_REMOVED);\n        intent.setFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);\n        List<ResolveInfo> receivers =\n            mPackageManager.queryBroadcastReceiversAsUser(intent, 0, accounts.userId);\n        List<String> result = new ArrayList<>();\n        if (receivers == null) {\n            return result;\n        }\n        for (ResolveInfo resolveInfo: receivers) {\n            String packageName = resolveInfo.activityInfo.applicationInfo.packageName;\n            int visibility = resolveAccountVisibility(account, packageName, accounts);\n            if (visibility == AccountManager.VISIBILITY_VISIBLE\n                || visibility == AccountManager.VISIBILITY_USER_MANAGED_VISIBLE) {\n                result.add(packageName);\n            }\n        }\n        return result;\n    }\n\n    // Returns true if given package is listening to ACTION_ACCOUNT_REMOVED and can see the account.\n    private boolean shouldNotifyPackageOnAccountRemoval(Account account,\n            String packageName, UserAccounts accounts) {\n        int visibility = resolveAccountVisibility(account, packageName, accounts);\n        if (visibility != AccountManager.VISIBILITY_VISIBLE\n            && visibility != AccountManager.VISIBILITY_USER_MANAGED_VISIBLE) {\n            return false;\n        }\n\n        Intent intent = new Intent(AccountManager.ACTION_ACCOUNT_REMOVED);\n        intent.setFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);\n        intent.setPackage(packageName);\n        List<ResolveInfo> receivers =\n            mPackageManager.queryBroadcastReceiversAsUser(intent, 0, accounts.userId);\n        return (receivers != null && receivers.size() > 0);\n    }\n\n    private boolean packageExistsForUser(String packageName, int userId) {\n        try {\n            final long identityToken = clearCallingIdentity();\n            try {\n                mPackageManager.getPackageUidAsUser(packageName, userId);\n                return true;\n            } finally {\n                restoreCallingIdentity(identityToken);\n            }\n        } catch (NameNotFoundException e) {\n            return false;\n        }\n    }\n\n    /**\n     * Returns true if packageName is one of special values.\n     */\n    private boolean isSpecialPackageKey(String packageName) {\n        return (AccountManager.PACKAGE_NAME_KEY_LEGACY_VISIBLE.equals(packageName)\n                || AccountManager.PACKAGE_NAME_KEY_LEGACY_NOT_VISIBLE.equals(packageName));\n    }\n\n    private void sendAccountsChangedBroadcast(int userId) {\n        Log.i(TAG, \"the accounts changed, sending broadcast of \"\n                + ACCOUNTS_CHANGED_INTENT.getAction());\n        mContext.sendBroadcastAsUser(ACCOUNTS_CHANGED_INTENT, new UserHandle(userId));\n    }\n\n    private void sendAccountRemovedBroadcast(Account account, String packageName, int userId) {\n        Intent intent = new Intent(AccountManager.ACTION_ACCOUNT_REMOVED);\n        intent.setFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);\n        intent.setPackage(packageName);\n        intent.putExtra(AccountManager.KEY_ACCOUNT_NAME, account.name);\n        intent.putExtra(AccountManager.KEY_ACCOUNT_TYPE, account.type);\n        mContext.sendBroadcastAsUser(intent, new UserHandle(userId));\n    }\n\n    @Override\n    public boolean onTransact(int code, Parcel data, Parcel reply, int flags)\n            throws RemoteException {\n        try {\n            return super.onTransact(code, data, reply, flags);\n        } catch (RuntimeException e) {\n            // The account manager only throws security exceptions, so let's\n            // log all others.\n            if (!(e instanceof SecurityException || e instanceof IllegalArgumentException)) {\n                Slog.wtf(TAG, \"Account Manager Crash\", e);\n            }\n            throw e;\n        }\n    }\n\n    private UserManager getUserManager() {\n        if (mUserManager == null) {\n            mUserManager = UserManager.get(mContext);\n        }\n        return mUserManager;\n    }\n\n    /**\n     * Validate internal set of accounts against installed authenticators for\n     * given user. Clears cached authenticators before validating.\n     */\n    public void validateAccounts(int userId) {\n        final UserAccounts accounts = getUserAccounts(userId);\n        // Invalidate user-specific cache to make sure we catch any\n        // removed authenticators.\n        validateAccountsInternal(accounts, true /* invalidateAuthenticatorCache */);\n    }\n\n    /**\n     * Validate internal set of accounts against installed authenticators for\n     * given user. Clear cached authenticators before validating when requested.\n     */\n    private void validateAccountsInternal(\n            UserAccounts accounts, boolean invalidateAuthenticatorCache) {\n        if (Log.isLoggable(TAG, Log.DEBUG)) {\n            Log.d(TAG, \"validateAccountsInternal \" + accounts.userId\n                    + \" isCeDatabaseAttached=\" + accounts.accountsDb.isCeDatabaseAttached()\n                    + \" userLocked=\" + mLocalUnlockedUsers.get(accounts.userId));\n        }\n\n        if (invalidateAuthenticatorCache) {\n            mAuthenticatorCache.invalidateCache(accounts.userId);\n        }\n\n        final HashMap<String, Integer> knownAuth = getAuthenticatorTypeAndUIDForUser(\n                mAuthenticatorCache, accounts.userId);\n        boolean userUnlocked = isLocalUnlockedUser(accounts.userId);\n\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                boolean accountDeleted = false;\n\n                // Get a map of stored authenticator types to UID\n                final AccountsDb accountsDb = accounts.accountsDb;\n                Map<String, Integer> metaAuthUid = accountsDb.findMetaAuthUid();\n                // Create a list of authenticator type whose previous uid no longer exists\n                HashSet<String> obsoleteAuthType = Sets.newHashSet();\n                SparseBooleanArray knownUids = null;\n                for (Entry<String, Integer> authToUidEntry : metaAuthUid.entrySet()) {\n                    String type = authToUidEntry.getKey();\n                    int uid = authToUidEntry.getValue();\n                    Integer knownUid = knownAuth.get(type);\n                    if (knownUid != null && uid == knownUid) {\n                        // Remove it from the knownAuth list if it's unchanged.\n                        knownAuth.remove(type);\n                    } else {\n                    /*\n                     * The authenticator is presently not cached and should only be triggered\n                     * when we think an authenticator has been removed (or is being updated).\n                     * But we still want to check if any data with the associated uid is\n                     * around. This is an (imperfect) signal that the package may be updating.\n                     *\n                     * A side effect of this is that an authenticator sharing a uid with\n                     * multiple apps won't get its credentials wiped as long as some app with\n                     * that uid is still on the device. But I suspect that this is a rare case.\n                     * And it isn't clear to me how an attacker could really exploit that\n                     * feature.\n                     *\n                     * The upshot is that we don't have to worry about accounts getting\n                     * uninstalled while the authenticator's package is being updated.\n                     *\n                     */\n                        if (knownUids == null) {\n                            knownUids = getUidsOfInstalledOrUpdatedPackagesAsUser(accounts.userId);\n                        }\n                        if (!knownUids.get(uid)) {\n                            // The authenticator is not presently available to the cache. And the\n                            // package no longer has a data directory (so we surmise it isn't\n                            // updating). So purge its data from the account databases.\n                            obsoleteAuthType.add(type);\n                            // And delete it from the TABLE_META\n                            accountsDb.deleteMetaByAuthTypeAndUid(type, uid);\n                        } else if (knownUid != null && knownUid != uid) {\n                            Slog.w(TAG, \"authenticator no longer exist for type \" + type);\n                            obsoleteAuthType.add(type);\n                            accountsDb.deleteMetaByAuthTypeAndUid(type, uid);\n                        }\n                    }\n                }\n\n                // Add the newly registered authenticator to TABLE_META. If old authenticators have\n                // been re-enabled (after being updated for example), then we just overwrite the old\n                // values.\n                for (Entry<String, Integer> entry : knownAuth.entrySet()) {\n                    accountsDb.insertOrReplaceMetaAuthTypeAndUid(entry.getKey(), entry.getValue());\n                }\n\n                final Map<Long, Account> accountsMap = accountsDb.findAllDeAccounts();\n                try {\n                    accounts.accountCache.clear();\n                    final HashMap<String, ArrayList<String>> accountNamesByType\n                            = new LinkedHashMap<>();\n                    for (Entry<Long, Account> accountEntry : accountsMap.entrySet()) {\n                        final long accountId = accountEntry.getKey();\n                        final Account account = accountEntry.getValue();\n                        if (obsoleteAuthType.contains(account.type)) {\n                            Slog.w(TAG, \"deleting account \" + account.toSafeString()\n                                    + \" because type \" + account.type\n                                    + \"'s registered authenticator no longer exist.\");\n                            Map<String, Integer> packagesToVisibility =\n                                    getRequestingPackages(account, accounts);\n                            List<String> accountRemovedReceivers =\n                                getAccountRemovedReceivers(account, accounts);\n                            accountsDb.beginTransaction();\n                            try {\n                                accountsDb.deleteDeAccount(accountId);\n                                // Also delete from CE table if user is unlocked; if user is\n                                // currently locked the account will be removed later by\n                                // syncDeCeAccountsLocked\n                                if (userUnlocked) {\n                                    accountsDb.deleteCeAccount(accountId);\n                                }\n                                accountsDb.setTransactionSuccessful();\n                            } finally {\n                                accountsDb.endTransaction();\n                            }\n                            accountDeleted = true;\n\n                            logRecord(AccountsDb.DEBUG_ACTION_AUTHENTICATOR_REMOVE,\n                                    AccountsDb.TABLE_ACCOUNTS, accountId, accounts);\n\n                            accounts.userDataCache.remove(account);\n                            accounts.authTokenCache.remove(account);\n                            accounts.accountTokenCaches.remove(account);\n                            accounts.visibilityCache.remove(account);\n\n                            for (Entry<String, Integer> packageToVisibility :\n                                    packagesToVisibility.entrySet()) {\n                                if (isVisible(packageToVisibility.getValue())) {\n                                    notifyPackage(packageToVisibility.getKey(), accounts);\n                                }\n                            }\n                            for (String packageName : accountRemovedReceivers) {\n                                sendAccountRemovedBroadcast(account, packageName, accounts.userId);\n                            }\n                        } else {\n                            ArrayList<String> accountNames = accountNamesByType.get(account.type);\n                            if (accountNames == null) {\n                                accountNames = new ArrayList<>();\n                                accountNamesByType.put(account.type, accountNames);\n                            }\n                            accountNames.add(account.name);\n                        }\n                    }\n                    for (Map.Entry<String, ArrayList<String>> cur : accountNamesByType.entrySet()) {\n                        final String accountType = cur.getKey();\n                        final ArrayList<String> accountNames = cur.getValue();\n                        final Account[] accountsForType = new Account[accountNames.size()];\n                        for (int i = 0; i < accountsForType.length; i++) {\n                            accountsForType[i] = new Account(accountNames.get(i), accountType,\n                                    UUID.randomUUID().toString());\n                        }\n                        accounts.accountCache.put(accountType, accountsForType);\n                    }\n                    accounts.visibilityCache.putAll(accountsDb.findAllVisibilityValues());\n                    AccountManager.invalidateLocalAccountsDataCaches();\n                } finally {\n                    if (accountDeleted) {\n                        sendAccountsChangedBroadcast(accounts.userId);\n                    }\n                }\n            }\n        }\n    }\n\n    private SparseBooleanArray getUidsOfInstalledOrUpdatedPackagesAsUser(int userId) {\n        // Get the UIDs of all apps that might have data on the device. We want\n        // to preserve user data if the app might otherwise be storing data.\n        List<PackageInfo> pkgsWithData =\n                mPackageManager.getInstalledPackagesAsUser(\n                        PackageManager.MATCH_UNINSTALLED_PACKAGES, userId);\n        SparseBooleanArray knownUids = new SparseBooleanArray(pkgsWithData.size());\n        for (PackageInfo pkgInfo : pkgsWithData) {\n            if (pkgInfo.applicationInfo != null\n                    && (pkgInfo.applicationInfo.flags & ApplicationInfo.FLAG_INSTALLED) != 0) {\n                knownUids.put(pkgInfo.applicationInfo.uid, true);\n            }\n        }\n        return knownUids;\n    }\n\n    static HashMap<String, Integer> getAuthenticatorTypeAndUIDForUser(\n            Context context,\n            int userId) {\n        AccountAuthenticatorCache authCache = new AccountAuthenticatorCache(context);\n        return getAuthenticatorTypeAndUIDForUser(authCache, userId);\n    }\n\n    private static HashMap<String, Integer> getAuthenticatorTypeAndUIDForUser(\n            IAccountAuthenticatorCache authCache,\n            int userId) {\n        HashMap<String, Integer> knownAuth = new LinkedHashMap<>();\n        for (RegisteredServicesCache.ServiceInfo<AuthenticatorDescription> service : authCache\n                .getAllServices(userId)) {\n            knownAuth.put(service.type.type, service.uid);\n        }\n        return knownAuth;\n    }\n\n    private UserAccounts getUserAccountsForCaller() {\n        return getUserAccounts(UserHandle.getCallingUserId());\n    }\n\n    protected UserAccounts getUserAccounts(int userId) {\n        try {\n            return getUserAccountsNotChecked(userId);\n        } catch (RuntimeException e) {\n            if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE)) {\n                // Let it go...\n                throw e;\n            }\n            // User accounts database is corrupted, we must wipe out the whole user, otherwise the\n            // system will crash indefinitely\n            Slog.wtf(TAG, \"Removing user \" + userId + \" due to exception (\" + e + \") reading its \"\n                    + \"account database\");\n            if (userId == ActivityManager.getCurrentUser() && userId != UserHandle.USER_SYSTEM) {\n                Slog.i(TAG, \"Switching to system user first\");\n                try {\n                    ActivityManager.getService().switchUser(UserHandle.USER_SYSTEM);\n                } catch (RemoteException re) {\n                    Slog.e(TAG, \"Could not switch to \" + UserHandle.USER_SYSTEM + \": \" + re);\n                }\n            }\n            if (!getUserManager().removeUserEvenWhenDisallowed(userId)) {\n                Slog.e(TAG, \"could not remove user \" + userId);\n            }\n            throw e;\n        }\n    }\n\n    private UserAccounts getUserAccountsNotChecked(int userId) {\n        synchronized (mUsers) {\n            UserAccounts accounts = mUsers.get(userId);\n            boolean validateAccounts = false;\n            if (accounts == null) {\n                File preNDbFile = new File(mInjector.getPreNDatabaseName(userId));\n                File deDbFile = new File(mInjector.getDeDatabaseName(userId));\n                accounts = new UserAccounts(mContext, userId, preNDbFile, deDbFile);\n                mUsers.append(userId, accounts);\n                purgeOldGrants(accounts);\n                AccountManager.invalidateLocalAccountsDataCaches();\n                validateAccounts = true;\n            }\n            // open CE database if necessary\n            if (!accounts.accountsDb.isCeDatabaseAttached() && mLocalUnlockedUsers.get(userId)) {\n                Log.i(TAG, \"User \" + userId + \" is unlocked - opening CE database\");\n                synchronized (accounts.dbLock) {\n                    synchronized (accounts.cacheLock) {\n                        File ceDatabaseFile = new File(mInjector.getCeDatabaseName(userId));\n                        accounts.accountsDb.attachCeDatabase(ceDatabaseFile);\n                    }\n                }\n                syncDeCeAccountsLocked(accounts);\n            }\n            if (validateAccounts) {\n                validateAccountsInternal(accounts, true /* invalidateAuthenticatorCache */);\n            }\n            return accounts;\n        }\n    }\n\n    private void syncDeCeAccountsLocked(UserAccounts accounts) {\n        Preconditions.checkState(Thread.holdsLock(mUsers), \"mUsers lock must be held\");\n        List<Account> accountsToRemove = accounts.accountsDb.findCeAccountsNotInDe();\n        if (!accountsToRemove.isEmpty()) {\n            Slog.i(TAG, accountsToRemove.size()\n                    + \" accounts were previously deleted while user \"\n                    + accounts.userId + \" was locked. Removing accounts from CE tables\");\n            logRecord(accounts, AccountsDb.DEBUG_ACTION_SYNC_DE_CE_ACCOUNTS,\n                    AccountsDb.TABLE_ACCOUNTS);\n\n            for (Account account : accountsToRemove) {\n                removeAccountInternal(accounts, account, Process.SYSTEM_UID);\n            }\n        }\n    }\n\n    private void purgeOldGrantsAll() {\n        synchronized (mUsers) {\n            for (int i = 0; i < mUsers.size(); i++) {\n                purgeOldGrants(mUsers.valueAt(i));\n            }\n        }\n    }\n\n    private void purgeOldGrants(UserAccounts accounts) {\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                List<Integer> uids = accounts.accountsDb.findAllUidGrants();\n                for (int uid : uids) {\n                    final boolean packageExists = mPackageManager.getPackagesForUid(uid) != null;\n                    if (packageExists) {\n                        continue;\n                    }\n                    Log.d(TAG, \"deleting grants for UID \" + uid\n                            + \" because its package is no longer installed\");\n                    accounts.accountsDb.deleteGrantsByUid(uid);\n                }\n            }\n        }\n    }\n\n    private void removeVisibilityValuesForPackage(String packageName) {\n        if (isSpecialPackageKey(packageName)) {\n            return;\n        }\n        synchronized (mUsers) {\n            int numberOfUsers = mUsers.size();\n            for (int i = 0; i < numberOfUsers; i++) {\n                UserAccounts accounts = mUsers.valueAt(i);\n                try {\n                    mPackageManager.getPackageUidAsUser(packageName, accounts.userId);\n                } catch (NameNotFoundException e) {\n                    // package does not exist - remove visibility values\n                    accounts.accountsDb.deleteAccountVisibilityForPackage(packageName);\n                    synchronized (accounts.dbLock) {\n                        synchronized (accounts.cacheLock) {\n                            for (Account account : accounts.visibilityCache.keySet()) {\n                                Map<String, Integer> accountVisibility =\n                                        getPackagesAndVisibilityForAccountLocked(account, accounts);\n                                accountVisibility.remove(packageName);\n                            }\n                            AccountManager.invalidateLocalAccountsDataCaches();\n                        }\n                    }\n              }\n          }\n        }\n    }\n\n    private void purgeUserData(int userId) {\n        UserAccounts accounts;\n        synchronized (mUsers) {\n            accounts = mUsers.get(userId);\n            mUsers.remove(userId);\n            mLocalUnlockedUsers.delete(userId);\n            AccountManager.invalidateLocalAccountsDataCaches();\n        }\n        if (accounts != null) {\n            synchronized (accounts.dbLock) {\n                synchronized (accounts.cacheLock) {\n                    accounts.accountsDb.closeDebugStatement();\n                    accounts.accountsDb.close();\n                }\n            }\n        }\n    }\n\n    @VisibleForTesting\n    void onUserUnlocked(Intent intent) {\n        onUnlockUser(intent.getIntExtra(Intent.EXTRA_USER_HANDLE, -1));\n    }\n\n    void onUnlockUser(int userId) {\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"onUserUnlocked \" + userId);\n        }\n        synchronized (mUsers) {\n            mLocalUnlockedUsers.put(userId, true);\n        }\n        if (userId < 1) return;\n        mHandler.post(() -> syncSharedAccounts(userId));\n    }\n\n    private void syncSharedAccounts(int userId) {\n        // Check if there's a shared account that needs to be created as an account\n        Account[] sharedAccounts = getSharedAccountsAsUser(userId);\n        if (sharedAccounts == null || sharedAccounts.length == 0) return;\n        Account[] accounts = getAccountsAsUser(null, userId, mContext.getOpPackageName());\n        int parentUserId = UserManager.isSplitSystemUser()\n                ? getUserManager().getUserInfo(userId).restrictedProfileParentId\n                : UserHandle.USER_SYSTEM;\n        if (parentUserId < 0) {\n            Log.w(TAG, \"User \" + userId + \" has shared accounts, but no parent user\");\n            return;\n        }\n        for (Account sa : sharedAccounts) {\n            if (ArrayUtils.contains(accounts, sa)) continue;\n            // Account doesn't exist. Copy it now.\n            copyAccountToUser(null /*no response*/, sa, parentUserId, userId);\n        }\n    }\n\n    @Override\n    public void onServiceChanged(AuthenticatorDescription desc, int userId, boolean removed) {\n        UserInfo user = getUserManager().getUserInfo(userId);\n        if (user == null) {\n            Log.w(TAG, \"onServiceChanged: ignore removed user \" + userId);\n            return;\n        }\n        validateAccountsInternal(getUserAccounts(userId), false /* invalidateAuthenticatorCache */);\n    }\n\n    @Override\n    public String getPassword(Account account) {\n        int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"getPassword: \" + account\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        if (account == null) throw new IllegalArgumentException(\"account is null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot get secrets for accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return readPasswordInternal(accounts, account);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private String readPasswordInternal(UserAccounts accounts, Account account) {\n        if (account == null) {\n            return null;\n        }\n        if (!isLocalUnlockedUser(accounts.userId)) {\n            Log.w(TAG, \"Password is not available - user \" + accounts.userId + \" data is locked\");\n            return null;\n        }\n\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                return accounts.accountsDb\n                        .findAccountPasswordByNameAndType(account.name, account.type);\n            }\n        }\n    }\n\n    @Override\n    public String getPreviousName(Account account) {\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"getPreviousName: \" + account\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        int userId = UserHandle.getCallingUserId();\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return readPreviousNameInternal(accounts, account);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private String readPreviousNameInternal(UserAccounts accounts, Account account) {\n        if  (account == null) {\n            return null;\n        }\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                AtomicReference<String> previousNameRef = accounts.previousNameCache.get(account);\n                if (previousNameRef == null) {\n                    String previousName = accounts.accountsDb.findDeAccountPreviousName(account);\n                    previousNameRef = new AtomicReference<>(previousName);\n                    accounts.previousNameCache.put(account, previousNameRef);\n                    return previousName;\n                } else {\n                    return previousNameRef.get();\n                }\n            }\n        }\n    }\n\n    @Override\n    public String getUserData(Account account, String key) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            String msg = String.format(\"getUserData( account: %s, key: %s, callerUid: %s, pid: %s\",\n                    account, key, callingUid, Binder.getCallingPid());\n            Log.v(TAG, msg);\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        Objects.requireNonNull(key, \"key cannot be null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot get user data for accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        if (!isLocalUnlockedUser(userId)) {\n            Log.w(TAG, \"User \" + userId + \" data is locked. callingUid \" + callingUid);\n            return null;\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            if (!accountExistsCache(accounts, account)) {\n                return null;\n            }\n            return readUserDataInternal(accounts, account, key);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public AuthenticatorDescription[] getAuthenticatorTypes(int userId) {\n        int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"getAuthenticatorTypes: \"\n                    + \"for user id \" + userId\n                    + \" caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        // Only allow the system process to read accounts of other users\n        if (isCrossUser(callingUid, userId)) {\n            throw new SecurityException(\n                    String.format(\n                            \"User %s tying to get authenticator types for %s\" ,\n                            UserHandle.getCallingUserId(),\n                            userId));\n        }\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            return getAuthenticatorTypesInternal(userId);\n\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    /**\n     * Should only be called inside of a clearCallingIdentity block.\n     */\n    private AuthenticatorDescription[] getAuthenticatorTypesInternal(int userId) {\n        mAuthenticatorCache.updateServices(userId);\n        Collection<AccountAuthenticatorCache.ServiceInfo<AuthenticatorDescription>>\n                authenticatorCollection = mAuthenticatorCache.getAllServices(userId);\n        AuthenticatorDescription[] types =\n                new AuthenticatorDescription[authenticatorCollection.size()];\n        int i = 0;\n        for (AccountAuthenticatorCache.ServiceInfo<AuthenticatorDescription> authenticator\n                : authenticatorCollection) {\n            types[i] = authenticator.type;\n            i++;\n        }\n        return types;\n    }\n\n    private boolean isCrossUser(int callingUid, int userId) {\n        return (userId != UserHandle.getCallingUserId()\n                && callingUid != Process.SYSTEM_UID\n                && mContext.checkCallingOrSelfPermission(\n                        android.Manifest.permission.INTERACT_ACROSS_USERS_FULL)\n                                != PackageManager.PERMISSION_GRANTED);\n    }\n\n    @Override\n    public boolean addAccountExplicitly(\n            Account account, String password, Bundle extras, String opPackageName) {\n        return addAccountExplicitlyWithVisibility(\n                account, password, extras, /* packageToVisibility= */ null, opPackageName);\n    }\n\n    @Override\n    public void copyAccountToUser(final IAccountManagerResponse response, final Account account,\n            final int userFrom, int userTo) {\n        int callingUid = Binder.getCallingUid();\n        if (isCrossUser(callingUid, UserHandle.USER_ALL)) {\n            throw new SecurityException(\"Calling copyAccountToUser requires \"\n                    + android.Manifest.permission.INTERACT_ACROSS_USERS_FULL);\n        }\n        final UserAccounts fromAccounts = getUserAccounts(userFrom);\n        final UserAccounts toAccounts = getUserAccounts(userTo);\n        if (fromAccounts == null || toAccounts == null) {\n            if (response != null) {\n                Bundle result = new Bundle();\n                result.putBoolean(AccountManager.KEY_BOOLEAN_RESULT, false);\n                try {\n                    response.onResult(result);\n                } catch (RemoteException e) {\n                    Slog.w(TAG, \"Failed to report error back to the client.\" + e);\n                }\n            }\n            return;\n        }\n\n        Slog.d(TAG, \"Copying account \" + account.toSafeString()\n                + \" from user \" + userFrom + \" to user \" + userTo);\n        final long identityToken = clearCallingIdentity();\n        try {\n            new Session(fromAccounts, response, account.type, false,\n                    false /* stripAuthTokenFromResult */, account.name,\n                    false /* authDetailsRequired */) {\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now) + \", getAccountCredentialsForClone\"\n                            + \", \" + account.type;\n                }\n\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.getAccountCredentialsForCloning(this, account);\n                }\n\n                @Override\n                public void onResult(Bundle result) {\n                    Bundle.setDefusable(result, true);\n                    if (result != null\n                            && result.getBoolean(AccountManager.KEY_BOOLEAN_RESULT, false)) {\n                        // Create a Session for the target user and pass in the bundle\n                        completeCloningAccount(response, result, account, toAccounts, userFrom);\n                    } else {\n                        super.onResult(result);\n                    }\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public boolean accountAuthenticated(final Account account) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            String msg = String.format(\n                    \"accountAuthenticated( account: %s, callerUid: %s)\",\n                    account,\n                    callingUid);\n            Log.v(TAG, msg);\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot notify authentication for accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n\n        if (!canUserModifyAccounts(userId, callingUid) ||\n                !canUserModifyAccountsForType(userId, account.type, callingUid)) {\n            return false;\n        }\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return updateLastAuthenticatedTime(account);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private boolean updateLastAuthenticatedTime(Account account) {\n        final UserAccounts accounts = getUserAccountsForCaller();\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                return accounts.accountsDb.updateAccountLastAuthenticatedTime(account);\n            }\n        }\n    }\n\n    private void completeCloningAccount(IAccountManagerResponse response,\n            final Bundle accountCredentials, final Account account, final UserAccounts targetUser,\n            final int parentUserId){\n        Bundle.setDefusable(accountCredentials, true);\n        final long id = clearCallingIdentity();\n        try {\n            new Session(targetUser, response, account.type, false,\n                    false /* stripAuthTokenFromResult */, account.name,\n                    false /* authDetailsRequired */) {\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now) + \", getAccountCredentialsForClone\"\n                            + \", \" + account.type;\n                }\n\n                @Override\n                public void run() throws RemoteException {\n                    // Confirm that the owner's account still exists before this step.\n                    for (Account acc : getAccounts(parentUserId, mContext.getOpPackageName())) {\n                        if (acc.equals(account)) {\n                            mAuthenticator.addAccountFromCredentials(\n                                    this, account, accountCredentials);\n                            break;\n                        }\n                    }\n                }\n\n                @Override\n                public void onResult(Bundle result) {\n                    Bundle.setDefusable(result, true);\n                    // TODO: Anything to do if if succedded?\n                    // TODO: If it failed: Show error notification? Should we remove the shadow\n                    // account to avoid retries?\n                    // TODO: what we do with the visibility?\n\n                    super.onResult(result);\n                }\n\n                @Override\n                public void onError(int errorCode, String errorMessage) {\n                    super.onError(errorCode,  errorMessage);\n                    // TODO: Show error notification to user\n                    // TODO: Should we remove the shadow account so that it doesn't keep trying?\n                }\n\n            }.bind();\n        } finally {\n            restoreCallingIdentity(id);\n        }\n    }\n\n    private boolean addAccountInternal(UserAccounts accounts, Account account, String password,\n            Bundle extras, int callingUid, Map<String, Integer> packageToVisibility,\n            String opPackageName) {\n        Bundle.setDefusable(extras, true);\n        if (account == null) {\n            return false;\n        }\n        if (account.name != null && account.name.length() > 200) {\n            Log.w(TAG, \"Account cannot be added - Name longer than 200 chars\");\n            return false;\n        }\n        if (account.type != null && account.type.length() > 200) {\n            Log.w(TAG, \"Account cannot be added - Name longer than 200 chars\");\n            return false;\n        }\n        if (!isLocalUnlockedUser(accounts.userId)) {\n            Log.w(TAG, \"Account \" + account.toSafeString() + \" cannot be added - user \"\n                    + accounts.userId + \" is locked. callingUid=\" + callingUid);\n            return false;\n        }\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                accounts.accountsDb.beginTransaction();\n                try {\n                    if (accounts.accountsDb.findCeAccountId(account) >= 0) {\n                        Log.w(TAG, \"insertAccountIntoDatabase: \" + account.toSafeString()\n                                + \", skipping since the account already exists\");\n                        return false;\n                    }\n                    if (accounts.accountsDb.findAllDeAccounts().size() > 100) {\n                        Log.w(TAG, \"insertAccountIntoDatabase: \" + account.toSafeString()\n                                + \", skipping since more than 50 accounts on device exist\");\n                        return false;\n                    }\n                    long accountId = accounts.accountsDb.insertCeAccount(account, password);\n                    if (accountId < 0) {\n                        Log.w(TAG, \"insertAccountIntoDatabase: \" + account.toSafeString()\n                                + \", skipping the DB insert failed\");\n                        return false;\n                    }\n                    // Insert into DE table\n                    if (accounts.accountsDb.insertDeAccount(account, accountId) < 0) {\n                        Log.w(TAG, \"insertAccountIntoDatabase: \" + account.toSafeString()\n                                + \", skipping the DB insert failed\");\n                        return false;\n                    }\n                    if (extras != null) {\n                        for (String key : extras.keySet()) {\n                            final String value = extras.getString(key);\n                            if (accounts.accountsDb.insertExtra(accountId, key, value) < 0) {\n                                Log.w(TAG, \"insertAccountIntoDatabase: \"\n                                        + account.toSafeString()\n                                        + \", skipping since insertExtra failed for key \" + key);\n                                return false;\n                            } else {\n                                AccountManager.invalidateLocalAccountUserDataCaches();\n                            }\n                        }\n                    }\n\n                    if (packageToVisibility != null) {\n                        for (Entry<String, Integer> entry : packageToVisibility.entrySet()) {\n                            setAccountVisibility(account, entry.getKey() /* package */,\n                                    entry.getValue() /* visibility */, false /* notify */,\n                                    accounts);\n                        }\n                    }\n                    accounts.accountsDb.setTransactionSuccessful();\n\n                    logRecord(AccountsDb.DEBUG_ACTION_ACCOUNT_ADD, AccountsDb.TABLE_ACCOUNTS,\n                            accountId,\n                            accounts, callingUid);\n\n                    insertAccountIntoCacheLocked(accounts, account);\n                } finally {\n                    accounts.accountsDb.endTransaction();\n                }\n            }\n        }\n        if (getUserManager().getUserInfo(accounts.userId).canHaveProfile()) {\n            addAccountToLinkedRestrictedUsers(account, accounts.userId);\n        }\n\n        sendNotificationAccountUpdated(account, accounts);\n        // Only send LOGIN_ACCOUNTS_CHANGED when the database changed.\n        sendAccountsChangedBroadcast(accounts.userId);\n\n        logAddAccountExplicitlyMetrics(opPackageName, account.type, packageToVisibility);\n        return true;\n    }\n\n    private void logAddAccountExplicitlyMetrics(\n            String callerPackage, String accountType,\n            @Nullable Map<String, Integer> accountVisibility) {\n        // Although this is not a 'device policy' API, enterprise is the current use case.\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.ADD_ACCOUNT_EXPLICITLY)\n                .setStrings(\n                        TextUtils.emptyIfNull(accountType),\n                        TextUtils.emptyIfNull(callerPackage),\n                        findPackagesPerVisibility(accountVisibility))\n                .write();\n    }\n\n    private String[] findPackagesPerVisibility(@Nullable Map<String, Integer> accountVisibility) {\n        Map<Integer, Set<String>> packagesPerVisibility = new HashMap<>();\n        if (accountVisibility != null) {\n            for (Entry<String, Integer> entry : accountVisibility.entrySet()) {\n                if (!packagesPerVisibility.containsKey(entry.getValue())) {\n                    packagesPerVisibility.put(entry.getValue(), new HashSet<>());\n                }\n                packagesPerVisibility.get(entry.getValue()).add(entry.getKey());\n            }\n        }\n\n        String[] packagesPerVisibilityStr = new String[5];\n        packagesPerVisibilityStr[AccountManager.VISIBILITY_UNDEFINED] = getPackagesForVisibilityStr(\n                AccountManager.VISIBILITY_UNDEFINED, packagesPerVisibility);\n        packagesPerVisibilityStr[AccountManager.VISIBILITY_VISIBLE] = getPackagesForVisibilityStr(\n                AccountManager.VISIBILITY_VISIBLE, packagesPerVisibility);\n        packagesPerVisibilityStr[AccountManager.VISIBILITY_USER_MANAGED_VISIBLE] =\n                getPackagesForVisibilityStr(\n                        AccountManager.VISIBILITY_USER_MANAGED_VISIBLE, packagesPerVisibility);\n        packagesPerVisibilityStr[AccountManager.VISIBILITY_NOT_VISIBLE] =\n                getPackagesForVisibilityStr(\n                        AccountManager.VISIBILITY_NOT_VISIBLE, packagesPerVisibility);\n        packagesPerVisibilityStr[AccountManager.VISIBILITY_USER_MANAGED_NOT_VISIBLE] =\n                getPackagesForVisibilityStr(\n                        AccountManager.VISIBILITY_USER_MANAGED_NOT_VISIBLE, packagesPerVisibility);\n        return packagesPerVisibilityStr;\n    }\n\n    private String getPackagesForVisibilityStr(\n            int visibility, Map<Integer, Set<String>> packagesPerVisibility) {\n        return visibility + \":\"\n                + (packagesPerVisibility.containsKey(visibility)\n                    ? TextUtils.join(\",\", packagesPerVisibility.get(visibility))\n                    : \"\");\n    }\n\n    private boolean isLocalUnlockedUser(int userId) {\n        synchronized (mUsers) {\n            return mLocalUnlockedUsers.get(userId);\n        }\n    }\n\n    /**\n     * Adds the account to all linked restricted users as shared accounts. If the user is currently\n     * running, then clone the account too.\n     * @param account the account to share with limited users\n     *\n     */\n    private void addAccountToLinkedRestrictedUsers(Account account, int parentUserId) {\n        List<UserInfo> users = getUserManager().getUsers();\n        for (UserInfo user : users) {\n            if (user.isRestricted() && (parentUserId == user.restrictedProfileParentId)) {\n                addSharedAccountAsUser(account, user.id);\n                if (isLocalUnlockedUser(user.id)) {\n                    mHandler.sendMessage(mHandler.obtainMessage(\n                            MESSAGE_COPY_SHARED_ACCOUNT, parentUserId, user.id, account));\n                }\n            }\n        }\n    }\n\n    @Override\n    public void hasFeatures(IAccountManagerResponse response,\n            Account account, String[] features, String opPackageName) {\n        int callingUid = Binder.getCallingUid();\n        mAppOpsManager.checkPackage(callingUid, opPackageName);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"hasFeatures: \" + account\n                    + \", response \" + response\n                    + \", features \" + Arrays.toString(features)\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Preconditions.checkArgument(account != null, \"account cannot be null\");\n        Preconditions.checkArgument(response != null, \"response cannot be null\");\n        Preconditions.checkArgument(features != null, \"features cannot be null\");\n        int userId = UserHandle.getCallingUserId();\n        checkReadAccountsPermitted(callingUid, account.type, userId,\n                opPackageName);\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            new TestFeaturesSession(accounts, response, account, features).bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private class TestFeaturesSession extends Session {\n        private final String[] mFeatures;\n        private final Account mAccount;\n\n        public TestFeaturesSession(UserAccounts accounts, IAccountManagerResponse response,\n                Account account, String[] features) {\n            super(accounts, response, account.type, false /* expectActivityLaunch */,\n                    true /* stripAuthTokenFromResult */, account.name,\n                    false /* authDetailsRequired */);\n            mFeatures = features;\n            mAccount = account;\n        }\n\n        @Override\n        public void run() throws RemoteException {\n            try {\n                mAuthenticator.hasFeatures(this, mAccount, mFeatures);\n            } catch (RemoteException e) {\n                onError(AccountManager.ERROR_CODE_REMOTE_EXCEPTION, \"remote exception\");\n            }\n        }\n\n        @Override\n        public void onResult(Bundle result) {\n            Bundle.setDefusable(result, true);\n            IAccountManagerResponse response = getResponseAndClose();\n            if (response != null) {\n                try {\n                    if (result == null) {\n                        response.onError(AccountManager.ERROR_CODE_INVALID_RESPONSE, \"null bundle\");\n                        return;\n                    }\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, getClass().getSimpleName() + \" calling onResult() on response \"\n                                + response);\n                    }\n                    final Bundle newResult = new Bundle();\n                    newResult.putBoolean(AccountManager.KEY_BOOLEAN_RESULT,\n                            result.getBoolean(AccountManager.KEY_BOOLEAN_RESULT, false));\n                    response.onResult(newResult);\n                } catch (RemoteException e) {\n                    // if the caller is dead then there is no one to care about remote exceptions\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, \"failure while notifying response\", e);\n                    }\n                }\n            }\n        }\n\n        @Override\n        protected String toDebugString(long now) {\n            return super.toDebugString(now) + \", hasFeatures\"\n                    + \", \" + mAccount\n                    + \", \" + (mFeatures != null ? TextUtils.join(\",\", mFeatures) : null);\n        }\n    }\n\n    @Override\n    public void renameAccount(\n            IAccountManagerResponse response, Account accountToRename, String newName) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"renameAccount: \" + accountToRename + \" -> \" + newName\n                + \", caller's uid \" + callingUid\n                + \", pid \" + Binder.getCallingPid());\n        }\n        if (accountToRename == null) throw new IllegalArgumentException(\"account is null\");\n        if (newName != null && newName.length() > 200) {\n            Log.e(TAG, \"renameAccount failed - account name longer than 200\");\n            throw new IllegalArgumentException(\"account name longer than 200\");\n        }\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(accountToRename.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot rename accounts of type: %s\",\n                    callingUid,\n                    accountToRename.type);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            Account resultingAccount = renameAccountInternal(accounts, accountToRename, newName);\n            Bundle result = new Bundle();\n            result.putString(AccountManager.KEY_ACCOUNT_NAME, resultingAccount.name);\n            result.putString(AccountManager.KEY_ACCOUNT_TYPE, resultingAccount.type);\n            result.putString(AccountManager.KEY_ACCOUNT_ACCESS_ID,\n                    resultingAccount.getAccessId());\n            try {\n                response.onResult(result);\n            } catch (RemoteException e) {\n                Log.w(TAG, e.getMessage());\n            }\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private Account renameAccountInternal(\n            UserAccounts accounts, Account accountToRename, String newName) {\n        Account resultAccount = null;\n        /*\n         * Cancel existing notifications. Let authenticators\n         * re-post notifications as required. But we don't know if\n         * the authenticators have bound their notifications to\n         * now stale account name data.\n         *\n         * With a rename api, we might not need to do this anymore but it\n         * shouldn't hurt.\n         */\n        cancelNotification(\n                getSigninRequiredNotificationId(accounts, accountToRename),\n                new UserHandle(accounts.userId));\n        synchronized(accounts.credentialsPermissionNotificationIds) {\n            for (Pair<Pair<Account, String>, Integer> pair:\n                    accounts.credentialsPermissionNotificationIds.keySet()) {\n                if (accountToRename.equals(pair.first.first)) {\n                    NotificationId id = accounts.credentialsPermissionNotificationIds.get(pair);\n                    cancelNotification(id, new UserHandle(accounts.userId));\n                }\n            }\n        }\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                List<String> accountRemovedReceivers =\n                    getAccountRemovedReceivers(accountToRename, accounts);\n                accounts.accountsDb.beginTransaction();\n                Account renamedAccount = new Account(newName, accountToRename.type);\n                try {\n                    if ((accounts.accountsDb.findCeAccountId(renamedAccount) >= 0)) {\n                        Log.e(TAG, \"renameAccount failed - account with new name already exists\");\n                        return null;\n                    }\n                    final long accountId = accounts.accountsDb.findDeAccountId(accountToRename);\n                    if (accountId >= 0) {\n                        accounts.accountsDb.renameCeAccount(accountId, newName);\n                        if (accounts.accountsDb.renameDeAccount(\n                                accountId, newName, accountToRename.name)) {\n                            accounts.accountsDb.setTransactionSuccessful();\n                        } else {\n                            Log.e(TAG, \"renameAccount failed\");\n                            return null;\n                        }\n                    } else {\n                        Log.e(TAG, \"renameAccount failed - old account does not exist\");\n                        return null;\n                    }\n                } finally {\n                    accounts.accountsDb.endTransaction();\n                }\n            /*\n             * Database transaction was successful. Clean up cached\n             * data associated with the account in the user profile.\n             */\n                renamedAccount = insertAccountIntoCacheLocked(accounts, renamedAccount);\n            /*\n             * Extract the data and token caches before removing the\n             * old account to preserve the user data associated with\n             * the account.\n             */\n                Map<String, String> tmpData = accounts.userDataCache.get(accountToRename);\n                Map<String, String> tmpTokens = accounts.authTokenCache.get(accountToRename);\n                Map<String, Integer> tmpVisibility = accounts.visibilityCache.get(accountToRename);\n                removeAccountFromCacheLocked(accounts, accountToRename);\n            /*\n             * Update the cached data associated with the renamed\n             * account.\n             */\n                accounts.userDataCache.put(renamedAccount, tmpData);\n                accounts.authTokenCache.put(renamedAccount, tmpTokens);\n                accounts.visibilityCache.put(renamedAccount, tmpVisibility);\n                accounts.previousNameCache.put(\n                        renamedAccount,\n                        new AtomicReference<>(accountToRename.name));\n                resultAccount = renamedAccount;\n\n                int parentUserId = accounts.userId;\n                if (canHaveProfile(parentUserId)) {\n                /*\n                 * Owner or system user account was renamed, rename the account for\n                 * those users with which the account was shared.\n                 */\n                    List<UserInfo> users = getUserManager().getAliveUsers();\n                    for (UserInfo user : users) {\n                        if (user.isRestricted()\n                                && (user.restrictedProfileParentId == parentUserId)) {\n                            renameSharedAccountAsUser(accountToRename, newName, user.id);\n                        }\n                    }\n                }\n\n                sendNotificationAccountUpdated(resultAccount, accounts);\n                sendAccountsChangedBroadcast(accounts.userId);\n                for (String packageName : accountRemovedReceivers) {\n                    sendAccountRemovedBroadcast(accountToRename, packageName, accounts.userId);\n                }\n\n                AccountManager.invalidateLocalAccountsDataCaches();\n                AccountManager.invalidateLocalAccountUserDataCaches();\n            }\n        }\n        return resultAccount;\n    }\n\n    private boolean canHaveProfile(final int parentUserId) {\n        final UserInfo userInfo = getUserManager().getUserInfo(parentUserId);\n        return userInfo != null && userInfo.canHaveProfile();\n    }\n\n    @Override\n    public void removeAccountAsUser(IAccountManagerResponse response, Account account,\n            boolean expectActivityLaunch, int userId) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"removeAccount: \" + account\n                    + \", response \" + response\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid()\n                    + \", for user id \" + userId);\n        }\n        Preconditions.checkArgument(account != null, \"account cannot be null\");\n        Preconditions.checkArgument(response != null, \"response cannot be null\");\n\n        // Only allow the system process to modify accounts of other users\n        if (isCrossUser(callingUid, userId)) {\n            throw new SecurityException(\n                    String.format(\n                            \"User %s tying remove account for %s\" ,\n                            UserHandle.getCallingUserId(),\n                            userId));\n        }\n        /*\n         * Only the system, authenticator or profile owner should be allowed to remove accounts for\n         * that authenticator.  This will let users remove accounts (via Settings in the system) but\n         * not arbitrary applications (like competing authenticators).\n         */\n        UserHandle user = UserHandle.of(userId);\n        if (!isAccountManagedByCaller(account.type, callingUid, user.getIdentifier())\n                && !isSystemUid(callingUid)\n                && !isProfileOwner(callingUid)) {\n            String msg = String.format(\n                    \"uid %s cannot remove accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        if (!canUserModifyAccounts(userId, callingUid)) {\n            try {\n                response.onError(AccountManager.ERROR_CODE_USER_RESTRICTED,\n                        \"User cannot modify accounts\");\n            } catch (RemoteException re) {\n            }\n            return;\n        }\n        if (!canUserModifyAccountsForType(userId, account.type, callingUid)) {\n            try {\n                response.onError(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                        \"User cannot modify accounts of this type (policy).\");\n            } catch (RemoteException re) {\n            }\n            return;\n        }\n        final long identityToken = clearCallingIdentity();\n        UserAccounts accounts = getUserAccounts(userId);\n        cancelNotification(getSigninRequiredNotificationId(accounts, account), user);\n        synchronized(accounts.credentialsPermissionNotificationIds) {\n            for (Pair<Pair<Account, String>, Integer> pair:\n                accounts.credentialsPermissionNotificationIds.keySet()) {\n                if (account.equals(pair.first.first)) {\n                    NotificationId id = accounts.credentialsPermissionNotificationIds.get(pair);\n                    cancelNotification(id, user);\n                }\n            }\n        }\n        final long accountId = accounts.accountsDb.findDeAccountId(account);\n        logRecord(\n                AccountsDb.DEBUG_ACTION_CALLED_ACCOUNT_REMOVE,\n                AccountsDb.TABLE_ACCOUNTS,\n                accountId,\n                accounts,\n                callingUid);\n        try {\n            new RemoveAccountSession(accounts, response, account, expectActivityLaunch).bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public boolean removeAccountExplicitly(Account account) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"removeAccountExplicitly: \" + account\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        int userId = Binder.getCallingUserHandle().getIdentifier();\n        if (account == null) {\n            /*\n             * Null accounts should result in returning false, as per\n             * AccountManage.addAccountExplicitly(...) java doc.\n             */\n            Log.e(TAG, \"account is null\");\n            return false;\n        } else if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot explicitly remove accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        UserAccounts accounts = getUserAccountsForCaller();\n        final long accountId = accounts.accountsDb.findDeAccountId(account);\n        logRecord(\n                AccountsDb.DEBUG_ACTION_CALLED_ACCOUNT_REMOVE,\n                AccountsDb.TABLE_ACCOUNTS,\n                accountId,\n                accounts,\n                callingUid);\n        final long identityToken = clearCallingIdentity();\n        try {\n            return removeAccountInternal(accounts, account, callingUid);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private class RemoveAccountSession extends Session {\n        final Account mAccount;\n        public RemoveAccountSession(UserAccounts accounts, IAccountManagerResponse response,\n                Account account, boolean expectActivityLaunch) {\n            super(accounts, response, account.type, expectActivityLaunch,\n                    true /* stripAuthTokenFromResult */, account.name,\n                    false /* authDetailsRequired */);\n            mAccount = account;\n        }\n\n        @Override\n        protected String toDebugString(long now) {\n            return super.toDebugString(now) + \", removeAccount\"\n                    + \", account \" + mAccount;\n        }\n\n        @Override\n        public void run() throws RemoteException {\n            mAuthenticator.getAccountRemovalAllowed(this, mAccount);\n        }\n\n        @Override\n        public void onResult(Bundle result) {\n            Bundle.setDefusable(result, true);\n            if (result != null && result.containsKey(AccountManager.KEY_BOOLEAN_RESULT)\n                    && !result.containsKey(AccountManager.KEY_INTENT)) {\n                final boolean removalAllowed = result.getBoolean(AccountManager.KEY_BOOLEAN_RESULT);\n                if (removalAllowed) {\n                    removeAccountInternal(mAccounts, mAccount, getCallingUid());\n                }\n                IAccountManagerResponse response = getResponseAndClose();\n                if (response != null) {\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, getClass().getSimpleName() + \" calling onResult() on response \"\n                                + response);\n                    }\n                    try {\n                        response.onResult(result);\n                    } catch (RemoteException e) {\n                        Slog.e(TAG, \"Error calling onResult()\", e);\n                    }\n                }\n            }\n            super.onResult(result);\n        }\n    }\n\n    @VisibleForTesting\n    protected void removeAccountInternal(Account account) {\n        removeAccountInternal(getUserAccountsForCaller(), account, getCallingUid());\n    }\n\n    private boolean removeAccountInternal(UserAccounts accounts, Account account, int callingUid) {\n        boolean isChanged = false;\n        boolean userUnlocked = isLocalUnlockedUser(accounts.userId);\n        if (!userUnlocked) {\n            Slog.i(TAG, \"Removing account \" + account.toSafeString()\n                    + \" while user \" + accounts.userId\n                    + \" is still locked. CE data will be removed later\");\n        }\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                Map<String, Integer> packagesToVisibility = getRequestingPackages(account,\n                        accounts);\n                List<String> accountRemovedReceivers =\n                    getAccountRemovedReceivers(account, accounts);\n                accounts.accountsDb.beginTransaction();\n                // Set to a placeholder value, this will only be used if the database\n                // transaction succeeds.\n                long accountId = -1;\n                try {\n                    accountId = accounts.accountsDb.findDeAccountId(account);\n                    if (accountId >= 0) {\n                        isChanged = accounts.accountsDb.deleteDeAccount(accountId);\n                    }\n                    // always delete from CE table if CE storage is available\n                    // DE account could be removed while CE was locked\n                    if (userUnlocked) {\n                        long ceAccountId = accounts.accountsDb.findCeAccountId(account);\n                        if (ceAccountId >= 0) {\n                            accounts.accountsDb.deleteCeAccount(ceAccountId);\n                        }\n                    }\n                    accounts.accountsDb.setTransactionSuccessful();\n                } finally {\n                    accounts.accountsDb.endTransaction();\n                }\n                if (isChanged) {\n                    removeAccountFromCacheLocked(accounts, account);\n                    for (Entry<String, Integer> packageToVisibility : packagesToVisibility\n                            .entrySet()) {\n                        if ((packageToVisibility.getValue() == AccountManager.VISIBILITY_VISIBLE)\n                                || (packageToVisibility.getValue()\n                                    == AccountManager.VISIBILITY_USER_MANAGED_VISIBLE)) {\n                            notifyPackage(packageToVisibility.getKey(), accounts);\n                        }\n                    }\n\n                    // Only broadcast LOGIN_ACCOUNTS_CHANGED if a change occurred.\n                    sendAccountsChangedBroadcast(accounts.userId);\n                    for (String packageName : accountRemovedReceivers) {\n                        sendAccountRemovedBroadcast(account, packageName, accounts.userId);\n                    }\n                    String action = userUnlocked ? AccountsDb.DEBUG_ACTION_ACCOUNT_REMOVE\n                            : AccountsDb.DEBUG_ACTION_ACCOUNT_REMOVE_DE;\n                    logRecord(action, AccountsDb.TABLE_ACCOUNTS, accountId, accounts);\n                }\n            }\n        }\n        final long id = Binder.clearCallingIdentity();\n        try {\n            int parentUserId = accounts.userId;\n            if (canHaveProfile(parentUserId)) {\n                // Remove from any restricted profiles that are sharing this account.\n                List<UserInfo> users = getUserManager().getAliveUsers();\n                for (UserInfo user : users) {\n                    if (user.isRestricted() && parentUserId == (user.restrictedProfileParentId)) {\n                        removeSharedAccountAsUser(account, user.id, callingUid);\n                    }\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(id);\n        }\n\n        if (isChanged) {\n            synchronized (accounts.credentialsPermissionNotificationIds) {\n                for (Pair<Pair<Account, String>, Integer> key\n                        : accounts.credentialsPermissionNotificationIds.keySet()) {\n                    if (account.equals(key.first.first)\n                            && AccountManager.ACCOUNT_ACCESS_TOKEN_TYPE.equals(key.first.second)) {\n                        final int uid = (Integer) key.second;\n                        mHandler.post(() -> cancelAccountAccessRequestNotificationIfNeeded(\n                                account, uid, false));\n                    }\n                }\n            }\n        }\n\n        AccountManager.invalidateLocalAccountUserDataCaches();\n\n        return isChanged;\n    }\n\n    @Override\n    public void invalidateAuthToken(String accountType, String authToken) {\n        int callerUid = Binder.getCallingUid();\n        Objects.requireNonNull(accountType, \"accountType cannot be null\");\n        Objects.requireNonNull(authToken, \"authToken cannot be null\");\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"invalidateAuthToken: accountType \" + accountType\n                    + \", caller's uid \" + callerUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        int userId = UserHandle.getCallingUserId();\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            List<Pair<Account, String>> deletedTokens;\n            synchronized (accounts.dbLock) {\n                accounts.accountsDb.beginTransaction();\n                try {\n                    deletedTokens = invalidateAuthTokenLocked(accounts, accountType, authToken);\n                    accounts.accountsDb.setTransactionSuccessful();\n                } finally {\n                    accounts.accountsDb.endTransaction();\n                }\n                synchronized (accounts.cacheLock) {\n                    for (Pair<Account, String> tokenInfo : deletedTokens) {\n                        Account act = tokenInfo.first;\n                        String tokenType = tokenInfo.second;\n                        writeAuthTokenIntoCacheLocked(accounts, act, tokenType, null);\n                    }\n                    // wipe out cached token in memory.\n                    accounts.accountTokenCaches.remove(accountType, authToken);\n                }\n            }\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private List<Pair<Account, String>> invalidateAuthTokenLocked(UserAccounts accounts, String accountType,\n            String authToken) {\n        // TODO Move to AccountsDB\n        List<Pair<Account, String>> results = new ArrayList<>();\n        Cursor cursor = accounts.accountsDb.findAuthtokenForAllAccounts(accountType, authToken);\n\n        try {\n            while (cursor.moveToNext()) {\n                String authTokenId = cursor.getString(0);\n                String accountName = cursor.getString(1);\n                String authTokenType = cursor.getString(2);\n                accounts.accountsDb.deleteAuthToken(authTokenId);\n                results.add(Pair.create(new Account(accountName, accountType), authTokenType));\n            }\n        } finally {\n            cursor.close();\n        }\n        return results;\n    }\n\n    private void saveCachedToken(\n            UserAccounts accounts,\n            Account account,\n            String callerPkg,\n            byte[] callerSigDigest,\n            String tokenType,\n            String token,\n            long expiryMillis) {\n\n        if (account == null || tokenType == null || callerPkg == null || callerSigDigest == null) {\n            return;\n        }\n        cancelNotification(getSigninRequiredNotificationId(accounts, account),\n                UserHandle.of(accounts.userId));\n        synchronized (accounts.cacheLock) {\n            accounts.accountTokenCaches.put(\n                    account, token, tokenType, callerPkg, callerSigDigest, expiryMillis);\n        }\n    }\n\n    private boolean saveAuthTokenToDatabase(UserAccounts accounts, Account account, String type,\n            String authToken) {\n        if (account == null || type == null) {\n            return false;\n        }\n        cancelNotification(getSigninRequiredNotificationId(accounts, account),\n                UserHandle.of(accounts.userId));\n        synchronized (accounts.dbLock) {\n            accounts.accountsDb.beginTransaction();\n            boolean updateCache = false;\n            try {\n                long accountId = accounts.accountsDb.findDeAccountId(account);\n                if (accountId < 0) {\n                    return false;\n                }\n                accounts.accountsDb.deleteAuthtokensByAccountIdAndType(accountId, type);\n                if (accounts.accountsDb.insertAuthToken(accountId, type, authToken) >= 0) {\n                    accounts.accountsDb.setTransactionSuccessful();\n                    updateCache = true;\n                    return true;\n                }\n                return false;\n            } finally {\n                accounts.accountsDb.endTransaction();\n                if (updateCache) {\n                    synchronized (accounts.cacheLock) {\n                        writeAuthTokenIntoCacheLocked(accounts, account, type, authToken);\n                    }\n                }\n            }\n        }\n    }\n\n    @Override\n    public String peekAuthToken(Account account, String authTokenType) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"peekAuthToken: \" + account\n                    + \", authTokenType \" + authTokenType\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        Objects.requireNonNull(authTokenType, \"authTokenType cannot be null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot peek the authtokens associated with accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        if (!isLocalUnlockedUser(userId)) {\n            Log.w(TAG, \"Authtoken not available - user \" + userId + \" data is locked. callingUid \"\n                    + callingUid);\n            return null;\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return readAuthTokenInternal(accounts, account, authTokenType);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void setAuthToken(Account account, String authTokenType, String authToken) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"setAuthToken: \" + account\n                    + \", authTokenType \" + authTokenType\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        Objects.requireNonNull(authTokenType, \"authTokenType cannot be null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot set auth tokens associated with accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            saveAuthTokenToDatabase(accounts, account, authTokenType, authToken);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void setPassword(Account account, String password) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"setAuthToken: \" + account\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot set secrets for accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            setPasswordInternal(accounts, account, password, callingUid);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private void setPasswordInternal(UserAccounts accounts, Account account, String password,\n            int callingUid) {\n        if (account == null) {\n            return;\n        }\n        boolean isChanged = false;\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                accounts.accountsDb.beginTransaction();\n                try {\n                    final long accountId = accounts.accountsDb.findDeAccountId(account);\n                    if (accountId >= 0) {\n                        accounts.accountsDb.updateCeAccountPassword(accountId, password);\n                        accounts.accountsDb.deleteAuthTokensByAccountId(accountId);\n                        accounts.authTokenCache.remove(account);\n                        accounts.accountTokenCaches.remove(account);\n                        accounts.accountsDb.setTransactionSuccessful();\n                        // If there is an account whose password will be updated and the database\n                        // transactions succeed, then we say that a change has occured. Even if the\n                        // new password is the same as the old and there were no authtokens to\n                        // delete.\n                        isChanged = true;\n                        String action = (password == null || password.length() == 0) ?\n                                AccountsDb.DEBUG_ACTION_CLEAR_PASSWORD\n                                : AccountsDb.DEBUG_ACTION_SET_PASSWORD;\n                        logRecord(action, AccountsDb.TABLE_ACCOUNTS, accountId, accounts,\n                                callingUid);\n                    }\n                } finally {\n                    accounts.accountsDb.endTransaction();\n                    if (isChanged) {\n                        // Send LOGIN_ACCOUNTS_CHANGED only if the something changed.\n                        sendNotificationAccountUpdated(account, accounts);\n                        sendAccountsChangedBroadcast(accounts.userId);\n                    }\n                }\n            }\n        }\n    }\n\n    @Override\n    public void clearPassword(Account account) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"clearPassword: \" + account\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot clear passwords for accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            setPasswordInternal(accounts, account, null, callingUid);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void setUserData(Account account, String key, String value) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"setUserData: \" + account\n                    + \", key \" + key\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        if (key == null) throw new IllegalArgumentException(\"key is null\");\n        if (account == null) throw new IllegalArgumentException(\"account is null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot set user data for accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            if (!accountExistsCache(accounts, account)) {\n                return;\n            }\n            setUserdataInternal(accounts, account, key, value);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private boolean accountExistsCache(UserAccounts accounts, Account account) {\n        synchronized (accounts.cacheLock) {\n            if (accounts.accountCache.containsKey(account.type)) {\n                for (Account acc : accounts.accountCache.get(account.type)) {\n                    if (acc.name.equals(account.name)) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    private void setUserdataInternal(UserAccounts accounts, Account account, String key,\n            String value) {\n        synchronized (accounts.dbLock) {\n            accounts.accountsDb.beginTransaction();\n            try {\n                long accountId = accounts.accountsDb.findDeAccountId(account);\n                if (accountId < 0) {\n                    return;\n                }\n                long extrasId = accounts.accountsDb.findExtrasIdByAccountId(accountId, key);\n                if (extrasId < 0) {\n                    extrasId = accounts.accountsDb.insertExtra(accountId, key, value);\n                    if (extrasId < 0) {\n                        return;\n                    }\n                } else if (!accounts.accountsDb.updateExtra(extrasId, value)) {\n                    return;\n                }\n                accounts.accountsDb.setTransactionSuccessful();\n            } finally {\n                accounts.accountsDb.endTransaction();\n            }\n            synchronized (accounts.cacheLock) {\n                writeUserDataIntoCacheLocked(accounts, account, key, value);\n                AccountManager.invalidateLocalAccountUserDataCaches();\n            }\n        }\n    }\n\n    private void onResult(IAccountManagerResponse response, Bundle result) {\n        if (result == null) {\n            Log.e(TAG, \"the result is unexpectedly null\", new Exception());\n        }\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, getClass().getSimpleName() + \" calling onResult() on response \"\n                    + response);\n        }\n        try {\n            response.onResult(result);\n        } catch (RemoteException e) {\n            // if the caller is dead then there is no one to care about remote\n            // exceptions\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"failure while notifying response\", e);\n            }\n        }\n    }\n\n    @Override\n    public void getAuthTokenLabel(IAccountManagerResponse response, final String accountType,\n                                  final String authTokenType)\n            throws RemoteException {\n        Preconditions.checkArgument(accountType != null, \"accountType cannot be null\");\n        Preconditions.checkArgument(authTokenType != null, \"authTokenType cannot be null\");\n\n        final int callingUid = getCallingUid();\n        clearCallingIdentity();\n        if (UserHandle.getAppId(callingUid) != Process.SYSTEM_UID) {\n            throw new SecurityException(\"can only call from system\");\n        }\n        int userId = UserHandle.getUserId(callingUid);\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            new Session(accounts, response, accountType, false /* expectActivityLaunch */,\n                    false /* stripAuthTokenFromResult */,  null /* accountName */,\n                    false /* authDetailsRequired */) {\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now) + \", getAuthTokenLabel\"\n                            + \", \" + accountType\n                            + \", authTokenType \" + authTokenType;\n                }\n\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.getAuthTokenLabel(this, authTokenType);\n                }\n\n                @Override\n                public void onResult(Bundle result) {\n                    Bundle.setDefusable(result, true);\n                    if (result != null) {\n                        String label = result.getString(AccountManager.KEY_AUTH_TOKEN_LABEL);\n                        Bundle bundle = new Bundle();\n                        bundle.putString(AccountManager.KEY_AUTH_TOKEN_LABEL, label);\n                        super.onResult(bundle);\n                        return;\n                    } else {\n                        super.onResult(result);\n                    }\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void getAuthToken(\n            IAccountManagerResponse response,\n            final Account account,\n            final String authTokenType,\n            final boolean notifyOnAuthFailure,\n            final boolean expectActivityLaunch,\n            final Bundle loginOptions) {\n        Bundle.setDefusable(loginOptions, true);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"getAuthToken: \" + account\n                    + \", response \" + response\n                    + \", authTokenType \" + authTokenType\n                    + \", notifyOnAuthFailure \" + notifyOnAuthFailure\n                    + \", expectActivityLaunch \" + expectActivityLaunch\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Preconditions.checkArgument(response != null, \"response cannot be null\");\n        try {\n            if (account == null) {\n                Slog.w(TAG, \"getAuthToken called with null account\");\n                response.onError(AccountManager.ERROR_CODE_BAD_ARGUMENTS, \"account is null\");\n                return;\n            }\n            if (authTokenType == null) {\n                Slog.w(TAG, \"getAuthToken called with null authTokenType\");\n                response.onError(AccountManager.ERROR_CODE_BAD_ARGUMENTS, \"authTokenType is null\");\n                return;\n            }\n        } catch (RemoteException e) {\n            Slog.w(TAG, \"Failed to report error back to the client.\" + e);\n            return;\n        }\n        int userId = UserHandle.getCallingUserId();\n        final long ident = Binder.clearCallingIdentity();\n        final UserAccounts accounts;\n        final RegisteredServicesCache.ServiceInfo<AuthenticatorDescription> authenticatorInfo;\n        try {\n            accounts = getUserAccounts(userId);\n            authenticatorInfo = mAuthenticatorCache.getServiceInfo(\n                    AuthenticatorDescription.newKey(account.type), accounts.userId);\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n\n        final boolean customTokens =\n                authenticatorInfo != null && authenticatorInfo.type.customTokens;\n\n        // skip the check if customTokens\n        final int callerUid = Binder.getCallingUid();\n        final boolean permissionGranted =\n                customTokens || permissionIsGranted(account, authTokenType, callerUid, userId);\n\n        // Get the calling package. We will use it for the purpose of caching.\n        final String callerPkg = loginOptions.getString(AccountManager.KEY_ANDROID_PACKAGE_NAME);\n        String[] callerOwnedPackageNames;\n        final long ident2 = Binder.clearCallingIdentity();\n        try {\n            callerOwnedPackageNames = mPackageManager.getPackagesForUid(callerUid);\n        } finally {\n            Binder.restoreCallingIdentity(ident2);\n        }\n        if (callerPkg == null || callerOwnedPackageNames == null\n                || !ArrayUtils.contains(callerOwnedPackageNames, callerPkg)) {\n            String msg = String.format(\n                    \"Uid %s is attempting to illegally masquerade as package %s!\",\n                    callerUid,\n                    callerPkg);\n            throw new SecurityException(msg);\n        }\n\n        // let authenticator know the identity of the caller\n        loginOptions.putInt(AccountManager.KEY_CALLER_UID, callerUid);\n        loginOptions.putInt(AccountManager.KEY_CALLER_PID, Binder.getCallingPid());\n\n        if (notifyOnAuthFailure) {\n            loginOptions.putBoolean(AccountManager.KEY_NOTIFY_ON_FAILURE, true);\n        }\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            // Distill the caller's package signatures into a single digest.\n            final byte[] callerPkgSigDigest = calculatePackageSignatureDigest(callerPkg);\n\n            // if the caller has permission, do the peek. otherwise go the more expensive\n            // route of starting a Session\n            if (!customTokens && permissionGranted) {\n                String authToken = readAuthTokenInternal(accounts, account, authTokenType);\n                if (authToken != null) {\n                    logGetAuthTokenMetrics(callerPkg, account.type);\n                    Bundle result = new Bundle();\n                    result.putString(AccountManager.KEY_AUTHTOKEN, authToken);\n                    result.putString(AccountManager.KEY_ACCOUNT_NAME, account.name);\n                    result.putString(AccountManager.KEY_ACCOUNT_TYPE, account.type);\n                    onResult(response, result);\n                    return;\n                }\n            }\n\n            if (customTokens) {\n                /*\n                 * Look up tokens in the new cache only if the loginOptions don't have parameters\n                 * outside of those expected to be injected by the AccountManager, e.g.\n                 * ANDORID_PACKAGE_NAME.\n                 */\n                String token = readCachedTokenInternal(\n                        accounts,\n                        account,\n                        authTokenType,\n                        callerPkg,\n                        callerPkgSigDigest);\n                if (token != null) {\n                    logGetAuthTokenMetrics(callerPkg, account.type);\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, \"getAuthToken: cache hit ofr custom token authenticator.\");\n                    }\n                    Bundle result = new Bundle();\n                    result.putString(AccountManager.KEY_AUTHTOKEN, token);\n                    result.putString(AccountManager.KEY_ACCOUNT_NAME, account.name);\n                    result.putString(AccountManager.KEY_ACCOUNT_TYPE, account.type);\n                    onResult(response, result);\n                    return;\n                }\n            }\n\n            new Session(\n                    accounts,\n                    response,\n                    account.type,\n                    expectActivityLaunch,\n                    false /* stripAuthTokenFromResult */,\n                    account.name,\n                    false /* authDetailsRequired */) {\n                @Override\n                protected String toDebugString(long now) {\n                    if (loginOptions != null) loginOptions.keySet();\n                    return super.toDebugString(now) + \", getAuthToken\"\n                            + \", \" + account.toSafeString()\n                            + \", authTokenType \" + authTokenType\n                            + \", loginOptions \" + loginOptions\n                            + \", notifyOnAuthFailure \" + notifyOnAuthFailure;\n                }\n\n                @Override\n                public void run() throws RemoteException {\n                    // If the caller doesn't have permission then create and return the\n                    // \"grant permission\" intent instead of the \"getAuthToken\" intent.\n                    if (!permissionGranted) {\n                        mAuthenticator.getAuthTokenLabel(this, authTokenType);\n                    } else {\n                        mAuthenticator.getAuthToken(this, account, authTokenType, loginOptions);\n                        logGetAuthTokenMetrics(callerPkg, account.type);\n                    }\n                }\n\n                @Override\n                public void onResult(Bundle result) {\n                    Bundle.setDefusable(result, true);\n                    if (result != null) {\n                        if (result.containsKey(AccountManager.KEY_AUTH_TOKEN_LABEL)) {\n                            Intent intent = newGrantCredentialsPermissionIntent(\n                                    account,\n                                    null,\n                                    callerUid,\n                                    new AccountAuthenticatorResponse(this),\n                                    authTokenType,\n                                    true);\n                            Bundle bundle = new Bundle();\n                            bundle.putParcelable(AccountManager.KEY_INTENT, intent);\n                            onResult(bundle);\n                            return;\n                        }\n                        String authToken = result.getString(AccountManager.KEY_AUTHTOKEN);\n                        if (authToken != null) {\n                            String name = result.getString(AccountManager.KEY_ACCOUNT_NAME);\n                            String type = result.getString(AccountManager.KEY_ACCOUNT_TYPE);\n                            if (TextUtils.isEmpty(type) || TextUtils.isEmpty(name)) {\n                                onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                                        \"the type and name should not be empty\");\n                                return;\n                            }\n                            Account resultAccount = new Account(name, type);\n                            if (!customTokens) {\n                                saveAuthTokenToDatabase(\n                                        mAccounts,\n                                        resultAccount,\n                                        authTokenType,\n                                        authToken);\n                            }\n                            long expiryMillis = result.getLong(\n                                    AbstractAccountAuthenticator.KEY_CUSTOM_TOKEN_EXPIRY, 0L);\n                            if (customTokens\n                                    && expiryMillis > System.currentTimeMillis()) {\n                                saveCachedToken(\n                                        mAccounts,\n                                        account,\n                                        callerPkg,\n                                        callerPkgSigDigest,\n                                        authTokenType,\n                                        authToken,\n                                        expiryMillis);\n                            }\n                        }\n\n                        Intent intent = result.getParcelable(AccountManager.KEY_INTENT);\n                        if (intent != null && notifyOnAuthFailure && !customTokens) {\n                            /*\n                             * Make sure that the supplied intent is owned by the authenticator\n                             * giving it to the system. Otherwise a malicious authenticator could\n                             * have users launching arbitrary activities by tricking users to\n                             * interact with malicious notifications.\n                             */\n                            if (!checkKeyIntent(\n                                    Binder.getCallingUid(),\n                                    result)) {\n                                onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                                        \"invalid intent in bundle returned\");\n                                return;\n                            }\n                            doNotification(\n                                    mAccounts,\n                                    account,\n                                    result.getString(AccountManager.KEY_AUTH_FAILED_MESSAGE),\n                                    intent, \"android\", accounts.userId);\n                        }\n                    }\n                    super.onResult(result);\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private void logGetAuthTokenMetrics(final String callerPackage, String accountType) {\n        // Although this is not a 'device policy' API, enterprise is the current use case.\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.GET_ACCOUNT_AUTH_TOKEN)\n                .setStrings(\n                        TextUtils.emptyIfNull(callerPackage),\n                        TextUtils.emptyIfNull(accountType))\n                .write();\n    }\n\n    private byte[] calculatePackageSignatureDigest(String callerPkg) {\n        MessageDigest digester;\n        try {\n            digester = MessageDigest.getInstance(\"SHA-256\");\n            PackageInfo pkgInfo = mPackageManager.getPackageInfo(\n                    callerPkg, PackageManager.GET_SIGNATURES);\n            for (Signature sig : pkgInfo.signatures) {\n                digester.update(sig.toByteArray());\n            }\n        } catch (NoSuchAlgorithmException x) {\n            Log.wtf(TAG, \"SHA-256 should be available\", x);\n            digester = null;\n        } catch (NameNotFoundException e) {\n            Log.w(TAG, \"Could not find packageinfo for: \" + callerPkg);\n            digester = null;\n        }\n        return (digester == null) ? null : digester.digest();\n    }\n\n    private void createNoCredentialsPermissionNotification(Account account, Intent intent,\n            String packageName, int userId) {\n        int uid = intent.getIntExtra(\n                GrantCredentialsPermissionActivity.EXTRAS_REQUESTING_UID, -1);\n        String authTokenType = intent.getStringExtra(\n                GrantCredentialsPermissionActivity.EXTRAS_AUTH_TOKEN_TYPE);\n        final String titleAndSubtitle =\n                mContext.getString(R.string.permission_request_notification_for_app_with_subtitle,\n                getApplicationLabel(packageName), account.name);\n        final int index = titleAndSubtitle.indexOf('\\n');\n        String title = titleAndSubtitle;\n        String subtitle = \"\";\n        if (index > 0) {\n            title = titleAndSubtitle.substring(0, index);\n            subtitle = titleAndSubtitle.substring(index + 1);\n        }\n        UserHandle user = UserHandle.of(userId);\n        Context contextForUser = getContextForUser(user);\n        Notification n =\n                new Notification.Builder(contextForUser, SystemNotificationChannels.ACCOUNT)\n                    .setSmallIcon(android.R.drawable.stat_sys_warning)\n                    .setWhen(0)\n                    .setColor(contextForUser.getColor(\n                            com.android.internal.R.color.system_notification_accent_color))\n                    .setContentTitle(title)\n                    .setContentText(subtitle)\n                    .setContentIntent(PendingIntent.getActivityAsUser(mContext, 0, intent,\n                            PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_IMMUTABLE,\n                            null, user))\n                    .build();\n        installNotification(getCredentialPermissionNotificationId(\n                account, authTokenType, uid), n, \"android\", user.getIdentifier());\n    }\n\n    private String getApplicationLabel(String packageName) {\n        try {\n            return mPackageManager.getApplicationLabel(\n                    mPackageManager.getApplicationInfo(packageName, 0)).toString();\n        } catch (PackageManager.NameNotFoundException e) {\n            return packageName;\n        }\n    }\n\n    private Intent newGrantCredentialsPermissionIntent(Account account, String packageName,\n            int uid, AccountAuthenticatorResponse response, String authTokenType,\n            boolean startInNewTask) {\n\n        Intent intent = new Intent(mContext, GrantCredentialsPermissionActivity.class);\n\n        if (startInNewTask) {\n            // See FLAG_ACTIVITY_NEW_TASK docs for limitations and benefits of the flag.\n            // Since it was set in Eclair+ we can't change it without breaking apps using\n            // the intent from a non-Activity context. This is the default behavior.\n            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        }\n        intent.addCategory(getCredentialPermissionNotificationId(account,\n                authTokenType, uid).mTag + (packageName != null ? packageName : \"\"));\n        intent.putExtra(GrantCredentialsPermissionActivity.EXTRAS_ACCOUNT, account);\n        intent.putExtra(GrantCredentialsPermissionActivity.EXTRAS_AUTH_TOKEN_TYPE, authTokenType);\n        intent.putExtra(GrantCredentialsPermissionActivity.EXTRAS_RESPONSE, response);\n        intent.putExtra(GrantCredentialsPermissionActivity.EXTRAS_REQUESTING_UID, uid);\n\n        return intent;\n    }\n\n    private NotificationId getCredentialPermissionNotificationId(Account account,\n            String authTokenType, int uid) {\n        NotificationId nId;\n        UserAccounts accounts = getUserAccounts(UserHandle.getUserId(uid));\n        synchronized (accounts.credentialsPermissionNotificationIds) {\n            final Pair<Pair<Account, String>, Integer> key =\n                    new Pair<Pair<Account, String>, Integer>(\n                            new Pair<Account, String>(account, authTokenType), uid);\n            nId = accounts.credentialsPermissionNotificationIds.get(key);\n            if (nId == null) {\n                String tag = TAG + \":\" + SystemMessage.NOTE_ACCOUNT_CREDENTIAL_PERMISSION\n                        + \":\" + account.hashCode() + \":\" + authTokenType.hashCode() + \":\" + uid;\n                int id = SystemMessage.NOTE_ACCOUNT_CREDENTIAL_PERMISSION;\n                nId = new NotificationId(tag, id);\n                accounts.credentialsPermissionNotificationIds.put(key, nId);\n            }\n        }\n        return nId;\n    }\n\n    private NotificationId getSigninRequiredNotificationId(UserAccounts accounts, Account account) {\n        NotificationId nId;\n        synchronized (accounts.signinRequiredNotificationIds) {\n            nId = accounts.signinRequiredNotificationIds.get(account);\n            if (nId == null) {\n                String tag = TAG + \":\" + SystemMessage.NOTE_ACCOUNT_REQUIRE_SIGNIN\n                        + \":\" + account.hashCode();\n                int id = SystemMessage.NOTE_ACCOUNT_REQUIRE_SIGNIN;\n                nId = new NotificationId(tag, id);\n                accounts.signinRequiredNotificationIds.put(account, nId);\n            }\n        }\n        return nId;\n    }\n\n    @Override\n    public void addAccount(final IAccountManagerResponse response, final String accountType,\n            final String authTokenType, final String[] requiredFeatures,\n            final boolean expectActivityLaunch, final Bundle optionsIn) {\n        Bundle.setDefusable(optionsIn, true);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"addAccount: accountType \" + accountType\n                    + \", response \" + response\n                    + \", authTokenType \" + authTokenType\n                    + \", requiredFeatures \" + Arrays.toString(requiredFeatures)\n                    + \", expectActivityLaunch \" + expectActivityLaunch\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        if (response == null) throw new IllegalArgumentException(\"response is null\");\n        if (accountType == null) throw new IllegalArgumentException(\"accountType is null\");\n\n        // Is user disallowed from modifying accounts?\n        final int uid = Binder.getCallingUid();\n        final int userId = UserHandle.getUserId(uid);\n        if (!canUserModifyAccounts(userId, uid)) {\n            try {\n                response.onError(AccountManager.ERROR_CODE_USER_RESTRICTED,\n                        \"User is not allowed to add an account!\");\n            } catch (RemoteException re) {\n            }\n            showCantAddAccount(AccountManager.ERROR_CODE_USER_RESTRICTED, userId);\n            return;\n        }\n        if (!canUserModifyAccountsForType(userId, accountType, uid)) {\n            try {\n                response.onError(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                        \"User cannot modify accounts of this type (policy).\");\n            } catch (RemoteException re) {\n            }\n            showCantAddAccount(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                    userId);\n            return;\n        }\n        addAccountAndLogMetrics(response, accountType, authTokenType, requiredFeatures,\n                expectActivityLaunch, optionsIn, userId);\n    }\n\n    @Override\n    public void addAccountAsUser(final IAccountManagerResponse response, final String accountType,\n            final String authTokenType, final String[] requiredFeatures,\n            final boolean expectActivityLaunch, final Bundle optionsIn, int userId) {\n        Bundle.setDefusable(optionsIn, true);\n        int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"addAccount: accountType \" + accountType\n                    + \", response \" + response\n                    + \", authTokenType \" + authTokenType\n                    + \", requiredFeatures \" + Arrays.toString(requiredFeatures)\n                    + \", expectActivityLaunch \" + expectActivityLaunch\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid()\n                    + \", for user id \" + userId);\n        }\n        Preconditions.checkArgument(response != null, \"response cannot be null\");\n        Preconditions.checkArgument(accountType != null, \"accountType cannot be null\");\n        // Only allow the system process to add accounts of other users\n        if (isCrossUser(callingUid, userId)) {\n            throw new SecurityException(\n                    String.format(\n                            \"User %s trying to add account for %s\" ,\n                            UserHandle.getCallingUserId(),\n                            userId));\n        }\n\n        // Is user disallowed from modifying accounts?\n        if (!canUserModifyAccounts(userId, callingUid)) {\n            try {\n                response.onError(AccountManager.ERROR_CODE_USER_RESTRICTED,\n                        \"User is not allowed to add an account!\");\n            } catch (RemoteException re) {\n            }\n            showCantAddAccount(AccountManager.ERROR_CODE_USER_RESTRICTED, userId);\n            return;\n        }\n        if (!canUserModifyAccountsForType(userId, accountType, callingUid)) {\n            try {\n                response.onError(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                        \"User cannot modify accounts of this type (policy).\");\n            } catch (RemoteException re) {\n            }\n            showCantAddAccount(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                    userId);\n            return;\n        }\n        addAccountAndLogMetrics(response, accountType, authTokenType, requiredFeatures,\n                expectActivityLaunch, optionsIn, userId);\n    }\n\n    private void addAccountAndLogMetrics(\n            IAccountManagerResponse response, String accountType,\n            String authTokenType, String[] requiredFeatures,\n            boolean expectActivityLaunch, Bundle optionsIn, int userId) {\n        final int pid = Binder.getCallingPid();\n        final int uid = Binder.getCallingUid();\n        final Bundle options = (optionsIn == null) ? new Bundle() : optionsIn;\n        options.putInt(AccountManager.KEY_CALLER_UID, uid);\n        options.putInt(AccountManager.KEY_CALLER_PID, pid);\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            logRecordWithUid(\n                    accounts, AccountsDb.DEBUG_ACTION_CALLED_ACCOUNT_ADD, AccountsDb.TABLE_ACCOUNTS,\n                    uid);\n            new Session(accounts, response, accountType, expectActivityLaunch,\n                    true /* stripAuthTokenFromResult */, null /* accountName */,\n                    false /* authDetailsRequired */, true /* updateLastAuthenticationTime */) {\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.addAccount(\n                            this, mAccountType, authTokenType, requiredFeatures, options);\n                    String callerPackage = options.getString(\n                            AccountManager.KEY_ANDROID_PACKAGE_NAME);\n                    logAddAccountMetrics(\n                            callerPackage, accountType, requiredFeatures, authTokenType);\n                }\n\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now) + \", addAccount\"\n                            + \", accountType \" + accountType\n                            + \", requiredFeatures \"\n                            + (requiredFeatures != null\n                            ? TextUtils.join(\",\", requiredFeatures)\n                            : null);\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private void logAddAccountMetrics(\n            String callerPackage, String accountType, String[] requiredFeatures,\n            String authTokenType) {\n        // Although this is not a 'device policy' API, enterprise is the current use case.\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.ADD_ACCOUNT)\n                .setStrings(\n                        TextUtils.emptyIfNull(accountType),\n                        TextUtils.emptyIfNull(callerPackage),\n                        TextUtils.emptyIfNull(authTokenType),\n                        requiredFeatures == null\n                                ? \"\"\n                                : TextUtils.join(\";\", requiredFeatures))\n                .write();\n    }\n\n    @Override\n    public void startAddAccountSession(\n            final IAccountManagerResponse response,\n            final String accountType,\n            final String authTokenType,\n            final String[] requiredFeatures,\n            final boolean expectActivityLaunch,\n            final Bundle optionsIn) {\n        Bundle.setDefusable(optionsIn, true);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG,\n                    \"startAddAccountSession: accountType \" + accountType\n                    + \", response \" + response\n                    + \", authTokenType \" + authTokenType\n                    + \", requiredFeatures \" + Arrays.toString(requiredFeatures)\n                    + \", expectActivityLaunch \" + expectActivityLaunch\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Preconditions.checkArgument(response != null, \"response cannot be null\");\n        Preconditions.checkArgument(accountType != null, \"accountType cannot be null\");\n\n        final int uid = Binder.getCallingUid();\n        final int userId = UserHandle.getUserId(uid);\n        if (!canUserModifyAccounts(userId, uid)) {\n            try {\n                response.onError(AccountManager.ERROR_CODE_USER_RESTRICTED,\n                        \"User is not allowed to add an account!\");\n            } catch (RemoteException re) {\n            }\n            showCantAddAccount(AccountManager.ERROR_CODE_USER_RESTRICTED, userId);\n            return;\n        }\n        if (!canUserModifyAccountsForType(userId, accountType, uid)) {\n            try {\n                response.onError(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                        \"User cannot modify accounts of this type (policy).\");\n            } catch (RemoteException re) {\n            }\n            showCantAddAccount(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                    userId);\n            return;\n        }\n        final int pid = Binder.getCallingPid();\n        final Bundle options = (optionsIn == null) ? new Bundle() : optionsIn;\n        options.putInt(AccountManager.KEY_CALLER_UID, uid);\n        options.putInt(AccountManager.KEY_CALLER_PID, pid);\n\n        // Check to see if the Password should be included to the caller.\n        String callerPkg = options.getString(AccountManager.KEY_ANDROID_PACKAGE_NAME);\n        boolean isPasswordForwardingAllowed = checkPermissionAndNote(\n                callerPkg, uid, Manifest.permission.GET_PASSWORD);\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            logRecordWithUid(accounts, AccountsDb.DEBUG_ACTION_CALLED_START_ACCOUNT_ADD,\n                    AccountsDb.TABLE_ACCOUNTS, uid);\n            new StartAccountSession(\n                    accounts,\n                    response,\n                    accountType,\n                    expectActivityLaunch,\n                    null /* accountName */,\n                    false /* authDetailsRequired */,\n                    true /* updateLastAuthenticationTime */,\n                    isPasswordForwardingAllowed) {\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.startAddAccountSession(this, mAccountType, authTokenType,\n                            requiredFeatures, options);\n                    logAddAccountMetrics(callerPkg, accountType, requiredFeatures, authTokenType);\n                }\n\n                @Override\n                protected String toDebugString(long now) {\n                    String requiredFeaturesStr = TextUtils.join(\",\", requiredFeatures);\n                    return super.toDebugString(now) + \", startAddAccountSession\" + \", accountType \"\n                            + accountType + \", requiredFeatures \"\n                            + (requiredFeatures != null ? requiredFeaturesStr : null);\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    /** Session that will encrypt the KEY_ACCOUNT_SESSION_BUNDLE in result. */\n    private abstract class StartAccountSession extends Session {\n\n        private final boolean mIsPasswordForwardingAllowed;\n\n        public StartAccountSession(\n                UserAccounts accounts,\n                IAccountManagerResponse response,\n                String accountType,\n                boolean expectActivityLaunch,\n                String accountName,\n                boolean authDetailsRequired,\n                boolean updateLastAuthenticationTime,\n                boolean isPasswordForwardingAllowed) {\n            super(accounts, response, accountType, expectActivityLaunch,\n                    true /* stripAuthTokenFromResult */, accountName, authDetailsRequired,\n                    updateLastAuthenticationTime);\n            mIsPasswordForwardingAllowed = isPasswordForwardingAllowed;\n        }\n\n        @Override\n        public void onResult(Bundle result) {\n            Bundle.setDefusable(result, true);\n            mNumResults++;\n            Intent intent = null;\n            if (result != null) {\n                if (!checkKeyIntent(\n                        Binder.getCallingUid(),\n                        result)) {\n                    onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                            \"invalid intent in bundle returned\");\n                    return;\n                }\n            }\n            IAccountManagerResponse response;\n            if (mExpectActivityLaunch && result != null\n                    && result.containsKey(AccountManager.KEY_INTENT)) {\n                response = mResponse;\n            } else {\n                response = getResponseAndClose();\n            }\n            if (response == null) {\n                return;\n            }\n            if (result == null) {\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.v(TAG, getClass().getSimpleName() + \" calling onError() on response \"\n                            + response);\n                }\n                sendErrorResponse(response, AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                        \"null bundle returned\");\n                return;\n            }\n\n            if ((result.getInt(AccountManager.KEY_ERROR_CODE, -1) > 0) && (intent == null)) {\n                // All AccountManager error codes are greater\n                // than 0\n                sendErrorResponse(response, result.getInt(AccountManager.KEY_ERROR_CODE),\n                        result.getString(AccountManager.KEY_ERROR_MESSAGE));\n                return;\n            }\n\n            // Omit passwords if the caller isn't permitted to see them.\n            if (!mIsPasswordForwardingAllowed) {\n                result.remove(AccountManager.KEY_PASSWORD);\n            }\n\n            // Strip auth token from result.\n            result.remove(AccountManager.KEY_AUTHTOKEN);\n            if (!checkKeyIntent(Binder.getCallingUid(), result)) {\n                onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                        \"invalid intent in bundle returned\");\n                return;\n            }\n\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG,\n                        getClass().getSimpleName() + \" calling onResult() on response \" + response);\n            }\n\n            // Get the session bundle created by authenticator. The\n            // bundle contains data necessary for finishing the session\n            // later. The session bundle will be encrypted here and\n            // decrypted later when trying to finish the session.\n            Bundle sessionBundle = result.getBundle(AccountManager.KEY_ACCOUNT_SESSION_BUNDLE);\n            if (sessionBundle != null) {\n                String accountType = sessionBundle.getString(AccountManager.KEY_ACCOUNT_TYPE);\n                if (TextUtils.isEmpty(accountType)\n                        || !mAccountType.equalsIgnoreCase(accountType)) {\n                    Log.w(TAG, \"Account type in session bundle doesn't match request.\");\n                }\n                // Add accountType info to session bundle. This will\n                // override any value set by authenticator.\n                sessionBundle.putString(AccountManager.KEY_ACCOUNT_TYPE, mAccountType);\n\n                // Encrypt session bundle before returning to caller.\n                try {\n                    CryptoHelper cryptoHelper = CryptoHelper.getInstance();\n                    Bundle encryptedBundle = cryptoHelper.encryptBundle(sessionBundle);\n                    result.putBundle(AccountManager.KEY_ACCOUNT_SESSION_BUNDLE, encryptedBundle);\n                } catch (GeneralSecurityException e) {\n                    if (Log.isLoggable(TAG, Log.DEBUG)) {\n                        Log.v(TAG, \"Failed to encrypt session bundle!\", e);\n                    }\n                    sendErrorResponse(response, AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                            \"failed to encrypt session bundle\");\n                    return;\n                }\n            }\n\n            sendResponse(response, result);\n        }\n    }\n\n    @Override\n    public void finishSessionAsUser(IAccountManagerResponse response,\n            @NonNull Bundle sessionBundle,\n            boolean expectActivityLaunch,\n            Bundle appInfo,\n            int userId) {\n        Bundle.setDefusable(sessionBundle, true);\n        int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG,\n                    \"finishSession: response \"+ response\n                            + \", expectActivityLaunch \" + expectActivityLaunch\n                            + \", caller's uid \" + callingUid\n                            + \", caller's user id \" + UserHandle.getCallingUserId()\n                            + \", pid \" + Binder.getCallingPid()\n                            + \", for user id \" + userId);\n        }\n        Preconditions.checkArgument(response != null, \"response cannot be null\");\n        // Session bundle is the encrypted bundle of the original bundle created by authenticator.\n        // Account type is added to it before encryption.\n        if (sessionBundle == null || sessionBundle.size() == 0) {\n            throw new IllegalArgumentException(\"sessionBundle is empty\");\n        }\n\n        // Only allow the system process to finish session for other users.\n        if (isCrossUser(callingUid, userId)) {\n            throw new SecurityException(\n                    String.format(\n                            \"User %s trying to finish session for %s without cross user permission\",\n                            UserHandle.getCallingUserId(),\n                            userId));\n        }\n\n        if (!canUserModifyAccounts(userId, callingUid)) {\n            sendErrorResponse(response,\n                    AccountManager.ERROR_CODE_USER_RESTRICTED,\n                    \"User is not allowed to add an account!\");\n            showCantAddAccount(AccountManager.ERROR_CODE_USER_RESTRICTED, userId);\n            return;\n        }\n\n        final int pid = Binder.getCallingPid();\n        final Bundle decryptedBundle;\n        final String accountType;\n        // First decrypt session bundle to get account type for checking permission.\n        try {\n            CryptoHelper cryptoHelper = CryptoHelper.getInstance();\n            decryptedBundle = cryptoHelper.decryptBundle(sessionBundle);\n            if (decryptedBundle == null) {\n                sendErrorResponse(\n                        response,\n                        AccountManager.ERROR_CODE_BAD_REQUEST,\n                        \"failed to decrypt session bundle\");\n                return;\n            }\n            accountType = decryptedBundle.getString(AccountManager.KEY_ACCOUNT_TYPE);\n            // Account type cannot be null. This should not happen if session bundle was created\n            // properly by #StartAccountSession.\n            if (TextUtils.isEmpty(accountType)) {\n                sendErrorResponse(\n                        response,\n                        AccountManager.ERROR_CODE_BAD_ARGUMENTS,\n                        \"accountType is empty\");\n                return;\n            }\n\n            // If by any chances, decryptedBundle contains colliding keys with\n            // system info\n            // such as AccountManager.KEY_ANDROID_PACKAGE_NAME required by the add account flow or\n            // update credentials flow, we should replace with the new values of the current call.\n            if (appInfo != null) {\n                decryptedBundle.putAll(appInfo);\n            }\n\n            // Add info that may be used by add account or update credentials flow.\n            decryptedBundle.putInt(AccountManager.KEY_CALLER_UID, callingUid);\n            decryptedBundle.putInt(AccountManager.KEY_CALLER_PID, pid);\n        } catch (GeneralSecurityException e) {\n            if (Log.isLoggable(TAG, Log.DEBUG)) {\n                Log.v(TAG, \"Failed to decrypt session bundle!\", e);\n            }\n            sendErrorResponse(\n                    response,\n                    AccountManager.ERROR_CODE_BAD_REQUEST,\n                    \"failed to decrypt session bundle\");\n            return;\n        }\n\n        if (!canUserModifyAccountsForType(userId, accountType, callingUid)) {\n            sendErrorResponse(\n                    response,\n                    AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                    \"User cannot modify accounts of this type (policy).\");\n            showCantAddAccount(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                    userId);\n            return;\n        }\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            logRecordWithUid(\n                    accounts,\n                    AccountsDb.DEBUG_ACTION_CALLED_ACCOUNT_SESSION_FINISH,\n                    AccountsDb.TABLE_ACCOUNTS,\n                    callingUid);\n            new Session(\n                    accounts,\n                    response,\n                    accountType,\n                    expectActivityLaunch,\n                    true /* stripAuthTokenFromResult */,\n                    null /* accountName */,\n                    false /* authDetailsRequired */,\n                    true /* updateLastAuthenticationTime */) {\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.finishSession(this, mAccountType, decryptedBundle);\n                }\n\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now)\n                            + \", finishSession\"\n                            + \", accountType \" + accountType;\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private void showCantAddAccount(int errorCode, int userId) {\n        final DevicePolicyManagerInternal dpmi =\n                LocalServices.getService(DevicePolicyManagerInternal.class);\n        Intent intent = null;\n        if (dpmi == null) {\n            intent = getDefaultCantAddAccountIntent(errorCode);\n        } else if (errorCode == AccountManager.ERROR_CODE_USER_RESTRICTED) {\n            intent = dpmi.createUserRestrictionSupportIntent(userId,\n                    UserManager.DISALLOW_MODIFY_ACCOUNTS);\n        } else if (errorCode == AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE) {\n            intent = dpmi.createShowAdminSupportIntent(userId, false);\n        }\n        if (intent == null) {\n            intent = getDefaultCantAddAccountIntent(errorCode);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            mContext.startActivityAsUser(intent, new UserHandle(userId));\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    /**\n     * Called when we don't know precisely who is preventing us from adding an account.\n     */\n    private Intent getDefaultCantAddAccountIntent(int errorCode) {\n        Intent cantAddAccount = new Intent(mContext, CantAddAccountActivity.class);\n        cantAddAccount.putExtra(CantAddAccountActivity.EXTRA_ERROR_CODE, errorCode);\n        cantAddAccount.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        return cantAddAccount;\n    }\n\n    @Override\n    public void confirmCredentialsAsUser(\n            IAccountManagerResponse response,\n            final Account account,\n            final Bundle options,\n            final boolean expectActivityLaunch,\n            int userId) {\n        Bundle.setDefusable(options, true);\n        int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"confirmCredentials: \" + account\n                    + \", response \" + response\n                    + \", expectActivityLaunch \" + expectActivityLaunch\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        // Only allow the system process to read accounts of other users\n        if (isCrossUser(callingUid, userId)) {\n            throw new SecurityException(\n                    String.format(\n                            \"User %s trying to confirm account credentials for %s\" ,\n                            UserHandle.getCallingUserId(),\n                            userId));\n        }\n        if (response == null) throw new IllegalArgumentException(\"response is null\");\n        if (account == null) throw new IllegalArgumentException(\"account is null\");\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            new Session(accounts, response, account.type, expectActivityLaunch,\n                    true /* stripAuthTokenFromResult */, account.name,\n                    true /* authDetailsRequired */, true /* updateLastAuthenticatedTime */) {\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.confirmCredentials(this, account, options);\n                }\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now) + \", confirmCredentials\"\n                            + \", \" + account.toSafeString();\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void updateCredentials(IAccountManagerResponse response, final Account account,\n            final String authTokenType, final boolean expectActivityLaunch,\n            final Bundle loginOptions) {\n        Bundle.setDefusable(loginOptions, true);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"updateCredentials: \" + account\n                    + \", response \" + response\n                    + \", authTokenType \" + authTokenType\n                    + \", expectActivityLaunch \" + expectActivityLaunch\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        if (response == null) throw new IllegalArgumentException(\"response is null\");\n        if (account == null) throw new IllegalArgumentException(\"account is null\");\n        int userId = UserHandle.getCallingUserId();\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            new Session(accounts, response, account.type, expectActivityLaunch,\n                    true /* stripAuthTokenFromResult */, account.name,\n                    false /* authDetailsRequired */, true /* updateLastCredentialTime */) {\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.updateCredentials(this, account, authTokenType, loginOptions);\n                }\n                @Override\n                protected String toDebugString(long now) {\n                    if (loginOptions != null) loginOptions.keySet();\n                    return super.toDebugString(now) + \", updateCredentials\"\n                            + \", \" + account.toSafeString()\n                            + \", authTokenType \" + authTokenType\n                            + \", loginOptions \" + loginOptions;\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void startUpdateCredentialsSession(\n            IAccountManagerResponse response,\n            final Account account,\n            final String authTokenType,\n            final boolean expectActivityLaunch,\n            final Bundle loginOptions) {\n        Bundle.setDefusable(loginOptions, true);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG,\n                    \"startUpdateCredentialsSession: \" + account + \", response \" + response\n                            + \", authTokenType \" + authTokenType + \", expectActivityLaunch \"\n                            + expectActivityLaunch + \", caller's uid \" + Binder.getCallingUid()\n                            + \", pid \" + Binder.getCallingPid());\n        }\n        if (response == null) {\n            throw new IllegalArgumentException(\"response is null\");\n        }\n        if (account == null) {\n            throw new IllegalArgumentException(\"account is null\");\n        }\n\n        final int uid = Binder.getCallingUid();\n        int userId = UserHandle.getCallingUserId();\n\n        // Check to see if the Password should be included to the caller.\n        String callerPkg = loginOptions.getString(AccountManager.KEY_ANDROID_PACKAGE_NAME);\n        boolean isPasswordForwardingAllowed = checkPermissionAndNote(\n                callerPkg, uid, Manifest.permission.GET_PASSWORD);\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            new StartAccountSession(\n                    accounts,\n                    response,\n                    account.type,\n                    expectActivityLaunch,\n                    account.name,\n                    false /* authDetailsRequired */,\n                    true /* updateLastCredentialTime */,\n                    isPasswordForwardingAllowed) {\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.startUpdateCredentialsSession(this, account, authTokenType,\n                            loginOptions);\n                }\n\n                @Override\n                protected String toDebugString(long now) {\n                    if (loginOptions != null)\n                        loginOptions.keySet();\n                    return super.toDebugString(now)\n                            + \", startUpdateCredentialsSession\"\n                            + \", \" + account.toSafeString()\n                            + \", authTokenType \" + authTokenType\n                            + \", loginOptions \" + loginOptions;\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void isCredentialsUpdateSuggested(\n            IAccountManagerResponse response,\n            final Account account,\n            final String statusToken) {\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG,\n                    \"isCredentialsUpdateSuggested: \" + account + \", response \" + response\n                            + \", caller's uid \" + Binder.getCallingUid()\n                            + \", pid \" + Binder.getCallingPid());\n        }\n        if (response == null) {\n            throw new IllegalArgumentException(\"response is null\");\n        }\n        if (account == null) {\n            throw new IllegalArgumentException(\"account is null\");\n        }\n        if (TextUtils.isEmpty(statusToken)) {\n            throw new IllegalArgumentException(\"status token is empty\");\n        }\n\n        int usrId = UserHandle.getCallingUserId();\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(usrId);\n            new Session(accounts, response, account.type, false /* expectActivityLaunch */,\n                    false /* stripAuthTokenFromResult */, account.name,\n                    false /* authDetailsRequired */) {\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now) + \", isCredentialsUpdateSuggested\"\n                            + \", \" + account.toSafeString();\n                }\n\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.isCredentialsUpdateSuggested(this, account, statusToken);\n                }\n\n                @Override\n                public void onResult(Bundle result) {\n                    Bundle.setDefusable(result, true);\n                    IAccountManagerResponse response = getResponseAndClose();\n                    if (response == null) {\n                        return;\n                    }\n\n                    if (result == null) {\n                        sendErrorResponse(\n                                response,\n                                AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                                \"null bundle\");\n                        return;\n                    }\n\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, getClass().getSimpleName() + \" calling onResult() on response \"\n                                + response);\n                    }\n                    // Check to see if an error occurred. We know if an error occurred because all\n                    // error codes are greater than 0.\n                    if ((result.getInt(AccountManager.KEY_ERROR_CODE, -1) > 0)) {\n                        sendErrorResponse(response,\n                                result.getInt(AccountManager.KEY_ERROR_CODE),\n                                result.getString(AccountManager.KEY_ERROR_MESSAGE));\n                        return;\n                    }\n                    if (!result.containsKey(AccountManager.KEY_BOOLEAN_RESULT)) {\n                        sendErrorResponse(\n                                response,\n                                AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                                \"no result in response\");\n                        return;\n                    }\n                    final Bundle newResult = new Bundle();\n                    newResult.putBoolean(AccountManager.KEY_BOOLEAN_RESULT,\n                            result.getBoolean(AccountManager.KEY_BOOLEAN_RESULT, false));\n                    sendResponse(response, newResult);\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void editProperties(IAccountManagerResponse response, final String accountType,\n            final boolean expectActivityLaunch) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"editProperties: accountType \" + accountType\n                    + \", response \" + response\n                    + \", expectActivityLaunch \" + expectActivityLaunch\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        if (response == null) throw new IllegalArgumentException(\"response is null\");\n        if (accountType == null) throw new IllegalArgumentException(\"accountType is null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(accountType, callingUid, userId)\n                && !isSystemUid(callingUid)) {\n            String msg = String.format(\n                    \"uid %s cannot edit authenticator properites for account type: %s\",\n                    callingUid,\n                    accountType);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            new Session(accounts, response, accountType, expectActivityLaunch,\n                    true /* stripAuthTokenFromResult */, null /* accountName */,\n                    false /* authDetailsRequired */) {\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.editProperties(this, mAccountType);\n                }\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now) + \", editProperties\"\n                            + \", accountType \" + accountType;\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public boolean hasAccountAccess(@NonNull Account account,  @NonNull String packageName,\n            @NonNull UserHandle userHandle) {\n        if (UserHandle.getAppId(Binder.getCallingUid()) != Process.SYSTEM_UID) {\n            throw new SecurityException(\"Can be called only by system UID\");\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        Objects.requireNonNull(packageName, \"packageName cannot be null\");\n        Objects.requireNonNull(userHandle, \"userHandle cannot be null\");\n\n        final int userId = userHandle.getIdentifier();\n\n        Preconditions.checkArgumentInRange(userId, 0, Integer.MAX_VALUE, \"user must be concrete\");\n\n        try {\n            int uid = mPackageManager.getPackageUidAsUser(packageName, userId);\n            return hasAccountAccess(account, packageName, uid);\n        } catch (NameNotFoundException e) {\n            Log.d(TAG, \"Package not found \" + e.getMessage());\n            return false;\n        }\n    }\n\n    // Returns package with oldest target SDK for given UID.\n    private String getPackageNameForUid(int uid) {\n        String[] packageNames = mPackageManager.getPackagesForUid(uid);\n        if (ArrayUtils.isEmpty(packageNames)) {\n            return null;\n        }\n        String packageName = packageNames[0];\n        if (packageNames.length == 1) {\n            return packageName;\n        }\n        // Due to visibility changes we want to use package with oldest target SDK\n        int oldestVersion = Integer.MAX_VALUE;\n        for (String name : packageNames) {\n            try {\n                ApplicationInfo applicationInfo = mPackageManager.getApplicationInfo(name, 0);\n                if (applicationInfo != null) {\n                    int version = applicationInfo.targetSdkVersion;\n                    if (version < oldestVersion) {\n                        oldestVersion = version;\n                        packageName = name;\n                    }\n                }\n            } catch (NameNotFoundException e) {\n                // skip\n            }\n        }\n        return packageName;\n    }\n\n    private boolean hasAccountAccess(@NonNull Account account, @Nullable String packageName,\n            int uid) {\n        if (packageName == null) {\n            packageName = getPackageNameForUid(uid);\n            if (packageName == null) {\n                return false;\n            }\n        }\n\n        // Use null token which means any token. Having a token means the package\n        // is trusted by the authenticator, hence it is fine to access the account.\n        if (permissionIsGranted(account, null, uid, UserHandle.getUserId(uid))) {\n            return true;\n        }\n        // In addition to the permissions required to get an auth token we also allow\n        // the account to be accessed by apps for which user or authenticator granted visibility.\n\n        int visibility = resolveAccountVisibility(account, packageName,\n            getUserAccounts(UserHandle.getUserId(uid)));\n        return (visibility == AccountManager.VISIBILITY_VISIBLE\n            || visibility == AccountManager.VISIBILITY_USER_MANAGED_VISIBLE);\n    }\n\n    @Override\n    public IntentSender createRequestAccountAccessIntentSenderAsUser(@NonNull Account account,\n            @NonNull String packageName, @NonNull UserHandle userHandle) {\n        if (UserHandle.getAppId(Binder.getCallingUid()) != Process.SYSTEM_UID) {\n            throw new SecurityException(\"Can be called only by system UID\");\n        }\n\n        Objects.requireNonNull(account, \"account cannot be null\");\n        Objects.requireNonNull(packageName, \"packageName cannot be null\");\n        Objects.requireNonNull(userHandle, \"userHandle cannot be null\");\n\n        final int userId = userHandle.getIdentifier();\n\n        Preconditions.checkArgumentInRange(userId, 0, Integer.MAX_VALUE, \"user must be concrete\");\n\n        final int uid;\n        try {\n            uid = mPackageManager.getPackageUidAsUser(packageName, userId);\n        } catch (NameNotFoundException e) {\n            Slog.e(TAG, \"Unknown package \" + packageName);\n            return null;\n        }\n\n        Intent intent = newRequestAccountAccessIntent(account, packageName, uid, null);\n\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            return PendingIntent.getActivityAsUser(\n                    mContext, 0, intent, PendingIntent.FLAG_ONE_SHOT\n                            | PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_IMMUTABLE,\n                    null, new UserHandle(userId)).getIntentSender();\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    private Intent newRequestAccountAccessIntent(Account account, String packageName,\n            int uid, RemoteCallback callback) {\n        return newGrantCredentialsPermissionIntent(account, packageName, uid,\n                new AccountAuthenticatorResponse(new IAccountAuthenticatorResponse.Stub() {\n            @Override\n            public void onResult(Bundle value) throws RemoteException {\n                handleAuthenticatorResponse(true);\n            }\n\n            @Override\n            public void onRequestContinued() {\n                /* ignore */\n            }\n\n            @Override\n            public void onError(int errorCode, String errorMessage) throws RemoteException {\n                handleAuthenticatorResponse(false);\n            }\n\n            private void handleAuthenticatorResponse(boolean accessGranted) throws RemoteException {\n                cancelNotification(getCredentialPermissionNotificationId(account,\n                        AccountManager.ACCOUNT_ACCESS_TOKEN_TYPE, uid),\n                        UserHandle.getUserHandleForUid(uid));\n                if (callback != null) {\n                    Bundle result = new Bundle();\n                    result.putBoolean(AccountManager.KEY_BOOLEAN_RESULT, accessGranted);\n                    callback.sendResult(result);\n                }\n            }\n        }), AccountManager.ACCOUNT_ACCESS_TOKEN_TYPE, false);\n    }\n\n    @Override\n    public boolean someUserHasAccount(@NonNull final Account account) {\n        if (!UserHandle.isSameApp(Process.SYSTEM_UID, Binder.getCallingUid())) {\n            throw new SecurityException(\"Only system can check for accounts across users\");\n        }\n        final long token = Binder.clearCallingIdentity();\n        try {\n            AccountAndUser[] allAccounts = getAllAccounts();\n            for (int i = allAccounts.length - 1; i >= 0; i--) {\n                if (allAccounts[i].account.equals(account)) {\n                    return true;\n                }\n            }\n            return false;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private class GetAccountsByTypeAndFeatureSession extends Session {\n        private final String[] mFeatures;\n        private volatile Account[] mAccountsOfType = null;\n        private volatile ArrayList<Account> mAccountsWithFeatures = null;\n        private volatile int mCurrentAccount = 0;\n        private final int mCallingUid;\n        private final String mPackageName;\n        private final boolean mIncludeManagedNotVisible;\n\n        public GetAccountsByTypeAndFeatureSession(\n                UserAccounts accounts,\n                IAccountManagerResponse response,\n                String type,\n                String[] features,\n                int callingUid,\n                String packageName,\n                boolean includeManagedNotVisible) {\n            super(accounts, response, type, false /* expectActivityLaunch */,\n                    true /* stripAuthTokenFromResult */, null /* accountName */,\n                    false /* authDetailsRequired */);\n            mCallingUid = callingUid;\n            mFeatures = features;\n            mPackageName = packageName;\n            mIncludeManagedNotVisible = includeManagedNotVisible;\n        }\n\n        @Override\n        public void run() throws RemoteException {\n            mAccountsOfType = getAccountsFromCache(mAccounts, mAccountType,\n                    mCallingUid, mPackageName, mIncludeManagedNotVisible);\n            // check whether each account matches the requested features\n            mAccountsWithFeatures = new ArrayList<>(mAccountsOfType.length);\n            mCurrentAccount = 0;\n\n            checkAccount();\n        }\n\n        public void checkAccount() {\n            if (mCurrentAccount >= mAccountsOfType.length) {\n                sendResult();\n                return;\n            }\n\n            final IAccountAuthenticator accountAuthenticator = mAuthenticator;\n            if (accountAuthenticator == null) {\n                // It is possible that the authenticator has died, which is indicated by\n                // mAuthenticator being set to null. If this happens then just abort.\n                // There is no need to send back a result or error in this case since\n                // that already happened when mAuthenticator was cleared.\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.v(TAG, \"checkAccount: aborting session since we are no longer\"\n                            + \" connected to the authenticator, \" + toDebugString());\n                }\n                return;\n            }\n            try {\n                accountAuthenticator.hasFeatures(this, mAccountsOfType[mCurrentAccount], mFeatures);\n            } catch (RemoteException e) {\n                onError(AccountManager.ERROR_CODE_REMOTE_EXCEPTION, \"remote exception\");\n            }\n        }\n\n        @Override\n        public void onResult(Bundle result) {\n            Bundle.setDefusable(result, true);\n            mNumResults++;\n            if (result == null) {\n                onError(AccountManager.ERROR_CODE_INVALID_RESPONSE, \"null bundle\");\n                return;\n            }\n            if (result.getBoolean(AccountManager.KEY_BOOLEAN_RESULT, false)) {\n                mAccountsWithFeatures.add(mAccountsOfType[mCurrentAccount]);\n            }\n            mCurrentAccount++;\n            checkAccount();\n        }\n\n        public void sendResult() {\n            IAccountManagerResponse response = getResponseAndClose();\n            if (response != null) {\n                try {\n                    Account[] accounts = new Account[mAccountsWithFeatures.size()];\n                    for (int i = 0; i < accounts.length; i++) {\n                        accounts[i] = mAccountsWithFeatures.get(i);\n                    }\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, getClass().getSimpleName() + \" calling onResult() on response \"\n                                + response);\n                    }\n                    Bundle result = new Bundle();\n                    result.putParcelableArray(AccountManager.KEY_ACCOUNTS, accounts);\n                    response.onResult(result);\n                } catch (RemoteException e) {\n                    // if the caller is dead then there is no one to care about remote exceptions\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, \"failure while notifying response\", e);\n                    }\n                }\n            }\n        }\n\n        @Override\n        protected String toDebugString(long now) {\n            return super.toDebugString(now) + \", getAccountsByTypeAndFeatures\"\n                    + \", \" + (mFeatures != null ? TextUtils.join(\",\", mFeatures) : null);\n        }\n    }\n\n    /**\n     * Returns the accounts visible to the client within the context of a specific user\n     * @hide\n     */\n    @NonNull\n    public Account[] getAccounts(int userId, String opPackageName) {\n        int callingUid = Binder.getCallingUid();\n        mAppOpsManager.checkPackage(callingUid, opPackageName);\n        List<String> visibleAccountTypes = getTypesVisibleToCaller(callingUid, userId,\n                opPackageName);\n        if (visibleAccountTypes.isEmpty()) {\n            return EMPTY_ACCOUNT_ARRAY;\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return getAccountsInternal(\n                    accounts,\n                    callingUid,\n                    opPackageName,\n                    visibleAccountTypes,\n                    false /* includeUserManagedNotVisible */);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    /**\n     * Returns accounts for all running users, ignores visibility values.\n     *\n     * @hide\n     */\n    @NonNull\n    public AccountAndUser[] getRunningAccounts() {\n        final int[] runningUserIds;\n        try {\n            runningUserIds = ActivityManager.getService().getRunningUserIds();\n        } catch (RemoteException e) {\n            // Running in system_server; should never happen\n            throw new RuntimeException(e);\n        }\n        return getAccounts(runningUserIds);\n    }\n\n    /**\n     * Returns accounts for all users, ignores visibility values.\n     *\n     * @hide\n     */\n    @NonNull\n    public AccountAndUser[] getAllAccounts() {\n        final List<UserInfo> users = getUserManager().getAliveUsers();\n        final int[] userIds = new int[users.size()];\n        for (int i = 0; i < userIds.length; i++) {\n            userIds[i] = users.get(i).id;\n        }\n        return getAccounts(userIds);\n    }\n\n    @NonNull\n    private AccountAndUser[] getAccounts(int[] userIds) {\n        final ArrayList<AccountAndUser> runningAccounts = Lists.newArrayList();\n        for (int userId : userIds) {\n            UserAccounts userAccounts = getUserAccounts(userId);\n            if (userAccounts == null) continue;\n            Account[] accounts = getAccountsFromCache(\n                    userAccounts,\n                    null /* type */,\n                    Binder.getCallingUid(),\n                    null /* packageName */,\n                    false /* include managed not visible*/);\n            for (Account account : accounts) {\n                runningAccounts.add(new AccountAndUser(account, userId));\n            }\n        }\n\n        AccountAndUser[] accountsArray = new AccountAndUser[runningAccounts.size()];\n        return runningAccounts.toArray(accountsArray);\n    }\n\n    @Override\n    @NonNull\n    public Account[] getAccountsAsUser(String type, int userId, String opPackageName) {\n        int callingUid = Binder.getCallingUid();\n        mAppOpsManager.checkPackage(callingUid, opPackageName);\n        return getAccountsAsUserForPackage(type, userId, opPackageName /* callingPackage */, -1,\n                opPackageName, false /* includeUserManagedNotVisible */);\n    }\n\n    @NonNull\n    private Account[] getAccountsAsUserForPackage(\n            String type,\n            int userId,\n            String callingPackage,\n            int packageUid,\n            String opPackageName,\n            boolean includeUserManagedNotVisible) {\n        int callingUid = Binder.getCallingUid();\n        // Only allow the system process to read accounts of other users\n        if (userId != UserHandle.getCallingUserId()\n                && callingUid != Process.SYSTEM_UID\n                && mContext.checkCallingOrSelfPermission(\n                    android.Manifest.permission.INTERACT_ACROSS_USERS_FULL)\n                    != PackageManager.PERMISSION_GRANTED) {\n            throw new SecurityException(\"User \" + UserHandle.getCallingUserId()\n                    + \" trying to get account for \" + userId);\n        }\n\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"getAccounts: accountType \" + type\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid());\n        }\n\n        // If the original calling app was using account choosing activity\n        // provided by the framework or authenticator we'll passing in\n        // the original caller's uid here, which is what should be used for filtering.\n        List<String> managedTypes =\n                getTypesManagedByCaller(callingUid, UserHandle.getUserId(callingUid));\n        if (packageUid != -1 &&\n                ((UserHandle.isSameApp(callingUid, Process.SYSTEM_UID)\n                || (type != null && managedTypes.contains(type))))) {\n            callingUid = packageUid;\n            opPackageName = callingPackage;\n        }\n        List<String> visibleAccountTypes = getTypesVisibleToCaller(callingUid, userId,\n                opPackageName);\n        if (visibleAccountTypes.isEmpty()\n                || (type != null && !visibleAccountTypes.contains(type))) {\n            return EMPTY_ACCOUNT_ARRAY;\n        } else if (visibleAccountTypes.contains(type)) {\n            // Prune the list down to just the requested type.\n            visibleAccountTypes = new ArrayList<>();\n            visibleAccountTypes.add(type);\n        } // else aggregate all the visible accounts (it won't matter if the\n          // list is empty).\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return getAccountsInternal(\n                    accounts,\n                    callingUid,\n                    opPackageName,\n                    visibleAccountTypes,\n                    includeUserManagedNotVisible);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @NonNull\n    private Account[] getAccountsInternal(\n            UserAccounts userAccounts,\n            int callingUid,\n            String callingPackage,\n            List<String> visibleAccountTypes,\n            boolean includeUserManagedNotVisible) {\n        ArrayList<Account> visibleAccounts = new ArrayList<>();\n        for (String visibleType : visibleAccountTypes) {\n            Account[] accountsForType = getAccountsFromCache(\n                    userAccounts, visibleType, callingUid, callingPackage,\n                    includeUserManagedNotVisible);\n            if (accountsForType != null) {\n                visibleAccounts.addAll(Arrays.asList(accountsForType));\n            }\n        }\n        Account[] result = new Account[visibleAccounts.size()];\n        for (int i = 0; i < visibleAccounts.size(); i++) {\n            result[i] = visibleAccounts.get(i);\n        }\n        return result;\n    }\n\n    @Override\n    public void addSharedAccountsFromParentUser(int parentUserId, int userId,\n            String opPackageName) {\n        checkManageOrCreateUsersPermission(\"addSharedAccountsFromParentUser\");\n        Account[] accounts = getAccountsAsUser(null, parentUserId, opPackageName);\n        for (Account account : accounts) {\n            addSharedAccountAsUser(account, userId);\n        }\n    }\n\n    private boolean addSharedAccountAsUser(Account account, int userId) {\n        userId = handleIncomingUser(userId);\n        UserAccounts accounts = getUserAccounts(userId);\n        accounts.accountsDb.deleteSharedAccount(account);\n        long accountId = accounts.accountsDb.insertSharedAccount(account);\n        if (accountId < 0) {\n            Log.w(TAG, \"insertAccountIntoDatabase: \" + account.toSafeString()\n                    + \", skipping the DB insert failed\");\n            return false;\n        }\n        logRecord(AccountsDb.DEBUG_ACTION_ACCOUNT_ADD, AccountsDb.TABLE_SHARED_ACCOUNTS, accountId,\n                accounts);\n        return true;\n    }\n\n    public boolean renameSharedAccountAsUser(Account account, String newName, int userId) {\n        userId = handleIncomingUser(userId);\n        UserAccounts accounts = getUserAccounts(userId);\n        long sharedTableAccountId = accounts.accountsDb.findSharedAccountId(account);\n        int r = accounts.accountsDb.renameSharedAccount(account, newName);\n        if (r > 0) {\n            int callingUid = getCallingUid();\n            logRecord(AccountsDb.DEBUG_ACTION_ACCOUNT_RENAME, AccountsDb.TABLE_SHARED_ACCOUNTS,\n                    sharedTableAccountId, accounts, callingUid);\n            // Recursively rename the account.\n            renameAccountInternal(accounts, account, newName);\n        }\n        return r > 0;\n    }\n\n    public boolean removeSharedAccountAsUser(Account account, int userId) {\n        return removeSharedAccountAsUser(account, userId, getCallingUid());\n    }\n\n    private boolean removeSharedAccountAsUser(Account account, int userId, int callingUid) {\n        userId = handleIncomingUser(userId);\n        UserAccounts accounts = getUserAccounts(userId);\n        long sharedTableAccountId = accounts.accountsDb.findSharedAccountId(account);\n        boolean deleted = accounts.accountsDb.deleteSharedAccount(account);\n        if (deleted) {\n            logRecord(AccountsDb.DEBUG_ACTION_ACCOUNT_REMOVE, AccountsDb.TABLE_SHARED_ACCOUNTS,\n                    sharedTableAccountId, accounts, callingUid);\n            removeAccountInternal(accounts, account, callingUid);\n        }\n        return deleted;\n    }\n\n    public Account[] getSharedAccountsAsUser(int userId) {\n        userId = handleIncomingUser(userId);\n        UserAccounts accounts = getUserAccounts(userId);\n        synchronized (accounts.dbLock) {\n            List<Account> accountList = accounts.accountsDb.getSharedAccounts();\n            Account[] accountArray = new Account[accountList.size()];\n            accountList.toArray(accountArray);\n            return accountArray;\n        }\n    }\n\n    @Override\n    @NonNull\n    public Account[] getAccountsForPackage(String packageName, int uid, String opPackageName) {\n        int callingUid = Binder.getCallingUid();\n        if (!UserHandle.isSameApp(callingUid, Process.SYSTEM_UID)) {\n            // Don't do opPackageName check - caller is system.\n            throw new SecurityException(\"getAccountsForPackage() called from unauthorized uid \"\n                    + callingUid + \" with uid=\" + uid);\n        }\n        return getAccountsAsUserForPackage(null, UserHandle.getCallingUserId(), packageName, uid,\n                opPackageName, true /* includeUserManagedNotVisible */);\n    }\n\n    @Override\n    @NonNull\n    public Account[] getAccountsByTypeForPackage(String type, String packageName,\n            String opPackageName) {\n        int callingUid =  Binder.getCallingUid();\n        int userId = UserHandle.getCallingUserId();\n        mAppOpsManager.checkPackage(callingUid, opPackageName);\n        int packageUid = -1;\n        try {\n            packageUid = mPackageManager.getPackageUidAsUser(packageName, userId);\n        } catch (NameNotFoundException re) {\n            Slog.e(TAG, \"Couldn't determine the packageUid for \" + packageName + re);\n            return EMPTY_ACCOUNT_ARRAY;\n        }\n        if (!UserHandle.isSameApp(callingUid, Process.SYSTEM_UID)\n                && (type != null && !isAccountManagedByCaller(type, callingUid, userId))) {\n                return EMPTY_ACCOUNT_ARRAY;\n        }\n        if (!UserHandle.isSameApp(callingUid, Process.SYSTEM_UID) && type == null) {\n            return getAccountsAsUserForPackage(type, userId,\n                packageName, packageUid, opPackageName, false /* includeUserManagedNotVisible */);\n        }\n        return getAccountsAsUserForPackage(type, userId,\n                packageName, packageUid, opPackageName, true /* includeUserManagedNotVisible */);\n    }\n\n    private boolean needToStartChooseAccountActivity(Account[] accounts, String callingPackage) {\n        if (accounts.length < 1) return false;\n        if (accounts.length > 1) return true;\n        Account account = accounts[0];\n        UserAccounts userAccounts = getUserAccounts(UserHandle.getCallingUserId());\n        int visibility = resolveAccountVisibility(account, callingPackage, userAccounts);\n        if (visibility == AccountManager.VISIBILITY_USER_MANAGED_NOT_VISIBLE) return true;\n        return false;\n    }\n\n    private void startChooseAccountActivityWithAccounts(\n        IAccountManagerResponse response, Account[] accounts, String callingPackage) {\n        Intent intent = new Intent(mContext, ChooseAccountActivity.class);\n        intent.putExtra(AccountManager.KEY_ACCOUNTS, accounts);\n        intent.putExtra(AccountManager.KEY_ACCOUNT_MANAGER_RESPONSE,\n                new AccountManagerResponse(response));\n        intent.putExtra(AccountManager.KEY_ANDROID_PACKAGE_NAME, callingPackage);\n\n        mContext.startActivityAsUser(intent, UserHandle.of(UserHandle.getCallingUserId()));\n    }\n\n    private void handleGetAccountsResult(\n        IAccountManagerResponse response,\n        Account[] accounts,\n        String callingPackage) {\n\n        if (needToStartChooseAccountActivity(accounts, callingPackage)) {\n            startChooseAccountActivityWithAccounts(response, accounts, callingPackage);\n            return;\n        }\n        if (accounts.length == 1) {\n            Bundle bundle = new Bundle();\n            bundle.putString(AccountManager.KEY_ACCOUNT_NAME, accounts[0].name);\n            bundle.putString(AccountManager.KEY_ACCOUNT_TYPE, accounts[0].type);\n            onResult(response, bundle);\n            return;\n        }\n        // No qualified account exists, return an empty Bundle.\n        onResult(response, new Bundle());\n    }\n\n    @Override\n    public void getAccountByTypeAndFeatures(\n        IAccountManagerResponse response,\n        String accountType,\n        String[] features,\n        String opPackageName) {\n\n        int callingUid = Binder.getCallingUid();\n        mAppOpsManager.checkPackage(callingUid, opPackageName);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"getAccount: accountType \" + accountType\n                    + \", response \" + response\n                    + \", features \" + Arrays.toString(features)\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        if (response == null) throw new IllegalArgumentException(\"response is null\");\n        if (accountType == null) throw new IllegalArgumentException(\"accountType is null\");\n\n        int userId = UserHandle.getCallingUserId();\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts userAccounts = getUserAccounts(userId);\n            if (ArrayUtils.isEmpty(features)) {\n                Account[] accountsWithManagedNotVisible = getAccountsFromCache(\n                    userAccounts, accountType, callingUid, opPackageName,\n                    true /* include managed not visible */);\n                handleGetAccountsResult(\n                    response, accountsWithManagedNotVisible, opPackageName);\n                return;\n            }\n\n            IAccountManagerResponse retrieveAccountsResponse =\n                new IAccountManagerResponse.Stub() {\n                @Override\n                public void onResult(Bundle value) throws RemoteException {\n                    Parcelable[] parcelables = value.getParcelableArray(\n                        AccountManager.KEY_ACCOUNTS);\n                    Account[] accounts = new Account[parcelables.length];\n                    for (int i = 0; i < parcelables.length; i++) {\n                        accounts[i] = (Account) parcelables[i];\n                    }\n                    handleGetAccountsResult(\n                        response, accounts, opPackageName);\n                }\n\n                @Override\n                public void onError(int errorCode, String errorMessage)\n                        throws RemoteException {\n                    // Will not be called in this case.\n                }\n            };\n            new GetAccountsByTypeAndFeatureSession(\n                    userAccounts,\n                    retrieveAccountsResponse,\n                    accountType,\n                    features,\n                    callingUid,\n                    opPackageName,\n                    true /* include managed not visible */).bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void getAccountsByFeatures(\n            IAccountManagerResponse response,\n            String type,\n            String[] features,\n            String opPackageName) {\n        int callingUid = Binder.getCallingUid();\n        mAppOpsManager.checkPackage(callingUid, opPackageName);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"getAccounts: accountType \" + type\n                    + \", response \" + response\n                    + \", features \" + Arrays.toString(features)\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        if (response == null) throw new IllegalArgumentException(\"response is null\");\n        if (type == null) throw new IllegalArgumentException(\"accountType is null\");\n        int userId = UserHandle.getCallingUserId();\n\n        List<String> visibleAccountTypes = getTypesVisibleToCaller(callingUid, userId,\n                opPackageName);\n        if (!visibleAccountTypes.contains(type)) {\n            Bundle result = new Bundle();\n            // Need to return just the accounts that are from matching signatures.\n            result.putParcelableArray(AccountManager.KEY_ACCOUNTS, EMPTY_ACCOUNT_ARRAY);\n            try {\n                response.onResult(result);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Cannot respond to caller do to exception.\" , e);\n            }\n            return;\n        }\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts userAccounts = getUserAccounts(userId);\n            if (features == null || features.length == 0) {\n                Account[] accounts = getAccountsFromCache(userAccounts, type, callingUid,\n                        opPackageName, false);\n                Bundle result = new Bundle();\n                result.putParcelableArray(AccountManager.KEY_ACCOUNTS, accounts);\n                onResult(response, result);\n                return;\n            }\n            new GetAccountsByTypeAndFeatureSession(\n                    userAccounts,\n                    response,\n                    type,\n                    features,\n                    callingUid,\n                    opPackageName,\n                    false /* include managed not visible */).bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void onAccountAccessed(String token) throws RemoteException {\n        final int uid = Binder.getCallingUid();\n        if (UserHandle.getAppId(uid) == Process.SYSTEM_UID) {\n            return;\n        }\n        final int userId = UserHandle.getCallingUserId();\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            for (Account account : getAccounts(userId, mContext.getOpPackageName())) {\n                if (Objects.equals(account.getAccessId(), token)) {\n                    // An app just accessed the account. At this point it knows about\n                    // it and there is not need to hide this account from the app.\n                    // Do we need to update account visibility here?\n                    if (!hasAccountAccess(account, null, uid)) {\n                        updateAppPermission(account, AccountManager.ACCOUNT_ACCESS_TOKEN_TYPE,\n                                uid, true);\n                    }\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    @Override\n    public void onShellCommand(FileDescriptor in, FileDescriptor out,\n            FileDescriptor err, String[] args, ShellCallback callback,\n            ResultReceiver resultReceiver) {\n        new AccountManagerServiceShellCommand(this).exec(this, in, out, err, args,\n                callback, resultReceiver);\n    }\n\n    private abstract class Session extends IAccountAuthenticatorResponse.Stub\n            implements IBinder.DeathRecipient, ServiceConnection {\n        IAccountManagerResponse mResponse;\n        final String mAccountType;\n        final boolean mExpectActivityLaunch;\n        final long mCreationTime;\n        final String mAccountName;\n        // Indicates if we need to add auth details(like last credential time)\n        final boolean mAuthDetailsRequired;\n        // If set, we need to update the last authenticated time. This is\n        // currently\n        // used on\n        // successful confirming credentials.\n        final boolean mUpdateLastAuthenticatedTime;\n\n        public int mNumResults = 0;\n        private int mNumRequestContinued = 0;\n        private int mNumErrors = 0;\n\n        IAccountAuthenticator mAuthenticator = null;\n\n        private final boolean mStripAuthTokenFromResult;\n        protected final UserAccounts mAccounts;\n\n        public Session(UserAccounts accounts, IAccountManagerResponse response, String accountType,\n                boolean expectActivityLaunch, boolean stripAuthTokenFromResult, String accountName,\n                boolean authDetailsRequired) {\n            this(accounts, response, accountType, expectActivityLaunch, stripAuthTokenFromResult,\n                    accountName, authDetailsRequired, false /* updateLastAuthenticatedTime */);\n        }\n\n        public Session(UserAccounts accounts, IAccountManagerResponse response, String accountType,\n                boolean expectActivityLaunch, boolean stripAuthTokenFromResult, String accountName,\n                boolean authDetailsRequired, boolean updateLastAuthenticatedTime) {\n            super();\n            //if (response == null) throw new IllegalArgumentException(\"response is null\");\n            if (accountType == null) throw new IllegalArgumentException(\"accountType is null\");\n            mAccounts = accounts;\n            mStripAuthTokenFromResult = stripAuthTokenFromResult;\n            mResponse = response;\n            mAccountType = accountType;\n            mExpectActivityLaunch = expectActivityLaunch;\n            mCreationTime = SystemClock.elapsedRealtime();\n            mAccountName = accountName;\n            mAuthDetailsRequired = authDetailsRequired;\n            mUpdateLastAuthenticatedTime = updateLastAuthenticatedTime;\n\n            synchronized (mSessions) {\n                mSessions.put(toString(), this);\n            }\n            scheduleTimeout();\n            if (response != null) {\n                try {\n                    response.asBinder().linkToDeath(this, 0 /* flags */);\n                } catch (RemoteException e) {\n                    mResponse = null;\n                    binderDied();\n                }\n            }\n        }\n\n        IAccountManagerResponse getResponseAndClose() {\n            if (mResponse == null) {\n                close();\n                return null;\n            }\n            IAccountManagerResponse response = mResponse;\n            close(); // this clears mResponse so we need to save the response before this call\n            return response;\n        }\n\n        /**\n         * Checks Intents, supplied via KEY_INTENT, to make sure that they don't violate our\n         * security policy.\n         *\n         * In particular we want to make sure that the Authenticator doesn't try to trick users\n         * into launching arbitrary intents on the device via by tricking to click authenticator\n         * supplied entries in the system Settings app.\n         */\n        protected boolean checkKeyIntent(int authUid, Bundle bundle) {\n            if (!checkKeyIntentParceledCorrectly(bundle)) {\n            \tEventLog.writeEvent(0x534e4554, \"250588548\", authUid, \"\");\n                return false;\n            }\n            Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT);\n            if (intent == null) {\n                return true;\n            }\n            // Explicitly set an empty ClipData to ensure that we don't offer to\n            // promote any Uris contained inside for granting purposes\n            if (intent.getClipData() == null) {\n                intent.setClipData(ClipData.newPlainText(null, null));\n            }\n            final long bid = Binder.clearCallingIdentity();\n            try {\n                PackageManager pm = mContext.getPackageManager();\n                ResolveInfo resolveInfo = pm.resolveActivityAsUser(intent, 0, mAccounts.userId);\n                if (resolveInfo == null) {\n                    return false;\n                }\n                if (\"content\".equals(intent.getScheme())) {\n                    return false;\n                }\n                ActivityInfo targetActivityInfo = resolveInfo.activityInfo;\n                int targetUid = targetActivityInfo.applicationInfo.uid;\n                PackageManagerInternal pmi = LocalServices.getService(PackageManagerInternal.class);\n                if (!isExportedSystemActivity(targetActivityInfo)\n                        && !pmi.hasSignatureCapability(\n                                targetUid, authUid,\n                                PackageParser.SigningDetails.CertCapabilities.AUTH)) {\n                    String pkgName = targetActivityInfo.packageName;\n                    String activityName = targetActivityInfo.name;\n                    String tmpl = \"KEY_INTENT resolved to an Activity (%s) in a package (%s) that \"\n                            + \"does not share a signature with the supplying authenticator (%s).\";\n                    Log.e(TAG, String.format(tmpl, activityName, pkgName, mAccountType));\n                    return false;\n                }\n                intent.setComponent(targetActivityInfo.getComponentName());\n                bundle.putParcelable(AccountManager.KEY_INTENT, intent);\n                return true;\n            } finally {\n                Binder.restoreCallingIdentity(bid);\n            }\n        }\n\n        /**\n         * Simulate the client side's deserialization of KEY_INTENT value, to make sure they don't\n         * violate our security policy.\n         *\n         * In particular we want to make sure the Authenticator doesn't trick users\n         * into launching arbitrary intents on the device via exploiting any other Parcel read/write\n         * mismatch problems.\n         */\n        private boolean checkKeyIntentParceledCorrectly(Bundle bundle) {\n            Parcel p = Parcel.obtain();\n            p.writeBundle(bundle);\n            p.setDataPosition(0);\n            Bundle simulateBundle = p.readBundle();\n            p.recycle();\n            Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT);\n            if (intent != null && intent.getClass() != Intent.class) {\n                return false;\n            }\n            Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT);\n            if (intent == null) {\n                return (simulateIntent == null);\n            }\n            if (!intent.filterEquals(simulateIntent)) {\n                return false;\n            }\n\n            if (intent.getSelector() != simulateIntent.getSelector()) {\n                return false;\n            }\n\n            int prohibitedFlags = Intent.FLAG_GRANT_READ_URI_PERMISSION\n                    | Intent.FLAG_GRANT_WRITE_URI_PERMISSION\n                    | Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION\n                    | Intent.FLAG_GRANT_PREFIX_URI_PERMISSION;\n            return (simulateIntent.getFlags() & prohibitedFlags) == 0;\n        }\n\n        private boolean isExportedSystemActivity(ActivityInfo activityInfo) {\n            String className = activityInfo.name;\n            return \"android\".equals(activityInfo.packageName) &&\n                    (GrantCredentialsPermissionActivity.class.getName().equals(className)\n                    || CantAddAccountActivity.class.getName().equals(className));\n        }\n\n        private void close() {\n            synchronized (mSessions) {\n                if (mSessions.remove(toString()) == null) {\n                    // the session was already closed, so bail out now\n                    return;\n                }\n            }\n            if (mResponse != null) {\n                // stop listening for response deaths\n                mResponse.asBinder().unlinkToDeath(this, 0 /* flags */);\n\n                // clear this so that we don't accidentally send any further results\n                mResponse = null;\n            }\n            cancelTimeout();\n            unbind();\n        }\n\n        @Override\n        public void binderDied() {\n            mResponse = null;\n            close();\n        }\n\n        protected String toDebugString() {\n            return toDebugString(SystemClock.elapsedRealtime());\n        }\n\n        protected String toDebugString(long now) {\n            return \"Session: expectLaunch \" + mExpectActivityLaunch\n                    + \", connected \" + (mAuthenticator != null)\n                    + \", stats (\" + mNumResults + \"/\" + mNumRequestContinued\n                    + \"/\" + mNumErrors + \")\"\n                    + \", lifetime \" + ((now - mCreationTime) / 1000.0);\n        }\n\n        void bind() {\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"initiating bind to authenticator type \" + mAccountType);\n            }\n            if (!bindToAuthenticator(mAccountType)) {\n                Log.d(TAG, \"bind attempt failed for \" + toDebugString());\n                onError(AccountManager.ERROR_CODE_REMOTE_EXCEPTION, \"bind failure\");\n            }\n        }\n\n        private void unbind() {\n            if (mAuthenticator != null) {\n                mAuthenticator = null;\n                mContext.unbindService(this);\n            }\n        }\n\n        private void scheduleTimeout() {\n            mHandler.sendMessageDelayed(\n                    mHandler.obtainMessage(MESSAGE_TIMED_OUT, this), TIMEOUT_DELAY_MS);\n        }\n\n        public void cancelTimeout() {\n            mHandler.removeMessages(MESSAGE_TIMED_OUT, this);\n        }\n\n        @Override\n        public void onServiceConnected(ComponentName name, IBinder service) {\n            mAuthenticator = IAccountAuthenticator.Stub.asInterface(service);\n            try {\n                run();\n            } catch (RemoteException e) {\n                onError(AccountManager.ERROR_CODE_REMOTE_EXCEPTION,\n                        \"remote exception\");\n            }\n        }\n\n        @Override\n        public void onServiceDisconnected(ComponentName name) {\n            mAuthenticator = null;\n            IAccountManagerResponse response = getResponseAndClose();\n            if (response != null) {\n                try {\n                    response.onError(AccountManager.ERROR_CODE_REMOTE_EXCEPTION,\n                            \"disconnected\");\n                } catch (RemoteException e) {\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, \"Session.onServiceDisconnected: \"\n                                + \"caught RemoteException while responding\", e);\n                    }\n                }\n            }\n        }\n\n        public abstract void run() throws RemoteException;\n\n        public void onTimedOut() {\n            IAccountManagerResponse response = getResponseAndClose();\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"Session.onTimedOut\");\n            }\n            if (response != null) {\n                try {\n                    response.onError(AccountManager.ERROR_CODE_REMOTE_EXCEPTION,\n                            \"timeout\");\n                } catch (RemoteException e) {\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, \"Session.onTimedOut: caught RemoteException while responding\",\n                                e);\n                    }\n                }\n            }\n        }\n\n        @Override\n        public void onResult(Bundle result) {\n            Bundle.setDefusable(result, true);\n            mNumResults++;\n            Intent intent = null;\n            if (result != null) {\n                boolean isSuccessfulConfirmCreds = result.getBoolean(\n                        AccountManager.KEY_BOOLEAN_RESULT, false);\n                boolean isSuccessfulUpdateCredsOrAddAccount =\n                        result.containsKey(AccountManager.KEY_ACCOUNT_NAME)\n                        && result.containsKey(AccountManager.KEY_ACCOUNT_TYPE);\n                // We should only update lastAuthenticated time, if\n                // mUpdateLastAuthenticatedTime is true and the confirmRequest\n                // or updateRequest was successful\n                boolean needUpdate = mUpdateLastAuthenticatedTime\n                        && (isSuccessfulConfirmCreds || isSuccessfulUpdateCredsOrAddAccount);\n                if (needUpdate || mAuthDetailsRequired) {\n                    boolean accountPresent = isAccountPresentForCaller(mAccountName, mAccountType);\n                    if (needUpdate && accountPresent) {\n                        updateLastAuthenticatedTime(new Account(mAccountName, mAccountType));\n                    }\n                    if (mAuthDetailsRequired) {\n                        long lastAuthenticatedTime = -1;\n                        if (accountPresent) {\n                            lastAuthenticatedTime = mAccounts.accountsDb\n                                    .findAccountLastAuthenticatedTime(\n                                            new Account(mAccountName, mAccountType));\n                        }\n                        result.putLong(AccountManager.KEY_LAST_AUTHENTICATED_TIME,\n                                lastAuthenticatedTime);\n                    }\n                }\n            }\n            if (result != null) {\n                if (!checkKeyIntent(\n                        Binder.getCallingUid(),\n                        result)) {\n                    onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                            \"invalid intent in bundle returned\");\n                    return;\n                }\n            }\n            if (result != null\n                    && !TextUtils.isEmpty(result.getString(AccountManager.KEY_AUTHTOKEN))) {\n                String accountName = result.getString(AccountManager.KEY_ACCOUNT_NAME);\n                String accountType = result.getString(AccountManager.KEY_ACCOUNT_TYPE);\n                if (!TextUtils.isEmpty(accountName) && !TextUtils.isEmpty(accountType)) {\n                    Account account = new Account(accountName, accountType);\n                    cancelNotification(getSigninRequiredNotificationId(mAccounts, account),\n                            new UserHandle(mAccounts.userId));\n                }\n            }\n            IAccountManagerResponse response;\n            if (mExpectActivityLaunch && result != null\n                    && result.containsKey(AccountManager.KEY_INTENT)) {\n                response = mResponse;\n            } else {\n                response = getResponseAndClose();\n            }\n            if (response != null) {\n                try {\n                    if (result == null) {\n                        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                            Log.v(TAG, getClass().getSimpleName()\n                                    + \" calling onError() on response \" + response);\n                        }\n                        response.onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                                \"null bundle returned\");\n                    } else {\n                        if (mStripAuthTokenFromResult) {\n                            result.remove(AccountManager.KEY_AUTHTOKEN);\n                            if (!checkKeyIntent(Binder.getCallingUid(), result)) {\n                                onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                                        \"invalid intent in bundle returned\");\n                                return;\n                            }\n                        }\n                        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                            Log.v(TAG, getClass().getSimpleName()\n                                    + \" calling onResult() on response \" + response);\n                        }\n                        if ((result.getInt(AccountManager.KEY_ERROR_CODE, -1) > 0) &&\n                                (intent == null)) {\n                            // All AccountManager error codes are greater than 0\n                            response.onError(result.getInt(AccountManager.KEY_ERROR_CODE),\n                                    result.getString(AccountManager.KEY_ERROR_MESSAGE));\n                        } else {\n                            response.onResult(result);\n                        }\n                    }\n                } catch (RemoteException e) {\n                    // if the caller is dead then there is no one to care about remote exceptions\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, \"failure while notifying response\", e);\n                    }\n                }\n            }\n        }\n\n        @Override\n        public void onRequestContinued() {\n            mNumRequestContinued++;\n        }\n\n        @Override\n        public void onError(int errorCode, String errorMessage) {\n            mNumErrors++;\n            IAccountManagerResponse response = getResponseAndClose();\n            if (response != null) {\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.v(TAG, getClass().getSimpleName()\n                            + \" calling onError() on response \" + response);\n                }\n                try {\n                    response.onError(errorCode, errorMessage);\n                } catch (RemoteException e) {\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, \"Session.onError: caught RemoteException while responding\", e);\n                    }\n                }\n            } else {\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.v(TAG, \"Session.onError: already closed\");\n                }\n            }\n        }\n\n        /**\n         * find the component name for the authenticator and initiate a bind\n         * if no authenticator or the bind fails then return false, otherwise return true\n         */\n        private boolean bindToAuthenticator(String authenticatorType) {\n            final AccountAuthenticatorCache.ServiceInfo<AuthenticatorDescription> authenticatorInfo;\n            authenticatorInfo = mAuthenticatorCache.getServiceInfo(\n                    AuthenticatorDescription.newKey(authenticatorType), mAccounts.userId);\n            if (authenticatorInfo == null) {\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.v(TAG, \"there is no authenticator for \" + authenticatorType\n                            + \", bailing out\");\n                }\n                return false;\n            }\n\n            if (!isLocalUnlockedUser(mAccounts.userId)\n                    && !authenticatorInfo.componentInfo.directBootAware) {\n                Slog.w(TAG, \"Blocking binding to authenticator \" + authenticatorInfo.componentName\n                        + \" which isn't encryption aware\");\n                return false;\n            }\n\n            Intent intent = new Intent();\n            intent.setAction(AccountManager.ACTION_AUTHENTICATOR_INTENT);\n            intent.setComponent(authenticatorInfo.componentName);\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"performing bindService to \" + authenticatorInfo.componentName);\n            }\n            int flags = Context.BIND_AUTO_CREATE;\n            if (mAuthenticatorCache.getBindInstantServiceAllowed(mAccounts.userId)) {\n                flags |= Context.BIND_ALLOW_INSTANT;\n            }\n            if (!mContext.bindServiceAsUser(intent, this, flags, UserHandle.of(mAccounts.userId))) {\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.v(TAG, \"bindService to \" + authenticatorInfo.componentName + \" failed\");\n                }\n                return false;\n            }\n\n            return true;\n        }\n    }\n\n    class MessageHandler extends Handler {\n        MessageHandler(Looper looper) {\n            super(looper);\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MESSAGE_TIMED_OUT:\n                    Session session = (Session)msg.obj;\n                    session.onTimedOut();\n                    break;\n\n                case MESSAGE_COPY_SHARED_ACCOUNT:\n                    copyAccountToUser(/*no response*/ null, (Account) msg.obj, msg.arg1, msg.arg2);\n                    break;\n\n                default:\n                    throw new IllegalStateException(\"unhandled message: \" + msg.what);\n            }\n        }\n    }\n\n    private void logRecord(UserAccounts accounts, String action, String tableName) {\n        logRecord(action, tableName, -1, accounts);\n    }\n\n    private void logRecordWithUid(UserAccounts accounts, String action, String tableName, int uid) {\n        logRecord(action, tableName, -1, accounts, uid);\n    }\n\n    /*\n     * This function receives an opened writable database.\n     */\n    private void logRecord(String action, String tableName, long accountId,\n            UserAccounts userAccount) {\n        logRecord(action, tableName, accountId, userAccount, getCallingUid());\n    }\n\n    /*\n     * This function receives an opened writable database and writes to it in a separate thread.\n     */\n    private void logRecord(String action, String tableName, long accountId,\n            UserAccounts userAccount, int callingUid) {\n\n        class LogRecordTask implements Runnable {\n            private final String action;\n            private final String tableName;\n            private final long accountId;\n            private final UserAccounts userAccount;\n            private final int callingUid;\n            private final long userDebugDbInsertionPoint;\n\n            LogRecordTask(final String action,\n                    final String tableName,\n                    final long accountId,\n                    final UserAccounts userAccount,\n                    final int callingUid,\n                    final long userDebugDbInsertionPoint) {\n                this.action = action;\n                this.tableName = tableName;\n                this.accountId = accountId;\n                this.userAccount = userAccount;\n                this.callingUid = callingUid;\n                this.userDebugDbInsertionPoint = userDebugDbInsertionPoint;\n            }\n\n            @Override\n            public void run() {\n                synchronized (userAccount.accountsDb.mDebugStatementLock) {\n                    SQLiteStatement logStatement = userAccount.accountsDb.getStatementForLogging();\n                    if (logStatement == null) {\n                        return; // Can't log.\n                    }\n                    logStatement.bindLong(1, accountId);\n                    logStatement.bindString(2, action);\n                    logStatement.bindString(3, mDateFormat.format(new Date()));\n                    logStatement.bindLong(4, callingUid);\n                    logStatement.bindString(5, tableName);\n                    logStatement.bindLong(6, userDebugDbInsertionPoint);\n                    try {\n                        logStatement.execute();\n                    } catch (IllegalStateException e) {\n                        // Guard against crash, DB can already be closed\n                        // since this statement is executed on a handler thread\n                        Slog.w(TAG, \"Failed to insert a log record. accountId=\" + accountId\n                                + \" action=\" + action + \" tableName=\" + tableName + \" Error: \" + e);\n                    } finally {\n                        logStatement.clearBindings();\n                    }\n                }\n            }\n        }\n        long insertionPoint = userAccount.accountsDb.reserveDebugDbInsertionPoint();\n        if (insertionPoint != -1) {\n            LogRecordTask logTask = new LogRecordTask(action, tableName, accountId, userAccount,\n                    callingUid, insertionPoint);\n            mHandler.post(logTask);\n        }\n    }\n\n    public IBinder onBind(@SuppressWarnings(\"unused\") Intent intent) {\n        return asBinder();\n    }\n\n    /**\n     * Searches array of arguments for the specified string\n     * @param args array of argument strings\n     * @param value value to search for\n     * @return true if the value is contained in the array\n     */\n    private static boolean scanArgs(String[] args, String value) {\n        if (args != null) {\n            for (String arg : args) {\n                if (value.equals(arg)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    @Override\n    protected void dump(FileDescriptor fd, PrintWriter fout, String[] args) {\n        if (!DumpUtils.checkDumpPermission(mContext, TAG, fout)) return;\n        final boolean isCheckinRequest = scanArgs(args, \"--checkin\") || scanArgs(args, \"-c\");\n        final IndentingPrintWriter ipw = new IndentingPrintWriter(fout, \"  \");\n\n        final List<UserInfo> users = getUserManager().getUsers();\n        for (UserInfo user : users) {\n            ipw.println(\"User \" + user + \":\");\n            ipw.increaseIndent();\n            dumpUser(getUserAccounts(user.id), fd, ipw, args, isCheckinRequest);\n            ipw.println();\n            ipw.decreaseIndent();\n        }\n    }\n\n    private void dumpUser(UserAccounts userAccounts, FileDescriptor fd, PrintWriter fout,\n            String[] args, boolean isCheckinRequest) {\n        if (isCheckinRequest) {\n            // This is a checkin request. *Only* upload the account types and the count of\n            // each.\n            synchronized (userAccounts.dbLock) {\n                userAccounts.accountsDb.dumpDeAccountsTable(fout);\n            }\n        } else {\n            Account[] accounts = getAccountsFromCache(userAccounts, null /* type */,\n                    Process.SYSTEM_UID, null /* packageName */, false);\n            fout.println(\"Accounts: \" + accounts.length);\n            for (Account account : accounts) {\n                fout.println(\"  \" + account.toString());\n            }\n\n            // Add debug information.\n            fout.println();\n            synchronized (userAccounts.dbLock) {\n                userAccounts.accountsDb.dumpDebugTable(fout);\n            }\n            fout.println();\n            synchronized (mSessions) {\n                final long now = SystemClock.elapsedRealtime();\n                fout.println(\"Active Sessions: \" + mSessions.size());\n                for (Session session : mSessions.values()) {\n                    fout.println(\"  \" + session.toDebugString(now));\n                }\n            }\n\n            fout.println();\n            mAuthenticatorCache.dump(fd, fout, args, userAccounts.userId);\n\n            boolean isUserUnlocked;\n            synchronized (mUsers) {\n                isUserUnlocked = isLocalUnlockedUser(userAccounts.userId);\n            }\n            // Following logs are printed only when user is unlocked.\n            if (!isUserUnlocked) {\n                return;\n            }\n            fout.println();\n            synchronized (userAccounts.dbLock) {\n                Map<Account, Map<String, Integer>> allVisibilityValues =\n                        userAccounts.accountsDb.findAllVisibilityValues();\n                fout.println(\"Account visibility:\");\n                for (Account account : allVisibilityValues.keySet()) {\n                    fout.println(\"  \" + account.name);\n                    Map<String, Integer> visibilities = allVisibilityValues.get(account);\n                    for (Entry<String, Integer> entry : visibilities.entrySet()) {\n                        fout.println(\"    \" + entry.getKey() + \", \" + entry.getValue());\n                    }\n                }\n            }\n        }\n    }\n\n    private void doNotification(UserAccounts accounts, Account account, CharSequence message,\n            Intent intent, String packageName, final int userId) {\n        final long identityToken = clearCallingIdentity();\n        try {\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"doNotification: \" + message + \" intent:\" + intent);\n            }\n\n            if (intent.getComponent() != null &&\n                    GrantCredentialsPermissionActivity.class.getName().equals(\n                            intent.getComponent().getClassName())) {\n                createNoCredentialsPermissionNotification(account, intent, packageName, userId);\n            } else {\n                Context contextForUser = getContextForUser(new UserHandle(userId));\n                final NotificationId id = getSigninRequiredNotificationId(accounts, account);\n                intent.addCategory(id.mTag);\n\n                final String notificationTitleFormat =\n                        contextForUser.getText(R.string.notification_title).toString();\n                Notification n =\n                        new Notification.Builder(contextForUser, SystemNotificationChannels.ACCOUNT)\n                        .setWhen(0)\n                        .setSmallIcon(android.R.drawable.stat_sys_warning)\n                        .setColor(contextForUser.getColor(\n                                com.android.internal.R.color.system_notification_accent_color))\n                        .setContentTitle(String.format(notificationTitleFormat, account.name))\n                        .setContentText(message)\n                        .setContentIntent(PendingIntent.getActivityAsUser(\n                                mContext, 0, intent,\n                                PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_IMMUTABLE,\n                                null, new UserHandle(userId)))\n                        .build();\n                installNotification(id, n, packageName, userId);\n            }\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private void installNotification(NotificationId id, final Notification notification,\n            String packageName, int userId) {\n        final long token = clearCallingIdentity();\n        try {\n            INotificationManager notificationManager = mInjector.getNotificationManager();\n            try {\n                // The calling uid must match either the package or op package, so use an op\n                // package that matches the cleared calling identity.\n                notificationManager.enqueueNotificationWithTag(packageName, \"android\",\n                        id.mTag, id.mId, notification, userId);\n            } catch (RemoteException e) {\n                /* ignore - local call */\n            }\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private void cancelNotification(NotificationId id, UserHandle user) {\n        cancelNotification(id, mContext.getPackageName(), user);\n    }\n\n    private void cancelNotification(NotificationId id, String packageName, UserHandle user) {\n        final long identityToken = clearCallingIdentity();\n        try {\n            INotificationManager service = mInjector.getNotificationManager();\n            service.cancelNotificationWithTag(\n                    packageName, \"android\", id.mTag, id.mId, user.getIdentifier());\n        } catch (RemoteException e) {\n            /* ignore - local call */\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private boolean isPermittedForPackage(String packageName, int userId, String... permissions) {\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            final int uid = mPackageManager.getPackageUidAsUser(packageName, userId);\n            IPackageManager pm = ActivityThread.getPackageManager();\n            for (String perm : permissions) {\n                if (pm.checkPermission(perm, packageName, userId)\n                        == PackageManager.PERMISSION_GRANTED) {\n                    // Checks runtime permission revocation.\n                    final int opCode = AppOpsManager.permissionToOpCode(perm);\n                    if (opCode == AppOpsManager.OP_NONE || mAppOpsManager.checkOpNoThrow(\n                            opCode, uid, packageName) == AppOpsManager.MODE_ALLOWED) {\n                        return true;\n                    }\n                }\n            }\n        } catch (NameNotFoundException | RemoteException e) {\n            // Assume permission is not granted if an error accrued.\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n        return false;\n    }\n\n    /**\n     * Checks that package has at least one of given permissions and makes note of app\n     * performing the action.\n     */\n    private boolean checkPermissionAndNote(String opPackageName, int callingUid,\n            String... permissions) {\n        for (String perm : permissions) {\n            if (mContext.checkCallingOrSelfPermission(perm) == PackageManager.PERMISSION_GRANTED) {\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.v(TAG, \"  caller uid \" + callingUid + \" has \" + perm);\n                }\n                final int opCode = AppOpsManager.permissionToOpCode(perm);\n                if (opCode == AppOpsManager.OP_NONE || mAppOpsManager.noteOpNoThrow(\n                        opCode, callingUid, opPackageName) == AppOpsManager.MODE_ALLOWED) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private int handleIncomingUser(int userId) {\n        try {\n            return ActivityManager.getService().handleIncomingUser(\n                    Binder.getCallingPid(), Binder.getCallingUid(), userId, true, true, \"\", null);\n        } catch (RemoteException re) {\n            // Shouldn't happen, local.\n        }\n        return userId;\n    }\n\n    private boolean isPrivileged(int callingUid) {\n        String[] packages;\n        final long identityToken = Binder.clearCallingIdentity();\n        try {\n            packages = mPackageManager.getPackagesForUid(callingUid);\n            if (packages == null) {\n                Log.d(TAG, \"No packages for callingUid \" + callingUid);\n                return false;\n            }\n            for (String name : packages) {\n                try {\n                    PackageInfo packageInfo =\n                        mPackageManager.getPackageInfo(name, 0 /* flags */);\n                    if (packageInfo != null\n                        && (packageInfo.applicationInfo.privateFlags\n                            & ApplicationInfo.PRIVATE_FLAG_PRIVILEGED) != 0) {\n                        return true;\n                    }\n                } catch (PackageManager.NameNotFoundException e) {\n                    Log.d(TAG, \"Package not found \" + e.getMessage());\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identityToken);\n        }\n        return false;\n    }\n\n    private boolean permissionIsGranted(\n            Account account, String authTokenType, int callerUid, int userId) {\n        if (UserHandle.getAppId(callerUid) == Process.SYSTEM_UID) {\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"Access to \" + account + \" granted calling uid is system\");\n            }\n            return true;\n        }\n\n        if (isPrivileged(callerUid)) {\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"Access to \" + account + \" granted calling uid \"\n                        + callerUid + \" privileged\");\n            }\n            return true;\n        }\n        if (account != null && isAccountManagedByCaller(account.type, callerUid, userId)) {\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"Access to \" + account + \" granted calling uid \"\n                        + callerUid + \" manages the account\");\n            }\n            return true;\n        }\n        if (account != null && hasExplicitlyGrantedPermission(account, authTokenType, callerUid)) {\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"Access to \" + account + \" granted calling uid \"\n                        + callerUid + \" user granted access\");\n            }\n            return true;\n        }\n\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"Access to \" + account + \" not granted for uid \" + callerUid);\n        }\n\n        return false;\n    }\n\n    private boolean isAccountVisibleToCaller(String accountType, int callingUid, int userId,\n            String opPackageName) {\n        if (accountType == null) {\n            return false;\n        } else {\n            return getTypesVisibleToCaller(callingUid, userId,\n                    opPackageName).contains(accountType);\n        }\n    }\n\n    // Method checks visibility for applications targeing API level below {@link\n    // android.os.Build.VERSION_CODES#O},\n    // returns true if the the app has GET_ACCOUNTS or GET_ACCOUNTS_PRIVILEGED permission.\n    private boolean checkGetAccountsPermission(String packageName, int userId) {\n        return isPermittedForPackage(packageName, userId, Manifest.permission.GET_ACCOUNTS,\n                Manifest.permission.GET_ACCOUNTS_PRIVILEGED);\n    }\n\n    private boolean checkReadContactsPermission(String packageName, int userId) {\n        return isPermittedForPackage(packageName, userId, Manifest.permission.READ_CONTACTS);\n    }\n\n    // Heuristic to check that account type may be associated with some contacts data and\n    // therefore READ_CONTACTS permission grants the access to account by default.\n    private boolean accountTypeManagesContacts(String accountType, int userId) {\n        if (accountType == null) {\n            return false;\n        }\n        final long identityToken = Binder.clearCallingIdentity();\n        Collection<RegisteredServicesCache.ServiceInfo<AuthenticatorDescription>> serviceInfos;\n        try {\n            serviceInfos = mAuthenticatorCache.getAllServices(userId);\n        } finally {\n            Binder.restoreCallingIdentity(identityToken);\n        }\n        // Check contacts related permissions for authenticator.\n        for (RegisteredServicesCache.ServiceInfo<AuthenticatorDescription> serviceInfo\n                : serviceInfos) {\n            if (accountType.equals(serviceInfo.type.type)) {\n                return isPermittedForPackage(serviceInfo.type.packageName, userId,\n                    Manifest.permission.WRITE_CONTACTS);\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Method checks package uid and signature with Authenticator which manages accountType.\n     *\n     * @return SIGNATURE_CHECK_UID_MATCH for uid match, SIGNATURE_CHECK_MATCH for signature match,\n     *         SIGNATURE_CHECK_MISMATCH otherwise.\n     */\n    private int checkPackageSignature(String accountType, int callingUid, int userId) {\n        if (accountType == null) {\n            return SIGNATURE_CHECK_MISMATCH;\n        }\n\n        final long identityToken = Binder.clearCallingIdentity();\n        Collection<RegisteredServicesCache.ServiceInfo<AuthenticatorDescription>> serviceInfos;\n        try {\n            serviceInfos = mAuthenticatorCache.getAllServices(userId);\n        } finally {\n            Binder.restoreCallingIdentity(identityToken);\n        }\n        // Check for signature match with Authenticator.LocalServices.getService(PackageManagerInternal.class);\n        PackageManagerInternal pmi = LocalServices.getService(PackageManagerInternal.class);\n        for (RegisteredServicesCache.ServiceInfo<AuthenticatorDescription> serviceInfo\n                : serviceInfos) {\n            if (accountType.equals(serviceInfo.type.type)) {\n                if (serviceInfo.uid == callingUid) {\n                    return SIGNATURE_CHECK_UID_MATCH;\n                }\n                if (pmi.hasSignatureCapability(\n                        serviceInfo.uid, callingUid,\n                        PackageParser.SigningDetails.CertCapabilities.AUTH)) {\n                    return SIGNATURE_CHECK_MATCH;\n                }\n            }\n        }\n        return SIGNATURE_CHECK_MISMATCH;\n    }\n\n    // returns true for applications with the same signature as authenticator.\n    private boolean isAccountManagedByCaller(String accountType, int callingUid, int userId) {\n        if (accountType == null) {\n            return false;\n        } else {\n            return getTypesManagedByCaller(callingUid, userId).contains(accountType);\n        }\n    }\n\n    private List<String> getTypesVisibleToCaller(int callingUid, int userId,\n            String opPackageName) {\n        return getTypesForCaller(callingUid, userId, true /* isOtherwisePermitted*/);\n    }\n\n    private List<String> getTypesManagedByCaller(int callingUid, int userId) {\n        return getTypesForCaller(callingUid, userId, false);\n    }\n\n    private List<String> getTypesForCaller(\n            int callingUid, int userId, boolean isOtherwisePermitted) {\n        List<String> managedAccountTypes = new ArrayList<>();\n        final long identityToken = Binder.clearCallingIdentity();\n        Collection<RegisteredServicesCache.ServiceInfo<AuthenticatorDescription>> serviceInfos;\n        try {\n            serviceInfos = mAuthenticatorCache.getAllServices(userId);\n        } finally {\n            Binder.restoreCallingIdentity(identityToken);\n        }\n\n        PackageManagerInternal pmi = LocalServices.getService(PackageManagerInternal.class);\n        for (RegisteredServicesCache.ServiceInfo<AuthenticatorDescription> serviceInfo :\n                serviceInfos) {\n            if (isOtherwisePermitted || pmi.hasSignatureCapability(\n                    serviceInfo.uid, callingUid,\n                    PackageParser.SigningDetails.CertCapabilities.AUTH)) {\n                managedAccountTypes.add(serviceInfo.type.type);\n            }\n        }\n        return managedAccountTypes;\n    }\n\n    private boolean isAccountPresentForCaller(String accountName, String accountType) {\n        if (getUserAccountsForCaller().accountCache.containsKey(accountType)) {\n            for (Account account : getUserAccountsForCaller().accountCache.get(accountType)) {\n                if (account.name.equals(accountName)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private static void checkManageUsersPermission(String message) {\n        if (ActivityManager.checkComponentPermission(\n                android.Manifest.permission.MANAGE_USERS, Binder.getCallingUid(), -1, true)\n                != PackageManager.PERMISSION_GRANTED) {\n            throw new SecurityException(\"You need MANAGE_USERS permission to: \" + message);\n        }\n    }\n\n    private static void checkManageOrCreateUsersPermission(String message) {\n        if (ActivityManager.checkComponentPermission(android.Manifest.permission.MANAGE_USERS,\n                Binder.getCallingUid(), -1, true) != PackageManager.PERMISSION_GRANTED &&\n                ActivityManager.checkComponentPermission(android.Manifest.permission.CREATE_USERS,\n                        Binder.getCallingUid(), -1, true) != PackageManager.PERMISSION_GRANTED) {\n            throw new SecurityException(\"You need MANAGE_USERS or CREATE_USERS permission to: \"\n                    + message);\n        }\n    }\n\n    private boolean hasExplicitlyGrantedPermission(Account account, String authTokenType,\n            int callerUid) {\n        if (UserHandle.getAppId(callerUid) == Process.SYSTEM_UID) {\n            return true;\n        }\n        UserAccounts accounts = getUserAccounts(UserHandle.getUserId(callerUid));\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                long grantsCount;\n                if (authTokenType != null) {\n                    grantsCount = accounts.accountsDb\n                            .findMatchingGrantsCount(callerUid, authTokenType, account);\n                } else {\n                    grantsCount = accounts.accountsDb.findMatchingGrantsCountAnyToken(callerUid,\n                            account);\n                }\n                final boolean permissionGranted = grantsCount > 0;\n\n                if (!permissionGranted && ActivityManager.isRunningInTestHarness()) {\n                    // TODO: Skip this check when running automated tests. Replace this\n                    // with a more general solution.\n                    Log.d(TAG, \"no credentials permission for usage of \"\n                            + account.toSafeString() + \", \"\n                            + authTokenType + \" by uid \" + callerUid\n                            + \" but ignoring since device is in test harness.\");\n                    return true;\n                }\n                return permissionGranted;\n            }\n        }\n    }\n\n    private boolean isSystemUid(int callingUid) {\n        String[] packages = null;\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            packages = mPackageManager.getPackagesForUid(callingUid);\n            if (packages != null) {\n                for (String name : packages) {\n                    try {\n                        PackageInfo packageInfo =\n                                mPackageManager.getPackageInfo(name, 0 /* flags */);\n                        if (packageInfo != null\n                                && (packageInfo.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM)\n                                != 0) {\n                            return true;\n                        }\n                    } catch (NameNotFoundException e) {\n                        Log.w(TAG, String.format(\"Could not find package [%s]\", name), e);\n                    }\n                }\n            } else {\n                Log.w(TAG, \"No known packages with uid \" + callingUid);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n        return false;\n    }\n\n    /** Succeeds if any of the specified permissions are granted. */\n    private void checkReadAccountsPermitted(\n            int callingUid,\n            String accountType,\n            int userId,\n            String opPackageName) {\n        if (!isAccountVisibleToCaller(accountType, callingUid, userId, opPackageName)) {\n            String msg = String.format(\n                    \"caller uid %s cannot access %s accounts\",\n                    callingUid,\n                    accountType);\n            Log.w(TAG, \"  \" + msg);\n            throw new SecurityException(msg);\n        }\n    }\n\n    private boolean canUserModifyAccounts(int userId, int callingUid) {\n        // the managing app can always modify accounts\n        if (isProfileOwner(callingUid)) {\n            return true;\n        }\n        if (getUserManager().getUserRestrictions(new UserHandle(userId))\n                .getBoolean(UserManager.DISALLOW_MODIFY_ACCOUNTS)) {\n            return false;\n        }\n        return true;\n    }\n\n    private boolean canUserModifyAccountsForType(int userId, String accountType, int callingUid) {\n        // the managing app can always modify accounts\n        if (isProfileOwner(callingUid)) {\n            return true;\n        }\n        DevicePolicyManager dpm = (DevicePolicyManager) mContext\n                .getSystemService(Context.DEVICE_POLICY_SERVICE);\n        String[] typesArray = dpm.getAccountTypesWithManagementDisabledAsUser(userId);\n        if (typesArray == null) {\n            return true;\n        }\n        for (String forbiddenType : typesArray) {\n            if (forbiddenType.equals(accountType)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private boolean isProfileOwner(int uid) {\n        final DevicePolicyManagerInternal dpmi =\n                LocalServices.getService(DevicePolicyManagerInternal.class);\n        //TODO(b/169395065) Figure out if this flow makes sense in Device Owner mode.\n        return (dpmi != null) && (dpmi.isActiveProfileOwner(uid) || dpmi.isActiveDeviceOwner(uid));\n    }\n\n    @Override\n    public void updateAppPermission(Account account, String authTokenType, int uid, boolean value)\n            throws RemoteException {\n        final int callingUid = getCallingUid();\n\n        if (UserHandle.getAppId(callingUid) != Process.SYSTEM_UID) {\n            throw new SecurityException();\n        }\n\n        if (value) {\n            grantAppPermission(account, authTokenType, uid);\n        } else {\n            revokeAppPermission(account, authTokenType, uid);\n        }\n    }\n\n    /**\n     * Allow callers with the given uid permission to get credentials for account/authTokenType.\n     * <p>\n     * Although this is public it can only be accessed via the AccountManagerService object\n     * which is in the system. This means we don't need to protect it with permissions.\n     * @hide\n     */\n    void grantAppPermission(Account account, String authTokenType, int uid) {\n        if (account == null || authTokenType == null) {\n            Log.e(TAG, \"grantAppPermission: called with invalid arguments\", new Exception());\n            return;\n        }\n        UserAccounts accounts = getUserAccounts(UserHandle.getUserId(uid));\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                long accountId = accounts.accountsDb.findDeAccountId(account);\n                if (accountId >= 0) {\n                    accounts.accountsDb.insertGrant(accountId, authTokenType, uid);\n                }\n                cancelNotification(\n                        getCredentialPermissionNotificationId(account, authTokenType, uid),\n                        UserHandle.of(accounts.userId));\n\n                cancelAccountAccessRequestNotificationIfNeeded(account, uid, true);\n            }\n        }\n\n        // Listeners are a final CopyOnWriteArrayList, hence no lock needed.\n        for (AccountManagerInternal.OnAppPermissionChangeListener listener\n                : mAppPermissionChangeListeners) {\n            mHandler.post(() -> listener.onAppPermissionChanged(account, uid));\n        }\n    }\n\n    /**\n     * Don't allow callers with the given uid permission to get credentials for\n     * account/authTokenType.\n     * <p>\n     * Although this is public it can only be accessed via the AccountManagerService object\n     * which is in the system. This means we don't need to protect it with permissions.\n     * @hide\n     */\n    private void revokeAppPermission(Account account, String authTokenType, int uid) {\n        if (account == null || authTokenType == null) {\n            Log.e(TAG, \"revokeAppPermission: called with invalid arguments\", new Exception());\n            return;\n        }\n        UserAccounts accounts = getUserAccounts(UserHandle.getUserId(uid));\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                accounts.accountsDb.beginTransaction();\n                try {\n                    long accountId = accounts.accountsDb.findDeAccountId(account);\n                    if (accountId >= 0) {\n                        accounts.accountsDb.deleteGrantsByAccountIdAuthTokenTypeAndUid(\n                                accountId, authTokenType, uid);\n                        accounts.accountsDb.setTransactionSuccessful();\n                    }\n                } finally {\n                    accounts.accountsDb.endTransaction();\n                }\n\n                cancelNotification(\n                        getCredentialPermissionNotificationId(account, authTokenType, uid),\n                        UserHandle.of(accounts.userId));\n            }\n        }\n\n        // Listeners are a final CopyOnWriteArrayList, hence no lock needed.\n        for (AccountManagerInternal.OnAppPermissionChangeListener listener\n                : mAppPermissionChangeListeners) {\n            mHandler.post(() -> listener.onAppPermissionChanged(account, uid));\n        }\n    }\n\n    private void removeAccountFromCacheLocked(UserAccounts accounts, Account account) {\n        final Account[] oldAccountsForType = accounts.accountCache.get(account.type);\n        if (oldAccountsForType != null) {\n            ArrayList<Account> newAccountsList = new ArrayList<>();\n            for (Account curAccount : oldAccountsForType) {\n                if (!curAccount.equals(account)) {\n                    newAccountsList.add(curAccount);\n                }\n            }\n            if (newAccountsList.isEmpty()) {\n                accounts.accountCache.remove(account.type);\n            } else {\n                Account[] newAccountsForType = new Account[newAccountsList.size()];\n                newAccountsForType = newAccountsList.toArray(newAccountsForType);\n                accounts.accountCache.put(account.type, newAccountsForType);\n            }\n        }\n        accounts.userDataCache.remove(account);\n        accounts.authTokenCache.remove(account);\n        accounts.previousNameCache.remove(account);\n        accounts.visibilityCache.remove(account);\n\n        AccountManager.invalidateLocalAccountsDataCaches();\n    }\n\n    /**\n     * This assumes that the caller has already checked that the account is not already present.\n     * IMPORTANT: The account being inserted will begin to be tracked for access in remote\n     * processes and if you will return this account to apps you should return the result.\n     * @return The inserted account which is a new instance that is being tracked.\n     */\n    private Account insertAccountIntoCacheLocked(UserAccounts accounts, Account account) {\n        Account[] accountsForType = accounts.accountCache.get(account.type);\n        int oldLength = (accountsForType != null) ? accountsForType.length : 0;\n        Account[] newAccountsForType = new Account[oldLength + 1];\n        if (accountsForType != null) {\n            System.arraycopy(accountsForType, 0, newAccountsForType, 0, oldLength);\n        }\n        String token = account.getAccessId() != null ? account.getAccessId()\n                : UUID.randomUUID().toString();\n        newAccountsForType[oldLength] = new Account(account, token);\n        accounts.accountCache.put(account.type, newAccountsForType);\n        AccountManager.invalidateLocalAccountsDataCaches();\n        return newAccountsForType[oldLength];\n    }\n\n    @NonNull\n    private Account[] filterAccounts(UserAccounts accounts, Account[] unfiltered, int callingUid,\n            @Nullable String callingPackage, boolean includeManagedNotVisible) {\n        String visibilityFilterPackage = callingPackage;\n        if (visibilityFilterPackage == null) {\n            visibilityFilterPackage = getPackageNameForUid(callingUid);\n        }\n        Map<Account, Integer> firstPass = new LinkedHashMap<>();\n        for (Account account : unfiltered) {\n            int visibility = resolveAccountVisibility(account, visibilityFilterPackage, accounts);\n            if ((visibility == AccountManager.VISIBILITY_VISIBLE\n                    || visibility == AccountManager.VISIBILITY_USER_MANAGED_VISIBLE)\n                    || (includeManagedNotVisible\n                            && (visibility\n                                    == AccountManager.VISIBILITY_USER_MANAGED_NOT_VISIBLE))) {\n                firstPass.put(account, visibility);\n            }\n        }\n        Map<Account, Integer> secondPass =\n                filterSharedAccounts(accounts, firstPass, callingUid, callingPackage);\n\n        Account[] filtered = new Account[secondPass.size()];\n        filtered = secondPass.keySet().toArray(filtered);\n        return filtered;\n    }\n\n    @NonNull\n    private Map<Account, Integer> filterSharedAccounts(UserAccounts userAccounts,\n            @NonNull Map<Account, Integer> unfiltered, int callingUid,\n            @Nullable String callingPackage) {\n        // first part is to filter shared accounts.\n        // unfiltered type check is not necessary.\n        if (getUserManager() == null || userAccounts == null || userAccounts.userId < 0\n                || callingUid == Process.SYSTEM_UID) {\n            return unfiltered;\n        }\n        UserInfo user = getUserManager().getUserInfo(userAccounts.userId);\n        if (user != null && user.isRestricted()) {\n            String[] packages = mPackageManager.getPackagesForUid(callingUid);\n            if (packages == null) {\n                packages = new String[] {};\n            }\n            // If any of the packages is a visible listed package, return the full set,\n            // otherwise return non-shared accounts only.\n            // This might be a temporary way to specify a visible list\n            String visibleList = mContext.getResources().getString(\n                    com.android.internal.R.string.config_appsAuthorizedForSharedAccounts);\n            for (String packageName : packages) {\n                if (visibleList.contains(\";\" + packageName + \";\")) {\n                    return unfiltered;\n                }\n            }\n            Account[] sharedAccounts = getSharedAccountsAsUser(userAccounts.userId);\n            if (ArrayUtils.isEmpty(sharedAccounts)) {\n                return unfiltered;\n            }\n            String requiredAccountType = \"\";\n            try {\n                // If there's an explicit callingPackage specified, check if that package\n                // opted in to see restricted accounts.\n                if (callingPackage != null) {\n                    PackageInfo pi = mPackageManager.getPackageInfo(callingPackage, 0);\n                    if (pi != null && pi.restrictedAccountType != null) {\n                        requiredAccountType = pi.restrictedAccountType;\n                    }\n                } else {\n                    // Otherwise check if the callingUid has a package that has opted in\n                    for (String packageName : packages) {\n                        PackageInfo pi = mPackageManager.getPackageInfo(packageName, 0);\n                        if (pi != null && pi.restrictedAccountType != null) {\n                            requiredAccountType = pi.restrictedAccountType;\n                            break;\n                        }\n                    }\n                }\n            } catch (NameNotFoundException e) {\n                Log.d(TAG, \"Package not found \" + e.getMessage());\n            }\n            Map<Account, Integer> filtered = new LinkedHashMap<>();\n            for (Map.Entry<Account, Integer> entry : unfiltered.entrySet()) {\n                Account account = entry.getKey();\n                if (account.type.equals(requiredAccountType)) {\n                    filtered.put(account, entry.getValue());\n                } else {\n                    boolean found = false;\n                    for (Account shared : sharedAccounts) {\n                        if (shared.equals(account)) {\n                            found = true;\n                            break;\n                        }\n                    }\n                    if (!found) {\n                        filtered.put(account, entry.getValue());\n                    }\n                }\n            }\n            return filtered;\n        } else {\n            return unfiltered;\n        }\n    }\n\n    /*\n     * packageName can be null. If not null, it should be used to filter out restricted accounts\n     * that the package is not allowed to access.\n     *\n     * <p>The method shouldn't be called with UserAccounts#cacheLock held, otherwise it will cause a\n     * deadlock\n     */\n    @NonNull\n    protected Account[] getAccountsFromCache(UserAccounts userAccounts, String accountType,\n            int callingUid, @Nullable String callingPackage, boolean includeManagedNotVisible) {\n        Preconditions.checkState(!Thread.holdsLock(userAccounts.cacheLock),\n                \"Method should not be called with cacheLock\");\n        if (accountType != null) {\n            Account[] accounts;\n            synchronized (userAccounts.cacheLock) {\n                accounts = userAccounts.accountCache.get(accountType);\n            }\n            if (accounts == null) {\n                return EMPTY_ACCOUNT_ARRAY;\n            } else {\n                return filterAccounts(userAccounts, Arrays.copyOf(accounts, accounts.length),\n                        callingUid, callingPackage, includeManagedNotVisible);\n            }\n        } else {\n            int totalLength = 0;\n            Account[] accountsArray;\n            synchronized (userAccounts.cacheLock) {\n                for (Account[] accounts : userAccounts.accountCache.values()) {\n                    totalLength += accounts.length;\n                }\n                if (totalLength == 0) {\n                    return EMPTY_ACCOUNT_ARRAY;\n                }\n                accountsArray = new Account[totalLength];\n                totalLength = 0;\n                for (Account[] accountsOfType : userAccounts.accountCache.values()) {\n                    System.arraycopy(accountsOfType, 0, accountsArray, totalLength,\n                            accountsOfType.length);\n                    totalLength += accountsOfType.length;\n                }\n            }\n            return filterAccounts(userAccounts, accountsArray, callingUid, callingPackage,\n                    includeManagedNotVisible);\n        }\n    }\n\n    /** protected by the {@code dbLock}, {@code cacheLock} */\n    protected void writeUserDataIntoCacheLocked(UserAccounts accounts,\n            Account account, String key, String value) {\n        Map<String, String> userDataForAccount = accounts.userDataCache.get(account);\n        if (userDataForAccount == null) {\n            userDataForAccount = accounts.accountsDb.findUserExtrasForAccount(account);\n            accounts.userDataCache.put(account, userDataForAccount);\n        }\n        if (value == null) {\n            userDataForAccount.remove(key);\n        } else {\n            userDataForAccount.put(key, value);\n        }\n    }\n\n    protected String readCachedTokenInternal(\n            UserAccounts accounts,\n            Account account,\n            String tokenType,\n            String callingPackage,\n            byte[] pkgSigDigest) {\n        synchronized (accounts.cacheLock) {\n            return accounts.accountTokenCaches.get(\n                    account, tokenType, callingPackage, pkgSigDigest);\n        }\n    }\n\n    /** protected by the {@code dbLock}, {@code cacheLock} */\n    protected void writeAuthTokenIntoCacheLocked(UserAccounts accounts,\n            Account account, String key, String value) {\n        Map<String, String> authTokensForAccount = accounts.authTokenCache.get(account);\n        if (authTokensForAccount == null) {\n            authTokensForAccount = accounts.accountsDb.findAuthTokensByAccount(account);\n            accounts.authTokenCache.put(account, authTokensForAccount);\n        }\n        if (value == null) {\n            authTokensForAccount.remove(key);\n        } else {\n            authTokensForAccount.put(key, value);\n        }\n    }\n\n    protected String readAuthTokenInternal(UserAccounts accounts, Account account,\n            String authTokenType) {\n        // Fast path - check if account is already cached\n        synchronized (accounts.cacheLock) {\n            Map<String, String> authTokensForAccount = accounts.authTokenCache.get(account);\n            if (authTokensForAccount != null) {\n                return authTokensForAccount.get(authTokenType);\n            }\n        }\n        // If not cached yet - do slow path and sync with db if necessary\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                Map<String, String> authTokensForAccount = accounts.authTokenCache.get(account);\n                if (authTokensForAccount == null) {\n                    // need to populate the cache for this account\n                    authTokensForAccount = accounts.accountsDb.findAuthTokensByAccount(account);\n                    accounts.authTokenCache.put(account, authTokensForAccount);\n                }\n                return authTokensForAccount.get(authTokenType);\n            }\n        }\n    }\n\n    private String readUserDataInternal(UserAccounts accounts, Account account, String key) {\n        Map<String, String> userDataForAccount;\n        // Fast path - check if data is already cached\n        synchronized (accounts.cacheLock) {\n            userDataForAccount = accounts.userDataCache.get(account);\n        }\n        // If not cached yet - do slow path and sync with db if necessary\n        if (userDataForAccount == null) {\n            synchronized (accounts.dbLock) {\n                synchronized (accounts.cacheLock) {\n                    userDataForAccount = accounts.userDataCache.get(account);\n                    if (userDataForAccount == null) {\n                        // need to populate the cache for this account\n                        userDataForAccount = accounts.accountsDb.findUserExtrasForAccount(account);\n                        accounts.userDataCache.put(account, userDataForAccount);\n                    }\n                }\n            }\n        }\n        return userDataForAccount.get(key);\n    }\n\n    private Context getContextForUser(UserHandle user) {\n        try {\n            return mContext.createPackageContextAsUser(mContext.getPackageName(), 0, user);\n        } catch (NameNotFoundException e) {\n            // Default to mContext, not finding the package system is running as is unlikely.\n            return mContext;\n        }\n    }\n\n    private void sendResponse(IAccountManagerResponse response, Bundle result) {\n        try {\n            response.onResult(result);\n        } catch (RemoteException e) {\n            // if the caller is dead then there is no one to care about remote\n            // exceptions\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"failure while notifying response\", e);\n            }\n        }\n    }\n\n    private void sendErrorResponse(IAccountManagerResponse response, int errorCode,\n            String errorMessage) {\n        try {\n            response.onError(errorCode, errorMessage);\n        } catch (RemoteException e) {\n            // if the caller is dead then there is no one to care about remote\n            // exceptions\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"failure while notifying response\", e);\n            }\n        }\n    }\n\n    private final class AccountManagerInternalImpl extends AccountManagerInternal {\n        private final Object mLock = new Object();\n\n        @GuardedBy(\"mLock\")\n        private AccountManagerBackupHelper mBackupHelper;\n\n        @Override\n        public void requestAccountAccess(@NonNull Account account, @NonNull String packageName,\n                @IntRange(from = 0) int userId, @NonNull RemoteCallback callback) {\n            if (account == null) {\n                Slog.w(TAG, \"account cannot be null\");\n                return;\n            }\n            if (packageName == null) {\n                Slog.w(TAG, \"packageName cannot be null\");\n                return;\n            }\n            if (userId < UserHandle.USER_SYSTEM) {\n                Slog.w(TAG, \"user id must be concrete\");\n                return;\n            }\n            if (callback == null) {\n                Slog.w(TAG, \"callback cannot be null\");\n                return;\n            }\n\n            int visibility =\n                resolveAccountVisibility(account, packageName, getUserAccounts(userId));\n            if (visibility == AccountManager.VISIBILITY_NOT_VISIBLE) {\n                Slog.w(TAG, \"requestAccountAccess: account is hidden\");\n                return;\n            }\n\n            if (AccountManagerService.this.hasAccountAccess(account, packageName,\n                    new UserHandle(userId))) {\n                Bundle result = new Bundle();\n                result.putBoolean(AccountManager.KEY_BOOLEAN_RESULT, true);\n                callback.sendResult(result);\n                return;\n            }\n\n            final int uid;\n            try {\n                final long identityToken = clearCallingIdentity();\n                try {\n                    uid = mPackageManager.getPackageUidAsUser(packageName, userId);\n                } finally {\n                    restoreCallingIdentity(identityToken);\n                }\n            } catch (NameNotFoundException e) {\n                Slog.e(TAG, \"Unknown package \" + packageName);\n                return;\n            }\n\n            Intent intent = newRequestAccountAccessIntent(account, packageName, uid, callback);\n            final UserAccounts userAccounts;\n            synchronized (mUsers) {\n                userAccounts = mUsers.get(userId);\n            }\n            SystemNotificationChannels.createAccountChannelForPackage(packageName, uid, mContext);\n            doNotification(userAccounts, account, null, intent, packageName, userId);\n        }\n\n        @Override\n        public void addOnAppPermissionChangeListener(OnAppPermissionChangeListener listener) {\n            // Listeners are a final CopyOnWriteArrayList, hence no lock needed.\n            mAppPermissionChangeListeners.add(listener);\n        }\n\n        @Override\n        public boolean hasAccountAccess(@NonNull Account account, @IntRange(from = 0) int uid) {\n            return AccountManagerService.this.hasAccountAccess(account, null, uid);\n        }\n\n        @Override\n        public byte[] backupAccountAccessPermissions(int userId) {\n            synchronized (mLock) {\n                if (mBackupHelper == null) {\n                    mBackupHelper = new AccountManagerBackupHelper(\n                            AccountManagerService.this, this);\n                }\n                return mBackupHelper.backupAccountAccessPermissions(userId);\n            }\n        }\n\n        @Override\n        public void restoreAccountAccessPermissions(byte[] data, int userId) {\n            synchronized (mLock) {\n                if (mBackupHelper == null) {\n                    mBackupHelper = new AccountManagerBackupHelper(\n                            AccountManagerService.this, this);\n                }\n                mBackupHelper.restoreAccountAccessPermissions(data, userId);\n            }\n        }\n    }\n\n    @VisibleForTesting\n    static class Injector {\n        private final Context mContext;\n\n        public Injector(Context context) {\n            mContext = context;\n        }\n\n        Looper getMessageHandlerLooper() {\n            ServiceThread serviceThread = new ServiceThread(TAG,\n                    android.os.Process.THREAD_PRIORITY_FOREGROUND, true /* allowIo */);\n            serviceThread.start();\n            return serviceThread.getLooper();\n        }\n\n        Context getContext() {\n            return mContext;\n        }\n\n        void addLocalService(AccountManagerInternal service) {\n            LocalServices.addService(AccountManagerInternal.class, service);\n        }\n\n        String getDeDatabaseName(int userId) {\n            File databaseFile = new File(Environment.getDataSystemDeDirectory(userId),\n                    AccountsDb.DE_DATABASE_NAME);\n            return databaseFile.getPath();\n        }\n\n        String getCeDatabaseName(int userId) {\n            File databaseFile = new File(Environment.getDataSystemCeDirectory(userId),\n                    AccountsDb.CE_DATABASE_NAME);\n            return databaseFile.getPath();\n        }\n\n        String getPreNDatabaseName(int userId) {\n            File systemDir = Environment.getDataSystemDirectory();\n            File databaseFile = new File(Environment.getUserSystemDirectory(userId),\n                    PRE_N_DATABASE_NAME);\n            if (userId == 0) {\n                // Migrate old file, if it exists, to the new location.\n                // Make sure the new file doesn't already exist. A placeholder file could have been\n                // accidentally created in the old location,\n                // causing the new one to become corrupted as well.\n                File oldFile = new File(systemDir, PRE_N_DATABASE_NAME);\n                if (oldFile.exists() && !databaseFile.exists()) {\n                    // Check for use directory; create if it doesn't exist, else renameTo will fail\n                    File userDir = Environment.getUserSystemDirectory(userId);\n                    if (!userDir.exists()) {\n                        if (!userDir.mkdirs()) {\n                            throw new IllegalStateException(\n                                    \"User dir cannot be created: \" + userDir);\n                        }\n                    }\n                    if (!oldFile.renameTo(databaseFile)) {\n                        throw new IllegalStateException(\n                                \"User dir cannot be migrated: \" + databaseFile);\n                    }\n                }\n            }\n            return databaseFile.getPath();\n        }\n\n        IAccountAuthenticatorCache getAccountAuthenticatorCache() {\n            return new AccountAuthenticatorCache(mContext);\n        }\n\n        INotificationManager getNotificationManager() {\n            return NotificationManager.getService();\n        }\n    }\n\n    private static class NotificationId {\n        final String mTag;\n        private final int mId;\n\n        NotificationId(String tag, int type) {\n            mTag = tag;\n            mId = type;\n        }\n    }\n}\n```"
                    }
                ]
            },
            {
                "downstream_version": "12L",
                "branch_used": "android12L-release",
                "downstream_patch": "185048041e6f9d43c38829c09965e7a4740d2a6a",
                "repo_path": "android_repos/base",
                "result": "failure",
                "downstream_patch_content": "commit 185048041e6f9d43c38829c09965e7a4740d2a6a\nAuthor: Dmitry Dementyev <dementyev@google.com>\nDate:   Wed Oct 16 15:01:59 2024 -0700\n\n    Update checkKeyIntent\n    \n    1) Explicityly set  component after target activity check.\n    2) Update Intent subclass check.\n    \n    Bug: 360846772\n    Test: manual\n    Flag: EXEMPT bugfix\n    \n    Merged-In: Ied7961c73299681aa5b523cf3f00fd905893116f\n    Change-Id: Iafc1e2260107f7ecc18c90ce12f8987b4fc76350\n\ndiff --git a/services/core/java/com/android/server/accounts/AccountManagerService.java b/services/core/java/com/android/server/accounts/AccountManagerService.java\nindex 36ffc40bf5f7..5f434ee267d4 100644\n--- a/services/core/java/com/android/server/accounts/AccountManagerService.java\n+++ b/services/core/java/com/android/server/accounts/AccountManagerService.java\n@@ -4916,6 +4916,8 @@ public class AccountManagerService\n                     Log.e(TAG, String.format(tmpl, activityName, pkgName, mAccountType));\n                     return false;\n                 }\n+                intent.setComponent(targetActivityInfo.getComponentName());\n+                bundle.putParcelable(AccountManager.KEY_INTENT, intent);\n                 return true;\n             } finally {\n                 Binder.restoreCallingIdentity(bid);\n@@ -4937,13 +4939,14 @@ public class AccountManagerService\n             Bundle simulateBundle = p.readBundle();\n             p.recycle();\n             Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT);\n-            if (intent != null && intent.getClass() != Intent.class) {\n-                return false;\n-            }\n             Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT);\n             if (intent == null) {\n                 return (simulateIntent == null);\n             }\n+            if (intent.getClass() != Intent.class || simulateIntent.getClass() != Intent.class) {\n+                return false;\n+            }\n+\n             if (!intent.filterEquals(simulateIntent)) {\n                 return false;\n             }\n",
                "file_conflicts": [
                    {
                        "file_name": "services/core/java/com/android/server/accounts/AccountManagerService.java",
                        "total_hunks": 2,
                        "failed_hunks": [
                            2
                        ],
                        "inline_merge_conflicts": [
                            {
                                "hunk_number": 1,
                                "merge_conflict": "<<<<<<< DOWNSTREAM (version 12L)\n\n=======\n                return false;\n            }\n\n            if (!intent.filterEquals(simulateIntent)) {\n>>>>>>> UPSTREAM PATCH (commit cde345a7ee06db716e613e12a2c218ce248ad1c4)"
                            }
                        ],
                        "rej_file_content": "```diff\n--- services/core/java/com/android/server/accounts/AccountManagerService.java\n+++ services/core/java/com/android/server/accounts/AccountManagerService.java\n@@ -5085,14 +5087,15 @@ public class AccountManagerService\n             Bundle simulateBundle = p.readBundle();\n             p.recycle();\n             Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT, Intent.class);\n-            if (intent != null && intent.getClass() != Intent.class) {\n-                return false;\n-            }\n             Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT,\n                     Intent.class);\n             if (intent == null) {\n                 return (simulateIntent == null);\n             }\n+            if (intent.getClass() != Intent.class || simulateIntent.getClass() != Intent.class) {\n+                return false;\n+            }\n+\n             if (!intent.filterEquals(simulateIntent)) {\n                 return false;\n             }\n```",
                        "patch_apply_output": "patching file services/core/java/com/android/server/accounts/AccountManagerService.java\nHunk #1 succeeded at 4916 (offset -146 lines).\nHunk #2 FAILED at 5085.\n1 out of 2 hunks FAILED -- saving rejects to file services/core/java/com/android/server/accounts/AccountManagerService.java.rej",
                        "inline_merge_output": "patching file services/core/java/com/android/server/accounts/AccountManagerService.java\nHunk #1 already applied at 5065-5066.\nHunk #2 already applied at 5088, NOT MERGED at 5094-5100.",
                        "upstream_file_content": "```java\n/*\n * Copyright (C) 2009 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.server.accounts;\n\nimport android.Manifest;\nimport android.accounts.AbstractAccountAuthenticator;\nimport android.accounts.Account;\nimport android.accounts.AccountAndUser;\nimport android.accounts.AccountAuthenticatorResponse;\nimport android.accounts.AccountManager;\nimport android.accounts.AccountManagerInternal;\nimport android.accounts.AccountManagerResponse;\nimport android.accounts.AuthenticatorDescription;\nimport android.accounts.CantAddAccountActivity;\nimport android.accounts.ChooseAccountActivity;\nimport android.accounts.GrantCredentialsPermissionActivity;\nimport android.accounts.IAccountAuthenticator;\nimport android.accounts.IAccountAuthenticatorResponse;\nimport android.accounts.IAccountManager;\nimport android.accounts.IAccountManagerResponse;\nimport android.annotation.IntRange;\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.app.ActivityManager;\nimport android.app.ActivityThread;\nimport android.app.AppOpsManager;\nimport android.app.BroadcastOptions;\nimport android.app.INotificationManager;\nimport android.app.Notification;\nimport android.app.NotificationManager;\nimport android.app.PendingIntent;\nimport android.app.admin.DevicePolicyEventLogger;\nimport android.app.admin.DevicePolicyManager;\nimport android.app.admin.DevicePolicyManagerInternal;\nimport android.app.compat.CompatChanges;\nimport android.compat.annotation.ChangeId;\nimport android.compat.annotation.EnabledAfter;\nimport android.content.BroadcastReceiver;\nimport android.content.ClipData;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.IntentSender;\nimport android.content.ServiceConnection;\nimport android.content.pm.ActivityInfo;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.IPackageManager;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManager.NameNotFoundException;\nimport android.content.pm.PackageManagerInternal;\nimport android.content.pm.RegisteredServicesCache;\nimport android.content.pm.RegisteredServicesCacheListener;\nimport android.content.pm.ResolveInfo;\nimport android.content.pm.Signature;\nimport android.content.pm.SigningDetails.CertCapabilities;\nimport android.content.pm.UserInfo;\nimport android.database.Cursor;\nimport android.database.sqlite.SQLiteCantOpenDatabaseException;\nimport android.database.sqlite.SQLiteException;\nimport android.database.sqlite.SQLiteFullException;\nimport android.database.sqlite.SQLiteStatement;\nimport android.os.Binder;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Environment;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.Parcel;\nimport android.os.Parcelable;\nimport android.os.Process;\nimport android.os.RemoteCallback;\nimport android.os.RemoteException;\nimport android.os.ResultReceiver;\nimport android.os.ShellCallback;\nimport android.os.StrictMode;\nimport android.os.SystemClock;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.provider.Settings;\nimport android.stats.devicepolicy.DevicePolicyEnums;\nimport android.text.TextUtils;\nimport android.util.EventLog;\nimport android.util.Log;\nimport android.util.Pair;\nimport android.util.Slog;\nimport android.util.SparseArray;\nimport android.util.SparseBooleanArray;\n\nimport com.android.internal.R;\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.content.PackageMonitor;\nimport com.android.internal.messages.nano.SystemMessageProto.SystemMessage;\nimport com.android.internal.notification.SystemNotificationChannels;\nimport com.android.internal.util.ArrayUtils;\nimport com.android.internal.util.DumpUtils;\nimport com.android.internal.util.IndentingPrintWriter;\nimport com.android.internal.util.Preconditions;\nimport com.android.modules.expresslog.Histogram;\nimport com.android.server.LocalServices;\nimport com.android.server.ServiceThread;\nimport com.android.server.SystemService;\n\nimport com.google.android.collect.Lists;\nimport com.google.android.collect.Sets;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.PrintWriter;\nimport java.security.GeneralSecurityException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.concurrent.atomic.AtomicReference;\n\n/**\n * A system service that provides  account, password, and authtoken management for all\n * accounts on the device. Some of these calls are implemented with the help of the corresponding\n * {@link IAccountAuthenticator} services. This service is not accessed by users directly,\n * instead one uses an instance of {@link AccountManager}, which can be accessed as follows:\n *    AccountManager accountManager = AccountManager.get(context);\n * @hide\n */\npublic class AccountManagerService\n        extends IAccountManager.Stub\n        implements RegisteredServicesCacheListener<AuthenticatorDescription> {\n    private static final String TAG = \"AccountManagerService\";\n\n    public static class Lifecycle extends SystemService {\n        private AccountManagerService mService;\n\n        public Lifecycle(Context context) {\n            super(context);\n        }\n\n        @Override\n        public void onStart() {\n            mService = new AccountManagerService(new Injector(getContext()));\n            publishBinderService(Context.ACCOUNT_SERVICE, mService);\n        }\n\n        @Override\n        public void onUserUnlocking(@NonNull TargetUser user) {\n            mService.onUnlockUser(user.getUserIdentifier());\n        }\n\n        @Override\n        public void onUserStopped(@NonNull TargetUser user) {\n            Slog.i(TAG, \"onUserStopped \" + user);\n            mService.purgeUserData(user.getUserIdentifier());\n        }\n    }\n\n    final Context mContext;\n\n    private static final int[] INTERESTING_APP_OPS = new int[] {\n        AppOpsManager.OP_GET_ACCOUNTS,\n        AppOpsManager.OP_READ_CONTACTS,\n        AppOpsManager.OP_WRITE_CONTACTS,\n    };\n\n    private final PackageManager mPackageManager;\n    private final AppOpsManager mAppOpsManager;\n    private UserManager mUserManager;\n    private final Injector mInjector;\n\n    final MessageHandler mHandler;\n\n    private static final int TIMEOUT_DELAY_MS = 1000 * 60 * 15;\n    // Messages that can be sent on mHandler\n    private static final int MESSAGE_TIMED_OUT = 3;\n    private static final int MESSAGE_COPY_SHARED_ACCOUNT = 4;\n\n    private final IAccountAuthenticatorCache mAuthenticatorCache;\n    private static final String PRE_N_DATABASE_NAME = \"accounts.db\";\n    private static final Intent ACCOUNTS_CHANGED_INTENT;\n    private static final Bundle ACCOUNTS_CHANGED_OPTIONS = new BroadcastOptions()\n            .setDeliveryGroupPolicy(BroadcastOptions.DELIVERY_GROUP_POLICY_MOST_RECENT)\n            .toBundle();\n\n    private static final int SIGNATURE_CHECK_MISMATCH = 0;\n    private static final int SIGNATURE_CHECK_MATCH = 1;\n    private static final int SIGNATURE_CHECK_UID_MATCH = 2;\n\n    /**\n     * Apps targeting Android U and above need to declare the package visibility needs in the\n     * manifest to access the AccountManager APIs.\n     */\n    @ChangeId\n    @EnabledAfter(targetSdkVersion = Build.VERSION_CODES.TIRAMISU)\n    private static final long ENFORCE_PACKAGE_VISIBILITY_FILTERING = 154726397;\n\n    static {\n        ACCOUNTS_CHANGED_INTENT = new Intent(AccountManager.LOGIN_ACCOUNTS_CHANGED_ACTION);\n        ACCOUNTS_CHANGED_INTENT.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT\n                | Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);\n    }\n\n    private final LinkedHashMap<String, Session> mSessions = new LinkedHashMap<String, Session>();\n\n    static class UserAccounts {\n        private final int userId;\n        final AccountsDb accountsDb;\n        private final HashMap<Pair<Pair<Account, String>, Integer>, NotificationId>\n                credentialsPermissionNotificationIds = new HashMap<>();\n        private final HashMap<Account, NotificationId> signinRequiredNotificationIds\n                = new HashMap<>();\n        final Object cacheLock = new Object();\n        final Object dbLock = new Object(); // if needed, dbLock must be obtained before cacheLock\n        /** protected by the {@link #cacheLock} */\n        final HashMap<String, Account[]> accountCache = new LinkedHashMap<>();\n        /** protected by the {@link #cacheLock} */\n        private final Map<Account, Map<String, String>> userDataCache = new HashMap<>();\n        /** protected by the {@link #cacheLock} */\n        private final Map<Account, Map<String, String>> authTokenCache = new HashMap<>();\n        /** protected by the {@link #cacheLock} */\n        private final TokenCache accountTokenCaches = new TokenCache();\n        /** protected by the {@link #cacheLock} */\n        private final Map<Account, Map<String, Integer>> visibilityCache = new HashMap<>();\n\n        /** protected by the {@link #mReceiversForType},\n         *  type -> (packageName -> number of active receivers)\n         *  type == null is used to get notifications about all account types\n         */\n        private final Map<String, Map<String, Integer>> mReceiversForType = new HashMap<>();\n\n        /**\n         * protected by the {@link #cacheLock}\n         *\n         * Caches the previous names associated with an account. Previous names\n         * should be cached because we expect that when an Account is renamed,\n         * many clients will receive a LOGIN_ACCOUNTS_CHANGED broadcast and\n         * want to know if the accounts they care about have been renamed.\n         *\n         * The previous names are wrapped in an {@link AtomicReference} so that\n         * we can distinguish between those accounts with no previous names and\n         * those whose previous names haven't been cached (yet).\n         */\n        private final HashMap<Account, AtomicReference<String>> previousNameCache =\n                new HashMap<Account, AtomicReference<String>>();\n\n        UserAccounts(Context context, int userId, File preNDbFile, File deDbFile) {\n            this.userId = userId;\n            synchronized (dbLock) {\n                synchronized (cacheLock) {\n                    accountsDb = AccountsDb.create(context, userId, preNDbFile, deDbFile);\n                }\n            }\n        }\n    }\n\n    private final SparseArray<UserAccounts> mUsers = new SparseArray<>();\n    private final SparseBooleanArray mLocalUnlockedUsers = new SparseBooleanArray();\n    // Not thread-safe. Only use in synchronized context\n    private final SimpleDateFormat mDateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n    private CopyOnWriteArrayList<AccountManagerInternal.OnAppPermissionChangeListener>\n            mAppPermissionChangeListeners = new CopyOnWriteArrayList<>();\n\n    private static AtomicReference<AccountManagerService> sThis = new AtomicReference<>();\n    private static final Account[] EMPTY_ACCOUNT_ARRAY = new Account[]{};\n\n    private static Histogram sResponseLatency = new Histogram(\n            \"app.value_high_authenticator_response_latency\",\n            new Histogram.ScaledRangeOptions(20, 10000, 10000, 1.5f)\n    );\n\n    /**\n     * This should only be called by system code. One should only call this after the service\n     * has started.\n     * @return a reference to the AccountManagerService instance\n     * @hide\n     */\n    public static AccountManagerService getSingleton() {\n        return sThis.get();\n    }\n\n    public AccountManagerService(Injector injector) {\n        mInjector = injector;\n        mContext = injector.getContext();\n        mPackageManager = mContext.getPackageManager();\n        mAppOpsManager = mContext.getSystemService(AppOpsManager.class);\n        mHandler = new MessageHandler(injector.getMessageHandlerLooper());\n        mAuthenticatorCache = mInjector.getAccountAuthenticatorCache();\n        mAuthenticatorCache.setListener(this, mHandler);\n\n        sThis.set(this);\n\n        IntentFilter intentFilter = new IntentFilter();\n        intentFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);\n        intentFilter.addDataScheme(\"package\");\n        mContext.registerReceiver(new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context1, Intent intent) {\n                // Don't delete accounts when updating a authenticator's\n                // package.\n                if (!intent.getBooleanExtra(Intent.EXTRA_REPLACING, false)) {\n                    /* Purging data requires file io, don't block the main thread. This is probably\n                     * less than ideal because we are introducing a race condition where old grants\n                     * could be exercised until they are purged. But that race condition existed\n                     * anyway with the broadcast receiver.\n                     *\n                     * Ideally, we would completely clear the cache, purge data from the database,\n                     * and then rebuild the cache. All under the cache lock. But that change is too\n                     * large at this point.\n                     */\n                    final String removedPackageName = intent.getData().getSchemeSpecificPart();\n                    Runnable purgingRunnable = new Runnable() {\n                        @Override\n                        public void run() {\n                            purgeOldGrantsAll();\n                            // Notify authenticator about removed app?\n                            removeVisibilityValuesForPackage(removedPackageName);\n                        }\n                    };\n                    mHandler.post(purgingRunnable);\n                }\n            }\n        }, intentFilter);\n\n        injector.addLocalService(new AccountManagerInternalImpl());\n\n        IntentFilter userFilter = new IntentFilter();\n        userFilter.addAction(Intent.ACTION_USER_REMOVED);\n        mContext.registerReceiverAsUser(new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                String action = intent.getAction();\n                if (Intent.ACTION_USER_REMOVED.equals(action)) {\n                    int userId = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, -1);\n                    if (userId < 1) return;\n                    Slog.i(TAG, \"User \" + userId + \" removed\");\n                    purgeUserData(userId);\n                }\n            }\n        }, UserHandle.ALL, userFilter, null, null);\n\n        // Need to cancel account request notifications if the update/install can access the account\n        new PackageMonitor() {\n            @Override\n            public void onPackageAdded(String packageName, int uid) {\n                // Called on a handler, and running as the system\n                try {\n                    UserAccounts accounts = getUserAccounts(UserHandle.getUserId(uid));\n                    cancelAccountAccessRequestNotificationIfNeeded(uid, true, accounts);\n                } catch (SQLiteCantOpenDatabaseException e) {\n                    Log.w(TAG, \"Can't read accounts database\", e);\n                    return;\n                }\n            }\n\n            @Override\n            public void onPackageUpdateFinished(String packageName, int uid) {\n                // Called on a handler, and running as the system\n                try {\n                    UserAccounts accounts = getUserAccounts(UserHandle.getUserId(uid));\n                    cancelAccountAccessRequestNotificationIfNeeded(uid, true, accounts);\n                } catch (SQLiteCantOpenDatabaseException e) {\n                    Log.w(TAG, \"Can't read accounts database\", e);\n                    return;\n                }\n            }\n        }.register(mContext, mHandler.getLooper(), UserHandle.ALL, true);\n\n        // Cancel account request notification if an app op was preventing the account access\n        for (int i = 0; i < INTERESTING_APP_OPS.length; ++i) {\n            mAppOpsManager.startWatchingMode(INTERESTING_APP_OPS[i], null,\n                    new OnInterestingAppOpChangedListener());\n        }\n\n        // Clear the accounts cache on permission changes.\n        // The specific permissions we care about are backed by AppOps, so just\n        // let the change events on those handle clearing any notifications.\n        mPackageManager.addOnPermissionsChangeListener((int uid) -> {\n            AccountManager.invalidateLocalAccountsDataCaches();\n        });\n    }\n\n    private class OnInterestingAppOpChangedListener\n            extends AppOpsManager.OnOpChangedInternalListener {\n        @Override\n        public void onOpChanged(int op, String packageName) {\n            final int userId = ActivityManager.getCurrentUser();\n            final int packageUid;\n            try {\n                packageUid = mPackageManager.getPackageUidAsUser(packageName, userId);\n            } catch (NameNotFoundException e) {\n                /* ignore */\n                return;\n            }\n\n            final int mode = mAppOpsManager.checkOpNoThrow(op, packageUid, packageName);\n            if (mode != AppOpsManager.MODE_ALLOWED) {\n                return;\n            }\n\n            final long identity = Binder.clearCallingIdentity();\n            try {\n                cancelAccountAccessRequestNotificationIfNeeded(\n                        packageName, packageUid, true, getUserAccounts(userId));\n            } catch (SQLiteCantOpenDatabaseException e) {\n                Log.w(TAG, \"Can't read accounts database\", e);\n            } finally {\n                Binder.restoreCallingIdentity(identity);\n            }\n        }\n    }\n\n    boolean getBindInstantServiceAllowed(int userId) {\n        return  mAuthenticatorCache.getBindInstantServiceAllowed(userId);\n    }\n\n    void setBindInstantServiceAllowed(int userId, boolean allowed) {\n        mAuthenticatorCache.setBindInstantServiceAllowed(userId, allowed);\n    }\n\n    private void cancelAccountAccessRequestNotificationIfNeeded(int uid,\n            boolean checkAccess, UserAccounts userAccounts) {\n        Account[] accounts = getAccountsOrEmptyArray(null, UserHandle.getUserId(uid), \"android\");\n        for (Account account : accounts) {\n            cancelAccountAccessRequestNotificationIfNeeded(account, uid, checkAccess, userAccounts);\n        }\n    }\n\n    private void cancelAccountAccessRequestNotificationIfNeeded(String packageName, int uid,\n            boolean checkAccess, UserAccounts userAccounts) {\n        Account[] accounts = getAccountsOrEmptyArray(null, UserHandle.getUserId(uid), \"android\");\n        for (Account account : accounts) {\n            cancelAccountAccessRequestNotificationIfNeeded(account,\n                    uid, packageName, checkAccess, userAccounts);\n        }\n    }\n\n    private void cancelAccountAccessRequestNotificationIfNeeded(Account account, int uid,\n            boolean checkAccess, UserAccounts accounts) {\n        String[] packageNames = mPackageManager.getPackagesForUid(uid);\n        if (packageNames != null) {\n            for (String packageName : packageNames) {\n                cancelAccountAccessRequestNotificationIfNeeded(account, uid,\n                        packageName, checkAccess, accounts);\n            }\n        }\n    }\n\n    private void cancelAccountAccessRequestNotificationIfNeeded(Account account,\n            int uid, String packageName, boolean checkAccess, UserAccounts accounts) {\n        if (!checkAccess || hasAccountAccess(account, packageName,\n                UserHandle.getUserHandleForUid(uid))) {\n            cancelNotification(getCredentialPermissionNotificationId(account,\n                    AccountManager.ACCOUNT_ACCESS_TOKEN_TYPE, uid, accounts),\n                    accounts);\n        }\n    }\n\n    @Override\n    public boolean addAccountExplicitlyWithVisibility(Account account, String password,\n            Bundle extras, Map packageToVisibility, String opPackageName) {\n        Bundle.setDefusable(extras, true);\n        int callingUid = Binder.getCallingUid();\n        int userId = UserHandle.getCallingUserId();\n        Objects.requireNonNull(account, \"account cannot be null\");\n        Log.v(TAG, \"addAccountExplicitly: caller's uid=\" + callingUid + \", pid=\"\n                + Binder.getCallingPid() + \", packageName=\" + opPackageName + \", accountType=\"\n                + account.type);\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\"uid=%s, package=%s cannot explicitly add \"\n                    + \"accounts of type: %s\", callingUid, opPackageName, account.type);\n            throw new SecurityException(msg);\n        }\n        /*\n         * Child users are not allowed to add accounts. Only the accounts that are shared by the\n         * parent profile can be added to child profile.\n         *\n         * TODO: Only allow accounts that were shared to be added by a limited user.\n         */\n        // fails if the account already exists\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return addAccountInternal(accounts, account, password, extras, callingUid,\n                    (Map<String, Integer>) packageToVisibility, opPackageName);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public Map<Account, Integer> getAccountsAndVisibilityForPackage(String packageName,\n            String accountType) {\n        int callingUid = Binder.getCallingUid();\n        int userId = UserHandle.getCallingUserId();\n        boolean isSystemUid = UserHandle.isSameApp(callingUid, Process.SYSTEM_UID);\n        List<String> managedTypes = getTypesForCaller(callingUid, userId, isSystemUid);\n\n        if ((accountType != null && !managedTypes.contains(accountType))\n                || (accountType == null && !isSystemUid)) {\n            throw new SecurityException(\n                    \"getAccountsAndVisibilityForPackage() called from unauthorized uid \"\n                            + callingUid + \" with packageName=\" + packageName);\n        }\n        if (accountType != null) {\n            managedTypes = new ArrayList<String>();\n            managedTypes.add(accountType);\n        }\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return getAccountsAndVisibilityForPackage(packageName, managedTypes, callingUid,\n                    accounts);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    /*\n     * accountTypes may not be null\n     */\n    private Map<Account, Integer> getAccountsAndVisibilityForPackage(String packageName,\n            List<String> accountTypes, Integer callingUid, UserAccounts accounts) {\n        if (!canCallerAccessPackage(packageName, callingUid, accounts.userId)) {\n            Log.w(TAG, \"getAccountsAndVisibilityForPackage#Package not found \" + packageName);\n            return new LinkedHashMap<>();\n        }\n\n        Map<Account, Integer> result = new LinkedHashMap<>();\n        for (String accountType : accountTypes) {\n            synchronized (accounts.dbLock) {\n                synchronized (accounts.cacheLock) {\n                    final Account[] accountsOfType = accounts.accountCache.get(accountType);\n                    if (accountsOfType != null) {\n                        for (Account account : accountsOfType) {\n                            result.put(account,\n                                    resolveAccountVisibility(account, packageName, accounts));\n                        }\n                    }\n                }\n            }\n        }\n        return filterSharedAccounts(accounts, result, callingUid, packageName);\n    }\n\n    @Override\n    public Map<String, Integer> getPackagesAndVisibilityForAccount(Account account) {\n        Objects.requireNonNull(account, \"account cannot be null\");\n        int callingUid = Binder.getCallingUid();\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)\n                && !isSystemUid(callingUid)) {\n            String msg =\n                    String.format(\"uid %s cannot get secrets for account %s\", callingUid, account);\n            throw new SecurityException(msg);\n        }\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            synchronized (accounts.dbLock) {\n                synchronized (accounts.cacheLock) {\n                    return getPackagesAndVisibilityForAccountLocked(account, accounts);\n                }\n            }\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n\n    }\n\n    /**\n     * Returns Map with all package names and visibility values for given account.\n     * The method and returned map must be guarded by accounts.cacheLock\n     *\n     * @param account Account to get visibility values.\n     * @param accounts UserAccount that currently hosts the account and application\n     *\n     * @return Map with cache for package names to visibility.\n     */\n    private @NonNull Map<String, Integer> getPackagesAndVisibilityForAccountLocked(Account account,\n            UserAccounts accounts) {\n        Map<String, Integer> accountVisibility = accounts.visibilityCache.get(account);\n        if (accountVisibility == null) {\n            Log.d(TAG, \"Visibility was not initialized\");\n            accountVisibility = new HashMap<>();\n            accounts.visibilityCache.put(account, accountVisibility);\n            AccountManager.invalidateLocalAccountsDataCaches();\n        }\n        return accountVisibility;\n    }\n\n    @Override\n    public int getAccountVisibility(Account account, String packageName) {\n        Objects.requireNonNull(account, \"account cannot be null\");\n        Objects.requireNonNull(packageName, \"packageName cannot be null\");\n        int callingUid = Binder.getCallingUid();\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)\n            && !isSystemUid(callingUid)) {\n            String msg = String.format(\n                    \"uid %s cannot get secrets for accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            if (AccountManager.PACKAGE_NAME_KEY_LEGACY_VISIBLE.equals(packageName)) {\n                int visibility = getAccountVisibilityFromCache(account, packageName, accounts);\n                if (AccountManager.VISIBILITY_UNDEFINED != visibility) {\n                    return visibility;\n                } else {\n                   return AccountManager.VISIBILITY_USER_MANAGED_VISIBLE;\n                }\n            }\n            if (AccountManager.PACKAGE_NAME_KEY_LEGACY_NOT_VISIBLE.equals(packageName)) {\n                int visibility = getAccountVisibilityFromCache(account, packageName, accounts);\n                if (AccountManager.VISIBILITY_UNDEFINED != visibility) {\n                    return visibility;\n                } else {\n                   return AccountManager.VISIBILITY_USER_MANAGED_NOT_VISIBLE;\n                }\n            }\n            if (!canCallerAccessPackage(packageName, callingUid, accounts.userId)) {\n                return AccountManager.VISIBILITY_NOT_VISIBLE;\n            }\n            return resolveAccountVisibility(account, packageName, accounts);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    /**\n     * Method returns visibility for given account and package name.\n     *\n     * @param account The account to check visibility.\n     * @param packageName Package name to check visibility.\n     * @param accounts UserAccount that currently hosts the account and application\n     *\n     * @return Visibility value, AccountManager.VISIBILITY_UNDEFINED if no value was stored.\n     *\n     */\n    private int getAccountVisibilityFromCache(Account account, String packageName,\n            UserAccounts accounts) {\n        synchronized (accounts.cacheLock) {\n            Map<String, Integer> accountVisibility =\n                    getPackagesAndVisibilityForAccountLocked(account, accounts);\n            Integer visibility = accountVisibility.get(packageName);\n            return visibility != null ? visibility : AccountManager.VISIBILITY_UNDEFINED;\n        }\n    }\n\n    /**\n     * Method which handles default values for Account visibility.\n     *\n     * @param account The account to check visibility.\n     * @param packageName Package name to check visibility\n     * @param accounts UserAccount that currently hosts the account and application\n     *\n     * @return Visibility value, the method never returns AccountManager.VISIBILITY_UNDEFINED\n     *\n     */\n    private Integer resolveAccountVisibility(Account account, @NonNull String packageName,\n            UserAccounts accounts) {\n        Objects.requireNonNull(packageName, \"packageName cannot be null\");\n        int uid = -1;\n        try {\n            final long identityToken = clearCallingIdentity();\n            try {\n                uid = mPackageManager.getPackageUidAsUser(packageName, accounts.userId);\n            } finally {\n                restoreCallingIdentity(identityToken);\n            }\n        } catch (NameNotFoundException e) {\n            Log.w(TAG, \"resolveAccountVisibility#Package not found \" + e.getMessage());\n            return AccountManager.VISIBILITY_NOT_VISIBLE;\n        }\n\n        // System visibility can not be restricted.\n        if (UserHandle.isSameApp(uid, Process.SYSTEM_UID)) {\n            return AccountManager.VISIBILITY_VISIBLE;\n        }\n\n        int signatureCheckResult =\n                checkPackageSignature(account.type, uid, accounts.userId);\n\n        // Authenticator can not restrict visibility to itself.\n        if (signatureCheckResult == SIGNATURE_CHECK_UID_MATCH) {\n            return AccountManager.VISIBILITY_VISIBLE; // Authenticator can always see the account\n        }\n\n        // Return stored value if it was set.\n        int visibility = getAccountVisibilityFromCache(account, packageName, accounts);\n\n        if (AccountManager.VISIBILITY_UNDEFINED != visibility) {\n            return visibility;\n        }\n\n        boolean isPrivileged = isPermittedForPackage(packageName, accounts.userId,\n                Manifest.permission.GET_ACCOUNTS_PRIVILEGED);\n\n        // Device/Profile owner gets visibility by default.\n        if (isProfileOwner(uid)) {\n            return AccountManager.VISIBILITY_VISIBLE;\n        }\n\n        boolean preO = isPreOApplication(packageName);\n        if ((signatureCheckResult != SIGNATURE_CHECK_MISMATCH)\n                || (preO && checkGetAccountsPermission(packageName, accounts.userId))\n                || (checkReadContactsPermission(packageName, accounts.userId)\n                    && accountTypeManagesContacts(account.type, accounts.userId))\n                || isPrivileged) {\n            // Use legacy for preO apps with GET_ACCOUNTS permission or pre/postO with signature\n            // match.\n            visibility = getAccountVisibilityFromCache(account,\n                    AccountManager.PACKAGE_NAME_KEY_LEGACY_VISIBLE, accounts);\n            if (AccountManager.VISIBILITY_UNDEFINED == visibility) {\n                visibility = AccountManager.VISIBILITY_USER_MANAGED_VISIBLE;\n            }\n        } else {\n            visibility = getAccountVisibilityFromCache(account,\n                    AccountManager.PACKAGE_NAME_KEY_LEGACY_NOT_VISIBLE, accounts);\n            if (AccountManager.VISIBILITY_UNDEFINED == visibility) {\n                visibility = AccountManager.VISIBILITY_USER_MANAGED_NOT_VISIBLE;\n            }\n        }\n        return visibility;\n    }\n\n    /**\n     * Checks targetSdk for a package;\n     *\n     * @param packageName Package name\n     *\n     * @return True if package's target SDK is below {@link android.os.Build.VERSION_CODES#O}, or\n     *         undefined\n     */\n    private boolean isPreOApplication(String packageName) {\n        try {\n            final long identityToken = clearCallingIdentity();\n            ApplicationInfo applicationInfo;\n            try {\n                applicationInfo = mPackageManager.getApplicationInfo(packageName, 0);\n            } finally {\n                restoreCallingIdentity(identityToken);\n            }\n\n            if (applicationInfo != null) {\n                int version = applicationInfo.targetSdkVersion;\n                return version < android.os.Build.VERSION_CODES.O;\n            }\n            return true;\n        } catch (NameNotFoundException e) {\n            Log.w(TAG, \"isPreOApplication#Package not found \" + e.getMessage());\n            return true;\n        }\n    }\n\n    @Override\n    public boolean setAccountVisibility(Account account, String packageName, int newVisibility) {\n        Objects.requireNonNull(account, \"account cannot be null\");\n        Objects.requireNonNull(packageName, \"packageName cannot be null\");\n        int callingUid = Binder.getCallingUid();\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)\n            && !isSystemUid(callingUid)) {\n            String msg = String.format(\n                    \"uid %s cannot get secrets for accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return setAccountVisibility(account, packageName, newVisibility, true /* notify */,\n                    accounts, callingUid);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private boolean isVisible(int visibility) {\n        return visibility == AccountManager.VISIBILITY_VISIBLE ||\n            visibility == AccountManager.VISIBILITY_USER_MANAGED_VISIBLE;\n    }\n\n    /**\n     * Updates visibility for given account name and package.\n     *\n     * @param account Account to update visibility.\n     * @param packageName Package name for which visibility is updated.\n     * @param newVisibility New visibility calue\n     * @param notify if the flag is set applications will get notification about visibility change\n     * @param accounts UserAccount that currently hosts the account and application\n     * @param callingUid The caller's uid.\n     *\n     * @return True if account visibility was changed.\n     */\n    private boolean setAccountVisibility(Account account, String packageName, int newVisibility,\n            boolean notify, UserAccounts accounts, int callingUid) {\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                Map<String, Integer> packagesToVisibility;\n                List<String> accountRemovedReceivers;\n                if (notify) {\n                    if (isSpecialPackageKey(packageName)) {\n                        packagesToVisibility =\n                                getRequestingPackages(account, accounts);\n                        accountRemovedReceivers = getAccountRemovedReceivers(account, accounts);\n                    } else {\n                        if (!canCallerAccessPackage(packageName, callingUid, accounts.userId)) {\n                            return false; // package is not installed or not visible.\n                        }\n                        packagesToVisibility = new HashMap<>();\n                        packagesToVisibility.put(packageName,\n                                resolveAccountVisibility(account, packageName, accounts));\n                        accountRemovedReceivers = new ArrayList<>();\n                        if (shouldNotifyPackageOnAccountRemoval(account, packageName, accounts)) {\n                            accountRemovedReceivers.add(packageName);\n                        }\n                    }\n                } else {\n                    // Notifications will not be send - only used during add account.\n                    if (!isSpecialPackageKey(packageName)\n                            && !canCallerAccessPackage(packageName, callingUid, accounts.userId)) {\n                        // package is not installed and not meta value.\n                        return false;\n                    }\n                    packagesToVisibility = Collections.emptyMap();\n                    accountRemovedReceivers = Collections.emptyList();\n                }\n                if (notify) {\n                    Integer oldVisibility =\n                            accounts.accountsDb.findAccountVisibility(account, packageName);\n                    if (oldVisibility != null && oldVisibility == newVisibility) {\n                        // Database will not be updated - skip LOGIN_ACCOUNTS_CHANGED broadcast.\n                        notify = false;\n                    }\n                }\n\n                if (!updateAccountVisibilityLocked(account, packageName, newVisibility, accounts)) {\n                    return false;\n                }\n\n                if (notify) {\n                    Log.i(TAG, \"Notifying visibility changed for package=\" + packageName);\n                    for (Entry<String, Integer> packageToVisibility : packagesToVisibility\n                            .entrySet()) {\n                        int oldVisibility = packageToVisibility.getValue();\n                        int currentVisibility =\n                            resolveAccountVisibility(account, packageName, accounts);\n                        if (isVisible(oldVisibility) != isVisible(currentVisibility)) {\n                            notifyPackage(packageToVisibility.getKey(), accounts);\n                        }\n                    }\n                    for (String packageNameToNotify : accountRemovedReceivers) {\n                        int currentVisibility =\n                                resolveAccountVisibility(account, packageNameToNotify, accounts);\n                        if (isVisible(currentVisibility)) {\n                            continue;\n                        }\n                        sendAccountRemovedBroadcast(\n                                account,\n                                packageNameToNotify,\n                                accounts.userId,\n                                /*useCase=*/\"setAccountVisibility\");\n                    }\n                    sendAccountsChangedBroadcast(\n                            accounts.userId, account.type, /*useCase=*/\"setAccountVisibility\");\n                }\n                return true;\n            }\n        }\n    }\n\n    // Update account visibility in cache and database.\n    private boolean updateAccountVisibilityLocked(Account account, String packageName,\n            int newVisibility, UserAccounts accounts) {\n        final long accountId = accounts.accountsDb.findDeAccountId(account);\n        if (accountId < 0) {\n            return false;\n        }\n\n        final StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskWrites();\n        try {\n            if (!accounts.accountsDb.setAccountVisibility(accountId, packageName,\n                    newVisibility)) {\n                return false;\n            }\n        } finally {\n            StrictMode.setThreadPolicy(oldPolicy);\n        }\n        Map<String, Integer> accountVisibility =\n            getPackagesAndVisibilityForAccountLocked(account, accounts);\n        accountVisibility.put(packageName, newVisibility);\n        AccountManager.invalidateLocalAccountsDataCaches();\n        return true;\n    }\n\n    @Override\n    public void registerAccountListener(String[] accountTypes, String opPackageName) {\n        int callingUid = Binder.getCallingUid();\n        mAppOpsManager.checkPackage(callingUid, opPackageName);\n\n        int userId = UserHandle.getCallingUserId();\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            registerAccountListener(accountTypes, opPackageName, accounts);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private void registerAccountListener(String[] accountTypes, String opPackageName,\n            UserAccounts accounts) {\n        synchronized (accounts.mReceiversForType) {\n            if (accountTypes == null) {\n                // null for any type\n                accountTypes = new String[] {null};\n            }\n            for (String type : accountTypes) {\n                Map<String, Integer> receivers = accounts.mReceiversForType.get(type);\n                if (receivers == null) {\n                    receivers = new HashMap<>();\n                    accounts.mReceiversForType.put(type, receivers);\n                }\n                Integer cnt = receivers.get(opPackageName);\n                receivers.put(opPackageName, cnt != null ? cnt + 1 : 1);\n            }\n        }\n    }\n\n    @Override\n    public void unregisterAccountListener(String[] accountTypes, String opPackageName) {\n        int callingUid = Binder.getCallingUid();\n        mAppOpsManager.checkPackage(callingUid, opPackageName);\n        int userId = UserHandle.getCallingUserId();\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            unregisterAccountListener(accountTypes, opPackageName, accounts);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private void unregisterAccountListener(String[] accountTypes, String opPackageName,\n            UserAccounts accounts) {\n        synchronized (accounts.mReceiversForType) {\n            if (accountTypes == null) {\n                // null for any type\n                accountTypes = new String[] {null};\n            }\n            for (String type : accountTypes) {\n                Map<String, Integer> receivers = accounts.mReceiversForType.get(type);\n                if (receivers == null || receivers.get(opPackageName) == null) {\n                    throw new IllegalArgumentException(\"attempt to unregister wrong receiver\");\n                }\n                Integer cnt = receivers.get(opPackageName);\n                if (cnt == 1) {\n                    receivers.remove(opPackageName);\n                } else {\n                    receivers.put(opPackageName, cnt - 1);\n                }\n            }\n        }\n    }\n\n    // Send notification to all packages which can potentially see the account\n    private void sendNotificationAccountUpdated(Account account, UserAccounts accounts) {\n        Map<String, Integer> packagesToVisibility = getRequestingPackages(account, accounts);\n\n        for (Entry<String, Integer> packageToVisibility : packagesToVisibility.entrySet()) {\n            if ((packageToVisibility.getValue() != AccountManager.VISIBILITY_NOT_VISIBLE)\n                    && (packageToVisibility.getValue()\n                        != AccountManager.VISIBILITY_USER_MANAGED_NOT_VISIBLE)) {\n                notifyPackage(packageToVisibility.getKey(), accounts);\n            }\n        }\n    }\n\n    /**\n     * Sends a direct intent to a package, notifying it of account visibility change.\n     *\n     * @param packageName to send Account to\n     * @param accounts UserAccount that currently hosts the account\n     */\n    private void notifyPackage(String packageName, UserAccounts accounts) {\n        Log.i(TAG, \"notifying package=\" + packageName + \" for userId=\" + accounts.userId\n                +\", sending broadcast of \" + AccountManager.ACTION_VISIBLE_ACCOUNTS_CHANGED);\n        Intent intent = new Intent(AccountManager.ACTION_VISIBLE_ACCOUNTS_CHANGED);\n        intent.setPackage(packageName);\n        intent.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);\n        mContext.sendBroadcastAsUser(intent, new UserHandle(accounts.userId));\n    }\n\n    // Returns a map from package name to visibility, for packages subscribed\n    // to notifications about any account type, or type of provided account\n    // account type or all types.\n    private Map<String, Integer> getRequestingPackages(Account account, UserAccounts accounts) {\n        Set<String> packages = new HashSet<>();\n        synchronized (accounts.mReceiversForType) {\n            for (String type : new String[] {account.type, null}) {\n                Map<String, Integer> receivers = accounts.mReceiversForType.get(type);\n                if (receivers != null) {\n                    packages.addAll(receivers.keySet());\n                }\n            }\n        }\n        Map<String, Integer> result = new HashMap<>();\n        for (String packageName : packages) {\n            result.put(packageName, resolveAccountVisibility(account, packageName, accounts));\n        }\n        return result;\n    }\n\n    // Returns a list of packages listening to ACTION_ACCOUNT_REMOVED able to see the account.\n    private List<String> getAccountRemovedReceivers(Account account, UserAccounts accounts) {\n        Intent intent = new Intent(AccountManager.ACTION_ACCOUNT_REMOVED);\n        intent.setFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);\n        List<ResolveInfo> receivers =\n            mPackageManager.queryBroadcastReceiversAsUser(intent, 0, accounts.userId);\n        List<String> result = new ArrayList<>();\n        if (receivers == null) {\n            return result;\n        }\n        for (ResolveInfo resolveInfo: receivers) {\n            String packageName = resolveInfo.activityInfo.applicationInfo.packageName;\n            int visibility = resolveAccountVisibility(account, packageName, accounts);\n            if (visibility == AccountManager.VISIBILITY_VISIBLE\n                || visibility == AccountManager.VISIBILITY_USER_MANAGED_VISIBLE) {\n                result.add(packageName);\n            }\n        }\n        return result;\n    }\n\n    // Returns true if given package is listening to ACTION_ACCOUNT_REMOVED and can see the account.\n    private boolean shouldNotifyPackageOnAccountRemoval(Account account,\n            String packageName, UserAccounts accounts) {\n        int visibility = resolveAccountVisibility(account, packageName, accounts);\n        if (visibility != AccountManager.VISIBILITY_VISIBLE\n            && visibility != AccountManager.VISIBILITY_USER_MANAGED_VISIBLE) {\n            return false;\n        }\n\n        Intent intent = new Intent(AccountManager.ACTION_ACCOUNT_REMOVED);\n        intent.setFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);\n        intent.setPackage(packageName);\n        List<ResolveInfo> receivers =\n            mPackageManager.queryBroadcastReceiversAsUser(intent, 0, accounts.userId);\n        return (receivers != null && receivers.size() > 0);\n    }\n\n    /**\n     * Returns true if packageName is one of special values.\n     */\n    private boolean isSpecialPackageKey(String packageName) {\n        return (AccountManager.PACKAGE_NAME_KEY_LEGACY_VISIBLE.equals(packageName)\n                || AccountManager.PACKAGE_NAME_KEY_LEGACY_NOT_VISIBLE.equals(packageName));\n    }\n\n    private void sendAccountsChangedBroadcast(\n            int userId, String accountType, @NonNull String useCase) {\n        Objects.requireNonNull(useCase, \"useCase can't be null\");\n        Log.i(TAG, \"the accountType= \" + (accountType == null ? \"\" : accountType)\n                + \" changed with useCase=\" + useCase + \" for userId=\" + userId\n                + \", sending broadcast of \" + ACCOUNTS_CHANGED_INTENT.getAction());\n        mContext.sendBroadcastAsUser(ACCOUNTS_CHANGED_INTENT, new UserHandle(userId),\n                null /* receiverPermission */, ACCOUNTS_CHANGED_OPTIONS);\n    }\n\n    private void sendAccountRemovedBroadcast(\n            Account account, String packageName, int userId, @NonNull String useCase) {\n        Objects.requireNonNull(useCase, \"useCase can't be null\");\n        Log.i(TAG, \"the account with type=\" + account.type + \" removed while useCase=\"\n                + useCase + \" for userId=\" + userId + \", sending broadcast of \"\n                + AccountManager.ACTION_ACCOUNT_REMOVED);\n        Intent intent = new Intent(AccountManager.ACTION_ACCOUNT_REMOVED);\n        intent.setFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);\n        intent.setPackage(packageName);\n        intent.putExtra(AccountManager.KEY_ACCOUNT_NAME, account.name);\n        intent.putExtra(AccountManager.KEY_ACCOUNT_TYPE, account.type);\n        mContext.sendBroadcastAsUser(intent, new UserHandle(userId));\n    }\n\n    @Override\n    public boolean onTransact(int code, Parcel data, Parcel reply, int flags)\n            throws RemoteException {\n        try {\n            return super.onTransact(code, data, reply, flags);\n        } catch (RuntimeException e) {\n            // The account manager only throws security exceptions, so let's\n            // log all others.\n            if (!(e instanceof SecurityException || e instanceof IllegalArgumentException)) {\n                Slog.wtf(TAG, \"Account Manager Crash\", e);\n            }\n            throw e;\n        }\n    }\n\n    private UserManager getUserManager() {\n        if (mUserManager == null) {\n            mUserManager = UserManager.get(mContext);\n        }\n        return mUserManager;\n    }\n\n    /**\n     * Validate internal set of accounts against installed authenticators for\n     * given user. Clears cached authenticators before validating.\n     */\n    public void validateAccounts(int userId) {\n        final UserAccounts accounts = getUserAccounts(userId);\n        // Invalidate user-specific cache to make sure we catch any\n        // removed authenticators.\n        validateAccountsInternal(accounts, true /* invalidateAuthenticatorCache */);\n    }\n\n    /**\n     * Validate internal set of accounts against installed authenticators for\n     * given user. Clear cached authenticators before validating when requested.\n     */\n    private void validateAccountsInternal(\n            UserAccounts accounts, boolean invalidateAuthenticatorCache) {\n        if (Log.isLoggable(TAG, Log.DEBUG)) {\n            Log.d(TAG, \"validateAccountsInternal \" + accounts.userId\n                    + \" isCeDatabaseAttached=\" + accounts.accountsDb.isCeDatabaseAttached()\n                    + \" userLocked=\" + mLocalUnlockedUsers.get(accounts.userId));\n        }\n\n        if (invalidateAuthenticatorCache) {\n            mAuthenticatorCache.invalidateCache(accounts.userId);\n        }\n\n        final HashMap<String, Integer> knownAuth = getAuthenticatorTypeAndUIDForUser(\n                mAuthenticatorCache, accounts.userId);\n        boolean userUnlocked = isLocalUnlockedUser(accounts.userId);\n\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                boolean accountDeleted = false;\n\n                // Get a map of stored authenticator types to UID\n                final AccountsDb accountsDb = accounts.accountsDb;\n                Map<String, Integer> metaAuthUid = accountsDb.findMetaAuthUid();\n                // Create a list of authenticator type whose previous uid no longer exists\n                HashSet<String> obsoleteAuthType = Sets.newHashSet();\n                SparseBooleanArray knownUids = null;\n                for (Entry<String, Integer> authToUidEntry : metaAuthUid.entrySet()) {\n                    String type = authToUidEntry.getKey();\n                    int uid = authToUidEntry.getValue();\n                    Integer knownUid = knownAuth.get(type);\n                    if (knownUid != null && uid == knownUid) {\n                        // Remove it from the knownAuth list if it's unchanged.\n                        knownAuth.remove(type);\n                    } else {\n                    /*\n                     * The authenticator is presently not cached and should only be triggered\n                     * when we think an authenticator has been removed (or is being updated).\n                     * But we still want to check if any data with the associated uid is\n                     * around. This is an (imperfect) signal that the package may be updating.\n                     *\n                     * A side effect of this is that an authenticator sharing a uid with\n                     * multiple apps won't get its credentials wiped as long as some app with\n                     * that uid is still on the device. But I suspect that this is a rare case.\n                     * And it isn't clear to me how an attacker could really exploit that\n                     * feature.\n                     *\n                     * The upshot is that we don't have to worry about accounts getting\n                     * uninstalled while the authenticator's package is being updated.\n                     *\n                     */\n                        if (knownUids == null) {\n                            knownUids = getUidsOfInstalledOrUpdatedPackagesAsUser(accounts.userId);\n                        }\n                        if (!knownUids.get(uid)) {\n                            // The authenticator is not presently available to the cache. And the\n                            // package no longer has a data directory (so we surmise it isn't\n                            // updating). So purge its data from the account databases.\n                            obsoleteAuthType.add(type);\n                            // And delete it from the TABLE_META\n                            accountsDb.deleteMetaByAuthTypeAndUid(type, uid);\n                        } else if (knownUid != null && knownUid != uid) {\n                            Slog.w(TAG, \"authenticator no longer exist for type \" + type);\n                            obsoleteAuthType.add(type);\n                            accountsDb.deleteMetaByAuthTypeAndUid(type, uid);\n                        }\n                    }\n                }\n\n                // Add the newly registered authenticator to TABLE_META. If old authenticators have\n                // been re-enabled (after being updated for example), then we just overwrite the old\n                // values.\n                for (Entry<String, Integer> entry : knownAuth.entrySet()) {\n                    accountsDb.insertOrReplaceMetaAuthTypeAndUid(entry.getKey(), entry.getValue());\n                }\n\n                final Map<Long, Account> accountsMap = accountsDb.findAllDeAccounts();\n                try {\n                    accounts.accountCache.clear();\n                    final HashMap<String, ArrayList<String>> accountNamesByType\n                            = new LinkedHashMap<>();\n                    for (Entry<Long, Account> accountEntry : accountsMap.entrySet()) {\n                        final long accountId = accountEntry.getKey();\n                        final Account account = accountEntry.getValue();\n                        if (obsoleteAuthType.contains(account.type)) {\n                            Slog.w(TAG, \"deleting account \" + account.toSafeString()\n                                    + \" because type \" + account.type\n                                    + \"'s registered authenticator no longer exist.\");\n                            Map<String, Integer> packagesToVisibility =\n                                    getRequestingPackages(account, accounts);\n                            List<String> accountRemovedReceivers =\n                                getAccountRemovedReceivers(account, accounts);\n                            accountsDb.beginTransaction();\n                            try {\n                                accountsDb.deleteDeAccount(accountId);\n                                // Also delete from CE table if user is unlocked; if user is\n                                // currently locked the account will be removed later by\n                                // syncDeCeAccountsLocked\n                                if (userUnlocked) {\n                                    accountsDb.deleteCeAccount(accountId);\n                                }\n                                accountsDb.setTransactionSuccessful();\n                            } finally {\n                                accountsDb.endTransaction();\n                            }\n                            accountDeleted = true;\n                            Log.i(TAG, \"validateAccountsInternal#Deleted UserId=\"\n                                    + accounts.userId + \", AccountId=\" + accountId);\n\n                            logRecord(AccountsDb.DEBUG_ACTION_AUTHENTICATOR_REMOVE,\n                                    AccountsDb.TABLE_ACCOUNTS, accountId, accounts);\n\n                            accounts.userDataCache.remove(account);\n                            accounts.authTokenCache.remove(account);\n                            accounts.accountTokenCaches.remove(account);\n                            accounts.visibilityCache.remove(account);\n\n                            for (Entry<String, Integer> packageToVisibility :\n                                    packagesToVisibility.entrySet()) {\n                                if (isVisible(packageToVisibility.getValue())) {\n                                    notifyPackage(packageToVisibility.getKey(), accounts);\n                                }\n                            }\n                            for (String packageName : accountRemovedReceivers) {\n                                sendAccountRemovedBroadcast(\n                                        account,\n                                        packageName,\n                                        accounts.userId,\n                                        /*useCase=*/\"validateAccounts\");\n                            }\n                        } else {\n                            ArrayList<String> accountNames = accountNamesByType.get(account.type);\n                            if (accountNames == null) {\n                                accountNames = new ArrayList<>();\n                                accountNamesByType.put(account.type, accountNames);\n                            }\n                            accountNames.add(account.name);\n                        }\n                    }\n                    for (Map.Entry<String, ArrayList<String>> cur : accountNamesByType.entrySet()) {\n                        final String accountType = cur.getKey();\n                        final ArrayList<String> accountNames = cur.getValue();\n                        final Account[] accountsForType = new Account[accountNames.size()];\n                        for (int i = 0; i < accountsForType.length; i++) {\n                            accountsForType[i] = new Account(accountNames.get(i), accountType,\n                                    UUID.randomUUID().toString());\n                        }\n                        accounts.accountCache.put(accountType, accountsForType);\n                    }\n                    accounts.visibilityCache.putAll(accountsDb.findAllVisibilityValues());\n                    AccountManager.invalidateLocalAccountsDataCaches();\n                } finally {\n                    if (accountDeleted) {\n                        sendAccountsChangedBroadcast(\n                                accounts.userId,\n                                /*accountType=*/\"ambiguous\",\n                                /*useCase=*/\"validateAccounts\");\n                    }\n                }\n            }\n        }\n    }\n\n    private SparseBooleanArray getUidsOfInstalledOrUpdatedPackagesAsUser(int userId) {\n        // Get the UIDs of all apps that might have data on the device. We want\n        // to preserve user data if the app might otherwise be storing data.\n        List<PackageInfo> pkgsWithData =\n                mPackageManager.getInstalledPackagesAsUser(\n                        PackageManager.MATCH_UNINSTALLED_PACKAGES, userId);\n        SparseBooleanArray knownUids = new SparseBooleanArray(pkgsWithData.size());\n        for (PackageInfo pkgInfo : pkgsWithData) {\n            if (pkgInfo.applicationInfo != null\n                    && (pkgInfo.applicationInfo.flags & ApplicationInfo.FLAG_INSTALLED) != 0) {\n                knownUids.put(pkgInfo.applicationInfo.uid, true);\n            }\n        }\n        return knownUids;\n    }\n\n    static HashMap<String, Integer> getAuthenticatorTypeAndUIDForUser(\n            Context context,\n            int userId) {\n        AccountAuthenticatorCache authCache = new AccountAuthenticatorCache(context);\n        return getAuthenticatorTypeAndUIDForUser(authCache, userId);\n    }\n\n    private static HashMap<String, Integer> getAuthenticatorTypeAndUIDForUser(\n            IAccountAuthenticatorCache authCache,\n            int userId) {\n        HashMap<String, Integer> knownAuth = new LinkedHashMap<>();\n        for (RegisteredServicesCache.ServiceInfo<AuthenticatorDescription> service : authCache\n                .getAllServices(userId)) {\n            knownAuth.put(service.type.type, service.uid);\n        }\n        return knownAuth;\n    }\n\n    private UserAccounts getUserAccountsForCaller() {\n        return getUserAccounts(UserHandle.getCallingUserId());\n    }\n\n    protected UserAccounts getUserAccounts(int userId) {\n        try {\n            return getUserAccountsNotChecked(userId);\n        } catch (RuntimeException e) {\n            if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE)) {\n                // Let it go...\n                throw e;\n            }\n            // User accounts database is corrupted, we must wipe out the whole user, otherwise the\n            // system will crash indefinitely\n            Slog.wtf(TAG, \"Removing user \" + userId + \" due to exception (\" + e + \") reading its \"\n                    + \"account database\");\n            if (userId == ActivityManager.getCurrentUser() && userId != UserHandle.USER_SYSTEM) {\n                Slog.i(TAG, \"Switching to system user first\");\n                try {\n                    ActivityManager.getService().switchUser(UserHandle.USER_SYSTEM);\n                } catch (RemoteException re) {\n                    Slog.e(TAG, \"Could not switch to \" + UserHandle.USER_SYSTEM + \": \" + re);\n                }\n            }\n            if (!getUserManager().removeUserEvenWhenDisallowed(userId)) {\n                Slog.e(TAG, \"could not remove user \" + userId);\n            }\n            throw e;\n        }\n    }\n\n    private UserAccounts getUserAccountsNotChecked(int userId) {\n        synchronized (mUsers) {\n            UserAccounts accounts = mUsers.get(userId);\n            boolean validateAccounts = false;\n            if (accounts == null) {\n                File preNDbFile = new File(mInjector.getPreNDatabaseName(userId));\n                File deDbFile = new File(mInjector.getDeDatabaseName(userId));\n                accounts = new UserAccounts(mContext, userId, preNDbFile, deDbFile);\n                mUsers.append(userId, accounts);\n                purgeOldGrants(accounts);\n                AccountManager.invalidateLocalAccountsDataCaches();\n                validateAccounts = true;\n            }\n            // open CE database if necessary\n            if (!accounts.accountsDb.isCeDatabaseAttached() && mLocalUnlockedUsers.get(userId)) {\n                Log.i(TAG, \"User \" + userId + \" is unlocked - opening CE database\");\n                synchronized (accounts.dbLock) {\n                    synchronized (accounts.cacheLock) {\n                        File ceDatabaseFile = new File(mInjector.getCeDatabaseName(userId));\n                        accounts.accountsDb.attachCeDatabase(ceDatabaseFile);\n                    }\n                }\n                syncDeCeAccountsLocked(accounts);\n            }\n            if (validateAccounts) {\n                validateAccountsInternal(accounts, true /* invalidateAuthenticatorCache */);\n            }\n            return accounts;\n        }\n    }\n\n    private void syncDeCeAccountsLocked(UserAccounts accounts) {\n        Preconditions.checkState(Thread.holdsLock(mUsers), \"mUsers lock must be held\");\n        List<Account> accountsToRemove = accounts.accountsDb.findCeAccountsNotInDe();\n        if (!accountsToRemove.isEmpty()) {\n            Slog.i(TAG, accountsToRemove.size()\n                    + \" accounts were previously deleted while user \"\n                    + accounts.userId + \" was locked. Removing accounts from CE tables\");\n            logRecord(accounts, AccountsDb.DEBUG_ACTION_SYNC_DE_CE_ACCOUNTS,\n                    AccountsDb.TABLE_ACCOUNTS);\n\n            for (Account account : accountsToRemove) {\n                removeAccountInternal(accounts, account, Process.SYSTEM_UID);\n            }\n        }\n    }\n\n    private void purgeOldGrantsAll() {\n        synchronized (mUsers) {\n            for (int i = 0; i < mUsers.size(); i++) {\n                purgeOldGrants(mUsers.valueAt(i));\n            }\n        }\n    }\n\n    private void purgeOldGrants(UserAccounts accounts) {\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                List<Integer> uids;\n                try {\n                    uids = accounts.accountsDb.findAllUidGrants();\n                } catch (SQLiteException e) {\n                    Log.w(TAG, \"Could not delete grants for user = \" + accounts.userId, e);\n                    return;\n                }\n                for (int uid : uids) {\n                    final boolean packageExists = mPackageManager.getPackagesForUid(uid) != null;\n                    if (packageExists) {\n                        continue;\n                    }\n                    Log.d(TAG, \"deleting grants for UID \" + uid\n                            + \" because its package is no longer installed\");\n                    accounts.accountsDb.deleteGrantsByUid(uid);\n                }\n            }\n        }\n    }\n\n    private void removeVisibilityValuesForPackage(String packageName) {\n        if (isSpecialPackageKey(packageName)) {\n            return;\n        }\n        synchronized (mUsers) {\n            int numberOfUsers = mUsers.size();\n            for (int i = 0; i < numberOfUsers; i++) {\n                UserAccounts accounts = mUsers.valueAt(i);\n                try {\n                    mPackageManager.getPackageUidAsUser(packageName, accounts.userId);\n                } catch (NameNotFoundException e) {\n                    // package does not exist - remove visibility values\n                    try {\n                        accounts.accountsDb.deleteAccountVisibilityForPackage(packageName);\n                    } catch (SQLiteCantOpenDatabaseException sqlException) {\n                        Log.w(TAG, \"Could not delete account visibility for user = \"\n                                + accounts.userId, sqlException);\n                        continue;\n                    }\n                    synchronized (accounts.dbLock) {\n                        synchronized (accounts.cacheLock) {\n                            for (Account account : accounts.visibilityCache.keySet()) {\n                                Map<String, Integer> accountVisibility =\n                                        getPackagesAndVisibilityForAccountLocked(account, accounts);\n                                accountVisibility.remove(packageName);\n                            }\n                            AccountManager.invalidateLocalAccountsDataCaches();\n                        }\n                    }\n              }\n          }\n        }\n    }\n\n    private void purgeUserData(int userId) {\n        UserAccounts accounts;\n        synchronized (mUsers) {\n            accounts = mUsers.get(userId);\n            mUsers.remove(userId);\n            mLocalUnlockedUsers.delete(userId);\n            AccountManager.invalidateLocalAccountsDataCaches();\n        }\n        if (accounts != null) {\n            synchronized (accounts.dbLock) {\n                synchronized (accounts.cacheLock) {\n                    accounts.accountsDb.closeDebugStatement();\n                    accounts.accountsDb.close();\n                }\n            }\n        }\n    }\n\n    @VisibleForTesting\n    void onUserUnlocked(Intent intent) {\n        onUnlockUser(intent.getIntExtra(Intent.EXTRA_USER_HANDLE, -1));\n    }\n\n    void onUnlockUser(int userId) {\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"onUserUnlocked \" + userId);\n        }\n        synchronized (mUsers) {\n            mLocalUnlockedUsers.put(userId, true);\n        }\n        if (userId < 1) return;\n        mHandler.post(() -> syncSharedAccounts(userId));\n    }\n\n    private void syncSharedAccounts(int userId) {\n        // Check if there's a shared account that needs to be created as an account\n        Account[] sharedAccounts = getSharedAccountsAsUser(userId);\n        if (sharedAccounts == null || sharedAccounts.length == 0) return;\n        Account[] accounts = getAccountsAsUser(null, userId, mContext.getOpPackageName());\n        int parentUserId = UserHandle.USER_SYSTEM;\n        for (Account sa : sharedAccounts) {\n            if (ArrayUtils.contains(accounts, sa)) continue;\n            // Account doesn't exist. Copy it now.\n            copyAccountToUser(null /*no response*/, sa, parentUserId, userId);\n        }\n    }\n\n    @Override\n    public void onServiceChanged(AuthenticatorDescription desc, int userId, boolean removed) {\n        UserInfo user = getUserManager().getUserInfo(userId);\n        if (user == null) {\n            Log.w(TAG, \"onServiceChanged: ignore removed user \" + userId);\n            return;\n        }\n        validateAccountsInternal(getUserAccounts(userId), false /* invalidateAuthenticatorCache */);\n    }\n\n    @Override\n    public String getPassword(Account account) {\n        int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"getPassword: \" + account\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        if (account == null) throw new IllegalArgumentException(\"account is null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot get secrets for accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return readPasswordInternal(accounts, account);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private String readPasswordInternal(UserAccounts accounts, Account account) {\n        if (account == null) {\n            return null;\n        }\n        if (!isLocalUnlockedUser(accounts.userId)) {\n            Log.w(TAG, \"Password is not available - user \" + accounts.userId + \" data is locked\");\n            return null;\n        }\n\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                return accounts.accountsDb\n                        .findAccountPasswordByNameAndType(account.name, account.type);\n            }\n        }\n    }\n\n    @Override\n    public String getPreviousName(Account account) {\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"getPreviousName: \" + account\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        int userId = UserHandle.getCallingUserId();\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return readPreviousNameInternal(accounts, account);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private String readPreviousNameInternal(UserAccounts accounts, Account account) {\n        if  (account == null) {\n            return null;\n        }\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                AtomicReference<String> previousNameRef = accounts.previousNameCache.get(account);\n                if (previousNameRef == null) {\n                    String previousName = accounts.accountsDb.findDeAccountPreviousName(account);\n                    previousNameRef = new AtomicReference<>(previousName);\n                    accounts.previousNameCache.put(account, previousNameRef);\n                    return previousName;\n                } else {\n                    return previousNameRef.get();\n                }\n            }\n        }\n    }\n\n    @Override\n    public String getUserData(Account account, String key) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            String msg = String.format(\"getUserData( account: %s, key: %s, callerUid: %s, pid: %s\",\n                    account, key, callingUid, Binder.getCallingPid());\n            Log.v(TAG, msg);\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        Objects.requireNonNull(key, \"key cannot be null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot get user data for accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        if (!isLocalUnlockedUser(userId)) {\n            Log.w(TAG, \"User \" + userId + \" data is locked. callingUid \" + callingUid);\n            return null;\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            if (!accountExistsCache(accounts, account)) {\n                return null;\n            }\n            return readUserDataInternal(accounts, account, key);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public AuthenticatorDescription[] getAuthenticatorTypes(int userId) {\n        int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"getAuthenticatorTypes: \"\n                    + \"for user id \" + userId\n                    + \" caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        // Only allow the system process to read accounts of other users\n        if (isCrossUser(callingUid, userId)) {\n            throw new SecurityException(\n                    String.format(\n                            \"User %s tying to get authenticator types for %s\" ,\n                            UserHandle.getCallingUserId(),\n                            userId));\n        }\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            return getAuthenticatorTypesInternal(userId, callingUid);\n\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    /**\n     * Should only be called inside of a clearCallingIdentity block.\n     */\n    private AuthenticatorDescription[] getAuthenticatorTypesInternal(int userId, int callingUid) {\n        mAuthenticatorCache.updateServices(userId);\n        Collection<AccountAuthenticatorCache.ServiceInfo<AuthenticatorDescription>>\n                authenticatorCollection = mAuthenticatorCache.getAllServices(userId);\n        final List<AuthenticatorDescription> types =\n                new ArrayList<>(authenticatorCollection.size());\n        for (AccountAuthenticatorCache.ServiceInfo<AuthenticatorDescription> authenticator\n                : authenticatorCollection) {\n            if (canCallerAccessPackage(authenticator.type.packageName, callingUid, userId)) {\n                types.add(authenticator.type);\n            }\n        }\n        return types.toArray(new AuthenticatorDescription[types.size()]);\n    }\n\n    private boolean isCrossUser(int callingUid, int userId) {\n        return (userId != UserHandle.getCallingUserId()\n                && callingUid != Process.SYSTEM_UID\n                && mContext.checkCallingOrSelfPermission(\n                        android.Manifest.permission.INTERACT_ACROSS_USERS_FULL)\n                                != PackageManager.PERMISSION_GRANTED);\n    }\n\n    @Override\n    public boolean addAccountExplicitly(\n            Account account, String password, Bundle extras, String opPackageName) {\n        return addAccountExplicitlyWithVisibility(\n                account, password, extras, /* packageToVisibility= */ null, opPackageName);\n    }\n\n    @Override\n    public void copyAccountToUser(final IAccountManagerResponse response, final Account account,\n            final int userFrom, int userTo) {\n        int callingUid = Binder.getCallingUid();\n        if (isCrossUser(callingUid, UserHandle.USER_ALL)) {\n            throw new SecurityException(\"Calling copyAccountToUser requires \"\n                    + android.Manifest.permission.INTERACT_ACROSS_USERS_FULL);\n        }\n        final UserAccounts fromAccounts = getUserAccounts(userFrom);\n        final UserAccounts toAccounts = getUserAccounts(userTo);\n        if (fromAccounts == null || toAccounts == null) {\n            if (response != null) {\n                Bundle result = new Bundle();\n                result.putBoolean(AccountManager.KEY_BOOLEAN_RESULT, false);\n                try {\n                    response.onResult(result);\n                } catch (RemoteException e) {\n                    Slog.w(TAG, \"Failed to report error back to the client.\" + e);\n                }\n            }\n            return;\n        }\n\n        Slog.d(TAG, \"Copying account \" + account.toSafeString()\n                + \" from user \" + userFrom + \" to user \" + userTo);\n        final long identityToken = clearCallingIdentity();\n        try {\n            new Session(fromAccounts, response, account.type, false,\n                    false /* stripAuthTokenFromResult */, account.name,\n                    false /* authDetailsRequired */) {\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now) + \", getAccountCredentialsForClone\"\n                            + \", \" + account.type;\n                }\n\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.getAccountCredentialsForCloning(this, account);\n                }\n\n                @Override\n                public void onResult(Bundle result) {\n                    Bundle.setDefusable(result, true);\n                    if (result != null\n                            && result.getBoolean(AccountManager.KEY_BOOLEAN_RESULT, false)) {\n                        // Create a Session for the target user and pass in the bundle\n                        completeCloningAccount(response, result, account, toAccounts, userFrom);\n                    } else {\n                        super.onResult(result);\n                    }\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public boolean accountAuthenticated(final Account account) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            String msg = String.format(\n                    \"accountAuthenticated( account: %s, callerUid: %s)\",\n                    account,\n                    callingUid);\n            Log.v(TAG, msg);\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot notify authentication for accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n\n        if (!canUserModifyAccounts(userId, callingUid) ||\n                !canUserModifyAccountsForType(userId, account.type, callingUid)) {\n            return false;\n        }\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return updateLastAuthenticatedTime(account);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private boolean updateLastAuthenticatedTime(Account account) {\n        final UserAccounts accounts = getUserAccountsForCaller();\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                return accounts.accountsDb.updateAccountLastAuthenticatedTime(account);\n            }\n        }\n    }\n\n    private void completeCloningAccount(IAccountManagerResponse response,\n            final Bundle accountCredentials, final Account account, final UserAccounts targetUser,\n            final int parentUserId){\n        Bundle.setDefusable(accountCredentials, true);\n        final long id = clearCallingIdentity();\n        try {\n            new Session(targetUser, response, account.type, false,\n                    false /* stripAuthTokenFromResult */, account.name,\n                    false /* authDetailsRequired */) {\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now) + \", getAccountCredentialsForClone\"\n                            + \", \" + account.type;\n                }\n\n                @Override\n                public void run() throws RemoteException {\n                    // Confirm that the owner's account still exists before this step.\n                    for (Account acc : getAccounts(parentUserId, mContext.getOpPackageName())) {\n                        if (acc.equals(account)) {\n                            mAuthenticator.addAccountFromCredentials(\n                                    this, account, accountCredentials);\n                            break;\n                        }\n                    }\n                }\n\n                @Override\n                public void onResult(Bundle result) {\n                    Bundle.setDefusable(result, true);\n                    // TODO: Anything to do if if succedded?\n                    // TODO: If it failed: Show error notification? Should we remove the shadow\n                    // account to avoid retries?\n                    // TODO: what we do with the visibility?\n\n                    super.onResult(result);\n                }\n\n                @Override\n                public void onError(int errorCode, String errorMessage) {\n                    super.onError(errorCode,  errorMessage);\n                    // TODO: Show error notification to user\n                    // TODO: Should we remove the shadow account so that it doesn't keep trying?\n                }\n\n            }.bind();\n        } finally {\n            restoreCallingIdentity(id);\n        }\n    }\n\n    private boolean addAccountInternal(UserAccounts accounts, Account account, String password,\n            Bundle extras, int callingUid, Map<String, Integer> packageToVisibility,\n            String opPackageName) {\n        Bundle.setDefusable(extras, true);\n        if (account == null) {\n            return false;\n        }\n        if (account.name != null && account.name.length() > 200) {\n            Log.w(TAG, \"Account cannot be added - Name longer than 200 chars\");\n            return false;\n        }\n        if (account.type != null && account.type.length() > 200) {\n            Log.w(TAG, \"Account cannot be added - Name longer than 200 chars\");\n            return false;\n        }\n        if (!isLocalUnlockedUser(accounts.userId)) {\n            Log.w(TAG, \"Account \" + account.toSafeString() + \" cannot be added - user \"\n                    + accounts.userId + \" is locked. callingUid=\" + callingUid);\n            return false;\n        }\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                accounts.accountsDb.beginTransaction();\n                try {\n                    if (accounts.accountsDb.findCeAccountId(account) >= 0) {\n                        Log.w(TAG, \"insertAccountIntoDatabase: \" + account.toSafeString()\n                                + \", skipping since the account already exists\");\n                        return false;\n                    }\n                    if (accounts.accountsDb.findAllDeAccounts().size() > 100) {\n                        Log.w(TAG, \"insertAccountIntoDatabase: \" + account.toSafeString()\n                                + \", skipping since more than 100 accounts on device exist\");\n                        return false;\n                    }\n                    long accountId = accounts.accountsDb.insertCeAccount(account, password);\n                    if (accountId < 0) {\n                        Log.w(TAG, \"insertAccountIntoDatabase: \" + account.toSafeString()\n                                + \", skipping the DB insert failed\");\n                        return false;\n                    }\n                    // Insert into DE table\n                    if (accounts.accountsDb.insertDeAccount(account, accountId) < 0) {\n                        Log.w(TAG, \"insertAccountIntoDatabase: \" + account.toSafeString()\n                                + \", skipping the DB insert failed\");\n                        return false;\n                    }\n                    if (extras != null) {\n                        for (String key : extras.keySet()) {\n                            final String value = extras.getString(key);\n                            if (accounts.accountsDb.insertExtra(accountId, key, value) < 0) {\n                                Log.w(TAG, \"insertAccountIntoDatabase: \"\n                                        + account.toSafeString()\n                                        + \", skipping since insertExtra failed for key \" + key);\n                                return false;\n                            } else {\n                                AccountManager.invalidateLocalAccountUserDataCaches();\n                            }\n                        }\n                    }\n\n                    if (packageToVisibility != null) {\n                        for (Entry<String, Integer> entry : packageToVisibility.entrySet()) {\n                            setAccountVisibility(account, entry.getKey() /* package */,\n                                    entry.getValue() /* visibility */, false /* notify */,\n                                    accounts, callingUid);\n                        }\n                    }\n                    accounts.accountsDb.setTransactionSuccessful();\n\n                    logRecord(AccountsDb.DEBUG_ACTION_ACCOUNT_ADD, AccountsDb.TABLE_ACCOUNTS,\n                            accountId,\n                            accounts, callingUid);\n\n                    insertAccountIntoCacheLocked(accounts, account);\n                } finally {\n                    accounts.accountsDb.endTransaction();\n                }\n            }\n        }\n        if (getUserManager().getUserInfo(accounts.userId).canHaveProfile()) {\n            addAccountToLinkedRestrictedUsers(account, accounts.userId);\n        }\n\n        sendNotificationAccountUpdated(account, accounts);\n        // Only send LOGIN_ACCOUNTS_CHANGED when the database changed.\n        Log.i(TAG, \"callingUid=\" + callingUid + \", userId=\" + accounts.userId\n                + \" added account\");\n        sendAccountsChangedBroadcast(accounts.userId, account.type, /*useCase=*/\"addAccount\");\n\n        logAddAccountExplicitlyMetrics(opPackageName, account.type, packageToVisibility);\n        return true;\n    }\n\n    private void logAddAccountExplicitlyMetrics(\n            String callerPackage, String accountType,\n            @Nullable Map<String, Integer> accountVisibility) {\n        // Although this is not a 'device policy' API, enterprise is the current use case.\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.ADD_ACCOUNT_EXPLICITLY)\n                .setStrings(\n                        TextUtils.emptyIfNull(accountType),\n                        TextUtils.emptyIfNull(callerPackage),\n                        findPackagesPerVisibility(accountVisibility))\n                .write();\n    }\n\n    private String[] findPackagesPerVisibility(@Nullable Map<String, Integer> accountVisibility) {\n        Map<Integer, Set<String>> packagesPerVisibility = new HashMap<>();\n        if (accountVisibility != null) {\n            for (Entry<String, Integer> entry : accountVisibility.entrySet()) {\n                if (!packagesPerVisibility.containsKey(entry.getValue())) {\n                    packagesPerVisibility.put(entry.getValue(), new HashSet<>());\n                }\n                packagesPerVisibility.get(entry.getValue()).add(entry.getKey());\n            }\n        }\n\n        String[] packagesPerVisibilityStr = new String[5];\n        packagesPerVisibilityStr[AccountManager.VISIBILITY_UNDEFINED] = getPackagesForVisibilityStr(\n                AccountManager.VISIBILITY_UNDEFINED, packagesPerVisibility);\n        packagesPerVisibilityStr[AccountManager.VISIBILITY_VISIBLE] = getPackagesForVisibilityStr(\n                AccountManager.VISIBILITY_VISIBLE, packagesPerVisibility);\n        packagesPerVisibilityStr[AccountManager.VISIBILITY_USER_MANAGED_VISIBLE] =\n                getPackagesForVisibilityStr(\n                        AccountManager.VISIBILITY_USER_MANAGED_VISIBLE, packagesPerVisibility);\n        packagesPerVisibilityStr[AccountManager.VISIBILITY_NOT_VISIBLE] =\n                getPackagesForVisibilityStr(\n                        AccountManager.VISIBILITY_NOT_VISIBLE, packagesPerVisibility);\n        packagesPerVisibilityStr[AccountManager.VISIBILITY_USER_MANAGED_NOT_VISIBLE] =\n                getPackagesForVisibilityStr(\n                        AccountManager.VISIBILITY_USER_MANAGED_NOT_VISIBLE, packagesPerVisibility);\n        return packagesPerVisibilityStr;\n    }\n\n    private String getPackagesForVisibilityStr(\n            int visibility, Map<Integer, Set<String>> packagesPerVisibility) {\n        return visibility + \":\"\n                + (packagesPerVisibility.containsKey(visibility)\n                    ? TextUtils.join(\",\", packagesPerVisibility.get(visibility))\n                    : \"\");\n    }\n\n    private boolean isLocalUnlockedUser(int userId) {\n        synchronized (mUsers) {\n            return mLocalUnlockedUsers.get(userId);\n        }\n    }\n\n    /**\n     * Adds the account to all linked restricted users as shared accounts. If the user is currently\n     * running, then clone the account too.\n     * @param account the account to share with limited users\n     *\n     */\n    private void addAccountToLinkedRestrictedUsers(Account account, int parentUserId) {\n        List<UserInfo> users = getUserManager().getUsers();\n        for (UserInfo user : users) {\n            if (user.isRestricted() && (parentUserId == user.restrictedProfileParentId)) {\n                addSharedAccountAsUser(account, user.id);\n                if (isLocalUnlockedUser(user.id)) {\n                    mHandler.sendMessage(mHandler.obtainMessage(\n                            MESSAGE_COPY_SHARED_ACCOUNT, parentUserId, user.id, account));\n                }\n            }\n        }\n    }\n\n    @Override\n    public void hasFeatures(IAccountManagerResponse response,\n            Account account, String[] features, int userId, String opPackageName) {\n        int callingUid = Binder.getCallingUid();\n        mAppOpsManager.checkPackage(callingUid, opPackageName);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"hasFeatures: \" + account\n                    + \", response \" + response\n                    + \", features \" + Arrays.toString(features)\n                    + \", caller's uid \" + callingUid\n                    + \", userId \" + userId\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Preconditions.checkArgument(account != null, \"account cannot be null\");\n        Preconditions.checkArgument(response != null, \"response cannot be null\");\n        Preconditions.checkArgument(features != null, \"features cannot be null\");\n\n        if (userId != UserHandle.getCallingUserId()\n                && callingUid != Process.SYSTEM_UID\n                && mContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.INTERACT_ACROSS_USERS_FULL)\n                != PackageManager.PERMISSION_GRANTED) {\n            throw new SecurityException(\"User \" + UserHandle.getCallingUserId()\n                    + \" trying to check account features for \" + userId);\n        }\n\n        checkReadAccountsPermitted(callingUid, account.type, userId,\n                opPackageName);\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            new TestFeaturesSession(accounts, response, account, features).bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private class TestFeaturesSession extends Session {\n        private final String[] mFeatures;\n        private final Account mAccount;\n\n        public TestFeaturesSession(UserAccounts accounts, IAccountManagerResponse response,\n                Account account, String[] features) {\n            super(accounts, response, account.type, false /* expectActivityLaunch */,\n                    true /* stripAuthTokenFromResult */, account.name,\n                    false /* authDetailsRequired */);\n            mFeatures = features;\n            mAccount = account;\n        }\n\n        @Override\n        public void run() throws RemoteException {\n            try {\n                mAuthenticator.hasFeatures(this, mAccount, mFeatures);\n            } catch (RemoteException e) {\n                onError(AccountManager.ERROR_CODE_REMOTE_EXCEPTION, \"remote exception\");\n            }\n        }\n\n        @Override\n        public void onResult(Bundle result) {\n            Bundle.setDefusable(result, true);\n            IAccountManagerResponse response = getResponseAndClose();\n            if (response != null) {\n                try {\n                    if (result == null) {\n                        response.onError(AccountManager.ERROR_CODE_INVALID_RESPONSE, \"null bundle\");\n                        return;\n                    }\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, getClass().getSimpleName() + \" calling onResult() on response \"\n                                + response);\n                    }\n                    final Bundle newResult = new Bundle();\n                    newResult.putBoolean(AccountManager.KEY_BOOLEAN_RESULT,\n                            result.getBoolean(AccountManager.KEY_BOOLEAN_RESULT, false));\n                    response.onResult(newResult);\n                } catch (RemoteException e) {\n                    // if the caller is dead then there is no one to care about remote exceptions\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, \"failure while notifying response\", e);\n                    }\n                }\n            }\n        }\n\n        @Override\n        protected String toDebugString(long now) {\n            return super.toDebugString(now) + \", hasFeatures\"\n                    + \", \" + mAccount\n                    + \", \" + (mFeatures != null ? TextUtils.join(\",\", mFeatures) : null);\n        }\n    }\n\n    @Override\n    public void renameAccount(\n            IAccountManagerResponse response, Account accountToRename, String newName) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"renameAccount: \" + accountToRename + \" -> \" + newName\n                + \", caller's uid \" + callingUid\n                + \", pid \" + Binder.getCallingPid());\n        }\n        if (accountToRename == null) throw new IllegalArgumentException(\"account is null\");\n        if (newName != null && newName.length() > 200) {\n            Log.e(TAG, \"renameAccount failed - account name longer than 200\");\n            throw new IllegalArgumentException(\"account name longer than 200\");\n        }\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(accountToRename.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot rename accounts of type: %s\",\n                    callingUid,\n                    accountToRename.type);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            Log.i(TAG, \"callingUid=\" + callingUid + \", userId=\" + accounts.userId\n                    + \" performing rename account\");\n            Account resultingAccount = renameAccountInternal(accounts, accountToRename, newName);\n            if (resultingAccount == null) {\n                resultingAccount = accountToRename;\n            }\n            Bundle result = new Bundle();\n            result.putString(AccountManager.KEY_ACCOUNT_NAME, resultingAccount.name);\n            result.putString(AccountManager.KEY_ACCOUNT_TYPE, resultingAccount.type);\n            result.putString(AccountManager.KEY_ACCOUNT_ACCESS_ID,\n                    resultingAccount.getAccessId());\n            try {\n                response.onResult(result);\n            } catch (RemoteException e) {\n                Log.w(TAG, e.getMessage());\n            }\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private Account renameAccountInternal(\n            UserAccounts accounts, Account accountToRename, String newName) {\n        Account resultAccount = null;\n        /*\n         * Cancel existing notifications. Let authenticators\n         * re-post notifications as required. But we don't know if\n         * the authenticators have bound their notifications to\n         * now stale account name data.\n         *\n         * With a rename api, we might not need to do this anymore but it\n         * shouldn't hurt.\n         */\n        cancelNotification(\n                getSigninRequiredNotificationId(accounts, accountToRename),\n                accounts);\n        synchronized(accounts.credentialsPermissionNotificationIds) {\n            for (Pair<Pair<Account, String>, Integer> pair:\n                    accounts.credentialsPermissionNotificationIds.keySet()) {\n                if (accountToRename.equals(pair.first.first)) {\n                    NotificationId id = accounts.credentialsPermissionNotificationIds.get(pair);\n                    cancelNotification(id, accounts);\n                }\n            }\n        }\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                List<String> accountRemovedReceivers =\n                    getAccountRemovedReceivers(accountToRename, accounts);\n                accounts.accountsDb.beginTransaction();\n                Account renamedAccount = new Account(newName, accountToRename.type);\n                try {\n                    if ((accounts.accountsDb.findCeAccountId(renamedAccount) >= 0)) {\n                        Log.e(TAG, \"renameAccount failed - account with new name already exists\");\n                        return null;\n                    }\n                    final long accountId = accounts.accountsDb.findDeAccountId(accountToRename);\n                    if (accountId >= 0) {\n                        accounts.accountsDb.renameCeAccount(accountId, newName);\n                        if (accounts.accountsDb.renameDeAccount(\n                                accountId, newName, accountToRename.name)) {\n                            accounts.accountsDb.setTransactionSuccessful();\n                        } else {\n                            Log.e(TAG, \"renameAccount failed\");\n                            return null;\n                        }\n                    } else {\n                        Log.e(TAG, \"renameAccount failed - old account does not exist\");\n                        return null;\n                    }\n                } finally {\n                    accounts.accountsDb.endTransaction();\n                }\n            /*\n             * Database transaction was successful. Clean up cached\n             * data associated with the account in the user profile.\n             */\n                renamedAccount = insertAccountIntoCacheLocked(accounts, renamedAccount);\n            /*\n             * Extract the data and token caches before removing the\n             * old account to preserve the user data associated with\n             * the account.\n             */\n                Map<String, String> tmpData = accounts.userDataCache.get(accountToRename);\n                Map<String, String> tmpTokens = accounts.authTokenCache.get(accountToRename);\n                Map<String, Integer> tmpVisibility = accounts.visibilityCache.get(accountToRename);\n                removeAccountFromCacheLocked(accounts, accountToRename);\n            /*\n             * Update the cached data associated with the renamed\n             * account.\n             */\n                accounts.userDataCache.put(renamedAccount, tmpData);\n                accounts.authTokenCache.put(renamedAccount, tmpTokens);\n                accounts.visibilityCache.put(renamedAccount, tmpVisibility);\n                accounts.previousNameCache.put(\n                        renamedAccount,\n                        new AtomicReference<>(accountToRename.name));\n                resultAccount = renamedAccount;\n\n                int parentUserId = accounts.userId;\n                if (canHaveProfile(parentUserId)) {\n                /*\n                 * Owner or system user account was renamed, rename the account for\n                 * those users with which the account was shared.\n                 */\n                    List<UserInfo> users = getUserManager().getAliveUsers();\n                    for (UserInfo user : users) {\n                        if (user.isRestricted()\n                                && (user.restrictedProfileParentId == parentUserId)) {\n                            renameSharedAccountAsUser(accountToRename, newName, user.id);\n                        }\n                    }\n                }\n\n                sendNotificationAccountUpdated(resultAccount, accounts);\n                sendAccountsChangedBroadcast(\n                        accounts.userId, accountToRename.type, /*useCase=*/\"renameAccount\");\n                for (String packageName : accountRemovedReceivers) {\n                    sendAccountRemovedBroadcast(\n                            accountToRename,\n                            packageName,\n                            accounts.userId,\n                            /*useCase=*/\"renameAccount\");\n                }\n\n                AccountManager.invalidateLocalAccountsDataCaches();\n                AccountManager.invalidateLocalAccountUserDataCaches();\n            }\n        }\n        return resultAccount;\n    }\n\n    private boolean canHaveProfile(final int parentUserId) {\n        final UserInfo userInfo = getUserManager().getUserInfo(parentUserId);\n        return userInfo != null && userInfo.canHaveProfile();\n    }\n\n    @Override\n    public void removeAccountAsUser(IAccountManagerResponse response, Account account,\n            boolean expectActivityLaunch, int userId) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"removeAccount: \" + account\n                    + \", response \" + response\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid()\n                    + \", for user id \" + userId);\n        }\n        Preconditions.checkArgument(account != null, \"account cannot be null\");\n        Preconditions.checkArgument(response != null, \"response cannot be null\");\n\n        // Only allow the system process to modify accounts of other users\n        if (isCrossUser(callingUid, userId)) {\n            throw new SecurityException(\n                    String.format(\n                            \"User %s tying remove account for %s\" ,\n                            UserHandle.getCallingUserId(),\n                            userId));\n        }\n        /*\n         * Only the system, authenticator or profile owner should be allowed to remove accounts for\n         * that authenticator.  This will let users remove accounts (via Settings in the system) but\n         * not arbitrary applications (like competing authenticators).\n         */\n        UserHandle user = UserHandle.of(userId);\n        if (!isAccountManagedByCaller(account.type, callingUid, user.getIdentifier())\n                && !isSystemUid(callingUid)\n                && !isProfileOwner(callingUid)) {\n            String msg = String.format(\n                    \"uid %s cannot remove accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        if (!canUserModifyAccounts(userId, callingUid)) {\n            try {\n                response.onError(AccountManager.ERROR_CODE_USER_RESTRICTED,\n                        \"User cannot modify accounts\");\n            } catch (RemoteException re) {\n            }\n            return;\n        }\n        if (!canUserModifyAccountsForType(userId, account.type, callingUid)) {\n            try {\n                response.onError(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                        \"User cannot modify accounts of this type (policy).\");\n            } catch (RemoteException re) {\n                Log.w(TAG, \"RemoteException while removing account\", re);\n            }\n            return;\n        }\n        if (isFirstAccountRemovalDisabled(account)) {\n            try {\n                response.onError(\n                        AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                        \"User cannot remove the first \"\n                                + account.type\n                                + \" account on the device.\");\n            } catch (RemoteException re) {\n                Log.w(TAG, \"RemoteException while removing account\", re);\n            }\n            return;\n        }\n        final long identityToken = clearCallingIdentity();\n        UserAccounts accounts = getUserAccounts(userId);\n        cancelNotification(getSigninRequiredNotificationId(accounts, account), accounts);\n        synchronized(accounts.credentialsPermissionNotificationIds) {\n            for (Pair<Pair<Account, String>, Integer> pair:\n                accounts.credentialsPermissionNotificationIds.keySet()) {\n                if (account.equals(pair.first.first)) {\n                    NotificationId id = accounts.credentialsPermissionNotificationIds.get(pair);\n                    cancelNotification(id, accounts);\n                }\n            }\n        }\n        final long accountId = accounts.accountsDb.findDeAccountId(account);\n        logRecord(\n                AccountsDb.DEBUG_ACTION_CALLED_ACCOUNT_REMOVE,\n                AccountsDb.TABLE_ACCOUNTS,\n                accountId,\n                accounts,\n                callingUid);\n        try {\n            new RemoveAccountSession(accounts, response, account, expectActivityLaunch).bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public boolean removeAccountExplicitly(Account account) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"removeAccountExplicitly: \" + account\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        int userId = Binder.getCallingUserHandle().getIdentifier();\n        if (account == null) {\n            /*\n             * Null accounts should result in returning false, as per\n             * AccountManage.addAccountExplicitly(...) java doc.\n             */\n            Log.e(TAG, \"account is null\");\n            return false;\n        } else if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot explicitly remove accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        if (isFirstAccountRemovalDisabled(account)) {\n            Log.e(TAG, \"Cannot remove the first \" + account.type + \" account on the device.\");\n            return false;\n        }\n        UserAccounts accounts = getUserAccountsForCaller();\n        final long accountId = accounts.accountsDb.findDeAccountId(account);\n        logRecord(\n                AccountsDb.DEBUG_ACTION_CALLED_ACCOUNT_REMOVE,\n                AccountsDb.TABLE_ACCOUNTS,\n                accountId,\n                accounts,\n                callingUid);\n        final long identityToken = clearCallingIdentity();\n        try {\n            return removeAccountInternal(accounts, account, callingUid);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private class RemoveAccountSession extends Session {\n        final Account mAccount;\n        public RemoveAccountSession(UserAccounts accounts, IAccountManagerResponse response,\n                Account account, boolean expectActivityLaunch) {\n            super(accounts, response, account.type, expectActivityLaunch,\n                    true /* stripAuthTokenFromResult */, account.name,\n                    false /* authDetailsRequired */);\n            mAccount = account;\n        }\n\n        @Override\n        protected String toDebugString(long now) {\n            return super.toDebugString(now) + \", removeAccount\"\n                    + \", account \" + mAccount;\n        }\n\n        @Override\n        public void run() throws RemoteException {\n            mAuthenticator.getAccountRemovalAllowed(this, mAccount);\n        }\n\n        @Override\n        public void onResult(Bundle result) {\n            Bundle.setDefusable(result, true);\n            if (result != null && result.containsKey(AccountManager.KEY_BOOLEAN_RESULT)\n                    && !result.containsKey(AccountManager.KEY_INTENT)) {\n                final boolean removalAllowed = result.getBoolean(AccountManager.KEY_BOOLEAN_RESULT);\n                if (removalAllowed) {\n                    removeAccountInternal(mAccounts, mAccount, getCallingUid());\n                }\n                IAccountManagerResponse response = getResponseAndClose();\n                if (response != null) {\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, getClass().getSimpleName() + \" calling onResult() on response \"\n                                + response);\n                    }\n                    try {\n                        response.onResult(result);\n                    } catch (RemoteException e) {\n                        Slog.e(TAG, \"Error calling onResult()\", e);\n                    }\n                }\n            }\n            super.onResult(result);\n        }\n    }\n\n    @VisibleForTesting\n    protected void removeAccountInternal(Account account) {\n        removeAccountInternal(getUserAccountsForCaller(), account, getCallingUid());\n    }\n\n    private boolean removeAccountInternal(UserAccounts accounts, Account account, int callingUid) {\n        boolean isChanged = false;\n        boolean userUnlocked = isLocalUnlockedUser(accounts.userId);\n        if (!userUnlocked) {\n            Slog.i(TAG, \"Removing account \" + account.toSafeString()\n                    + \" while user \" + accounts.userId\n                    + \" is still locked. CE data will be removed later\");\n        }\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                Map<String, Integer> packagesToVisibility = getRequestingPackages(account,\n                        accounts);\n                List<String> accountRemovedReceivers =\n                    getAccountRemovedReceivers(account, accounts);\n                accounts.accountsDb.beginTransaction();\n                // Set to a placeholder value, this will only be used if the database\n                // transaction succeeds.\n                long accountId = -1;\n                try {\n                    accountId = accounts.accountsDb.findDeAccountId(account);\n                    if (accountId >= 0) {\n                        isChanged = accounts.accountsDb.deleteDeAccount(accountId);\n                    }\n                    // always delete from CE table if CE storage is available\n                    // DE account could be removed while CE was locked\n                    if (userUnlocked) {\n                        long ceAccountId = accounts.accountsDb.findCeAccountId(account);\n                        if (ceAccountId >= 0) {\n                            accounts.accountsDb.deleteCeAccount(ceAccountId);\n                        }\n                    }\n                    accounts.accountsDb.setTransactionSuccessful();\n                } finally {\n                    accounts.accountsDb.endTransaction();\n                }\n                if (isChanged) {\n                    removeAccountFromCacheLocked(accounts, account);\n                    for (Entry<String, Integer> packageToVisibility : packagesToVisibility\n                            .entrySet()) {\n                        if ((packageToVisibility.getValue() == AccountManager.VISIBILITY_VISIBLE)\n                                || (packageToVisibility.getValue()\n                                    == AccountManager.VISIBILITY_USER_MANAGED_VISIBLE)) {\n                            notifyPackage(packageToVisibility.getKey(), accounts);\n                        }\n                    }\n\n                    // Only broadcast LOGIN_ACCOUNTS_CHANGED if a change occurred.\n                    Log.i(TAG, \"callingUid=\" + callingUid + \", userId=\" + accounts.userId\n                            + \" removed account\");\n                    sendAccountsChangedBroadcast(\n                            accounts.userId, account.type, /*useCase=*/\"removeAccount\");\n                    for (String packageName : accountRemovedReceivers) {\n                        sendAccountRemovedBroadcast(\n                                account, packageName, accounts.userId, /*useCase=*/\"removeAccount\");\n                    }\n                    String action = userUnlocked ? AccountsDb.DEBUG_ACTION_ACCOUNT_REMOVE\n                            : AccountsDb.DEBUG_ACTION_ACCOUNT_REMOVE_DE;\n                    logRecord(action, AccountsDb.TABLE_ACCOUNTS, accountId, accounts);\n                }\n            }\n        }\n        final long id = Binder.clearCallingIdentity();\n        try {\n            int parentUserId = accounts.userId;\n            if (canHaveProfile(parentUserId)) {\n                // Remove from any restricted profiles that are sharing this account.\n                List<UserInfo> users = getUserManager().getAliveUsers();\n                for (UserInfo user : users) {\n                    if (user.isRestricted() && parentUserId == (user.restrictedProfileParentId)) {\n                        removeSharedAccountAsUser(account, user.id, callingUid);\n                    }\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(id);\n        }\n\n        if (isChanged) {\n            synchronized (accounts.credentialsPermissionNotificationIds) {\n                for (Pair<Pair<Account, String>, Integer> key\n                        : accounts.credentialsPermissionNotificationIds.keySet()) {\n                    if (account.equals(key.first.first)\n                            && AccountManager.ACCOUNT_ACCESS_TOKEN_TYPE.equals(key.first.second)) {\n                        final int uid = (Integer) key.second;\n                        mHandler.post(() -> cancelAccountAccessRequestNotificationIfNeeded(\n                                account, uid, false, accounts));\n                    }\n                }\n            }\n        }\n\n        AccountManager.invalidateLocalAccountUserDataCaches();\n\n        return isChanged;\n    }\n\n    @Override\n    public void invalidateAuthToken(String accountType, String authToken) {\n        int callerUid = Binder.getCallingUid();\n        Objects.requireNonNull(accountType, \"accountType cannot be null\");\n        Objects.requireNonNull(authToken, \"authToken cannot be null\");\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"invalidateAuthToken: accountType \" + accountType\n                    + \", caller's uid \" + callerUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        int userId = UserHandle.getCallingUserId();\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            List<Pair<Account, String>> deletedTokens;\n            synchronized (accounts.dbLock) {\n                accounts.accountsDb.beginTransaction();\n                try {\n                    deletedTokens = invalidateAuthTokenLocked(accounts, accountType, authToken);\n                    accounts.accountsDb.setTransactionSuccessful();\n                } finally {\n                    accounts.accountsDb.endTransaction();\n                }\n                synchronized (accounts.cacheLock) {\n                    for (Pair<Account, String> tokenInfo : deletedTokens) {\n                        Account act = tokenInfo.first;\n                        String tokenType = tokenInfo.second;\n                        writeAuthTokenIntoCacheLocked(accounts, act, tokenType, null);\n                    }\n                    // wipe out cached token in memory.\n                    accounts.accountTokenCaches.remove(accountType, authToken);\n                }\n            }\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private List<Pair<Account, String>> invalidateAuthTokenLocked(UserAccounts accounts, String accountType,\n            String authToken) {\n        // TODO Move to AccountsDB\n        List<Pair<Account, String>> results = new ArrayList<>();\n        Cursor cursor = accounts.accountsDb.findAuthtokenForAllAccounts(accountType, authToken);\n\n        try {\n            while (cursor.moveToNext()) {\n                String authTokenId = cursor.getString(0);\n                String accountName = cursor.getString(1);\n                String authTokenType = cursor.getString(2);\n                accounts.accountsDb.deleteAuthToken(authTokenId);\n                results.add(Pair.create(new Account(accountName, accountType), authTokenType));\n            }\n        } finally {\n            cursor.close();\n        }\n        return results;\n    }\n\n    private void saveCachedToken(\n            UserAccounts accounts,\n            Account account,\n            String callerPkg,\n            byte[] callerSigDigest,\n            String tokenType,\n            String token,\n            long expiryMillis) {\n\n        if (account == null || tokenType == null || callerPkg == null || callerSigDigest == null) {\n            return;\n        }\n        cancelNotification(getSigninRequiredNotificationId(accounts, account), accounts);\n        synchronized (accounts.cacheLock) {\n            accounts.accountTokenCaches.put(\n                    account, token, tokenType, callerPkg, callerSigDigest, expiryMillis);\n        }\n    }\n\n    private boolean saveAuthTokenToDatabase(UserAccounts accounts, Account account, String type,\n            String authToken) {\n        if (account == null || type == null) {\n            return false;\n        }\n        cancelNotification(getSigninRequiredNotificationId(accounts, account), accounts);\n        synchronized (accounts.dbLock) {\n            accounts.accountsDb.beginTransaction();\n            boolean updateCache = false;\n            try {\n                long accountId = accounts.accountsDb.findDeAccountId(account);\n                if (accountId < 0) {\n                    return false;\n                }\n                accounts.accountsDb.deleteAuthtokensByAccountIdAndType(accountId, type);\n                if (accounts.accountsDb.insertAuthToken(accountId, type, authToken) >= 0) {\n                    accounts.accountsDb.setTransactionSuccessful();\n                    updateCache = true;\n                    return true;\n                }\n                return false;\n            } finally {\n                accounts.accountsDb.endTransaction();\n                if (updateCache) {\n                    synchronized (accounts.cacheLock) {\n                        writeAuthTokenIntoCacheLocked(accounts, account, type, authToken);\n                    }\n                }\n            }\n        }\n    }\n\n    @Override\n    public String peekAuthToken(Account account, String authTokenType) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"peekAuthToken: \" + account\n                    + \", authTokenType \" + authTokenType\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        Objects.requireNonNull(authTokenType, \"authTokenType cannot be null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot peek the authtokens associated with accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        if (!isLocalUnlockedUser(userId)) {\n            Log.w(TAG, \"Authtoken not available - user \" + userId + \" data is locked. callingUid \"\n                    + callingUid);\n            return null;\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return readAuthTokenInternal(accounts, account, authTokenType);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void setAuthToken(Account account, String authTokenType, String authToken) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"setAuthToken: \" + account\n                    + \", authTokenType \" + authTokenType\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        Objects.requireNonNull(authTokenType, \"authTokenType cannot be null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot set auth tokens associated with accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            saveAuthTokenToDatabase(accounts, account, authTokenType, authToken);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void setPassword(Account account, String password) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"setAuthToken: \" + account\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot set secrets for accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            setPasswordInternal(accounts, account, password, callingUid);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private void setPasswordInternal(UserAccounts accounts, Account account, String password,\n            int callingUid) {\n        if (account == null) {\n            return;\n        }\n        boolean isChanged = false;\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                accounts.accountsDb.beginTransaction();\n                try {\n                    final long accountId = accounts.accountsDb.findDeAccountId(account);\n                    if (accountId >= 0) {\n                        accounts.accountsDb.updateCeAccountPassword(accountId, password);\n                        accounts.accountsDb.deleteAuthTokensByAccountId(accountId);\n                        accounts.authTokenCache.remove(account);\n                        accounts.accountTokenCaches.remove(account);\n                        accounts.accountsDb.setTransactionSuccessful();\n                        // If there is an account whose password will be updated and the database\n                        // transactions succeed, then we say that a change has occured. Even if the\n                        // new password is the same as the old and there were no authtokens to\n                        // delete.\n                        isChanged = true;\n                        String action = (password == null || password.length() == 0) ?\n                                AccountsDb.DEBUG_ACTION_CLEAR_PASSWORD\n                                : AccountsDb.DEBUG_ACTION_SET_PASSWORD;\n                        logRecord(action, AccountsDb.TABLE_ACCOUNTS, accountId, accounts,\n                                callingUid);\n                    }\n                } finally {\n                    accounts.accountsDb.endTransaction();\n                    if (isChanged) {\n                        // Send LOGIN_ACCOUNTS_CHANGED only if the something changed.\n                        sendNotificationAccountUpdated(account, accounts);\n                        Log.i(TAG, \"callingUid=\" + callingUid + \" changed password\");\n                        sendAccountsChangedBroadcast(\n                                accounts.userId, account.type, /*useCase=*/\"setPassword\");\n                    }\n                }\n            }\n        }\n    }\n\n    @Override\n    public void clearPassword(Account account) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"clearPassword: \" + account\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot clear passwords for accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            setPasswordInternal(accounts, account, null, callingUid);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void setUserData(Account account, String key, String value) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"setUserData: \" + account\n                    + \", key \" + key\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        if (key == null) throw new IllegalArgumentException(\"key is null\");\n        if (account == null) throw new IllegalArgumentException(\"account is null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot set user data for accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            if (!accountExistsCache(accounts, account)) {\n                return;\n            }\n            setUserdataInternal(accounts, account, key, value);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private boolean accountExistsCache(UserAccounts accounts, Account account) {\n        synchronized (accounts.cacheLock) {\n            if (accounts.accountCache.containsKey(account.type)) {\n                for (Account acc : accounts.accountCache.get(account.type)) {\n                    if (acc.name.equals(account.name)) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    private void setUserdataInternal(UserAccounts accounts, Account account, String key,\n            String value) {\n        synchronized (accounts.dbLock) {\n            accounts.accountsDb.beginTransaction();\n            try {\n                long accountId = accounts.accountsDb.findDeAccountId(account);\n                if (accountId < 0) {\n                    return;\n                }\n                long extrasId = accounts.accountsDb.findExtrasIdByAccountId(accountId, key);\n                if (extrasId < 0) {\n                    extrasId = accounts.accountsDb.insertExtra(accountId, key, value);\n                    if (extrasId < 0) {\n                        return;\n                    }\n                } else if (!accounts.accountsDb.updateExtra(extrasId, value)) {\n                    return;\n                }\n                accounts.accountsDb.setTransactionSuccessful();\n            } finally {\n                accounts.accountsDb.endTransaction();\n            }\n            synchronized (accounts.cacheLock) {\n                writeUserDataIntoCacheLocked(accounts, account, key, value);\n                AccountManager.invalidateLocalAccountUserDataCaches();\n            }\n        }\n    }\n\n    private void onResult(IAccountManagerResponse response, Bundle result) {\n        if (result == null) {\n            Log.e(TAG, \"the result is unexpectedly null\", new Exception());\n        }\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, getClass().getSimpleName() + \" calling onResult() on response \"\n                    + response);\n        }\n        try {\n            response.onResult(result);\n        } catch (RemoteException e) {\n            // if the caller is dead then there is no one to care about remote\n            // exceptions\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"failure while notifying response\", e);\n            }\n        }\n    }\n\n    @Override\n    public void getAuthTokenLabel(IAccountManagerResponse response, final String accountType,\n                                  final String authTokenType)\n            throws RemoteException {\n        Preconditions.checkArgument(accountType != null, \"accountType cannot be null\");\n        Preconditions.checkArgument(authTokenType != null, \"authTokenType cannot be null\");\n\n        final int callingUid = getCallingUid();\n        clearCallingIdentity();\n        if (UserHandle.getAppId(callingUid) != Process.SYSTEM_UID) {\n            throw new SecurityException(\"can only call from system\");\n        }\n        int userId = UserHandle.getUserId(callingUid);\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            new Session(accounts, response, accountType, false /* expectActivityLaunch */,\n                    false /* stripAuthTokenFromResult */,  null /* accountName */,\n                    false /* authDetailsRequired */) {\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now) + \", getAuthTokenLabel\"\n                            + \", \" + accountType\n                            + \", authTokenType \" + authTokenType;\n                }\n\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.getAuthTokenLabel(this, authTokenType);\n                }\n\n                @Override\n                public void onResult(Bundle result) {\n                    Bundle.setDefusable(result, true);\n                    if (result != null) {\n                        String label = result.getString(AccountManager.KEY_AUTH_TOKEN_LABEL);\n                        Bundle bundle = new Bundle();\n                        bundle.putString(AccountManager.KEY_AUTH_TOKEN_LABEL, label);\n                        super.onResult(bundle);\n                        return;\n                    } else {\n                        super.onResult(result);\n                    }\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void getAuthToken(\n            IAccountManagerResponse response,\n            final Account account,\n            final String authTokenType,\n            final boolean notifyOnAuthFailure,\n            final boolean expectActivityLaunch,\n            final Bundle loginOptions) {\n        Bundle.setDefusable(loginOptions, true);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"getAuthToken: \" + account\n                    + \", response \" + response\n                    + \", authTokenType \" + authTokenType\n                    + \", notifyOnAuthFailure \" + notifyOnAuthFailure\n                    + \", expectActivityLaunch \" + expectActivityLaunch\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Preconditions.checkArgument(response != null, \"response cannot be null\");\n        try {\n            if (account == null) {\n                Slog.w(TAG, \"getAuthToken called with null account\");\n                response.onError(AccountManager.ERROR_CODE_BAD_ARGUMENTS, \"account is null\");\n                return;\n            }\n            if (authTokenType == null) {\n                Slog.w(TAG, \"getAuthToken called with null authTokenType\");\n                response.onError(AccountManager.ERROR_CODE_BAD_ARGUMENTS, \"authTokenType is null\");\n                return;\n            }\n        } catch (RemoteException e) {\n            Slog.w(TAG, \"Failed to report error back to the client.\" + e);\n            return;\n        }\n        int userId = UserHandle.getCallingUserId();\n        final long ident = Binder.clearCallingIdentity();\n        final UserAccounts accounts;\n        final RegisteredServicesCache.ServiceInfo<AuthenticatorDescription> authenticatorInfo;\n        try {\n            accounts = getUserAccounts(userId);\n            authenticatorInfo = mAuthenticatorCache.getServiceInfo(\n                    AuthenticatorDescription.newKey(account.type), accounts.userId);\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n\n        final boolean customTokens =\n                authenticatorInfo != null && authenticatorInfo.type.customTokens;\n\n        // skip the check if customTokens\n        final int callerUid = Binder.getCallingUid();\n        final boolean permissionGranted =\n                customTokens || permissionIsGranted(account, authTokenType, callerUid, userId);\n\n        // Get the calling package. We will use it for the purpose of caching.\n        final String callerPkg = loginOptions.getString(AccountManager.KEY_ANDROID_PACKAGE_NAME);\n        String[] callerOwnedPackageNames;\n        final long ident2 = Binder.clearCallingIdentity();\n        try {\n            callerOwnedPackageNames = mPackageManager.getPackagesForUid(callerUid);\n        } finally {\n            Binder.restoreCallingIdentity(ident2);\n        }\n        if (callerPkg == null || callerOwnedPackageNames == null\n                || !ArrayUtils.contains(callerOwnedPackageNames, callerPkg)) {\n            String msg = String.format(\n                    \"Uid %s is attempting to illegally masquerade as package %s!\",\n                    callerUid,\n                    callerPkg);\n            throw new SecurityException(msg);\n        }\n\n        // let authenticator know the identity of the caller\n        loginOptions.putInt(AccountManager.KEY_CALLER_UID, callerUid);\n        loginOptions.putInt(AccountManager.KEY_CALLER_PID, Binder.getCallingPid());\n\n        if (notifyOnAuthFailure) {\n            loginOptions.putBoolean(AccountManager.KEY_NOTIFY_ON_FAILURE, true);\n        }\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            // Distill the caller's package signatures into a single digest.\n            final byte[] callerPkgSigDigest = calculatePackageSignatureDigest(callerPkg, userId);\n\n            // if the caller has permission, do the peek. otherwise go the more expensive\n            // route of starting a Session\n            if (!customTokens && permissionGranted) {\n                String authToken = readAuthTokenInternal(accounts, account, authTokenType);\n                if (authToken != null) {\n                    logGetAuthTokenMetrics(callerPkg, account.type);\n                    Bundle result = new Bundle();\n                    result.putString(AccountManager.KEY_AUTHTOKEN, authToken);\n                    result.putString(AccountManager.KEY_ACCOUNT_NAME, account.name);\n                    result.putString(AccountManager.KEY_ACCOUNT_TYPE, account.type);\n                    onResult(response, result);\n                    return;\n                }\n            }\n\n            if (customTokens) {\n                /*\n                 * Look up tokens in the new cache only if the loginOptions don't have parameters\n                 * outside of those expected to be injected by the AccountManager, e.g.\n                 * ANDORID_PACKAGE_NAME.\n                 */\n                TokenCache.Value cachedToken = readCachedTokenInternal(\n                        accounts,\n                        account,\n                        authTokenType,\n                        callerPkg,\n                        callerPkgSigDigest);\n                if (cachedToken != null) {\n                    logGetAuthTokenMetrics(callerPkg, account.type);\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, \"getAuthToken: cache hit ofr custom token authenticator.\");\n                    }\n                    Bundle result = new Bundle();\n                    result.putString(AccountManager.KEY_AUTHTOKEN, cachedToken.token);\n                    result.putLong(AbstractAccountAuthenticator.KEY_CUSTOM_TOKEN_EXPIRY,\n                            cachedToken.expiryEpochMillis);\n                    result.putString(AccountManager.KEY_ACCOUNT_NAME, account.name);\n                    result.putString(AccountManager.KEY_ACCOUNT_TYPE, account.type);\n                    onResult(response, result);\n                    return;\n                }\n            }\n\n            new Session(\n                    accounts,\n                    response,\n                    account.type,\n                    expectActivityLaunch,\n                    false /* stripAuthTokenFromResult */,\n                    account.name,\n                    false /* authDetailsRequired */) {\n                @Override\n                protected String toDebugString(long now) {\n                    if (loginOptions != null) loginOptions.keySet();\n                    return super.toDebugString(now) + \", getAuthToken\"\n                            + \", \" + account.toSafeString()\n                            + \", authTokenType \" + authTokenType\n                            + \", loginOptions \" + loginOptions\n                            + \", notifyOnAuthFailure \" + notifyOnAuthFailure;\n                }\n\n                @Override\n                public void run() throws RemoteException {\n                    // If the caller doesn't have permission then create and return the\n                    // \"grant permission\" intent instead of the \"getAuthToken\" intent.\n                    if (!permissionGranted) {\n                        mAuthenticator.getAuthTokenLabel(this, authTokenType);\n                    } else {\n                        mAuthenticator.getAuthToken(this, account, authTokenType, loginOptions);\n                        logGetAuthTokenMetrics(callerPkg, account.type);\n                    }\n                }\n\n                @Override\n                public void onResult(Bundle result) {\n                    Bundle.setDefusable(result, true);\n                    if (result != null) {\n                        if (result.containsKey(AccountManager.KEY_AUTH_TOKEN_LABEL)) {\n                            Intent intent = newGrantCredentialsPermissionIntent(\n                                    account,\n                                    null,\n                                    callerUid,\n                                    new AccountAuthenticatorResponse(this),\n                                    authTokenType,\n                                    true);\n                            mCanStartAccountManagerActivity = true;\n                            Bundle bundle = new Bundle();\n                            bundle.putParcelable(AccountManager.KEY_INTENT, intent);\n                            onResult(bundle);\n                            return;\n                        }\n                        String authToken = result.getString(AccountManager.KEY_AUTHTOKEN);\n                        if (authToken != null) {\n                            String name = result.getString(AccountManager.KEY_ACCOUNT_NAME);\n                            String type = result.getString(AccountManager.KEY_ACCOUNT_TYPE);\n                            if (TextUtils.isEmpty(type) || TextUtils.isEmpty(name)) {\n                                onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                                        \"the type and name should not be empty\");\n                                return;\n                            }\n                            Account resultAccount = new Account(name, type);\n                            if (!customTokens) {\n                                saveAuthTokenToDatabase(\n                                        mAccounts,\n                                        resultAccount,\n                                        authTokenType,\n                                        authToken);\n                            }\n                            long expiryMillis = result.getLong(\n                                    AbstractAccountAuthenticator.KEY_CUSTOM_TOKEN_EXPIRY, 0L);\n                            if (customTokens\n                                    && expiryMillis > System.currentTimeMillis()) {\n                                saveCachedToken(\n                                        mAccounts,\n                                        account,\n                                        callerPkg,\n                                        callerPkgSigDigest,\n                                        authTokenType,\n                                        authToken,\n                                        expiryMillis);\n                            }\n                        }\n\n                        Intent intent = result.getParcelable(AccountManager.KEY_INTENT, android.content.Intent.class);\n                        if (intent != null && notifyOnAuthFailure && !customTokens) {\n                            /*\n                             * Make sure that the supplied intent is owned by the authenticator\n                             * giving it to the system. Otherwise a malicious authenticator could\n                             * have users launching arbitrary activities by tricking users to\n                             * interact with malicious notifications.\n                             */\n                            if (!checkKeyIntent(\n                                    Binder.getCallingUid(),\n                                    result)) {\n                                onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                                        \"invalid intent in bundle returned\");\n                                return;\n                            }\n                            doNotification(\n                                    mAccounts,\n                                    account,\n                                    result.getString(AccountManager.KEY_AUTH_FAILED_MESSAGE),\n                                    intent, \"android\", accounts.userId);\n                        }\n                    }\n                    super.onResult(result);\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private void logGetAuthTokenMetrics(final String callerPackage, String accountType) {\n        // Although this is not a 'device policy' API, enterprise is the current use case.\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.GET_ACCOUNT_AUTH_TOKEN)\n                .setStrings(\n                        TextUtils.emptyIfNull(callerPackage),\n                        TextUtils.emptyIfNull(accountType))\n                .write();\n    }\n\n    private byte[] calculatePackageSignatureDigest(String callerPkg, int userId) {\n        MessageDigest digester;\n        try {\n            digester = MessageDigest.getInstance(\"SHA-256\");\n            PackageInfo pkgInfo = mPackageManager.getPackageInfoAsUser(\n                    callerPkg, PackageManager.GET_SIGNATURES, userId);\n            for (Signature sig : pkgInfo.signatures) {\n                digester.update(sig.toByteArray());\n            }\n        } catch (NoSuchAlgorithmException x) {\n            Log.wtf(TAG, \"SHA-256 should be available\", x);\n            digester = null;\n        } catch (NameNotFoundException e) {\n            Log.w(TAG, \"Could not find packageinfo for: \" + callerPkg);\n            digester = null;\n        }\n        return (digester == null) ? null : digester.digest();\n    }\n\n    private void createNoCredentialsPermissionNotification(Account account, Intent intent,\n            String packageName, UserAccounts accounts) {\n        int userId = accounts.userId;\n        int uid = intent.getIntExtra(\n                GrantCredentialsPermissionActivity.EXTRAS_REQUESTING_UID, -1);\n        String authTokenType = intent.getStringExtra(\n                GrantCredentialsPermissionActivity.EXTRAS_AUTH_TOKEN_TYPE);\n        final String titleAndSubtitle =\n                mContext.getString(R.string.permission_request_notification_for_app_with_subtitle,\n                getApplicationLabel(packageName, userId), account.name);\n        final int index = titleAndSubtitle.indexOf('\\n');\n        String title = titleAndSubtitle;\n        String subtitle = \"\";\n        if (index > 0) {\n            title = titleAndSubtitle.substring(0, index);\n            subtitle = titleAndSubtitle.substring(index + 1);\n        }\n        UserHandle user = UserHandle.of(userId);\n        Context contextForUser = getContextForUser(user);\n        Notification n =\n                new Notification.Builder(contextForUser, SystemNotificationChannels.ACCOUNT)\n                    .setSmallIcon(android.R.drawable.stat_sys_warning)\n                    .setWhen(0)\n                    .setColor(contextForUser.getColor(\n                            com.android.internal.R.color.system_notification_accent_color))\n                    .setContentTitle(title)\n                    .setContentText(subtitle)\n                    .setContentIntent(PendingIntent.getActivityAsUser(mContext, 0, intent,\n                            PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_IMMUTABLE,\n                            null, user))\n                    .build();\n        installNotification(getCredentialPermissionNotificationId(\n                account, authTokenType, uid, accounts), n, \"android\", user.getIdentifier());\n    }\n\n    private String getApplicationLabel(String packageName, int userId) {\n        try {\n            return mPackageManager.getApplicationLabel(\n                    mPackageManager.getApplicationInfoAsUser(packageName, 0, userId)).toString();\n        } catch (PackageManager.NameNotFoundException e) {\n            return packageName;\n        }\n    }\n\n    private Intent newGrantCredentialsPermissionIntent(Account account, String packageName,\n            int uid, AccountAuthenticatorResponse response, String authTokenType,\n            boolean startInNewTask) {\n\n        Intent intent = new Intent(mContext, GrantCredentialsPermissionActivity.class);\n\n        if (startInNewTask) {\n            // See FLAG_ACTIVITY_NEW_TASK docs for limitations and benefits of the flag.\n            // Since it was set in Eclair+ we can't change it without breaking apps using\n            // the intent from a non-Activity context. This is the default behavior.\n            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        }\n        UserAccounts accounts = getUserAccounts(UserHandle.getUserId(uid));\n        intent.addCategory(getCredentialPermissionNotificationId(account,\n                authTokenType, uid, accounts).mTag + (packageName != null ? packageName : \"\"));\n        intent.putExtra(GrantCredentialsPermissionActivity.EXTRAS_ACCOUNT, account);\n        intent.putExtra(GrantCredentialsPermissionActivity.EXTRAS_AUTH_TOKEN_TYPE, authTokenType);\n        intent.putExtra(GrantCredentialsPermissionActivity.EXTRAS_RESPONSE, response);\n        intent.putExtra(GrantCredentialsPermissionActivity.EXTRAS_REQUESTING_UID, uid);\n\n        return intent;\n    }\n\n    private NotificationId getCredentialPermissionNotificationId(Account account,\n            String authTokenType, int uid, UserAccounts accounts) {\n        NotificationId nId;\n        synchronized (accounts.credentialsPermissionNotificationIds) {\n            final Pair<Pair<Account, String>, Integer> key =\n                    new Pair<Pair<Account, String>, Integer>(\n                            new Pair<Account, String>(account, authTokenType), uid);\n            nId = accounts.credentialsPermissionNotificationIds.get(key);\n            if (nId == null) {\n                String tag = TAG + \":\" + SystemMessage.NOTE_ACCOUNT_CREDENTIAL_PERMISSION\n                        + \":\" + account.hashCode() + \":\" + authTokenType.hashCode() + \":\" + uid;\n                int id = SystemMessage.NOTE_ACCOUNT_CREDENTIAL_PERMISSION;\n                nId = new NotificationId(tag, id);\n                accounts.credentialsPermissionNotificationIds.put(key, nId);\n            }\n        }\n        return nId;\n    }\n\n    private NotificationId getSigninRequiredNotificationId(UserAccounts accounts, Account account) {\n        NotificationId nId;\n        synchronized (accounts.signinRequiredNotificationIds) {\n            nId = accounts.signinRequiredNotificationIds.get(account);\n            if (nId == null) {\n                String tag = TAG + \":\" + SystemMessage.NOTE_ACCOUNT_REQUIRE_SIGNIN\n                        + \":\" + account.hashCode();\n                int id = SystemMessage.NOTE_ACCOUNT_REQUIRE_SIGNIN;\n                nId = new NotificationId(tag, id);\n                accounts.signinRequiredNotificationIds.put(account, nId);\n            }\n        }\n        return nId;\n    }\n\n    @Override\n    public void addAccount(final IAccountManagerResponse response, final String accountType,\n            final String authTokenType, final String[] requiredFeatures,\n            final boolean expectActivityLaunch, final Bundle optionsIn) {\n        Bundle.setDefusable(optionsIn, true);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"addAccount: accountType \" + accountType\n                    + \", response \" + response\n                    + \", authTokenType \" + authTokenType\n                    + \", requiredFeatures \" + Arrays.toString(requiredFeatures)\n                    + \", expectActivityLaunch \" + expectActivityLaunch\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        if (response == null) throw new IllegalArgumentException(\"response is null\");\n        if (accountType == null) throw new IllegalArgumentException(\"accountType is null\");\n\n        // Is user disallowed from modifying accounts?\n        final int uid = Binder.getCallingUid();\n        final int userId = UserHandle.getUserId(uid);\n        if (!canUserModifyAccounts(userId, uid)) {\n            try {\n                response.onError(AccountManager.ERROR_CODE_USER_RESTRICTED,\n                        \"User is not allowed to add an account!\");\n            } catch (RemoteException re) {\n            }\n            showCantAddAccount(AccountManager.ERROR_CODE_USER_RESTRICTED, userId);\n            return;\n        }\n        if (!canUserModifyAccountsForType(userId, accountType, uid)) {\n            try {\n                response.onError(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                        \"User cannot modify accounts of this type (policy).\");\n            } catch (RemoteException re) {\n            }\n            showCantAddAccount(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                    userId);\n            return;\n        }\n        addAccountAndLogMetrics(response, accountType, authTokenType, requiredFeatures,\n                expectActivityLaunch, optionsIn, userId);\n    }\n\n    @Override\n    public void addAccountAsUser(final IAccountManagerResponse response, final String accountType,\n            final String authTokenType, final String[] requiredFeatures,\n            final boolean expectActivityLaunch, final Bundle optionsIn, int userId) {\n        Bundle.setDefusable(optionsIn, true);\n        int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"addAccount: accountType \" + accountType\n                    + \", response \" + response\n                    + \", authTokenType \" + authTokenType\n                    + \", requiredFeatures \" + Arrays.toString(requiredFeatures)\n                    + \", expectActivityLaunch \" + expectActivityLaunch\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid()\n                    + \", for user id \" + userId);\n        }\n        Preconditions.checkArgument(response != null, \"response cannot be null\");\n        Preconditions.checkArgument(accountType != null, \"accountType cannot be null\");\n        // Only allow the system process to add accounts of other users\n        if (isCrossUser(callingUid, userId)) {\n            throw new SecurityException(\n                    String.format(\n                            \"User %s trying to add account for %s\" ,\n                            UserHandle.getCallingUserId(),\n                            userId));\n        }\n\n        // Is user disallowed from modifying accounts?\n        if (!canUserModifyAccounts(userId, callingUid)) {\n            try {\n                response.onError(AccountManager.ERROR_CODE_USER_RESTRICTED,\n                        \"User is not allowed to add an account!\");\n            } catch (RemoteException re) {\n            }\n            showCantAddAccount(AccountManager.ERROR_CODE_USER_RESTRICTED, userId);\n            return;\n        }\n        if (!canUserModifyAccountsForType(userId, accountType, callingUid)) {\n            try {\n                response.onError(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                        \"User cannot modify accounts of this type (policy).\");\n            } catch (RemoteException re) {\n            }\n            showCantAddAccount(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                    userId);\n            return;\n        }\n        addAccountAndLogMetrics(response, accountType, authTokenType, requiredFeatures,\n                expectActivityLaunch, optionsIn, userId);\n    }\n\n    private void addAccountAndLogMetrics(\n            IAccountManagerResponse response, String accountType,\n            String authTokenType, String[] requiredFeatures,\n            boolean expectActivityLaunch, Bundle optionsIn, int userId) {\n        final int pid = Binder.getCallingPid();\n        final int uid = Binder.getCallingUid();\n        final Bundle options = (optionsIn == null) ? new Bundle() : optionsIn;\n        options.putInt(AccountManager.KEY_CALLER_UID, uid);\n        options.putInt(AccountManager.KEY_CALLER_PID, pid);\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            logRecordWithUid(\n                    accounts, AccountsDb.DEBUG_ACTION_CALLED_ACCOUNT_ADD, AccountsDb.TABLE_ACCOUNTS,\n                    uid);\n            new Session(accounts, response, accountType, expectActivityLaunch,\n                    true /* stripAuthTokenFromResult */, null /* accountName */,\n                    false /* authDetailsRequired */, true /* updateLastAuthenticationTime */) {\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.addAccount(\n                            this, mAccountType, authTokenType, requiredFeatures, options);\n                    String callerPackage = options.getString(\n                            AccountManager.KEY_ANDROID_PACKAGE_NAME);\n                    logAddAccountMetrics(\n                            callerPackage, accountType, requiredFeatures, authTokenType);\n                }\n\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now) + \", addAccount\"\n                            + \", accountType \" + accountType\n                            + \", requiredFeatures \"\n                            + (requiredFeatures != null\n                            ? TextUtils.join(\",\", requiredFeatures)\n                            : null);\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private void logAddAccountMetrics(\n            String callerPackage, String accountType, String[] requiredFeatures,\n            String authTokenType) {\n        // Although this is not a 'device policy' API, enterprise is the current use case.\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.ADD_ACCOUNT)\n                .setStrings(\n                        TextUtils.emptyIfNull(accountType),\n                        TextUtils.emptyIfNull(callerPackage),\n                        TextUtils.emptyIfNull(authTokenType),\n                        requiredFeatures == null\n                                ? \"\"\n                                : TextUtils.join(\";\", requiredFeatures))\n                .write();\n    }\n\n    @Override\n    public void startAddAccountSession(\n            final IAccountManagerResponse response,\n            final String accountType,\n            final String authTokenType,\n            final String[] requiredFeatures,\n            final boolean expectActivityLaunch,\n            final Bundle optionsIn) {\n        Bundle.setDefusable(optionsIn, true);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG,\n                    \"startAddAccountSession: accountType \" + accountType\n                    + \", response \" + response\n                    + \", authTokenType \" + authTokenType\n                    + \", requiredFeatures \" + Arrays.toString(requiredFeatures)\n                    + \", expectActivityLaunch \" + expectActivityLaunch\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Preconditions.checkArgument(response != null, \"response cannot be null\");\n        Preconditions.checkArgument(accountType != null, \"accountType cannot be null\");\n\n        final int uid = Binder.getCallingUid();\n        final int userId = UserHandle.getUserId(uid);\n        if (!canUserModifyAccounts(userId, uid)) {\n            try {\n                response.onError(AccountManager.ERROR_CODE_USER_RESTRICTED,\n                        \"User is not allowed to add an account!\");\n            } catch (RemoteException re) {\n            }\n            showCantAddAccount(AccountManager.ERROR_CODE_USER_RESTRICTED, userId);\n            return;\n        }\n        if (!canUserModifyAccountsForType(userId, accountType, uid)) {\n            try {\n                response.onError(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                        \"User cannot modify accounts of this type (policy).\");\n            } catch (RemoteException re) {\n            }\n            showCantAddAccount(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                    userId);\n            return;\n        }\n        final int pid = Binder.getCallingPid();\n        final Bundle options = (optionsIn == null) ? new Bundle() : optionsIn;\n        options.putInt(AccountManager.KEY_CALLER_UID, uid);\n        options.putInt(AccountManager.KEY_CALLER_PID, pid);\n\n        // Check to see if the Password should be included to the caller.\n        String callerPkg = options.getString(AccountManager.KEY_ANDROID_PACKAGE_NAME);\n        boolean isPasswordForwardingAllowed = checkPermissionAndNote(\n                callerPkg, uid, Manifest.permission.GET_PASSWORD);\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            logRecordWithUid(accounts, AccountsDb.DEBUG_ACTION_CALLED_START_ACCOUNT_ADD,\n                    AccountsDb.TABLE_ACCOUNTS, uid);\n            new StartAccountSession(\n                    accounts,\n                    response,\n                    accountType,\n                    expectActivityLaunch,\n                    null /* accountName */,\n                    false /* authDetailsRequired */,\n                    true /* updateLastAuthenticationTime */,\n                    isPasswordForwardingAllowed) {\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.startAddAccountSession(this, mAccountType, authTokenType,\n                            requiredFeatures, options);\n                    logAddAccountMetrics(callerPkg, accountType, requiredFeatures, authTokenType);\n                }\n\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now) + \", startAddAccountSession\" + \", accountType \"\n                            + accountType + \", requiredFeatures \"\n                            + (requiredFeatures != null\n                                ? TextUtils.join(\",\", requiredFeatures) : \"null\");\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    /** Session that will encrypt the KEY_ACCOUNT_SESSION_BUNDLE in result. */\n    private abstract class StartAccountSession extends Session {\n\n        private final boolean mIsPasswordForwardingAllowed;\n\n        public StartAccountSession(\n                UserAccounts accounts,\n                IAccountManagerResponse response,\n                String accountType,\n                boolean expectActivityLaunch,\n                String accountName,\n                boolean authDetailsRequired,\n                boolean updateLastAuthenticationTime,\n                boolean isPasswordForwardingAllowed) {\n            super(accounts, response, accountType, expectActivityLaunch,\n                    true /* stripAuthTokenFromResult */, accountName, authDetailsRequired,\n                    updateLastAuthenticationTime);\n            mIsPasswordForwardingAllowed = isPasswordForwardingAllowed;\n        }\n\n        @Override\n        public void onResult(Bundle result) {\n            Bundle.setDefusable(result, true);\n            mNumResults++;\n            Intent intent = null;\n            if (result != null) {\n                if (!checkKeyIntent(\n                        Binder.getCallingUid(),\n                        result)) {\n                    onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                            \"invalid intent in bundle returned\");\n                    return;\n                }\n            }\n            IAccountManagerResponse response;\n            if (mExpectActivityLaunch && result != null\n                    && result.containsKey(AccountManager.KEY_INTENT)) {\n                response = mResponse;\n            } else {\n                response = getResponseAndClose();\n            }\n            if (response == null) {\n                return;\n            }\n            if (result == null) {\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.v(TAG, getClass().getSimpleName() + \" calling onError() on response \"\n                            + response);\n                }\n                sendErrorResponse(response, AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                        \"null bundle returned\");\n                return;\n            }\n\n            if ((result.getInt(AccountManager.KEY_ERROR_CODE, -1) > 0) && (intent == null)) {\n                // All AccountManager error codes are greater\n                // than 0\n                sendErrorResponse(response, result.getInt(AccountManager.KEY_ERROR_CODE),\n                        result.getString(AccountManager.KEY_ERROR_MESSAGE));\n                return;\n            }\n\n            // Omit passwords if the caller isn't permitted to see them.\n            if (!mIsPasswordForwardingAllowed) {\n                result.remove(AccountManager.KEY_PASSWORD);\n            }\n\n            // Strip auth token from result.\n            result.remove(AccountManager.KEY_AUTHTOKEN);\n            if (!checkKeyIntent(Binder.getCallingUid(), result)) {\n                onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                        \"invalid intent in bundle returned\");\n                return;\n            }\n\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG,\n                        getClass().getSimpleName() + \" calling onResult() on response \" + response);\n            }\n\n            // Get the session bundle created by authenticator. The\n            // bundle contains data necessary for finishing the session\n            // later. The session bundle will be encrypted here and\n            // decrypted later when trying to finish the session.\n            Bundle sessionBundle = result.getBundle(AccountManager.KEY_ACCOUNT_SESSION_BUNDLE);\n            if (sessionBundle != null) {\n                String accountType = sessionBundle.getString(AccountManager.KEY_ACCOUNT_TYPE);\n                if (TextUtils.isEmpty(accountType)\n                        || !mAccountType.equalsIgnoreCase(accountType)) {\n                    Log.w(TAG, \"Account type in session bundle doesn't match request.\");\n                }\n                // Add accountType info to session bundle. This will\n                // override any value set by authenticator.\n                sessionBundle.putString(AccountManager.KEY_ACCOUNT_TYPE, mAccountType);\n\n                // Encrypt session bundle before returning to caller.\n                try {\n                    CryptoHelper cryptoHelper = CryptoHelper.getInstance();\n                    Bundle encryptedBundle = cryptoHelper.encryptBundle(sessionBundle);\n                    result.putBundle(AccountManager.KEY_ACCOUNT_SESSION_BUNDLE, encryptedBundle);\n                } catch (GeneralSecurityException e) {\n                    if (Log.isLoggable(TAG, Log.DEBUG)) {\n                        Log.v(TAG, \"Failed to encrypt session bundle!\", e);\n                    }\n                    sendErrorResponse(response, AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                            \"failed to encrypt session bundle\");\n                    return;\n                }\n            }\n\n            sendResponse(response, result);\n        }\n    }\n\n    @Override\n    public void finishSessionAsUser(IAccountManagerResponse response,\n            @NonNull Bundle sessionBundle,\n            boolean expectActivityLaunch,\n            Bundle appInfo,\n            int userId) {\n        Bundle.setDefusable(sessionBundle, true);\n        int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG,\n                    \"finishSession: response \"+ response\n                            + \", expectActivityLaunch \" + expectActivityLaunch\n                            + \", caller's uid \" + callingUid\n                            + \", caller's user id \" + UserHandle.getCallingUserId()\n                            + \", pid \" + Binder.getCallingPid()\n                            + \", for user id \" + userId);\n        }\n        Preconditions.checkArgument(response != null, \"response cannot be null\");\n        // Session bundle is the encrypted bundle of the original bundle created by authenticator.\n        // Account type is added to it before encryption.\n        if (sessionBundle == null || sessionBundle.size() == 0) {\n            throw new IllegalArgumentException(\"sessionBundle is empty\");\n        }\n\n        // Only allow the system process to finish session for other users.\n        if (isCrossUser(callingUid, userId)) {\n            throw new SecurityException(\n                    String.format(\n                            \"User %s trying to finish session for %s without cross user permission\",\n                            UserHandle.getCallingUserId(),\n                            userId));\n        }\n\n        if (!canUserModifyAccounts(userId, callingUid)) {\n            sendErrorResponse(response,\n                    AccountManager.ERROR_CODE_USER_RESTRICTED,\n                    \"User is not allowed to add an account!\");\n            showCantAddAccount(AccountManager.ERROR_CODE_USER_RESTRICTED, userId);\n            return;\n        }\n\n        final int pid = Binder.getCallingPid();\n        final Bundle decryptedBundle;\n        final String accountType;\n        // First decrypt session bundle to get account type for checking permission.\n        try {\n            CryptoHelper cryptoHelper = CryptoHelper.getInstance();\n            decryptedBundle = cryptoHelper.decryptBundle(sessionBundle);\n            if (decryptedBundle == null) {\n                sendErrorResponse(\n                        response,\n                        AccountManager.ERROR_CODE_BAD_REQUEST,\n                        \"failed to decrypt session bundle\");\n                return;\n            }\n            accountType = decryptedBundle.getString(AccountManager.KEY_ACCOUNT_TYPE);\n            // Account type cannot be null. This should not happen if session bundle was created\n            // properly by #StartAccountSession.\n            if (TextUtils.isEmpty(accountType)) {\n                sendErrorResponse(\n                        response,\n                        AccountManager.ERROR_CODE_BAD_ARGUMENTS,\n                        \"accountType is empty\");\n                return;\n            }\n\n            // If by any chances, decryptedBundle contains colliding keys with\n            // system info\n            // such as AccountManager.KEY_ANDROID_PACKAGE_NAME required by the add account flow or\n            // update credentials flow, we should replace with the new values of the current call.\n            if (appInfo != null) {\n                decryptedBundle.putAll(appInfo);\n            }\n\n            // Add info that may be used by add account or update credentials flow.\n            decryptedBundle.putInt(AccountManager.KEY_CALLER_UID, callingUid);\n            decryptedBundle.putInt(AccountManager.KEY_CALLER_PID, pid);\n        } catch (GeneralSecurityException e) {\n            if (Log.isLoggable(TAG, Log.DEBUG)) {\n                Log.v(TAG, \"Failed to decrypt session bundle!\", e);\n            }\n            sendErrorResponse(\n                    response,\n                    AccountManager.ERROR_CODE_BAD_REQUEST,\n                    \"failed to decrypt session bundle\");\n            return;\n        }\n\n        if (!canUserModifyAccountsForType(userId, accountType, callingUid)) {\n            sendErrorResponse(\n                    response,\n                    AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                    \"User cannot modify accounts of this type (policy).\");\n            showCantAddAccount(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                    userId);\n            return;\n        }\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            logRecordWithUid(\n                    accounts,\n                    AccountsDb.DEBUG_ACTION_CALLED_ACCOUNT_SESSION_FINISH,\n                    AccountsDb.TABLE_ACCOUNTS,\n                    callingUid);\n            new Session(\n                    accounts,\n                    response,\n                    accountType,\n                    expectActivityLaunch,\n                    true /* stripAuthTokenFromResult */,\n                    null /* accountName */,\n                    false /* authDetailsRequired */,\n                    true /* updateLastAuthenticationTime */) {\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.finishSession(this, mAccountType, decryptedBundle);\n                }\n\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now)\n                            + \", finishSession\"\n                            + \", accountType \" + accountType;\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private void showCantAddAccount(int errorCode, int userId) {\n        final DevicePolicyManagerInternal dpmi =\n                LocalServices.getService(DevicePolicyManagerInternal.class);\n        Intent intent = null;\n        if (dpmi == null) {\n            intent = getDefaultCantAddAccountIntent(errorCode);\n        } else if (errorCode == AccountManager.ERROR_CODE_USER_RESTRICTED) {\n            intent = dpmi.createUserRestrictionSupportIntent(userId,\n                    UserManager.DISALLOW_MODIFY_ACCOUNTS);\n        } else if (errorCode == AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE) {\n            intent = dpmi.createShowAdminSupportIntent(userId, false);\n        }\n        if (intent == null) {\n            intent = getDefaultCantAddAccountIntent(errorCode);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            mContext.startActivityAsUser(intent, new UserHandle(userId));\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    /**\n     * Called when we don't know precisely who is preventing us from adding an account.\n     */\n    private Intent getDefaultCantAddAccountIntent(int errorCode) {\n        Intent cantAddAccount = new Intent(mContext, CantAddAccountActivity.class);\n        cantAddAccount.putExtra(CantAddAccountActivity.EXTRA_ERROR_CODE, errorCode);\n        cantAddAccount.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        return cantAddAccount;\n    }\n\n    @Override\n    public void confirmCredentialsAsUser(\n            IAccountManagerResponse response,\n            final Account account,\n            final Bundle options,\n            final boolean expectActivityLaunch,\n            int userId) {\n        Bundle.setDefusable(options, true);\n        int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"confirmCredentials: \" + account\n                    + \", response \" + response\n                    + \", expectActivityLaunch \" + expectActivityLaunch\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        // Only allow the system process to read accounts of other users\n        if (isCrossUser(callingUid, userId)) {\n            throw new SecurityException(\n                    String.format(\n                            \"User %s trying to confirm account credentials for %s\" ,\n                            UserHandle.getCallingUserId(),\n                            userId));\n        }\n        if (response == null) throw new IllegalArgumentException(\"response is null\");\n        if (account == null) throw new IllegalArgumentException(\"account is null\");\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            new Session(accounts, response, account.type, expectActivityLaunch,\n                    true /* stripAuthTokenFromResult */, account.name,\n                    true /* authDetailsRequired */, true /* updateLastAuthenticatedTime */) {\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.confirmCredentials(this, account, options);\n                }\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now) + \", confirmCredentials\"\n                            + \", \" + account.toSafeString();\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void updateCredentials(IAccountManagerResponse response, final Account account,\n            final String authTokenType, final boolean expectActivityLaunch,\n            final Bundle loginOptions) {\n        Bundle.setDefusable(loginOptions, true);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"updateCredentials: \" + account\n                    + \", response \" + response\n                    + \", authTokenType \" + authTokenType\n                    + \", expectActivityLaunch \" + expectActivityLaunch\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        if (response == null) throw new IllegalArgumentException(\"response is null\");\n        if (account == null) throw new IllegalArgumentException(\"account is null\");\n        int userId = UserHandle.getCallingUserId();\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            new Session(accounts, response, account.type, expectActivityLaunch,\n                    true /* stripAuthTokenFromResult */, account.name,\n                    false /* authDetailsRequired */, true /* updateLastCredentialTime */) {\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.updateCredentials(this, account, authTokenType, loginOptions);\n                }\n                @Override\n                protected String toDebugString(long now) {\n                    if (loginOptions != null) loginOptions.keySet();\n                    return super.toDebugString(now) + \", updateCredentials\"\n                            + \", \" + account.toSafeString()\n                            + \", authTokenType \" + authTokenType\n                            + \", loginOptions \" + loginOptions;\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void startUpdateCredentialsSession(\n            IAccountManagerResponse response,\n            final Account account,\n            final String authTokenType,\n            final boolean expectActivityLaunch,\n            final Bundle loginOptions) {\n        Bundle.setDefusable(loginOptions, true);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG,\n                    \"startUpdateCredentialsSession: \" + account + \", response \" + response\n                            + \", authTokenType \" + authTokenType + \", expectActivityLaunch \"\n                            + expectActivityLaunch + \", caller's uid \" + Binder.getCallingUid()\n                            + \", pid \" + Binder.getCallingPid());\n        }\n        if (response == null) {\n            throw new IllegalArgumentException(\"response is null\");\n        }\n        if (account == null) {\n            throw new IllegalArgumentException(\"account is null\");\n        }\n\n        final int uid = Binder.getCallingUid();\n        int userId = UserHandle.getCallingUserId();\n\n        // Check to see if the Password should be included to the caller.\n        String callerPkg = loginOptions.getString(AccountManager.KEY_ANDROID_PACKAGE_NAME);\n        boolean isPasswordForwardingAllowed = checkPermissionAndNote(\n                callerPkg, uid, Manifest.permission.GET_PASSWORD);\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            new StartAccountSession(\n                    accounts,\n                    response,\n                    account.type,\n                    expectActivityLaunch,\n                    account.name,\n                    false /* authDetailsRequired */,\n                    true /* updateLastCredentialTime */,\n                    isPasswordForwardingAllowed) {\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.startUpdateCredentialsSession(this, account, authTokenType,\n                            loginOptions);\n                }\n\n                @Override\n                protected String toDebugString(long now) {\n                    if (loginOptions != null)\n                        loginOptions.keySet();\n                    return super.toDebugString(now)\n                            + \", startUpdateCredentialsSession\"\n                            + \", \" + account.toSafeString()\n                            + \", authTokenType \" + authTokenType\n                            + \", loginOptions \" + loginOptions;\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void isCredentialsUpdateSuggested(\n            IAccountManagerResponse response,\n            final Account account,\n            final String statusToken) {\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG,\n                    \"isCredentialsUpdateSuggested: \" + account + \", response \" + response\n                            + \", caller's uid \" + Binder.getCallingUid()\n                            + \", pid \" + Binder.getCallingPid());\n        }\n        if (response == null) {\n            throw new IllegalArgumentException(\"response is null\");\n        }\n        if (account == null) {\n            throw new IllegalArgumentException(\"account is null\");\n        }\n        if (TextUtils.isEmpty(statusToken)) {\n            throw new IllegalArgumentException(\"status token is empty\");\n        }\n\n        int usrId = UserHandle.getCallingUserId();\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(usrId);\n            new Session(accounts, response, account.type, false /* expectActivityLaunch */,\n                    false /* stripAuthTokenFromResult */, account.name,\n                    false /* authDetailsRequired */) {\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now) + \", isCredentialsUpdateSuggested\"\n                            + \", \" + account.toSafeString();\n                }\n\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.isCredentialsUpdateSuggested(this, account, statusToken);\n                }\n\n                @Override\n                public void onResult(Bundle result) {\n                    Bundle.setDefusable(result, true);\n                    IAccountManagerResponse response = getResponseAndClose();\n                    if (response == null) {\n                        return;\n                    }\n\n                    if (result == null) {\n                        sendErrorResponse(\n                                response,\n                                AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                                \"null bundle\");\n                        return;\n                    }\n\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, getClass().getSimpleName() + \" calling onResult() on response \"\n                                + response);\n                    }\n                    // Check to see if an error occurred. We know if an error occurred because all\n                    // error codes are greater than 0.\n                    if ((result.getInt(AccountManager.KEY_ERROR_CODE, -1) > 0)) {\n                        sendErrorResponse(response,\n                                result.getInt(AccountManager.KEY_ERROR_CODE),\n                                result.getString(AccountManager.KEY_ERROR_MESSAGE));\n                        return;\n                    }\n                    if (!result.containsKey(AccountManager.KEY_BOOLEAN_RESULT)) {\n                        sendErrorResponse(\n                                response,\n                                AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                                \"no result in response\");\n                        return;\n                    }\n                    final Bundle newResult = new Bundle();\n                    newResult.putBoolean(AccountManager.KEY_BOOLEAN_RESULT,\n                            result.getBoolean(AccountManager.KEY_BOOLEAN_RESULT, false));\n                    sendResponse(response, newResult);\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void editProperties(IAccountManagerResponse response, final String accountType,\n            final boolean expectActivityLaunch) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"editProperties: accountType \" + accountType\n                    + \", response \" + response\n                    + \", expectActivityLaunch \" + expectActivityLaunch\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        if (response == null) throw new IllegalArgumentException(\"response is null\");\n        if (accountType == null) throw new IllegalArgumentException(\"accountType is null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(accountType, callingUid, userId)\n                && !isSystemUid(callingUid)) {\n            String msg = String.format(\n                    \"uid %s cannot edit authenticator properites for account type: %s\",\n                    callingUid,\n                    accountType);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            new Session(accounts, response, accountType, expectActivityLaunch,\n                    true /* stripAuthTokenFromResult */, null /* accountName */,\n                    false /* authDetailsRequired */) {\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.editProperties(this, mAccountType);\n                }\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now) + \", editProperties\"\n                            + \", accountType \" + accountType;\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public boolean hasAccountAccess(@NonNull Account account,  @NonNull String packageName,\n            @NonNull UserHandle userHandle) {\n        if (UserHandle.getAppId(Binder.getCallingUid()) != Process.SYSTEM_UID) {\n            throw new SecurityException(\"Can be called only by system UID\");\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        Objects.requireNonNull(packageName, \"packageName cannot be null\");\n        Objects.requireNonNull(userHandle, \"userHandle cannot be null\");\n\n        final int userId = userHandle.getIdentifier();\n\n        Preconditions.checkArgumentInRange(userId, 0, Integer.MAX_VALUE, \"user must be concrete\");\n\n        try {\n            int uid = mPackageManager.getPackageUidAsUser(packageName, userId);\n            return hasAccountAccess(account, packageName, uid);\n        } catch (NameNotFoundException e) {\n            Log.w(TAG, \"hasAccountAccess#Package not found \" + e.getMessage());\n            return false;\n        }\n    }\n\n    // Returns package with oldest target SDK for given UID.\n    private String getPackageNameForUid(int uid) {\n        String[] packageNames = mPackageManager.getPackagesForUid(uid);\n        if (ArrayUtils.isEmpty(packageNames)) {\n            return null;\n        }\n        String packageName = packageNames[0];\n        if (packageNames.length == 1) {\n            return packageName;\n        }\n        // Due to visibility changes we want to use package with oldest target SDK\n        int oldestVersion = Integer.MAX_VALUE;\n        for (String name : packageNames) {\n            try {\n                ApplicationInfo applicationInfo = mPackageManager.getApplicationInfo(name, 0);\n                if (applicationInfo != null) {\n                    int version = applicationInfo.targetSdkVersion;\n                    if (version < oldestVersion) {\n                        oldestVersion = version;\n                        packageName = name;\n                    }\n                }\n            } catch (NameNotFoundException e) {\n                // skip\n            }\n        }\n        return packageName;\n    }\n\n    private boolean hasAccountAccess(@NonNull Account account, @Nullable String packageName,\n            int uid) {\n        if (packageName == null) {\n            packageName = getPackageNameForUid(uid);\n            if (packageName == null) {\n                return false;\n            }\n        }\n\n        // Use null token which means any token. Having a token means the package\n        // is trusted by the authenticator, hence it is fine to access the account.\n        if (permissionIsGranted(account, null, uid, UserHandle.getUserId(uid))) {\n            return true;\n        }\n        // In addition to the permissions required to get an auth token we also allow\n        // the account to be accessed by apps for which user or authenticator granted visibility.\n\n        int visibility = resolveAccountVisibility(account, packageName,\n            getUserAccounts(UserHandle.getUserId(uid)));\n        return (visibility == AccountManager.VISIBILITY_VISIBLE\n            || visibility == AccountManager.VISIBILITY_USER_MANAGED_VISIBLE);\n    }\n\n    @Override\n    public IntentSender createRequestAccountAccessIntentSenderAsUser(@NonNull Account account,\n            @NonNull String packageName, @NonNull UserHandle userHandle) {\n        if (UserHandle.getAppId(Binder.getCallingUid()) != Process.SYSTEM_UID) {\n            throw new SecurityException(\"Can be called only by system UID\");\n        }\n\n        Objects.requireNonNull(account, \"account cannot be null\");\n        Objects.requireNonNull(packageName, \"packageName cannot be null\");\n        Objects.requireNonNull(userHandle, \"userHandle cannot be null\");\n\n        final int userId = userHandle.getIdentifier();\n\n        Preconditions.checkArgumentInRange(userId, 0, Integer.MAX_VALUE, \"user must be concrete\");\n\n        final int uid;\n        try {\n            uid = mPackageManager.getPackageUidAsUser(packageName, userId);\n        } catch (NameNotFoundException e) {\n            Slog.e(TAG, \"Unknown package \" + packageName);\n            return null;\n        }\n\n        Intent intent = newRequestAccountAccessIntent(account, packageName, uid, null);\n\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            return PendingIntent.getActivityAsUser(\n                    mContext, 0, intent, PendingIntent.FLAG_ONE_SHOT\n                            | PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_IMMUTABLE,\n                    null, new UserHandle(userId)).getIntentSender();\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    private Intent newRequestAccountAccessIntent(Account account, String packageName,\n            int uid, RemoteCallback callback) {\n        return newGrantCredentialsPermissionIntent(account, packageName, uid,\n                new AccountAuthenticatorResponse(new IAccountAuthenticatorResponse.Stub() {\n            @Override\n            public void onResult(Bundle value) throws RemoteException {\n                handleAuthenticatorResponse(true);\n            }\n\n            @Override\n            public void onRequestContinued() {\n                /* ignore */\n            }\n\n            @Override\n            public void onError(int errorCode, String errorMessage) throws RemoteException {\n                handleAuthenticatorResponse(false);\n            }\n\n            private void handleAuthenticatorResponse(boolean accessGranted) throws RemoteException {\n                UserAccounts userAccounts = getUserAccounts(UserHandle.getUserId(uid));\n                cancelNotification(getCredentialPermissionNotificationId(account,\n                        AccountManager.ACCOUNT_ACCESS_TOKEN_TYPE, uid, userAccounts), userAccounts);\n                if (callback != null) {\n                    Bundle result = new Bundle();\n                    result.putBoolean(AccountManager.KEY_BOOLEAN_RESULT, accessGranted);\n                    callback.sendResult(result);\n                }\n            }\n        }), AccountManager.ACCOUNT_ACCESS_TOKEN_TYPE, false);\n    }\n\n    @Override\n    public boolean someUserHasAccount(@NonNull final Account account) {\n        if (!UserHandle.isSameApp(Process.SYSTEM_UID, Binder.getCallingUid())) {\n            throw new SecurityException(\"Only system can check for accounts across users\");\n        }\n        final long token = Binder.clearCallingIdentity();\n        try {\n            AccountAndUser[] allAccounts = getAllAccountsForSystemProcess();\n            for (int i = allAccounts.length - 1; i >= 0; i--) {\n                if (allAccounts[i].account.equals(account)) {\n                    return true;\n                }\n            }\n            return false;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private class GetAccountsByTypeAndFeatureSession extends Session {\n        private final String[] mFeatures;\n        private volatile Account[] mAccountsOfType = null;\n        private volatile ArrayList<Account> mAccountsWithFeatures = null;\n        private volatile int mCurrentAccount = 0;\n        private final int mCallingUid;\n        private final String mPackageName;\n        private final boolean mIncludeManagedNotVisible;\n\n        public GetAccountsByTypeAndFeatureSession(\n                UserAccounts accounts,\n                IAccountManagerResponse response,\n                String type,\n                String[] features,\n                int callingUid,\n                String packageName,\n                boolean includeManagedNotVisible) {\n            super(accounts, response, type, false /* expectActivityLaunch */,\n                    true /* stripAuthTokenFromResult */, null /* accountName */,\n                    false /* authDetailsRequired */);\n            mCallingUid = callingUid;\n            mFeatures = features;\n            mPackageName = packageName;\n            mIncludeManagedNotVisible = includeManagedNotVisible;\n        }\n\n        @Override\n        public void run() throws RemoteException {\n            mAccountsOfType = getAccountsFromCache(mAccounts, mAccountType,\n                    mCallingUid, mPackageName, mIncludeManagedNotVisible);\n            // check whether each account matches the requested features\n            mAccountsWithFeatures = new ArrayList<>(mAccountsOfType.length);\n            mCurrentAccount = 0;\n\n            checkAccount();\n        }\n\n        public void checkAccount() {\n            if (mCurrentAccount >= mAccountsOfType.length) {\n                sendResult();\n                return;\n            }\n\n            final IAccountAuthenticator accountAuthenticator = mAuthenticator;\n            if (accountAuthenticator == null) {\n                // It is possible that the authenticator has died, which is indicated by\n                // mAuthenticator being set to null. If this happens then just abort.\n                // There is no need to send back a result or error in this case since\n                // that already happened when mAuthenticator was cleared.\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.v(TAG, \"checkAccount: aborting session since we are no longer\"\n                            + \" connected to the authenticator, \" + toDebugString());\n                }\n                return;\n            }\n            try {\n                accountAuthenticator.hasFeatures(this, mAccountsOfType[mCurrentAccount], mFeatures);\n            } catch (RemoteException e) {\n                onError(AccountManager.ERROR_CODE_REMOTE_EXCEPTION, \"remote exception\");\n            }\n        }\n\n        @Override\n        public void onResult(Bundle result) {\n            Bundle.setDefusable(result, true);\n            mNumResults++;\n            if (result == null) {\n                onError(AccountManager.ERROR_CODE_INVALID_RESPONSE, \"null bundle\");\n                return;\n            }\n            if (result.getBoolean(AccountManager.KEY_BOOLEAN_RESULT, false)) {\n                mAccountsWithFeatures.add(mAccountsOfType[mCurrentAccount]);\n            }\n            mCurrentAccount++;\n            checkAccount();\n        }\n\n        public void sendResult() {\n            IAccountManagerResponse response = getResponseAndClose();\n            if (response != null) {\n                try {\n                    Account[] accounts = new Account[mAccountsWithFeatures.size()];\n                    for (int i = 0; i < accounts.length; i++) {\n                        accounts[i] = mAccountsWithFeatures.get(i);\n                    }\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, getClass().getSimpleName() + \" calling onResult() on response \"\n                                + response);\n                    }\n                    Bundle result = new Bundle();\n                    result.putParcelableArray(AccountManager.KEY_ACCOUNTS, accounts);\n                    response.onResult(result);\n                } catch (RemoteException e) {\n                    // if the caller is dead then there is no one to care about remote exceptions\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, \"failure while notifying response\", e);\n                    }\n                }\n            }\n        }\n\n        @Override\n        protected String toDebugString(long now) {\n            return super.toDebugString(now) + \", getAccountsByTypeAndFeatures\"\n                    + \", \" + (mFeatures != null ? TextUtils.join(\",\", mFeatures) : null);\n        }\n    }\n\n    /**\n     * Returns the accounts visible to the client within the context of a specific user\n     * @hide\n     */\n    @NonNull\n    public Account[] getAccounts(int userId, String opPackageName) {\n        int callingUid = Binder.getCallingUid();\n        mAppOpsManager.checkPackage(callingUid, opPackageName);\n        List<String> visibleAccountTypes = getTypesVisibleToCaller(callingUid, userId,\n                opPackageName);\n        if (visibleAccountTypes.isEmpty()) {\n            return EMPTY_ACCOUNT_ARRAY;\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return getAccountsInternal(\n                    accounts,\n                    callingUid,\n                    opPackageName,\n                    visibleAccountTypes,\n                    false /* includeUserManagedNotVisible */);\n        } catch (SQLiteException e) {\n            Log.w(TAG, \"Could not get accounts for user \" + userId, e);\n            return new Account[]{};\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    /**\n     * Returns accounts for all running users, ignores visibility values.\n     *\n     * Should only be called by System process.\n     * @hide\n     */\n    @NonNull\n    public AccountAndUser[] getRunningAccountsForSystem() {\n        final int[] runningUserIds;\n        try {\n            runningUserIds = ActivityManager.getService().getRunningUserIds();\n        } catch (RemoteException e) {\n            // Running in system_server; should never happen\n            throw new RuntimeException(e);\n        }\n        return getAccountsForSystem(runningUserIds);\n    }\n\n    /**\n     * Returns accounts for all users, ignores visibility values.\n     *\n     * Should only be called by system process\n     *\n     * @hide\n     */\n    @NonNull\n    public AccountAndUser[] getAllAccountsForSystemProcess() {\n        final List<UserInfo> users = getUserManager().getAliveUsers();\n        final int[] userIds = new int[users.size()];\n        for (int i = 0; i < userIds.length; i++) {\n            userIds[i] = users.get(i).id;\n        }\n        return getAccountsForSystem(userIds);\n    }\n\n    /**\n     * Returns all accounts for the given user, ignores all visibility checks.\n     * This should only be called by system process.\n     *\n     * @hide\n     */\n    @NonNull\n    private AccountAndUser[] getAccountsForSystem(int[] userIds) {\n        final ArrayList<AccountAndUser> runningAccounts = Lists.newArrayList();\n        for (int userId : userIds) {\n            UserAccounts userAccounts = getUserAccounts(userId);\n            if (userAccounts == null) continue;\n            Account[] accounts = getAccountsFromCache(\n                    userAccounts,\n                    null /* type */,\n                    Binder.getCallingUid(),\n                    \"android\"/* packageName */,\n                    false /* include managed not visible*/);\n            for (Account account : accounts) {\n                runningAccounts.add(new AccountAndUser(account, userId));\n            }\n        }\n\n        AccountAndUser[] accountsArray = new AccountAndUser[runningAccounts.size()];\n        return runningAccounts.toArray(accountsArray);\n    }\n\n    @Override\n    @NonNull\n    public Account[] getAccountsAsUser(String type, int userId, String opPackageName) {\n        int callingUid = Binder.getCallingUid();\n        mAppOpsManager.checkPackage(callingUid, opPackageName);\n        try {\n            return getAccountsAsUserForPackage(type, userId, opPackageName /* callingPackage */, -1,\n                    opPackageName, false /* includeUserManagedNotVisible */);\n        } catch (SQLiteException e) {\n            Log.e(TAG, \"Could not get accounts for user \" + userId, e);\n            return new Account[]{};\n        }\n    }\n\n    @NonNull\n    private Account[] getAccountsOrEmptyArray(String type, int userId, String opPackageName) {\n        try {\n            return getAccountsAsUser(type, userId, opPackageName);\n        } catch (SQLiteException e) {\n            Log.w(TAG, \"Could not get accounts for user \" + userId, e);\n            return new Account[]{};\n        }\n    }\n\n    @NonNull\n    private Account[] getAccountsAsUserForPackage(\n            String type,\n            int userId,\n            String callingPackage,\n            int packageUid,\n            String opPackageName,\n            boolean includeUserManagedNotVisible) {\n        int callingUid = Binder.getCallingUid();\n        // Only allow the system process to read accounts of other users\n        if (userId != UserHandle.getCallingUserId()\n                && callingUid != Process.SYSTEM_UID\n                && mContext.checkCallingOrSelfPermission(\n                    android.Manifest.permission.INTERACT_ACROSS_USERS_FULL)\n                    != PackageManager.PERMISSION_GRANTED) {\n            throw new SecurityException(\"User \" + UserHandle.getCallingUserId()\n                    + \" trying to get account for \" + userId);\n        }\n\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"getAccounts: accountType \" + type\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid());\n        }\n\n        // If the original calling app was using account choosing activity\n        // provided by the framework or authenticator we'll passing in\n        // the original caller's uid here, which is what should be used for filtering.\n        List<String> managedTypes =\n                getTypesManagedByCaller(callingUid, UserHandle.getUserId(callingUid));\n        if (packageUid != -1 &&\n                ((UserHandle.isSameApp(callingUid, Process.SYSTEM_UID)\n                || (type != null && managedTypes.contains(type))))) {\n            callingUid = packageUid;\n            opPackageName = callingPackage;\n        }\n        List<String> visibleAccountTypes = getTypesVisibleToCaller(callingUid, userId,\n                opPackageName);\n        if (visibleAccountTypes.isEmpty()\n                || (type != null && !visibleAccountTypes.contains(type))) {\n            return EMPTY_ACCOUNT_ARRAY;\n        } else if (visibleAccountTypes.contains(type)) {\n            // Prune the list down to just the requested type.\n            visibleAccountTypes = new ArrayList<>();\n            visibleAccountTypes.add(type);\n        } // else aggregate all the visible accounts (it won't matter if the\n          // list is empty).\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return getAccountsInternal(\n                    accounts,\n                    callingUid,\n                    opPackageName,\n                    visibleAccountTypes,\n                    includeUserManagedNotVisible);\n        } catch (SQLiteException e) {\n            Log.w(TAG, \"Could not get accounts for user \" + userId, e);\n            return new Account[]{};\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @NonNull\n    private Account[] getAccountsInternal(\n            UserAccounts userAccounts,\n            int callingUid,\n            String callingPackage,\n            List<String> visibleAccountTypes,\n            boolean includeUserManagedNotVisible) {\n        ArrayList<Account> visibleAccounts = new ArrayList<>();\n        for (String visibleType : visibleAccountTypes) {\n            Account[] accountsForType = getAccountsFromCache(\n                    userAccounts, visibleType, callingUid, callingPackage,\n                    includeUserManagedNotVisible);\n            if (accountsForType != null) {\n                visibleAccounts.addAll(Arrays.asList(accountsForType));\n            }\n        }\n        Account[] result = new Account[visibleAccounts.size()];\n        for (int i = 0; i < visibleAccounts.size(); i++) {\n            result[i] = visibleAccounts.get(i);\n        }\n        return result;\n    }\n\n    @Override\n    public void addSharedAccountsFromParentUser(int parentUserId, int userId,\n            String opPackageName) {\n        checkManageOrCreateUsersPermission(\"addSharedAccountsFromParentUser\");\n        Account[] accounts = getAccountsOrEmptyArray(null, parentUserId, opPackageName);\n        for (Account account : accounts) {\n            addSharedAccountAsUser(account, userId);\n        }\n    }\n\n    private boolean addSharedAccountAsUser(Account account, int userId) {\n        userId = handleIncomingUser(userId);\n        UserAccounts accounts = getUserAccounts(userId);\n        accounts.accountsDb.deleteSharedAccount(account);\n        long accountId = accounts.accountsDb.insertSharedAccount(account);\n        if (accountId < 0) {\n            Log.w(TAG, \"insertAccountIntoDatabase: \" + account.toSafeString()\n                    + \", skipping the DB insert failed\");\n            return false;\n        }\n        logRecord(AccountsDb.DEBUG_ACTION_ACCOUNT_ADD, AccountsDb.TABLE_SHARED_ACCOUNTS, accountId,\n                accounts);\n        return true;\n    }\n\n    public boolean renameSharedAccountAsUser(Account account, String newName, int userId) {\n        userId = handleIncomingUser(userId);\n        UserAccounts accounts = getUserAccounts(userId);\n        long sharedTableAccountId = accounts.accountsDb.findSharedAccountId(account);\n        int r = accounts.accountsDb.renameSharedAccount(account, newName);\n        if (r > 0) {\n            int callingUid = getCallingUid();\n            logRecord(AccountsDb.DEBUG_ACTION_ACCOUNT_RENAME, AccountsDb.TABLE_SHARED_ACCOUNTS,\n                    sharedTableAccountId, accounts, callingUid);\n            // Recursively rename the account.\n            renameAccountInternal(accounts, account, newName);\n        }\n        return r > 0;\n    }\n\n    public boolean removeSharedAccountAsUser(Account account, int userId) {\n        return removeSharedAccountAsUser(account, userId, getCallingUid());\n    }\n\n    private boolean removeSharedAccountAsUser(Account account, int userId, int callingUid) {\n        userId = handleIncomingUser(userId);\n        UserAccounts accounts = getUserAccounts(userId);\n        long sharedTableAccountId = accounts.accountsDb.findSharedAccountId(account);\n        boolean deleted = accounts.accountsDb.deleteSharedAccount(account);\n        if (deleted) {\n            logRecord(AccountsDb.DEBUG_ACTION_ACCOUNT_REMOVE, AccountsDb.TABLE_SHARED_ACCOUNTS,\n                    sharedTableAccountId, accounts, callingUid);\n            removeAccountInternal(accounts, account, callingUid);\n        }\n        return deleted;\n    }\n\n    public Account[] getSharedAccountsAsUser(int userId) {\n        userId = handleIncomingUser(userId);\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            synchronized (accounts.dbLock) {\n                List<Account> accountList = accounts.accountsDb.getSharedAccounts();\n                Account[] accountArray = new Account[accountList.size()];\n                accountList.toArray(accountArray);\n                return accountArray;\n            }\n        } catch (SQLiteException e) {\n            Log.w(TAG, \"Could not get shared accounts for user \" + userId, e);\n            return new Account[]{};\n        }\n    }\n\n    @Override\n    @NonNull\n    public Account[] getAccountsForPackage(String packageName, int uid, String opPackageName) {\n        int callingUid = Binder.getCallingUid();\n        if (!UserHandle.isSameApp(callingUid, Process.SYSTEM_UID)) {\n            // Don't do opPackageName check - caller is system.\n            throw new SecurityException(\"getAccountsForPackage() called from unauthorized uid \"\n                    + callingUid + \" with uid=\" + uid);\n        }\n        return getAccountsAsUserForPackage(null, UserHandle.getCallingUserId(), packageName, uid,\n                opPackageName, true /* includeUserManagedNotVisible */);\n    }\n\n    @Override\n    @NonNull\n    public Account[] getAccountsByTypeForPackage(String type, String packageName,\n            String opPackageName) {\n        int callingUid =  Binder.getCallingUid();\n        int userId = UserHandle.getCallingUserId();\n        mAppOpsManager.checkPackage(callingUid, opPackageName);\n        int packageUid = -1;\n        try {\n            packageUid = mPackageManager.getPackageUidAsUser(packageName, userId);\n        } catch (NameNotFoundException re) {\n            Slog.e(TAG, \"Couldn't determine the packageUid for \" + packageName + re);\n            return EMPTY_ACCOUNT_ARRAY;\n        }\n        if (!UserHandle.isSameApp(callingUid, Process.SYSTEM_UID)\n                && (type != null && !isAccountManagedByCaller(type, callingUid, userId))) {\n                return EMPTY_ACCOUNT_ARRAY;\n        }\n        if (!UserHandle.isSameApp(callingUid, Process.SYSTEM_UID) && type == null) {\n            return getAccountsAsUserForPackage(type, userId,\n                packageName, packageUid, opPackageName, false /* includeUserManagedNotVisible */);\n        }\n        return getAccountsAsUserForPackage(type, userId,\n                packageName, packageUid, opPackageName, true /* includeUserManagedNotVisible */);\n    }\n\n    private boolean needToStartChooseAccountActivity(Account[] accounts, String callingPackage) {\n        if (accounts.length < 1) return false;\n        if (accounts.length > 1) return true;\n        Account account = accounts[0];\n        UserAccounts userAccounts = getUserAccounts(UserHandle.getCallingUserId());\n        int visibility = resolveAccountVisibility(account, callingPackage, userAccounts);\n        if (visibility == AccountManager.VISIBILITY_USER_MANAGED_NOT_VISIBLE) return true;\n        return false;\n    }\n\n    private void startChooseAccountActivityWithAccounts(\n        IAccountManagerResponse response, Account[] accounts, String callingPackage) {\n        Intent intent = new Intent(mContext, ChooseAccountActivity.class);\n        intent.putExtra(AccountManager.KEY_ACCOUNTS, accounts);\n        intent.putExtra(AccountManager.KEY_ACCOUNT_MANAGER_RESPONSE,\n                new AccountManagerResponse(response));\n        intent.putExtra(AccountManager.KEY_ANDROID_PACKAGE_NAME, callingPackage);\n\n        mContext.startActivityAsUser(intent, UserHandle.of(UserHandle.getCallingUserId()));\n    }\n\n    private void handleGetAccountsResult(\n        IAccountManagerResponse response,\n        Account[] accounts,\n        String callingPackage) {\n\n        if (needToStartChooseAccountActivity(accounts, callingPackage)) {\n            startChooseAccountActivityWithAccounts(response, accounts, callingPackage);\n            return;\n        }\n        if (accounts.length == 1) {\n            Bundle bundle = new Bundle();\n            bundle.putString(AccountManager.KEY_ACCOUNT_NAME, accounts[0].name);\n            bundle.putString(AccountManager.KEY_ACCOUNT_TYPE, accounts[0].type);\n            onResult(response, bundle);\n            return;\n        }\n        // No qualified account exists, return an empty Bundle.\n        onResult(response, new Bundle());\n    }\n\n    @Override\n    public void getAccountByTypeAndFeatures(\n        IAccountManagerResponse response,\n        String accountType,\n        String[] features,\n        String opPackageName) {\n\n        int callingUid = Binder.getCallingUid();\n        mAppOpsManager.checkPackage(callingUid, opPackageName);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"getAccount: accountType \" + accountType\n                    + \", response \" + response\n                    + \", features \" + Arrays.toString(features)\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        if (response == null) throw new IllegalArgumentException(\"response is null\");\n        if (accountType == null) throw new IllegalArgumentException(\"accountType is null\");\n\n        int userId = UserHandle.getCallingUserId();\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts userAccounts = getUserAccounts(userId);\n            if (ArrayUtils.isEmpty(features)) {\n                Account[] accountsWithManagedNotVisible = getAccountsFromCache(\n                    userAccounts, accountType, callingUid, opPackageName,\n                    true /* include managed not visible */);\n                handleGetAccountsResult(\n                    response, accountsWithManagedNotVisible, opPackageName);\n                return;\n            }\n\n            IAccountManagerResponse retrieveAccountsResponse =\n                new IAccountManagerResponse.Stub() {\n                @Override\n                public void onResult(Bundle value) throws RemoteException {\n                    Parcelable[] parcelables = value.getParcelableArray(\n                        AccountManager.KEY_ACCOUNTS);\n                    Account[] accounts = new Account[parcelables.length];\n                    for (int i = 0; i < parcelables.length; i++) {\n                        accounts[i] = (Account) parcelables[i];\n                    }\n                    handleGetAccountsResult(\n                        response, accounts, opPackageName);\n                }\n\n                @Override\n                public void onError(int errorCode, String errorMessage)\n                        throws RemoteException {\n                    // Will not be called in this case.\n                }\n            };\n            new GetAccountsByTypeAndFeatureSession(\n                    userAccounts,\n                    retrieveAccountsResponse,\n                    accountType,\n                    features,\n                    callingUid,\n                    opPackageName,\n                    true /* include managed not visible */).bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void getAccountsByFeatures(\n            IAccountManagerResponse response,\n            String type,\n            String[] features,\n            String opPackageName) {\n        int callingUid = Binder.getCallingUid();\n        mAppOpsManager.checkPackage(callingUid, opPackageName);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"getAccounts: accountType \" + type\n                    + \", response \" + response\n                    + \", features \" + Arrays.toString(features)\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        if (response == null) throw new IllegalArgumentException(\"response is null\");\n        if (type == null) throw new IllegalArgumentException(\"accountType is null\");\n        int userId = UserHandle.getCallingUserId();\n\n        List<String> visibleAccountTypes = getTypesVisibleToCaller(callingUid, userId,\n                opPackageName);\n        if (!visibleAccountTypes.contains(type)) {\n            Bundle result = new Bundle();\n            // Need to return just the accounts that are from matching signatures.\n            result.putParcelableArray(AccountManager.KEY_ACCOUNTS, EMPTY_ACCOUNT_ARRAY);\n            try {\n                response.onResult(result);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Cannot respond to caller do to exception.\" , e);\n            }\n            return;\n        }\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts userAccounts = getUserAccounts(userId);\n            if (features == null || features.length == 0) {\n                Account[] accounts = getAccountsFromCache(userAccounts, type, callingUid,\n                        opPackageName, false);\n                Bundle result = new Bundle();\n                result.putParcelableArray(AccountManager.KEY_ACCOUNTS, accounts);\n                onResult(response, result);\n                return;\n            }\n            new GetAccountsByTypeAndFeatureSession(\n                    userAccounts,\n                    response,\n                    type,\n                    features,\n                    callingUid,\n                    opPackageName,\n                    false /* include managed not visible */).bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void onAccountAccessed(String token) throws RemoteException {\n        final int uid = Binder.getCallingUid();\n        if (UserHandle.getAppId(uid) == Process.SYSTEM_UID) {\n            return;\n        }\n        final int userId = UserHandle.getCallingUserId();\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            for (Account account : getAccounts(userId, mContext.getOpPackageName())) {\n                if (Objects.equals(account.getAccessId(), token)) {\n                    // An app just accessed the account. At this point it knows about\n                    // it and there is not need to hide this account from the app.\n                    // Do we need to update account visibility here?\n                    if (!hasAccountAccess(account, null, uid)) {\n                        updateAppPermission(account, AccountManager.ACCOUNT_ACCESS_TOKEN_TYPE,\n                                uid, true);\n                    }\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    @Override\n    public void onShellCommand(FileDescriptor in, FileDescriptor out,\n            FileDescriptor err, String[] args, ShellCallback callback,\n            ResultReceiver resultReceiver) {\n        new AccountManagerServiceShellCommand(this).exec(this, in, out, err, args,\n                callback, resultReceiver);\n    }\n\n    private abstract class Session extends IAccountAuthenticatorResponse.Stub\n            implements IBinder.DeathRecipient, ServiceConnection {\n        private final Object mSessionLock = new Object();\n        IAccountManagerResponse mResponse;\n        final String mAccountType;\n        final boolean mExpectActivityLaunch;\n        final long mCreationTime;\n        final String mAccountName;\n        // Indicates if we need to add auth details(like last credential time)\n        final boolean mAuthDetailsRequired;\n        // If set, we need to update the last authenticated time. This is\n        // currently\n        // used on\n        // successful confirming credentials.\n        final boolean mUpdateLastAuthenticatedTime;\n\n        public int mNumResults = 0;\n        private int mNumRequestContinued = 0;\n        private int mNumErrors = 0;\n\n        IAccountAuthenticator mAuthenticator = null;\n\n        private final boolean mStripAuthTokenFromResult;\n        protected boolean mCanStartAccountManagerActivity = false;\n        protected final UserAccounts mAccounts;\n\n        private int mAuthenticatorUid;\n        private long mBindingStartTime;\n\n        public Session(UserAccounts accounts, IAccountManagerResponse response, String accountType,\n                boolean expectActivityLaunch, boolean stripAuthTokenFromResult, String accountName,\n                boolean authDetailsRequired) {\n            this(accounts, response, accountType, expectActivityLaunch, stripAuthTokenFromResult,\n                    accountName, authDetailsRequired, false /* updateLastAuthenticatedTime */);\n        }\n\n        public Session(UserAccounts accounts, IAccountManagerResponse response, String accountType,\n                boolean expectActivityLaunch, boolean stripAuthTokenFromResult, String accountName,\n                boolean authDetailsRequired, boolean updateLastAuthenticatedTime) {\n            super();\n            //if (response == null) throw new IllegalArgumentException(\"response is null\");\n            if (accountType == null) throw new IllegalArgumentException(\"accountType is null\");\n            mAccounts = accounts;\n            mStripAuthTokenFromResult = stripAuthTokenFromResult;\n            mAccountType = accountType;\n            mExpectActivityLaunch = expectActivityLaunch;\n            mCreationTime = SystemClock.elapsedRealtime();\n            mAccountName = accountName;\n            mAuthDetailsRequired = authDetailsRequired;\n            mUpdateLastAuthenticatedTime = updateLastAuthenticatedTime;\n\n            synchronized (mSessions) {\n                mSessions.put(toString(), this);\n            }\n            scheduleTimeout();\n            if (response != null) {\n                try {\n                    response.asBinder().linkToDeath(this, 0 /* flags */);\n                    mResponse = response;\n                } catch (RemoteException e) {\n                    binderDied();\n                }\n            }\n        }\n\n        IAccountManagerResponse getResponseAndClose() {\n            if (mAuthenticatorUid != 0 && mBindingStartTime > 0) {\n                sResponseLatency.logSampleWithUid(mAuthenticatorUid,\n                        SystemClock.uptimeMillis() - mBindingStartTime);\n            }\n            if (mResponse == null) {\n                close();\n                return null;\n            }\n            IAccountManagerResponse response = mResponse;\n            close(); // this clears mResponse so we need to save the response before this call\n            return response;\n        }\n\n        /**\n         * Checks Intents, supplied via KEY_INTENT, to make sure that they don't violate our\n         * security policy.\n         *\n         * In particular we want to make sure that the Authenticator doesn't try to trick users\n         * into launching arbitrary intents on the device via by tricking to click authenticator\n         * supplied entries in the system Settings app.\n         */\n        protected boolean checkKeyIntent(int authUid, Bundle bundle) {\n            if (!checkKeyIntentParceledCorrectly(bundle)) {\n                EventLog.writeEvent(0x534e4554, \"250588548\", authUid, \"\");\n                return false;\n            }\n            Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT, Intent.class);\n            if (intent == null) {\n                return true;\n            }\n            // Explicitly set an empty ClipData to ensure that we don't offer to\n            // promote any Uris contained inside for granting purposes\n            if (intent.getClipData() == null) {\n                intent.setClipData(ClipData.newPlainText(null, null));\n            }\n            final long bid = Binder.clearCallingIdentity();\n            try {\n                PackageManager pm = mContext.getPackageManager();\n                ResolveInfo resolveInfo = pm.resolveActivityAsUser(intent, 0, mAccounts.userId);\n                if (resolveInfo == null) {\n                    return false;\n                }\n                if (\"content\".equals(intent.getScheme())) {\n                    return false;\n                }\n                ActivityInfo targetActivityInfo = resolveInfo.activityInfo;\n                int targetUid = targetActivityInfo.applicationInfo.uid;\n                PackageManagerInternal pmi = LocalServices.getService(PackageManagerInternal.class);\n                if (!isExportedSystemActivity(targetActivityInfo)\n                        && !pmi.hasSignatureCapability(targetUid, authUid, CertCapabilities.AUTH)) {\n                    String pkgName = targetActivityInfo.packageName;\n                    String activityName = targetActivityInfo.name;\n                    String tmpl = \"KEY_INTENT resolved to an Activity (%s) in a package (%s) that \"\n                            + \"does not share a signature with the supplying authenticator (%s).\";\n                    Log.e(TAG, String.format(tmpl, activityName, pkgName, mAccountType));\n                    return false;\n                }\n                intent.setComponent(targetActivityInfo.getComponentName());\n                bundle.putParcelable(AccountManager.KEY_INTENT, intent);\n                return true;\n            } finally {\n                Binder.restoreCallingIdentity(bid);\n            }\n        }\n\n        /**\n         * Simulate the client side's deserialization of KEY_INTENT value, to make sure they don't\n         * violate our security policy.\n         *\n         * In particular we want to make sure the Authenticator doesn't trick users\n         * into launching arbitrary intents on the device via exploiting any other Parcel read/write\n         * mismatch problems.\n         */\n        private boolean checkKeyIntentParceledCorrectly(Bundle bundle) {\n            Parcel p = Parcel.obtain();\n            p.writeBundle(bundle);\n            p.setDataPosition(0);\n            Bundle simulateBundle = p.readBundle();\n            p.recycle();\n            Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT, Intent.class);\n            Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT,\n                    Intent.class);\n            if (intent == null) {\n                return (simulateIntent == null);\n            }\n            if (intent.getClass() != Intent.class || simulateIntent.getClass() != Intent.class) {\n                return false;\n            }\n\n            if (!intent.filterEquals(simulateIntent)) {\n                return false;\n            }\n\n            if (intent.getSelector() != simulateIntent.getSelector()) {\n                return false;\n            }\n\n            int prohibitedFlags = Intent.FLAG_GRANT_READ_URI_PERMISSION\n                    | Intent.FLAG_GRANT_WRITE_URI_PERMISSION\n                    | Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION\n                    | Intent.FLAG_GRANT_PREFIX_URI_PERMISSION;\n            return (simulateIntent.getFlags() & prohibitedFlags) == 0;\n        }\n\n        private boolean isExportedSystemActivity(ActivityInfo activityInfo) {\n            String className = activityInfo.name;\n            if (!\"android\".equals(activityInfo.packageName)) {\n                return false;\n\n            }\n            return (mCanStartAccountManagerActivity\n                    && GrantCredentialsPermissionActivity.class.getName().equals(className))\n                    || CantAddAccountActivity.class.getName().equals(className);\n        }\n\n        private void close() {\n            synchronized (mSessions) {\n                if (mSessions.remove(toString()) == null) {\n                    // the session was already closed, so bail out now\n                    return;\n                }\n            }\n            if (mResponse != null) {\n                // stop listening for response deaths\n                mResponse.asBinder().unlinkToDeath(this, 0 /* flags */);\n\n                // clear this so that we don't accidentally send any further results\n                mResponse = null;\n            }\n            cancelTimeout();\n            unbind();\n        }\n\n        @Override\n        public void binderDied() {\n            mResponse = null;\n            close();\n        }\n\n        protected String toDebugString() {\n            return toDebugString(SystemClock.elapsedRealtime());\n        }\n\n        protected String toDebugString(long now) {\n            return \"Session: expectLaunch \" + mExpectActivityLaunch\n                    + \", connected \" + (mAuthenticator != null)\n                    + \", stats (\" + mNumResults + \"/\" + mNumRequestContinued\n                    + \"/\" + mNumErrors + \")\"\n                    + \", lifetime \" + ((now - mCreationTime) / 1000.0);\n        }\n\n        void bind() {\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"initiating bind to authenticator type \" + mAccountType);\n            }\n            if (!bindToAuthenticator(mAccountType)) {\n                Log.w(TAG, \"bind attempt failed for \" + toDebugString());\n                onError(AccountManager.ERROR_CODE_REMOTE_EXCEPTION, \"bind failure\");\n            }\n        }\n\n        private void unbind() {\n            synchronized (mSessionLock) {\n                if (mAuthenticator != null) {\n                    mAuthenticator = null;\n                    mContext.unbindService(this);\n                }\n            }\n        }\n\n        private void scheduleTimeout() {\n            mHandler.sendMessageDelayed(\n                    mHandler.obtainMessage(MESSAGE_TIMED_OUT, this), TIMEOUT_DELAY_MS);\n        }\n\n        public void cancelTimeout() {\n            mHandler.removeMessages(MESSAGE_TIMED_OUT, this);\n        }\n\n        @Override\n        public void onServiceConnected(ComponentName name, IBinder service) {\n            synchronized (mSessionLock) {\n                mAuthenticator = IAccountAuthenticator.Stub.asInterface(service);\n                try {\n                    run();\n                } catch (RemoteException e) {\n                    onError(AccountManager.ERROR_CODE_REMOTE_EXCEPTION,\n                            \"remote exception\");\n                }\n            }\n        }\n\n        @Override\n        public void onServiceDisconnected(ComponentName name) {\n            IAccountManagerResponse response = getResponseAndClose();\n            if (response != null) {\n                try {\n                    response.onError(AccountManager.ERROR_CODE_REMOTE_EXCEPTION,\n                            \"disconnected\");\n                } catch (RemoteException e) {\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, \"Session.onServiceDisconnected: \"\n                                + \"caught RemoteException while responding\", e);\n                    }\n                }\n            }\n        }\n\n        public abstract void run() throws RemoteException;\n\n        public void onTimedOut() {\n            IAccountManagerResponse response = getResponseAndClose();\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"Session.onTimedOut\");\n            }\n            if (response != null) {\n                try {\n                    response.onError(AccountManager.ERROR_CODE_REMOTE_EXCEPTION,\n                            \"timeout\");\n                } catch (RemoteException e) {\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, \"Session.onTimedOut: caught RemoteException while responding\",\n                                e);\n                    }\n                }\n            }\n        }\n\n        @Override\n        public void onResult(Bundle result) {\n            Bundle.setDefusable(result, true);\n            mNumResults++;\n            Intent intent = null;\n            if (result != null) {\n                boolean isSuccessfulConfirmCreds = result.getBoolean(\n                        AccountManager.KEY_BOOLEAN_RESULT, false);\n                boolean isSuccessfulUpdateCredsOrAddAccount =\n                        result.containsKey(AccountManager.KEY_ACCOUNT_NAME)\n                        && result.containsKey(AccountManager.KEY_ACCOUNT_TYPE);\n                // We should only update lastAuthenticated time, if\n                // mUpdateLastAuthenticatedTime is true and the confirmRequest\n                // or updateRequest was successful\n                boolean needUpdate = mUpdateLastAuthenticatedTime\n                        && (isSuccessfulConfirmCreds || isSuccessfulUpdateCredsOrAddAccount);\n                if (needUpdate || mAuthDetailsRequired) {\n                    boolean accountPresent = isAccountPresentForCaller(mAccountName, mAccountType);\n                    if (needUpdate && accountPresent) {\n                        updateLastAuthenticatedTime(new Account(mAccountName, mAccountType));\n                    }\n                    if (mAuthDetailsRequired) {\n                        long lastAuthenticatedTime = -1;\n                        if (accountPresent) {\n                            lastAuthenticatedTime = mAccounts.accountsDb\n                                    .findAccountLastAuthenticatedTime(\n                                            new Account(mAccountName, mAccountType));\n                        }\n                        result.putLong(AccountManager.KEY_LAST_AUTHENTICATED_TIME,\n                                lastAuthenticatedTime);\n                    }\n                }\n            }\n            if (result != null) {\n                if (!checkKeyIntent(\n                        Binder.getCallingUid(),\n                        result)) {\n                    onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                            \"invalid intent in bundle returned\");\n                    return;\n                }\n            }\n            if (result != null\n                    && !TextUtils.isEmpty(result.getString(AccountManager.KEY_AUTHTOKEN))) {\n                String accountName = result.getString(AccountManager.KEY_ACCOUNT_NAME);\n                String accountType = result.getString(AccountManager.KEY_ACCOUNT_TYPE);\n                if (!TextUtils.isEmpty(accountName) && !TextUtils.isEmpty(accountType)) {\n                    Account account = new Account(accountName, accountType);\n                    cancelNotification(getSigninRequiredNotificationId(mAccounts, account),\n                            mAccounts);\n                }\n            }\n            IAccountManagerResponse response;\n            if (mExpectActivityLaunch && result != null\n                    && result.containsKey(AccountManager.KEY_INTENT)) {\n                response = mResponse;\n            } else {\n                response = getResponseAndClose();\n            }\n            if (response != null) {\n                try {\n                    if (result == null) {\n                        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                            Log.v(TAG, getClass().getSimpleName()\n                                    + \" calling onError() on response \" + response);\n                        }\n                        response.onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                                \"null bundle returned\");\n                    } else {\n                        if (mStripAuthTokenFromResult) {\n                            result.remove(AccountManager.KEY_AUTHTOKEN);\n                            if (!checkKeyIntent(Binder.getCallingUid(), result)) {\n                                onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                                        \"invalid intent in bundle returned\");\n                                return;\n                            }\n                        }\n                        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                            Log.v(TAG, getClass().getSimpleName()\n                                    + \" calling onResult() on response \" + response);\n                        }\n                        if ((result.getInt(AccountManager.KEY_ERROR_CODE, -1) > 0) &&\n                                (intent == null)) {\n                            // All AccountManager error codes are greater than 0\n                            response.onError(result.getInt(AccountManager.KEY_ERROR_CODE),\n                                    result.getString(AccountManager.KEY_ERROR_MESSAGE));\n                        } else {\n                            response.onResult(result);\n                        }\n                    }\n                } catch (RemoteException e) {\n                    // if the caller is dead then there is no one to care about remote exceptions\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, \"failure while notifying response\", e);\n                    }\n                }\n            }\n        }\n\n        @Override\n        public void onRequestContinued() {\n            mNumRequestContinued++;\n        }\n\n        @Override\n        public void onError(int errorCode, String errorMessage) {\n            mNumErrors++;\n            IAccountManagerResponse response = getResponseAndClose();\n            if (response != null) {\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.v(TAG, getClass().getSimpleName()\n                            + \" calling onError() on response \" + response);\n                }\n                try {\n                    response.onError(errorCode, errorMessage);\n                } catch (RemoteException e) {\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, \"Session.onError: caught RemoteException while responding\", e);\n                    }\n                }\n            } else {\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.v(TAG, \"Session.onError: already closed\");\n                }\n            }\n        }\n\n        /**\n         * find the component name for the authenticator and initiate a bind\n         * if no authenticator or the bind fails then return false, otherwise return true\n         */\n        private boolean bindToAuthenticator(String authenticatorType) {\n            final AccountAuthenticatorCache.ServiceInfo<AuthenticatorDescription> authenticatorInfo;\n            authenticatorInfo = mAuthenticatorCache.getServiceInfo(\n                    AuthenticatorDescription.newKey(authenticatorType), mAccounts.userId);\n            if (authenticatorInfo == null) {\n                Log.w(TAG, \"there is no authenticator for \" + authenticatorType\n                        + \", bailing out\");\n\n                return false;\n            }\n\n            if (!isLocalUnlockedUser(mAccounts.userId)\n                    && !authenticatorInfo.componentInfo.directBootAware) {\n                Slog.w(TAG, \"Blocking binding to authenticator \" + authenticatorInfo.componentName\n                        + \" which isn't encryption aware\");\n                return false;\n            }\n\n            Intent intent = new Intent();\n            intent.setAction(AccountManager.ACTION_AUTHENTICATOR_INTENT);\n            intent.setComponent(authenticatorInfo.componentName);\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"performing bindService to \" + authenticatorInfo.componentName);\n            }\n            long flags = Context.BIND_AUTO_CREATE;\n            if (mAuthenticatorCache.getBindInstantServiceAllowed(mAccounts.userId)) {\n                flags |= Context.BIND_ALLOW_INSTANT;\n            }\n            if (!mContext.bindServiceAsUser(intent, this, Context.BindServiceFlags.of(flags),\n                    UserHandle.of(mAccounts.userId))) {\n                Log.w(TAG, \"bindService to \" + authenticatorInfo.componentName + \" failed\");\n                // Perform unbind as per documentation at Context.bindServiceAsUser\n                mContext.unbindService(this);\n                return false;\n            }\n            mAuthenticatorUid = authenticatorInfo.uid;\n            mBindingStartTime = SystemClock.uptimeMillis();\n            return true;\n        }\n    }\n\n    class MessageHandler extends Handler {\n        MessageHandler(Looper looper) {\n            super(looper);\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MESSAGE_TIMED_OUT:\n                    Session session = (Session)msg.obj;\n                    session.onTimedOut();\n                    break;\n\n                case MESSAGE_COPY_SHARED_ACCOUNT:\n                    copyAccountToUser(/*no response*/ null, (Account) msg.obj, msg.arg1, msg.arg2);\n                    break;\n\n                default:\n                    throw new IllegalStateException(\"unhandled message: \" + msg.what);\n            }\n        }\n    }\n\n    private void logRecord(UserAccounts accounts, String action, String tableName) {\n        logRecord(action, tableName, -1, accounts);\n    }\n\n    private void logRecordWithUid(UserAccounts accounts, String action, String tableName, int uid) {\n        logRecord(action, tableName, -1, accounts, uid);\n    }\n\n    /*\n     * This function receives an opened writable database.\n     */\n    private void logRecord(String action, String tableName, long accountId,\n            UserAccounts userAccount) {\n        logRecord(action, tableName, accountId, userAccount, getCallingUid());\n    }\n\n    /*\n     * This function receives an opened writable database and writes to it in a separate thread.\n     */\n    private void logRecord(String action, String tableName, long accountId,\n            UserAccounts userAccount, int callingUid) {\n\n        class LogRecordTask implements Runnable {\n            private final String action;\n            private final String tableName;\n            private final long accountId;\n            private final UserAccounts userAccount;\n            private final int callingUid;\n            private final long userDebugDbInsertionPoint;\n\n            LogRecordTask(final String action,\n                    final String tableName,\n                    final long accountId,\n                    final UserAccounts userAccount,\n                    final int callingUid,\n                    final long userDebugDbInsertionPoint) {\n                this.action = action;\n                this.tableName = tableName;\n                this.accountId = accountId;\n                this.userAccount = userAccount;\n                this.callingUid = callingUid;\n                this.userDebugDbInsertionPoint = userDebugDbInsertionPoint;\n            }\n\n            @Override\n            public void run() {\n                synchronized (userAccount.accountsDb.mDebugStatementLock) {\n                    SQLiteStatement logStatement = userAccount.accountsDb.getStatementForLogging();\n                    if (logStatement == null) {\n                        return; // Can't log.\n                    }\n                    logStatement.bindLong(1, accountId);\n                    logStatement.bindString(2, action);\n                    logStatement.bindString(3, mDateFormat.format(new Date()));\n                    logStatement.bindLong(4, callingUid);\n                    logStatement.bindString(5, tableName);\n                    logStatement.bindLong(6, userDebugDbInsertionPoint);\n                    try {\n                        logStatement.execute();\n                    } catch (IllegalStateException | SQLiteFullException e) {\n                        // Guard against crash, DB can already be closed\n                        // since this statement is executed on a handler thread\n                        Slog.w(TAG, \"Failed to insert a log record. accountId=\" + accountId\n                                + \" action=\" + action + \" tableName=\" + tableName + \" Error: \" + e);\n                    } finally {\n                        logStatement.clearBindings();\n                    }\n                }\n            }\n        }\n        long insertionPoint = userAccount.accountsDb.reserveDebugDbInsertionPoint();\n        if (insertionPoint != -1) {\n            LogRecordTask logTask = new LogRecordTask(action, tableName, accountId, userAccount,\n                    callingUid, insertionPoint);\n            mHandler.post(logTask);\n        }\n    }\n\n    public IBinder onBind(@SuppressWarnings(\"unused\") Intent intent) {\n        return asBinder();\n    }\n\n    /**\n     * Searches array of arguments for the specified string\n     * @param args array of argument strings\n     * @param value value to search for\n     * @return true if the value is contained in the array\n     */\n    private static boolean scanArgs(String[] args, String value) {\n        if (args != null) {\n            for (String arg : args) {\n                if (value.equals(arg)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    @Override\n    protected void dump(FileDescriptor fd, PrintWriter fout, String[] args) {\n        if (!DumpUtils.checkDumpPermission(mContext, TAG, fout)) return;\n        final boolean isCheckinRequest = scanArgs(args, \"--checkin\") || scanArgs(args, \"-c\");\n        final IndentingPrintWriter ipw = new IndentingPrintWriter(fout, \"  \");\n\n        final List<UserInfo> users = getUserManager().getUsers();\n        for (UserInfo user : users) {\n            ipw.println(\"User \" + user + \":\");\n            ipw.increaseIndent();\n            dumpUser(getUserAccounts(user.id), fd, ipw, args, isCheckinRequest);\n            ipw.println();\n            ipw.decreaseIndent();\n        }\n    }\n\n    private void dumpUser(UserAccounts userAccounts, FileDescriptor fd, PrintWriter fout,\n            String[] args, boolean isCheckinRequest) {\n        if (isCheckinRequest) {\n            // This is a checkin request. *Only* upload the account types and the count of\n            // each.\n            synchronized (userAccounts.dbLock) {\n                userAccounts.accountsDb.dumpDeAccountsTable(fout);\n            }\n        } else {\n            Account[] accounts = getAccountsFromCache(userAccounts, null /* type */,\n                    Process.SYSTEM_UID, \"android\" /* packageName */, false);\n            fout.println(\"Accounts: \" + accounts.length);\n            for (Account account : accounts) {\n                fout.println(\"  \" + account.toString());\n            }\n\n            // Add debug information.\n            fout.println();\n            synchronized (userAccounts.dbLock) {\n                userAccounts.accountsDb.dumpDebugTable(fout);\n            }\n            fout.println();\n            synchronized (mSessions) {\n                final long now = SystemClock.elapsedRealtime();\n                fout.println(\"Active Sessions: \" + mSessions.size());\n                for (Session session : mSessions.values()) {\n                    fout.println(\"  \" + session.toDebugString(now));\n                }\n            }\n\n            fout.println();\n            mAuthenticatorCache.dump(fd, fout, args, userAccounts.userId);\n\n            boolean isUserUnlocked;\n            synchronized (mUsers) {\n                isUserUnlocked = isLocalUnlockedUser(userAccounts.userId);\n            }\n            // Following logs are printed only when user is unlocked.\n            if (!isUserUnlocked) {\n                return;\n            }\n            fout.println();\n            synchronized (userAccounts.dbLock) {\n                Map<Account, Map<String, Integer>> allVisibilityValues =\n                        userAccounts.accountsDb.findAllVisibilityValues();\n                fout.println(\"Account visibility:\");\n                for (Account account : allVisibilityValues.keySet()) {\n                    fout.println(\"  \" + account.name);\n                    Map<String, Integer> visibilities = allVisibilityValues.get(account);\n                    for (Entry<String, Integer> entry : visibilities.entrySet()) {\n                        fout.println(\"    \" + entry.getKey() + \", \" + entry.getValue());\n                    }\n                }\n            }\n        }\n    }\n\n    private void doNotification(UserAccounts accounts, Account account, CharSequence message,\n            Intent intent, String packageName, final int userId) {\n        final long identityToken = clearCallingIdentity();\n        try {\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"doNotification: \" + message + \" intent:\" + intent);\n            }\n\n            if (intent.getComponent() != null &&\n                    GrantCredentialsPermissionActivity.class.getName().equals(\n                            intent.getComponent().getClassName())) {\n                createNoCredentialsPermissionNotification(account, intent, packageName, accounts);\n            } else {\n                Context contextForUser = getContextForUser(new UserHandle(userId));\n                final NotificationId id = getSigninRequiredNotificationId(accounts, account);\n                intent.addCategory(id.mTag);\n\n                final String notificationTitleFormat =\n                        contextForUser.getText(R.string.notification_title).toString();\n                Notification n =\n                        new Notification.Builder(contextForUser, SystemNotificationChannels.ACCOUNT)\n                        .setWhen(0)\n                        .setSmallIcon(android.R.drawable.stat_sys_warning)\n                        .setColor(contextForUser.getColor(\n                                com.android.internal.R.color.system_notification_accent_color))\n                        .setContentTitle(String.format(notificationTitleFormat, account.name))\n                        .setContentText(message)\n                        .setContentIntent(PendingIntent.getActivityAsUser(\n                                mContext, 0, intent,\n                                PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_IMMUTABLE,\n                                null, new UserHandle(userId)))\n                        .build();\n                installNotification(id, n, packageName, userId);\n            }\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private void installNotification(NotificationId id, final Notification notification,\n            String packageName, int userId) {\n        final long token = clearCallingIdentity();\n        try {\n            INotificationManager notificationManager = mInjector.getNotificationManager();\n            try {\n                // The calling uid must match either the package or op package, so use an op\n                // package that matches the cleared calling identity.\n                notificationManager.enqueueNotificationWithTag(packageName, \"android\",\n                        id.mTag, id.mId, notification, userId);\n            } catch (RemoteException e) {\n                /* ignore - local call */\n            }\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private void cancelNotification(NotificationId id, UserAccounts accounts) {\n        cancelNotification(id, mContext.getPackageName(), accounts);\n    }\n\n    private void cancelNotification(NotificationId id, String packageName, UserAccounts accounts) {\n        final long identityToken = clearCallingIdentity();\n        try {\n            INotificationManager service = mInjector.getNotificationManager();\n            service.cancelNotificationWithTag(\n                    packageName, \"android\", id.mTag, id.mId,\n                    UserHandle.of(accounts.userId).getIdentifier());\n        } catch (RemoteException e) {\n            /* ignore - local call */\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private boolean isPermittedForPackage(String packageName, int userId, String... permissions) {\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            final int uid = mPackageManager.getPackageUidAsUser(packageName, userId);\n            IPackageManager pm = ActivityThread.getPackageManager();\n            for (String perm : permissions) {\n                if (pm.checkPermission(perm, packageName, userId)\n                        == PackageManager.PERMISSION_GRANTED) {\n                    // Checks runtime permission revocation.\n                    final int opCode = AppOpsManager.permissionToOpCode(perm);\n                    if (opCode == AppOpsManager.OP_NONE || mAppOpsManager.checkOpNoThrow(\n                            opCode, uid, packageName) == AppOpsManager.MODE_ALLOWED) {\n                        return true;\n                    }\n                }\n            }\n        } catch (NameNotFoundException | RemoteException e) {\n            // Assume permission is not granted if an error accrued.\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n        return false;\n    }\n\n    /**\n     * Checks that package has at least one of given permissions and makes note of app\n     * performing the action.\n     */\n    private boolean checkPermissionAndNote(String opPackageName, int callingUid,\n            String... permissions) {\n        for (String perm : permissions) {\n            if (mContext.checkCallingOrSelfPermission(perm) == PackageManager.PERMISSION_GRANTED) {\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.v(TAG, \"  caller uid \" + callingUid + \" has \" + perm);\n                }\n                final int opCode = AppOpsManager.permissionToOpCode(perm);\n                if (opCode == AppOpsManager.OP_NONE || mAppOpsManager.noteOpNoThrow(\n                        opCode, callingUid, opPackageName) == AppOpsManager.MODE_ALLOWED) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private int handleIncomingUser(int userId) {\n        try {\n            return ActivityManager.getService().handleIncomingUser(\n                    Binder.getCallingPid(), Binder.getCallingUid(), userId, true, true, \"\", null);\n        } catch (RemoteException re) {\n            // Shouldn't happen, local.\n        }\n        return userId;\n    }\n\n    private boolean isPrivileged(int callingUid) {\n        String[] packages;\n        final long identityToken = Binder.clearCallingIdentity();\n        try {\n            packages = mPackageManager.getPackagesForUid(callingUid);\n            if (packages == null) {\n                Log.d(TAG, \"No packages for callingUid \" + callingUid);\n                return false;\n            }\n            for (String name : packages) {\n                try {\n                    PackageInfo packageInfo =\n                        mPackageManager.getPackageInfo(name, 0 /* flags */);\n                    if (packageInfo != null\n                        && (packageInfo.applicationInfo.privateFlags\n                            & ApplicationInfo.PRIVATE_FLAG_PRIVILEGED) != 0) {\n                        return true;\n                    }\n                } catch (PackageManager.NameNotFoundException e) {\n                    Log.w(TAG, \"isPrivileged#Package not found \" + e.getMessage());\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identityToken);\n        }\n        return false;\n    }\n\n    private boolean permissionIsGranted(\n            Account account, String authTokenType, int callerUid, int userId) {\n        if (UserHandle.getAppId(callerUid) == Process.SYSTEM_UID) {\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"Access to \" + account + \" granted calling uid is system\");\n            }\n            return true;\n        }\n\n        if (isPrivileged(callerUid)) {\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"Access to \" + account + \" granted calling uid \"\n                        + callerUid + \" privileged\");\n            }\n            return true;\n        }\n        if (account != null && isAccountManagedByCaller(account.type, callerUid, userId)) {\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"Access to \" + account + \" granted calling uid \"\n                        + callerUid + \" manages the account\");\n            }\n            return true;\n        }\n        if (account != null && hasExplicitlyGrantedPermission(account, authTokenType, callerUid)) {\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"Access to \" + account + \" granted calling uid \"\n                        + callerUid + \" user granted access\");\n            }\n            return true;\n        }\n\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"Access to \" + account + \" not granted for uid \" + callerUid);\n        }\n\n        return false;\n    }\n\n    private boolean isAccountVisibleToCaller(String accountType, int callingUid, int userId,\n            String opPackageName) {\n        if (accountType == null) {\n            return false;\n        } else {\n            return getTypesVisibleToCaller(callingUid, userId,\n                    opPackageName).contains(accountType);\n        }\n    }\n\n    // Method checks visibility for applications targeing API level below {@link\n    // android.os.Build.VERSION_CODES#O},\n    // returns true if the the app has GET_ACCOUNTS or GET_ACCOUNTS_PRIVILEGED permission.\n    private boolean checkGetAccountsPermission(String packageName, int userId) {\n        return isPermittedForPackage(packageName, userId, Manifest.permission.GET_ACCOUNTS,\n                Manifest.permission.GET_ACCOUNTS_PRIVILEGED);\n    }\n\n    private boolean checkReadContactsPermission(String packageName, int userId) {\n        return isPermittedForPackage(packageName, userId, Manifest.permission.READ_CONTACTS);\n    }\n\n    // Heuristic to check that account type may be associated with some contacts data and\n    // therefore READ_CONTACTS permission grants the access to account by default.\n    private boolean accountTypeManagesContacts(String accountType, int userId) {\n        if (accountType == null) {\n            return false;\n        }\n        final long identityToken = Binder.clearCallingIdentity();\n        Collection<RegisteredServicesCache.ServiceInfo<AuthenticatorDescription>> serviceInfos;\n        try {\n            serviceInfos = mAuthenticatorCache.getAllServices(userId);\n        } finally {\n            Binder.restoreCallingIdentity(identityToken);\n        }\n        // Check contacts related permissions for authenticator.\n        for (RegisteredServicesCache.ServiceInfo<AuthenticatorDescription> serviceInfo\n                : serviceInfos) {\n            if (accountType.equals(serviceInfo.type.type)) {\n                return isPermittedForPackage(serviceInfo.type.packageName, userId,\n                    Manifest.permission.WRITE_CONTACTS);\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Method checks package uid and signature with Authenticator which manages accountType.\n     *\n     * @return SIGNATURE_CHECK_UID_MATCH for uid match, SIGNATURE_CHECK_MATCH for signature match,\n     *         SIGNATURE_CHECK_MISMATCH otherwise.\n     */\n    private int checkPackageSignature(String accountType, int callingUid, int userId) {\n        if (accountType == null) {\n            return SIGNATURE_CHECK_MISMATCH;\n        }\n\n        final long identityToken = Binder.clearCallingIdentity();\n        Collection<RegisteredServicesCache.ServiceInfo<AuthenticatorDescription>> serviceInfos;\n        try {\n            serviceInfos = mAuthenticatorCache.getAllServices(userId);\n        } finally {\n            Binder.restoreCallingIdentity(identityToken);\n        }\n        // Check for signature match with Authenticator.LocalServices.getService(PackageManagerInternal.class);\n        PackageManagerInternal pmi = LocalServices.getService(PackageManagerInternal.class);\n        for (RegisteredServicesCache.ServiceInfo<AuthenticatorDescription> serviceInfo\n                : serviceInfos) {\n            if (accountType.equals(serviceInfo.type.type)) {\n                if (serviceInfo.uid == callingUid) {\n                    return SIGNATURE_CHECK_UID_MATCH;\n                }\n                if (pmi.hasSignatureCapability(\n                        serviceInfo.uid, callingUid, CertCapabilities.AUTH)) {\n                    return SIGNATURE_CHECK_MATCH;\n                }\n            }\n        }\n        return SIGNATURE_CHECK_MISMATCH;\n    }\n\n    // returns true for applications with the same signature as authenticator.\n    private boolean isAccountManagedByCaller(String accountType, int callingUid, int userId) {\n        if (accountType == null) {\n            return false;\n        } else {\n            return getTypesManagedByCaller(callingUid, userId).contains(accountType);\n        }\n    }\n\n    private List<String> getTypesVisibleToCaller(int callingUid, int userId,\n            String opPackageName) {\n        return getTypesForCaller(callingUid, userId, true /* isOtherwisePermitted*/);\n    }\n\n    private List<String> getTypesManagedByCaller(int callingUid, int userId) {\n        return getTypesForCaller(callingUid, userId, false);\n    }\n\n    private List<String> getTypesForCaller(\n            int callingUid, int userId, boolean isOtherwisePermitted) {\n        List<String> managedAccountTypes = new ArrayList<>();\n        final long identityToken = Binder.clearCallingIdentity();\n        Collection<RegisteredServicesCache.ServiceInfo<AuthenticatorDescription>> serviceInfos;\n        try {\n            serviceInfos = mAuthenticatorCache.getAllServices(userId);\n        } finally {\n            Binder.restoreCallingIdentity(identityToken);\n        }\n\n        PackageManagerInternal pmi = LocalServices.getService(PackageManagerInternal.class);\n        for (RegisteredServicesCache.ServiceInfo<AuthenticatorDescription> serviceInfo :\n                serviceInfos) {\n            if (isOtherwisePermitted || pmi.hasSignatureCapability(\n                    serviceInfo.uid, callingUid, CertCapabilities.AUTH)) {\n                managedAccountTypes.add(serviceInfo.type.type);\n            }\n        }\n        return managedAccountTypes;\n    }\n\n    private boolean isAccountPresentForCaller(String accountName, String accountType) {\n        if (getUserAccountsForCaller().accountCache.containsKey(accountType)) {\n            for (Account account : getUserAccountsForCaller().accountCache.get(accountType)) {\n                if (account.name.equals(accountName)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private static void checkManageUsersPermission(String message) {\n        if (ActivityManager.checkComponentPermission(\n                android.Manifest.permission.MANAGE_USERS, Binder.getCallingUid(), -1, true)\n                != PackageManager.PERMISSION_GRANTED) {\n            throw new SecurityException(\"You need MANAGE_USERS permission to: \" + message);\n        }\n    }\n\n    private static void checkManageOrCreateUsersPermission(String message) {\n        if (ActivityManager.checkComponentPermission(android.Manifest.permission.MANAGE_USERS,\n                Binder.getCallingUid(), -1, true) != PackageManager.PERMISSION_GRANTED &&\n                ActivityManager.checkComponentPermission(android.Manifest.permission.CREATE_USERS,\n                        Binder.getCallingUid(), -1, true) != PackageManager.PERMISSION_GRANTED) {\n            throw new SecurityException(\"You need MANAGE_USERS or CREATE_USERS permission to: \"\n                    + message);\n        }\n    }\n\n    private boolean hasExplicitlyGrantedPermission(Account account, String authTokenType,\n            int callerUid) {\n        if (UserHandle.getAppId(callerUid) == Process.SYSTEM_UID) {\n            return true;\n        }\n        UserAccounts accounts = getUserAccounts(UserHandle.getUserId(callerUid));\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                long grantsCount;\n                if (authTokenType != null) {\n                    grantsCount = accounts.accountsDb\n                            .findMatchingGrantsCount(callerUid, authTokenType, account);\n                } else {\n                    grantsCount = accounts.accountsDb.findMatchingGrantsCountAnyToken(callerUid,\n                            account);\n                }\n                final boolean permissionGranted = grantsCount > 0;\n\n                if (!permissionGranted && ActivityManager.isRunningInTestHarness()) {\n                    // TODO: Skip this check when running automated tests. Replace this\n                    // with a more general solution.\n                    Log.d(TAG, \"no credentials permission for usage of \"\n                            + account.toSafeString() + \", \"\n                            + authTokenType + \" by uid \" + callerUid\n                            + \" but ignoring since device is in test harness.\");\n                    return true;\n                }\n                return permissionGranted;\n            }\n        }\n    }\n\n    private boolean isSystemUid(int callingUid) {\n        String[] packages = null;\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            packages = mPackageManager.getPackagesForUid(callingUid);\n            if (packages != null) {\n                for (String name : packages) {\n                    try {\n                        PackageInfo packageInfo =\n                                mPackageManager.getPackageInfo(name, 0 /* flags */);\n                        if (packageInfo != null\n                                && (packageInfo.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM)\n                                != 0) {\n                            return true;\n                        }\n                    } catch (NameNotFoundException e) {\n                        Log.w(TAG, String.format(\"Could not find package [%s]\", name), e);\n                    }\n                }\n            } else {\n                Log.w(TAG, \"No known packages with uid \" + callingUid);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n        return false;\n    }\n\n    /** Succeeds if any of the specified permissions are granted. */\n    private void checkReadAccountsPermitted(\n            int callingUid,\n            String accountType,\n            int userId,\n            String opPackageName) {\n        if (!isAccountVisibleToCaller(accountType, callingUid, userId, opPackageName)) {\n            String msg = String.format(\n                    \"caller uid %s cannot access %s accounts\",\n                    callingUid,\n                    accountType);\n            Log.w(TAG, \"  \" + msg);\n            throw new SecurityException(msg);\n        }\n    }\n\n    private boolean canUserModifyAccounts(int userId, int callingUid) {\n        // the managing app can always modify accounts\n        if (isProfileOwner(callingUid)) {\n            return true;\n        }\n        if (getUserManager().getUserRestrictions(new UserHandle(userId))\n                .getBoolean(UserManager.DISALLOW_MODIFY_ACCOUNTS)) {\n            return false;\n        }\n        return true;\n    }\n\n    private boolean canUserModifyAccountsForType(int userId, String accountType, int callingUid) {\n        return Binder.withCleanCallingIdentity(() -> {\n            // the managing app can always modify accounts\n            if (isProfileOwner(callingUid)) {\n                return true;\n            }\n            DevicePolicyManager dpm = (DevicePolicyManager) mContext\n                    .getSystemService(Context.DEVICE_POLICY_SERVICE);\n            String[] typesArray = dpm.getAccountTypesWithManagementDisabledAsUser(userId);\n            if (typesArray == null) {\n                return true;\n            }\n            for (String forbiddenType : typesArray) {\n                if (forbiddenType.equals(accountType)) {\n                    return false;\n                }\n            }\n            return true;\n        });\n    }\n\n    private boolean isProfileOwner(int uid) {\n        final DevicePolicyManagerInternal dpmi =\n                LocalServices.getService(DevicePolicyManagerInternal.class);\n        //TODO(b/169395065) Figure out if this flow makes sense in Device Owner mode.\n        return (dpmi != null) && (dpmi.isActiveProfileOwner(uid) || dpmi.isActiveDeviceOwner(uid));\n    }\n\n    /**\n     * Filter the access to the target package by rules of the package visibility if the caller\n     * targeting API level U and above. Otherwise, returns true if the package is installed on\n     * the device.\n     *\n     * @param targetPkgName The package name to check.\n     * @param callingUid The caller that is going to access the package.\n     * @param userId The user ID where the target package resides.\n     * @return true if the caller is able to access the package.\n     */\n    private boolean canCallerAccessPackage(@NonNull String targetPkgName, int callingUid,\n            int userId) {\n        final PackageManagerInternal pmInternal =\n                LocalServices.getService(PackageManagerInternal.class);\n        if (!CompatChanges.isChangeEnabled(ENFORCE_PACKAGE_VISIBILITY_FILTERING, callingUid)) {\n            return pmInternal.getPackageUid(\n                    targetPkgName, 0 /* flags */, userId) != Process.INVALID_UID;\n        }\n        final boolean canAccess = !pmInternal.filterAppAccess(targetPkgName, callingUid, userId);\n        if (!canAccess && Log.isLoggable(TAG, Log.DEBUG)) {\n            Log.d(TAG, \"Package \" + targetPkgName + \" is not visible to caller \" + callingUid\n                    + \" for user \" + userId);\n        }\n        return canAccess;\n    }\n\n    @Override\n    public void updateAppPermission(Account account, String authTokenType, int uid, boolean value)\n            throws RemoteException {\n        final int callingUid = getCallingUid();\n\n        if (UserHandle.getAppId(callingUid) != Process.SYSTEM_UID) {\n            throw new SecurityException();\n        }\n\n        if (value) {\n            grantAppPermission(account, authTokenType, uid);\n        } else {\n            revokeAppPermission(account, authTokenType, uid);\n        }\n    }\n\n    /**\n     * Allow callers with the given uid permission to get credentials for account/authTokenType.\n     * <p>\n     * Although this is public it can only be accessed via the AccountManagerService object\n     * which is in the system. This means we don't need to protect it with permissions.\n     * @hide\n     */\n    void grantAppPermission(Account account, String authTokenType, int uid) {\n        if (account == null || authTokenType == null) {\n            Log.e(TAG, \"grantAppPermission: called with invalid arguments\", new Exception());\n            return;\n        }\n        UserAccounts accounts = getUserAccounts(UserHandle.getUserId(uid));\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                long accountId = accounts.accountsDb.findDeAccountId(account);\n                if (accountId >= 0) {\n                    accounts.accountsDb.insertGrant(accountId, authTokenType, uid);\n                }\n                cancelNotification(\n                        getCredentialPermissionNotificationId(\n                                account, authTokenType, uid, accounts),\n                        accounts);\n\n                cancelAccountAccessRequestNotificationIfNeeded(account, uid, true, accounts);\n            }\n        }\n\n        // Listeners are a final CopyOnWriteArrayList, hence no lock needed.\n        for (AccountManagerInternal.OnAppPermissionChangeListener listener\n                : mAppPermissionChangeListeners) {\n            mHandler.post(() -> listener.onAppPermissionChanged(account, uid));\n        }\n    }\n\n    /**\n     * Don't allow callers with the given uid permission to get credentials for\n     * account/authTokenType.\n     * <p>\n     * Although this is public it can only be accessed via the AccountManagerService object\n     * which is in the system. This means we don't need to protect it with permissions.\n     * @hide\n     */\n    private void revokeAppPermission(Account account, String authTokenType, int uid) {\n        if (account == null || authTokenType == null) {\n            Log.e(TAG, \"revokeAppPermission: called with invalid arguments\", new Exception());\n            return;\n        }\n        UserAccounts accounts = getUserAccounts(UserHandle.getUserId(uid));\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                accounts.accountsDb.beginTransaction();\n                try {\n                    long accountId = accounts.accountsDb.findDeAccountId(account);\n                    if (accountId >= 0) {\n                        accounts.accountsDb.deleteGrantsByAccountIdAuthTokenTypeAndUid(\n                                accountId, authTokenType, uid);\n                        accounts.accountsDb.setTransactionSuccessful();\n                    }\n                } finally {\n                    accounts.accountsDb.endTransaction();\n                }\n\n                cancelNotification(\n                        getCredentialPermissionNotificationId(\n                                account, authTokenType, uid, accounts),\n                        accounts);\n            }\n        }\n\n        // Listeners are a final CopyOnWriteArrayList, hence no lock needed.\n        for (AccountManagerInternal.OnAppPermissionChangeListener listener\n                : mAppPermissionChangeListeners) {\n            mHandler.post(() -> listener.onAppPermissionChanged(account, uid));\n        }\n    }\n\n    private void removeAccountFromCacheLocked(UserAccounts accounts, Account account) {\n        final Account[] oldAccountsForType = accounts.accountCache.get(account.type);\n        if (oldAccountsForType != null) {\n            ArrayList<Account> newAccountsList = new ArrayList<>();\n            for (Account curAccount : oldAccountsForType) {\n                if (!curAccount.equals(account)) {\n                    newAccountsList.add(curAccount);\n                }\n            }\n            if (newAccountsList.isEmpty()) {\n                accounts.accountCache.remove(account.type);\n            } else {\n                Account[] newAccountsForType = new Account[newAccountsList.size()];\n                newAccountsForType = newAccountsList.toArray(newAccountsForType);\n                accounts.accountCache.put(account.type, newAccountsForType);\n            }\n        }\n        accounts.userDataCache.remove(account);\n        accounts.authTokenCache.remove(account);\n        accounts.previousNameCache.remove(account);\n        accounts.visibilityCache.remove(account);\n\n        AccountManager.invalidateLocalAccountsDataCaches();\n    }\n\n    /**\n     * This assumes that the caller has already checked that the account is not already present.\n     * IMPORTANT: The account being inserted will begin to be tracked for access in remote\n     * processes and if you will return this account to apps you should return the result.\n     * @return The inserted account which is a new instance that is being tracked.\n     */\n    private Account insertAccountIntoCacheLocked(UserAccounts accounts, Account account) {\n        Account[] accountsForType = accounts.accountCache.get(account.type);\n        int oldLength = (accountsForType != null) ? accountsForType.length : 0;\n        Account[] newAccountsForType = new Account[oldLength + 1];\n        if (accountsForType != null) {\n            System.arraycopy(accountsForType, 0, newAccountsForType, 0, oldLength);\n        }\n        String token = account.getAccessId() != null ? account.getAccessId()\n                : UUID.randomUUID().toString();\n        newAccountsForType[oldLength] = new Account(account, token);\n        accounts.accountCache.put(account.type, newAccountsForType);\n        AccountManager.invalidateLocalAccountsDataCaches();\n        return newAccountsForType[oldLength];\n    }\n\n    @NonNull\n    private Account[] filterAccounts(UserAccounts accounts, Account[] unfiltered, int callingUid,\n            @Nullable String callingPackage, boolean includeManagedNotVisible) {\n        String visibilityFilterPackage = callingPackage;\n        if (visibilityFilterPackage == null) {\n            visibilityFilterPackage = getPackageNameForUid(callingUid);\n        }\n        Map<Account, Integer> firstPass = new LinkedHashMap<>();\n        for (Account account : unfiltered) {\n            int visibility = resolveAccountVisibility(account, visibilityFilterPackage, accounts);\n            if ((visibility == AccountManager.VISIBILITY_VISIBLE\n                    || visibility == AccountManager.VISIBILITY_USER_MANAGED_VISIBLE)\n                    || (includeManagedNotVisible\n                            && (visibility\n                                    == AccountManager.VISIBILITY_USER_MANAGED_NOT_VISIBLE))) {\n                firstPass.put(account, visibility);\n            }\n        }\n        Map<Account, Integer> secondPass =\n                filterSharedAccounts(accounts, firstPass, callingUid, callingPackage);\n\n        Account[] filtered = new Account[secondPass.size()];\n        filtered = secondPass.keySet().toArray(filtered);\n        return filtered;\n    }\n\n    @NonNull\n    private Map<Account, Integer> filterSharedAccounts(UserAccounts userAccounts,\n            @NonNull Map<Account, Integer> unfiltered, int callingUid,\n            @Nullable String callingPackage) {\n        // first part is to filter shared accounts.\n        // unfiltered type check is not necessary.\n        if (getUserManager() == null || userAccounts == null || userAccounts.userId < 0\n                || callingUid == Process.SYSTEM_UID) {\n            return unfiltered;\n        }\n        UserInfo user = getUserManager().getUserInfo(userAccounts.userId);\n        if (user != null && user.isRestricted()) {\n            String[] packages = mPackageManager.getPackagesForUid(callingUid);\n            if (packages == null) {\n                packages = new String[] {};\n            }\n            // If any of the packages is a visible listed package, return the full set,\n            // otherwise return non-shared accounts only.\n            // This might be a temporary way to specify a visible list\n            String visibleList = mContext.getResources().getString(\n                    com.android.internal.R.string.config_appsAuthorizedForSharedAccounts);\n            for (String packageName : packages) {\n                if (visibleList.contains(\";\" + packageName + \";\")) {\n                    return unfiltered;\n                }\n            }\n            Account[] sharedAccounts = getSharedAccountsAsUser(userAccounts.userId);\n            if (ArrayUtils.isEmpty(sharedAccounts)) {\n                return unfiltered;\n            }\n            String requiredAccountType = \"\";\n            try {\n                // If there's an explicit callingPackage specified, check if that package\n                // opted in to see restricted accounts.\n                if (callingPackage != null) {\n                    PackageInfo pi = mPackageManager.getPackageInfo(callingPackage, 0);\n                    if (pi != null && pi.restrictedAccountType != null) {\n                        requiredAccountType = pi.restrictedAccountType;\n                    }\n                } else {\n                    // Otherwise check if the callingUid has a package that has opted in\n                    for (String packageName : packages) {\n                        PackageInfo pi = mPackageManager.getPackageInfo(packageName, 0);\n                        if (pi != null && pi.restrictedAccountType != null) {\n                            requiredAccountType = pi.restrictedAccountType;\n                            break;\n                        }\n                    }\n                }\n            } catch (NameNotFoundException e) {\n                Log.w(TAG, \"filterSharedAccounts#Package not found \" + e.getMessage());\n            }\n            Map<Account, Integer> filtered = new LinkedHashMap<>();\n            for (Map.Entry<Account, Integer> entry : unfiltered.entrySet()) {\n                Account account = entry.getKey();\n                if (account.type.equals(requiredAccountType)) {\n                    filtered.put(account, entry.getValue());\n                } else {\n                    boolean found = false;\n                    for (Account shared : sharedAccounts) {\n                        if (shared.equals(account)) {\n                            found = true;\n                            break;\n                        }\n                    }\n                    if (!found) {\n                        filtered.put(account, entry.getValue());\n                    }\n                }\n            }\n            return filtered;\n        } else {\n            return unfiltered;\n        }\n    }\n\n    /*\n     * packageName can be null. If not null, it should be used to filter out restricted accounts\n     * that the package is not allowed to access.\n     *\n     * <p>The method shouldn't be called with UserAccounts#cacheLock held, otherwise it will cause a\n     * deadlock\n     */\n    @NonNull\n    protected Account[] getAccountsFromCache(UserAccounts userAccounts, String accountType,\n            int callingUid, @Nullable String callingPackage, boolean includeManagedNotVisible) {\n        Preconditions.checkState(!Thread.holdsLock(userAccounts.cacheLock),\n                \"Method should not be called with cacheLock\");\n        if (accountType != null) {\n            Account[] accounts;\n            synchronized (userAccounts.cacheLock) {\n                accounts = userAccounts.accountCache.get(accountType);\n            }\n            if (accounts == null) {\n                return EMPTY_ACCOUNT_ARRAY;\n            } else {\n                return filterAccounts(userAccounts, Arrays.copyOf(accounts, accounts.length),\n                        callingUid, callingPackage, includeManagedNotVisible);\n            }\n        } else {\n            int totalLength = 0;\n            Account[] accountsArray;\n            synchronized (userAccounts.cacheLock) {\n                for (Account[] accounts : userAccounts.accountCache.values()) {\n                    totalLength += accounts.length;\n                }\n                if (totalLength == 0) {\n                    return EMPTY_ACCOUNT_ARRAY;\n                }\n                accountsArray = new Account[totalLength];\n                totalLength = 0;\n                for (Account[] accountsOfType : userAccounts.accountCache.values()) {\n                    System.arraycopy(accountsOfType, 0, accountsArray, totalLength,\n                            accountsOfType.length);\n                    totalLength += accountsOfType.length;\n                }\n            }\n            return filterAccounts(userAccounts, accountsArray, callingUid, callingPackage,\n                    includeManagedNotVisible);\n        }\n    }\n\n    /** protected by the {@code dbLock}, {@code cacheLock} */\n    protected void writeUserDataIntoCacheLocked(UserAccounts accounts,\n            Account account, String key, String value) {\n        Map<String, String> userDataForAccount = accounts.userDataCache.get(account);\n        if (userDataForAccount == null) {\n            userDataForAccount = accounts.accountsDb.findUserExtrasForAccount(account);\n            accounts.userDataCache.put(account, userDataForAccount);\n        }\n        if (value == null) {\n            userDataForAccount.remove(key);\n        } else {\n            userDataForAccount.put(key, value);\n        }\n    }\n\n    protected TokenCache.Value readCachedTokenInternal(\n            UserAccounts accounts,\n            Account account,\n            String tokenType,\n            String callingPackage,\n            byte[] pkgSigDigest) {\n        synchronized (accounts.cacheLock) {\n            return accounts.accountTokenCaches.get(\n                    account, tokenType, callingPackage, pkgSigDigest);\n        }\n    }\n\n    /** protected by the {@code dbLock}, {@code cacheLock} */\n    protected void writeAuthTokenIntoCacheLocked(UserAccounts accounts,\n            Account account, String key, String value) {\n        Map<String, String> authTokensForAccount = accounts.authTokenCache.get(account);\n        if (authTokensForAccount == null) {\n            authTokensForAccount = accounts.accountsDb.findAuthTokensByAccount(account);\n            accounts.authTokenCache.put(account, authTokensForAccount);\n        }\n        if (value == null) {\n            authTokensForAccount.remove(key);\n        } else {\n            authTokensForAccount.put(key, value);\n        }\n    }\n\n    protected String readAuthTokenInternal(UserAccounts accounts, Account account,\n            String authTokenType) {\n        // Fast path - check if account is already cached\n        synchronized (accounts.cacheLock) {\n            Map<String, String> authTokensForAccount = accounts.authTokenCache.get(account);\n            if (authTokensForAccount != null) {\n                return authTokensForAccount.get(authTokenType);\n            }\n        }\n        // If not cached yet - do slow path and sync with db if necessary\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                Map<String, String> authTokensForAccount = accounts.authTokenCache.get(account);\n                if (authTokensForAccount == null) {\n                    // need to populate the cache for this account\n                    authTokensForAccount = accounts.accountsDb.findAuthTokensByAccount(account);\n                    accounts.authTokenCache.put(account, authTokensForAccount);\n                }\n                return authTokensForAccount.get(authTokenType);\n            }\n        }\n    }\n\n    private String readUserDataInternal(UserAccounts accounts, Account account, String key) {\n        Map<String, String> userDataForAccount;\n        // Fast path - check if data is already cached\n        synchronized (accounts.cacheLock) {\n            userDataForAccount = accounts.userDataCache.get(account);\n        }\n        // If not cached yet - do slow path and sync with db if necessary\n        if (userDataForAccount == null) {\n            synchronized (accounts.dbLock) {\n                synchronized (accounts.cacheLock) {\n                    userDataForAccount = accounts.userDataCache.get(account);\n                    if (userDataForAccount == null) {\n                        // need to populate the cache for this account\n                        userDataForAccount = accounts.accountsDb.findUserExtrasForAccount(account);\n                        accounts.userDataCache.put(account, userDataForAccount);\n                    }\n                }\n            }\n        }\n        return userDataForAccount.get(key);\n    }\n\n    private Context getContextForUser(UserHandle user) {\n        try {\n            return mContext.createPackageContextAsUser(mContext.getPackageName(), 0, user);\n        } catch (NameNotFoundException e) {\n            // Default to mContext, not finding the package system is running as is unlikely.\n            return mContext;\n        }\n    }\n\n    private void sendResponse(IAccountManagerResponse response, Bundle result) {\n        try {\n            response.onResult(result);\n        } catch (RemoteException e) {\n            // if the caller is dead then there is no one to care about remote\n            // exceptions\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"failure while notifying response\", e);\n            }\n        }\n    }\n\n    private void sendErrorResponse(IAccountManagerResponse response, int errorCode,\n            String errorMessage) {\n        try {\n            response.onError(errorCode, errorMessage);\n        } catch (RemoteException e) {\n            // if the caller is dead then there is no one to care about remote\n            // exceptions\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"failure while notifying response\", e);\n            }\n        }\n    }\n\n    /**\n     * Returns true if the config_canRemoveOrRenameFirstUser is false, and the given account type\n     * matches the one provided by config_accountTypeToKeepFirstUser.\n     */\n    private boolean isFirstAccountRemovalDisabled(Account account) {\n        // Skip if not targeting the first user.\n        int userId = UserHandle.getCallingUserId();\n        if (userId != 0) {\n            return false;\n        }\n\n        // Skip if we are allowed to remove/rename first account.\n        if (mContext.getResources()\n                .getBoolean(com.android.internal.R.bool.config_canRemoveFirstAccount)) {\n            return false;\n        }\n\n        // Skip if needed for testing.\n        if (Settings.Secure.getIntForUser(\n                mContext.getContentResolver(),\n                Settings.Secure.ALLOW_PRIMARY_GAIA_ACCOUNT_REMOVAL_FOR_TESTS,\n                0 /* default */,\n                0 /* userHandle */) != 0) {\n            return false;\n        }\n\n        // Skip if not targeting desired account.\n        String typeToKeep =\n                mContext.getResources()\n                        .getString(\n                                com.android.internal.R.string.config_accountTypeToKeepFirstAccount);\n        if (typeToKeep.isEmpty() || !typeToKeep.equals(account.type)) {\n            return false;\n        }\n\n        // Only restrict first account.\n        UserAccounts accounts = getUserAccounts(0 /* userId */);\n        Account[] accountsOfType = getAccountsFromCache(accounts, typeToKeep,\n                Process.SYSTEM_UID, \"android\" /* packageName */, false);\n        return accountsOfType.length > 0 && accountsOfType[0].equals(account);\n    }\n\n    private final class AccountManagerInternalImpl extends AccountManagerInternal {\n        private final Object mLock = new Object();\n\n        @GuardedBy(\"mLock\")\n        private AccountManagerBackupHelper mBackupHelper;\n\n        @Override\n        public void requestAccountAccess(@NonNull Account account, @NonNull String packageName,\n                @IntRange(from = 0) int userId, @NonNull RemoteCallback callback) {\n            if (account == null) {\n                Slog.w(TAG, \"account cannot be null\");\n                return;\n            }\n            if (packageName == null) {\n                Slog.w(TAG, \"packageName cannot be null\");\n                return;\n            }\n            if (userId < UserHandle.USER_SYSTEM) {\n                Slog.w(TAG, \"user id must be concrete\");\n                return;\n            }\n            if (callback == null) {\n                Slog.w(TAG, \"callback cannot be null\");\n                return;\n            }\n\n            int visibility =\n                resolveAccountVisibility(account, packageName, getUserAccounts(userId));\n            if (visibility == AccountManager.VISIBILITY_NOT_VISIBLE) {\n                Slog.w(TAG, \"requestAccountAccess: account is hidden\");\n                return;\n            }\n\n            if (AccountManagerService.this.hasAccountAccess(account, packageName,\n                    new UserHandle(userId))) {\n                Bundle result = new Bundle();\n                result.putBoolean(AccountManager.KEY_BOOLEAN_RESULT, true);\n                callback.sendResult(result);\n                return;\n            }\n\n            final int uid;\n            try {\n                final long identityToken = clearCallingIdentity();\n                try {\n                    uid = mPackageManager.getPackageUidAsUser(packageName, userId);\n                } finally {\n                    restoreCallingIdentity(identityToken);\n                }\n            } catch (NameNotFoundException e) {\n                Slog.e(TAG, \"Unknown package \" + packageName);\n                return;\n            }\n\n            Intent intent = newRequestAccountAccessIntent(account, packageName, uid, callback);\n            final UserAccounts userAccounts;\n            synchronized (mUsers) {\n                userAccounts = mUsers.get(userId);\n            }\n            SystemNotificationChannels.createAccountChannelForPackage(packageName, uid, mContext);\n            doNotification(userAccounts, account, null, intent, packageName, userId);\n        }\n\n        @Override\n        public void addOnAppPermissionChangeListener(OnAppPermissionChangeListener listener) {\n            // Listeners are a final CopyOnWriteArrayList, hence no lock needed.\n            mAppPermissionChangeListeners.add(listener);\n        }\n\n        @Override\n        public boolean hasAccountAccess(@NonNull Account account, @IntRange(from = 0) int uid) {\n            return AccountManagerService.this.hasAccountAccess(account, null, uid);\n        }\n\n        @Override\n        public byte[] backupAccountAccessPermissions(int userId) {\n            synchronized (mLock) {\n                if (mBackupHelper == null) {\n                    mBackupHelper = new AccountManagerBackupHelper(\n                            AccountManagerService.this, this);\n                }\n                return mBackupHelper.backupAccountAccessPermissions(userId);\n            }\n        }\n\n        @Override\n        public void restoreAccountAccessPermissions(byte[] data, int userId) {\n            synchronized (mLock) {\n                if (mBackupHelper == null) {\n                    mBackupHelper = new AccountManagerBackupHelper(\n                            AccountManagerService.this, this);\n                }\n                mBackupHelper.restoreAccountAccessPermissions(data, userId);\n            }\n        }\n    }\n\n    @VisibleForTesting\n    static class Injector {\n        private final Context mContext;\n\n        public Injector(Context context) {\n            mContext = context;\n        }\n\n        Looper getMessageHandlerLooper() {\n            ServiceThread serviceThread = new ServiceThread(TAG,\n                    android.os.Process.THREAD_PRIORITY_FOREGROUND, true /* allowIo */);\n            serviceThread.start();\n            return serviceThread.getLooper();\n        }\n\n        Context getContext() {\n            return mContext;\n        }\n\n        void addLocalService(AccountManagerInternal service) {\n            LocalServices.addService(AccountManagerInternal.class, service);\n        }\n\n        String getDeDatabaseName(int userId) {\n            File databaseFile = new File(Environment.getDataSystemDeDirectory(userId),\n                    AccountsDb.DE_DATABASE_NAME);\n            return databaseFile.getPath();\n        }\n\n        String getCeDatabaseName(int userId) {\n            File databaseFile = new File(Environment.getDataSystemCeDirectory(userId),\n                    AccountsDb.CE_DATABASE_NAME);\n            return databaseFile.getPath();\n        }\n\n        String getPreNDatabaseName(int userId) {\n            File systemDir = Environment.getDataSystemDirectory();\n            File databaseFile = new File(Environment.getUserSystemDirectory(userId),\n                    PRE_N_DATABASE_NAME);\n            if (userId == 0) {\n                // Migrate old file, if it exists, to the new location.\n                // Make sure the new file doesn't already exist. A placeholder file could have been\n                // accidentally created in the old location,\n                // causing the new one to become corrupted as well.\n                File oldFile = new File(systemDir, PRE_N_DATABASE_NAME);\n                if (oldFile.exists() && !databaseFile.exists()) {\n                    // Check for use directory; create if it doesn't exist, else renameTo will fail\n                    File userDir = Environment.getUserSystemDirectory(userId);\n                    if (!userDir.exists()) {\n                        if (!userDir.mkdirs()) {\n                            throw new IllegalStateException(\n                                    \"User dir cannot be created: \" + userDir);\n                        }\n                    }\n                    if (!oldFile.renameTo(databaseFile)) {\n                        throw new IllegalStateException(\n                                \"User dir cannot be migrated: \" + databaseFile);\n                    }\n                }\n            }\n            return databaseFile.getPath();\n        }\n\n        IAccountAuthenticatorCache getAccountAuthenticatorCache() {\n            return new AccountAuthenticatorCache(mContext);\n        }\n\n        INotificationManager getNotificationManager() {\n            return NotificationManager.getService();\n        }\n    }\n\n    private static class NotificationId {\n        final String mTag;\n        private final int mId;\n\n        NotificationId(String tag, int type) {\n            mTag = tag;\n            mId = type;\n        }\n    }\n}\n```",
                        "downstream_file_content": "```java\n/*\n * Copyright (C) 2009 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.server.accounts;\n\nimport android.Manifest;\nimport android.accounts.AbstractAccountAuthenticator;\nimport android.accounts.Account;\nimport android.accounts.AccountAndUser;\nimport android.accounts.AccountAuthenticatorResponse;\nimport android.accounts.AccountManager;\nimport android.accounts.AccountManagerInternal;\nimport android.accounts.AccountManagerResponse;\nimport android.accounts.AuthenticatorDescription;\nimport android.accounts.CantAddAccountActivity;\nimport android.accounts.ChooseAccountActivity;\nimport android.accounts.GrantCredentialsPermissionActivity;\nimport android.accounts.IAccountAuthenticator;\nimport android.accounts.IAccountAuthenticatorResponse;\nimport android.accounts.IAccountManager;\nimport android.accounts.IAccountManagerResponse;\nimport android.annotation.IntRange;\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.app.ActivityManager;\nimport android.app.ActivityThread;\nimport android.app.AppOpsManager;\nimport android.app.INotificationManager;\nimport android.app.Notification;\nimport android.app.NotificationManager;\nimport android.app.PendingIntent;\nimport android.app.admin.DevicePolicyEventLogger;\nimport android.app.admin.DevicePolicyManager;\nimport android.app.admin.DevicePolicyManagerInternal;\nimport android.content.BroadcastReceiver;\nimport android.content.ClipData;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.IntentSender;\nimport android.content.ServiceConnection;\nimport android.content.pm.ActivityInfo;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.IPackageManager;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManager.NameNotFoundException;\nimport android.content.pm.PackageManagerInternal;\nimport android.content.pm.PackageParser;\nimport android.content.pm.RegisteredServicesCache;\nimport android.content.pm.RegisteredServicesCacheListener;\nimport android.content.pm.ResolveInfo;\nimport android.content.pm.Signature;\nimport android.content.pm.UserInfo;\nimport android.database.Cursor;\nimport android.database.sqlite.SQLiteStatement;\nimport android.os.Binder;\nimport android.os.Bundle;\nimport android.os.Environment;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.Parcel;\nimport android.os.Parcelable;\nimport android.os.Process;\nimport android.os.RemoteCallback;\nimport android.os.RemoteException;\nimport android.os.ResultReceiver;\nimport android.os.ShellCallback;\nimport android.os.StrictMode;\nimport android.os.SystemClock;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.stats.devicepolicy.DevicePolicyEnums;\nimport android.text.TextUtils;\nimport android.util.EventLog;\nimport android.util.Log;\nimport android.util.Pair;\nimport android.util.Slog;\nimport android.util.SparseArray;\nimport android.util.SparseBooleanArray;\n\nimport com.android.internal.R;\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.content.PackageMonitor;\nimport com.android.internal.messages.nano.SystemMessageProto.SystemMessage;\nimport com.android.internal.notification.SystemNotificationChannels;\nimport com.android.internal.util.ArrayUtils;\nimport com.android.internal.util.DumpUtils;\nimport com.android.internal.util.IndentingPrintWriter;\nimport com.android.internal.util.Preconditions;\nimport com.android.server.LocalServices;\nimport com.android.server.ServiceThread;\nimport com.android.server.SystemService;\n\nimport com.google.android.collect.Lists;\nimport com.google.android.collect.Sets;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.PrintWriter;\nimport java.security.GeneralSecurityException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.concurrent.atomic.AtomicReference;\n\n/**\n * A system service that provides  account, password, and authtoken management for all\n * accounts on the device. Some of these calls are implemented with the help of the corresponding\n * {@link IAccountAuthenticator} services. This service is not accessed by users directly,\n * instead one uses an instance of {@link AccountManager}, which can be accessed as follows:\n *    AccountManager accountManager = AccountManager.get(context);\n * @hide\n */\npublic class AccountManagerService\n        extends IAccountManager.Stub\n        implements RegisteredServicesCacheListener<AuthenticatorDescription> {\n    private static final String TAG = \"AccountManagerService\";\n\n    public static class Lifecycle extends SystemService {\n        private AccountManagerService mService;\n\n        public Lifecycle(Context context) {\n            super(context);\n        }\n\n        @Override\n        public void onStart() {\n            mService = new AccountManagerService(new Injector(getContext()));\n            publishBinderService(Context.ACCOUNT_SERVICE, mService);\n        }\n\n        @Override\n        public void onUserUnlocking(@NonNull TargetUser user) {\n            mService.onUnlockUser(user.getUserIdentifier());\n        }\n\n        @Override\n        public void onUserStopping(@NonNull TargetUser user) {\n            Slog.i(TAG, \"onStopUser \" + user);\n            mService.purgeUserData(user.getUserIdentifier());\n        }\n    }\n\n    final Context mContext;\n\n    private final PackageManager mPackageManager;\n    private final AppOpsManager mAppOpsManager;\n    private UserManager mUserManager;\n    private final Injector mInjector;\n\n    final MessageHandler mHandler;\n\n    private static final int TIMEOUT_DELAY_MS = 1000 * 60 * 15;\n    // Messages that can be sent on mHandler\n    private static final int MESSAGE_TIMED_OUT = 3;\n    private static final int MESSAGE_COPY_SHARED_ACCOUNT = 4;\n\n    private final IAccountAuthenticatorCache mAuthenticatorCache;\n    private static final String PRE_N_DATABASE_NAME = \"accounts.db\";\n    private static final Intent ACCOUNTS_CHANGED_INTENT;\n\n    private static final int SIGNATURE_CHECK_MISMATCH = 0;\n    private static final int SIGNATURE_CHECK_MATCH = 1;\n    private static final int SIGNATURE_CHECK_UID_MATCH = 2;\n\n    static {\n        ACCOUNTS_CHANGED_INTENT = new Intent(AccountManager.LOGIN_ACCOUNTS_CHANGED_ACTION);\n        ACCOUNTS_CHANGED_INTENT.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT\n                | Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);\n    }\n\n    private final LinkedHashMap<String, Session> mSessions = new LinkedHashMap<String, Session>();\n\n    static class UserAccounts {\n        private final int userId;\n        final AccountsDb accountsDb;\n        private final HashMap<Pair<Pair<Account, String>, Integer>, NotificationId>\n                credentialsPermissionNotificationIds = new HashMap<>();\n        private final HashMap<Account, NotificationId> signinRequiredNotificationIds\n                = new HashMap<>();\n        final Object cacheLock = new Object();\n        final Object dbLock = new Object(); // if needed, dbLock must be obtained before cacheLock\n        /** protected by the {@link #cacheLock} */\n        final HashMap<String, Account[]> accountCache = new LinkedHashMap<>();\n        /** protected by the {@link #cacheLock} */\n        private final Map<Account, Map<String, String>> userDataCache = new HashMap<>();\n        /** protected by the {@link #cacheLock} */\n        private final Map<Account, Map<String, String>> authTokenCache = new HashMap<>();\n        /** protected by the {@link #cacheLock} */\n        private final TokenCache accountTokenCaches = new TokenCache();\n        /** protected by the {@link #cacheLock} */\n        private final Map<Account, Map<String, Integer>> visibilityCache = new HashMap<>();\n\n        /** protected by the {@link #mReceiversForType},\n         *  type -> (packageName -> number of active receivers)\n         *  type == null is used to get notifications about all account types\n         */\n        private final Map<String, Map<String, Integer>> mReceiversForType = new HashMap<>();\n\n        /**\n         * protected by the {@link #cacheLock}\n         *\n         * Caches the previous names associated with an account. Previous names\n         * should be cached because we expect that when an Account is renamed,\n         * many clients will receive a LOGIN_ACCOUNTS_CHANGED broadcast and\n         * want to know if the accounts they care about have been renamed.\n         *\n         * The previous names are wrapped in an {@link AtomicReference} so that\n         * we can distinguish between those accounts with no previous names and\n         * those whose previous names haven't been cached (yet).\n         */\n        private final HashMap<Account, AtomicReference<String>> previousNameCache =\n                new HashMap<Account, AtomicReference<String>>();\n\n        UserAccounts(Context context, int userId, File preNDbFile, File deDbFile) {\n            this.userId = userId;\n            synchronized (dbLock) {\n                synchronized (cacheLock) {\n                    accountsDb = AccountsDb.create(context, userId, preNDbFile, deDbFile);\n                }\n            }\n        }\n    }\n\n    private final SparseArray<UserAccounts> mUsers = new SparseArray<>();\n    private final SparseBooleanArray mLocalUnlockedUsers = new SparseBooleanArray();\n    // Not thread-safe. Only use in synchronized context\n    private final SimpleDateFormat mDateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n    private CopyOnWriteArrayList<AccountManagerInternal.OnAppPermissionChangeListener>\n            mAppPermissionChangeListeners = new CopyOnWriteArrayList<>();\n\n    private static AtomicReference<AccountManagerService> sThis = new AtomicReference<>();\n    private static final Account[] EMPTY_ACCOUNT_ARRAY = new Account[]{};\n\n    /**\n     * This should only be called by system code. One should only call this after the service\n     * has started.\n     * @return a reference to the AccountManagerService instance\n     * @hide\n     */\n    public static AccountManagerService getSingleton() {\n        return sThis.get();\n    }\n\n    public AccountManagerService(Injector injector) {\n        mInjector = injector;\n        mContext = injector.getContext();\n        mPackageManager = mContext.getPackageManager();\n        mAppOpsManager = mContext.getSystemService(AppOpsManager.class);\n        mHandler = new MessageHandler(injector.getMessageHandlerLooper());\n        mAuthenticatorCache = mInjector.getAccountAuthenticatorCache();\n        mAuthenticatorCache.setListener(this, mHandler);\n\n        sThis.set(this);\n\n        IntentFilter intentFilter = new IntentFilter();\n        intentFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);\n        intentFilter.addDataScheme(\"package\");\n        mContext.registerReceiver(new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context1, Intent intent) {\n                // Don't delete accounts when updating a authenticator's\n                // package.\n                if (!intent.getBooleanExtra(Intent.EXTRA_REPLACING, false)) {\n                    /* Purging data requires file io, don't block the main thread. This is probably\n                     * less than ideal because we are introducing a race condition where old grants\n                     * could be exercised until they are purged. But that race condition existed\n                     * anyway with the broadcast receiver.\n                     *\n                     * Ideally, we would completely clear the cache, purge data from the database,\n                     * and then rebuild the cache. All under the cache lock. But that change is too\n                     * large at this point.\n                     */\n                    final String removedPackageName = intent.getData().getSchemeSpecificPart();\n                    Runnable purgingRunnable = new Runnable() {\n                        @Override\n                        public void run() {\n                            purgeOldGrantsAll();\n                            // Notify authenticator about removed app?\n                            removeVisibilityValuesForPackage(removedPackageName);\n                        }\n                    };\n                    mHandler.post(purgingRunnable);\n                }\n            }\n        }, intentFilter);\n\n        injector.addLocalService(new AccountManagerInternalImpl());\n\n        IntentFilter userFilter = new IntentFilter();\n        userFilter.addAction(Intent.ACTION_USER_REMOVED);\n        mContext.registerReceiverAsUser(new BroadcastReceiver() {\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                String action = intent.getAction();\n                if (Intent.ACTION_USER_REMOVED.equals(action)) {\n                    int userId = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, -1);\n                    if (userId < 1) return;\n                    Slog.i(TAG, \"User \" + userId + \" removed\");\n                    purgeUserData(userId);\n                }\n            }\n        }, UserHandle.ALL, userFilter, null, null);\n\n        // Need to cancel account request notifications if the update/install can access the account\n        new PackageMonitor() {\n            @Override\n            public void onPackageAdded(String packageName, int uid) {\n                // Called on a handler, and running as the system\n                cancelAccountAccessRequestNotificationIfNeeded(uid, true);\n            }\n\n            @Override\n            public void onPackageUpdateFinished(String packageName, int uid) {\n                // Called on a handler, and running as the system\n                cancelAccountAccessRequestNotificationIfNeeded(uid, true);\n            }\n        }.register(mContext, mHandler.getLooper(), UserHandle.ALL, true);\n\n        // Cancel account request notification if an app op was preventing the account access\n        mAppOpsManager.startWatchingMode(AppOpsManager.OP_GET_ACCOUNTS, null,\n                new AppOpsManager.OnOpChangedInternalListener() {\n            @Override\n            public void onOpChanged(int op, String packageName) {\n                try {\n                    final int userId = ActivityManager.getCurrentUser();\n                    final int uid = mPackageManager.getPackageUidAsUser(packageName, userId);\n                    final int mode = mAppOpsManager.checkOpNoThrow(\n                            AppOpsManager.OP_GET_ACCOUNTS, uid, packageName);\n                    if (mode == AppOpsManager.MODE_ALLOWED) {\n                        final long identity = Binder.clearCallingIdentity();\n                        try {\n                            cancelAccountAccessRequestNotificationIfNeeded(packageName, uid, true);\n                        } finally {\n                            Binder.restoreCallingIdentity(identity);\n                        }\n                    }\n                } catch (NameNotFoundException e) {\n                    /* ignore */\n                }\n            }\n        });\n\n        // Cancel account request notification if a permission was preventing the account access\n        mPackageManager.addOnPermissionsChangeListener(\n                (int uid) -> {\n            // Permission changes cause requires updating accounts cache.\n            AccountManager.invalidateLocalAccountsDataCaches();\n\n            Account[] accounts = null;\n            String[] packageNames = mPackageManager.getPackagesForUid(uid);\n            if (packageNames != null) {\n                final int userId = UserHandle.getUserId(uid);\n                final long identity = Binder.clearCallingIdentity();\n                try {\n                    for (String packageName : packageNames) {\n                                // if app asked for permission we need to cancel notification even\n                                // for O+ applications.\n                                if (mPackageManager.checkPermission(\n                                        Manifest.permission.GET_ACCOUNTS,\n                                        packageName) != PackageManager.PERMISSION_GRANTED) {\n                                    continue;\n                                }\n\n                        if (accounts == null) {\n                            accounts = getAccountsAsUser(null, userId, \"android\");\n                            if (ArrayUtils.isEmpty(accounts)) {\n                                return;\n                            }\n                        }\n\n                        for (Account account : accounts) {\n                            cancelAccountAccessRequestNotificationIfNeeded(\n                                    account, uid, packageName, true);\n                        }\n                    }\n                } finally {\n                    Binder.restoreCallingIdentity(identity);\n                }\n            }\n        });\n    }\n\n\n    boolean getBindInstantServiceAllowed(int userId) {\n        return  mAuthenticatorCache.getBindInstantServiceAllowed(userId);\n    }\n\n    void setBindInstantServiceAllowed(int userId, boolean allowed) {\n        mAuthenticatorCache.setBindInstantServiceAllowed(userId, allowed);\n    }\n\n    private void cancelAccountAccessRequestNotificationIfNeeded(int uid,\n            boolean checkAccess) {\n        Account[] accounts = getAccountsAsUser(null, UserHandle.getUserId(uid), \"android\");\n        for (Account account : accounts) {\n            cancelAccountAccessRequestNotificationIfNeeded(account, uid, checkAccess);\n        }\n    }\n\n    private void cancelAccountAccessRequestNotificationIfNeeded(String packageName, int uid,\n            boolean checkAccess) {\n        Account[] accounts = getAccountsAsUser(null, UserHandle.getUserId(uid), \"android\");\n        for (Account account : accounts) {\n            cancelAccountAccessRequestNotificationIfNeeded(account, uid, packageName, checkAccess);\n        }\n    }\n\n    private void cancelAccountAccessRequestNotificationIfNeeded(Account account, int uid,\n            boolean checkAccess) {\n        String[] packageNames = mPackageManager.getPackagesForUid(uid);\n        if (packageNames != null) {\n            for (String packageName : packageNames) {\n                cancelAccountAccessRequestNotificationIfNeeded(account, uid,\n                        packageName, checkAccess);\n            }\n        }\n    }\n\n    private void cancelAccountAccessRequestNotificationIfNeeded(Account account,\n            int uid, String packageName, boolean checkAccess) {\n        if (!checkAccess || hasAccountAccess(account, packageName,\n                UserHandle.getUserHandleForUid(uid))) {\n            cancelNotification(getCredentialPermissionNotificationId(account,\n                    AccountManager.ACCOUNT_ACCESS_TOKEN_TYPE, uid),\n                    UserHandle.getUserHandleForUid(uid));\n        }\n    }\n\n    @Override\n    public boolean addAccountExplicitlyWithVisibility(Account account, String password,\n            Bundle extras, Map packageToVisibility, String opPackageName) {\n        Bundle.setDefusable(extras, true);\n        int callingUid = Binder.getCallingUid();\n        int userId = UserHandle.getCallingUserId();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"addAccountExplicitly: \" + account + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\"uid %s cannot explicitly add accounts of type: %s\",\n                    callingUid, account.type);\n            throw new SecurityException(msg);\n        }\n        /*\n         * Child users are not allowed to add accounts. Only the accounts that are shared by the\n         * parent profile can be added to child profile.\n         *\n         * TODO: Only allow accounts that were shared to be added by a limited user.\n         */\n        // fails if the account already exists\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return addAccountInternal(accounts, account, password, extras, callingUid,\n                    (Map<String, Integer>) packageToVisibility, opPackageName);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public Map<Account, Integer> getAccountsAndVisibilityForPackage(String packageName,\n            String accountType) {\n        int callingUid = Binder.getCallingUid();\n        int userId = UserHandle.getCallingUserId();\n        boolean isSystemUid = UserHandle.isSameApp(callingUid, Process.SYSTEM_UID);\n        List<String> managedTypes = getTypesForCaller(callingUid, userId, isSystemUid);\n\n        if ((accountType != null && !managedTypes.contains(accountType))\n                || (accountType == null && !isSystemUid)) {\n            throw new SecurityException(\n                    \"getAccountsAndVisibilityForPackage() called from unauthorized uid \"\n                            + callingUid + \" with packageName=\" + packageName);\n        }\n        if (accountType != null) {\n            managedTypes = new ArrayList<String>();\n            managedTypes.add(accountType);\n        }\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return getAccountsAndVisibilityForPackage(packageName, managedTypes, callingUid,\n                    accounts);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    /*\n     * accountTypes may not be null\n     */\n    private Map<Account, Integer> getAccountsAndVisibilityForPackage(String packageName,\n            List<String> accountTypes, Integer callingUid, UserAccounts accounts) {\n        if (!packageExistsForUser(packageName, accounts.userId)) {\n            Log.d(TAG, \"Package not found \" + packageName);\n            return new LinkedHashMap<>();\n        }\n\n        Map<Account, Integer> result = new LinkedHashMap<>();\n        for (String accountType : accountTypes) {\n            synchronized (accounts.dbLock) {\n                synchronized (accounts.cacheLock) {\n                    final Account[] accountsOfType = accounts.accountCache.get(accountType);\n                    if (accountsOfType != null) {\n                        for (Account account : accountsOfType) {\n                            result.put(account,\n                                    resolveAccountVisibility(account, packageName, accounts));\n                        }\n                    }\n                }\n            }\n        }\n        return filterSharedAccounts(accounts, result, callingUid, packageName);\n    }\n\n    @Override\n    public Map<String, Integer> getPackagesAndVisibilityForAccount(Account account) {\n        Objects.requireNonNull(account, \"account cannot be null\");\n        int callingUid = Binder.getCallingUid();\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)\n                && !isSystemUid(callingUid)) {\n            String msg =\n                    String.format(\"uid %s cannot get secrets for account %s\", callingUid, account);\n            throw new SecurityException(msg);\n        }\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            synchronized (accounts.dbLock) {\n                synchronized (accounts.cacheLock) {\n                    return getPackagesAndVisibilityForAccountLocked(account, accounts);\n                }\n            }\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n\n    }\n\n    /**\n     * Returns Map with all package names and visibility values for given account.\n     * The method and returned map must be guarded by accounts.cacheLock\n     *\n     * @param account Account to get visibility values.\n     * @param accounts UserAccount that currently hosts the account and application\n     *\n     * @return Map with cache for package names to visibility.\n     */\n    private @NonNull Map<String, Integer> getPackagesAndVisibilityForAccountLocked(Account account,\n            UserAccounts accounts) {\n        Map<String, Integer> accountVisibility = accounts.visibilityCache.get(account);\n        if (accountVisibility == null) {\n            Log.d(TAG, \"Visibility was not initialized\");\n            accountVisibility = new HashMap<>();\n            accounts.visibilityCache.put(account, accountVisibility);\n            AccountManager.invalidateLocalAccountsDataCaches();\n        }\n        return accountVisibility;\n    }\n\n    @Override\n    public int getAccountVisibility(Account account, String packageName) {\n        Objects.requireNonNull(account, \"account cannot be null\");\n        Objects.requireNonNull(packageName, \"packageName cannot be null\");\n        int callingUid = Binder.getCallingUid();\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)\n            && !isSystemUid(callingUid)) {\n            String msg = String.format(\n                    \"uid %s cannot get secrets for accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            if (AccountManager.PACKAGE_NAME_KEY_LEGACY_VISIBLE.equals(packageName)) {\n                int visibility = getAccountVisibilityFromCache(account, packageName, accounts);\n                if (AccountManager.VISIBILITY_UNDEFINED != visibility) {\n                    return visibility;\n                } else {\n                   return AccountManager.VISIBILITY_USER_MANAGED_VISIBLE;\n                }\n            }\n            if (AccountManager.PACKAGE_NAME_KEY_LEGACY_NOT_VISIBLE.equals(packageName)) {\n                int visibility = getAccountVisibilityFromCache(account, packageName, accounts);\n                if (AccountManager.VISIBILITY_UNDEFINED != visibility) {\n                    return visibility;\n                } else {\n                   return AccountManager.VISIBILITY_USER_MANAGED_NOT_VISIBLE;\n                }\n            }\n            return resolveAccountVisibility(account, packageName, accounts);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    /**\n     * Method returns visibility for given account and package name.\n     *\n     * @param account The account to check visibility.\n     * @param packageName Package name to check visibility.\n     * @param accounts UserAccount that currently hosts the account and application\n     *\n     * @return Visibility value, AccountManager.VISIBILITY_UNDEFINED if no value was stored.\n     *\n     */\n    private int getAccountVisibilityFromCache(Account account, String packageName,\n            UserAccounts accounts) {\n        synchronized (accounts.cacheLock) {\n            Map<String, Integer> accountVisibility =\n                    getPackagesAndVisibilityForAccountLocked(account, accounts);\n            Integer visibility = accountVisibility.get(packageName);\n            return visibility != null ? visibility : AccountManager.VISIBILITY_UNDEFINED;\n        }\n    }\n\n    /**\n     * Method which handles default values for Account visibility.\n     *\n     * @param account The account to check visibility.\n     * @param packageName Package name to check visibility\n     * @param accounts UserAccount that currently hosts the account and application\n     *\n     * @return Visibility value, the method never returns AccountManager.VISIBILITY_UNDEFINED\n     *\n     */\n    private Integer resolveAccountVisibility(Account account, @NonNull String packageName,\n            UserAccounts accounts) {\n        Objects.requireNonNull(packageName, \"packageName cannot be null\");\n        int uid = -1;\n        try {\n            final long identityToken = clearCallingIdentity();\n            try {\n                uid = mPackageManager.getPackageUidAsUser(packageName, accounts.userId);\n            } finally {\n                restoreCallingIdentity(identityToken);\n            }\n        } catch (NameNotFoundException e) {\n            Log.d(TAG, \"Package not found \" + e.getMessage());\n            return AccountManager.VISIBILITY_NOT_VISIBLE;\n        }\n\n        // System visibility can not be restricted.\n        if (UserHandle.isSameApp(uid, Process.SYSTEM_UID)) {\n            return AccountManager.VISIBILITY_VISIBLE;\n        }\n\n        int signatureCheckResult =\n                checkPackageSignature(account.type, uid, accounts.userId);\n\n        // Authenticator can not restrict visibility to itself.\n        if (signatureCheckResult == SIGNATURE_CHECK_UID_MATCH) {\n            return AccountManager.VISIBILITY_VISIBLE; // Authenticator can always see the account\n        }\n\n        // Return stored value if it was set.\n        int visibility = getAccountVisibilityFromCache(account, packageName, accounts);\n\n        if (AccountManager.VISIBILITY_UNDEFINED != visibility) {\n            return visibility;\n        }\n\n        boolean isPrivileged = isPermittedForPackage(packageName, accounts.userId,\n                Manifest.permission.GET_ACCOUNTS_PRIVILEGED);\n\n        // Device/Profile owner gets visibility by default.\n        if (isProfileOwner(uid)) {\n            return AccountManager.VISIBILITY_VISIBLE;\n        }\n\n        boolean preO = isPreOApplication(packageName);\n        if ((signatureCheckResult != SIGNATURE_CHECK_MISMATCH)\n                || (preO && checkGetAccountsPermission(packageName, accounts.userId))\n                || (checkReadContactsPermission(packageName, accounts.userId)\n                    && accountTypeManagesContacts(account.type, accounts.userId))\n                || isPrivileged) {\n            // Use legacy for preO apps with GET_ACCOUNTS permission or pre/postO with signature\n            // match.\n            visibility = getAccountVisibilityFromCache(account,\n                    AccountManager.PACKAGE_NAME_KEY_LEGACY_VISIBLE, accounts);\n            if (AccountManager.VISIBILITY_UNDEFINED == visibility) {\n                visibility = AccountManager.VISIBILITY_USER_MANAGED_VISIBLE;\n            }\n        } else {\n            visibility = getAccountVisibilityFromCache(account,\n                    AccountManager.PACKAGE_NAME_KEY_LEGACY_NOT_VISIBLE, accounts);\n            if (AccountManager.VISIBILITY_UNDEFINED == visibility) {\n                visibility = AccountManager.VISIBILITY_USER_MANAGED_NOT_VISIBLE;\n            }\n        }\n        return visibility;\n    }\n\n    /**\n     * Checks targetSdk for a package;\n     *\n     * @param packageName Package name\n     *\n     * @return True if package's target SDK is below {@link android.os.Build.VERSION_CODES#O}, or\n     *         undefined\n     */\n    private boolean isPreOApplication(String packageName) {\n        try {\n            final long identityToken = clearCallingIdentity();\n            ApplicationInfo applicationInfo;\n            try {\n                applicationInfo = mPackageManager.getApplicationInfo(packageName, 0);\n            } finally {\n                restoreCallingIdentity(identityToken);\n            }\n\n            if (applicationInfo != null) {\n                int version = applicationInfo.targetSdkVersion;\n                return version < android.os.Build.VERSION_CODES.O;\n            }\n            return true;\n        } catch (NameNotFoundException e) {\n            Log.d(TAG, \"Package not found \" + e.getMessage());\n            return true;\n        }\n    }\n\n    @Override\n    public boolean setAccountVisibility(Account account, String packageName, int newVisibility) {\n        Objects.requireNonNull(account, \"account cannot be null\");\n        Objects.requireNonNull(packageName, \"packageName cannot be null\");\n        int callingUid = Binder.getCallingUid();\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)\n            && !isSystemUid(callingUid)) {\n            String msg = String.format(\n                    \"uid %s cannot get secrets for accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return setAccountVisibility(account, packageName, newVisibility, true /* notify */,\n                accounts);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private boolean isVisible(int visibility) {\n        return visibility == AccountManager.VISIBILITY_VISIBLE ||\n            visibility == AccountManager.VISIBILITY_USER_MANAGED_VISIBLE;\n    }\n\n    /**\n     * Updates visibility for given account name and package.\n     *\n     * @param account Account to update visibility.\n     * @param packageName Package name for which visibility is updated.\n     * @param newVisibility New visibility calue\n     * @param notify if the flag is set applications will get notification about visibility change\n     * @param accounts UserAccount that currently hosts the account and application\n     *\n     * @return True if account visibility was changed.\n     */\n    private boolean setAccountVisibility(Account account, String packageName, int newVisibility,\n            boolean notify, UserAccounts accounts) {\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                Map<String, Integer> packagesToVisibility;\n                List<String> accountRemovedReceivers;\n                if (notify) {\n                    if (isSpecialPackageKey(packageName)) {\n                        packagesToVisibility =\n                                getRequestingPackages(account, accounts);\n                        accountRemovedReceivers = getAccountRemovedReceivers(account, accounts);\n                    } else {\n                        if (!packageExistsForUser(packageName, accounts.userId)) {\n                            return false; // package is not installed.\n                        }\n                        packagesToVisibility = new HashMap<>();\n                        packagesToVisibility.put(packageName,\n                                resolveAccountVisibility(account, packageName, accounts));\n                        accountRemovedReceivers = new ArrayList<>();\n                        if (shouldNotifyPackageOnAccountRemoval(account, packageName, accounts)) {\n                            accountRemovedReceivers.add(packageName);\n                        }\n                    }\n                } else {\n                    // Notifications will not be send - only used during add account.\n                    if (!isSpecialPackageKey(packageName) &&\n                            !packageExistsForUser(packageName, accounts.userId)) {\n                        // package is not installed and not meta value.\n                        return false;\n                    }\n                    packagesToVisibility = Collections.emptyMap();\n                    accountRemovedReceivers = Collections.emptyList();\n                }\n\n                if (!updateAccountVisibilityLocked(account, packageName, newVisibility, accounts)) {\n                    return false;\n                }\n\n                if (notify) {\n                    for (Entry<String, Integer> packageToVisibility : packagesToVisibility\n                            .entrySet()) {\n                        int oldVisibility = packageToVisibility.getValue();\n                        int currentVisibility =\n                            resolveAccountVisibility(account, packageName, accounts);\n                        if (isVisible(oldVisibility) != isVisible(currentVisibility)) {\n                            notifyPackage(packageToVisibility.getKey(), accounts);\n                        }\n                    }\n                    for (String packageNameToNotify : accountRemovedReceivers) {\n                        sendAccountRemovedBroadcast(account, packageNameToNotify, accounts.userId);\n                    }\n                    sendAccountsChangedBroadcast(accounts.userId);\n                }\n                return true;\n            }\n        }\n    }\n\n    // Update account visibility in cache and database.\n    private boolean updateAccountVisibilityLocked(Account account, String packageName,\n            int newVisibility, UserAccounts accounts) {\n        final long accountId = accounts.accountsDb.findDeAccountId(account);\n        if (accountId < 0) {\n            return false;\n        }\n\n        final StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskWrites();\n        try {\n            if (!accounts.accountsDb.setAccountVisibility(accountId, packageName,\n                    newVisibility)) {\n                return false;\n            }\n        } finally {\n            StrictMode.setThreadPolicy(oldPolicy);\n        }\n        Map<String, Integer> accountVisibility =\n            getPackagesAndVisibilityForAccountLocked(account, accounts);\n        accountVisibility.put(packageName, newVisibility);\n        AccountManager.invalidateLocalAccountsDataCaches();\n        return true;\n    }\n\n    @Override\n    public void registerAccountListener(String[] accountTypes, String opPackageName) {\n        int callingUid = Binder.getCallingUid();\n        mAppOpsManager.checkPackage(callingUid, opPackageName);\n\n        int userId = UserHandle.getCallingUserId();\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            registerAccountListener(accountTypes, opPackageName, accounts);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private void registerAccountListener(String[] accountTypes, String opPackageName,\n            UserAccounts accounts) {\n        synchronized (accounts.mReceiversForType) {\n            if (accountTypes == null) {\n                // null for any type\n                accountTypes = new String[] {null};\n            }\n            for (String type : accountTypes) {\n                Map<String, Integer> receivers = accounts.mReceiversForType.get(type);\n                if (receivers == null) {\n                    receivers = new HashMap<>();\n                    accounts.mReceiversForType.put(type, receivers);\n                }\n                Integer cnt = receivers.get(opPackageName);\n                receivers.put(opPackageName, cnt != null ? cnt + 1 : 1);\n            }\n        }\n    }\n\n    @Override\n    public void unregisterAccountListener(String[] accountTypes, String opPackageName) {\n        int callingUid = Binder.getCallingUid();\n        mAppOpsManager.checkPackage(callingUid, opPackageName);\n        int userId = UserHandle.getCallingUserId();\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            unregisterAccountListener(accountTypes, opPackageName, accounts);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private void unregisterAccountListener(String[] accountTypes, String opPackageName,\n            UserAccounts accounts) {\n        synchronized (accounts.mReceiversForType) {\n            if (accountTypes == null) {\n                // null for any type\n                accountTypes = new String[] {null};\n            }\n            for (String type : accountTypes) {\n                Map<String, Integer> receivers = accounts.mReceiversForType.get(type);\n                if (receivers == null || receivers.get(opPackageName) == null) {\n                    throw new IllegalArgumentException(\"attempt to unregister wrong receiver\");\n                }\n                Integer cnt = receivers.get(opPackageName);\n                if (cnt == 1) {\n                    receivers.remove(opPackageName);\n                } else {\n                    receivers.put(opPackageName, cnt - 1);\n                }\n            }\n        }\n    }\n\n    // Send notification to all packages which can potentially see the account\n    private void sendNotificationAccountUpdated(Account account, UserAccounts accounts) {\n        Map<String, Integer> packagesToVisibility = getRequestingPackages(account, accounts);\n\n        for (Entry<String, Integer> packageToVisibility : packagesToVisibility.entrySet()) {\n            if ((packageToVisibility.getValue() != AccountManager.VISIBILITY_NOT_VISIBLE)\n                    && (packageToVisibility.getValue()\n                        != AccountManager.VISIBILITY_USER_MANAGED_NOT_VISIBLE)) {\n                notifyPackage(packageToVisibility.getKey(), accounts);\n            }\n        }\n    }\n\n    /**\n     * Sends a direct intent to a package, notifying it of account visibility change.\n     *\n     * @param packageName to send Account to\n     * @param accounts UserAccount that currently hosts the account\n     */\n    private void notifyPackage(String packageName, UserAccounts accounts) {\n        Intent intent = new Intent(AccountManager.ACTION_VISIBLE_ACCOUNTS_CHANGED);\n        intent.setPackage(packageName);\n        intent.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);\n        mContext.sendBroadcastAsUser(intent, new UserHandle(accounts.userId));\n    }\n\n    // Returns a map from package name to visibility, for packages subscribed\n    // to notifications about any account type, or type of provided account\n    // account type or all types.\n    private Map<String, Integer> getRequestingPackages(Account account, UserAccounts accounts) {\n        Set<String> packages = new HashSet<>();\n        synchronized (accounts.mReceiversForType) {\n            for (String type : new String[] {account.type, null}) {\n                Map<String, Integer> receivers = accounts.mReceiversForType.get(type);\n                if (receivers != null) {\n                    packages.addAll(receivers.keySet());\n                }\n            }\n        }\n        Map<String, Integer> result = new HashMap<>();\n        for (String packageName : packages) {\n            result.put(packageName, resolveAccountVisibility(account, packageName, accounts));\n        }\n        return result;\n    }\n\n    // Returns a list of packages listening to ACTION_ACCOUNT_REMOVED able to see the account.\n    private List<String> getAccountRemovedReceivers(Account account, UserAccounts accounts) {\n        Intent intent = new Intent(AccountManager.ACTION_ACCOUNT_REMOVED);\n        intent.setFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);\n        List<ResolveInfo> receivers =\n            mPackageManager.queryBroadcastReceiversAsUser(intent, 0, accounts.userId);\n        List<String> result = new ArrayList<>();\n        if (receivers == null) {\n            return result;\n        }\n        for (ResolveInfo resolveInfo: receivers) {\n            String packageName = resolveInfo.activityInfo.applicationInfo.packageName;\n            int visibility = resolveAccountVisibility(account, packageName, accounts);\n            if (visibility == AccountManager.VISIBILITY_VISIBLE\n                || visibility == AccountManager.VISIBILITY_USER_MANAGED_VISIBLE) {\n                result.add(packageName);\n            }\n        }\n        return result;\n    }\n\n    // Returns true if given package is listening to ACTION_ACCOUNT_REMOVED and can see the account.\n    private boolean shouldNotifyPackageOnAccountRemoval(Account account,\n            String packageName, UserAccounts accounts) {\n        int visibility = resolveAccountVisibility(account, packageName, accounts);\n        if (visibility != AccountManager.VISIBILITY_VISIBLE\n            && visibility != AccountManager.VISIBILITY_USER_MANAGED_VISIBLE) {\n            return false;\n        }\n\n        Intent intent = new Intent(AccountManager.ACTION_ACCOUNT_REMOVED);\n        intent.setFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);\n        intent.setPackage(packageName);\n        List<ResolveInfo> receivers =\n            mPackageManager.queryBroadcastReceiversAsUser(intent, 0, accounts.userId);\n        return (receivers != null && receivers.size() > 0);\n    }\n\n    private boolean packageExistsForUser(String packageName, int userId) {\n        try {\n            final long identityToken = clearCallingIdentity();\n            try {\n                mPackageManager.getPackageUidAsUser(packageName, userId);\n                return true;\n            } finally {\n                restoreCallingIdentity(identityToken);\n            }\n        } catch (NameNotFoundException e) {\n            return false;\n        }\n    }\n\n    /**\n     * Returns true if packageName is one of special values.\n     */\n    private boolean isSpecialPackageKey(String packageName) {\n        return (AccountManager.PACKAGE_NAME_KEY_LEGACY_VISIBLE.equals(packageName)\n                || AccountManager.PACKAGE_NAME_KEY_LEGACY_NOT_VISIBLE.equals(packageName));\n    }\n\n    private void sendAccountsChangedBroadcast(int userId) {\n        Log.i(TAG, \"the accounts changed, sending broadcast of \"\n                + ACCOUNTS_CHANGED_INTENT.getAction());\n        mContext.sendBroadcastAsUser(ACCOUNTS_CHANGED_INTENT, new UserHandle(userId));\n    }\n\n    private void sendAccountRemovedBroadcast(Account account, String packageName, int userId) {\n        Intent intent = new Intent(AccountManager.ACTION_ACCOUNT_REMOVED);\n        intent.setFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);\n        intent.setPackage(packageName);\n        intent.putExtra(AccountManager.KEY_ACCOUNT_NAME, account.name);\n        intent.putExtra(AccountManager.KEY_ACCOUNT_TYPE, account.type);\n        mContext.sendBroadcastAsUser(intent, new UserHandle(userId));\n    }\n\n    @Override\n    public boolean onTransact(int code, Parcel data, Parcel reply, int flags)\n            throws RemoteException {\n        try {\n            return super.onTransact(code, data, reply, flags);\n        } catch (RuntimeException e) {\n            // The account manager only throws security exceptions, so let's\n            // log all others.\n            if (!(e instanceof SecurityException || e instanceof IllegalArgumentException)) {\n                Slog.wtf(TAG, \"Account Manager Crash\", e);\n            }\n            throw e;\n        }\n    }\n\n    private UserManager getUserManager() {\n        if (mUserManager == null) {\n            mUserManager = UserManager.get(mContext);\n        }\n        return mUserManager;\n    }\n\n    /**\n     * Validate internal set of accounts against installed authenticators for\n     * given user. Clears cached authenticators before validating.\n     */\n    public void validateAccounts(int userId) {\n        final UserAccounts accounts = getUserAccounts(userId);\n        // Invalidate user-specific cache to make sure we catch any\n        // removed authenticators.\n        validateAccountsInternal(accounts, true /* invalidateAuthenticatorCache */);\n    }\n\n    /**\n     * Validate internal set of accounts against installed authenticators for\n     * given user. Clear cached authenticators before validating when requested.\n     */\n    private void validateAccountsInternal(\n            UserAccounts accounts, boolean invalidateAuthenticatorCache) {\n        if (Log.isLoggable(TAG, Log.DEBUG)) {\n            Log.d(TAG, \"validateAccountsInternal \" + accounts.userId\n                    + \" isCeDatabaseAttached=\" + accounts.accountsDb.isCeDatabaseAttached()\n                    + \" userLocked=\" + mLocalUnlockedUsers.get(accounts.userId));\n        }\n\n        if (invalidateAuthenticatorCache) {\n            mAuthenticatorCache.invalidateCache(accounts.userId);\n        }\n\n        final HashMap<String, Integer> knownAuth = getAuthenticatorTypeAndUIDForUser(\n                mAuthenticatorCache, accounts.userId);\n        boolean userUnlocked = isLocalUnlockedUser(accounts.userId);\n\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                boolean accountDeleted = false;\n\n                // Get a map of stored authenticator types to UID\n                final AccountsDb accountsDb = accounts.accountsDb;\n                Map<String, Integer> metaAuthUid = accountsDb.findMetaAuthUid();\n                // Create a list of authenticator type whose previous uid no longer exists\n                HashSet<String> obsoleteAuthType = Sets.newHashSet();\n                SparseBooleanArray knownUids = null;\n                for (Entry<String, Integer> authToUidEntry : metaAuthUid.entrySet()) {\n                    String type = authToUidEntry.getKey();\n                    int uid = authToUidEntry.getValue();\n                    Integer knownUid = knownAuth.get(type);\n                    if (knownUid != null && uid == knownUid) {\n                        // Remove it from the knownAuth list if it's unchanged.\n                        knownAuth.remove(type);\n                    } else {\n                    /*\n                     * The authenticator is presently not cached and should only be triggered\n                     * when we think an authenticator has been removed (or is being updated).\n                     * But we still want to check if any data with the associated uid is\n                     * around. This is an (imperfect) signal that the package may be updating.\n                     *\n                     * A side effect of this is that an authenticator sharing a uid with\n                     * multiple apps won't get its credentials wiped as long as some app with\n                     * that uid is still on the device. But I suspect that this is a rare case.\n                     * And it isn't clear to me how an attacker could really exploit that\n                     * feature.\n                     *\n                     * The upshot is that we don't have to worry about accounts getting\n                     * uninstalled while the authenticator's package is being updated.\n                     *\n                     */\n                        if (knownUids == null) {\n                            knownUids = getUidsOfInstalledOrUpdatedPackagesAsUser(accounts.userId);\n                        }\n                        if (!knownUids.get(uid)) {\n                            // The authenticator is not presently available to the cache. And the\n                            // package no longer has a data directory (so we surmise it isn't\n                            // updating). So purge its data from the account databases.\n                            obsoleteAuthType.add(type);\n                            // And delete it from the TABLE_META\n                            accountsDb.deleteMetaByAuthTypeAndUid(type, uid);\n                        } else if (knownUid != null && knownUid != uid) {\n                            Slog.w(TAG, \"authenticator no longer exist for type \" + type);\n                            obsoleteAuthType.add(type);\n                            accountsDb.deleteMetaByAuthTypeAndUid(type, uid);\n                        }\n                    }\n                }\n\n                // Add the newly registered authenticator to TABLE_META. If old authenticators have\n                // been re-enabled (after being updated for example), then we just overwrite the old\n                // values.\n                for (Entry<String, Integer> entry : knownAuth.entrySet()) {\n                    accountsDb.insertOrReplaceMetaAuthTypeAndUid(entry.getKey(), entry.getValue());\n                }\n\n                final Map<Long, Account> accountsMap = accountsDb.findAllDeAccounts();\n                try {\n                    accounts.accountCache.clear();\n                    final HashMap<String, ArrayList<String>> accountNamesByType\n                            = new LinkedHashMap<>();\n                    for (Entry<Long, Account> accountEntry : accountsMap.entrySet()) {\n                        final long accountId = accountEntry.getKey();\n                        final Account account = accountEntry.getValue();\n                        if (obsoleteAuthType.contains(account.type)) {\n                            Slog.w(TAG, \"deleting account \" + account.toSafeString()\n                                    + \" because type \" + account.type\n                                    + \"'s registered authenticator no longer exist.\");\n                            Map<String, Integer> packagesToVisibility =\n                                    getRequestingPackages(account, accounts);\n                            List<String> accountRemovedReceivers =\n                                getAccountRemovedReceivers(account, accounts);\n                            accountsDb.beginTransaction();\n                            try {\n                                accountsDb.deleteDeAccount(accountId);\n                                // Also delete from CE table if user is unlocked; if user is\n                                // currently locked the account will be removed later by\n                                // syncDeCeAccountsLocked\n                                if (userUnlocked) {\n                                    accountsDb.deleteCeAccount(accountId);\n                                }\n                                accountsDb.setTransactionSuccessful();\n                            } finally {\n                                accountsDb.endTransaction();\n                            }\n                            accountDeleted = true;\n\n                            logRecord(AccountsDb.DEBUG_ACTION_AUTHENTICATOR_REMOVE,\n                                    AccountsDb.TABLE_ACCOUNTS, accountId, accounts);\n\n                            accounts.userDataCache.remove(account);\n                            accounts.authTokenCache.remove(account);\n                            accounts.accountTokenCaches.remove(account);\n                            accounts.visibilityCache.remove(account);\n\n                            for (Entry<String, Integer> packageToVisibility :\n                                    packagesToVisibility.entrySet()) {\n                                if (isVisible(packageToVisibility.getValue())) {\n                                    notifyPackage(packageToVisibility.getKey(), accounts);\n                                }\n                            }\n                            for (String packageName : accountRemovedReceivers) {\n                                sendAccountRemovedBroadcast(account, packageName, accounts.userId);\n                            }\n                        } else {\n                            ArrayList<String> accountNames = accountNamesByType.get(account.type);\n                            if (accountNames == null) {\n                                accountNames = new ArrayList<>();\n                                accountNamesByType.put(account.type, accountNames);\n                            }\n                            accountNames.add(account.name);\n                        }\n                    }\n                    for (Map.Entry<String, ArrayList<String>> cur : accountNamesByType.entrySet()) {\n                        final String accountType = cur.getKey();\n                        final ArrayList<String> accountNames = cur.getValue();\n                        final Account[] accountsForType = new Account[accountNames.size()];\n                        for (int i = 0; i < accountsForType.length; i++) {\n                            accountsForType[i] = new Account(accountNames.get(i), accountType,\n                                    UUID.randomUUID().toString());\n                        }\n                        accounts.accountCache.put(accountType, accountsForType);\n                    }\n                    accounts.visibilityCache.putAll(accountsDb.findAllVisibilityValues());\n                    AccountManager.invalidateLocalAccountsDataCaches();\n                } finally {\n                    if (accountDeleted) {\n                        sendAccountsChangedBroadcast(accounts.userId);\n                    }\n                }\n            }\n        }\n    }\n\n    private SparseBooleanArray getUidsOfInstalledOrUpdatedPackagesAsUser(int userId) {\n        // Get the UIDs of all apps that might have data on the device. We want\n        // to preserve user data if the app might otherwise be storing data.\n        List<PackageInfo> pkgsWithData =\n                mPackageManager.getInstalledPackagesAsUser(\n                        PackageManager.MATCH_UNINSTALLED_PACKAGES, userId);\n        SparseBooleanArray knownUids = new SparseBooleanArray(pkgsWithData.size());\n        for (PackageInfo pkgInfo : pkgsWithData) {\n            if (pkgInfo.applicationInfo != null\n                    && (pkgInfo.applicationInfo.flags & ApplicationInfo.FLAG_INSTALLED) != 0) {\n                knownUids.put(pkgInfo.applicationInfo.uid, true);\n            }\n        }\n        return knownUids;\n    }\n\n    static HashMap<String, Integer> getAuthenticatorTypeAndUIDForUser(\n            Context context,\n            int userId) {\n        AccountAuthenticatorCache authCache = new AccountAuthenticatorCache(context);\n        return getAuthenticatorTypeAndUIDForUser(authCache, userId);\n    }\n\n    private static HashMap<String, Integer> getAuthenticatorTypeAndUIDForUser(\n            IAccountAuthenticatorCache authCache,\n            int userId) {\n        HashMap<String, Integer> knownAuth = new LinkedHashMap<>();\n        for (RegisteredServicesCache.ServiceInfo<AuthenticatorDescription> service : authCache\n                .getAllServices(userId)) {\n            knownAuth.put(service.type.type, service.uid);\n        }\n        return knownAuth;\n    }\n\n    private UserAccounts getUserAccountsForCaller() {\n        return getUserAccounts(UserHandle.getCallingUserId());\n    }\n\n    protected UserAccounts getUserAccounts(int userId) {\n        try {\n            return getUserAccountsNotChecked(userId);\n        } catch (RuntimeException e) {\n            if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE)) {\n                // Let it go...\n                throw e;\n            }\n            // User accounts database is corrupted, we must wipe out the whole user, otherwise the\n            // system will crash indefinitely\n            Slog.wtf(TAG, \"Removing user \" + userId + \" due to exception (\" + e + \") reading its \"\n                    + \"account database\");\n            if (userId == ActivityManager.getCurrentUser() && userId != UserHandle.USER_SYSTEM) {\n                Slog.i(TAG, \"Switching to system user first\");\n                try {\n                    ActivityManager.getService().switchUser(UserHandle.USER_SYSTEM);\n                } catch (RemoteException re) {\n                    Slog.e(TAG, \"Could not switch to \" + UserHandle.USER_SYSTEM + \": \" + re);\n                }\n            }\n            if (!getUserManager().removeUserEvenWhenDisallowed(userId)) {\n                Slog.e(TAG, \"could not remove user \" + userId);\n            }\n            throw e;\n        }\n    }\n\n    private UserAccounts getUserAccountsNotChecked(int userId) {\n        synchronized (mUsers) {\n            UserAccounts accounts = mUsers.get(userId);\n            boolean validateAccounts = false;\n            if (accounts == null) {\n                File preNDbFile = new File(mInjector.getPreNDatabaseName(userId));\n                File deDbFile = new File(mInjector.getDeDatabaseName(userId));\n                accounts = new UserAccounts(mContext, userId, preNDbFile, deDbFile);\n                mUsers.append(userId, accounts);\n                purgeOldGrants(accounts);\n                AccountManager.invalidateLocalAccountsDataCaches();\n                validateAccounts = true;\n            }\n            // open CE database if necessary\n            if (!accounts.accountsDb.isCeDatabaseAttached() && mLocalUnlockedUsers.get(userId)) {\n                Log.i(TAG, \"User \" + userId + \" is unlocked - opening CE database\");\n                synchronized (accounts.dbLock) {\n                    synchronized (accounts.cacheLock) {\n                        File ceDatabaseFile = new File(mInjector.getCeDatabaseName(userId));\n                        accounts.accountsDb.attachCeDatabase(ceDatabaseFile);\n                    }\n                }\n                syncDeCeAccountsLocked(accounts);\n            }\n            if (validateAccounts) {\n                validateAccountsInternal(accounts, true /* invalidateAuthenticatorCache */);\n            }\n            return accounts;\n        }\n    }\n\n    private void syncDeCeAccountsLocked(UserAccounts accounts) {\n        Preconditions.checkState(Thread.holdsLock(mUsers), \"mUsers lock must be held\");\n        List<Account> accountsToRemove = accounts.accountsDb.findCeAccountsNotInDe();\n        if (!accountsToRemove.isEmpty()) {\n            Slog.i(TAG, accountsToRemove.size()\n                    + \" accounts were previously deleted while user \"\n                    + accounts.userId + \" was locked. Removing accounts from CE tables\");\n            logRecord(accounts, AccountsDb.DEBUG_ACTION_SYNC_DE_CE_ACCOUNTS,\n                    AccountsDb.TABLE_ACCOUNTS);\n\n            for (Account account : accountsToRemove) {\n                removeAccountInternal(accounts, account, Process.SYSTEM_UID);\n            }\n        }\n    }\n\n    private void purgeOldGrantsAll() {\n        synchronized (mUsers) {\n            for (int i = 0; i < mUsers.size(); i++) {\n                purgeOldGrants(mUsers.valueAt(i));\n            }\n        }\n    }\n\n    private void purgeOldGrants(UserAccounts accounts) {\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                List<Integer> uids = accounts.accountsDb.findAllUidGrants();\n                for (int uid : uids) {\n                    final boolean packageExists = mPackageManager.getPackagesForUid(uid) != null;\n                    if (packageExists) {\n                        continue;\n                    }\n                    Log.d(TAG, \"deleting grants for UID \" + uid\n                            + \" because its package is no longer installed\");\n                    accounts.accountsDb.deleteGrantsByUid(uid);\n                }\n            }\n        }\n    }\n\n    private void removeVisibilityValuesForPackage(String packageName) {\n        if (isSpecialPackageKey(packageName)) {\n            return;\n        }\n        synchronized (mUsers) {\n            int numberOfUsers = mUsers.size();\n            for (int i = 0; i < numberOfUsers; i++) {\n                UserAccounts accounts = mUsers.valueAt(i);\n                try {\n                    mPackageManager.getPackageUidAsUser(packageName, accounts.userId);\n                } catch (NameNotFoundException e) {\n                    // package does not exist - remove visibility values\n                    accounts.accountsDb.deleteAccountVisibilityForPackage(packageName);\n                    synchronized (accounts.dbLock) {\n                        synchronized (accounts.cacheLock) {\n                            for (Account account : accounts.visibilityCache.keySet()) {\n                                Map<String, Integer> accountVisibility =\n                                        getPackagesAndVisibilityForAccountLocked(account, accounts);\n                                accountVisibility.remove(packageName);\n                            }\n                            AccountManager.invalidateLocalAccountsDataCaches();\n                        }\n                    }\n              }\n          }\n        }\n    }\n\n    private void purgeUserData(int userId) {\n        UserAccounts accounts;\n        synchronized (mUsers) {\n            accounts = mUsers.get(userId);\n            mUsers.remove(userId);\n            mLocalUnlockedUsers.delete(userId);\n            AccountManager.invalidateLocalAccountsDataCaches();\n        }\n        if (accounts != null) {\n            synchronized (accounts.dbLock) {\n                synchronized (accounts.cacheLock) {\n                    accounts.accountsDb.closeDebugStatement();\n                    accounts.accountsDb.close();\n                }\n            }\n        }\n    }\n\n    @VisibleForTesting\n    void onUserUnlocked(Intent intent) {\n        onUnlockUser(intent.getIntExtra(Intent.EXTRA_USER_HANDLE, -1));\n    }\n\n    void onUnlockUser(int userId) {\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"onUserUnlocked \" + userId);\n        }\n        synchronized (mUsers) {\n            mLocalUnlockedUsers.put(userId, true);\n        }\n        if (userId < 1) return;\n        mHandler.post(() -> syncSharedAccounts(userId));\n    }\n\n    private void syncSharedAccounts(int userId) {\n        // Check if there's a shared account that needs to be created as an account\n        Account[] sharedAccounts = getSharedAccountsAsUser(userId);\n        if (sharedAccounts == null || sharedAccounts.length == 0) return;\n        Account[] accounts = getAccountsAsUser(null, userId, mContext.getOpPackageName());\n        int parentUserId = UserManager.isSplitSystemUser()\n                ? getUserManager().getUserInfo(userId).restrictedProfileParentId\n                : UserHandle.USER_SYSTEM;\n        if (parentUserId < 0) {\n            Log.w(TAG, \"User \" + userId + \" has shared accounts, but no parent user\");\n            return;\n        }\n        for (Account sa : sharedAccounts) {\n            if (ArrayUtils.contains(accounts, sa)) continue;\n            // Account doesn't exist. Copy it now.\n            copyAccountToUser(null /*no response*/, sa, parentUserId, userId);\n        }\n    }\n\n    @Override\n    public void onServiceChanged(AuthenticatorDescription desc, int userId, boolean removed) {\n        UserInfo user = getUserManager().getUserInfo(userId);\n        if (user == null) {\n            Log.w(TAG, \"onServiceChanged: ignore removed user \" + userId);\n            return;\n        }\n        validateAccountsInternal(getUserAccounts(userId), false /* invalidateAuthenticatorCache */);\n    }\n\n    @Override\n    public String getPassword(Account account) {\n        int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"getPassword: \" + account\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        if (account == null) throw new IllegalArgumentException(\"account is null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot get secrets for accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return readPasswordInternal(accounts, account);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private String readPasswordInternal(UserAccounts accounts, Account account) {\n        if (account == null) {\n            return null;\n        }\n        if (!isLocalUnlockedUser(accounts.userId)) {\n            Log.w(TAG, \"Password is not available - user \" + accounts.userId + \" data is locked\");\n            return null;\n        }\n\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                return accounts.accountsDb\n                        .findAccountPasswordByNameAndType(account.name, account.type);\n            }\n        }\n    }\n\n    @Override\n    public String getPreviousName(Account account) {\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"getPreviousName: \" + account\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        int userId = UserHandle.getCallingUserId();\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return readPreviousNameInternal(accounts, account);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private String readPreviousNameInternal(UserAccounts accounts, Account account) {\n        if  (account == null) {\n            return null;\n        }\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                AtomicReference<String> previousNameRef = accounts.previousNameCache.get(account);\n                if (previousNameRef == null) {\n                    String previousName = accounts.accountsDb.findDeAccountPreviousName(account);\n                    previousNameRef = new AtomicReference<>(previousName);\n                    accounts.previousNameCache.put(account, previousNameRef);\n                    return previousName;\n                } else {\n                    return previousNameRef.get();\n                }\n            }\n        }\n    }\n\n    @Override\n    public String getUserData(Account account, String key) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            String msg = String.format(\"getUserData( account: %s, key: %s, callerUid: %s, pid: %s\",\n                    account, key, callingUid, Binder.getCallingPid());\n            Log.v(TAG, msg);\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        Objects.requireNonNull(key, \"key cannot be null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot get user data for accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        if (!isLocalUnlockedUser(userId)) {\n            Log.w(TAG, \"User \" + userId + \" data is locked. callingUid \" + callingUid);\n            return null;\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            if (!accountExistsCache(accounts, account)) {\n                return null;\n            }\n            return readUserDataInternal(accounts, account, key);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public AuthenticatorDescription[] getAuthenticatorTypes(int userId) {\n        int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"getAuthenticatorTypes: \"\n                    + \"for user id \" + userId\n                    + \" caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        // Only allow the system process to read accounts of other users\n        if (isCrossUser(callingUid, userId)) {\n            throw new SecurityException(\n                    String.format(\n                            \"User %s tying to get authenticator types for %s\" ,\n                            UserHandle.getCallingUserId(),\n                            userId));\n        }\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            return getAuthenticatorTypesInternal(userId);\n\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    /**\n     * Should only be called inside of a clearCallingIdentity block.\n     */\n    private AuthenticatorDescription[] getAuthenticatorTypesInternal(int userId) {\n        mAuthenticatorCache.updateServices(userId);\n        Collection<AccountAuthenticatorCache.ServiceInfo<AuthenticatorDescription>>\n                authenticatorCollection = mAuthenticatorCache.getAllServices(userId);\n        AuthenticatorDescription[] types =\n                new AuthenticatorDescription[authenticatorCollection.size()];\n        int i = 0;\n        for (AccountAuthenticatorCache.ServiceInfo<AuthenticatorDescription> authenticator\n                : authenticatorCollection) {\n            types[i] = authenticator.type;\n            i++;\n        }\n        return types;\n    }\n\n    private boolean isCrossUser(int callingUid, int userId) {\n        return (userId != UserHandle.getCallingUserId()\n                && callingUid != Process.SYSTEM_UID\n                && mContext.checkCallingOrSelfPermission(\n                        android.Manifest.permission.INTERACT_ACROSS_USERS_FULL)\n                                != PackageManager.PERMISSION_GRANTED);\n    }\n\n    @Override\n    public boolean addAccountExplicitly(\n            Account account, String password, Bundle extras, String opPackageName) {\n        return addAccountExplicitlyWithVisibility(\n                account, password, extras, /* packageToVisibility= */ null, opPackageName);\n    }\n\n    @Override\n    public void copyAccountToUser(final IAccountManagerResponse response, final Account account,\n            final int userFrom, int userTo) {\n        int callingUid = Binder.getCallingUid();\n        if (isCrossUser(callingUid, UserHandle.USER_ALL)) {\n            throw new SecurityException(\"Calling copyAccountToUser requires \"\n                    + android.Manifest.permission.INTERACT_ACROSS_USERS_FULL);\n        }\n        final UserAccounts fromAccounts = getUserAccounts(userFrom);\n        final UserAccounts toAccounts = getUserAccounts(userTo);\n        if (fromAccounts == null || toAccounts == null) {\n            if (response != null) {\n                Bundle result = new Bundle();\n                result.putBoolean(AccountManager.KEY_BOOLEAN_RESULT, false);\n                try {\n                    response.onResult(result);\n                } catch (RemoteException e) {\n                    Slog.w(TAG, \"Failed to report error back to the client.\" + e);\n                }\n            }\n            return;\n        }\n\n        Slog.d(TAG, \"Copying account \" + account.toSafeString()\n                + \" from user \" + userFrom + \" to user \" + userTo);\n        final long identityToken = clearCallingIdentity();\n        try {\n            new Session(fromAccounts, response, account.type, false,\n                    false /* stripAuthTokenFromResult */, account.name,\n                    false /* authDetailsRequired */) {\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now) + \", getAccountCredentialsForClone\"\n                            + \", \" + account.type;\n                }\n\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.getAccountCredentialsForCloning(this, account);\n                }\n\n                @Override\n                public void onResult(Bundle result) {\n                    Bundle.setDefusable(result, true);\n                    if (result != null\n                            && result.getBoolean(AccountManager.KEY_BOOLEAN_RESULT, false)) {\n                        // Create a Session for the target user and pass in the bundle\n                        completeCloningAccount(response, result, account, toAccounts, userFrom);\n                    } else {\n                        super.onResult(result);\n                    }\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public boolean accountAuthenticated(final Account account) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            String msg = String.format(\n                    \"accountAuthenticated( account: %s, callerUid: %s)\",\n                    account,\n                    callingUid);\n            Log.v(TAG, msg);\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot notify authentication for accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n\n        if (!canUserModifyAccounts(userId, callingUid) ||\n                !canUserModifyAccountsForType(userId, account.type, callingUid)) {\n            return false;\n        }\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return updateLastAuthenticatedTime(account);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private boolean updateLastAuthenticatedTime(Account account) {\n        final UserAccounts accounts = getUserAccountsForCaller();\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                return accounts.accountsDb.updateAccountLastAuthenticatedTime(account);\n            }\n        }\n    }\n\n    private void completeCloningAccount(IAccountManagerResponse response,\n            final Bundle accountCredentials, final Account account, final UserAccounts targetUser,\n            final int parentUserId){\n        Bundle.setDefusable(accountCredentials, true);\n        final long id = clearCallingIdentity();\n        try {\n            new Session(targetUser, response, account.type, false,\n                    false /* stripAuthTokenFromResult */, account.name,\n                    false /* authDetailsRequired */) {\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now) + \", getAccountCredentialsForClone\"\n                            + \", \" + account.type;\n                }\n\n                @Override\n                public void run() throws RemoteException {\n                    // Confirm that the owner's account still exists before this step.\n                    for (Account acc : getAccounts(parentUserId, mContext.getOpPackageName())) {\n                        if (acc.equals(account)) {\n                            mAuthenticator.addAccountFromCredentials(\n                                    this, account, accountCredentials);\n                            break;\n                        }\n                    }\n                }\n\n                @Override\n                public void onResult(Bundle result) {\n                    Bundle.setDefusable(result, true);\n                    // TODO: Anything to do if if succedded?\n                    // TODO: If it failed: Show error notification? Should we remove the shadow\n                    // account to avoid retries?\n                    // TODO: what we do with the visibility?\n\n                    super.onResult(result);\n                }\n\n                @Override\n                public void onError(int errorCode, String errorMessage) {\n                    super.onError(errorCode,  errorMessage);\n                    // TODO: Show error notification to user\n                    // TODO: Should we remove the shadow account so that it doesn't keep trying?\n                }\n\n            }.bind();\n        } finally {\n            restoreCallingIdentity(id);\n        }\n    }\n\n    private boolean addAccountInternal(UserAccounts accounts, Account account, String password,\n            Bundle extras, int callingUid, Map<String, Integer> packageToVisibility,\n            String opPackageName) {\n        Bundle.setDefusable(extras, true);\n        if (account == null) {\n            return false;\n        }\n        if (account.name != null && account.name.length() > 200) {\n            Log.w(TAG, \"Account cannot be added - Name longer than 200 chars\");\n            return false;\n        }\n        if (account.type != null && account.type.length() > 200) {\n            Log.w(TAG, \"Account cannot be added - Name longer than 200 chars\");\n            return false;\n        }\n        if (!isLocalUnlockedUser(accounts.userId)) {\n            Log.w(TAG, \"Account \" + account.toSafeString() + \" cannot be added - user \"\n                    + accounts.userId + \" is locked. callingUid=\" + callingUid);\n            return false;\n        }\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                accounts.accountsDb.beginTransaction();\n                try {\n                    if (accounts.accountsDb.findCeAccountId(account) >= 0) {\n                        Log.w(TAG, \"insertAccountIntoDatabase: \" + account.toSafeString()\n                                + \", skipping since the account already exists\");\n                        return false;\n                    }\n                    if (accounts.accountsDb.findAllDeAccounts().size() > 100) {\n                        Log.w(TAG, \"insertAccountIntoDatabase: \" + account.toSafeString()\n                                + \", skipping since more than 50 accounts on device exist\");\n                        return false;\n                    }\n                    long accountId = accounts.accountsDb.insertCeAccount(account, password);\n                    if (accountId < 0) {\n                        Log.w(TAG, \"insertAccountIntoDatabase: \" + account.toSafeString()\n                                + \", skipping the DB insert failed\");\n                        return false;\n                    }\n                    // Insert into DE table\n                    if (accounts.accountsDb.insertDeAccount(account, accountId) < 0) {\n                        Log.w(TAG, \"insertAccountIntoDatabase: \" + account.toSafeString()\n                                + \", skipping the DB insert failed\");\n                        return false;\n                    }\n                    if (extras != null) {\n                        for (String key : extras.keySet()) {\n                            final String value = extras.getString(key);\n                            if (accounts.accountsDb.insertExtra(accountId, key, value) < 0) {\n                                Log.w(TAG, \"insertAccountIntoDatabase: \"\n                                        + account.toSafeString()\n                                        + \", skipping since insertExtra failed for key \" + key);\n                                return false;\n                            } else {\n                                AccountManager.invalidateLocalAccountUserDataCaches();\n                            }\n                        }\n                    }\n\n                    if (packageToVisibility != null) {\n                        for (Entry<String, Integer> entry : packageToVisibility.entrySet()) {\n                            setAccountVisibility(account, entry.getKey() /* package */,\n                                    entry.getValue() /* visibility */, false /* notify */,\n                                    accounts);\n                        }\n                    }\n                    accounts.accountsDb.setTransactionSuccessful();\n\n                    logRecord(AccountsDb.DEBUG_ACTION_ACCOUNT_ADD, AccountsDb.TABLE_ACCOUNTS,\n                            accountId,\n                            accounts, callingUid);\n\n                    insertAccountIntoCacheLocked(accounts, account);\n                } finally {\n                    accounts.accountsDb.endTransaction();\n                }\n            }\n        }\n        if (getUserManager().getUserInfo(accounts.userId).canHaveProfile()) {\n            addAccountToLinkedRestrictedUsers(account, accounts.userId);\n        }\n\n        sendNotificationAccountUpdated(account, accounts);\n        // Only send LOGIN_ACCOUNTS_CHANGED when the database changed.\n        sendAccountsChangedBroadcast(accounts.userId);\n\n        logAddAccountExplicitlyMetrics(opPackageName, account.type, packageToVisibility);\n        return true;\n    }\n\n    private void logAddAccountExplicitlyMetrics(\n            String callerPackage, String accountType,\n            @Nullable Map<String, Integer> accountVisibility) {\n        // Although this is not a 'device policy' API, enterprise is the current use case.\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.ADD_ACCOUNT_EXPLICITLY)\n                .setStrings(\n                        TextUtils.emptyIfNull(accountType),\n                        TextUtils.emptyIfNull(callerPackage),\n                        findPackagesPerVisibility(accountVisibility))\n                .write();\n    }\n\n    private String[] findPackagesPerVisibility(@Nullable Map<String, Integer> accountVisibility) {\n        Map<Integer, Set<String>> packagesPerVisibility = new HashMap<>();\n        if (accountVisibility != null) {\n            for (Entry<String, Integer> entry : accountVisibility.entrySet()) {\n                if (!packagesPerVisibility.containsKey(entry.getValue())) {\n                    packagesPerVisibility.put(entry.getValue(), new HashSet<>());\n                }\n                packagesPerVisibility.get(entry.getValue()).add(entry.getKey());\n            }\n        }\n\n        String[] packagesPerVisibilityStr = new String[5];\n        packagesPerVisibilityStr[AccountManager.VISIBILITY_UNDEFINED] = getPackagesForVisibilityStr(\n                AccountManager.VISIBILITY_UNDEFINED, packagesPerVisibility);\n        packagesPerVisibilityStr[AccountManager.VISIBILITY_VISIBLE] = getPackagesForVisibilityStr(\n                AccountManager.VISIBILITY_VISIBLE, packagesPerVisibility);\n        packagesPerVisibilityStr[AccountManager.VISIBILITY_USER_MANAGED_VISIBLE] =\n                getPackagesForVisibilityStr(\n                        AccountManager.VISIBILITY_USER_MANAGED_VISIBLE, packagesPerVisibility);\n        packagesPerVisibilityStr[AccountManager.VISIBILITY_NOT_VISIBLE] =\n                getPackagesForVisibilityStr(\n                        AccountManager.VISIBILITY_NOT_VISIBLE, packagesPerVisibility);\n        packagesPerVisibilityStr[AccountManager.VISIBILITY_USER_MANAGED_NOT_VISIBLE] =\n                getPackagesForVisibilityStr(\n                        AccountManager.VISIBILITY_USER_MANAGED_NOT_VISIBLE, packagesPerVisibility);\n        return packagesPerVisibilityStr;\n    }\n\n    private String getPackagesForVisibilityStr(\n            int visibility, Map<Integer, Set<String>> packagesPerVisibility) {\n        return visibility + \":\"\n                + (packagesPerVisibility.containsKey(visibility)\n                    ? TextUtils.join(\",\", packagesPerVisibility.get(visibility))\n                    : \"\");\n    }\n\n    private boolean isLocalUnlockedUser(int userId) {\n        synchronized (mUsers) {\n            return mLocalUnlockedUsers.get(userId);\n        }\n    }\n\n    /**\n     * Adds the account to all linked restricted users as shared accounts. If the user is currently\n     * running, then clone the account too.\n     * @param account the account to share with limited users\n     *\n     */\n    private void addAccountToLinkedRestrictedUsers(Account account, int parentUserId) {\n        List<UserInfo> users = getUserManager().getUsers();\n        for (UserInfo user : users) {\n            if (user.isRestricted() && (parentUserId == user.restrictedProfileParentId)) {\n                addSharedAccountAsUser(account, user.id);\n                if (isLocalUnlockedUser(user.id)) {\n                    mHandler.sendMessage(mHandler.obtainMessage(\n                            MESSAGE_COPY_SHARED_ACCOUNT, parentUserId, user.id, account));\n                }\n            }\n        }\n    }\n\n    @Override\n    public void hasFeatures(IAccountManagerResponse response,\n            Account account, String[] features, String opPackageName) {\n        int callingUid = Binder.getCallingUid();\n        mAppOpsManager.checkPackage(callingUid, opPackageName);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"hasFeatures: \" + account\n                    + \", response \" + response\n                    + \", features \" + Arrays.toString(features)\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Preconditions.checkArgument(account != null, \"account cannot be null\");\n        Preconditions.checkArgument(response != null, \"response cannot be null\");\n        Preconditions.checkArgument(features != null, \"features cannot be null\");\n        int userId = UserHandle.getCallingUserId();\n        checkReadAccountsPermitted(callingUid, account.type, userId,\n                opPackageName);\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            new TestFeaturesSession(accounts, response, account, features).bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private class TestFeaturesSession extends Session {\n        private final String[] mFeatures;\n        private final Account mAccount;\n\n        public TestFeaturesSession(UserAccounts accounts, IAccountManagerResponse response,\n                Account account, String[] features) {\n            super(accounts, response, account.type, false /* expectActivityLaunch */,\n                    true /* stripAuthTokenFromResult */, account.name,\n                    false /* authDetailsRequired */);\n            mFeatures = features;\n            mAccount = account;\n        }\n\n        @Override\n        public void run() throws RemoteException {\n            try {\n                mAuthenticator.hasFeatures(this, mAccount, mFeatures);\n            } catch (RemoteException e) {\n                onError(AccountManager.ERROR_CODE_REMOTE_EXCEPTION, \"remote exception\");\n            }\n        }\n\n        @Override\n        public void onResult(Bundle result) {\n            Bundle.setDefusable(result, true);\n            IAccountManagerResponse response = getResponseAndClose();\n            if (response != null) {\n                try {\n                    if (result == null) {\n                        response.onError(AccountManager.ERROR_CODE_INVALID_RESPONSE, \"null bundle\");\n                        return;\n                    }\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, getClass().getSimpleName() + \" calling onResult() on response \"\n                                + response);\n                    }\n                    final Bundle newResult = new Bundle();\n                    newResult.putBoolean(AccountManager.KEY_BOOLEAN_RESULT,\n                            result.getBoolean(AccountManager.KEY_BOOLEAN_RESULT, false));\n                    response.onResult(newResult);\n                } catch (RemoteException e) {\n                    // if the caller is dead then there is no one to care about remote exceptions\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, \"failure while notifying response\", e);\n                    }\n                }\n            }\n        }\n\n        @Override\n        protected String toDebugString(long now) {\n            return super.toDebugString(now) + \", hasFeatures\"\n                    + \", \" + mAccount\n                    + \", \" + (mFeatures != null ? TextUtils.join(\",\", mFeatures) : null);\n        }\n    }\n\n    @Override\n    public void renameAccount(\n            IAccountManagerResponse response, Account accountToRename, String newName) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"renameAccount: \" + accountToRename + \" -> \" + newName\n                + \", caller's uid \" + callingUid\n                + \", pid \" + Binder.getCallingPid());\n        }\n        if (accountToRename == null) throw new IllegalArgumentException(\"account is null\");\n        if (newName != null && newName.length() > 200) {\n            Log.e(TAG, \"renameAccount failed - account name longer than 200\");\n            throw new IllegalArgumentException(\"account name longer than 200\");\n        }\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(accountToRename.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot rename accounts of type: %s\",\n                    callingUid,\n                    accountToRename.type);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            Account resultingAccount = renameAccountInternal(accounts, accountToRename, newName);\n            Bundle result = new Bundle();\n            result.putString(AccountManager.KEY_ACCOUNT_NAME, resultingAccount.name);\n            result.putString(AccountManager.KEY_ACCOUNT_TYPE, resultingAccount.type);\n            result.putString(AccountManager.KEY_ACCOUNT_ACCESS_ID,\n                    resultingAccount.getAccessId());\n            try {\n                response.onResult(result);\n            } catch (RemoteException e) {\n                Log.w(TAG, e.getMessage());\n            }\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private Account renameAccountInternal(\n            UserAccounts accounts, Account accountToRename, String newName) {\n        Account resultAccount = null;\n        /*\n         * Cancel existing notifications. Let authenticators\n         * re-post notifications as required. But we don't know if\n         * the authenticators have bound their notifications to\n         * now stale account name data.\n         *\n         * With a rename api, we might not need to do this anymore but it\n         * shouldn't hurt.\n         */\n        cancelNotification(\n                getSigninRequiredNotificationId(accounts, accountToRename),\n                new UserHandle(accounts.userId));\n        synchronized(accounts.credentialsPermissionNotificationIds) {\n            for (Pair<Pair<Account, String>, Integer> pair:\n                    accounts.credentialsPermissionNotificationIds.keySet()) {\n                if (accountToRename.equals(pair.first.first)) {\n                    NotificationId id = accounts.credentialsPermissionNotificationIds.get(pair);\n                    cancelNotification(id, new UserHandle(accounts.userId));\n                }\n            }\n        }\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                List<String> accountRemovedReceivers =\n                    getAccountRemovedReceivers(accountToRename, accounts);\n                accounts.accountsDb.beginTransaction();\n                Account renamedAccount = new Account(newName, accountToRename.type);\n                try {\n                    if ((accounts.accountsDb.findCeAccountId(renamedAccount) >= 0)) {\n                        Log.e(TAG, \"renameAccount failed - account with new name already exists\");\n                        return null;\n                    }\n                    final long accountId = accounts.accountsDb.findDeAccountId(accountToRename);\n                    if (accountId >= 0) {\n                        accounts.accountsDb.renameCeAccount(accountId, newName);\n                        if (accounts.accountsDb.renameDeAccount(\n                                accountId, newName, accountToRename.name)) {\n                            accounts.accountsDb.setTransactionSuccessful();\n                        } else {\n                            Log.e(TAG, \"renameAccount failed\");\n                            return null;\n                        }\n                    } else {\n                        Log.e(TAG, \"renameAccount failed - old account does not exist\");\n                        return null;\n                    }\n                } finally {\n                    accounts.accountsDb.endTransaction();\n                }\n            /*\n             * Database transaction was successful. Clean up cached\n             * data associated with the account in the user profile.\n             */\n                renamedAccount = insertAccountIntoCacheLocked(accounts, renamedAccount);\n            /*\n             * Extract the data and token caches before removing the\n             * old account to preserve the user data associated with\n             * the account.\n             */\n                Map<String, String> tmpData = accounts.userDataCache.get(accountToRename);\n                Map<String, String> tmpTokens = accounts.authTokenCache.get(accountToRename);\n                Map<String, Integer> tmpVisibility = accounts.visibilityCache.get(accountToRename);\n                removeAccountFromCacheLocked(accounts, accountToRename);\n            /*\n             * Update the cached data associated with the renamed\n             * account.\n             */\n                accounts.userDataCache.put(renamedAccount, tmpData);\n                accounts.authTokenCache.put(renamedAccount, tmpTokens);\n                accounts.visibilityCache.put(renamedAccount, tmpVisibility);\n                accounts.previousNameCache.put(\n                        renamedAccount,\n                        new AtomicReference<>(accountToRename.name));\n                resultAccount = renamedAccount;\n\n                int parentUserId = accounts.userId;\n                if (canHaveProfile(parentUserId)) {\n                /*\n                 * Owner or system user account was renamed, rename the account for\n                 * those users with which the account was shared.\n                 */\n                    List<UserInfo> users = getUserManager().getAliveUsers();\n                    for (UserInfo user : users) {\n                        if (user.isRestricted()\n                                && (user.restrictedProfileParentId == parentUserId)) {\n                            renameSharedAccountAsUser(accountToRename, newName, user.id);\n                        }\n                    }\n                }\n\n                sendNotificationAccountUpdated(resultAccount, accounts);\n                sendAccountsChangedBroadcast(accounts.userId);\n                for (String packageName : accountRemovedReceivers) {\n                    sendAccountRemovedBroadcast(accountToRename, packageName, accounts.userId);\n                }\n\n                AccountManager.invalidateLocalAccountsDataCaches();\n                AccountManager.invalidateLocalAccountUserDataCaches();\n            }\n        }\n        return resultAccount;\n    }\n\n    private boolean canHaveProfile(final int parentUserId) {\n        final UserInfo userInfo = getUserManager().getUserInfo(parentUserId);\n        return userInfo != null && userInfo.canHaveProfile();\n    }\n\n    @Override\n    public void removeAccountAsUser(IAccountManagerResponse response, Account account,\n            boolean expectActivityLaunch, int userId) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"removeAccount: \" + account\n                    + \", response \" + response\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid()\n                    + \", for user id \" + userId);\n        }\n        Preconditions.checkArgument(account != null, \"account cannot be null\");\n        Preconditions.checkArgument(response != null, \"response cannot be null\");\n\n        // Only allow the system process to modify accounts of other users\n        if (isCrossUser(callingUid, userId)) {\n            throw new SecurityException(\n                    String.format(\n                            \"User %s tying remove account for %s\" ,\n                            UserHandle.getCallingUserId(),\n                            userId));\n        }\n        /*\n         * Only the system, authenticator or profile owner should be allowed to remove accounts for\n         * that authenticator.  This will let users remove accounts (via Settings in the system) but\n         * not arbitrary applications (like competing authenticators).\n         */\n        UserHandle user = UserHandle.of(userId);\n        if (!isAccountManagedByCaller(account.type, callingUid, user.getIdentifier())\n                && !isSystemUid(callingUid)\n                && !isProfileOwner(callingUid)) {\n            String msg = String.format(\n                    \"uid %s cannot remove accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        if (!canUserModifyAccounts(userId, callingUid)) {\n            try {\n                response.onError(AccountManager.ERROR_CODE_USER_RESTRICTED,\n                        \"User cannot modify accounts\");\n            } catch (RemoteException re) {\n            }\n            return;\n        }\n        if (!canUserModifyAccountsForType(userId, account.type, callingUid)) {\n            try {\n                response.onError(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                        \"User cannot modify accounts of this type (policy).\");\n            } catch (RemoteException re) {\n            }\n            return;\n        }\n        final long identityToken = clearCallingIdentity();\n        UserAccounts accounts = getUserAccounts(userId);\n        cancelNotification(getSigninRequiredNotificationId(accounts, account), user);\n        synchronized(accounts.credentialsPermissionNotificationIds) {\n            for (Pair<Pair<Account, String>, Integer> pair:\n                accounts.credentialsPermissionNotificationIds.keySet()) {\n                if (account.equals(pair.first.first)) {\n                    NotificationId id = accounts.credentialsPermissionNotificationIds.get(pair);\n                    cancelNotification(id, user);\n                }\n            }\n        }\n        final long accountId = accounts.accountsDb.findDeAccountId(account);\n        logRecord(\n                AccountsDb.DEBUG_ACTION_CALLED_ACCOUNT_REMOVE,\n                AccountsDb.TABLE_ACCOUNTS,\n                accountId,\n                accounts,\n                callingUid);\n        try {\n            new RemoveAccountSession(accounts, response, account, expectActivityLaunch).bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public boolean removeAccountExplicitly(Account account) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"removeAccountExplicitly: \" + account\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        int userId = Binder.getCallingUserHandle().getIdentifier();\n        if (account == null) {\n            /*\n             * Null accounts should result in returning false, as per\n             * AccountManage.addAccountExplicitly(...) java doc.\n             */\n            Log.e(TAG, \"account is null\");\n            return false;\n        } else if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot explicitly remove accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        UserAccounts accounts = getUserAccountsForCaller();\n        final long accountId = accounts.accountsDb.findDeAccountId(account);\n        logRecord(\n                AccountsDb.DEBUG_ACTION_CALLED_ACCOUNT_REMOVE,\n                AccountsDb.TABLE_ACCOUNTS,\n                accountId,\n                accounts,\n                callingUid);\n        final long identityToken = clearCallingIdentity();\n        try {\n            return removeAccountInternal(accounts, account, callingUid);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private class RemoveAccountSession extends Session {\n        final Account mAccount;\n        public RemoveAccountSession(UserAccounts accounts, IAccountManagerResponse response,\n                Account account, boolean expectActivityLaunch) {\n            super(accounts, response, account.type, expectActivityLaunch,\n                    true /* stripAuthTokenFromResult */, account.name,\n                    false /* authDetailsRequired */);\n            mAccount = account;\n        }\n\n        @Override\n        protected String toDebugString(long now) {\n            return super.toDebugString(now) + \", removeAccount\"\n                    + \", account \" + mAccount;\n        }\n\n        @Override\n        public void run() throws RemoteException {\n            mAuthenticator.getAccountRemovalAllowed(this, mAccount);\n        }\n\n        @Override\n        public void onResult(Bundle result) {\n            Bundle.setDefusable(result, true);\n            if (result != null && result.containsKey(AccountManager.KEY_BOOLEAN_RESULT)\n                    && !result.containsKey(AccountManager.KEY_INTENT)) {\n                final boolean removalAllowed = result.getBoolean(AccountManager.KEY_BOOLEAN_RESULT);\n                if (removalAllowed) {\n                    removeAccountInternal(mAccounts, mAccount, getCallingUid());\n                }\n                IAccountManagerResponse response = getResponseAndClose();\n                if (response != null) {\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, getClass().getSimpleName() + \" calling onResult() on response \"\n                                + response);\n                    }\n                    try {\n                        response.onResult(result);\n                    } catch (RemoteException e) {\n                        Slog.e(TAG, \"Error calling onResult()\", e);\n                    }\n                }\n            }\n            super.onResult(result);\n        }\n    }\n\n    @VisibleForTesting\n    protected void removeAccountInternal(Account account) {\n        removeAccountInternal(getUserAccountsForCaller(), account, getCallingUid());\n    }\n\n    private boolean removeAccountInternal(UserAccounts accounts, Account account, int callingUid) {\n        boolean isChanged = false;\n        boolean userUnlocked = isLocalUnlockedUser(accounts.userId);\n        if (!userUnlocked) {\n            Slog.i(TAG, \"Removing account \" + account.toSafeString()\n                    + \" while user \" + accounts.userId\n                    + \" is still locked. CE data will be removed later\");\n        }\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                Map<String, Integer> packagesToVisibility = getRequestingPackages(account,\n                        accounts);\n                List<String> accountRemovedReceivers =\n                    getAccountRemovedReceivers(account, accounts);\n                accounts.accountsDb.beginTransaction();\n                // Set to a placeholder value, this will only be used if the database\n                // transaction succeeds.\n                long accountId = -1;\n                try {\n                    accountId = accounts.accountsDb.findDeAccountId(account);\n                    if (accountId >= 0) {\n                        isChanged = accounts.accountsDb.deleteDeAccount(accountId);\n                    }\n                    // always delete from CE table if CE storage is available\n                    // DE account could be removed while CE was locked\n                    if (userUnlocked) {\n                        long ceAccountId = accounts.accountsDb.findCeAccountId(account);\n                        if (ceAccountId >= 0) {\n                            accounts.accountsDb.deleteCeAccount(ceAccountId);\n                        }\n                    }\n                    accounts.accountsDb.setTransactionSuccessful();\n                } finally {\n                    accounts.accountsDb.endTransaction();\n                }\n                if (isChanged) {\n                    removeAccountFromCacheLocked(accounts, account);\n                    for (Entry<String, Integer> packageToVisibility : packagesToVisibility\n                            .entrySet()) {\n                        if ((packageToVisibility.getValue() == AccountManager.VISIBILITY_VISIBLE)\n                                || (packageToVisibility.getValue()\n                                    == AccountManager.VISIBILITY_USER_MANAGED_VISIBLE)) {\n                            notifyPackage(packageToVisibility.getKey(), accounts);\n                        }\n                    }\n\n                    // Only broadcast LOGIN_ACCOUNTS_CHANGED if a change occurred.\n                    sendAccountsChangedBroadcast(accounts.userId);\n                    for (String packageName : accountRemovedReceivers) {\n                        sendAccountRemovedBroadcast(account, packageName, accounts.userId);\n                    }\n                    String action = userUnlocked ? AccountsDb.DEBUG_ACTION_ACCOUNT_REMOVE\n                            : AccountsDb.DEBUG_ACTION_ACCOUNT_REMOVE_DE;\n                    logRecord(action, AccountsDb.TABLE_ACCOUNTS, accountId, accounts);\n                }\n            }\n        }\n        final long id = Binder.clearCallingIdentity();\n        try {\n            int parentUserId = accounts.userId;\n            if (canHaveProfile(parentUserId)) {\n                // Remove from any restricted profiles that are sharing this account.\n                List<UserInfo> users = getUserManager().getAliveUsers();\n                for (UserInfo user : users) {\n                    if (user.isRestricted() && parentUserId == (user.restrictedProfileParentId)) {\n                        removeSharedAccountAsUser(account, user.id, callingUid);\n                    }\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(id);\n        }\n\n        if (isChanged) {\n            synchronized (accounts.credentialsPermissionNotificationIds) {\n                for (Pair<Pair<Account, String>, Integer> key\n                        : accounts.credentialsPermissionNotificationIds.keySet()) {\n                    if (account.equals(key.first.first)\n                            && AccountManager.ACCOUNT_ACCESS_TOKEN_TYPE.equals(key.first.second)) {\n                        final int uid = (Integer) key.second;\n                        mHandler.post(() -> cancelAccountAccessRequestNotificationIfNeeded(\n                                account, uid, false));\n                    }\n                }\n            }\n        }\n\n        AccountManager.invalidateLocalAccountUserDataCaches();\n\n        return isChanged;\n    }\n\n    @Override\n    public void invalidateAuthToken(String accountType, String authToken) {\n        int callerUid = Binder.getCallingUid();\n        Objects.requireNonNull(accountType, \"accountType cannot be null\");\n        Objects.requireNonNull(authToken, \"authToken cannot be null\");\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"invalidateAuthToken: accountType \" + accountType\n                    + \", caller's uid \" + callerUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        int userId = UserHandle.getCallingUserId();\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            List<Pair<Account, String>> deletedTokens;\n            synchronized (accounts.dbLock) {\n                accounts.accountsDb.beginTransaction();\n                try {\n                    deletedTokens = invalidateAuthTokenLocked(accounts, accountType, authToken);\n                    accounts.accountsDb.setTransactionSuccessful();\n                } finally {\n                    accounts.accountsDb.endTransaction();\n                }\n                synchronized (accounts.cacheLock) {\n                    for (Pair<Account, String> tokenInfo : deletedTokens) {\n                        Account act = tokenInfo.first;\n                        String tokenType = tokenInfo.second;\n                        writeAuthTokenIntoCacheLocked(accounts, act, tokenType, null);\n                    }\n                    // wipe out cached token in memory.\n                    accounts.accountTokenCaches.remove(accountType, authToken);\n                }\n            }\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private List<Pair<Account, String>> invalidateAuthTokenLocked(UserAccounts accounts, String accountType,\n            String authToken) {\n        // TODO Move to AccountsDB\n        List<Pair<Account, String>> results = new ArrayList<>();\n        Cursor cursor = accounts.accountsDb.findAuthtokenForAllAccounts(accountType, authToken);\n\n        try {\n            while (cursor.moveToNext()) {\n                String authTokenId = cursor.getString(0);\n                String accountName = cursor.getString(1);\n                String authTokenType = cursor.getString(2);\n                accounts.accountsDb.deleteAuthToken(authTokenId);\n                results.add(Pair.create(new Account(accountName, accountType), authTokenType));\n            }\n        } finally {\n            cursor.close();\n        }\n        return results;\n    }\n\n    private void saveCachedToken(\n            UserAccounts accounts,\n            Account account,\n            String callerPkg,\n            byte[] callerSigDigest,\n            String tokenType,\n            String token,\n            long expiryMillis) {\n\n        if (account == null || tokenType == null || callerPkg == null || callerSigDigest == null) {\n            return;\n        }\n        cancelNotification(getSigninRequiredNotificationId(accounts, account),\n                UserHandle.of(accounts.userId));\n        synchronized (accounts.cacheLock) {\n            accounts.accountTokenCaches.put(\n                    account, token, tokenType, callerPkg, callerSigDigest, expiryMillis);\n        }\n    }\n\n    private boolean saveAuthTokenToDatabase(UserAccounts accounts, Account account, String type,\n            String authToken) {\n        if (account == null || type == null) {\n            return false;\n        }\n        cancelNotification(getSigninRequiredNotificationId(accounts, account),\n                UserHandle.of(accounts.userId));\n        synchronized (accounts.dbLock) {\n            accounts.accountsDb.beginTransaction();\n            boolean updateCache = false;\n            try {\n                long accountId = accounts.accountsDb.findDeAccountId(account);\n                if (accountId < 0) {\n                    return false;\n                }\n                accounts.accountsDb.deleteAuthtokensByAccountIdAndType(accountId, type);\n                if (accounts.accountsDb.insertAuthToken(accountId, type, authToken) >= 0) {\n                    accounts.accountsDb.setTransactionSuccessful();\n                    updateCache = true;\n                    return true;\n                }\n                return false;\n            } finally {\n                accounts.accountsDb.endTransaction();\n                if (updateCache) {\n                    synchronized (accounts.cacheLock) {\n                        writeAuthTokenIntoCacheLocked(accounts, account, type, authToken);\n                    }\n                }\n            }\n        }\n    }\n\n    @Override\n    public String peekAuthToken(Account account, String authTokenType) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"peekAuthToken: \" + account\n                    + \", authTokenType \" + authTokenType\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        Objects.requireNonNull(authTokenType, \"authTokenType cannot be null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot peek the authtokens associated with accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        if (!isLocalUnlockedUser(userId)) {\n            Log.w(TAG, \"Authtoken not available - user \" + userId + \" data is locked. callingUid \"\n                    + callingUid);\n            return null;\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return readAuthTokenInternal(accounts, account, authTokenType);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void setAuthToken(Account account, String authTokenType, String authToken) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"setAuthToken: \" + account\n                    + \", authTokenType \" + authTokenType\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        Objects.requireNonNull(authTokenType, \"authTokenType cannot be null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot set auth tokens associated with accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            saveAuthTokenToDatabase(accounts, account, authTokenType, authToken);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void setPassword(Account account, String password) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"setAuthToken: \" + account\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot set secrets for accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            setPasswordInternal(accounts, account, password, callingUid);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private void setPasswordInternal(UserAccounts accounts, Account account, String password,\n            int callingUid) {\n        if (account == null) {\n            return;\n        }\n        boolean isChanged = false;\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                accounts.accountsDb.beginTransaction();\n                try {\n                    final long accountId = accounts.accountsDb.findDeAccountId(account);\n                    if (accountId >= 0) {\n                        accounts.accountsDb.updateCeAccountPassword(accountId, password);\n                        accounts.accountsDb.deleteAuthTokensByAccountId(accountId);\n                        accounts.authTokenCache.remove(account);\n                        accounts.accountTokenCaches.remove(account);\n                        accounts.accountsDb.setTransactionSuccessful();\n                        // If there is an account whose password will be updated and the database\n                        // transactions succeed, then we say that a change has occured. Even if the\n                        // new password is the same as the old and there were no authtokens to\n                        // delete.\n                        isChanged = true;\n                        String action = (password == null || password.length() == 0) ?\n                                AccountsDb.DEBUG_ACTION_CLEAR_PASSWORD\n                                : AccountsDb.DEBUG_ACTION_SET_PASSWORD;\n                        logRecord(action, AccountsDb.TABLE_ACCOUNTS, accountId, accounts,\n                                callingUid);\n                    }\n                } finally {\n                    accounts.accountsDb.endTransaction();\n                    if (isChanged) {\n                        // Send LOGIN_ACCOUNTS_CHANGED only if the something changed.\n                        sendNotificationAccountUpdated(account, accounts);\n                        sendAccountsChangedBroadcast(accounts.userId);\n                    }\n                }\n            }\n        }\n    }\n\n    @Override\n    public void clearPassword(Account account) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"clearPassword: \" + account\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot clear passwords for accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            setPasswordInternal(accounts, account, null, callingUid);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void setUserData(Account account, String key, String value) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"setUserData: \" + account\n                    + \", key \" + key\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        if (key == null) throw new IllegalArgumentException(\"key is null\");\n        if (account == null) throw new IllegalArgumentException(\"account is null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(account.type, callingUid, userId)) {\n            String msg = String.format(\n                    \"uid %s cannot set user data for accounts of type: %s\",\n                    callingUid,\n                    account.type);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            if (!accountExistsCache(accounts, account)) {\n                return;\n            }\n            setUserdataInternal(accounts, account, key, value);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private boolean accountExistsCache(UserAccounts accounts, Account account) {\n        synchronized (accounts.cacheLock) {\n            if (accounts.accountCache.containsKey(account.type)) {\n                for (Account acc : accounts.accountCache.get(account.type)) {\n                    if (acc.name.equals(account.name)) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    private void setUserdataInternal(UserAccounts accounts, Account account, String key,\n            String value) {\n        synchronized (accounts.dbLock) {\n            accounts.accountsDb.beginTransaction();\n            try {\n                long accountId = accounts.accountsDb.findDeAccountId(account);\n                if (accountId < 0) {\n                    return;\n                }\n                long extrasId = accounts.accountsDb.findExtrasIdByAccountId(accountId, key);\n                if (extrasId < 0) {\n                    extrasId = accounts.accountsDb.insertExtra(accountId, key, value);\n                    if (extrasId < 0) {\n                        return;\n                    }\n                } else if (!accounts.accountsDb.updateExtra(extrasId, value)) {\n                    return;\n                }\n                accounts.accountsDb.setTransactionSuccessful();\n            } finally {\n                accounts.accountsDb.endTransaction();\n            }\n            synchronized (accounts.cacheLock) {\n                writeUserDataIntoCacheLocked(accounts, account, key, value);\n                AccountManager.invalidateLocalAccountUserDataCaches();\n            }\n        }\n    }\n\n    private void onResult(IAccountManagerResponse response, Bundle result) {\n        if (result == null) {\n            Log.e(TAG, \"the result is unexpectedly null\", new Exception());\n        }\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, getClass().getSimpleName() + \" calling onResult() on response \"\n                    + response);\n        }\n        try {\n            response.onResult(result);\n        } catch (RemoteException e) {\n            // if the caller is dead then there is no one to care about remote\n            // exceptions\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"failure while notifying response\", e);\n            }\n        }\n    }\n\n    @Override\n    public void getAuthTokenLabel(IAccountManagerResponse response, final String accountType,\n                                  final String authTokenType)\n            throws RemoteException {\n        Preconditions.checkArgument(accountType != null, \"accountType cannot be null\");\n        Preconditions.checkArgument(authTokenType != null, \"authTokenType cannot be null\");\n\n        final int callingUid = getCallingUid();\n        clearCallingIdentity();\n        if (UserHandle.getAppId(callingUid) != Process.SYSTEM_UID) {\n            throw new SecurityException(\"can only call from system\");\n        }\n        int userId = UserHandle.getUserId(callingUid);\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            new Session(accounts, response, accountType, false /* expectActivityLaunch */,\n                    false /* stripAuthTokenFromResult */,  null /* accountName */,\n                    false /* authDetailsRequired */) {\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now) + \", getAuthTokenLabel\"\n                            + \", \" + accountType\n                            + \", authTokenType \" + authTokenType;\n                }\n\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.getAuthTokenLabel(this, authTokenType);\n                }\n\n                @Override\n                public void onResult(Bundle result) {\n                    Bundle.setDefusable(result, true);\n                    if (result != null) {\n                        String label = result.getString(AccountManager.KEY_AUTH_TOKEN_LABEL);\n                        Bundle bundle = new Bundle();\n                        bundle.putString(AccountManager.KEY_AUTH_TOKEN_LABEL, label);\n                        super.onResult(bundle);\n                        return;\n                    } else {\n                        super.onResult(result);\n                    }\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void getAuthToken(\n            IAccountManagerResponse response,\n            final Account account,\n            final String authTokenType,\n            final boolean notifyOnAuthFailure,\n            final boolean expectActivityLaunch,\n            final Bundle loginOptions) {\n        Bundle.setDefusable(loginOptions, true);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"getAuthToken: \" + account\n                    + \", response \" + response\n                    + \", authTokenType \" + authTokenType\n                    + \", notifyOnAuthFailure \" + notifyOnAuthFailure\n                    + \", expectActivityLaunch \" + expectActivityLaunch\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Preconditions.checkArgument(response != null, \"response cannot be null\");\n        try {\n            if (account == null) {\n                Slog.w(TAG, \"getAuthToken called with null account\");\n                response.onError(AccountManager.ERROR_CODE_BAD_ARGUMENTS, \"account is null\");\n                return;\n            }\n            if (authTokenType == null) {\n                Slog.w(TAG, \"getAuthToken called with null authTokenType\");\n                response.onError(AccountManager.ERROR_CODE_BAD_ARGUMENTS, \"authTokenType is null\");\n                return;\n            }\n        } catch (RemoteException e) {\n            Slog.w(TAG, \"Failed to report error back to the client.\" + e);\n            return;\n        }\n        int userId = UserHandle.getCallingUserId();\n        final long ident = Binder.clearCallingIdentity();\n        final UserAccounts accounts;\n        final RegisteredServicesCache.ServiceInfo<AuthenticatorDescription> authenticatorInfo;\n        try {\n            accounts = getUserAccounts(userId);\n            authenticatorInfo = mAuthenticatorCache.getServiceInfo(\n                    AuthenticatorDescription.newKey(account.type), accounts.userId);\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n\n        final boolean customTokens =\n                authenticatorInfo != null && authenticatorInfo.type.customTokens;\n\n        // skip the check if customTokens\n        final int callerUid = Binder.getCallingUid();\n        final boolean permissionGranted =\n                customTokens || permissionIsGranted(account, authTokenType, callerUid, userId);\n\n        // Get the calling package. We will use it for the purpose of caching.\n        final String callerPkg = loginOptions.getString(AccountManager.KEY_ANDROID_PACKAGE_NAME);\n        String[] callerOwnedPackageNames;\n        final long ident2 = Binder.clearCallingIdentity();\n        try {\n            callerOwnedPackageNames = mPackageManager.getPackagesForUid(callerUid);\n        } finally {\n            Binder.restoreCallingIdentity(ident2);\n        }\n        if (callerPkg == null || callerOwnedPackageNames == null\n                || !ArrayUtils.contains(callerOwnedPackageNames, callerPkg)) {\n            String msg = String.format(\n                    \"Uid %s is attempting to illegally masquerade as package %s!\",\n                    callerUid,\n                    callerPkg);\n            throw new SecurityException(msg);\n        }\n\n        // let authenticator know the identity of the caller\n        loginOptions.putInt(AccountManager.KEY_CALLER_UID, callerUid);\n        loginOptions.putInt(AccountManager.KEY_CALLER_PID, Binder.getCallingPid());\n\n        if (notifyOnAuthFailure) {\n            loginOptions.putBoolean(AccountManager.KEY_NOTIFY_ON_FAILURE, true);\n        }\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            // Distill the caller's package signatures into a single digest.\n            final byte[] callerPkgSigDigest = calculatePackageSignatureDigest(callerPkg);\n\n            // if the caller has permission, do the peek. otherwise go the more expensive\n            // route of starting a Session\n            if (!customTokens && permissionGranted) {\n                String authToken = readAuthTokenInternal(accounts, account, authTokenType);\n                if (authToken != null) {\n                    logGetAuthTokenMetrics(callerPkg, account.type);\n                    Bundle result = new Bundle();\n                    result.putString(AccountManager.KEY_AUTHTOKEN, authToken);\n                    result.putString(AccountManager.KEY_ACCOUNT_NAME, account.name);\n                    result.putString(AccountManager.KEY_ACCOUNT_TYPE, account.type);\n                    onResult(response, result);\n                    return;\n                }\n            }\n\n            if (customTokens) {\n                /*\n                 * Look up tokens in the new cache only if the loginOptions don't have parameters\n                 * outside of those expected to be injected by the AccountManager, e.g.\n                 * ANDORID_PACKAGE_NAME.\n                 */\n                String token = readCachedTokenInternal(\n                        accounts,\n                        account,\n                        authTokenType,\n                        callerPkg,\n                        callerPkgSigDigest);\n                if (token != null) {\n                    logGetAuthTokenMetrics(callerPkg, account.type);\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, \"getAuthToken: cache hit ofr custom token authenticator.\");\n                    }\n                    Bundle result = new Bundle();\n                    result.putString(AccountManager.KEY_AUTHTOKEN, token);\n                    result.putString(AccountManager.KEY_ACCOUNT_NAME, account.name);\n                    result.putString(AccountManager.KEY_ACCOUNT_TYPE, account.type);\n                    onResult(response, result);\n                    return;\n                }\n            }\n\n            new Session(\n                    accounts,\n                    response,\n                    account.type,\n                    expectActivityLaunch,\n                    false /* stripAuthTokenFromResult */,\n                    account.name,\n                    false /* authDetailsRequired */) {\n                @Override\n                protected String toDebugString(long now) {\n                    if (loginOptions != null) loginOptions.keySet();\n                    return super.toDebugString(now) + \", getAuthToken\"\n                            + \", \" + account.toSafeString()\n                            + \", authTokenType \" + authTokenType\n                            + \", loginOptions \" + loginOptions\n                            + \", notifyOnAuthFailure \" + notifyOnAuthFailure;\n                }\n\n                @Override\n                public void run() throws RemoteException {\n                    // If the caller doesn't have permission then create and return the\n                    // \"grant permission\" intent instead of the \"getAuthToken\" intent.\n                    if (!permissionGranted) {\n                        mAuthenticator.getAuthTokenLabel(this, authTokenType);\n                    } else {\n                        mAuthenticator.getAuthToken(this, account, authTokenType, loginOptions);\n                        logGetAuthTokenMetrics(callerPkg, account.type);\n                    }\n                }\n\n                @Override\n                public void onResult(Bundle result) {\n                    Bundle.setDefusable(result, true);\n                    if (result != null) {\n                        if (result.containsKey(AccountManager.KEY_AUTH_TOKEN_LABEL)) {\n                            Intent intent = newGrantCredentialsPermissionIntent(\n                                    account,\n                                    null,\n                                    callerUid,\n                                    new AccountAuthenticatorResponse(this),\n                                    authTokenType,\n                                    true);\n                            Bundle bundle = new Bundle();\n                            bundle.putParcelable(AccountManager.KEY_INTENT, intent);\n                            onResult(bundle);\n                            return;\n                        }\n                        String authToken = result.getString(AccountManager.KEY_AUTHTOKEN);\n                        if (authToken != null) {\n                            String name = result.getString(AccountManager.KEY_ACCOUNT_NAME);\n                            String type = result.getString(AccountManager.KEY_ACCOUNT_TYPE);\n                            if (TextUtils.isEmpty(type) || TextUtils.isEmpty(name)) {\n                                onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                                        \"the type and name should not be empty\");\n                                return;\n                            }\n                            Account resultAccount = new Account(name, type);\n                            if (!customTokens) {\n                                saveAuthTokenToDatabase(\n                                        mAccounts,\n                                        resultAccount,\n                                        authTokenType,\n                                        authToken);\n                            }\n                            long expiryMillis = result.getLong(\n                                    AbstractAccountAuthenticator.KEY_CUSTOM_TOKEN_EXPIRY, 0L);\n                            if (customTokens\n                                    && expiryMillis > System.currentTimeMillis()) {\n                                saveCachedToken(\n                                        mAccounts,\n                                        account,\n                                        callerPkg,\n                                        callerPkgSigDigest,\n                                        authTokenType,\n                                        authToken,\n                                        expiryMillis);\n                            }\n                        }\n\n                        Intent intent = result.getParcelable(AccountManager.KEY_INTENT);\n                        if (intent != null && notifyOnAuthFailure && !customTokens) {\n                            /*\n                             * Make sure that the supplied intent is owned by the authenticator\n                             * giving it to the system. Otherwise a malicious authenticator could\n                             * have users launching arbitrary activities by tricking users to\n                             * interact with malicious notifications.\n                             */\n                            if (!checkKeyIntent(\n                                    Binder.getCallingUid(),\n                                    result)) {\n                                onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                                        \"invalid intent in bundle returned\");\n                                return;\n                            }\n                            doNotification(\n                                    mAccounts,\n                                    account,\n                                    result.getString(AccountManager.KEY_AUTH_FAILED_MESSAGE),\n                                    intent, \"android\", accounts.userId);\n                        }\n                    }\n                    super.onResult(result);\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private void logGetAuthTokenMetrics(final String callerPackage, String accountType) {\n        // Although this is not a 'device policy' API, enterprise is the current use case.\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.GET_ACCOUNT_AUTH_TOKEN)\n                .setStrings(\n                        TextUtils.emptyIfNull(callerPackage),\n                        TextUtils.emptyIfNull(accountType))\n                .write();\n    }\n\n    private byte[] calculatePackageSignatureDigest(String callerPkg) {\n        MessageDigest digester;\n        try {\n            digester = MessageDigest.getInstance(\"SHA-256\");\n            PackageInfo pkgInfo = mPackageManager.getPackageInfo(\n                    callerPkg, PackageManager.GET_SIGNATURES);\n            for (Signature sig : pkgInfo.signatures) {\n                digester.update(sig.toByteArray());\n            }\n        } catch (NoSuchAlgorithmException x) {\n            Log.wtf(TAG, \"SHA-256 should be available\", x);\n            digester = null;\n        } catch (NameNotFoundException e) {\n            Log.w(TAG, \"Could not find packageinfo for: \" + callerPkg);\n            digester = null;\n        }\n        return (digester == null) ? null : digester.digest();\n    }\n\n    private void createNoCredentialsPermissionNotification(Account account, Intent intent,\n            String packageName, int userId) {\n        int uid = intent.getIntExtra(\n                GrantCredentialsPermissionActivity.EXTRAS_REQUESTING_UID, -1);\n        String authTokenType = intent.getStringExtra(\n                GrantCredentialsPermissionActivity.EXTRAS_AUTH_TOKEN_TYPE);\n        final String titleAndSubtitle =\n                mContext.getString(R.string.permission_request_notification_for_app_with_subtitle,\n                getApplicationLabel(packageName), account.name);\n        final int index = titleAndSubtitle.indexOf('\\n');\n        String title = titleAndSubtitle;\n        String subtitle = \"\";\n        if (index > 0) {\n            title = titleAndSubtitle.substring(0, index);\n            subtitle = titleAndSubtitle.substring(index + 1);\n        }\n        UserHandle user = UserHandle.of(userId);\n        Context contextForUser = getContextForUser(user);\n        Notification n =\n                new Notification.Builder(contextForUser, SystemNotificationChannels.ACCOUNT)\n                    .setSmallIcon(android.R.drawable.stat_sys_warning)\n                    .setWhen(0)\n                    .setColor(contextForUser.getColor(\n                            com.android.internal.R.color.system_notification_accent_color))\n                    .setContentTitle(title)\n                    .setContentText(subtitle)\n                    .setContentIntent(PendingIntent.getActivityAsUser(mContext, 0, intent,\n                            PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_IMMUTABLE,\n                            null, user))\n                    .build();\n        installNotification(getCredentialPermissionNotificationId(\n                account, authTokenType, uid), n, \"android\", user.getIdentifier());\n    }\n\n    private String getApplicationLabel(String packageName) {\n        try {\n            return mPackageManager.getApplicationLabel(\n                    mPackageManager.getApplicationInfo(packageName, 0)).toString();\n        } catch (PackageManager.NameNotFoundException e) {\n            return packageName;\n        }\n    }\n\n    private Intent newGrantCredentialsPermissionIntent(Account account, String packageName,\n            int uid, AccountAuthenticatorResponse response, String authTokenType,\n            boolean startInNewTask) {\n\n        Intent intent = new Intent(mContext, GrantCredentialsPermissionActivity.class);\n\n        if (startInNewTask) {\n            // See FLAG_ACTIVITY_NEW_TASK docs for limitations and benefits of the flag.\n            // Since it was set in Eclair+ we can't change it without breaking apps using\n            // the intent from a non-Activity context. This is the default behavior.\n            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        }\n        intent.addCategory(getCredentialPermissionNotificationId(account,\n                authTokenType, uid).mTag + (packageName != null ? packageName : \"\"));\n        intent.putExtra(GrantCredentialsPermissionActivity.EXTRAS_ACCOUNT, account);\n        intent.putExtra(GrantCredentialsPermissionActivity.EXTRAS_AUTH_TOKEN_TYPE, authTokenType);\n        intent.putExtra(GrantCredentialsPermissionActivity.EXTRAS_RESPONSE, response);\n        intent.putExtra(GrantCredentialsPermissionActivity.EXTRAS_REQUESTING_UID, uid);\n\n        return intent;\n    }\n\n    private NotificationId getCredentialPermissionNotificationId(Account account,\n            String authTokenType, int uid) {\n        NotificationId nId;\n        UserAccounts accounts = getUserAccounts(UserHandle.getUserId(uid));\n        synchronized (accounts.credentialsPermissionNotificationIds) {\n            final Pair<Pair<Account, String>, Integer> key =\n                    new Pair<Pair<Account, String>, Integer>(\n                            new Pair<Account, String>(account, authTokenType), uid);\n            nId = accounts.credentialsPermissionNotificationIds.get(key);\n            if (nId == null) {\n                String tag = TAG + \":\" + SystemMessage.NOTE_ACCOUNT_CREDENTIAL_PERMISSION\n                        + \":\" + account.hashCode() + \":\" + authTokenType.hashCode() + \":\" + uid;\n                int id = SystemMessage.NOTE_ACCOUNT_CREDENTIAL_PERMISSION;\n                nId = new NotificationId(tag, id);\n                accounts.credentialsPermissionNotificationIds.put(key, nId);\n            }\n        }\n        return nId;\n    }\n\n    private NotificationId getSigninRequiredNotificationId(UserAccounts accounts, Account account) {\n        NotificationId nId;\n        synchronized (accounts.signinRequiredNotificationIds) {\n            nId = accounts.signinRequiredNotificationIds.get(account);\n            if (nId == null) {\n                String tag = TAG + \":\" + SystemMessage.NOTE_ACCOUNT_REQUIRE_SIGNIN\n                        + \":\" + account.hashCode();\n                int id = SystemMessage.NOTE_ACCOUNT_REQUIRE_SIGNIN;\n                nId = new NotificationId(tag, id);\n                accounts.signinRequiredNotificationIds.put(account, nId);\n            }\n        }\n        return nId;\n    }\n\n    @Override\n    public void addAccount(final IAccountManagerResponse response, final String accountType,\n            final String authTokenType, final String[] requiredFeatures,\n            final boolean expectActivityLaunch, final Bundle optionsIn) {\n        Bundle.setDefusable(optionsIn, true);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"addAccount: accountType \" + accountType\n                    + \", response \" + response\n                    + \", authTokenType \" + authTokenType\n                    + \", requiredFeatures \" + Arrays.toString(requiredFeatures)\n                    + \", expectActivityLaunch \" + expectActivityLaunch\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        if (response == null) throw new IllegalArgumentException(\"response is null\");\n        if (accountType == null) throw new IllegalArgumentException(\"accountType is null\");\n\n        // Is user disallowed from modifying accounts?\n        final int uid = Binder.getCallingUid();\n        final int userId = UserHandle.getUserId(uid);\n        if (!canUserModifyAccounts(userId, uid)) {\n            try {\n                response.onError(AccountManager.ERROR_CODE_USER_RESTRICTED,\n                        \"User is not allowed to add an account!\");\n            } catch (RemoteException re) {\n            }\n            showCantAddAccount(AccountManager.ERROR_CODE_USER_RESTRICTED, userId);\n            return;\n        }\n        if (!canUserModifyAccountsForType(userId, accountType, uid)) {\n            try {\n                response.onError(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                        \"User cannot modify accounts of this type (policy).\");\n            } catch (RemoteException re) {\n            }\n            showCantAddAccount(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                    userId);\n            return;\n        }\n        addAccountAndLogMetrics(response, accountType, authTokenType, requiredFeatures,\n                expectActivityLaunch, optionsIn, userId);\n    }\n\n    @Override\n    public void addAccountAsUser(final IAccountManagerResponse response, final String accountType,\n            final String authTokenType, final String[] requiredFeatures,\n            final boolean expectActivityLaunch, final Bundle optionsIn, int userId) {\n        Bundle.setDefusable(optionsIn, true);\n        int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"addAccount: accountType \" + accountType\n                    + \", response \" + response\n                    + \", authTokenType \" + authTokenType\n                    + \", requiredFeatures \" + Arrays.toString(requiredFeatures)\n                    + \", expectActivityLaunch \" + expectActivityLaunch\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid()\n                    + \", for user id \" + userId);\n        }\n        Preconditions.checkArgument(response != null, \"response cannot be null\");\n        Preconditions.checkArgument(accountType != null, \"accountType cannot be null\");\n        // Only allow the system process to add accounts of other users\n        if (isCrossUser(callingUid, userId)) {\n            throw new SecurityException(\n                    String.format(\n                            \"User %s trying to add account for %s\" ,\n                            UserHandle.getCallingUserId(),\n                            userId));\n        }\n\n        // Is user disallowed from modifying accounts?\n        if (!canUserModifyAccounts(userId, callingUid)) {\n            try {\n                response.onError(AccountManager.ERROR_CODE_USER_RESTRICTED,\n                        \"User is not allowed to add an account!\");\n            } catch (RemoteException re) {\n            }\n            showCantAddAccount(AccountManager.ERROR_CODE_USER_RESTRICTED, userId);\n            return;\n        }\n        if (!canUserModifyAccountsForType(userId, accountType, callingUid)) {\n            try {\n                response.onError(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                        \"User cannot modify accounts of this type (policy).\");\n            } catch (RemoteException re) {\n            }\n            showCantAddAccount(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                    userId);\n            return;\n        }\n        addAccountAndLogMetrics(response, accountType, authTokenType, requiredFeatures,\n                expectActivityLaunch, optionsIn, userId);\n    }\n\n    private void addAccountAndLogMetrics(\n            IAccountManagerResponse response, String accountType,\n            String authTokenType, String[] requiredFeatures,\n            boolean expectActivityLaunch, Bundle optionsIn, int userId) {\n        final int pid = Binder.getCallingPid();\n        final int uid = Binder.getCallingUid();\n        final Bundle options = (optionsIn == null) ? new Bundle() : optionsIn;\n        options.putInt(AccountManager.KEY_CALLER_UID, uid);\n        options.putInt(AccountManager.KEY_CALLER_PID, pid);\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            logRecordWithUid(\n                    accounts, AccountsDb.DEBUG_ACTION_CALLED_ACCOUNT_ADD, AccountsDb.TABLE_ACCOUNTS,\n                    uid);\n            new Session(accounts, response, accountType, expectActivityLaunch,\n                    true /* stripAuthTokenFromResult */, null /* accountName */,\n                    false /* authDetailsRequired */, true /* updateLastAuthenticationTime */) {\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.addAccount(\n                            this, mAccountType, authTokenType, requiredFeatures, options);\n                    String callerPackage = options.getString(\n                            AccountManager.KEY_ANDROID_PACKAGE_NAME);\n                    logAddAccountMetrics(\n                            callerPackage, accountType, requiredFeatures, authTokenType);\n                }\n\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now) + \", addAccount\"\n                            + \", accountType \" + accountType\n                            + \", requiredFeatures \"\n                            + (requiredFeatures != null\n                            ? TextUtils.join(\",\", requiredFeatures)\n                            : null);\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private void logAddAccountMetrics(\n            String callerPackage, String accountType, String[] requiredFeatures,\n            String authTokenType) {\n        // Although this is not a 'device policy' API, enterprise is the current use case.\n        DevicePolicyEventLogger\n                .createEvent(DevicePolicyEnums.ADD_ACCOUNT)\n                .setStrings(\n                        TextUtils.emptyIfNull(accountType),\n                        TextUtils.emptyIfNull(callerPackage),\n                        TextUtils.emptyIfNull(authTokenType),\n                        requiredFeatures == null\n                                ? \"\"\n                                : TextUtils.join(\";\", requiredFeatures))\n                .write();\n    }\n\n    @Override\n    public void startAddAccountSession(\n            final IAccountManagerResponse response,\n            final String accountType,\n            final String authTokenType,\n            final String[] requiredFeatures,\n            final boolean expectActivityLaunch,\n            final Bundle optionsIn) {\n        Bundle.setDefusable(optionsIn, true);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG,\n                    \"startAddAccountSession: accountType \" + accountType\n                    + \", response \" + response\n                    + \", authTokenType \" + authTokenType\n                    + \", requiredFeatures \" + Arrays.toString(requiredFeatures)\n                    + \", expectActivityLaunch \" + expectActivityLaunch\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        Preconditions.checkArgument(response != null, \"response cannot be null\");\n        Preconditions.checkArgument(accountType != null, \"accountType cannot be null\");\n\n        final int uid = Binder.getCallingUid();\n        final int userId = UserHandle.getUserId(uid);\n        if (!canUserModifyAccounts(userId, uid)) {\n            try {\n                response.onError(AccountManager.ERROR_CODE_USER_RESTRICTED,\n                        \"User is not allowed to add an account!\");\n            } catch (RemoteException re) {\n            }\n            showCantAddAccount(AccountManager.ERROR_CODE_USER_RESTRICTED, userId);\n            return;\n        }\n        if (!canUserModifyAccountsForType(userId, accountType, uid)) {\n            try {\n                response.onError(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                        \"User cannot modify accounts of this type (policy).\");\n            } catch (RemoteException re) {\n            }\n            showCantAddAccount(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                    userId);\n            return;\n        }\n        final int pid = Binder.getCallingPid();\n        final Bundle options = (optionsIn == null) ? new Bundle() : optionsIn;\n        options.putInt(AccountManager.KEY_CALLER_UID, uid);\n        options.putInt(AccountManager.KEY_CALLER_PID, pid);\n\n        // Check to see if the Password should be included to the caller.\n        String callerPkg = options.getString(AccountManager.KEY_ANDROID_PACKAGE_NAME);\n        boolean isPasswordForwardingAllowed = checkPermissionAndNote(\n                callerPkg, uid, Manifest.permission.GET_PASSWORD);\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            logRecordWithUid(accounts, AccountsDb.DEBUG_ACTION_CALLED_START_ACCOUNT_ADD,\n                    AccountsDb.TABLE_ACCOUNTS, uid);\n            new StartAccountSession(\n                    accounts,\n                    response,\n                    accountType,\n                    expectActivityLaunch,\n                    null /* accountName */,\n                    false /* authDetailsRequired */,\n                    true /* updateLastAuthenticationTime */,\n                    isPasswordForwardingAllowed) {\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.startAddAccountSession(this, mAccountType, authTokenType,\n                            requiredFeatures, options);\n                    logAddAccountMetrics(callerPkg, accountType, requiredFeatures, authTokenType);\n                }\n\n                @Override\n                protected String toDebugString(long now) {\n                    String requiredFeaturesStr = TextUtils.join(\",\", requiredFeatures);\n                    return super.toDebugString(now) + \", startAddAccountSession\" + \", accountType \"\n                            + accountType + \", requiredFeatures \"\n                            + (requiredFeatures != null ? requiredFeaturesStr : null);\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    /** Session that will encrypt the KEY_ACCOUNT_SESSION_BUNDLE in result. */\n    private abstract class StartAccountSession extends Session {\n\n        private final boolean mIsPasswordForwardingAllowed;\n\n        public StartAccountSession(\n                UserAccounts accounts,\n                IAccountManagerResponse response,\n                String accountType,\n                boolean expectActivityLaunch,\n                String accountName,\n                boolean authDetailsRequired,\n                boolean updateLastAuthenticationTime,\n                boolean isPasswordForwardingAllowed) {\n            super(accounts, response, accountType, expectActivityLaunch,\n                    true /* stripAuthTokenFromResult */, accountName, authDetailsRequired,\n                    updateLastAuthenticationTime);\n            mIsPasswordForwardingAllowed = isPasswordForwardingAllowed;\n        }\n\n        @Override\n        public void onResult(Bundle result) {\n            Bundle.setDefusable(result, true);\n            mNumResults++;\n            Intent intent = null;\n            if (result != null) {\n                if (!checkKeyIntent(\n                        Binder.getCallingUid(),\n                        result)) {\n                    onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                            \"invalid intent in bundle returned\");\n                    return;\n                }\n            }\n            IAccountManagerResponse response;\n            if (mExpectActivityLaunch && result != null\n                    && result.containsKey(AccountManager.KEY_INTENT)) {\n                response = mResponse;\n            } else {\n                response = getResponseAndClose();\n            }\n            if (response == null) {\n                return;\n            }\n            if (result == null) {\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.v(TAG, getClass().getSimpleName() + \" calling onError() on response \"\n                            + response);\n                }\n                sendErrorResponse(response, AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                        \"null bundle returned\");\n                return;\n            }\n\n            if ((result.getInt(AccountManager.KEY_ERROR_CODE, -1) > 0) && (intent == null)) {\n                // All AccountManager error codes are greater\n                // than 0\n                sendErrorResponse(response, result.getInt(AccountManager.KEY_ERROR_CODE),\n                        result.getString(AccountManager.KEY_ERROR_MESSAGE));\n                return;\n            }\n\n            // Omit passwords if the caller isn't permitted to see them.\n            if (!mIsPasswordForwardingAllowed) {\n                result.remove(AccountManager.KEY_PASSWORD);\n            }\n\n            // Strip auth token from result.\n            result.remove(AccountManager.KEY_AUTHTOKEN);\n            if (!checkKeyIntent(Binder.getCallingUid(), result)) {\n                onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                        \"invalid intent in bundle returned\");\n                return;\n            }\n\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG,\n                        getClass().getSimpleName() + \" calling onResult() on response \" + response);\n            }\n\n            // Get the session bundle created by authenticator. The\n            // bundle contains data necessary for finishing the session\n            // later. The session bundle will be encrypted here and\n            // decrypted later when trying to finish the session.\n            Bundle sessionBundle = result.getBundle(AccountManager.KEY_ACCOUNT_SESSION_BUNDLE);\n            if (sessionBundle != null) {\n                String accountType = sessionBundle.getString(AccountManager.KEY_ACCOUNT_TYPE);\n                if (TextUtils.isEmpty(accountType)\n                        || !mAccountType.equalsIgnoreCase(accountType)) {\n                    Log.w(TAG, \"Account type in session bundle doesn't match request.\");\n                }\n                // Add accountType info to session bundle. This will\n                // override any value set by authenticator.\n                sessionBundle.putString(AccountManager.KEY_ACCOUNT_TYPE, mAccountType);\n\n                // Encrypt session bundle before returning to caller.\n                try {\n                    CryptoHelper cryptoHelper = CryptoHelper.getInstance();\n                    Bundle encryptedBundle = cryptoHelper.encryptBundle(sessionBundle);\n                    result.putBundle(AccountManager.KEY_ACCOUNT_SESSION_BUNDLE, encryptedBundle);\n                } catch (GeneralSecurityException e) {\n                    if (Log.isLoggable(TAG, Log.DEBUG)) {\n                        Log.v(TAG, \"Failed to encrypt session bundle!\", e);\n                    }\n                    sendErrorResponse(response, AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                            \"failed to encrypt session bundle\");\n                    return;\n                }\n            }\n\n            sendResponse(response, result);\n        }\n    }\n\n    @Override\n    public void finishSessionAsUser(IAccountManagerResponse response,\n            @NonNull Bundle sessionBundle,\n            boolean expectActivityLaunch,\n            Bundle appInfo,\n            int userId) {\n        Bundle.setDefusable(sessionBundle, true);\n        int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG,\n                    \"finishSession: response \"+ response\n                            + \", expectActivityLaunch \" + expectActivityLaunch\n                            + \", caller's uid \" + callingUid\n                            + \", caller's user id \" + UserHandle.getCallingUserId()\n                            + \", pid \" + Binder.getCallingPid()\n                            + \", for user id \" + userId);\n        }\n        Preconditions.checkArgument(response != null, \"response cannot be null\");\n        // Session bundle is the encrypted bundle of the original bundle created by authenticator.\n        // Account type is added to it before encryption.\n        if (sessionBundle == null || sessionBundle.size() == 0) {\n            throw new IllegalArgumentException(\"sessionBundle is empty\");\n        }\n\n        // Only allow the system process to finish session for other users.\n        if (isCrossUser(callingUid, userId)) {\n            throw new SecurityException(\n                    String.format(\n                            \"User %s trying to finish session for %s without cross user permission\",\n                            UserHandle.getCallingUserId(),\n                            userId));\n        }\n\n        if (!canUserModifyAccounts(userId, callingUid)) {\n            sendErrorResponse(response,\n                    AccountManager.ERROR_CODE_USER_RESTRICTED,\n                    \"User is not allowed to add an account!\");\n            showCantAddAccount(AccountManager.ERROR_CODE_USER_RESTRICTED, userId);\n            return;\n        }\n\n        final int pid = Binder.getCallingPid();\n        final Bundle decryptedBundle;\n        final String accountType;\n        // First decrypt session bundle to get account type for checking permission.\n        try {\n            CryptoHelper cryptoHelper = CryptoHelper.getInstance();\n            decryptedBundle = cryptoHelper.decryptBundle(sessionBundle);\n            if (decryptedBundle == null) {\n                sendErrorResponse(\n                        response,\n                        AccountManager.ERROR_CODE_BAD_REQUEST,\n                        \"failed to decrypt session bundle\");\n                return;\n            }\n            accountType = decryptedBundle.getString(AccountManager.KEY_ACCOUNT_TYPE);\n            // Account type cannot be null. This should not happen if session bundle was created\n            // properly by #StartAccountSession.\n            if (TextUtils.isEmpty(accountType)) {\n                sendErrorResponse(\n                        response,\n                        AccountManager.ERROR_CODE_BAD_ARGUMENTS,\n                        \"accountType is empty\");\n                return;\n            }\n\n            // If by any chances, decryptedBundle contains colliding keys with\n            // system info\n            // such as AccountManager.KEY_ANDROID_PACKAGE_NAME required by the add account flow or\n            // update credentials flow, we should replace with the new values of the current call.\n            if (appInfo != null) {\n                decryptedBundle.putAll(appInfo);\n            }\n\n            // Add info that may be used by add account or update credentials flow.\n            decryptedBundle.putInt(AccountManager.KEY_CALLER_UID, callingUid);\n            decryptedBundle.putInt(AccountManager.KEY_CALLER_PID, pid);\n        } catch (GeneralSecurityException e) {\n            if (Log.isLoggable(TAG, Log.DEBUG)) {\n                Log.v(TAG, \"Failed to decrypt session bundle!\", e);\n            }\n            sendErrorResponse(\n                    response,\n                    AccountManager.ERROR_CODE_BAD_REQUEST,\n                    \"failed to decrypt session bundle\");\n            return;\n        }\n\n        if (!canUserModifyAccountsForType(userId, accountType, callingUid)) {\n            sendErrorResponse(\n                    response,\n                    AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                    \"User cannot modify accounts of this type (policy).\");\n            showCantAddAccount(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,\n                    userId);\n            return;\n        }\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            logRecordWithUid(\n                    accounts,\n                    AccountsDb.DEBUG_ACTION_CALLED_ACCOUNT_SESSION_FINISH,\n                    AccountsDb.TABLE_ACCOUNTS,\n                    callingUid);\n            new Session(\n                    accounts,\n                    response,\n                    accountType,\n                    expectActivityLaunch,\n                    true /* stripAuthTokenFromResult */,\n                    null /* accountName */,\n                    false /* authDetailsRequired */,\n                    true /* updateLastAuthenticationTime */) {\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.finishSession(this, mAccountType, decryptedBundle);\n                }\n\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now)\n                            + \", finishSession\"\n                            + \", accountType \" + accountType;\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private void showCantAddAccount(int errorCode, int userId) {\n        final DevicePolicyManagerInternal dpmi =\n                LocalServices.getService(DevicePolicyManagerInternal.class);\n        Intent intent = null;\n        if (dpmi == null) {\n            intent = getDefaultCantAddAccountIntent(errorCode);\n        } else if (errorCode == AccountManager.ERROR_CODE_USER_RESTRICTED) {\n            intent = dpmi.createUserRestrictionSupportIntent(userId,\n                    UserManager.DISALLOW_MODIFY_ACCOUNTS);\n        } else if (errorCode == AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE) {\n            intent = dpmi.createShowAdminSupportIntent(userId, false);\n        }\n        if (intent == null) {\n            intent = getDefaultCantAddAccountIntent(errorCode);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            mContext.startActivityAsUser(intent, new UserHandle(userId));\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    /**\n     * Called when we don't know precisely who is preventing us from adding an account.\n     */\n    private Intent getDefaultCantAddAccountIntent(int errorCode) {\n        Intent cantAddAccount = new Intent(mContext, CantAddAccountActivity.class);\n        cantAddAccount.putExtra(CantAddAccountActivity.EXTRA_ERROR_CODE, errorCode);\n        cantAddAccount.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        return cantAddAccount;\n    }\n\n    @Override\n    public void confirmCredentialsAsUser(\n            IAccountManagerResponse response,\n            final Account account,\n            final Bundle options,\n            final boolean expectActivityLaunch,\n            int userId) {\n        Bundle.setDefusable(options, true);\n        int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"confirmCredentials: \" + account\n                    + \", response \" + response\n                    + \", expectActivityLaunch \" + expectActivityLaunch\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        // Only allow the system process to read accounts of other users\n        if (isCrossUser(callingUid, userId)) {\n            throw new SecurityException(\n                    String.format(\n                            \"User %s trying to confirm account credentials for %s\" ,\n                            UserHandle.getCallingUserId(),\n                            userId));\n        }\n        if (response == null) throw new IllegalArgumentException(\"response is null\");\n        if (account == null) throw new IllegalArgumentException(\"account is null\");\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            new Session(accounts, response, account.type, expectActivityLaunch,\n                    true /* stripAuthTokenFromResult */, account.name,\n                    true /* authDetailsRequired */, true /* updateLastAuthenticatedTime */) {\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.confirmCredentials(this, account, options);\n                }\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now) + \", confirmCredentials\"\n                            + \", \" + account.toSafeString();\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void updateCredentials(IAccountManagerResponse response, final Account account,\n            final String authTokenType, final boolean expectActivityLaunch,\n            final Bundle loginOptions) {\n        Bundle.setDefusable(loginOptions, true);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"updateCredentials: \" + account\n                    + \", response \" + response\n                    + \", authTokenType \" + authTokenType\n                    + \", expectActivityLaunch \" + expectActivityLaunch\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        if (response == null) throw new IllegalArgumentException(\"response is null\");\n        if (account == null) throw new IllegalArgumentException(\"account is null\");\n        int userId = UserHandle.getCallingUserId();\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            new Session(accounts, response, account.type, expectActivityLaunch,\n                    true /* stripAuthTokenFromResult */, account.name,\n                    false /* authDetailsRequired */, true /* updateLastCredentialTime */) {\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.updateCredentials(this, account, authTokenType, loginOptions);\n                }\n                @Override\n                protected String toDebugString(long now) {\n                    if (loginOptions != null) loginOptions.keySet();\n                    return super.toDebugString(now) + \", updateCredentials\"\n                            + \", \" + account.toSafeString()\n                            + \", authTokenType \" + authTokenType\n                            + \", loginOptions \" + loginOptions;\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void startUpdateCredentialsSession(\n            IAccountManagerResponse response,\n            final Account account,\n            final String authTokenType,\n            final boolean expectActivityLaunch,\n            final Bundle loginOptions) {\n        Bundle.setDefusable(loginOptions, true);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG,\n                    \"startUpdateCredentialsSession: \" + account + \", response \" + response\n                            + \", authTokenType \" + authTokenType + \", expectActivityLaunch \"\n                            + expectActivityLaunch + \", caller's uid \" + Binder.getCallingUid()\n                            + \", pid \" + Binder.getCallingPid());\n        }\n        if (response == null) {\n            throw new IllegalArgumentException(\"response is null\");\n        }\n        if (account == null) {\n            throw new IllegalArgumentException(\"account is null\");\n        }\n\n        final int uid = Binder.getCallingUid();\n        int userId = UserHandle.getCallingUserId();\n\n        // Check to see if the Password should be included to the caller.\n        String callerPkg = loginOptions.getString(AccountManager.KEY_ANDROID_PACKAGE_NAME);\n        boolean isPasswordForwardingAllowed = checkPermissionAndNote(\n                callerPkg, uid, Manifest.permission.GET_PASSWORD);\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            new StartAccountSession(\n                    accounts,\n                    response,\n                    account.type,\n                    expectActivityLaunch,\n                    account.name,\n                    false /* authDetailsRequired */,\n                    true /* updateLastCredentialTime */,\n                    isPasswordForwardingAllowed) {\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.startUpdateCredentialsSession(this, account, authTokenType,\n                            loginOptions);\n                }\n\n                @Override\n                protected String toDebugString(long now) {\n                    if (loginOptions != null)\n                        loginOptions.keySet();\n                    return super.toDebugString(now)\n                            + \", startUpdateCredentialsSession\"\n                            + \", \" + account.toSafeString()\n                            + \", authTokenType \" + authTokenType\n                            + \", loginOptions \" + loginOptions;\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void isCredentialsUpdateSuggested(\n            IAccountManagerResponse response,\n            final Account account,\n            final String statusToken) {\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG,\n                    \"isCredentialsUpdateSuggested: \" + account + \", response \" + response\n                            + \", caller's uid \" + Binder.getCallingUid()\n                            + \", pid \" + Binder.getCallingPid());\n        }\n        if (response == null) {\n            throw new IllegalArgumentException(\"response is null\");\n        }\n        if (account == null) {\n            throw new IllegalArgumentException(\"account is null\");\n        }\n        if (TextUtils.isEmpty(statusToken)) {\n            throw new IllegalArgumentException(\"status token is empty\");\n        }\n\n        int usrId = UserHandle.getCallingUserId();\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(usrId);\n            new Session(accounts, response, account.type, false /* expectActivityLaunch */,\n                    false /* stripAuthTokenFromResult */, account.name,\n                    false /* authDetailsRequired */) {\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now) + \", isCredentialsUpdateSuggested\"\n                            + \", \" + account.toSafeString();\n                }\n\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.isCredentialsUpdateSuggested(this, account, statusToken);\n                }\n\n                @Override\n                public void onResult(Bundle result) {\n                    Bundle.setDefusable(result, true);\n                    IAccountManagerResponse response = getResponseAndClose();\n                    if (response == null) {\n                        return;\n                    }\n\n                    if (result == null) {\n                        sendErrorResponse(\n                                response,\n                                AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                                \"null bundle\");\n                        return;\n                    }\n\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, getClass().getSimpleName() + \" calling onResult() on response \"\n                                + response);\n                    }\n                    // Check to see if an error occurred. We know if an error occurred because all\n                    // error codes are greater than 0.\n                    if ((result.getInt(AccountManager.KEY_ERROR_CODE, -1) > 0)) {\n                        sendErrorResponse(response,\n                                result.getInt(AccountManager.KEY_ERROR_CODE),\n                                result.getString(AccountManager.KEY_ERROR_MESSAGE));\n                        return;\n                    }\n                    if (!result.containsKey(AccountManager.KEY_BOOLEAN_RESULT)) {\n                        sendErrorResponse(\n                                response,\n                                AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                                \"no result in response\");\n                        return;\n                    }\n                    final Bundle newResult = new Bundle();\n                    newResult.putBoolean(AccountManager.KEY_BOOLEAN_RESULT,\n                            result.getBoolean(AccountManager.KEY_BOOLEAN_RESULT, false));\n                    sendResponse(response, newResult);\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void editProperties(IAccountManagerResponse response, final String accountType,\n            final boolean expectActivityLaunch) {\n        final int callingUid = Binder.getCallingUid();\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"editProperties: accountType \" + accountType\n                    + \", response \" + response\n                    + \", expectActivityLaunch \" + expectActivityLaunch\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        if (response == null) throw new IllegalArgumentException(\"response is null\");\n        if (accountType == null) throw new IllegalArgumentException(\"accountType is null\");\n        int userId = UserHandle.getCallingUserId();\n        if (!isAccountManagedByCaller(accountType, callingUid, userId)\n                && !isSystemUid(callingUid)) {\n            String msg = String.format(\n                    \"uid %s cannot edit authenticator properites for account type: %s\",\n                    callingUid,\n                    accountType);\n            throw new SecurityException(msg);\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            new Session(accounts, response, accountType, expectActivityLaunch,\n                    true /* stripAuthTokenFromResult */, null /* accountName */,\n                    false /* authDetailsRequired */) {\n                @Override\n                public void run() throws RemoteException {\n                    mAuthenticator.editProperties(this, mAccountType);\n                }\n                @Override\n                protected String toDebugString(long now) {\n                    return super.toDebugString(now) + \", editProperties\"\n                            + \", accountType \" + accountType;\n                }\n            }.bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public boolean hasAccountAccess(@NonNull Account account,  @NonNull String packageName,\n            @NonNull UserHandle userHandle) {\n        if (UserHandle.getAppId(Binder.getCallingUid()) != Process.SYSTEM_UID) {\n            throw new SecurityException(\"Can be called only by system UID\");\n        }\n        Objects.requireNonNull(account, \"account cannot be null\");\n        Objects.requireNonNull(packageName, \"packageName cannot be null\");\n        Objects.requireNonNull(userHandle, \"userHandle cannot be null\");\n\n        final int userId = userHandle.getIdentifier();\n\n        Preconditions.checkArgumentInRange(userId, 0, Integer.MAX_VALUE, \"user must be concrete\");\n\n        try {\n            int uid = mPackageManager.getPackageUidAsUser(packageName, userId);\n            return hasAccountAccess(account, packageName, uid);\n        } catch (NameNotFoundException e) {\n            Log.d(TAG, \"Package not found \" + e.getMessage());\n            return false;\n        }\n    }\n\n    // Returns package with oldest target SDK for given UID.\n    private String getPackageNameForUid(int uid) {\n        String[] packageNames = mPackageManager.getPackagesForUid(uid);\n        if (ArrayUtils.isEmpty(packageNames)) {\n            return null;\n        }\n        String packageName = packageNames[0];\n        if (packageNames.length == 1) {\n            return packageName;\n        }\n        // Due to visibility changes we want to use package with oldest target SDK\n        int oldestVersion = Integer.MAX_VALUE;\n        for (String name : packageNames) {\n            try {\n                ApplicationInfo applicationInfo = mPackageManager.getApplicationInfo(name, 0);\n                if (applicationInfo != null) {\n                    int version = applicationInfo.targetSdkVersion;\n                    if (version < oldestVersion) {\n                        oldestVersion = version;\n                        packageName = name;\n                    }\n                }\n            } catch (NameNotFoundException e) {\n                // skip\n            }\n        }\n        return packageName;\n    }\n\n    private boolean hasAccountAccess(@NonNull Account account, @Nullable String packageName,\n            int uid) {\n        if (packageName == null) {\n            packageName = getPackageNameForUid(uid);\n            if (packageName == null) {\n                return false;\n            }\n        }\n\n        // Use null token which means any token. Having a token means the package\n        // is trusted by the authenticator, hence it is fine to access the account.\n        if (permissionIsGranted(account, null, uid, UserHandle.getUserId(uid))) {\n            return true;\n        }\n        // In addition to the permissions required to get an auth token we also allow\n        // the account to be accessed by apps for which user or authenticator granted visibility.\n\n        int visibility = resolveAccountVisibility(account, packageName,\n            getUserAccounts(UserHandle.getUserId(uid)));\n        return (visibility == AccountManager.VISIBILITY_VISIBLE\n            || visibility == AccountManager.VISIBILITY_USER_MANAGED_VISIBLE);\n    }\n\n    @Override\n    public IntentSender createRequestAccountAccessIntentSenderAsUser(@NonNull Account account,\n            @NonNull String packageName, @NonNull UserHandle userHandle) {\n        if (UserHandle.getAppId(Binder.getCallingUid()) != Process.SYSTEM_UID) {\n            throw new SecurityException(\"Can be called only by system UID\");\n        }\n\n        Objects.requireNonNull(account, \"account cannot be null\");\n        Objects.requireNonNull(packageName, \"packageName cannot be null\");\n        Objects.requireNonNull(userHandle, \"userHandle cannot be null\");\n\n        final int userId = userHandle.getIdentifier();\n\n        Preconditions.checkArgumentInRange(userId, 0, Integer.MAX_VALUE, \"user must be concrete\");\n\n        final int uid;\n        try {\n            uid = mPackageManager.getPackageUidAsUser(packageName, userId);\n        } catch (NameNotFoundException e) {\n            Slog.e(TAG, \"Unknown package \" + packageName);\n            return null;\n        }\n\n        Intent intent = newRequestAccountAccessIntent(account, packageName, uid, null);\n\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            return PendingIntent.getActivityAsUser(\n                    mContext, 0, intent, PendingIntent.FLAG_ONE_SHOT\n                            | PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_IMMUTABLE,\n                    null, new UserHandle(userId)).getIntentSender();\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    private Intent newRequestAccountAccessIntent(Account account, String packageName,\n            int uid, RemoteCallback callback) {\n        return newGrantCredentialsPermissionIntent(account, packageName, uid,\n                new AccountAuthenticatorResponse(new IAccountAuthenticatorResponse.Stub() {\n            @Override\n            public void onResult(Bundle value) throws RemoteException {\n                handleAuthenticatorResponse(true);\n            }\n\n            @Override\n            public void onRequestContinued() {\n                /* ignore */\n            }\n\n            @Override\n            public void onError(int errorCode, String errorMessage) throws RemoteException {\n                handleAuthenticatorResponse(false);\n            }\n\n            private void handleAuthenticatorResponse(boolean accessGranted) throws RemoteException {\n                cancelNotification(getCredentialPermissionNotificationId(account,\n                        AccountManager.ACCOUNT_ACCESS_TOKEN_TYPE, uid),\n                        UserHandle.getUserHandleForUid(uid));\n                if (callback != null) {\n                    Bundle result = new Bundle();\n                    result.putBoolean(AccountManager.KEY_BOOLEAN_RESULT, accessGranted);\n                    callback.sendResult(result);\n                }\n            }\n        }), AccountManager.ACCOUNT_ACCESS_TOKEN_TYPE, false);\n    }\n\n    @Override\n    public boolean someUserHasAccount(@NonNull final Account account) {\n        if (!UserHandle.isSameApp(Process.SYSTEM_UID, Binder.getCallingUid())) {\n            throw new SecurityException(\"Only system can check for accounts across users\");\n        }\n        final long token = Binder.clearCallingIdentity();\n        try {\n            AccountAndUser[] allAccounts = getAllAccounts();\n            for (int i = allAccounts.length - 1; i >= 0; i--) {\n                if (allAccounts[i].account.equals(account)) {\n                    return true;\n                }\n            }\n            return false;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private class GetAccountsByTypeAndFeatureSession extends Session {\n        private final String[] mFeatures;\n        private volatile Account[] mAccountsOfType = null;\n        private volatile ArrayList<Account> mAccountsWithFeatures = null;\n        private volatile int mCurrentAccount = 0;\n        private final int mCallingUid;\n        private final String mPackageName;\n        private final boolean mIncludeManagedNotVisible;\n\n        public GetAccountsByTypeAndFeatureSession(\n                UserAccounts accounts,\n                IAccountManagerResponse response,\n                String type,\n                String[] features,\n                int callingUid,\n                String packageName,\n                boolean includeManagedNotVisible) {\n            super(accounts, response, type, false /* expectActivityLaunch */,\n                    true /* stripAuthTokenFromResult */, null /* accountName */,\n                    false /* authDetailsRequired */);\n            mCallingUid = callingUid;\n            mFeatures = features;\n            mPackageName = packageName;\n            mIncludeManagedNotVisible = includeManagedNotVisible;\n        }\n\n        @Override\n        public void run() throws RemoteException {\n            mAccountsOfType = getAccountsFromCache(mAccounts, mAccountType,\n                    mCallingUid, mPackageName, mIncludeManagedNotVisible);\n            // check whether each account matches the requested features\n            mAccountsWithFeatures = new ArrayList<>(mAccountsOfType.length);\n            mCurrentAccount = 0;\n\n            checkAccount();\n        }\n\n        public void checkAccount() {\n            if (mCurrentAccount >= mAccountsOfType.length) {\n                sendResult();\n                return;\n            }\n\n            final IAccountAuthenticator accountAuthenticator = mAuthenticator;\n            if (accountAuthenticator == null) {\n                // It is possible that the authenticator has died, which is indicated by\n                // mAuthenticator being set to null. If this happens then just abort.\n                // There is no need to send back a result or error in this case since\n                // that already happened when mAuthenticator was cleared.\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.v(TAG, \"checkAccount: aborting session since we are no longer\"\n                            + \" connected to the authenticator, \" + toDebugString());\n                }\n                return;\n            }\n            try {\n                accountAuthenticator.hasFeatures(this, mAccountsOfType[mCurrentAccount], mFeatures);\n            } catch (RemoteException e) {\n                onError(AccountManager.ERROR_CODE_REMOTE_EXCEPTION, \"remote exception\");\n            }\n        }\n\n        @Override\n        public void onResult(Bundle result) {\n            Bundle.setDefusable(result, true);\n            mNumResults++;\n            if (result == null) {\n                onError(AccountManager.ERROR_CODE_INVALID_RESPONSE, \"null bundle\");\n                return;\n            }\n            if (result.getBoolean(AccountManager.KEY_BOOLEAN_RESULT, false)) {\n                mAccountsWithFeatures.add(mAccountsOfType[mCurrentAccount]);\n            }\n            mCurrentAccount++;\n            checkAccount();\n        }\n\n        public void sendResult() {\n            IAccountManagerResponse response = getResponseAndClose();\n            if (response != null) {\n                try {\n                    Account[] accounts = new Account[mAccountsWithFeatures.size()];\n                    for (int i = 0; i < accounts.length; i++) {\n                        accounts[i] = mAccountsWithFeatures.get(i);\n                    }\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, getClass().getSimpleName() + \" calling onResult() on response \"\n                                + response);\n                    }\n                    Bundle result = new Bundle();\n                    result.putParcelableArray(AccountManager.KEY_ACCOUNTS, accounts);\n                    response.onResult(result);\n                } catch (RemoteException e) {\n                    // if the caller is dead then there is no one to care about remote exceptions\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, \"failure while notifying response\", e);\n                    }\n                }\n            }\n        }\n\n        @Override\n        protected String toDebugString(long now) {\n            return super.toDebugString(now) + \", getAccountsByTypeAndFeatures\"\n                    + \", \" + (mFeatures != null ? TextUtils.join(\",\", mFeatures) : null);\n        }\n    }\n\n    /**\n     * Returns the accounts visible to the client within the context of a specific user\n     * @hide\n     */\n    @NonNull\n    public Account[] getAccounts(int userId, String opPackageName) {\n        int callingUid = Binder.getCallingUid();\n        mAppOpsManager.checkPackage(callingUid, opPackageName);\n        List<String> visibleAccountTypes = getTypesVisibleToCaller(callingUid, userId,\n                opPackageName);\n        if (visibleAccountTypes.isEmpty()) {\n            return EMPTY_ACCOUNT_ARRAY;\n        }\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return getAccountsInternal(\n                    accounts,\n                    callingUid,\n                    opPackageName,\n                    visibleAccountTypes,\n                    false /* includeUserManagedNotVisible */);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    /**\n     * Returns accounts for all running users, ignores visibility values.\n     *\n     * @hide\n     */\n    @NonNull\n    public AccountAndUser[] getRunningAccounts() {\n        final int[] runningUserIds;\n        try {\n            runningUserIds = ActivityManager.getService().getRunningUserIds();\n        } catch (RemoteException e) {\n            // Running in system_server; should never happen\n            throw new RuntimeException(e);\n        }\n        return getAccounts(runningUserIds);\n    }\n\n    /**\n     * Returns accounts for all users, ignores visibility values.\n     *\n     * @hide\n     */\n    @NonNull\n    public AccountAndUser[] getAllAccounts() {\n        final List<UserInfo> users = getUserManager().getAliveUsers();\n        final int[] userIds = new int[users.size()];\n        for (int i = 0; i < userIds.length; i++) {\n            userIds[i] = users.get(i).id;\n        }\n        return getAccounts(userIds);\n    }\n\n    @NonNull\n    private AccountAndUser[] getAccounts(int[] userIds) {\n        final ArrayList<AccountAndUser> runningAccounts = Lists.newArrayList();\n        for (int userId : userIds) {\n            UserAccounts userAccounts = getUserAccounts(userId);\n            if (userAccounts == null) continue;\n            Account[] accounts = getAccountsFromCache(\n                    userAccounts,\n                    null /* type */,\n                    Binder.getCallingUid(),\n                    null /* packageName */,\n                    false /* include managed not visible*/);\n            for (Account account : accounts) {\n                runningAccounts.add(new AccountAndUser(account, userId));\n            }\n        }\n\n        AccountAndUser[] accountsArray = new AccountAndUser[runningAccounts.size()];\n        return runningAccounts.toArray(accountsArray);\n    }\n\n    @Override\n    @NonNull\n    public Account[] getAccountsAsUser(String type, int userId, String opPackageName) {\n        int callingUid = Binder.getCallingUid();\n        mAppOpsManager.checkPackage(callingUid, opPackageName);\n        return getAccountsAsUserForPackage(type, userId, opPackageName /* callingPackage */, -1,\n                opPackageName, false /* includeUserManagedNotVisible */);\n    }\n\n    @NonNull\n    private Account[] getAccountsAsUserForPackage(\n            String type,\n            int userId,\n            String callingPackage,\n            int packageUid,\n            String opPackageName,\n            boolean includeUserManagedNotVisible) {\n        int callingUid = Binder.getCallingUid();\n        // Only allow the system process to read accounts of other users\n        if (userId != UserHandle.getCallingUserId()\n                && callingUid != Process.SYSTEM_UID\n                && mContext.checkCallingOrSelfPermission(\n                    android.Manifest.permission.INTERACT_ACROSS_USERS_FULL)\n                    != PackageManager.PERMISSION_GRANTED) {\n            throw new SecurityException(\"User \" + UserHandle.getCallingUserId()\n                    + \" trying to get account for \" + userId);\n        }\n\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"getAccounts: accountType \" + type\n                    + \", caller's uid \" + Binder.getCallingUid()\n                    + \", pid \" + Binder.getCallingPid());\n        }\n\n        // If the original calling app was using account choosing activity\n        // provided by the framework or authenticator we'll passing in\n        // the original caller's uid here, which is what should be used for filtering.\n        List<String> managedTypes =\n                getTypesManagedByCaller(callingUid, UserHandle.getUserId(callingUid));\n        if (packageUid != -1 &&\n                ((UserHandle.isSameApp(callingUid, Process.SYSTEM_UID)\n                || (type != null && managedTypes.contains(type))))) {\n            callingUid = packageUid;\n            opPackageName = callingPackage;\n        }\n        List<String> visibleAccountTypes = getTypesVisibleToCaller(callingUid, userId,\n                opPackageName);\n        if (visibleAccountTypes.isEmpty()\n                || (type != null && !visibleAccountTypes.contains(type))) {\n            return EMPTY_ACCOUNT_ARRAY;\n        } else if (visibleAccountTypes.contains(type)) {\n            // Prune the list down to just the requested type.\n            visibleAccountTypes = new ArrayList<>();\n            visibleAccountTypes.add(type);\n        } // else aggregate all the visible accounts (it won't matter if the\n          // list is empty).\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts accounts = getUserAccounts(userId);\n            return getAccountsInternal(\n                    accounts,\n                    callingUid,\n                    opPackageName,\n                    visibleAccountTypes,\n                    includeUserManagedNotVisible);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @NonNull\n    private Account[] getAccountsInternal(\n            UserAccounts userAccounts,\n            int callingUid,\n            String callingPackage,\n            List<String> visibleAccountTypes,\n            boolean includeUserManagedNotVisible) {\n        ArrayList<Account> visibleAccounts = new ArrayList<>();\n        for (String visibleType : visibleAccountTypes) {\n            Account[] accountsForType = getAccountsFromCache(\n                    userAccounts, visibleType, callingUid, callingPackage,\n                    includeUserManagedNotVisible);\n            if (accountsForType != null) {\n                visibleAccounts.addAll(Arrays.asList(accountsForType));\n            }\n        }\n        Account[] result = new Account[visibleAccounts.size()];\n        for (int i = 0; i < visibleAccounts.size(); i++) {\n            result[i] = visibleAccounts.get(i);\n        }\n        return result;\n    }\n\n    @Override\n    public void addSharedAccountsFromParentUser(int parentUserId, int userId,\n            String opPackageName) {\n        checkManageOrCreateUsersPermission(\"addSharedAccountsFromParentUser\");\n        Account[] accounts = getAccountsAsUser(null, parentUserId, opPackageName);\n        for (Account account : accounts) {\n            addSharedAccountAsUser(account, userId);\n        }\n    }\n\n    private boolean addSharedAccountAsUser(Account account, int userId) {\n        userId = handleIncomingUser(userId);\n        UserAccounts accounts = getUserAccounts(userId);\n        accounts.accountsDb.deleteSharedAccount(account);\n        long accountId = accounts.accountsDb.insertSharedAccount(account);\n        if (accountId < 0) {\n            Log.w(TAG, \"insertAccountIntoDatabase: \" + account.toSafeString()\n                    + \", skipping the DB insert failed\");\n            return false;\n        }\n        logRecord(AccountsDb.DEBUG_ACTION_ACCOUNT_ADD, AccountsDb.TABLE_SHARED_ACCOUNTS, accountId,\n                accounts);\n        return true;\n    }\n\n    public boolean renameSharedAccountAsUser(Account account, String newName, int userId) {\n        userId = handleIncomingUser(userId);\n        UserAccounts accounts = getUserAccounts(userId);\n        long sharedTableAccountId = accounts.accountsDb.findSharedAccountId(account);\n        int r = accounts.accountsDb.renameSharedAccount(account, newName);\n        if (r > 0) {\n            int callingUid = getCallingUid();\n            logRecord(AccountsDb.DEBUG_ACTION_ACCOUNT_RENAME, AccountsDb.TABLE_SHARED_ACCOUNTS,\n                    sharedTableAccountId, accounts, callingUid);\n            // Recursively rename the account.\n            renameAccountInternal(accounts, account, newName);\n        }\n        return r > 0;\n    }\n\n    public boolean removeSharedAccountAsUser(Account account, int userId) {\n        return removeSharedAccountAsUser(account, userId, getCallingUid());\n    }\n\n    private boolean removeSharedAccountAsUser(Account account, int userId, int callingUid) {\n        userId = handleIncomingUser(userId);\n        UserAccounts accounts = getUserAccounts(userId);\n        long sharedTableAccountId = accounts.accountsDb.findSharedAccountId(account);\n        boolean deleted = accounts.accountsDb.deleteSharedAccount(account);\n        if (deleted) {\n            logRecord(AccountsDb.DEBUG_ACTION_ACCOUNT_REMOVE, AccountsDb.TABLE_SHARED_ACCOUNTS,\n                    sharedTableAccountId, accounts, callingUid);\n            removeAccountInternal(accounts, account, callingUid);\n        }\n        return deleted;\n    }\n\n    public Account[] getSharedAccountsAsUser(int userId) {\n        userId = handleIncomingUser(userId);\n        UserAccounts accounts = getUserAccounts(userId);\n        synchronized (accounts.dbLock) {\n            List<Account> accountList = accounts.accountsDb.getSharedAccounts();\n            Account[] accountArray = new Account[accountList.size()];\n            accountList.toArray(accountArray);\n            return accountArray;\n        }\n    }\n\n    @Override\n    @NonNull\n    public Account[] getAccountsForPackage(String packageName, int uid, String opPackageName) {\n        int callingUid = Binder.getCallingUid();\n        if (!UserHandle.isSameApp(callingUid, Process.SYSTEM_UID)) {\n            // Don't do opPackageName check - caller is system.\n            throw new SecurityException(\"getAccountsForPackage() called from unauthorized uid \"\n                    + callingUid + \" with uid=\" + uid);\n        }\n        return getAccountsAsUserForPackage(null, UserHandle.getCallingUserId(), packageName, uid,\n                opPackageName, true /* includeUserManagedNotVisible */);\n    }\n\n    @Override\n    @NonNull\n    public Account[] getAccountsByTypeForPackage(String type, String packageName,\n            String opPackageName) {\n        int callingUid =  Binder.getCallingUid();\n        int userId = UserHandle.getCallingUserId();\n        mAppOpsManager.checkPackage(callingUid, opPackageName);\n        int packageUid = -1;\n        try {\n            packageUid = mPackageManager.getPackageUidAsUser(packageName, userId);\n        } catch (NameNotFoundException re) {\n            Slog.e(TAG, \"Couldn't determine the packageUid for \" + packageName + re);\n            return EMPTY_ACCOUNT_ARRAY;\n        }\n        if (!UserHandle.isSameApp(callingUid, Process.SYSTEM_UID)\n                && (type != null && !isAccountManagedByCaller(type, callingUid, userId))) {\n                return EMPTY_ACCOUNT_ARRAY;\n        }\n        if (!UserHandle.isSameApp(callingUid, Process.SYSTEM_UID) && type == null) {\n            return getAccountsAsUserForPackage(type, userId,\n                packageName, packageUid, opPackageName, false /* includeUserManagedNotVisible */);\n        }\n        return getAccountsAsUserForPackage(type, userId,\n                packageName, packageUid, opPackageName, true /* includeUserManagedNotVisible */);\n    }\n\n    private boolean needToStartChooseAccountActivity(Account[] accounts, String callingPackage) {\n        if (accounts.length < 1) return false;\n        if (accounts.length > 1) return true;\n        Account account = accounts[0];\n        UserAccounts userAccounts = getUserAccounts(UserHandle.getCallingUserId());\n        int visibility = resolveAccountVisibility(account, callingPackage, userAccounts);\n        if (visibility == AccountManager.VISIBILITY_USER_MANAGED_NOT_VISIBLE) return true;\n        return false;\n    }\n\n    private void startChooseAccountActivityWithAccounts(\n        IAccountManagerResponse response, Account[] accounts, String callingPackage) {\n        Intent intent = new Intent(mContext, ChooseAccountActivity.class);\n        intent.putExtra(AccountManager.KEY_ACCOUNTS, accounts);\n        intent.putExtra(AccountManager.KEY_ACCOUNT_MANAGER_RESPONSE,\n                new AccountManagerResponse(response));\n        intent.putExtra(AccountManager.KEY_ANDROID_PACKAGE_NAME, callingPackage);\n\n        mContext.startActivityAsUser(intent, UserHandle.of(UserHandle.getCallingUserId()));\n    }\n\n    private void handleGetAccountsResult(\n        IAccountManagerResponse response,\n        Account[] accounts,\n        String callingPackage) {\n\n        if (needToStartChooseAccountActivity(accounts, callingPackage)) {\n            startChooseAccountActivityWithAccounts(response, accounts, callingPackage);\n            return;\n        }\n        if (accounts.length == 1) {\n            Bundle bundle = new Bundle();\n            bundle.putString(AccountManager.KEY_ACCOUNT_NAME, accounts[0].name);\n            bundle.putString(AccountManager.KEY_ACCOUNT_TYPE, accounts[0].type);\n            onResult(response, bundle);\n            return;\n        }\n        // No qualified account exists, return an empty Bundle.\n        onResult(response, new Bundle());\n    }\n\n    @Override\n    public void getAccountByTypeAndFeatures(\n        IAccountManagerResponse response,\n        String accountType,\n        String[] features,\n        String opPackageName) {\n\n        int callingUid = Binder.getCallingUid();\n        mAppOpsManager.checkPackage(callingUid, opPackageName);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"getAccount: accountType \" + accountType\n                    + \", response \" + response\n                    + \", features \" + Arrays.toString(features)\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        if (response == null) throw new IllegalArgumentException(\"response is null\");\n        if (accountType == null) throw new IllegalArgumentException(\"accountType is null\");\n\n        int userId = UserHandle.getCallingUserId();\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts userAccounts = getUserAccounts(userId);\n            if (ArrayUtils.isEmpty(features)) {\n                Account[] accountsWithManagedNotVisible = getAccountsFromCache(\n                    userAccounts, accountType, callingUid, opPackageName,\n                    true /* include managed not visible */);\n                handleGetAccountsResult(\n                    response, accountsWithManagedNotVisible, opPackageName);\n                return;\n            }\n\n            IAccountManagerResponse retrieveAccountsResponse =\n                new IAccountManagerResponse.Stub() {\n                @Override\n                public void onResult(Bundle value) throws RemoteException {\n                    Parcelable[] parcelables = value.getParcelableArray(\n                        AccountManager.KEY_ACCOUNTS);\n                    Account[] accounts = new Account[parcelables.length];\n                    for (int i = 0; i < parcelables.length; i++) {\n                        accounts[i] = (Account) parcelables[i];\n                    }\n                    handleGetAccountsResult(\n                        response, accounts, opPackageName);\n                }\n\n                @Override\n                public void onError(int errorCode, String errorMessage)\n                        throws RemoteException {\n                    // Will not be called in this case.\n                }\n            };\n            new GetAccountsByTypeAndFeatureSession(\n                    userAccounts,\n                    retrieveAccountsResponse,\n                    accountType,\n                    features,\n                    callingUid,\n                    opPackageName,\n                    true /* include managed not visible */).bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void getAccountsByFeatures(\n            IAccountManagerResponse response,\n            String type,\n            String[] features,\n            String opPackageName) {\n        int callingUid = Binder.getCallingUid();\n        mAppOpsManager.checkPackage(callingUid, opPackageName);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"getAccounts: accountType \" + type\n                    + \", response \" + response\n                    + \", features \" + Arrays.toString(features)\n                    + \", caller's uid \" + callingUid\n                    + \", pid \" + Binder.getCallingPid());\n        }\n        if (response == null) throw new IllegalArgumentException(\"response is null\");\n        if (type == null) throw new IllegalArgumentException(\"accountType is null\");\n        int userId = UserHandle.getCallingUserId();\n\n        List<String> visibleAccountTypes = getTypesVisibleToCaller(callingUid, userId,\n                opPackageName);\n        if (!visibleAccountTypes.contains(type)) {\n            Bundle result = new Bundle();\n            // Need to return just the accounts that are from matching signatures.\n            result.putParcelableArray(AccountManager.KEY_ACCOUNTS, EMPTY_ACCOUNT_ARRAY);\n            try {\n                response.onResult(result);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Cannot respond to caller do to exception.\" , e);\n            }\n            return;\n        }\n\n        final long identityToken = clearCallingIdentity();\n        try {\n            UserAccounts userAccounts = getUserAccounts(userId);\n            if (features == null || features.length == 0) {\n                Account[] accounts = getAccountsFromCache(userAccounts, type, callingUid,\n                        opPackageName, false);\n                Bundle result = new Bundle();\n                result.putParcelableArray(AccountManager.KEY_ACCOUNTS, accounts);\n                onResult(response, result);\n                return;\n            }\n            new GetAccountsByTypeAndFeatureSession(\n                    userAccounts,\n                    response,\n                    type,\n                    features,\n                    callingUid,\n                    opPackageName,\n                    false /* include managed not visible */).bind();\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    @Override\n    public void onAccountAccessed(String token) throws RemoteException {\n        final int uid = Binder.getCallingUid();\n        if (UserHandle.getAppId(uid) == Process.SYSTEM_UID) {\n            return;\n        }\n        final int userId = UserHandle.getCallingUserId();\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            for (Account account : getAccounts(userId, mContext.getOpPackageName())) {\n                if (Objects.equals(account.getAccessId(), token)) {\n                    // An app just accessed the account. At this point it knows about\n                    // it and there is not need to hide this account from the app.\n                    // Do we need to update account visibility here?\n                    if (!hasAccountAccess(account, null, uid)) {\n                        updateAppPermission(account, AccountManager.ACCOUNT_ACCESS_TOKEN_TYPE,\n                                uid, true);\n                    }\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n    }\n\n    @Override\n    public void onShellCommand(FileDescriptor in, FileDescriptor out,\n            FileDescriptor err, String[] args, ShellCallback callback,\n            ResultReceiver resultReceiver) {\n        new AccountManagerServiceShellCommand(this).exec(this, in, out, err, args,\n                callback, resultReceiver);\n    }\n\n    private abstract class Session extends IAccountAuthenticatorResponse.Stub\n            implements IBinder.DeathRecipient, ServiceConnection {\n        IAccountManagerResponse mResponse;\n        final String mAccountType;\n        final boolean mExpectActivityLaunch;\n        final long mCreationTime;\n        final String mAccountName;\n        // Indicates if we need to add auth details(like last credential time)\n        final boolean mAuthDetailsRequired;\n        // If set, we need to update the last authenticated time. This is\n        // currently\n        // used on\n        // successful confirming credentials.\n        final boolean mUpdateLastAuthenticatedTime;\n\n        public int mNumResults = 0;\n        private int mNumRequestContinued = 0;\n        private int mNumErrors = 0;\n\n        IAccountAuthenticator mAuthenticator = null;\n\n        private final boolean mStripAuthTokenFromResult;\n        protected final UserAccounts mAccounts;\n\n        public Session(UserAccounts accounts, IAccountManagerResponse response, String accountType,\n                boolean expectActivityLaunch, boolean stripAuthTokenFromResult, String accountName,\n                boolean authDetailsRequired) {\n            this(accounts, response, accountType, expectActivityLaunch, stripAuthTokenFromResult,\n                    accountName, authDetailsRequired, false /* updateLastAuthenticatedTime */);\n        }\n\n        public Session(UserAccounts accounts, IAccountManagerResponse response, String accountType,\n                boolean expectActivityLaunch, boolean stripAuthTokenFromResult, String accountName,\n                boolean authDetailsRequired, boolean updateLastAuthenticatedTime) {\n            super();\n            //if (response == null) throw new IllegalArgumentException(\"response is null\");\n            if (accountType == null) throw new IllegalArgumentException(\"accountType is null\");\n            mAccounts = accounts;\n            mStripAuthTokenFromResult = stripAuthTokenFromResult;\n            mResponse = response;\n            mAccountType = accountType;\n            mExpectActivityLaunch = expectActivityLaunch;\n            mCreationTime = SystemClock.elapsedRealtime();\n            mAccountName = accountName;\n            mAuthDetailsRequired = authDetailsRequired;\n            mUpdateLastAuthenticatedTime = updateLastAuthenticatedTime;\n\n            synchronized (mSessions) {\n                mSessions.put(toString(), this);\n            }\n            scheduleTimeout();\n            if (response != null) {\n                try {\n                    response.asBinder().linkToDeath(this, 0 /* flags */);\n                } catch (RemoteException e) {\n                    mResponse = null;\n                    binderDied();\n                }\n            }\n        }\n\n        IAccountManagerResponse getResponseAndClose() {\n            if (mResponse == null) {\n                close();\n                return null;\n            }\n            IAccountManagerResponse response = mResponse;\n            close(); // this clears mResponse so we need to save the response before this call\n            return response;\n        }\n\n        /**\n         * Checks Intents, supplied via KEY_INTENT, to make sure that they don't violate our\n         * security policy.\n         *\n         * In particular we want to make sure that the Authenticator doesn't try to trick users\n         * into launching arbitrary intents on the device via by tricking to click authenticator\n         * supplied entries in the system Settings app.\n         */\n        protected boolean checkKeyIntent(int authUid, Bundle bundle) {\n            if (!checkKeyIntentParceledCorrectly(bundle)) {\n            \tEventLog.writeEvent(0x534e4554, \"250588548\", authUid, \"\");\n                return false;\n            }\n            Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT);\n            if (intent == null) {\n                return true;\n            }\n            // Explicitly set an empty ClipData to ensure that we don't offer to\n            // promote any Uris contained inside for granting purposes\n            if (intent.getClipData() == null) {\n                intent.setClipData(ClipData.newPlainText(null, null));\n            }\n            final long bid = Binder.clearCallingIdentity();\n            try {\n                PackageManager pm = mContext.getPackageManager();\n                ResolveInfo resolveInfo = pm.resolveActivityAsUser(intent, 0, mAccounts.userId);\n                if (resolveInfo == null) {\n                    return false;\n                }\n                if (\"content\".equals(intent.getScheme())) {\n                    return false;\n                }\n                ActivityInfo targetActivityInfo = resolveInfo.activityInfo;\n                int targetUid = targetActivityInfo.applicationInfo.uid;\n                PackageManagerInternal pmi = LocalServices.getService(PackageManagerInternal.class);\n                if (!isExportedSystemActivity(targetActivityInfo)\n                        && !pmi.hasSignatureCapability(\n                                targetUid, authUid,\n                                PackageParser.SigningDetails.CertCapabilities.AUTH)) {\n                    String pkgName = targetActivityInfo.packageName;\n                    String activityName = targetActivityInfo.name;\n                    String tmpl = \"KEY_INTENT resolved to an Activity (%s) in a package (%s) that \"\n                            + \"does not share a signature with the supplying authenticator (%s).\";\n                    Log.e(TAG, String.format(tmpl, activityName, pkgName, mAccountType));\n                    return false;\n                }\n                intent.setComponent(targetActivityInfo.getComponentName());\n                bundle.putParcelable(AccountManager.KEY_INTENT, intent);\n                return true;\n            } finally {\n                Binder.restoreCallingIdentity(bid);\n            }\n        }\n\n        /**\n         * Simulate the client side's deserialization of KEY_INTENT value, to make sure they don't\n         * violate our security policy.\n         *\n         * In particular we want to make sure the Authenticator doesn't trick users\n         * into launching arbitrary intents on the device via exploiting any other Parcel read/write\n         * mismatch problems.\n         */\n        private boolean checkKeyIntentParceledCorrectly(Bundle bundle) {\n            Parcel p = Parcel.obtain();\n            p.writeBundle(bundle);\n            p.setDataPosition(0);\n            Bundle simulateBundle = p.readBundle();\n            p.recycle();\n            Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT);\n            if (intent != null && intent.getClass() != Intent.class) {\n                return false;\n            }\n            Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT);\n            if (intent == null) {\n                return (simulateIntent == null);\n            }\n            if (!intent.filterEquals(simulateIntent)) {\n                return false;\n            }\n\n            if (intent.getSelector() != simulateIntent.getSelector()) {\n                return false;\n            }\n\n            int prohibitedFlags = Intent.FLAG_GRANT_READ_URI_PERMISSION\n                    | Intent.FLAG_GRANT_WRITE_URI_PERMISSION\n                    | Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION\n                    | Intent.FLAG_GRANT_PREFIX_URI_PERMISSION;\n            return (simulateIntent.getFlags() & prohibitedFlags) == 0;\n        }\n\n        private boolean isExportedSystemActivity(ActivityInfo activityInfo) {\n            String className = activityInfo.name;\n            return \"android\".equals(activityInfo.packageName) &&\n                    (GrantCredentialsPermissionActivity.class.getName().equals(className)\n                    || CantAddAccountActivity.class.getName().equals(className));\n        }\n\n        private void close() {\n            synchronized (mSessions) {\n                if (mSessions.remove(toString()) == null) {\n                    // the session was already closed, so bail out now\n                    return;\n                }\n            }\n            if (mResponse != null) {\n                // stop listening for response deaths\n                mResponse.asBinder().unlinkToDeath(this, 0 /* flags */);\n\n                // clear this so that we don't accidentally send any further results\n                mResponse = null;\n            }\n            cancelTimeout();\n            unbind();\n        }\n\n        @Override\n        public void binderDied() {\n            mResponse = null;\n            close();\n        }\n\n        protected String toDebugString() {\n            return toDebugString(SystemClock.elapsedRealtime());\n        }\n\n        protected String toDebugString(long now) {\n            return \"Session: expectLaunch \" + mExpectActivityLaunch\n                    + \", connected \" + (mAuthenticator != null)\n                    + \", stats (\" + mNumResults + \"/\" + mNumRequestContinued\n                    + \"/\" + mNumErrors + \")\"\n                    + \", lifetime \" + ((now - mCreationTime) / 1000.0);\n        }\n\n        void bind() {\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"initiating bind to authenticator type \" + mAccountType);\n            }\n            if (!bindToAuthenticator(mAccountType)) {\n                Log.d(TAG, \"bind attempt failed for \" + toDebugString());\n                onError(AccountManager.ERROR_CODE_REMOTE_EXCEPTION, \"bind failure\");\n            }\n        }\n\n        private void unbind() {\n            if (mAuthenticator != null) {\n                mAuthenticator = null;\n                mContext.unbindService(this);\n            }\n        }\n\n        private void scheduleTimeout() {\n            mHandler.sendMessageDelayed(\n                    mHandler.obtainMessage(MESSAGE_TIMED_OUT, this), TIMEOUT_DELAY_MS);\n        }\n\n        public void cancelTimeout() {\n            mHandler.removeMessages(MESSAGE_TIMED_OUT, this);\n        }\n\n        @Override\n        public void onServiceConnected(ComponentName name, IBinder service) {\n            mAuthenticator = IAccountAuthenticator.Stub.asInterface(service);\n            try {\n                run();\n            } catch (RemoteException e) {\n                onError(AccountManager.ERROR_CODE_REMOTE_EXCEPTION,\n                        \"remote exception\");\n            }\n        }\n\n        @Override\n        public void onServiceDisconnected(ComponentName name) {\n            mAuthenticator = null;\n            IAccountManagerResponse response = getResponseAndClose();\n            if (response != null) {\n                try {\n                    response.onError(AccountManager.ERROR_CODE_REMOTE_EXCEPTION,\n                            \"disconnected\");\n                } catch (RemoteException e) {\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, \"Session.onServiceDisconnected: \"\n                                + \"caught RemoteException while responding\", e);\n                    }\n                }\n            }\n        }\n\n        public abstract void run() throws RemoteException;\n\n        public void onTimedOut() {\n            IAccountManagerResponse response = getResponseAndClose();\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"Session.onTimedOut\");\n            }\n            if (response != null) {\n                try {\n                    response.onError(AccountManager.ERROR_CODE_REMOTE_EXCEPTION,\n                            \"timeout\");\n                } catch (RemoteException e) {\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, \"Session.onTimedOut: caught RemoteException while responding\",\n                                e);\n                    }\n                }\n            }\n        }\n\n        @Override\n        public void onResult(Bundle result) {\n            Bundle.setDefusable(result, true);\n            mNumResults++;\n            Intent intent = null;\n            if (result != null) {\n                boolean isSuccessfulConfirmCreds = result.getBoolean(\n                        AccountManager.KEY_BOOLEAN_RESULT, false);\n                boolean isSuccessfulUpdateCredsOrAddAccount =\n                        result.containsKey(AccountManager.KEY_ACCOUNT_NAME)\n                        && result.containsKey(AccountManager.KEY_ACCOUNT_TYPE);\n                // We should only update lastAuthenticated time, if\n                // mUpdateLastAuthenticatedTime is true and the confirmRequest\n                // or updateRequest was successful\n                boolean needUpdate = mUpdateLastAuthenticatedTime\n                        && (isSuccessfulConfirmCreds || isSuccessfulUpdateCredsOrAddAccount);\n                if (needUpdate || mAuthDetailsRequired) {\n                    boolean accountPresent = isAccountPresentForCaller(mAccountName, mAccountType);\n                    if (needUpdate && accountPresent) {\n                        updateLastAuthenticatedTime(new Account(mAccountName, mAccountType));\n                    }\n                    if (mAuthDetailsRequired) {\n                        long lastAuthenticatedTime = -1;\n                        if (accountPresent) {\n                            lastAuthenticatedTime = mAccounts.accountsDb\n                                    .findAccountLastAuthenticatedTime(\n                                            new Account(mAccountName, mAccountType));\n                        }\n                        result.putLong(AccountManager.KEY_LAST_AUTHENTICATED_TIME,\n                                lastAuthenticatedTime);\n                    }\n                }\n            }\n            if (result != null) {\n                if (!checkKeyIntent(\n                        Binder.getCallingUid(),\n                        result)) {\n                    onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                            \"invalid intent in bundle returned\");\n                    return;\n                }\n            }\n            if (result != null\n                    && !TextUtils.isEmpty(result.getString(AccountManager.KEY_AUTHTOKEN))) {\n                String accountName = result.getString(AccountManager.KEY_ACCOUNT_NAME);\n                String accountType = result.getString(AccountManager.KEY_ACCOUNT_TYPE);\n                if (!TextUtils.isEmpty(accountName) && !TextUtils.isEmpty(accountType)) {\n                    Account account = new Account(accountName, accountType);\n                    cancelNotification(getSigninRequiredNotificationId(mAccounts, account),\n                            new UserHandle(mAccounts.userId));\n                }\n            }\n            IAccountManagerResponse response;\n            if (mExpectActivityLaunch && result != null\n                    && result.containsKey(AccountManager.KEY_INTENT)) {\n                response = mResponse;\n            } else {\n                response = getResponseAndClose();\n            }\n            if (response != null) {\n                try {\n                    if (result == null) {\n                        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                            Log.v(TAG, getClass().getSimpleName()\n                                    + \" calling onError() on response \" + response);\n                        }\n                        response.onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                                \"null bundle returned\");\n                    } else {\n                        if (mStripAuthTokenFromResult) {\n                            result.remove(AccountManager.KEY_AUTHTOKEN);\n                            if (!checkKeyIntent(Binder.getCallingUid(), result)) {\n                                onError(AccountManager.ERROR_CODE_INVALID_RESPONSE,\n                                        \"invalid intent in bundle returned\");\n                                return;\n                            }\n                        }\n                        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                            Log.v(TAG, getClass().getSimpleName()\n                                    + \" calling onResult() on response \" + response);\n                        }\n                        if ((result.getInt(AccountManager.KEY_ERROR_CODE, -1) > 0) &&\n                                (intent == null)) {\n                            // All AccountManager error codes are greater than 0\n                            response.onError(result.getInt(AccountManager.KEY_ERROR_CODE),\n                                    result.getString(AccountManager.KEY_ERROR_MESSAGE));\n                        } else {\n                            response.onResult(result);\n                        }\n                    }\n                } catch (RemoteException e) {\n                    // if the caller is dead then there is no one to care about remote exceptions\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, \"failure while notifying response\", e);\n                    }\n                }\n            }\n        }\n\n        @Override\n        public void onRequestContinued() {\n            mNumRequestContinued++;\n        }\n\n        @Override\n        public void onError(int errorCode, String errorMessage) {\n            mNumErrors++;\n            IAccountManagerResponse response = getResponseAndClose();\n            if (response != null) {\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.v(TAG, getClass().getSimpleName()\n                            + \" calling onError() on response \" + response);\n                }\n                try {\n                    response.onError(errorCode, errorMessage);\n                } catch (RemoteException e) {\n                    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                        Log.v(TAG, \"Session.onError: caught RemoteException while responding\", e);\n                    }\n                }\n            } else {\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.v(TAG, \"Session.onError: already closed\");\n                }\n            }\n        }\n\n        /**\n         * find the component name for the authenticator and initiate a bind\n         * if no authenticator or the bind fails then return false, otherwise return true\n         */\n        private boolean bindToAuthenticator(String authenticatorType) {\n            final AccountAuthenticatorCache.ServiceInfo<AuthenticatorDescription> authenticatorInfo;\n            authenticatorInfo = mAuthenticatorCache.getServiceInfo(\n                    AuthenticatorDescription.newKey(authenticatorType), mAccounts.userId);\n            if (authenticatorInfo == null) {\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.v(TAG, \"there is no authenticator for \" + authenticatorType\n                            + \", bailing out\");\n                }\n                return false;\n            }\n\n            if (!isLocalUnlockedUser(mAccounts.userId)\n                    && !authenticatorInfo.componentInfo.directBootAware) {\n                Slog.w(TAG, \"Blocking binding to authenticator \" + authenticatorInfo.componentName\n                        + \" which isn't encryption aware\");\n                return false;\n            }\n\n            Intent intent = new Intent();\n            intent.setAction(AccountManager.ACTION_AUTHENTICATOR_INTENT);\n            intent.setComponent(authenticatorInfo.componentName);\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"performing bindService to \" + authenticatorInfo.componentName);\n            }\n            int flags = Context.BIND_AUTO_CREATE;\n            if (mAuthenticatorCache.getBindInstantServiceAllowed(mAccounts.userId)) {\n                flags |= Context.BIND_ALLOW_INSTANT;\n            }\n            if (!mContext.bindServiceAsUser(intent, this, flags, UserHandle.of(mAccounts.userId))) {\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.v(TAG, \"bindService to \" + authenticatorInfo.componentName + \" failed\");\n                }\n                return false;\n            }\n\n            return true;\n        }\n    }\n\n    class MessageHandler extends Handler {\n        MessageHandler(Looper looper) {\n            super(looper);\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MESSAGE_TIMED_OUT:\n                    Session session = (Session)msg.obj;\n                    session.onTimedOut();\n                    break;\n\n                case MESSAGE_COPY_SHARED_ACCOUNT:\n                    copyAccountToUser(/*no response*/ null, (Account) msg.obj, msg.arg1, msg.arg2);\n                    break;\n\n                default:\n                    throw new IllegalStateException(\"unhandled message: \" + msg.what);\n            }\n        }\n    }\n\n    private void logRecord(UserAccounts accounts, String action, String tableName) {\n        logRecord(action, tableName, -1, accounts);\n    }\n\n    private void logRecordWithUid(UserAccounts accounts, String action, String tableName, int uid) {\n        logRecord(action, tableName, -1, accounts, uid);\n    }\n\n    /*\n     * This function receives an opened writable database.\n     */\n    private void logRecord(String action, String tableName, long accountId,\n            UserAccounts userAccount) {\n        logRecord(action, tableName, accountId, userAccount, getCallingUid());\n    }\n\n    /*\n     * This function receives an opened writable database and writes to it in a separate thread.\n     */\n    private void logRecord(String action, String tableName, long accountId,\n            UserAccounts userAccount, int callingUid) {\n\n        class LogRecordTask implements Runnable {\n            private final String action;\n            private final String tableName;\n            private final long accountId;\n            private final UserAccounts userAccount;\n            private final int callingUid;\n            private final long userDebugDbInsertionPoint;\n\n            LogRecordTask(final String action,\n                    final String tableName,\n                    final long accountId,\n                    final UserAccounts userAccount,\n                    final int callingUid,\n                    final long userDebugDbInsertionPoint) {\n                this.action = action;\n                this.tableName = tableName;\n                this.accountId = accountId;\n                this.userAccount = userAccount;\n                this.callingUid = callingUid;\n                this.userDebugDbInsertionPoint = userDebugDbInsertionPoint;\n            }\n\n            @Override\n            public void run() {\n                synchronized (userAccount.accountsDb.mDebugStatementLock) {\n                    SQLiteStatement logStatement = userAccount.accountsDb.getStatementForLogging();\n                    if (logStatement == null) {\n                        return; // Can't log.\n                    }\n                    logStatement.bindLong(1, accountId);\n                    logStatement.bindString(2, action);\n                    logStatement.bindString(3, mDateFormat.format(new Date()));\n                    logStatement.bindLong(4, callingUid);\n                    logStatement.bindString(5, tableName);\n                    logStatement.bindLong(6, userDebugDbInsertionPoint);\n                    try {\n                        logStatement.execute();\n                    } catch (IllegalStateException e) {\n                        // Guard against crash, DB can already be closed\n                        // since this statement is executed on a handler thread\n                        Slog.w(TAG, \"Failed to insert a log record. accountId=\" + accountId\n                                + \" action=\" + action + \" tableName=\" + tableName + \" Error: \" + e);\n                    } finally {\n                        logStatement.clearBindings();\n                    }\n                }\n            }\n        }\n        long insertionPoint = userAccount.accountsDb.reserveDebugDbInsertionPoint();\n        if (insertionPoint != -1) {\n            LogRecordTask logTask = new LogRecordTask(action, tableName, accountId, userAccount,\n                    callingUid, insertionPoint);\n            mHandler.post(logTask);\n        }\n    }\n\n    public IBinder onBind(@SuppressWarnings(\"unused\") Intent intent) {\n        return asBinder();\n    }\n\n    /**\n     * Searches array of arguments for the specified string\n     * @param args array of argument strings\n     * @param value value to search for\n     * @return true if the value is contained in the array\n     */\n    private static boolean scanArgs(String[] args, String value) {\n        if (args != null) {\n            for (String arg : args) {\n                if (value.equals(arg)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    @Override\n    protected void dump(FileDescriptor fd, PrintWriter fout, String[] args) {\n        if (!DumpUtils.checkDumpPermission(mContext, TAG, fout)) return;\n        final boolean isCheckinRequest = scanArgs(args, \"--checkin\") || scanArgs(args, \"-c\");\n        final IndentingPrintWriter ipw = new IndentingPrintWriter(fout, \"  \");\n\n        final List<UserInfo> users = getUserManager().getUsers();\n        for (UserInfo user : users) {\n            ipw.println(\"User \" + user + \":\");\n            ipw.increaseIndent();\n            dumpUser(getUserAccounts(user.id), fd, ipw, args, isCheckinRequest);\n            ipw.println();\n            ipw.decreaseIndent();\n        }\n    }\n\n    private void dumpUser(UserAccounts userAccounts, FileDescriptor fd, PrintWriter fout,\n            String[] args, boolean isCheckinRequest) {\n        if (isCheckinRequest) {\n            // This is a checkin request. *Only* upload the account types and the count of\n            // each.\n            synchronized (userAccounts.dbLock) {\n                userAccounts.accountsDb.dumpDeAccountsTable(fout);\n            }\n        } else {\n            Account[] accounts = getAccountsFromCache(userAccounts, null /* type */,\n                    Process.SYSTEM_UID, null /* packageName */, false);\n            fout.println(\"Accounts: \" + accounts.length);\n            for (Account account : accounts) {\n                fout.println(\"  \" + account.toString());\n            }\n\n            // Add debug information.\n            fout.println();\n            synchronized (userAccounts.dbLock) {\n                userAccounts.accountsDb.dumpDebugTable(fout);\n            }\n            fout.println();\n            synchronized (mSessions) {\n                final long now = SystemClock.elapsedRealtime();\n                fout.println(\"Active Sessions: \" + mSessions.size());\n                for (Session session : mSessions.values()) {\n                    fout.println(\"  \" + session.toDebugString(now));\n                }\n            }\n\n            fout.println();\n            mAuthenticatorCache.dump(fd, fout, args, userAccounts.userId);\n\n            boolean isUserUnlocked;\n            synchronized (mUsers) {\n                isUserUnlocked = isLocalUnlockedUser(userAccounts.userId);\n            }\n            // Following logs are printed only when user is unlocked.\n            if (!isUserUnlocked) {\n                return;\n            }\n            fout.println();\n            synchronized (userAccounts.dbLock) {\n                Map<Account, Map<String, Integer>> allVisibilityValues =\n                        userAccounts.accountsDb.findAllVisibilityValues();\n                fout.println(\"Account visibility:\");\n                for (Account account : allVisibilityValues.keySet()) {\n                    fout.println(\"  \" + account.name);\n                    Map<String, Integer> visibilities = allVisibilityValues.get(account);\n                    for (Entry<String, Integer> entry : visibilities.entrySet()) {\n                        fout.println(\"    \" + entry.getKey() + \", \" + entry.getValue());\n                    }\n                }\n            }\n        }\n    }\n\n    private void doNotification(UserAccounts accounts, Account account, CharSequence message,\n            Intent intent, String packageName, final int userId) {\n        final long identityToken = clearCallingIdentity();\n        try {\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"doNotification: \" + message + \" intent:\" + intent);\n            }\n\n            if (intent.getComponent() != null &&\n                    GrantCredentialsPermissionActivity.class.getName().equals(\n                            intent.getComponent().getClassName())) {\n                createNoCredentialsPermissionNotification(account, intent, packageName, userId);\n            } else {\n                Context contextForUser = getContextForUser(new UserHandle(userId));\n                final NotificationId id = getSigninRequiredNotificationId(accounts, account);\n                intent.addCategory(id.mTag);\n\n                final String notificationTitleFormat =\n                        contextForUser.getText(R.string.notification_title).toString();\n                Notification n =\n                        new Notification.Builder(contextForUser, SystemNotificationChannels.ACCOUNT)\n                        .setWhen(0)\n                        .setSmallIcon(android.R.drawable.stat_sys_warning)\n                        .setColor(contextForUser.getColor(\n                                com.android.internal.R.color.system_notification_accent_color))\n                        .setContentTitle(String.format(notificationTitleFormat, account.name))\n                        .setContentText(message)\n                        .setContentIntent(PendingIntent.getActivityAsUser(\n                                mContext, 0, intent,\n                                PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_IMMUTABLE,\n                                null, new UserHandle(userId)))\n                        .build();\n                installNotification(id, n, packageName, userId);\n            }\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private void installNotification(NotificationId id, final Notification notification,\n            String packageName, int userId) {\n        final long token = clearCallingIdentity();\n        try {\n            INotificationManager notificationManager = mInjector.getNotificationManager();\n            try {\n                // The calling uid must match either the package or op package, so use an op\n                // package that matches the cleared calling identity.\n                notificationManager.enqueueNotificationWithTag(packageName, \"android\",\n                        id.mTag, id.mId, notification, userId);\n            } catch (RemoteException e) {\n                /* ignore - local call */\n            }\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private void cancelNotification(NotificationId id, UserHandle user) {\n        cancelNotification(id, mContext.getPackageName(), user);\n    }\n\n    private void cancelNotification(NotificationId id, String packageName, UserHandle user) {\n        final long identityToken = clearCallingIdentity();\n        try {\n            INotificationManager service = mInjector.getNotificationManager();\n            service.cancelNotificationWithTag(\n                    packageName, \"android\", id.mTag, id.mId, user.getIdentifier());\n        } catch (RemoteException e) {\n            /* ignore - local call */\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }\n\n    private boolean isPermittedForPackage(String packageName, int userId, String... permissions) {\n        final long identity = Binder.clearCallingIdentity();\n        try {\n            final int uid = mPackageManager.getPackageUidAsUser(packageName, userId);\n            IPackageManager pm = ActivityThread.getPackageManager();\n            for (String perm : permissions) {\n                if (pm.checkPermission(perm, packageName, userId)\n                        == PackageManager.PERMISSION_GRANTED) {\n                    // Checks runtime permission revocation.\n                    final int opCode = AppOpsManager.permissionToOpCode(perm);\n                    if (opCode == AppOpsManager.OP_NONE || mAppOpsManager.checkOpNoThrow(\n                            opCode, uid, packageName) == AppOpsManager.MODE_ALLOWED) {\n                        return true;\n                    }\n                }\n            }\n        } catch (NameNotFoundException | RemoteException e) {\n            // Assume permission is not granted if an error accrued.\n        } finally {\n            Binder.restoreCallingIdentity(identity);\n        }\n        return false;\n    }\n\n    /**\n     * Checks that package has at least one of given permissions and makes note of app\n     * performing the action.\n     */\n    private boolean checkPermissionAndNote(String opPackageName, int callingUid,\n            String... permissions) {\n        for (String perm : permissions) {\n            if (mContext.checkCallingOrSelfPermission(perm) == PackageManager.PERMISSION_GRANTED) {\n                if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                    Log.v(TAG, \"  caller uid \" + callingUid + \" has \" + perm);\n                }\n                final int opCode = AppOpsManager.permissionToOpCode(perm);\n                if (opCode == AppOpsManager.OP_NONE || mAppOpsManager.noteOpNoThrow(\n                        opCode, callingUid, opPackageName) == AppOpsManager.MODE_ALLOWED) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private int handleIncomingUser(int userId) {\n        try {\n            return ActivityManager.getService().handleIncomingUser(\n                    Binder.getCallingPid(), Binder.getCallingUid(), userId, true, true, \"\", null);\n        } catch (RemoteException re) {\n            // Shouldn't happen, local.\n        }\n        return userId;\n    }\n\n    private boolean isPrivileged(int callingUid) {\n        String[] packages;\n        final long identityToken = Binder.clearCallingIdentity();\n        try {\n            packages = mPackageManager.getPackagesForUid(callingUid);\n            if (packages == null) {\n                Log.d(TAG, \"No packages for callingUid \" + callingUid);\n                return false;\n            }\n            for (String name : packages) {\n                try {\n                    PackageInfo packageInfo =\n                        mPackageManager.getPackageInfo(name, 0 /* flags */);\n                    if (packageInfo != null\n                        && (packageInfo.applicationInfo.privateFlags\n                            & ApplicationInfo.PRIVATE_FLAG_PRIVILEGED) != 0) {\n                        return true;\n                    }\n                } catch (PackageManager.NameNotFoundException e) {\n                    Log.d(TAG, \"Package not found \" + e.getMessage());\n                }\n            }\n        } finally {\n            Binder.restoreCallingIdentity(identityToken);\n        }\n        return false;\n    }\n\n    private boolean permissionIsGranted(\n            Account account, String authTokenType, int callerUid, int userId) {\n        if (UserHandle.getAppId(callerUid) == Process.SYSTEM_UID) {\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"Access to \" + account + \" granted calling uid is system\");\n            }\n            return true;\n        }\n\n        if (isPrivileged(callerUid)) {\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"Access to \" + account + \" granted calling uid \"\n                        + callerUid + \" privileged\");\n            }\n            return true;\n        }\n        if (account != null && isAccountManagedByCaller(account.type, callerUid, userId)) {\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"Access to \" + account + \" granted calling uid \"\n                        + callerUid + \" manages the account\");\n            }\n            return true;\n        }\n        if (account != null && hasExplicitlyGrantedPermission(account, authTokenType, callerUid)) {\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"Access to \" + account + \" granted calling uid \"\n                        + callerUid + \" user granted access\");\n            }\n            return true;\n        }\n\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"Access to \" + account + \" not granted for uid \" + callerUid);\n        }\n\n        return false;\n    }\n\n    private boolean isAccountVisibleToCaller(String accountType, int callingUid, int userId,\n            String opPackageName) {\n        if (accountType == null) {\n            return false;\n        } else {\n            return getTypesVisibleToCaller(callingUid, userId,\n                    opPackageName).contains(accountType);\n        }\n    }\n\n    // Method checks visibility for applications targeing API level below {@link\n    // android.os.Build.VERSION_CODES#O},\n    // returns true if the the app has GET_ACCOUNTS or GET_ACCOUNTS_PRIVILEGED permission.\n    private boolean checkGetAccountsPermission(String packageName, int userId) {\n        return isPermittedForPackage(packageName, userId, Manifest.permission.GET_ACCOUNTS,\n                Manifest.permission.GET_ACCOUNTS_PRIVILEGED);\n    }\n\n    private boolean checkReadContactsPermission(String packageName, int userId) {\n        return isPermittedForPackage(packageName, userId, Manifest.permission.READ_CONTACTS);\n    }\n\n    // Heuristic to check that account type may be associated with some contacts data and\n    // therefore READ_CONTACTS permission grants the access to account by default.\n    private boolean accountTypeManagesContacts(String accountType, int userId) {\n        if (accountType == null) {\n            return false;\n        }\n        final long identityToken = Binder.clearCallingIdentity();\n        Collection<RegisteredServicesCache.ServiceInfo<AuthenticatorDescription>> serviceInfos;\n        try {\n            serviceInfos = mAuthenticatorCache.getAllServices(userId);\n        } finally {\n            Binder.restoreCallingIdentity(identityToken);\n        }\n        // Check contacts related permissions for authenticator.\n        for (RegisteredServicesCache.ServiceInfo<AuthenticatorDescription> serviceInfo\n                : serviceInfos) {\n            if (accountType.equals(serviceInfo.type.type)) {\n                return isPermittedForPackage(serviceInfo.type.packageName, userId,\n                    Manifest.permission.WRITE_CONTACTS);\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Method checks package uid and signature with Authenticator which manages accountType.\n     *\n     * @return SIGNATURE_CHECK_UID_MATCH for uid match, SIGNATURE_CHECK_MATCH for signature match,\n     *         SIGNATURE_CHECK_MISMATCH otherwise.\n     */\n    private int checkPackageSignature(String accountType, int callingUid, int userId) {\n        if (accountType == null) {\n            return SIGNATURE_CHECK_MISMATCH;\n        }\n\n        final long identityToken = Binder.clearCallingIdentity();\n        Collection<RegisteredServicesCache.ServiceInfo<AuthenticatorDescription>> serviceInfos;\n        try {\n            serviceInfos = mAuthenticatorCache.getAllServices(userId);\n        } finally {\n            Binder.restoreCallingIdentity(identityToken);\n        }\n        // Check for signature match with Authenticator.LocalServices.getService(PackageManagerInternal.class);\n        PackageManagerInternal pmi = LocalServices.getService(PackageManagerInternal.class);\n        for (RegisteredServicesCache.ServiceInfo<AuthenticatorDescription> serviceInfo\n                : serviceInfos) {\n            if (accountType.equals(serviceInfo.type.type)) {\n                if (serviceInfo.uid == callingUid) {\n                    return SIGNATURE_CHECK_UID_MATCH;\n                }\n                if (pmi.hasSignatureCapability(\n                        serviceInfo.uid, callingUid,\n                        PackageParser.SigningDetails.CertCapabilities.AUTH)) {\n                    return SIGNATURE_CHECK_MATCH;\n                }\n            }\n        }\n        return SIGNATURE_CHECK_MISMATCH;\n    }\n\n    // returns true for applications with the same signature as authenticator.\n    private boolean isAccountManagedByCaller(String accountType, int callingUid, int userId) {\n        if (accountType == null) {\n            return false;\n        } else {\n            return getTypesManagedByCaller(callingUid, userId).contains(accountType);\n        }\n    }\n\n    private List<String> getTypesVisibleToCaller(int callingUid, int userId,\n            String opPackageName) {\n        return getTypesForCaller(callingUid, userId, true /* isOtherwisePermitted*/);\n    }\n\n    private List<String> getTypesManagedByCaller(int callingUid, int userId) {\n        return getTypesForCaller(callingUid, userId, false);\n    }\n\n    private List<String> getTypesForCaller(\n            int callingUid, int userId, boolean isOtherwisePermitted) {\n        List<String> managedAccountTypes = new ArrayList<>();\n        final long identityToken = Binder.clearCallingIdentity();\n        Collection<RegisteredServicesCache.ServiceInfo<AuthenticatorDescription>> serviceInfos;\n        try {\n            serviceInfos = mAuthenticatorCache.getAllServices(userId);\n        } finally {\n            Binder.restoreCallingIdentity(identityToken);\n        }\n\n        PackageManagerInternal pmi = LocalServices.getService(PackageManagerInternal.class);\n        for (RegisteredServicesCache.ServiceInfo<AuthenticatorDescription> serviceInfo :\n                serviceInfos) {\n            if (isOtherwisePermitted || pmi.hasSignatureCapability(\n                    serviceInfo.uid, callingUid,\n                    PackageParser.SigningDetails.CertCapabilities.AUTH)) {\n                managedAccountTypes.add(serviceInfo.type.type);\n            }\n        }\n        return managedAccountTypes;\n    }\n\n    private boolean isAccountPresentForCaller(String accountName, String accountType) {\n        if (getUserAccountsForCaller().accountCache.containsKey(accountType)) {\n            for (Account account : getUserAccountsForCaller().accountCache.get(accountType)) {\n                if (account.name.equals(accountName)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private static void checkManageUsersPermission(String message) {\n        if (ActivityManager.checkComponentPermission(\n                android.Manifest.permission.MANAGE_USERS, Binder.getCallingUid(), -1, true)\n                != PackageManager.PERMISSION_GRANTED) {\n            throw new SecurityException(\"You need MANAGE_USERS permission to: \" + message);\n        }\n    }\n\n    private static void checkManageOrCreateUsersPermission(String message) {\n        if (ActivityManager.checkComponentPermission(android.Manifest.permission.MANAGE_USERS,\n                Binder.getCallingUid(), -1, true) != PackageManager.PERMISSION_GRANTED &&\n                ActivityManager.checkComponentPermission(android.Manifest.permission.CREATE_USERS,\n                        Binder.getCallingUid(), -1, true) != PackageManager.PERMISSION_GRANTED) {\n            throw new SecurityException(\"You need MANAGE_USERS or CREATE_USERS permission to: \"\n                    + message);\n        }\n    }\n\n    private boolean hasExplicitlyGrantedPermission(Account account, String authTokenType,\n            int callerUid) {\n        if (UserHandle.getAppId(callerUid) == Process.SYSTEM_UID) {\n            return true;\n        }\n        UserAccounts accounts = getUserAccounts(UserHandle.getUserId(callerUid));\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                long grantsCount;\n                if (authTokenType != null) {\n                    grantsCount = accounts.accountsDb\n                            .findMatchingGrantsCount(callerUid, authTokenType, account);\n                } else {\n                    grantsCount = accounts.accountsDb.findMatchingGrantsCountAnyToken(callerUid,\n                            account);\n                }\n                final boolean permissionGranted = grantsCount > 0;\n\n                if (!permissionGranted && ActivityManager.isRunningInTestHarness()) {\n                    // TODO: Skip this check when running automated tests. Replace this\n                    // with a more general solution.\n                    Log.d(TAG, \"no credentials permission for usage of \"\n                            + account.toSafeString() + \", \"\n                            + authTokenType + \" by uid \" + callerUid\n                            + \" but ignoring since device is in test harness.\");\n                    return true;\n                }\n                return permissionGranted;\n            }\n        }\n    }\n\n    private boolean isSystemUid(int callingUid) {\n        String[] packages = null;\n        final long ident = Binder.clearCallingIdentity();\n        try {\n            packages = mPackageManager.getPackagesForUid(callingUid);\n            if (packages != null) {\n                for (String name : packages) {\n                    try {\n                        PackageInfo packageInfo =\n                                mPackageManager.getPackageInfo(name, 0 /* flags */);\n                        if (packageInfo != null\n                                && (packageInfo.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM)\n                                != 0) {\n                            return true;\n                        }\n                    } catch (NameNotFoundException e) {\n                        Log.w(TAG, String.format(\"Could not find package [%s]\", name), e);\n                    }\n                }\n            } else {\n                Log.w(TAG, \"No known packages with uid \" + callingUid);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n        return false;\n    }\n\n    /** Succeeds if any of the specified permissions are granted. */\n    private void checkReadAccountsPermitted(\n            int callingUid,\n            String accountType,\n            int userId,\n            String opPackageName) {\n        if (!isAccountVisibleToCaller(accountType, callingUid, userId, opPackageName)) {\n            String msg = String.format(\n                    \"caller uid %s cannot access %s accounts\",\n                    callingUid,\n                    accountType);\n            Log.w(TAG, \"  \" + msg);\n            throw new SecurityException(msg);\n        }\n    }\n\n    private boolean canUserModifyAccounts(int userId, int callingUid) {\n        // the managing app can always modify accounts\n        if (isProfileOwner(callingUid)) {\n            return true;\n        }\n        if (getUserManager().getUserRestrictions(new UserHandle(userId))\n                .getBoolean(UserManager.DISALLOW_MODIFY_ACCOUNTS)) {\n            return false;\n        }\n        return true;\n    }\n\n    private boolean canUserModifyAccountsForType(int userId, String accountType, int callingUid) {\n        // the managing app can always modify accounts\n        if (isProfileOwner(callingUid)) {\n            return true;\n        }\n        DevicePolicyManager dpm = (DevicePolicyManager) mContext\n                .getSystemService(Context.DEVICE_POLICY_SERVICE);\n        String[] typesArray = dpm.getAccountTypesWithManagementDisabledAsUser(userId);\n        if (typesArray == null) {\n            return true;\n        }\n        for (String forbiddenType : typesArray) {\n            if (forbiddenType.equals(accountType)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private boolean isProfileOwner(int uid) {\n        final DevicePolicyManagerInternal dpmi =\n                LocalServices.getService(DevicePolicyManagerInternal.class);\n        //TODO(b/169395065) Figure out if this flow makes sense in Device Owner mode.\n        return (dpmi != null) && (dpmi.isActiveProfileOwner(uid) || dpmi.isActiveDeviceOwner(uid));\n    }\n\n    @Override\n    public void updateAppPermission(Account account, String authTokenType, int uid, boolean value)\n            throws RemoteException {\n        final int callingUid = getCallingUid();\n\n        if (UserHandle.getAppId(callingUid) != Process.SYSTEM_UID) {\n            throw new SecurityException();\n        }\n\n        if (value) {\n            grantAppPermission(account, authTokenType, uid);\n        } else {\n            revokeAppPermission(account, authTokenType, uid);\n        }\n    }\n\n    /**\n     * Allow callers with the given uid permission to get credentials for account/authTokenType.\n     * <p>\n     * Although this is public it can only be accessed via the AccountManagerService object\n     * which is in the system. This means we don't need to protect it with permissions.\n     * @hide\n     */\n    void grantAppPermission(Account account, String authTokenType, int uid) {\n        if (account == null || authTokenType == null) {\n            Log.e(TAG, \"grantAppPermission: called with invalid arguments\", new Exception());\n            return;\n        }\n        UserAccounts accounts = getUserAccounts(UserHandle.getUserId(uid));\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                long accountId = accounts.accountsDb.findDeAccountId(account);\n                if (accountId >= 0) {\n                    accounts.accountsDb.insertGrant(accountId, authTokenType, uid);\n                }\n                cancelNotification(\n                        getCredentialPermissionNotificationId(account, authTokenType, uid),\n                        UserHandle.of(accounts.userId));\n\n                cancelAccountAccessRequestNotificationIfNeeded(account, uid, true);\n            }\n        }\n\n        // Listeners are a final CopyOnWriteArrayList, hence no lock needed.\n        for (AccountManagerInternal.OnAppPermissionChangeListener listener\n                : mAppPermissionChangeListeners) {\n            mHandler.post(() -> listener.onAppPermissionChanged(account, uid));\n        }\n    }\n\n    /**\n     * Don't allow callers with the given uid permission to get credentials for\n     * account/authTokenType.\n     * <p>\n     * Although this is public it can only be accessed via the AccountManagerService object\n     * which is in the system. This means we don't need to protect it with permissions.\n     * @hide\n     */\n    private void revokeAppPermission(Account account, String authTokenType, int uid) {\n        if (account == null || authTokenType == null) {\n            Log.e(TAG, \"revokeAppPermission: called with invalid arguments\", new Exception());\n            return;\n        }\n        UserAccounts accounts = getUserAccounts(UserHandle.getUserId(uid));\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                accounts.accountsDb.beginTransaction();\n                try {\n                    long accountId = accounts.accountsDb.findDeAccountId(account);\n                    if (accountId >= 0) {\n                        accounts.accountsDb.deleteGrantsByAccountIdAuthTokenTypeAndUid(\n                                accountId, authTokenType, uid);\n                        accounts.accountsDb.setTransactionSuccessful();\n                    }\n                } finally {\n                    accounts.accountsDb.endTransaction();\n                }\n\n                cancelNotification(\n                        getCredentialPermissionNotificationId(account, authTokenType, uid),\n                        UserHandle.of(accounts.userId));\n            }\n        }\n\n        // Listeners are a final CopyOnWriteArrayList, hence no lock needed.\n        for (AccountManagerInternal.OnAppPermissionChangeListener listener\n                : mAppPermissionChangeListeners) {\n            mHandler.post(() -> listener.onAppPermissionChanged(account, uid));\n        }\n    }\n\n    private void removeAccountFromCacheLocked(UserAccounts accounts, Account account) {\n        final Account[] oldAccountsForType = accounts.accountCache.get(account.type);\n        if (oldAccountsForType != null) {\n            ArrayList<Account> newAccountsList = new ArrayList<>();\n            for (Account curAccount : oldAccountsForType) {\n                if (!curAccount.equals(account)) {\n                    newAccountsList.add(curAccount);\n                }\n            }\n            if (newAccountsList.isEmpty()) {\n                accounts.accountCache.remove(account.type);\n            } else {\n                Account[] newAccountsForType = new Account[newAccountsList.size()];\n                newAccountsForType = newAccountsList.toArray(newAccountsForType);\n                accounts.accountCache.put(account.type, newAccountsForType);\n            }\n        }\n        accounts.userDataCache.remove(account);\n        accounts.authTokenCache.remove(account);\n        accounts.previousNameCache.remove(account);\n        accounts.visibilityCache.remove(account);\n\n        AccountManager.invalidateLocalAccountsDataCaches();\n    }\n\n    /**\n     * This assumes that the caller has already checked that the account is not already present.\n     * IMPORTANT: The account being inserted will begin to be tracked for access in remote\n     * processes and if you will return this account to apps you should return the result.\n     * @return The inserted account which is a new instance that is being tracked.\n     */\n    private Account insertAccountIntoCacheLocked(UserAccounts accounts, Account account) {\n        Account[] accountsForType = accounts.accountCache.get(account.type);\n        int oldLength = (accountsForType != null) ? accountsForType.length : 0;\n        Account[] newAccountsForType = new Account[oldLength + 1];\n        if (accountsForType != null) {\n            System.arraycopy(accountsForType, 0, newAccountsForType, 0, oldLength);\n        }\n        String token = account.getAccessId() != null ? account.getAccessId()\n                : UUID.randomUUID().toString();\n        newAccountsForType[oldLength] = new Account(account, token);\n        accounts.accountCache.put(account.type, newAccountsForType);\n        AccountManager.invalidateLocalAccountsDataCaches();\n        return newAccountsForType[oldLength];\n    }\n\n    @NonNull\n    private Account[] filterAccounts(UserAccounts accounts, Account[] unfiltered, int callingUid,\n            @Nullable String callingPackage, boolean includeManagedNotVisible) {\n        String visibilityFilterPackage = callingPackage;\n        if (visibilityFilterPackage == null) {\n            visibilityFilterPackage = getPackageNameForUid(callingUid);\n        }\n        Map<Account, Integer> firstPass = new LinkedHashMap<>();\n        for (Account account : unfiltered) {\n            int visibility = resolveAccountVisibility(account, visibilityFilterPackage, accounts);\n            if ((visibility == AccountManager.VISIBILITY_VISIBLE\n                    || visibility == AccountManager.VISIBILITY_USER_MANAGED_VISIBLE)\n                    || (includeManagedNotVisible\n                            && (visibility\n                                    == AccountManager.VISIBILITY_USER_MANAGED_NOT_VISIBLE))) {\n                firstPass.put(account, visibility);\n            }\n        }\n        Map<Account, Integer> secondPass =\n                filterSharedAccounts(accounts, firstPass, callingUid, callingPackage);\n\n        Account[] filtered = new Account[secondPass.size()];\n        filtered = secondPass.keySet().toArray(filtered);\n        return filtered;\n    }\n\n    @NonNull\n    private Map<Account, Integer> filterSharedAccounts(UserAccounts userAccounts,\n            @NonNull Map<Account, Integer> unfiltered, int callingUid,\n            @Nullable String callingPackage) {\n        // first part is to filter shared accounts.\n        // unfiltered type check is not necessary.\n        if (getUserManager() == null || userAccounts == null || userAccounts.userId < 0\n                || callingUid == Process.SYSTEM_UID) {\n            return unfiltered;\n        }\n        UserInfo user = getUserManager().getUserInfo(userAccounts.userId);\n        if (user != null && user.isRestricted()) {\n            String[] packages = mPackageManager.getPackagesForUid(callingUid);\n            if (packages == null) {\n                packages = new String[] {};\n            }\n            // If any of the packages is a visible listed package, return the full set,\n            // otherwise return non-shared accounts only.\n            // This might be a temporary way to specify a visible list\n            String visibleList = mContext.getResources().getString(\n                    com.android.internal.R.string.config_appsAuthorizedForSharedAccounts);\n            for (String packageName : packages) {\n                if (visibleList.contains(\";\" + packageName + \";\")) {\n                    return unfiltered;\n                }\n            }\n            Account[] sharedAccounts = getSharedAccountsAsUser(userAccounts.userId);\n            if (ArrayUtils.isEmpty(sharedAccounts)) {\n                return unfiltered;\n            }\n            String requiredAccountType = \"\";\n            try {\n                // If there's an explicit callingPackage specified, check if that package\n                // opted in to see restricted accounts.\n                if (callingPackage != null) {\n                    PackageInfo pi = mPackageManager.getPackageInfo(callingPackage, 0);\n                    if (pi != null && pi.restrictedAccountType != null) {\n                        requiredAccountType = pi.restrictedAccountType;\n                    }\n                } else {\n                    // Otherwise check if the callingUid has a package that has opted in\n                    for (String packageName : packages) {\n                        PackageInfo pi = mPackageManager.getPackageInfo(packageName, 0);\n                        if (pi != null && pi.restrictedAccountType != null) {\n                            requiredAccountType = pi.restrictedAccountType;\n                            break;\n                        }\n                    }\n                }\n            } catch (NameNotFoundException e) {\n                Log.d(TAG, \"Package not found \" + e.getMessage());\n            }\n            Map<Account, Integer> filtered = new LinkedHashMap<>();\n            for (Map.Entry<Account, Integer> entry : unfiltered.entrySet()) {\n                Account account = entry.getKey();\n                if (account.type.equals(requiredAccountType)) {\n                    filtered.put(account, entry.getValue());\n                } else {\n                    boolean found = false;\n                    for (Account shared : sharedAccounts) {\n                        if (shared.equals(account)) {\n                            found = true;\n                            break;\n                        }\n                    }\n                    if (!found) {\n                        filtered.put(account, entry.getValue());\n                    }\n                }\n            }\n            return filtered;\n        } else {\n            return unfiltered;\n        }\n    }\n\n    /*\n     * packageName can be null. If not null, it should be used to filter out restricted accounts\n     * that the package is not allowed to access.\n     *\n     * <p>The method shouldn't be called with UserAccounts#cacheLock held, otherwise it will cause a\n     * deadlock\n     */\n    @NonNull\n    protected Account[] getAccountsFromCache(UserAccounts userAccounts, String accountType,\n            int callingUid, @Nullable String callingPackage, boolean includeManagedNotVisible) {\n        Preconditions.checkState(!Thread.holdsLock(userAccounts.cacheLock),\n                \"Method should not be called with cacheLock\");\n        if (accountType != null) {\n            Account[] accounts;\n            synchronized (userAccounts.cacheLock) {\n                accounts = userAccounts.accountCache.get(accountType);\n            }\n            if (accounts == null) {\n                return EMPTY_ACCOUNT_ARRAY;\n            } else {\n                return filterAccounts(userAccounts, Arrays.copyOf(accounts, accounts.length),\n                        callingUid, callingPackage, includeManagedNotVisible);\n            }\n        } else {\n            int totalLength = 0;\n            Account[] accountsArray;\n            synchronized (userAccounts.cacheLock) {\n                for (Account[] accounts : userAccounts.accountCache.values()) {\n                    totalLength += accounts.length;\n                }\n                if (totalLength == 0) {\n                    return EMPTY_ACCOUNT_ARRAY;\n                }\n                accountsArray = new Account[totalLength];\n                totalLength = 0;\n                for (Account[] accountsOfType : userAccounts.accountCache.values()) {\n                    System.arraycopy(accountsOfType, 0, accountsArray, totalLength,\n                            accountsOfType.length);\n                    totalLength += accountsOfType.length;\n                }\n            }\n            return filterAccounts(userAccounts, accountsArray, callingUid, callingPackage,\n                    includeManagedNotVisible);\n        }\n    }\n\n    /** protected by the {@code dbLock}, {@code cacheLock} */\n    protected void writeUserDataIntoCacheLocked(UserAccounts accounts,\n            Account account, String key, String value) {\n        Map<String, String> userDataForAccount = accounts.userDataCache.get(account);\n        if (userDataForAccount == null) {\n            userDataForAccount = accounts.accountsDb.findUserExtrasForAccount(account);\n            accounts.userDataCache.put(account, userDataForAccount);\n        }\n        if (value == null) {\n            userDataForAccount.remove(key);\n        } else {\n            userDataForAccount.put(key, value);\n        }\n    }\n\n    protected String readCachedTokenInternal(\n            UserAccounts accounts,\n            Account account,\n            String tokenType,\n            String callingPackage,\n            byte[] pkgSigDigest) {\n        synchronized (accounts.cacheLock) {\n            return accounts.accountTokenCaches.get(\n                    account, tokenType, callingPackage, pkgSigDigest);\n        }\n    }\n\n    /** protected by the {@code dbLock}, {@code cacheLock} */\n    protected void writeAuthTokenIntoCacheLocked(UserAccounts accounts,\n            Account account, String key, String value) {\n        Map<String, String> authTokensForAccount = accounts.authTokenCache.get(account);\n        if (authTokensForAccount == null) {\n            authTokensForAccount = accounts.accountsDb.findAuthTokensByAccount(account);\n            accounts.authTokenCache.put(account, authTokensForAccount);\n        }\n        if (value == null) {\n            authTokensForAccount.remove(key);\n        } else {\n            authTokensForAccount.put(key, value);\n        }\n    }\n\n    protected String readAuthTokenInternal(UserAccounts accounts, Account account,\n            String authTokenType) {\n        // Fast path - check if account is already cached\n        synchronized (accounts.cacheLock) {\n            Map<String, String> authTokensForAccount = accounts.authTokenCache.get(account);\n            if (authTokensForAccount != null) {\n                return authTokensForAccount.get(authTokenType);\n            }\n        }\n        // If not cached yet - do slow path and sync with db if necessary\n        synchronized (accounts.dbLock) {\n            synchronized (accounts.cacheLock) {\n                Map<String, String> authTokensForAccount = accounts.authTokenCache.get(account);\n                if (authTokensForAccount == null) {\n                    // need to populate the cache for this account\n                    authTokensForAccount = accounts.accountsDb.findAuthTokensByAccount(account);\n                    accounts.authTokenCache.put(account, authTokensForAccount);\n                }\n                return authTokensForAccount.get(authTokenType);\n            }\n        }\n    }\n\n    private String readUserDataInternal(UserAccounts accounts, Account account, String key) {\n        Map<String, String> userDataForAccount;\n        // Fast path - check if data is already cached\n        synchronized (accounts.cacheLock) {\n            userDataForAccount = accounts.userDataCache.get(account);\n        }\n        // If not cached yet - do slow path and sync with db if necessary\n        if (userDataForAccount == null) {\n            synchronized (accounts.dbLock) {\n                synchronized (accounts.cacheLock) {\n                    userDataForAccount = accounts.userDataCache.get(account);\n                    if (userDataForAccount == null) {\n                        // need to populate the cache for this account\n                        userDataForAccount = accounts.accountsDb.findUserExtrasForAccount(account);\n                        accounts.userDataCache.put(account, userDataForAccount);\n                    }\n                }\n            }\n        }\n        return userDataForAccount.get(key);\n    }\n\n    private Context getContextForUser(UserHandle user) {\n        try {\n            return mContext.createPackageContextAsUser(mContext.getPackageName(), 0, user);\n        } catch (NameNotFoundException e) {\n            // Default to mContext, not finding the package system is running as is unlikely.\n            return mContext;\n        }\n    }\n\n    private void sendResponse(IAccountManagerResponse response, Bundle result) {\n        try {\n            response.onResult(result);\n        } catch (RemoteException e) {\n            // if the caller is dead then there is no one to care about remote\n            // exceptions\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"failure while notifying response\", e);\n            }\n        }\n    }\n\n    private void sendErrorResponse(IAccountManagerResponse response, int errorCode,\n            String errorMessage) {\n        try {\n            response.onError(errorCode, errorMessage);\n        } catch (RemoteException e) {\n            // if the caller is dead then there is no one to care about remote\n            // exceptions\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"failure while notifying response\", e);\n            }\n        }\n    }\n\n    private final class AccountManagerInternalImpl extends AccountManagerInternal {\n        private final Object mLock = new Object();\n\n        @GuardedBy(\"mLock\")\n        private AccountManagerBackupHelper mBackupHelper;\n\n        @Override\n        public void requestAccountAccess(@NonNull Account account, @NonNull String packageName,\n                @IntRange(from = 0) int userId, @NonNull RemoteCallback callback) {\n            if (account == null) {\n                Slog.w(TAG, \"account cannot be null\");\n                return;\n            }\n            if (packageName == null) {\n                Slog.w(TAG, \"packageName cannot be null\");\n                return;\n            }\n            if (userId < UserHandle.USER_SYSTEM) {\n                Slog.w(TAG, \"user id must be concrete\");\n                return;\n            }\n            if (callback == null) {\n                Slog.w(TAG, \"callback cannot be null\");\n                return;\n            }\n\n            int visibility =\n                resolveAccountVisibility(account, packageName, getUserAccounts(userId));\n            if (visibility == AccountManager.VISIBILITY_NOT_VISIBLE) {\n                Slog.w(TAG, \"requestAccountAccess: account is hidden\");\n                return;\n            }\n\n            if (AccountManagerService.this.hasAccountAccess(account, packageName,\n                    new UserHandle(userId))) {\n                Bundle result = new Bundle();\n                result.putBoolean(AccountManager.KEY_BOOLEAN_RESULT, true);\n                callback.sendResult(result);\n                return;\n            }\n\n            final int uid;\n            try {\n                final long identityToken = clearCallingIdentity();\n                try {\n                    uid = mPackageManager.getPackageUidAsUser(packageName, userId);\n                } finally {\n                    restoreCallingIdentity(identityToken);\n                }\n            } catch (NameNotFoundException e) {\n                Slog.e(TAG, \"Unknown package \" + packageName);\n                return;\n            }\n\n            Intent intent = newRequestAccountAccessIntent(account, packageName, uid, callback);\n            final UserAccounts userAccounts;\n            synchronized (mUsers) {\n                userAccounts = mUsers.get(userId);\n            }\n            SystemNotificationChannels.createAccountChannelForPackage(packageName, uid, mContext);\n            doNotification(userAccounts, account, null, intent, packageName, userId);\n        }\n\n        @Override\n        public void addOnAppPermissionChangeListener(OnAppPermissionChangeListener listener) {\n            // Listeners are a final CopyOnWriteArrayList, hence no lock needed.\n            mAppPermissionChangeListeners.add(listener);\n        }\n\n        @Override\n        public boolean hasAccountAccess(@NonNull Account account, @IntRange(from = 0) int uid) {\n            return AccountManagerService.this.hasAccountAccess(account, null, uid);\n        }\n\n        @Override\n        public byte[] backupAccountAccessPermissions(int userId) {\n            synchronized (mLock) {\n                if (mBackupHelper == null) {\n                    mBackupHelper = new AccountManagerBackupHelper(\n                            AccountManagerService.this, this);\n                }\n                return mBackupHelper.backupAccountAccessPermissions(userId);\n            }\n        }\n\n        @Override\n        public void restoreAccountAccessPermissions(byte[] data, int userId) {\n            synchronized (mLock) {\n                if (mBackupHelper == null) {\n                    mBackupHelper = new AccountManagerBackupHelper(\n                            AccountManagerService.this, this);\n                }\n                mBackupHelper.restoreAccountAccessPermissions(data, userId);\n            }\n        }\n    }\n\n    @VisibleForTesting\n    static class Injector {\n        private final Context mContext;\n\n        public Injector(Context context) {\n            mContext = context;\n        }\n\n        Looper getMessageHandlerLooper() {\n            ServiceThread serviceThread = new ServiceThread(TAG,\n                    android.os.Process.THREAD_PRIORITY_FOREGROUND, true /* allowIo */);\n            serviceThread.start();\n            return serviceThread.getLooper();\n        }\n\n        Context getContext() {\n            return mContext;\n        }\n\n        void addLocalService(AccountManagerInternal service) {\n            LocalServices.addService(AccountManagerInternal.class, service);\n        }\n\n        String getDeDatabaseName(int userId) {\n            File databaseFile = new File(Environment.getDataSystemDeDirectory(userId),\n                    AccountsDb.DE_DATABASE_NAME);\n            return databaseFile.getPath();\n        }\n\n        String getCeDatabaseName(int userId) {\n            File databaseFile = new File(Environment.getDataSystemCeDirectory(userId),\n                    AccountsDb.CE_DATABASE_NAME);\n            return databaseFile.getPath();\n        }\n\n        String getPreNDatabaseName(int userId) {\n            File systemDir = Environment.getDataSystemDirectory();\n            File databaseFile = new File(Environment.getUserSystemDirectory(userId),\n                    PRE_N_DATABASE_NAME);\n            if (userId == 0) {\n                // Migrate old file, if it exists, to the new location.\n                // Make sure the new file doesn't already exist. A placeholder file could have been\n                // accidentally created in the old location,\n                // causing the new one to become corrupted as well.\n                File oldFile = new File(systemDir, PRE_N_DATABASE_NAME);\n                if (oldFile.exists() && !databaseFile.exists()) {\n                    // Check for use directory; create if it doesn't exist, else renameTo will fail\n                    File userDir = Environment.getUserSystemDirectory(userId);\n                    if (!userDir.exists()) {\n                        if (!userDir.mkdirs()) {\n                            throw new IllegalStateException(\n                                    \"User dir cannot be created: \" + userDir);\n                        }\n                    }\n                    if (!oldFile.renameTo(databaseFile)) {\n                        throw new IllegalStateException(\n                                \"User dir cannot be migrated: \" + databaseFile);\n                    }\n                }\n            }\n            return databaseFile.getPath();\n        }\n\n        IAccountAuthenticatorCache getAccountAuthenticatorCache() {\n            return new AccountAuthenticatorCache(mContext);\n        }\n\n        INotificationManager getNotificationManager() {\n            return NotificationManager.getService();\n        }\n    }\n\n    private static class NotificationId {\n        final String mTag;\n        private final int mId;\n\n        NotificationId(String tag, int type) {\n            mTag = tag;\n            mId = type;\n        }\n    }\n}\n```"
                    }
                ]
            }
        ],
        "upstream_patch_content": "From cde345a7ee06db716e613e12a2c218ce248ad1c4 Mon Sep 17 00:00:00 2001\nFrom: Dmitry Dementyev <dementyev@google.com>\nDate: Tue, 1 Oct 2024 14:57:44 -0700\nSubject: [PATCH] Update checkKeyIntent\n\n1) Explicityly set  component after target activity check.\n2) Update Intent subclass check.\n\nBug: 360846772\nTest: manual\nFlag: EXEMPT bugfix\nChange-Id: Ied7961c73299681aa5b523cf3f00fd905893116f\n---\n .../android/server/accounts/AccountManagerService.java   | 9 ++++++---\n 1 file changed, 6 insertions(+), 3 deletions(-)\n\ndiff --git a/services/core/java/com/android/server/accounts/AccountManagerService.java b/services/core/java/com/android/server/accounts/AccountManagerService.java\nindex 3499a3a5edde..0ca3b56486e3 100644\n--- a/services/core/java/com/android/server/accounts/AccountManagerService.java\n+++ b/services/core/java/com/android/server/accounts/AccountManagerService.java\n@@ -5062,6 +5062,8 @@ public class AccountManagerService\n                     Log.e(TAG, String.format(tmpl, activityName, pkgName, mAccountType));\n                     return false;\n                 }\n+                intent.setComponent(targetActivityInfo.getComponentName());\n+                bundle.putParcelable(AccountManager.KEY_INTENT, intent);\n                 return true;\n             } finally {\n                 Binder.restoreCallingIdentity(bid);\n@@ -5083,14 +5085,15 @@ public class AccountManagerService\n             Bundle simulateBundle = p.readBundle();\n             p.recycle();\n             Intent intent = bundle.getParcelable(AccountManager.KEY_INTENT, Intent.class);\n-            if (intent != null && intent.getClass() != Intent.class) {\n-                return false;\n-            }\n             Intent simulateIntent = simulateBundle.getParcelable(AccountManager.KEY_INTENT,\n                     Intent.class);\n             if (intent == null) {\n                 return (simulateIntent == null);\n             }\n+            if (intent.getClass() != Intent.class || simulateIntent.getClass() != Intent.class) {\n+                return false;\n+            }\n+\n             if (!intent.filterEquals(simulateIntent)) {\n                 return false;\n             }\n-- \n2.39.5 (Apple Git-154)\n\n",
        "upstream_commits": [
            "cde345a7ee06db716e613e12a2c218ce248ad1c4"
        ]
    },
    {
        "id": "ASB-A-289375038",
        "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-289375038",
        "severity": "High",
        "failures": [
            {
                "downstream_version": "13",
                "branch_used": "android13-release",
                "downstream_patch": "038b1e8626399ff3f374d5af987e3efd64a19321",
                "repo_path": "android_repos/Bluetooth",
                "result": "failure",
                "downstream_patch_content": "commit 038b1e8626399ff3f374d5af987e3efd64a19321\nAuthor: Brian Delwiche <delwiche@google.com>\nDate:   Thu Nov 14 00:35:48 2024 +0000\n\n    Reset permissions for not bonded device\n    \n    According to the PBAP specification,\n    The PSE user shall have to confirm at least the first Phone Book Access\n    Profile connection from each new PCE.\n    \n    According to the MAP specification,\n    The MCE and MSE shall be bonded before setting up a Message Access Profile\n    connection.\n    \n    Let's remove the permissions when the device is unbonded.\n    \n    This is a backport of change ag/30386015 but requires minor changes to\n    logic.\n    \n    Flag: EXEMPT, security fix\n    Bug: 289375038\n    Bug: 289811388\n    Test: atest BluetoothInstrumentationTests\n    Ignore-AOSP-First: security fix\n    Merged-In: I94478a4a45a434732d4bc4810da31ef45ef891af\n    Change-Id: I8b9b29310db2d14e5dfaddc81a682366fbef42d3\n\ndiff --git a/android/app/src/com/android/bluetooth/btservice/BondStateMachine.java b/android/app/src/com/android/bluetooth/btservice/BondStateMachine.java\nindex d62d7ba06d..1a1c912f3f 100644\n--- a/android/app/src/com/android/bluetooth/btservice/BondStateMachine.java\n+++ b/android/app/src/com/android/bluetooth/btservice/BondStateMachine.java\n@@ -439,6 +439,13 @@ final class BondStateMachine extends StateMachine {\n             }\n         }\n \n+        if (newState == BluetoothDevice.BOND_NONE) {\n+            // Remove the permissions for unbonded devices\n+            mAdapterService.setMessageAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+            mAdapterService.setPhonebookAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+            mAdapterService.setSimAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+        }\n+\n         Intent intent = new Intent(BluetoothDevice.ACTION_BOND_STATE_CHANGED);\n         intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);\n         intent.putExtra(BluetoothDevice.EXTRA_BOND_STATE, newState);\n",
                "file_conflicts": [
                    {
                        "file_name": "android/app/src/com/android/bluetooth/btservice/AdapterService.java",
                        "total_hunks": 2,
                        "failed_hunks": [
                            1,
                            2
                        ],
                        "inline_merge_conflicts": [
                            {
                                "hunk_number": 1,
                                "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n\n=======\n\n        if (toState == BOND_NONE) {\n            // Remove the permissions for unbonded devices\n            setMessageAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n            setPhonebookAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n            setSimAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n        }\n    }\n>>>>>>> UPSTREAM PATCH (commit 771aed3ea225d9ca2ef91e88f45f330ced952772)"
                            }
                        ],
                        "rej_file_content": "```diff\n--- android/app/src/com/android/bluetooth/btservice/AdapterService.java\n+++ android/app/src/com/android/bluetooth/btservice/AdapterService.java\n@@ -27,6 +27,7 @@ import static android.bluetooth.BluetoothAdapter.SCAN_MODE_CONNECTABLE;\n import static android.bluetooth.BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE;\n import static android.bluetooth.BluetoothAdapter.SCAN_MODE_NONE;\n import static android.bluetooth.BluetoothDevice.BATTERY_LEVEL_UNKNOWN;\n+import static android.bluetooth.BluetoothDevice.BOND_NONE;\n import static android.bluetooth.BluetoothDevice.TRANSPORT_AUTO;\n import static android.bluetooth.IBluetoothLeAudio.LE_AUDIO_GROUP_ID_INVALID;\n import static android.text.format.DateUtils.MINUTE_IN_MILLIS;\n@@ -6121,6 +6122,13 @@ public class AdapterService extends Service {\n             mCsipSetCoordinatorService.handleBondStateChanged(device, fromState, toState);\n         }\n         mDatabaseManager.handleBondStateChanged(device, fromState, toState);\n+\n+        if (toState == BOND_NONE) {\n+            // Remove the permissions for unbonded devices\n+            setMessageAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+            setPhonebookAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+            setSimAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+        }\n     }\n \n     static int convertScanModeToHal(int mode) {\n```",
                        "patch_apply_output": "patching file android/app/src/com/android/bluetooth/btservice/AdapterService.java\nHunk #1 FAILED at 27.\nHunk #2 FAILED at 6121.\n2 out of 2 hunks FAILED -- saving rejects to file android/app/src/com/android/bluetooth/btservice/AdapterService.java.rej",
                        "inline_merge_output": "patching file android/app/src/com/android/bluetooth/btservice/AdapterService.java\nHunk #1 already applied at 30.\nHunk #2 NOT MERGED at 6125-6135.",
                        "upstream_file_content": "```java\n/*\n * Copyright (C) 2012 The Android Open Source Project\n * Copyright (C) 2016-2017 The Linux Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.bluetooth.btservice;\n\nimport static android.Manifest.permission.BLUETOOTH_CONNECT;\nimport static android.Manifest.permission.BLUETOOTH_PRIVILEGED;\nimport static android.Manifest.permission.BLUETOOTH_SCAN;\nimport static android.Manifest.permission.DUMP;\nimport static android.Manifest.permission.LOCAL_MAC_ADDRESS;\nimport static android.Manifest.permission.MODIFY_PHONE_STATE;\nimport static android.bluetooth.BluetoothAdapter.SCAN_MODE_CONNECTABLE;\nimport static android.bluetooth.BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE;\nimport static android.bluetooth.BluetoothAdapter.SCAN_MODE_NONE;\nimport static android.bluetooth.BluetoothDevice.BATTERY_LEVEL_UNKNOWN;\nimport static android.bluetooth.BluetoothDevice.BOND_NONE;\nimport static android.bluetooth.BluetoothDevice.TRANSPORT_AUTO;\nimport static android.bluetooth.IBluetoothLeAudio.LE_AUDIO_GROUP_ID_INVALID;\nimport static android.text.format.DateUtils.MINUTE_IN_MILLIS;\nimport static android.text.format.DateUtils.SECOND_IN_MILLIS;\n\nimport static com.android.bluetooth.ChangeIds.ENFORCE_CONNECT;\nimport static com.android.bluetooth.Utils.callerIsSystem;\nimport static com.android.bluetooth.Utils.callerIsSystemOrActiveOrManagedUser;\nimport static com.android.bluetooth.Utils.getBytesFromAddress;\nimport static com.android.bluetooth.Utils.isDualModeAudioEnabled;\nimport static com.android.bluetooth.Utils.isPackageNameAccurate;\n\nimport static java.util.Objects.requireNonNull;\n\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.annotation.RequiresPermission;\nimport android.annotation.SuppressLint;\nimport android.app.AppOpsManager;\nimport android.app.PendingIntent;\nimport android.app.Service;\nimport android.app.admin.DevicePolicyManager;\nimport android.app.compat.CompatChanges;\nimport android.bluetooth.BluetoothA2dp;\nimport android.bluetooth.BluetoothActivityEnergyInfo;\nimport android.bluetooth.BluetoothAdapter;\nimport android.bluetooth.BluetoothAdapter.ActiveDeviceProfile;\nimport android.bluetooth.BluetoothAdapter.ActiveDeviceUse;\nimport android.bluetooth.BluetoothDevice;\nimport android.bluetooth.BluetoothFrameworkInitializer;\nimport android.bluetooth.BluetoothMap;\nimport android.bluetooth.BluetoothProfile;\nimport android.bluetooth.BluetoothProtoEnums;\nimport android.bluetooth.BluetoothQualityReport;\nimport android.bluetooth.BluetoothSap;\nimport android.bluetooth.BluetoothServerSocket;\nimport android.bluetooth.BluetoothSinkAudioPolicy;\nimport android.bluetooth.BluetoothSocket;\nimport android.bluetooth.BluetoothStatusCodes;\nimport android.bluetooth.BluetoothUtils;\nimport android.bluetooth.BluetoothUuid;\nimport android.bluetooth.BufferConstraints;\nimport android.bluetooth.IBluetooth;\nimport android.bluetooth.IBluetoothActivityEnergyInfoListener;\nimport android.bluetooth.IBluetoothCallback;\nimport android.bluetooth.IBluetoothConnectionCallback;\nimport android.bluetooth.IBluetoothMetadataListener;\nimport android.bluetooth.IBluetoothOobDataCallback;\nimport android.bluetooth.IBluetoothPreferredAudioProfilesCallback;\nimport android.bluetooth.IBluetoothQualityReportReadyCallback;\nimport android.bluetooth.IBluetoothSocketManager;\nimport android.bluetooth.IncomingRfcommSocketInfo;\nimport android.bluetooth.OobData;\nimport android.bluetooth.UidTraffic;\nimport android.bluetooth.rfcomm.BluetoothRfcommProtoEnums;\nimport android.companion.CompanionDeviceManager;\nimport android.content.AttributionSource;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.SharedPreferences;\nimport android.content.pm.PackageManager;\nimport android.hardware.display.DisplayManager;\nimport android.os.AsyncTask;\nimport android.os.BatteryStatsManager;\nimport android.os.Binder;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.ParcelUuid;\nimport android.os.Parcelable;\nimport android.os.PowerManager;\nimport android.os.Process;\nimport android.os.RemoteCallbackList;\nimport android.os.RemoteException;\nimport android.os.SystemClock;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.provider.DeviceConfig;\nimport android.provider.Settings;\nimport android.sysprop.BluetoothProperties;\nimport android.text.TextUtils;\nimport android.util.Base64;\nimport android.util.Log;\nimport android.util.SparseArray;\n\nimport com.android.bluetooth.BluetoothMetricsProto;\nimport com.android.bluetooth.BluetoothStatsLog;\nimport com.android.bluetooth.R;\nimport com.android.bluetooth.Utils;\nimport com.android.bluetooth.a2dp.A2dpService;\nimport com.android.bluetooth.a2dpsink.A2dpSinkService;\nimport com.android.bluetooth.avrcp.AvrcpTargetService;\nimport com.android.bluetooth.avrcpcontroller.AvrcpControllerService;\nimport com.android.bluetooth.bas.BatteryService;\nimport com.android.bluetooth.bass_client.BassClientService;\nimport com.android.bluetooth.btservice.InteropUtil.InteropFeature;\nimport com.android.bluetooth.btservice.RemoteDevices.DeviceProperties;\nimport com.android.bluetooth.btservice.bluetoothkeystore.BluetoothKeystoreNativeInterface;\nimport com.android.bluetooth.btservice.bluetoothkeystore.BluetoothKeystoreService;\nimport com.android.bluetooth.btservice.storage.DatabaseManager;\nimport com.android.bluetooth.btservice.storage.MetadataDatabase;\nimport com.android.bluetooth.csip.CsipSetCoordinatorService;\nimport com.android.bluetooth.flags.Flags;\nimport com.android.bluetooth.gatt.GattService;\nimport com.android.bluetooth.hap.HapClientService;\nimport com.android.bluetooth.hearingaid.HearingAidService;\nimport com.android.bluetooth.hfp.HeadsetService;\nimport com.android.bluetooth.hfpclient.HeadsetClientService;\nimport com.android.bluetooth.hid.HidDeviceService;\nimport com.android.bluetooth.hid.HidHostService;\nimport com.android.bluetooth.le_audio.LeAudioService;\nimport com.android.bluetooth.le_scan.ScanController;\nimport com.android.bluetooth.le_scan.ScanManager;\nimport com.android.bluetooth.map.BluetoothMapService;\nimport com.android.bluetooth.mapclient.MapClientService;\nimport com.android.bluetooth.mcp.McpService;\nimport com.android.bluetooth.opp.BluetoothOppService;\nimport com.android.bluetooth.pan.PanService;\nimport com.android.bluetooth.pbap.BluetoothPbapService;\nimport com.android.bluetooth.pbapclient.PbapClientService;\nimport com.android.bluetooth.sap.SapService;\nimport com.android.bluetooth.sdp.SdpManager;\nimport com.android.bluetooth.tbs.TbsService;\nimport com.android.bluetooth.telephony.BluetoothInCallService;\nimport com.android.bluetooth.vc.VolumeControlService;\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.modules.expresslog.Counter;\nimport com.android.modules.utils.BackgroundThread;\nimport com.android.modules.utils.BytesMatcher;\n\nimport libcore.util.SneakyThrow;\n\nimport com.google.common.base.Ascii;\nimport com.google.common.collect.EvictingQueue;\nimport com.google.protobuf.InvalidProtocolBufferException;\n\nimport java.io.FileDescriptor;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.time.Duration;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.Executor;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\n\npublic class AdapterService extends Service {\n    private static final String TAG = \"BluetoothAdapterService\";\n\n    private static final int MESSAGE_PROFILE_SERVICE_STATE_CHANGED = 1;\n    private static final int MESSAGE_PROFILE_SERVICE_REGISTERED = 2;\n    private static final int MESSAGE_PROFILE_SERVICE_UNREGISTERED = 3;\n    private static final int MESSAGE_PREFERRED_AUDIO_PROFILES_AUDIO_FRAMEWORK_TIMEOUT = 4;\n\n    private static final int CONTROLLER_ENERGY_UPDATE_TIMEOUT_MILLIS = 100;\n    private static final int MIN_ADVT_INSTANCES_FOR_MA = 5;\n    private static final int MIN_OFFLOADED_FILTERS = 10;\n    private static final int MIN_OFFLOADED_SCAN_STORAGE_BYTES = 1024;\n\n    private static final Duration PENDING_SOCKET_HANDOFF_TIMEOUT = Duration.ofMinutes(1);\n    private static final Duration GENERATE_LOCAL_OOB_DATA_TIMEOUT = Duration.ofSeconds(2);\n    private static final Duration PREFERRED_AUDIO_PROFILE_CHANGE_TIMEOUT = Duration.ofSeconds(10);\n\n    static final String PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE = \"phonebook_access_permission\";\n    static final String MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE = \"message_access_permission\";\n    static final String SIM_ACCESS_PERMISSION_PREFERENCE_FILE = \"sim_access_permission\";\n\n    private static BluetoothProperties.snoop_log_mode_values sSnoopLogSettingAtEnable =\n            BluetoothProperties.snoop_log_mode_values.EMPTY;\n    private static String sDefaultSnoopLogSettingAtEnable = \"empty\";\n    private static boolean sSnoopLogFilterHeadersSettingAtEnable = false;\n    private static boolean sSnoopLogFilterProfileA2dpSettingAtEnable = false;\n    private static boolean sSnoopLogFilterProfileRfcommSettingAtEnable = false;\n\n    private static BluetoothProperties.snoop_log_filter_profile_pbap_values\n            sSnoopLogFilterProfilePbapModeSettingAtEnable =\n                    BluetoothProperties.snoop_log_filter_profile_pbap_values.EMPTY;\n    private static BluetoothProperties.snoop_log_filter_profile_map_values\n            sSnoopLogFilterProfileMapModeSettingAtEnable =\n                    BluetoothProperties.snoop_log_filter_profile_map_values.EMPTY;\n\n    private static AdapterService sAdapterService;\n\n    private final Object mEnergyInfoLock = new Object();\n    private final SparseArray<UidTraffic> mUidTraffic = new SparseArray<>();\n\n    private final Map<Integer, ProfileService> mStartedProfiles = new HashMap<>();\n    private final List<ProfileService> mRegisteredProfiles = new ArrayList<>();\n    private final List<ProfileService> mRunningProfiles = new ArrayList<>();\n\n    private final List<DiscoveringPackage> mDiscoveringPackages = new ArrayList<>();\n\n    private final AdapterNativeInterface mNativeInterface = AdapterNativeInterface.getInstance();\n\n    private final Map<BluetoothDevice, RemoteCallbackList<IBluetoothMetadataListener>>\n            mMetadataListeners = new HashMap<>();\n\n    // Map<groupId, PendingAudioProfilePreferenceRequest>\n    @GuardedBy(\"mCsipGroupsPendingAudioProfileChanges\")\n    private final Map<Integer, PendingAudioProfilePreferenceRequest>\n            mCsipGroupsPendingAudioProfileChanges = new HashMap<>();\n\n    private final Map<BluetoothStateCallback, Executor> mLocalCallbacks = new ConcurrentHashMap<>();\n    private final Map<UUID, RfcommListenerData> mBluetoothServerSockets = new ConcurrentHashMap<>();\n    private final ArrayDeque<IBluetoothOobDataCallback> mOobDataCallbackQueue = new ArrayDeque<>();\n\n    private final RemoteCallbackList<IBluetoothPreferredAudioProfilesCallback>\n            mPreferredAudioProfilesCallbacks = new RemoteCallbackList<>();\n    private final RemoteCallbackList<IBluetoothQualityReportReadyCallback>\n            mBluetoothQualityReportReadyCallbacks = new RemoteCallbackList<>();\n    private final RemoteCallbackList<IBluetoothCallback> mRemoteCallbacks =\n            new RemoteCallbackList<>();\n    private final RemoteCallbackList<IBluetoothConnectionCallback> mBluetoothConnectionCallbacks =\n            new RemoteCallbackList<>();\n\n    private final EvictingQueue<String> mScanModeChanges = EvictingQueue.create(10);\n\n    private final DeviceConfigListener mDeviceConfigListener = new DeviceConfigListener();\n\n    private final Looper mLooper;\n    private final AdapterServiceHandler mHandler;\n\n    private int mStackReportedState;\n    private long mTxTimeTotalMs;\n    private long mRxTimeTotalMs;\n    private long mIdleTimeTotalMs;\n    private long mEnergyUsedTotalVoltAmpSecMicro;\n    private HashSet<String> mLeAudioAllowDevices = new HashSet<>();\n\n    private BluetoothAdapter mAdapter;\n    @VisibleForTesting AdapterProperties mAdapterProperties;\n    private AdapterState mAdapterStateMachine;\n    private BondStateMachine mBondStateMachine;\n    private RemoteDevices mRemoteDevices;\n    private AdapterSuspend mAdapterSuspend;\n\n    /* TODO: Consider to remove the search API from this class, if changed to use call-back */\n    private SdpManager mSdpManager = null;\n\n    private boolean mNativeAvailable;\n    private boolean mCleaningUp;\n    private boolean mQuietmode = false;\n    private Map<String, CallerInfo> mBondAttemptCallerInfo = new HashMap<>();\n\n    private BatteryStatsManager mBatteryStatsManager;\n    private PowerManager mPowerManager;\n    private PowerManager.WakeLock mWakeLock;\n    private UserManager mUserManager;\n    private CompanionDeviceManager mCompanionDeviceManager;\n\n    // Phone Policy is not used on all devices. Ensure you null check before using it\n    @Nullable private PhonePolicy mPhonePolicy;\n\n    private ActiveDeviceManager mActiveDeviceManager;\n    private final DatabaseManager mDatabaseManager;\n    private final SilenceDeviceManager mSilenceDeviceManager;\n    private CompanionManager mBtCompanionManager;\n    private AppOpsManager mAppOps;\n\n    private BluetoothSocketManagerBinder mBluetoothSocketManagerBinder;\n\n    private BluetoothKeystoreService mBluetoothKeystoreService;\n    private A2dpService mA2dpService;\n    private A2dpSinkService mA2dpSinkService;\n    private HeadsetService mHeadsetService;\n    private HeadsetClientService mHeadsetClientService;\n    private BluetoothMapService mMapService;\n    private MapClientService mMapClientService;\n    private HidDeviceService mHidDeviceService;\n    private HidHostService mHidHostService;\n    private PanService mPanService;\n    private BluetoothPbapService mPbapService;\n    private PbapClientService mPbapClientService;\n    private HearingAidService mHearingAidService;\n    private HapClientService mHapClientService;\n    private SapService mSapService;\n    private VolumeControlService mVolumeControlService;\n    private CsipSetCoordinatorService mCsipSetCoordinatorService;\n    private LeAudioService mLeAudioService;\n    private BassClientService mBassClientService;\n    private BatteryService mBatteryService;\n    private BluetoothQualityReportNativeInterface mBluetoothQualityReportNativeInterface;\n    private GattService mGattService;\n    private ScanController mScanController;\n\n    private volatile boolean mTestModeEnabled = false;\n\n    private MetricsLogger mMetricsLogger;\n\n    /** Handlers for incoming service calls */\n    private AdapterServiceBinder mBinder;\n\n    private volatile int mScanMode;\n\n    // Report ID definition\n    public enum BqrQualityReportId {\n        QUALITY_REPORT_ID_MONITOR_MODE(0x01),\n        QUALITY_REPORT_ID_APPROACH_LSTO(0x02),\n        QUALITY_REPORT_ID_A2DP_AUDIO_CHOPPY(0x03),\n        QUALITY_REPORT_ID_SCO_VOICE_CHOPPY(0x04),\n        QUALITY_REPORT_ID_ROOT_INFLAMMATION(0x05),\n        QUALITY_REPORT_ID_CONNECT_FAIL(0x08),\n        QUALITY_REPORT_ID_LMP_LL_MESSAGE_TRACE(0x11),\n        QUALITY_REPORT_ID_BT_SCHEDULING_TRACE(0x12),\n        QUALITY_REPORT_ID_CONTROLLER_DBG_INFO(0x13);\n\n        private final int mValue;\n\n        BqrQualityReportId(int value) {\n            mValue = value;\n        }\n\n        public int getValue() {\n            return mValue;\n        }\n    };\n\n    static {\n        if (!Flags.avoidStaticLoadingOfNative()) {\n            Log.d(TAG, \"Loading JNI Library\");\n            if (Utils.isInstrumentationTestMode()) {\n                Log.w(TAG, \"App is instrumented. Skip loading the native\");\n            } else {\n                System.loadLibrary(\"bluetooth_jni\");\n            }\n        }\n    }\n\n    // Keep a constructor for ActivityThread.handleCreateService\n    AdapterService() {\n        this(Looper.getMainLooper());\n    }\n\n    @VisibleForTesting\n    AdapterService(Looper looper) {\n        mLooper = requireNonNull(looper);\n        mHandler = new AdapterServiceHandler(mLooper);\n        mSilenceDeviceManager = new SilenceDeviceManager(this, new ServiceFactory(), mLooper);\n        mDatabaseManager = new DatabaseManager(this);\n    }\n\n    @VisibleForTesting\n    public AdapterService(Context ctx) {\n        this(Looper.getMainLooper());\n        attachBaseContext(ctx);\n    }\n\n    public static synchronized AdapterService getAdapterService() {\n        return sAdapterService;\n    }\n\n    AdapterNativeInterface getNative() {\n        return mNativeInterface;\n    }\n\n    /** Allow test to set an AdapterService to be return by AdapterService.getAdapterService() */\n    @VisibleForTesting\n    public static synchronized void setAdapterService(AdapterService instance) {\n        if (instance == null) {\n            Log.e(TAG, \"setAdapterService() - instance is null\");\n            return;\n        }\n        Log.d(TAG, \"setAdapterService() - set service to \" + instance);\n        sAdapterService = instance;\n    }\n\n    /** Clear test Adapter service. See {@code setAdapterService} */\n    @VisibleForTesting\n    public static synchronized void clearAdapterService(AdapterService instance) {\n        if (sAdapterService == instance) {\n            Log.d(TAG, \"clearAdapterService() - This adapter was cleared \" + instance);\n            sAdapterService = null;\n        } else {\n            Log.d(\n                    TAG,\n                    \"clearAdapterService() - incorrect cleared adapter.\"\n                            + (\" Instance=\" + instance)\n                            + (\" vs sAdapterService=\" + sAdapterService));\n        }\n    }\n\n    /**\n     * Register a {@link ProfileService} with AdapterService.\n     *\n     * @param profile the service being added.\n     */\n    public void addProfile(ProfileService profile) {\n        mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_REGISTERED, profile).sendToTarget();\n    }\n\n    /**\n     * Unregister a ProfileService with AdapterService.\n     *\n     * @param profile the service being removed.\n     */\n    public void removeProfile(ProfileService profile) {\n        mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_UNREGISTERED, profile).sendToTarget();\n    }\n\n    /**\n     * Notify AdapterService that a ProfileService has started or stopped.\n     *\n     * @param profile the service being removed.\n     * @param state {@link BluetoothAdapter#STATE_ON} or {@link BluetoothAdapter#STATE_OFF}\n     */\n    public void onProfileServiceStateChanged(ProfileService profile, int state) {\n        if (state != BluetoothAdapter.STATE_ON && state != BluetoothAdapter.STATE_OFF) {\n            throw new IllegalArgumentException(BluetoothAdapter.nameForState(state));\n        }\n        Message m = mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_STATE_CHANGED);\n        m.obj = profile;\n        m.arg1 = state;\n        mHandler.sendMessage(m);\n    }\n\n    class AdapterServiceHandler extends Handler {\n        AdapterServiceHandler(Looper looper) {\n            super(looper);\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            Log.v(TAG, \"handleMessage() - Message: \" + msg.what);\n\n            switch (msg.what) {\n                case MESSAGE_PROFILE_SERVICE_STATE_CHANGED:\n                    Log.v(TAG, \"handleMessage() - MESSAGE_PROFILE_SERVICE_STATE_CHANGED\");\n                    processProfileServiceStateChanged((ProfileService) msg.obj, msg.arg1);\n                    break;\n                case MESSAGE_PROFILE_SERVICE_REGISTERED:\n                    Log.v(TAG, \"handleMessage() - MESSAGE_PROFILE_SERVICE_REGISTERED\");\n                    registerProfileService((ProfileService) msg.obj);\n                    break;\n                case MESSAGE_PROFILE_SERVICE_UNREGISTERED:\n                    Log.v(TAG, \"handleMessage() - MESSAGE_PROFILE_SERVICE_UNREGISTERED\");\n                    unregisterProfileService((ProfileService) msg.obj);\n                    break;\n                case MESSAGE_PREFERRED_AUDIO_PROFILES_AUDIO_FRAMEWORK_TIMEOUT:\n                    Log.e(\n                            TAG,\n                            \"handleMessage() - \"\n                                    + \"MESSAGE_PREFERRED_PROFILE_CHANGE_AUDIO_FRAMEWORK_TIMEOUT\");\n                    int groupId = (int) msg.obj;\n\n                    synchronized (mCsipGroupsPendingAudioProfileChanges) {\n                        removeFromPendingAudioProfileChanges(groupId);\n                        PendingAudioProfilePreferenceRequest request =\n                                mCsipGroupsPendingAudioProfileChanges.remove(groupId);\n                        Log.e(\n                                TAG,\n                                \"Preferred audio profiles change audio framework timeout for \"\n                                        + (\"device \" + request.mDeviceRequested));\n                        sendPreferredAudioProfilesCallbackToApps(\n                                request.mDeviceRequested,\n                                request.mRequestedPreferences,\n                                BluetoothStatusCodes.ERROR_TIMEOUT);\n                    }\n                    break;\n            }\n        }\n\n        private void registerProfileService(ProfileService profile) {\n            if (mRegisteredProfiles.contains(profile)) {\n                Log.e(TAG, profile.getName() + \" already registered.\");\n                return;\n            }\n            mRegisteredProfiles.add(profile);\n        }\n\n        private void unregisterProfileService(ProfileService profile) {\n            if (!mRegisteredProfiles.contains(profile)) {\n                Log.e(TAG, profile.getName() + \" not registered (UNREGISTER).\");\n                return;\n            }\n            mRegisteredProfiles.remove(profile);\n        }\n\n        private void processProfileServiceStateChanged(ProfileService profile, int state) {\n            switch (state) {\n                case BluetoothAdapter.STATE_ON:\n                    if (!mRegisteredProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" not registered (STATE_ON).\");\n                        return;\n                    }\n                    if (mRunningProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" already running.\");\n                        return;\n                    }\n                    mRunningProfiles.add(profile);\n                    // TODO(b/228875190): GATT is assumed supported. GATT starting triggers hardware\n                    // initialization. Configuring a device without GATT causes start up failures.\n                    if (GattService.class.getSimpleName().equals(profile.getName())\n                            && !Flags.scanManagerRefactor()) {\n                        mNativeInterface.enable();\n                    } else if (mRegisteredProfiles.size() == Config.getSupportedProfiles().length\n                            && mRegisteredProfiles.size() == mRunningProfiles.size()) {\n                        mAdapterProperties.onBluetoothReady();\n                        setScanMode(SCAN_MODE_CONNECTABLE, \"processProfileServiceStateChanged\");\n                        updateUuids();\n                        initProfileServices();\n                        mNativeInterface.getAdapterProperty(\n                                AbstractionLayer.BT_PROPERTY_DYNAMIC_AUDIO_BUFFER);\n                        mAdapterStateMachine.sendMessage(AdapterState.BREDR_STARTED);\n                        mBtCompanionManager.loadCompanionInfo();\n                    }\n                    break;\n                case BluetoothAdapter.STATE_OFF:\n                    if (!mRegisteredProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" not registered (STATE_OFF).\");\n                        return;\n                    }\n                    if (!mRunningProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" not running.\");\n                        return;\n                    }\n                    mRunningProfiles.remove(profile);\n\n                    if (Flags.scanManagerRefactor()) {\n                        if (mRunningProfiles.size() == 0) {\n                            mAdapterStateMachine.sendMessage(AdapterState.BREDR_STOPPED);\n                        }\n                    } else {\n                        // TODO(b/228875190): GATT is assumed supported. GATT is expected to be the\n                        // only profile available in the \"BLE ON\" state. If only GATT is left, send\n                        // BREDR_STOPPED. If GATT is stopped, deinitialize the hardware.\n                        if ((mRunningProfiles.size() == 1\n                                && (GattService.class\n                                        .getSimpleName()\n                                        .equals(mRunningProfiles.get(0).getName())))) {\n                            mAdapterStateMachine.sendMessage(AdapterState.BREDR_STOPPED);\n                        } else if (mRunningProfiles.size() == 0) {\n                            mNativeInterface.disable();\n                        }\n                    }\n                    break;\n                default:\n                    Log.e(TAG, \"Unhandled profile state: \" + state);\n            }\n        }\n    }\n\n    /**\n     * Stores information about requests made to the audio framework arising from calls to {@link\n     * BluetoothAdapter#setPreferredAudioProfiles(BluetoothDevice, Bundle)}.\n     */\n    private static class PendingAudioProfilePreferenceRequest {\n        // The newly requested preferences\n        final Bundle mRequestedPreferences;\n        // Reference counter for how many calls are pending completion in the audio framework\n        int mRemainingRequestsToAudioFramework;\n        // The device with which the request was made. Used for sending the callback.\n        final BluetoothDevice mDeviceRequested;\n\n        /**\n         * Constructs an entity to store information about pending preferred audio profile changes.\n         *\n         * @param preferences newly requested preferences\n         * @param numRequestsToAudioFramework how many active device changed requests are sent to\n         *     the audio framework\n         * @param device the device with which the request was made\n         */\n        PendingAudioProfilePreferenceRequest(\n                Bundle preferences, int numRequestsToAudioFramework, BluetoothDevice device) {\n            mRequestedPreferences = preferences;\n            mRemainingRequestsToAudioFramework = numRequestsToAudioFramework;\n            mDeviceRequested = device;\n        }\n    }\n\n    final @NonNull <T> T getNonNullSystemService(@NonNull Class<T> clazz) {\n        return requireNonNull(getSystemService(clazz));\n    }\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        Log.d(TAG, \"onCreate()\");\n        if (!Flags.fastBindToApp()) {\n            init();\n            return;\n        }\n        // OnCreate must perform the minimum of infaillible and mandatory initialization\n        mRemoteDevices = new RemoteDevices(this, mLooper);\n        mAdapterProperties = new AdapterProperties(this);\n        mAdapterStateMachine = new AdapterState(this, mLooper);\n        mBinder = new AdapterServiceBinder(this);\n        mUserManager = getNonNullSystemService(UserManager.class);\n        mAppOps = getNonNullSystemService(AppOpsManager.class);\n        mPowerManager = getNonNullSystemService(PowerManager.class);\n        mBatteryStatsManager = getNonNullSystemService(BatteryStatsManager.class);\n        mCompanionDeviceManager = getNonNullSystemService(CompanionDeviceManager.class);\n        setAdapterService(this);\n    }\n\n    @SuppressLint(\"AndroidFrameworkRequiresPermission\")\n    private void init() {\n        Log.d(TAG, \"init()\");\n        Config.init(this);\n        initMetricsLogger();\n        mDeviceConfigListener.start();\n\n        if (!Flags.fastBindToApp()) {\n            // Moved to OnCreate\n            mUserManager = getNonNullSystemService(UserManager.class);\n            mAppOps = getNonNullSystemService(AppOpsManager.class);\n            mPowerManager = getNonNullSystemService(PowerManager.class);\n            mBatteryStatsManager = getNonNullSystemService(BatteryStatsManager.class);\n            mCompanionDeviceManager = getNonNullSystemService(CompanionDeviceManager.class);\n            mRemoteDevices = new RemoteDevices(this, mLooper);\n        }\n\n        clearDiscoveringPackages();\n        if (!Flags.fastBindToApp()) {\n            mBinder = new AdapterServiceBinder(this);\n        }\n        mAdapter = BluetoothAdapter.getDefaultAdapter();\n        if (!Flags.fastBindToApp()) {\n            // Moved to OnCreate\n            mAdapterProperties = new AdapterProperties(this);\n            mAdapterStateMachine = new AdapterState(this, mLooper);\n        }\n        boolean isCommonCriteriaMode =\n                getNonNullSystemService(DevicePolicyManager.class)\n                        .isCommonCriteriaModeEnabled(null);\n        mBluetoothKeystoreService =\n                new BluetoothKeystoreService(\n                        BluetoothKeystoreNativeInterface.getInstance(), isCommonCriteriaMode);\n        mBluetoothKeystoreService.start();\n        int configCompareResult = mBluetoothKeystoreService.getCompareResult();\n\n        // Start tracking Binder latency for the bluetooth process.\n        BluetoothFrameworkInitializer.initializeBinderCallsStats(getApplicationContext());\n\n        // Android TV doesn't show consent dialogs for just works and encryption only le pairing\n        boolean isAtvDevice =\n                getApplicationContext()\n                        .getPackageManager()\n                        .hasSystemFeature(PackageManager.FEATURE_LEANBACK_ONLY);\n        if (Flags.avoidStaticLoadingOfNative()) {\n            if (Utils.isInstrumentationTestMode()) {\n                Log.w(TAG, \"This Bluetooth App is instrumented. ** Skip loading the native **\");\n            } else {\n                Log.d(TAG, \"Loading JNI Library\");\n                System.loadLibrary(\"bluetooth_jni\");\n            }\n        }\n        mNativeInterface.init(\n                this,\n                mAdapterProperties,\n                mUserManager.isGuestUser(),\n                isCommonCriteriaMode,\n                configCompareResult,\n                isAtvDevice,\n                getApplicationInfo().dataDir);\n        mNativeAvailable = true;\n        // Load the name and address\n        mNativeInterface.getAdapterProperty(AbstractionLayer.BT_PROPERTY_BDADDR);\n        mNativeInterface.getAdapterProperty(AbstractionLayer.BT_PROPERTY_BDNAME);\n        mNativeInterface.getAdapterProperty(AbstractionLayer.BT_PROPERTY_CLASS_OF_DEVICE);\n\n        mBluetoothKeystoreService.initJni();\n\n        mBluetoothQualityReportNativeInterface =\n                requireNonNull(\n                        BluetoothQualityReportNativeInterface.getInstance(),\n                        \"BluetoothQualityReportNativeInterface cannot be null when BQR starts\");\n        mBluetoothQualityReportNativeInterface.init();\n\n        if (Flags.fastBindToApp()) {\n            mSdpManager = new SdpManager(this, mLooper);\n        } else {\n            mSdpManager = new SdpManager(this);\n        }\n\n        mDatabaseManager.start(MetadataDatabase.createDatabase(this));\n\n        boolean isAutomotiveDevice =\n                getApplicationContext()\n                        .getPackageManager()\n                        .hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE);\n\n        /*\n         * Phone policy is specific to phone implementations and hence if a device wants to exclude\n         * it out then it can be disabled by using the flag below. Phone policy is never used on\n         * Android Automotive OS builds, in favor of a policy currently located in\n         * CarBluetoothService.\n         */\n        if (!isAutomotiveDevice && getResources().getBoolean(R.bool.enable_phone_policy)) {\n            Log.i(TAG, \"Phone policy enabled\");\n            mPhonePolicy = new PhonePolicy(this, new ServiceFactory());\n            mPhonePolicy.start();\n        } else {\n            Log.i(TAG, \"Phone policy disabled\");\n        }\n\n        if (Flags.audioRoutingCentralization()) {\n            mActiveDeviceManager = new AudioRoutingManager(this, new ServiceFactory());\n        } else {\n            mActiveDeviceManager = new ActiveDeviceManager(this, new ServiceFactory());\n        }\n        mActiveDeviceManager.start();\n\n        mSilenceDeviceManager.start();\n\n        mBtCompanionManager = new CompanionManager(this, new ServiceFactory());\n\n        mBluetoothSocketManagerBinder = new BluetoothSocketManagerBinder(this);\n\n        if (Flags.adapterSuspendMgmt()) {\n            mAdapterSuspend =\n                    new AdapterSuspend(\n                            mNativeInterface, mLooper, getSystemService(DisplayManager.class));\n        }\n\n        if (!Flags.fastBindToApp()) {\n            setAdapterService(this);\n        }\n\n        invalidateBluetoothCaches();\n\n        // First call to getSharedPreferences will result in a file read into\n        // memory cache. Call it here asynchronously to avoid potential ANR\n        // in the future\n        new AsyncTask<Void, Void, Void>() {\n            @Override\n            protected Void doInBackground(Void... params) {\n                getSharedPreferences(\n                        PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE, Context.MODE_PRIVATE);\n                getSharedPreferences(\n                        MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE, Context.MODE_PRIVATE);\n                getSharedPreferences(SIM_ACCESS_PERMISSION_PREFERENCE_FILE, Context.MODE_PRIVATE);\n                return null;\n            }\n        }.execute();\n\n        try {\n            int systemUiUid =\n                    getApplicationContext()\n                            .createContextAsUser(UserHandle.SYSTEM, /* flags= */ 0)\n                            .getPackageManager()\n                            .getPackageUid(\n                                    \"com.android.systemui\", PackageManager.MATCH_SYSTEM_ONLY);\n\n            Utils.setSystemUiUid(systemUiUid);\n        } catch (PackageManager.NameNotFoundException e) {\n            // Some platforms, such as wearables do not have a system ui.\n            Log.w(TAG, \"Unable to resolve SystemUI's UID.\", e);\n        }\n    }\n\n    @Override\n    public IBinder onBind(Intent intent) {\n        Log.d(TAG, \"onBind()\");\n        return mBinder;\n    }\n\n    @Override\n    public boolean onUnbind(Intent intent) {\n        Log.d(TAG, \"onUnbind()\");\n        return super.onUnbind(intent);\n    }\n\n    @Override\n    public void onDestroy() {\n        Log.d(TAG, \"onDestroy()\");\n    }\n\n    public ActiveDeviceManager getActiveDeviceManager() {\n        return mActiveDeviceManager;\n    }\n\n    public SilenceDeviceManager getSilenceDeviceManager() {\n        return mSilenceDeviceManager;\n    }\n\n    private boolean initMetricsLogger() {\n        if (mMetricsLogger != null) {\n            return false;\n        }\n        mMetricsLogger = MetricsLogger.getInstance();\n        return mMetricsLogger.init(this);\n    }\n\n    private boolean closeMetricsLogger() {\n        if (mMetricsLogger == null) {\n            return false;\n        }\n        boolean result = mMetricsLogger.close();\n        mMetricsLogger = null;\n        return result;\n    }\n\n    /**\n     * Log L2CAP CoC Server Connection Metrics\n     *\n     * @param port port of socket\n     * @param isSecured if secured API is called\n     * @param result transaction result of the connection\n     * @param socketCreationLatencyMillis latency of the connection\n     * @param timeoutMillis timeout set by the app\n     */\n    public void logL2capcocServerConnection(\n            BluetoothDevice device,\n            int port,\n            boolean isSecured,\n            int result,\n            long socketCreationTimeMillis,\n            long socketCreationLatencyMillis,\n            long socketConnectionTimeMillis,\n            long timeoutMillis,\n            int appUid) {\n\n        int metricId = 0;\n        if (device != null) {\n            metricId = getMetricId(device);\n        }\n        long currentTime = System.currentTimeMillis();\n        long endToEndLatencyMillis = currentTime - socketCreationTimeMillis;\n        long socketAcceptanceLatencyMillis = currentTime - socketConnectionTimeMillis;\n        Log.i(\n                TAG,\n                \"Statslog L2capcoc server connection.\"\n                        + (\" metricId \" + metricId)\n                        + (\" port \" + port)\n                        + (\" isSecured \" + isSecured)\n                        + (\" result \" + result)\n                        + (\" endToEndLatencyMillis \" + endToEndLatencyMillis)\n                        + (\" socketCreationLatencyMillis \" + socketCreationLatencyMillis)\n                        + (\" socketAcceptanceLatencyMillis \" + socketAcceptanceLatencyMillis)\n                        + (\" timeout set by app \" + timeoutMillis)\n                        + (\" appUid \" + appUid));\n        BluetoothStatsLog.write(\n                BluetoothStatsLog.BLUETOOTH_L2CAP_COC_SERVER_CONNECTION,\n                metricId,\n                port,\n                isSecured,\n                result,\n                endToEndLatencyMillis,\n                timeoutMillis,\n                appUid,\n                socketCreationLatencyMillis,\n                socketAcceptanceLatencyMillis);\n    }\n\n    public void setMetricsLogger(MetricsLogger metricsLogger) {\n        mMetricsLogger = metricsLogger;\n    }\n\n    /**\n     * Log L2CAP CoC Client Connection Metrics\n     *\n     * @param device Bluetooth device\n     * @param port port of socket\n     * @param isSecured if secured API is called\n     * @param result transaction result of the connection\n     * @param socketCreationLatencyNanos latency of the connection\n     */\n    public void logL2capcocClientConnection(\n            BluetoothDevice device,\n            int port,\n            boolean isSecured,\n            int result,\n            long socketCreationTimeNanos,\n            long socketCreationLatencyNanos,\n            long socketConnectionTimeNanos,\n            int appUid) {\n\n        int metricId = getMetricId(device);\n        long currentTime = System.nanoTime();\n        long endToEndLatencyMillis = (currentTime - socketCreationTimeNanos) / 1000000;\n        long socketCreationLatencyMillis = socketCreationLatencyNanos / 1000000;\n        long socketConnectionLatencyMillis = (currentTime - socketConnectionTimeNanos) / 1000000;\n        Log.i(\n                TAG,\n                \"Statslog L2capcoc client connection.\"\n                        + (\" metricId \" + metricId)\n                        + (\" port \" + port)\n                        + (\" isSecured \" + isSecured)\n                        + (\" result \" + result)\n                        + (\" endToEndLatencyMillis \" + endToEndLatencyMillis)\n                        + (\" socketCreationLatencyMillis \" + socketCreationLatencyMillis)\n                        + (\" socketConnectionLatencyMillis \" + socketConnectionLatencyMillis)\n                        + (\" appUid \" + appUid));\n        BluetoothStatsLog.write(\n                BluetoothStatsLog.BLUETOOTH_L2CAP_COC_CLIENT_CONNECTION,\n                metricId,\n                port,\n                isSecured,\n                result,\n                endToEndLatencyMillis,\n                appUid,\n                socketCreationLatencyMillis,\n                socketConnectionLatencyMillis);\n    }\n\n    /**\n     * Log RFCOMM Connection Metrics\n     *\n     * @param device Bluetooth device\n     * @param isSecured if secured API is called\n     * @param resultCode transaction result of the connection\n     * @param isSerialPort true if service class UUID is 0x1101\n     */\n    public void logRfcommConnectionAttempt(\n            BluetoothDevice device,\n            boolean isSecured,\n            int resultCode,\n            long socketCreationTimeNanos,\n            boolean isSerialPort,\n            int appUid) {\n        int metricId = getMetricId(device);\n        long currentTime = System.nanoTime();\n        long endToEndLatencyNanos = currentTime - socketCreationTimeNanos;\n        byte[] remoteDeviceInfoBytes = MetricsLogger.getInstance().getRemoteDeviceInfoProto(device);\n        BluetoothStatsLog.write(\n                BluetoothStatsLog.BLUETOOTH_RFCOMM_CONNECTION_ATTEMPTED,\n                metricId,\n                endToEndLatencyNanos,\n                isSecured\n                        ? BluetoothRfcommProtoEnums.SOCKET_SECURITY_SECURE\n                        : BluetoothRfcommProtoEnums.SOCKET_SECURITY_INSECURE,\n                resultCode,\n                isSerialPort,\n                appUid,\n                remoteDeviceInfoBytes);\n    }\n\n    public boolean sdpSearch(BluetoothDevice device, ParcelUuid uuid) {\n        if (mSdpManager == null) {\n            return false;\n        }\n        mSdpManager.sdpSearch(device, uuid);\n        return true;\n    }\n\n    @RequiresPermission(BLUETOOTH_CONNECT)\n    void bringUpBle() {\n        Log.d(TAG, \"bleOnProcessStart()\");\n\n        if (getResources()\n                .getBoolean(R.bool.config_bluetooth_reload_supported_profiles_when_enabled)) {\n            Config.init(getApplicationContext());\n        }\n\n        // Reset |mRemoteDevices| whenever BLE is turned off then on\n        // This is to replace the fact that |mRemoteDevices| was\n        // reinitialized in previous code.\n        //\n        // TODO(apanicke): The reason is unclear but\n        // I believe it is to clear the variable every time BLE was\n        // turned off then on. The same effect can be achieved by\n        // calling cleanup but this may not be necessary at all\n        // We should figure out why this is needed later\n        mRemoteDevices.reset();\n        mAdapterProperties.init(mRemoteDevices);\n\n        Log.d(TAG, \"bleOnProcessStart() - Make Bond State Machine\");\n        mBondStateMachine = BondStateMachine.make(this, mAdapterProperties, mRemoteDevices);\n\n        mNativeInterface.getCallbacks().init(mBondStateMachine, mRemoteDevices);\n\n        mBatteryStatsManager.reportBleScanReset();\n        BluetoothStatsLog.write_non_chained(\n                BluetoothStatsLog.BLE_SCAN_STATE_CHANGED,\n                -1,\n                null,\n                BluetoothStatsLog.BLE_SCAN_STATE_CHANGED__STATE__RESET,\n                false,\n                false,\n                false);\n\n        // TODO(b/228875190): GATT is assumed supported. As a result, we don't respect the\n        // configuration sysprop. Configuring a device without GATT, although rare, will cause stack\n        // start up errors yielding init loops.\n        if (!GattService.isEnabled()) {\n            Log.w(\n                    TAG,\n                    \"GATT is configured off but the stack assumes it to be enabled. Start anyway.\");\n        }\n        if (Flags.scanManagerRefactor()) {\n            startScanController();\n        } else {\n            startGattProfileService();\n        }\n    }\n\n    void bringDownBle() {\n        if (Flags.scanManagerRefactor()) {\n            stopScanController();\n        } else {\n            stopGattProfileService();\n        }\n    }\n\n    void stateChangeCallback(int status) {\n        if (status == AbstractionLayer.BT_STATE_OFF) {\n            Log.d(TAG, \"stateChangeCallback: disableNative() completed\");\n            mAdapterStateMachine.sendMessage(AdapterState.BLE_STOPPED);\n        } else if (status == AbstractionLayer.BT_STATE_ON) {\n            mAdapterStateMachine.sendMessage(AdapterState.BLE_STARTED);\n        } else {\n            Log.e(TAG, \"Incorrect status \" + status + \" in stateChangeCallback\");\n        }\n    }\n\n    void startProfileServices() {\n        Log.d(TAG, \"startCoreServices()\");\n        int[] supportedProfileServices = Config.getSupportedProfiles();\n        if (Flags.scanManagerRefactor()) {\n            // Scanning is always supported, started separately, and is not a profile service.\n            // This will check other profile services.\n            if (supportedProfileServices.length == 0) {\n                mAdapterProperties.onBluetoothReady();\n                setScanMode(SCAN_MODE_CONNECTABLE, \"startProfileServices\");\n                updateUuids();\n                mAdapterStateMachine.sendMessage(AdapterState.BREDR_STARTED);\n            } else {\n                setAllProfileServiceStates(supportedProfileServices, BluetoothAdapter.STATE_ON);\n            }\n        } else {\n            // TODO(b/228875190): GATT is assumed supported. If we support no other profiles then\n            // just move on to BREDR_STARTED. Note that configuring GATT to NOT supported will cause\n            // adapter initialization failures\n            if (supportedProfileServices.length == 1\n                    && supportedProfileServices[0] == BluetoothProfile.GATT) {\n                mAdapterProperties.onBluetoothReady();\n                setScanMode(SCAN_MODE_CONNECTABLE, \"startProfileServices\");\n                updateUuids();\n                mAdapterStateMachine.sendMessage(AdapterState.BREDR_STARTED);\n            } else {\n                setAllProfileServiceStates(supportedProfileServices, BluetoothAdapter.STATE_ON);\n            }\n        }\n    }\n\n    void stopProfileServices() {\n        // Make sure to stop classic background tasks now\n        mNativeInterface.cancelDiscovery();\n        setScanMode(SCAN_MODE_NONE, \"StopProfileServices\");\n\n        int[] supportedProfileServices = Config.getSupportedProfiles();\n        if (Flags.scanManagerRefactor()) {\n            // Scanning is always supported, started separately, and is not a profile service.\n            // This will check other profile services.\n            if (supportedProfileServices.length == 0) {\n                mAdapterStateMachine.sendMessage(AdapterState.BREDR_STOPPED);\n            } else {\n                setAllProfileServiceStates(supportedProfileServices, BluetoothAdapter.STATE_OFF);\n            }\n        } else {\n            // TODO(b/228875190): GATT is assumed supported. If we support no profiles then just\n            // move on to BREDR_STOPPED\n            if (supportedProfileServices.length == 1\n                    && (mRunningProfiles.size() == 1\n                            && GattService.class\n                                    .getSimpleName()\n                                    .equals(mRunningProfiles.get(0).getName()))) {\n                Log.d(\n                        TAG,\n                        \"stopProfileServices() - No profiles services to stop or already stopped.\");\n                mAdapterStateMachine.sendMessage(AdapterState.BREDR_STOPPED);\n            } else {\n                setAllProfileServiceStates(supportedProfileServices, BluetoothAdapter.STATE_OFF);\n            }\n        }\n    }\n\n    private void startGattProfileService() {\n        Log.d(TAG, \"startGattProfileService() called\");\n        mGattService = new GattService(this);\n\n        mStartedProfiles.put(BluetoothProfile.GATT, mGattService);\n        addProfile(mGattService);\n        mGattService.start();\n        mGattService.setAvailable(true);\n        onProfileServiceStateChanged(mGattService, BluetoothAdapter.STATE_ON);\n    }\n\n    private void startScanController() {\n        Log.d(TAG, \"startScanController() called\");\n        mScanController = new ScanController(this);\n        mNativeInterface.enable();\n    }\n\n    private void stopGattProfileService() {\n        Log.d(TAG, \"stopGattProfileService() called\");\n        setScanMode(SCAN_MODE_NONE, \"stopGattProfileService\");\n\n        if (mRunningProfiles.size() == 0) {\n            Log.d(TAG, \"stopGattProfileService() - No profiles services to stop.\");\n            mAdapterStateMachine.sendMessage(AdapterState.BLE_STOPPED);\n        }\n\n        mStartedProfiles.remove(BluetoothProfile.GATT);\n        if (mGattService != null) {\n            mGattService.setAvailable(false);\n            onProfileServiceStateChanged(mGattService, BluetoothAdapter.STATE_OFF);\n            mGattService.stop();\n            removeProfile(mGattService);\n            mGattService.cleanup();\n            mGattService.getBinder().cleanup();\n            mGattService = null;\n        }\n    }\n\n    private void stopScanController() {\n        Log.d(TAG, \"stopScanController() called\");\n        setScanMode(SCAN_MODE_NONE, \"stopScanController\");\n\n        if (mScanController == null) {\n            mAdapterStateMachine.sendMessage(AdapterState.BLE_STOPPED);\n        } else {\n            mScanController.stop();\n            mScanController = null;\n            mNativeInterface.disable();\n        }\n    }\n\n    private void invalidateBluetoothGetStateCache() {\n        if (Flags.getStateFromSystemServer()) {\n            // State is managed by the system server\n            return;\n        }\n        BluetoothAdapter.invalidateBluetoothGetStateCache();\n    }\n\n    void updateLeAudioProfileServiceState() {\n        Set<Integer> nonSupportedProfiles = new HashSet<>();\n\n        if (!isLeConnectedIsochronousStreamCentralSupported()) {\n            for (int profileId : Config.getLeAudioUnicastProfiles()) {\n                nonSupportedProfiles.add(profileId);\n            }\n        }\n\n        if (!isLeAudioBroadcastAssistantSupported()) {\n            nonSupportedProfiles.add(BluetoothProfile.LE_AUDIO_BROADCAST_ASSISTANT);\n        }\n\n        if (!isLeAudioBroadcastSourceSupported()) {\n            Config.setProfileEnabled(BluetoothProfile.LE_AUDIO_BROADCAST, false);\n        }\n\n        // Disable the non-supported profiles service\n        for (int profileId : nonSupportedProfiles) {\n            Config.setProfileEnabled(profileId, false);\n            if (mStartedProfiles.containsKey(profileId)) {\n                setProfileServiceState(profileId, BluetoothAdapter.STATE_OFF);\n            }\n        }\n    }\n\n    void updateAdapterName(String name) {\n        int n = mRemoteCallbacks.beginBroadcast();\n        Log.d(TAG, \"updateAdapterName(\" + name + \")\");\n        for (int i = 0; i < n; i++) {\n            try {\n                mRemoteCallbacks.getBroadcastItem(i).onAdapterNameChange(name);\n            } catch (RemoteException e) {\n                Log.d(TAG, \"updateAdapterName() - Callback #\" + i + \" failed (\" + e + \")\");\n            }\n        }\n        mRemoteCallbacks.finishBroadcast();\n    }\n\n    void updateAdapterAddress(String address) {\n        int n = mRemoteCallbacks.beginBroadcast();\n        Log.d(TAG, \"updateAdapterAddress(\" + BluetoothUtils.toAnonymizedAddress(address) + \")\");\n        for (int i = 0; i < n; i++) {\n            try {\n                mRemoteCallbacks.getBroadcastItem(i).onAdapterAddressChange(address);\n            } catch (RemoteException e) {\n                Log.d(TAG, \"updateAdapterAddress() - Callback #\" + i + \" failed (\" + e + \")\");\n            }\n        }\n        mRemoteCallbacks.finishBroadcast();\n    }\n\n    void updateAdapterState(int prevState, int newState) {\n        mAdapterProperties.setState(newState);\n        invalidateBluetoothGetStateCache();\n\n        // Only BluetoothManagerService should be registered\n        int n = mRemoteCallbacks.beginBroadcast();\n        Log.d(\n                TAG,\n                \"updateAdapterState() - Broadcasting state \"\n                        + BluetoothAdapter.nameForState(newState)\n                        + \" to \"\n                        + n\n                        + \" receivers.\");\n        for (int i = 0; i < n; i++) {\n            try {\n                mRemoteCallbacks.getBroadcastItem(i).onBluetoothStateChange(prevState, newState);\n            } catch (RemoteException e) {\n                Log.d(TAG, \"updateAdapterState() - Callback #\" + i + \" failed (\" + e + \")\");\n            }\n        }\n        mRemoteCallbacks.finishBroadcast();\n\n        for (Map.Entry<BluetoothStateCallback, Executor> e : mLocalCallbacks.entrySet()) {\n            e.getValue().execute(() -> e.getKey().onBluetoothStateChange(prevState, newState));\n        }\n\n        // Turn the Adapter all the way off if we are disabling and the snoop log setting changed.\n        if (newState == BluetoothAdapter.STATE_BLE_TURNING_ON) {\n            sSnoopLogSettingAtEnable =\n                    BluetoothProperties.snoop_log_mode()\n                            .orElse(BluetoothProperties.snoop_log_mode_values.EMPTY);\n            sDefaultSnoopLogSettingAtEnable =\n                    Settings.Global.getString(\n                            getContentResolver(), Settings.Global.BLUETOOTH_BTSNOOP_DEFAULT_MODE);\n\n            sSnoopLogFilterHeadersSettingAtEnable =\n                    BluetoothProperties.snoop_log_filter_snoop_headers_enabled().orElse(false);\n            sSnoopLogFilterProfileA2dpSettingAtEnable =\n                    BluetoothProperties.snoop_log_filter_profile_a2dp_enabled().orElse(false);\n            sSnoopLogFilterProfileRfcommSettingAtEnable =\n                    BluetoothProperties.snoop_log_filter_profile_rfcomm_enabled().orElse(false);\n            sSnoopLogFilterProfilePbapModeSettingAtEnable =\n                    BluetoothProperties.snoop_log_filter_profile_pbap()\n                            .orElse(BluetoothProperties.snoop_log_filter_profile_pbap_values.EMPTY);\n            sSnoopLogFilterProfileMapModeSettingAtEnable =\n                    BluetoothProperties.snoop_log_filter_profile_map()\n                            .orElse(BluetoothProperties.snoop_log_filter_profile_map_values.EMPTY);\n\n            BluetoothProperties.snoop_default_mode(\n                    BluetoothProperties.snoop_default_mode_values.DISABLED);\n            for (BluetoothProperties.snoop_default_mode_values value :\n                    BluetoothProperties.snoop_default_mode_values.values()) {\n                if (value.getPropValue().equals(sDefaultSnoopLogSettingAtEnable)) {\n                    BluetoothProperties.snoop_default_mode(value);\n                }\n            }\n        } else if (newState == BluetoothAdapter.STATE_BLE_ON\n                && prevState != BluetoothAdapter.STATE_OFF) {\n            var snoopLogSetting =\n                    BluetoothProperties.snoop_log_mode()\n                            .orElse(BluetoothProperties.snoop_log_mode_values.EMPTY);\n            var snoopDefaultModeSetting =\n                    Settings.Global.getString(\n                            getContentResolver(), Settings.Global.BLUETOOTH_BTSNOOP_DEFAULT_MODE);\n\n            var snoopLogFilterHeadersSettingAtEnable =\n                    BluetoothProperties.snoop_log_filter_snoop_headers_enabled().orElse(false);\n            var snoopLogFilterProfileA2dpSettingAtEnable =\n                    BluetoothProperties.snoop_log_filter_profile_a2dp_enabled().orElse(false);\n            var snoopLogFilterProfileRfcommSettingAtEnable =\n                    BluetoothProperties.snoop_log_filter_profile_rfcomm_enabled().orElse(false);\n\n            var snoopLogFilterProfilePbapModeSetting =\n                    BluetoothProperties.snoop_log_filter_profile_pbap()\n                            .orElse(BluetoothProperties.snoop_log_filter_profile_pbap_values.EMPTY);\n            var snoopLogFilterProfileMapModeSetting =\n                    BluetoothProperties.snoop_log_filter_profile_map()\n                            .orElse(BluetoothProperties.snoop_log_filter_profile_map_values.EMPTY);\n\n            if (!(sSnoopLogSettingAtEnable == snoopLogSetting)\n                    || !(Objects.equals(sDefaultSnoopLogSettingAtEnable, snoopDefaultModeSetting))\n                    || !(sSnoopLogFilterHeadersSettingAtEnable\n                            == snoopLogFilterHeadersSettingAtEnable)\n                    || !(sSnoopLogFilterProfileA2dpSettingAtEnable\n                            == snoopLogFilterProfileA2dpSettingAtEnable)\n                    || !(sSnoopLogFilterProfileRfcommSettingAtEnable\n                            == snoopLogFilterProfileRfcommSettingAtEnable)\n                    || !(sSnoopLogFilterProfilePbapModeSettingAtEnable\n                            == snoopLogFilterProfilePbapModeSetting)\n                    || !(sSnoopLogFilterProfileMapModeSettingAtEnable\n                            == snoopLogFilterProfileMapModeSetting)) {\n                mAdapterStateMachine.sendMessage(AdapterState.BLE_TURN_OFF);\n            }\n        }\n    }\n\n    void linkQualityReportCallback(\n            long timestamp,\n            int reportId,\n            int rssi,\n            int snr,\n            int retransmissionCount,\n            int packetsNotReceiveCount,\n            int negativeAcknowledgementCount) {\n        BluetoothInCallService bluetoothInCallService = BluetoothInCallService.getInstance();\n\n        if (reportId == BqrQualityReportId.QUALITY_REPORT_ID_SCO_VOICE_CHOPPY.getValue()) {\n            if (bluetoothInCallService == null) {\n                Log.w(\n                        TAG,\n                        \"No BluetoothInCallService while trying to send BQR.\"\n                                + (\" timestamp: \" + timestamp)\n                                + (\" reportId: \" + reportId)\n                                + (\" rssi: \" + rssi)\n                                + (\" snr: \" + snr)\n                                + (\" retransmissionCount: \" + retransmissionCount)\n                                + (\" packetsNotReceiveCount: \" + packetsNotReceiveCount)\n                                + (\" negativeAcknowledgementCount: \"\n                                        + negativeAcknowledgementCount));\n                return;\n            }\n            bluetoothInCallService.sendBluetoothCallQualityReport(\n                    timestamp,\n                    rssi,\n                    snr,\n                    retransmissionCount,\n                    packetsNotReceiveCount,\n                    negativeAcknowledgementCount);\n        }\n    }\n\n    /**\n     * Callback from Bluetooth Quality Report Native Interface to inform the listeners about\n     * Bluetooth Quality.\n     *\n     * @param device is the BluetoothDevice which connection quality is being reported\n     * @param bluetoothQualityReport a Parcel that contains information about Bluetooth Quality\n     * @return whether the Bluetooth stack acknowledged the change successfully\n     */\n    public int bluetoothQualityReportReadyCallback(\n            BluetoothDevice device, BluetoothQualityReport bluetoothQualityReport) {\n        synchronized (mBluetoothQualityReportReadyCallbacks) {\n            int n = mBluetoothQualityReportReadyCallbacks.beginBroadcast();\n            Log.d(\n                    TAG,\n                    \"bluetoothQualityReportReadyCallback() - \"\n                            + \"Broadcasting Bluetooth Quality Report to \"\n                            + n\n                            + \" receivers.\");\n            for (int i = 0; i < n; i++) {\n                try {\n                    mBluetoothQualityReportReadyCallbacks\n                            .getBroadcastItem(i)\n                            .onBluetoothQualityReportReady(\n                                    device, bluetoothQualityReport, BluetoothStatusCodes.SUCCESS);\n                } catch (RemoteException e) {\n                    Log.d(\n                            TAG,\n                            \"bluetoothQualityReportReadyCallback() - Callback #\"\n                                    + i\n                                    + \" failed (\"\n                                    + e\n                                    + \")\");\n                }\n            }\n            mBluetoothQualityReportReadyCallbacks.finishBroadcast();\n        }\n\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    void switchBufferSizeCallback(boolean isLowLatencyBufferSize) {\n        List<BluetoothDevice> activeDevices = getActiveDevices(BluetoothProfile.A2DP);\n        if (activeDevices.size() != 1) {\n            Log.e(\n                    TAG,\n                    \"Cannot switch buffer size. The number of A2DP active devices is \"\n                            + activeDevices.size());\n            return;\n        }\n\n        // Send intent to fastpair\n        Intent switchBufferSizeIntent = new Intent(BluetoothDevice.ACTION_SWITCH_BUFFER_SIZE);\n        switchBufferSizeIntent.setClassName(\n                getString(com.android.bluetooth.R.string.peripheral_link_package),\n                getString(com.android.bluetooth.R.string.peripheral_link_package)\n                        + getString(com.android.bluetooth.R.string.peripheral_link_service));\n        switchBufferSizeIntent.putExtra(BluetoothDevice.EXTRA_DEVICE, activeDevices.get(0));\n        switchBufferSizeIntent.putExtra(\n                BluetoothDevice.EXTRA_LOW_LATENCY_BUFFER_SIZE, isLowLatencyBufferSize);\n        sendBroadcastMultiplePermissions(\n                switchBufferSizeIntent,\n                new String[] {BLUETOOTH_CONNECT, BLUETOOTH_PRIVILEGED},\n                null);\n    }\n\n    void switchCodecCallback(boolean isLowLatencyBufferSize) {\n        List<BluetoothDevice> activeDevices = getActiveDevices(BluetoothProfile.A2DP);\n        if (activeDevices.size() != 1) {\n            Log.e(\n                    TAG,\n                    \"Cannot switch buffer size. The number of A2DP active devices is \"\n                            + activeDevices.size());\n            return;\n        }\n        mA2dpService.switchCodecByBufferSize(activeDevices.get(0), isLowLatencyBufferSize);\n    }\n\n    @RequiresPermission(BLUETOOTH_CONNECT)\n    void cleanup() {\n        Log.d(TAG, \"cleanup()\");\n        if (mCleaningUp) {\n            Log.e(TAG, \"cleanup() - Service already starting to cleanup, ignoring request...\");\n            return;\n        }\n\n        closeMetricsLogger();\n\n        clearAdapterService(this);\n\n        mCleaningUp = true;\n        invalidateBluetoothCaches();\n\n        stopRfcommServerSockets();\n\n        // This wake lock release may also be called concurrently by\n        // {@link #releaseWakeLock(String lockName)}, so a synchronization is needed here.\n        synchronized (this) {\n            if (mWakeLock != null) {\n                if (mWakeLock.isHeld()) {\n                    mWakeLock.release();\n                }\n                mWakeLock = null;\n            }\n        }\n\n        mDatabaseManager.cleanup();\n\n        if (mAdapterStateMachine != null) {\n            mAdapterStateMachine.doQuit();\n        }\n\n        if (mBondStateMachine != null) {\n            mBondStateMachine.doQuit();\n        }\n\n        if (mRemoteDevices != null) {\n            mRemoteDevices.reset();\n        }\n\n        if (mSdpManager != null) {\n            mSdpManager.cleanup();\n            mSdpManager = null;\n        }\n\n        if (mNativeAvailable) {\n            Log.d(TAG, \"cleanup() - Cleaning up adapter native\");\n            mNativeInterface.cleanup();\n            mNativeAvailable = false;\n        }\n\n        if (mAdapterProperties != null) {\n            mAdapterProperties.cleanup();\n        }\n\n        if (mNativeInterface.getCallbacks() != null) {\n            mNativeInterface.getCallbacks().cleanup();\n        }\n\n        if (mBluetoothKeystoreService != null) {\n            Log.d(TAG, \"cleanup(): mBluetoothKeystoreService.cleanup()\");\n            mBluetoothKeystoreService.cleanup();\n        }\n\n        if (mPhonePolicy != null) {\n            mPhonePolicy.cleanup();\n        }\n\n        mSilenceDeviceManager.cleanup();\n\n        if (mActiveDeviceManager != null) {\n            mActiveDeviceManager.cleanup();\n        }\n\n        if (mBluetoothSocketManagerBinder != null) {\n            mBluetoothSocketManagerBinder.cleanUp();\n            mBluetoothSocketManagerBinder = null;\n        }\n\n        if (mAdapterSuspend != null) {\n            mAdapterSuspend.cleanup();\n            mAdapterSuspend = null;\n        }\n\n        mPreferredAudioProfilesCallbacks.kill();\n\n        mBluetoothQualityReportReadyCallbacks.kill();\n\n        mBluetoothConnectionCallbacks.kill();\n\n        mRemoteCallbacks.kill();\n\n        mMetadataListeners.values().forEach(v -> v.kill());\n    }\n\n    private void invalidateBluetoothCaches() {\n        BluetoothAdapter.invalidateGetProfileConnectionStateCache();\n        BluetoothAdapter.invalidateIsOffloadedFilteringSupportedCache();\n        BluetoothDevice.invalidateBluetoothGetBondStateCache();\n        if (!Flags.getStateFromSystemServer()) {\n            BluetoothAdapter.invalidateBluetoothGetStateCache();\n        }\n        BluetoothAdapter.invalidateGetAdapterConnectionStateCache();\n        BluetoothMap.invalidateBluetoothGetConnectionStateCache();\n        BluetoothSap.invalidateBluetoothGetConnectionStateCache();\n    }\n\n    private static final Map<Integer, Function<AdapterService, ProfileService>>\n            PROFILE_CONSTRUCTORS =\n                    Map.ofEntries(\n                            Map.entry(BluetoothProfile.A2DP, A2dpService::new),\n                            Map.entry(BluetoothProfile.A2DP_SINK, A2dpSinkService::new),\n                            Map.entry(BluetoothProfile.AVRCP, AvrcpTargetService::new),\n                            Map.entry(\n                                    BluetoothProfile.AVRCP_CONTROLLER, AvrcpControllerService::new),\n                            Map.entry(\n                                    BluetoothProfile.LE_AUDIO_BROADCAST_ASSISTANT,\n                                    BassClientService::new),\n                            Map.entry(BluetoothProfile.BATTERY, BatteryService::new),\n                            Map.entry(\n                                    BluetoothProfile.CSIP_SET_COORDINATOR,\n                                    CsipSetCoordinatorService::new),\n                            Map.entry(BluetoothProfile.HAP_CLIENT, HapClientService::new),\n                            Map.entry(BluetoothProfile.HEADSET, HeadsetService::new),\n                            Map.entry(BluetoothProfile.HEADSET_CLIENT, HeadsetClientService::new),\n                            Map.entry(BluetoothProfile.HEARING_AID, HearingAidService::new),\n                            Map.entry(BluetoothProfile.HID_DEVICE, HidDeviceService::new),\n                            Map.entry(BluetoothProfile.HID_HOST, HidHostService::new),\n                            Map.entry(BluetoothProfile.GATT, GattService::new),\n                            Map.entry(BluetoothProfile.LE_AUDIO, LeAudioService::new),\n                            Map.entry(BluetoothProfile.LE_CALL_CONTROL, TbsService::new),\n                            Map.entry(BluetoothProfile.MAP, BluetoothMapService::new),\n                            Map.entry(BluetoothProfile.MAP_CLIENT, MapClientService::new),\n                            Map.entry(BluetoothProfile.MCP_SERVER, McpService::new),\n                            Map.entry(BluetoothProfile.OPP, BluetoothOppService::new),\n                            Map.entry(BluetoothProfile.PAN, PanService::new),\n                            Map.entry(BluetoothProfile.PBAP, BluetoothPbapService::new),\n                            Map.entry(BluetoothProfile.PBAP_CLIENT, PbapClientService::new),\n                            Map.entry(BluetoothProfile.SAP, SapService::new),\n                            Map.entry(BluetoothProfile.VOLUME_CONTROL, VolumeControlService::new));\n\n    @VisibleForTesting\n    void setProfileServiceState(int profileId, int state) {\n        if (state == BluetoothAdapter.STATE_ON) {\n            if (!mStartedProfiles.containsKey(profileId)) {\n                ProfileService profileService = PROFILE_CONSTRUCTORS.get(profileId).apply(this);\n                mStartedProfiles.put(profileId, profileService);\n                addProfile(profileService);\n                profileService.start();\n                profileService.setAvailable(true);\n                // With `Flags.scanManagerRefactor()` GattService initialization is pushed back to\n                // `ON` state instead of `BLE_ON`. Here we ensure mGattService is set prior\n                // to other Profiles using it.\n                if (profileId == BluetoothProfile.GATT && Flags.scanManagerRefactor()) {\n                    mGattService = GattService.getGattService();\n                }\n                onProfileServiceStateChanged(profileService, BluetoothAdapter.STATE_ON);\n            } else {\n                Log.e(\n                        TAG,\n                        \"setProfileServiceState(\"\n                                + BluetoothProfile.getProfileName(profileId)\n                                + \", STATE_ON): profile is already started\");\n            }\n        } else if (state == BluetoothAdapter.STATE_OFF) {\n            ProfileService profileService = mStartedProfiles.remove(profileId);\n            if (profileService != null) {\n                profileService.setAvailable(false);\n                onProfileServiceStateChanged(profileService, BluetoothAdapter.STATE_OFF);\n                profileService.stop();\n                removeProfile(profileService);\n                profileService.cleanup();\n                if (profileService.getBinder() != null) {\n                    profileService.getBinder().cleanup();\n                }\n            } else {\n                Log.e(\n                        TAG,\n                        \"setProfileServiceState(\"\n                                + BluetoothProfile.getProfileName(profileId)\n                                + \", STATE_OFF): profile is already stopped\");\n            }\n        }\n    }\n\n    private void setAllProfileServiceStates(int[] profileIds, int state) {\n        for (int profileId : profileIds) {\n            if (!Flags.scanManagerRefactor()) {\n                // TODO(b/228875190): GATT is assumed supported and treated differently as part of\n                //  the \"BLE ON\" state, despite GATT not being BLE specific.\n                if (profileId == BluetoothProfile.GATT) {\n                    continue;\n                }\n            }\n            setProfileServiceState(profileId, state);\n        }\n    }\n\n    /**\n     * Checks whether the remote device is a dual mode audio sink device (supports both classic and\n     * LE Audio sink roles.\n     *\n     * @param device the remote device\n     * @return {@code true} if it's a dual mode audio device, {@code false} otherwise\n     */\n    public boolean isDualModeAudioSinkDevice(BluetoothDevice device) {\n        if (mLeAudioService == null\n                || mLeAudioService.getGroupId(device) == LE_AUDIO_GROUP_ID_INVALID) {\n            return false;\n        }\n\n        // Check if any device in the CSIP group is a dual mode audio sink device\n        for (BluetoothDevice groupDevice :\n                mLeAudioService.getGroupDevices(mLeAudioService.getGroupId(device))) {\n            if (isProfileSupported(groupDevice, BluetoothProfile.LE_AUDIO)\n                    && (isProfileSupported(groupDevice, BluetoothProfile.HEADSET)\n                            || isProfileSupported(groupDevice, BluetoothProfile.A2DP))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Checks whether the local and remote device support a connection for duplex audio (input and\n     * output) over HFP or LE Audio.\n     *\n     * @param groupDevices the devices in the CSIP group\n     * @return {@code true} if duplex is supported on the remote device, {@code false} otherwise\n     */\n    private boolean isDuplexAudioSupported(List<BluetoothDevice> groupDevices) {\n        for (BluetoothDevice device : groupDevices) {\n            if (isProfileSupported(device, BluetoothProfile.HEADSET)\n                    || (isProfileSupported(device, BluetoothProfile.LE_AUDIO)\n                            && mLeAudioService != null\n                            && mLeAudioService.isLeAudioDuplexSupported(device))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Checks whether the local and remote device support a connection for output only audio over\n     * A2DP or LE Audio.\n     *\n     * @param groupDevices the devices in the CSIP group\n     * @return {@code true} if output only is supported, {@code false} otherwise\n     */\n    private boolean isOutputOnlyAudioSupported(List<BluetoothDevice> groupDevices) {\n        for (BluetoothDevice device : groupDevices) {\n            if (isProfileSupported(device, BluetoothProfile.A2DP)\n                    || (isProfileSupported(device, BluetoothProfile.LE_AUDIO)\n                            && mLeAudioService != null\n                            && mLeAudioService.isLeAudioOutputSupported(device))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Verifies whether the profile is supported by the local bluetooth adapter by checking a\n     * bitmask of its supported profiles\n     *\n     * @param device is the remote device we wish to connect to\n     * @param profile is the profile we are checking for support\n     * @return true if the profile is supported by both the local and remote device, false otherwise\n     */\n    @VisibleForTesting\n    boolean isProfileSupported(BluetoothDevice device, int profile) {\n        final ParcelUuid[] remoteDeviceUuids = getRemoteUuids(device);\n        final ParcelUuid[] localDeviceUuids = mAdapterProperties.getUuids();\n        if (remoteDeviceUuids == null || remoteDeviceUuids.length == 0) {\n            Log.e(\n                    TAG,\n                    \"isProfileSupported(\"\n                            + (\"device=\" + device)\n                            + (\", profile=\" + BluetoothProfile.getProfileName(profile) + \"):\")\n                            + \" remote device Uuids Empty\");\n        }\n\n        Log.v(\n                TAG,\n                \"isProfileSupported(\"\n                        + (\"device=\" + device)\n                        + (\", profile=\" + BluetoothProfile.getProfileName(profile) + \"):\")\n                        + (\" local_uuids=\" + Arrays.toString(localDeviceUuids))\n                        + (\", remote_uuids=\" + Arrays.toString(remoteDeviceUuids)));\n\n        if (profile == BluetoothProfile.HEADSET) {\n            return (Utils.arrayContains(localDeviceUuids, BluetoothUuid.HSP_AG)\n                            && Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HSP))\n                    || (Utils.arrayContains(localDeviceUuids, BluetoothUuid.HFP_AG)\n                            && Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HFP));\n        }\n        if (profile == BluetoothProfile.HEADSET_CLIENT) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HFP_AG)\n                    && Utils.arrayContains(localDeviceUuids, BluetoothUuid.HFP);\n        }\n        if (profile == BluetoothProfile.A2DP) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.ADV_AUDIO_DIST)\n                    || Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.A2DP_SINK);\n        }\n        if (profile == BluetoothProfile.A2DP_SINK) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.ADV_AUDIO_DIST)\n                    || Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.A2DP_SOURCE);\n        }\n        if (profile == BluetoothProfile.OPP) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.OBEX_OBJECT_PUSH);\n        }\n        if (profile == BluetoothProfile.HID_HOST) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HID)\n                    || Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HOGP)\n                    || (Flags.androidHeadtrackerService()\n                            && Utils.arrayContains(\n                                    remoteDeviceUuids, HidHostService.ANDROID_HEADTRACKER_UUID));\n        }\n        if (profile == BluetoothProfile.HID_DEVICE) {\n            return mHidDeviceService.getConnectionState(device)\n                    == BluetoothProfile.STATE_DISCONNECTED;\n        }\n        if (profile == BluetoothProfile.PAN) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.NAP);\n        }\n        if (profile == BluetoothProfile.MAP) {\n            return mMapService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED;\n        }\n        if (profile == BluetoothProfile.PBAP) {\n            return mPbapService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED;\n        }\n        if (profile == BluetoothProfile.MAP_CLIENT) {\n            return Utils.arrayContains(localDeviceUuids, BluetoothUuid.MNS)\n                    && Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.MAS);\n        }\n        if (profile == BluetoothProfile.PBAP_CLIENT) {\n            return Utils.arrayContains(localDeviceUuids, BluetoothUuid.PBAP_PCE)\n                    && Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.PBAP_PSE);\n        }\n        if (profile == BluetoothProfile.HEARING_AID) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HEARING_AID);\n        }\n        if (profile == BluetoothProfile.SAP) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.SAP);\n        }\n        if (profile == BluetoothProfile.VOLUME_CONTROL) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.VOLUME_CONTROL);\n        }\n        if (profile == BluetoothProfile.CSIP_SET_COORDINATOR) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.COORDINATED_SET);\n        }\n        if (profile == BluetoothProfile.LE_AUDIO) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.LE_AUDIO);\n        }\n        if (profile == BluetoothProfile.HAP_CLIENT) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HAS);\n        }\n        if (profile == BluetoothProfile.LE_AUDIO_BROADCAST_ASSISTANT) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.BASS);\n        }\n        if (profile == BluetoothProfile.BATTERY) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.BATTERY);\n        }\n\n        Log.e(TAG, \"isSupported: Unexpected profile passed in to function: \" + profile);\n        return false;\n    }\n\n    /**\n     * Checks if the connection policy of all profiles are unknown for the given device\n     *\n     * @param device is the device for which we are checking if the connection policy of all\n     *     profiles are unknown\n     * @return false if one of profile is enabled or disabled, true otherwise\n     */\n    boolean isAllProfilesUnknown(BluetoothDevice device) {\n        if (mA2dpService != null\n                && mA2dpService.getConnectionPolicy(device)\n                        != BluetoothProfile.CONNECTION_POLICY_UNKNOWN) {\n            return false;\n        }\n        if (mA2dpSinkService != null\n                && mA2dpSinkService.getConnectionPolicy(device)\n                        != BluetoothProfile.CONNECTION_POLICY_UNKNOWN) {\n            return false;\n        }\n        if (mHeadsetService != null\n                && mHeadsetService.getConnectionPolicy(device)\n                        != BluetoothProfile.CONNECTION_POLICY_UNKNOWN) {\n            return false;\n        }\n        if (mHeadsetClientService != null\n                && mHeadsetClientService.getConnectionPolicy(device)\n                        != BluetoothProfile.CONNECTION_POLICY_UNKNOWN) {\n            return false;\n        }\n        if (mMapClientService != null\n                && mMapClientService.getConnectionPolicy(device)\n                        != BluetoothProfile.CONNECTION_POLICY_UNKNOWN) {\n            return false;\n        }\n        if (mHidHostService != null\n                && mHidHostService.getConnectionPolicy(device)\n                        != BluetoothProfile.CONNECTION_POLICY_UNKNOWN) {\n            return false;\n        }\n        if (mPanService != null\n                && mPanService.getConnectionPolicy(device)\n                        != BluetoothProfile.CONNECTION_POLICY_UNKNOWN) {\n            return false;\n        }\n        if (mPbapClientService != null\n                && mPbapClientService.getConnectionPolicy(device)\n                        != BluetoothProfile.CONNECTION_POLICY_UNKNOWN) {\n            return false;\n        }\n        if (mHearingAidService != null\n                && mHearingAidService.getConnectionPolicy(device)\n                        != BluetoothProfile.CONNECTION_POLICY_UNKNOWN) {\n            return false;\n        }\n        if (mHapClientService != null\n                && mHapClientService.getConnectionPolicy(device)\n                        != BluetoothProfile.CONNECTION_POLICY_UNKNOWN) {\n            return false;\n        }\n        if (mVolumeControlService != null\n                && mVolumeControlService.getConnectionPolicy(device)\n                        != BluetoothProfile.CONNECTION_POLICY_UNKNOWN) {\n            return false;\n        }\n        if (mCsipSetCoordinatorService != null\n                && mCsipSetCoordinatorService.getConnectionPolicy(device)\n                        != BluetoothProfile.CONNECTION_POLICY_UNKNOWN) {\n            return false;\n        }\n        if (mLeAudioService != null\n                && mLeAudioService.getConnectionPolicy(device)\n                        != BluetoothProfile.CONNECTION_POLICY_UNKNOWN) {\n            return false;\n        }\n        if (mBassClientService != null\n                && mBassClientService.getConnectionPolicy(device)\n                        != BluetoothProfile.CONNECTION_POLICY_UNKNOWN) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Connects only available profiles (those with {@link\n     * BluetoothProfile#CONNECTION_POLICY_ALLOWED})\n     *\n     * @param device is the device with which we are connecting the profiles\n     * @return {@link BluetoothStatusCodes#SUCCESS}\n     */\n    private int connectEnabledProfiles(BluetoothDevice device) {\n        if (mCsipSetCoordinatorService != null\n                && isProfileSupported(device, BluetoothProfile.CSIP_SET_COORDINATOR)\n                && mCsipSetCoordinatorService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Coordinated Set Profile\");\n            mCsipSetCoordinatorService.connect(device);\n        }\n        if (mA2dpService != null\n                && isProfileSupported(device, BluetoothProfile.A2DP)\n                && mA2dpService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting A2dp\");\n            mA2dpService.connect(device);\n        }\n        if (mA2dpSinkService != null\n                && isProfileSupported(device, BluetoothProfile.A2DP_SINK)\n                && mA2dpSinkService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting A2dp Sink\");\n            mA2dpSinkService.connect(device);\n        }\n        if (mHeadsetService != null\n                && isProfileSupported(device, BluetoothProfile.HEADSET)\n                && mHeadsetService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Headset Profile\");\n            mHeadsetService.connect(device);\n        }\n        if (mHeadsetClientService != null\n                && isProfileSupported(device, BluetoothProfile.HEADSET_CLIENT)\n                && mHeadsetClientService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting HFP\");\n            mHeadsetClientService.connect(device);\n        }\n        if (mMapClientService != null\n                && isProfileSupported(device, BluetoothProfile.MAP_CLIENT)\n                && mMapClientService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting MAP\");\n            mMapClientService.connect(device);\n        }\n        if (mHidHostService != null\n                && isProfileSupported(device, BluetoothProfile.HID_HOST)\n                && mHidHostService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Hid Host Profile\");\n            mHidHostService.connect(device);\n        }\n        if (mPanService != null\n                && isProfileSupported(device, BluetoothProfile.PAN)\n                && mPanService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Pan Profile\");\n            mPanService.connect(device);\n        }\n        if (mPbapClientService != null\n                && isProfileSupported(device, BluetoothProfile.PBAP_CLIENT)\n                && mPbapClientService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Pbap\");\n            mPbapClientService.connect(device);\n        }\n        if (mHearingAidService != null\n                && isProfileSupported(device, BluetoothProfile.HEARING_AID)\n                && mHearingAidService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Hearing Aid Profile\");\n            mHearingAidService.connect(device);\n        }\n        if (mHapClientService != null\n                && isProfileSupported(device, BluetoothProfile.HAP_CLIENT)\n                && mHapClientService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting HAS Profile\");\n            mHapClientService.connect(device);\n        }\n        if (mVolumeControlService != null\n                && isProfileSupported(device, BluetoothProfile.VOLUME_CONTROL)\n                && mVolumeControlService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Volume Control Profile\");\n            mVolumeControlService.connect(device);\n        }\n        if (mLeAudioService != null\n                && isProfileSupported(device, BluetoothProfile.LE_AUDIO)\n                && mLeAudioService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting LeAudio profile (BAP)\");\n            mLeAudioService.connect(device);\n        }\n        if (mBassClientService != null\n                && isProfileSupported(device, BluetoothProfile.LE_AUDIO_BROADCAST_ASSISTANT)\n                && mBassClientService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting LE Broadcast Assistant Profile\");\n            mBassClientService.connect(device);\n        }\n        if (mBatteryService != null\n                && isProfileSupported(device, BluetoothProfile.BATTERY)\n                && mBatteryService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Battery Service\");\n            mBatteryService.connect(device);\n        }\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    /**\n     * Verifies that all bluetooth profile services are running\n     *\n     * @return true if all bluetooth profile services running, false otherwise\n     */\n    private boolean profileServicesRunning() {\n        if (mRegisteredProfiles.size() == Config.getSupportedProfiles().length\n                && mRegisteredProfiles.size() == mRunningProfiles.size()) {\n            return true;\n        }\n\n        Log.e(TAG, \"profileServicesRunning: One or more supported services not running\");\n        return false;\n    }\n\n    /** Initializes all the profile services fields */\n    private void initProfileServices() {\n        Log.i(TAG, \"initProfileServices: Initializing all bluetooth profile services\");\n        mA2dpService = A2dpService.getA2dpService();\n        mA2dpSinkService = A2dpSinkService.getA2dpSinkService();\n        mHeadsetService = HeadsetService.getHeadsetService();\n        mHeadsetClientService = HeadsetClientService.getHeadsetClientService();\n        mMapService = BluetoothMapService.getBluetoothMapService();\n        mMapClientService = MapClientService.getMapClientService();\n        mHidDeviceService = HidDeviceService.getHidDeviceService();\n        mHidHostService = HidHostService.getHidHostService();\n        mPanService = PanService.getPanService();\n        mPbapService = BluetoothPbapService.getBluetoothPbapService();\n        mPbapClientService = PbapClientService.getPbapClientService();\n        mHearingAidService = HearingAidService.getHearingAidService();\n        mHapClientService = HapClientService.getHapClientService();\n        mSapService = SapService.getSapService();\n        mVolumeControlService = VolumeControlService.getVolumeControlService();\n        mCsipSetCoordinatorService = CsipSetCoordinatorService.getCsipSetCoordinatorService();\n        mLeAudioService = LeAudioService.getLeAudioService();\n        mBassClientService = BassClientService.getBassClientService();\n        mBatteryService = BatteryService.getBatteryService();\n    }\n\n    @BluetoothAdapter.RfcommListenerResult\n    @RequiresPermission(BLUETOOTH_CONNECT)\n    private int startRfcommListener(\n            String name, ParcelUuid uuid, PendingIntent pendingIntent, AttributionSource source) {\n        if (mBluetoothServerSockets.containsKey(uuid.getUuid())) {\n            Log.d(TAG, \"Cannot start RFCOMM listener: UUID \" + uuid.getUuid() + \"already in use.\");\n            return BluetoothStatusCodes.RFCOMM_LISTENER_START_FAILED_UUID_IN_USE;\n        }\n\n        try {\n            startRfcommListenerInternal(name, uuid.getUuid(), pendingIntent, source);\n        } catch (IOException e) {\n            return BluetoothStatusCodes.RFCOMM_LISTENER_FAILED_TO_CREATE_SERVER_SOCKET;\n        }\n\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    @BluetoothAdapter.RfcommListenerResult\n    @VisibleForTesting\n    int stopRfcommListener(ParcelUuid uuid, AttributionSource source) {\n        RfcommListenerData listenerData = mBluetoothServerSockets.get(uuid.getUuid());\n\n        if (listenerData == null) {\n            Log.d(TAG, \"Cannot stop RFCOMM listener: UUID \" + uuid.getUuid() + \"is not registered\");\n            return BluetoothStatusCodes.RFCOMM_LISTENER_OPERATION_FAILED_NO_MATCHING_SERVICE_RECORD;\n        }\n\n        if (source.getUid() != listenerData.mAttributionSource.getUid()) {\n            return BluetoothStatusCodes.RFCOMM_LISTENER_OPERATION_FAILED_DIFFERENT_APP;\n        }\n\n        // Remove the entry so that it does not try and restart the server socket.\n        mBluetoothServerSockets.remove(uuid.getUuid());\n\n        return listenerData.closeServerAndPendingSockets(mHandler);\n    }\n\n    @VisibleForTesting\n    IncomingRfcommSocketInfo retrievePendingSocketForServiceRecord(\n            ParcelUuid uuid, AttributionSource source) {\n        IncomingRfcommSocketInfo socketInfo = new IncomingRfcommSocketInfo();\n\n        RfcommListenerData listenerData = mBluetoothServerSockets.get(uuid.getUuid());\n\n        if (listenerData == null) {\n            socketInfo.status =\n                    BluetoothStatusCodes\n                            .RFCOMM_LISTENER_OPERATION_FAILED_NO_MATCHING_SERVICE_RECORD;\n            return socketInfo;\n        }\n\n        if (source.getUid() != listenerData.mAttributionSource.getUid()) {\n            socketInfo.status = BluetoothStatusCodes.RFCOMM_LISTENER_OPERATION_FAILED_DIFFERENT_APP;\n            return socketInfo;\n        }\n\n        BluetoothSocket socket = listenerData.mPendingSockets.poll();\n\n        if (socket == null) {\n            socketInfo.status = BluetoothStatusCodes.RFCOMM_LISTENER_NO_SOCKET_AVAILABLE;\n            return socketInfo;\n        }\n\n        mHandler.removeCallbacksAndMessages(socket);\n\n        socketInfo.bluetoothDevice = socket.getRemoteDevice();\n        socketInfo.pfd = socket.getParcelFileDescriptor();\n        socketInfo.status = BluetoothStatusCodes.SUCCESS;\n\n        return socketInfo;\n    }\n\n    @RequiresPermission(BLUETOOTH_CONNECT)\n    private void handleIncomingRfcommConnections(UUID uuid) {\n        RfcommListenerData listenerData = mBluetoothServerSockets.get(uuid);\n        while (true) {\n            BluetoothSocket socket;\n            try {\n                socket = listenerData.mServerSocket.accept();\n            } catch (IOException e) {\n                if (mBluetoothServerSockets.containsKey(uuid)) {\n                    // The uuid still being in the map indicates that the accept failure is\n                    // unexpected. Try and restart the listener.\n                    Log.e(TAG, \"Failed to accept socket on \" + listenerData.mServerSocket, e);\n                    restartRfcommListener(listenerData, uuid);\n                }\n                return;\n            }\n\n            listenerData.mPendingSockets.add(socket);\n            try {\n                listenerData.mPendingIntent.send();\n            } catch (PendingIntent.CanceledException e) {\n                Log.e(TAG, \"PendingIntent for RFCOMM socket notifications cancelled.\", e);\n                // The pending intent was cancelled, close the server as there is no longer any way\n                // to notify the app that registered the listener.\n                listenerData.closeServerAndPendingSockets(mHandler);\n                mBluetoothServerSockets.remove(uuid);\n                return;\n            }\n            mHandler.postDelayed(\n                    () -> pendingSocketTimeoutRunnable(listenerData, socket),\n                    socket,\n                    PENDING_SOCKET_HANDOFF_TIMEOUT.toMillis());\n        }\n    }\n\n    // Tries to restart the rfcomm listener for the given UUID\n    @RequiresPermission(BLUETOOTH_CONNECT)\n    private void restartRfcommListener(RfcommListenerData listenerData, UUID uuid) {\n        listenerData.closeServerAndPendingSockets(mHandler);\n        try {\n            startRfcommListenerInternal(\n                    listenerData.mName,\n                    uuid,\n                    listenerData.mPendingIntent,\n                    listenerData.mAttributionSource);\n        } catch (IOException e) {\n            Log.e(TAG, \"Failed to recreate rfcomm server socket\", e);\n\n            mBluetoothServerSockets.remove(uuid);\n        }\n    }\n\n    private void pendingSocketTimeoutRunnable(\n            RfcommListenerData listenerData, BluetoothSocket socket) {\n        boolean socketFound = listenerData.mPendingSockets.remove(socket);\n        if (socketFound) {\n            try {\n                socket.close();\n            } catch (IOException e) {\n                Log.e(TAG, \"Failed to close bt socket\", e);\n                // We don't care if closing the socket failed, just continue on.\n            }\n        }\n    }\n\n    @RequiresPermission(BLUETOOTH_CONNECT)\n    private void startRfcommListenerInternal(\n            String name, UUID uuid, PendingIntent intent, AttributionSource source)\n            throws IOException {\n        BluetoothServerSocket bluetoothServerSocket =\n                mAdapter.listenUsingRfcommWithServiceRecord(name, uuid);\n\n        RfcommListenerData listenerData =\n                new RfcommListenerData(bluetoothServerSocket, name, intent, source);\n\n        mBluetoothServerSockets.put(uuid, listenerData);\n\n        new Thread(() -> handleIncomingRfcommConnections(uuid)).start();\n    }\n\n    private void stopRfcommServerSockets() {\n        Iterator<Map.Entry<UUID, RfcommListenerData>> socketsIterator =\n                mBluetoothServerSockets.entrySet().iterator();\n        while (socketsIterator.hasNext()) {\n            socketsIterator.next().getValue().closeServerAndPendingSockets(mHandler);\n            socketsIterator.remove();\n        }\n    }\n\n    private static class RfcommListenerData {\n        final BluetoothServerSocket mServerSocket;\n        // Service record name\n        final String mName;\n        // The Intent which contains the Service info to which the incoming socket connections are\n        // handed off to.\n        final PendingIntent mPendingIntent;\n        // AttributionSource for the requester of the RFCOMM listener\n        final AttributionSource mAttributionSource;\n        // Contains the connected sockets which are pending transfer to the app which requested the\n        // listener.\n        final ConcurrentLinkedQueue<BluetoothSocket> mPendingSockets =\n                new ConcurrentLinkedQueue<>();\n\n        RfcommListenerData(\n                BluetoothServerSocket serverSocket,\n                String name,\n                PendingIntent pendingIntent,\n                AttributionSource source) {\n            mServerSocket = serverSocket;\n            mName = name;\n            mPendingIntent = pendingIntent;\n            mAttributionSource = source;\n        }\n\n        int closeServerAndPendingSockets(Handler handler) {\n            int result = BluetoothStatusCodes.SUCCESS;\n            try {\n                mServerSocket.close();\n            } catch (IOException e) {\n                Log.e(TAG, \"Failed to call close on rfcomm server socket\", e);\n                result = BluetoothStatusCodes.RFCOMM_LISTENER_FAILED_TO_CLOSE_SERVER_SOCKET;\n            }\n            mPendingSockets.forEach(\n                    pendingSocket -> {\n                        handler.removeCallbacksAndMessages(pendingSocket);\n                        try {\n                            pendingSocket.close();\n                        } catch (IOException e) {\n                            Log.e(TAG, \"Failed to close socket\", e);\n                        }\n                    });\n            mPendingSockets.clear();\n\n            return result;\n        }\n    }\n\n    @VisibleForTesting\n    boolean isAvailable() {\n        return !mCleaningUp;\n    }\n\n    /**\n     * Set metadata value for the given device and key\n     *\n     * @return true if metadata is set successfully\n     */\n    public boolean setMetadata(BluetoothDevice device, int key, byte[] value) {\n        if (value == null || value.length > BluetoothDevice.METADATA_MAX_LENGTH) {\n            return false;\n        }\n        return mDatabaseManager.setCustomMeta(device, key, value);\n    }\n\n    /**\n     * Get metadata of given device and key\n     *\n     * @return value of given device and key combination\n     */\n    public byte[] getMetadata(BluetoothDevice device, int key) {\n        return mDatabaseManager.getCustomMeta(device, key);\n    }\n\n    /** Update Adapter Properties when BT profiles connection state changes. */\n    public void updateProfileConnectionAdapterProperties(\n            BluetoothDevice device, int profile, int state, int prevState) {\n        mHandler.post(\n                () ->\n                        mAdapterProperties.updateOnProfileConnectionChanged(\n                                device, profile, state, prevState));\n    }\n\n    /**\n     * There is no leak of this binder since it is never re-used and the process is systematically\n     * killed\n     */\n    @VisibleForTesting\n    public static class AdapterServiceBinder extends IBluetooth.Stub {\n        private final AdapterService mService;\n\n        AdapterServiceBinder(AdapterService svc) {\n            mService = svc;\n            if (Flags.getStateFromSystemServer()) {\n                return;\n            }\n            mService.invalidateBluetoothGetStateCache();\n            BluetoothAdapter.getDefaultAdapter().disableBluetoothGetStateCache();\n        }\n\n        public AdapterService getService() {\n            if (!mService.isAvailable()) {\n                return null;\n            }\n            return mService;\n        }\n\n        @Override\n        public int getState() {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothAdapter.STATE_OFF;\n            }\n\n            return service.getState();\n        }\n\n        @Override\n        public void killBluetoothProcess() {\n            mService.enforceCallingPermission(BLUETOOTH_PRIVILEGED, null);\n\n            Runnable killAction =\n                    () -> {\n                        if (Flags.killInsteadOfExit()) {\n                            Log.i(TAG, \"killBluetoothProcess: Calling killProcess(myPid())\");\n                            Process.killProcess(Process.myPid());\n                        } else {\n                            Log.i(TAG, \"killBluetoothProcess: Calling System.exit\");\n                            System.exit(0);\n                        }\n                    };\n\n            // Post on the main handler to let the cleanup complete before calling exit\n            mService.mHandler.post(killAction);\n\n            try {\n                // Wait for Bluetooth to be killed from its main thread\n                Thread.sleep(1_000); // SystemServer is waiting 2000 ms, we need to wait less here\n            } catch (InterruptedException e) {\n                Log.e(TAG, \"killBluetoothProcess: Interrupted while waiting for kill\");\n            }\n\n            // Bluetooth cannot be killed on the main thread; it is in a deadLock.\n            // Trying to recover by killing the Bluetooth from the binder thread.\n            // This is bad :(\n            Counter.logIncrement(\"bluetooth.value_kill_from_binder_thread\");\n            Log.wtf(TAG, \"Failed to kill Bluetooth using its main thread. Trying from binder\");\n            killAction.run();\n        }\n\n        @Override\n        public void offToBleOn(boolean quietMode, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"offToBleOn\")) {\n                return;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            service.offToBleOn(quietMode);\n        }\n\n        @Override\n        public void onToBleOn(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"onToBleOn\")) {\n                return;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            service.onToBleOn();\n        }\n\n        @Override\n        public String getAddress(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getAddress\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getAddress\")) {\n                return null;\n            }\n\n            service.enforceCallingOrSelfPermission(LOCAL_MAC_ADDRESS, null);\n\n            return Utils.getAddressStringFromByte(service.mAdapterProperties.getAddress());\n        }\n\n        @Override\n        public List<ParcelUuid> getUuids(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getUuids\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getUuids\")) {\n                return Collections.emptyList();\n            }\n\n            ParcelUuid[] parcels = service.mAdapterProperties.getUuids();\n            if (parcels == null) {\n                parcels = new ParcelUuid[0];\n            }\n            return Arrays.asList(parcels);\n        }\n\n        @Override\n        public String getIdentityAddress(String address) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getIdentityAddress\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service,\n                            Utils.getCallingAttributionSource(mService),\n                            \"AdapterService getIdentityAddress\")) {\n                return null;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            return service.getIdentityAddress(address);\n        }\n\n        @Override\n        public String getName(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getName\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getName\")) {\n                return null;\n            }\n\n            return service.getName();\n        }\n\n        @Override\n        public int getNameLengthForAdvertise(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"getNameLengthForAdvertise\")\n                    || !Utils.checkAdvertisePermissionForDataDelivery(service, source, TAG)) {\n                return -1;\n            }\n\n            return service.getNameLengthForAdvertise();\n        }\n\n        @Override\n        public boolean setName(String name, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"setName\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService setName\")) {\n                return false;\n            }\n\n            Log.d(TAG, \"AdapterServiceBinder.setName(\" + name + \")\");\n            return service.mAdapterProperties.setName(name);\n        }\n\n        @Override\n        public int getScanMode(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getScanMode\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, source, \"AdapterService getScanMode\")) {\n                return SCAN_MODE_NONE;\n            }\n\n            return service.getScanMode();\n        }\n\n        @Override\n        public int setScanMode(int mode, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"setScanMode\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, source, \"AdapterService setScanMode\")) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_SCAN_PERMISSION;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            String logCaller = Utils.getUidPidString() + \" packageName=\" + source.getPackageName();\n            CompletableFuture<Boolean> future = new CompletableFuture<>();\n            mService.mHandler.post(\n                    () ->\n                            future.complete(\n                                    service.getState() == BluetoothAdapter.STATE_ON\n                                            && service.setScanMode(mode, logCaller)));\n            return future.join()\n                    ? BluetoothStatusCodes.SUCCESS\n                    : BluetoothStatusCodes.ERROR_UNKNOWN;\n        }\n\n        @Override\n        public long getDiscoverableTimeout(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getDiscoverableTimeout\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, source, \"AdapterService getDiscoverableTimeout\")) {\n                return -1;\n            }\n\n            return service.mAdapterProperties.getDiscoverableTimeout();\n        }\n\n        @Override\n        public int setDiscoverableTimeout(long timeout, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"setDiscoverableTimeout\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, source, \"AdapterService setDiscoverableTimeout\")) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_SCAN_PERMISSION;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            return service.mAdapterProperties.setDiscoverableTimeout((int) timeout)\n                    ? BluetoothStatusCodes.SUCCESS\n                    : BluetoothStatusCodes.ERROR_UNKNOWN;\n        }\n\n        @Override\n        public boolean startDiscovery(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"startDiscovery\")) {\n                return false;\n            }\n\n            if (!Utils.checkScanPermissionForDataDelivery(service, source, \"Starting discovery.\")) {\n                return false;\n            }\n\n            Log.i(TAG, \"startDiscovery: from \" + Utils.getUidPidString());\n            return service.startDiscovery(source);\n        }\n\n        @Override\n        public boolean cancelDiscovery(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"cancelDiscovery\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, source, \"AdapterService cancelDiscovery\")) {\n                return false;\n            }\n\n            Log.i(TAG, \"cancelDiscovery: from \" + Utils.getUidPidString());\n            return service.mNativeInterface.cancelDiscovery();\n        }\n\n        @Override\n        public boolean isDiscovering(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"isDiscovering\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, source, \"AdapterService isDiscovering\")) {\n                return false;\n            }\n\n            return service.mAdapterProperties.isDiscovering();\n        }\n\n        @Override\n        public long getDiscoveryEndMillis(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getDiscoveryEndMillis\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return -1;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            return service.mAdapterProperties.discoveryEndMillis();\n        }\n\n        @Override\n        public List<BluetoothDevice> getMostRecentlyConnectedDevices(AttributionSource source) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getMostRecentlyConnectedDevices\")) {\n                return Collections.emptyList();\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            return service.mDatabaseManager.getMostRecentlyConnectedDevices();\n        }\n\n        @Override\n        public List<BluetoothDevice> getBondedDevices(AttributionSource source) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getBondedDevices\")) {\n                return Collections.emptyList();\n            }\n\n            return Arrays.asList(service.getBondedDevices());\n        }\n\n        @Override\n        public int getAdapterConnectionState() {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothAdapter.STATE_DISCONNECTED;\n            }\n\n            return service.mAdapterProperties.getConnectionState();\n        }\n\n        /**\n         * This method has an associated binder cache. The invalidation methods must be changed if\n         * the logic behind this method changes.\n         */\n        @Override\n        public int getProfileConnectionState(int profile, AttributionSource source) {\n            AdapterService service = getService();\n            boolean checkConnect = false;\n            final int callingUid = Binder.getCallingUid();\n            final long token = Binder.clearCallingIdentity();\n            try {\n                checkConnect = CompatChanges.isChangeEnabled(ENFORCE_CONNECT, callingUid);\n            } finally {\n                Binder.restoreCallingIdentity(token);\n            }\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"getProfileConnectionState\")\n                    || (checkConnect\n                            && !Utils.checkConnectPermissionForDataDelivery(\n                                    service, source, \"AdapterService getProfileConnectionState\"))) {\n                return BluetoothProfile.STATE_DISCONNECTED;\n            }\n\n            return service.mAdapterProperties.getProfileConnectionState(profile);\n        }\n\n        @Override\n        public boolean createBond(\n                BluetoothDevice device,\n                int transport,\n                OobData remoteP192Data,\n                OobData remoteP256Data,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"createBond\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService createBond\")) {\n                return false;\n            }\n\n            // This conditional is required to satisfy permission dependencies\n            // since createBond calls createBondOutOfBand with null value passed as data.\n            // BluetoothDevice#createBond requires BLUETOOTH_ADMIN only.\n            service.enforceBluetoothPrivilegedPermissionIfNeeded(remoteP192Data, remoteP256Data);\n\n            Log.i(\n                    TAG,\n                    \"createBond:\"\n                            + (\" device=\" + device)\n                            + (\" transport=\" + transport)\n                            + (\" from \" + Utils.getUidPidString()));\n            return service.createBond(\n                    device, transport, remoteP192Data, remoteP256Data, source.getPackageName());\n        }\n\n        @Override\n        public boolean cancelBondProcess(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"cancelBondProcess\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService cancelBondProcess\")) {\n                return false;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            Log.i(TAG, \"cancelBondProcess: device=\" + device + \", from \" + Utils.getUidPidString());\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp != null) {\n                deviceProp.setBondingInitiatedLocally(false);\n            }\n\n            return service.mNativeInterface.cancelBond(getBytesFromAddress(device.getAddress()));\n        }\n\n        @Override\n        public boolean removeBond(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"removeBond\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService removeBond\")) {\n                return false;\n            }\n\n            Log.i(TAG, \"removeBond: device=\" + device + \", from \" + Utils.getUidPidString());\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null || deviceProp.getBondState() != BluetoothDevice.BOND_BONDED) {\n                Log.w(\n                        TAG,\n                        device\n                                + \" cannot be removed since \"\n                                + ((deviceProp == null)\n                                        ? \"properties are empty\"\n                                        : \"bond state is \" + deviceProp.getBondState()));\n                return false;\n            }\n            service.mBondAttemptCallerInfo.remove(device.getAddress());\n            deviceProp.setBondingInitiatedLocally(false);\n\n            Message msg = service.mBondStateMachine.obtainMessage(BondStateMachine.REMOVE_BOND);\n            msg.obj = device;\n            service.mBondStateMachine.sendMessage(msg);\n            return true;\n        }\n\n        @Override\n        public int getBondState(BluetoothDevice device, AttributionSource source) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getBondState\")) {\n                return BluetoothDevice.BOND_NONE;\n            }\n\n            return service.getBondState(device);\n        }\n\n        @Override\n        public boolean isBondingInitiatedLocally(BluetoothDevice device, AttributionSource source) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService isBondingInitiatedLocally\")) {\n                return false;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            return deviceProp != null && deviceProp.isBondingInitiatedLocally();\n        }\n\n        @Override\n        public void generateLocalOobData(\n                int transport, IBluetoothOobDataCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"generateLocalOobData\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            service.generateLocalOobData(transport, callback);\n        }\n\n        @Override\n        public long getSupportedProfiles(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return 0;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            return Config.getSupportedProfilesBitMask();\n        }\n\n        @Override\n        public int getConnectionState(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getConnectionState\")) {\n                return BluetoothDevice.CONNECTION_STATE_DISCONNECTED;\n            }\n\n            return service.getConnectionState(device);\n        }\n\n        @Override\n        public int getConnectionHandle(\n                BluetoothDevice device, int transport, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getConnectionHandle\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothDevice.ERROR;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            return service.getConnectionHandle(device, transport);\n        }\n\n        @Override\n        public boolean canBondWithoutDialog(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            return service.canBondWithoutDialog(device);\n        }\n\n        @Override\n        public String getPackageNameOfBondingApplication(\n                BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return null;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            return service.getPackageNameOfBondingApplication(device);\n        }\n\n        @Override\n        public boolean removeActiveDevice(@ActiveDeviceUse int profiles, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"removeActiveDevice\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            service.enforceCallingOrSelfPermission(MODIFY_PHONE_STATE, null);\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            Log.i(\n                    TAG,\n                    \"removeActiveDevice: profiles=\"\n                            + profiles\n                            + \", from \"\n                            + Utils.getUidPidString());\n            return service.setActiveDevice(null, profiles);\n        }\n\n        @Override\n        public boolean setActiveDevice(\n                BluetoothDevice device, @ActiveDeviceUse int profiles, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"setActiveDevice\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            service.enforceCallingOrSelfPermission(MODIFY_PHONE_STATE, null);\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            Log.i(\n                    TAG,\n                    \"setActiveDevice: device=\"\n                            + device\n                            + \", profiles=\"\n                            + profiles\n                            + \", from \"\n                            + Utils.getUidPidString());\n\n            return service.setActiveDevice(device, profiles);\n        }\n\n        @Override\n        public List<BluetoothDevice> getActiveDevices(\n                @ActiveDeviceProfile int profile, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getActiveDevices\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return Collections.emptyList();\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            return service.getActiveDevices(profile);\n        }\n\n        @Override\n        public int connectAllEnabledProfiles(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null || !service.isEnabled()) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveOrManagedUser(service, TAG, \"connectAllEnabledProfiles\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            if (device == null) {\n                throw new IllegalArgumentException(\"device cannot be null\");\n            }\n            if (!BluetoothAdapter.checkBluetoothAddress(device.getAddress())) {\n                throw new IllegalArgumentException(\"device cannot have an invalid address\");\n            }\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n\n            service.enforceCallingOrSelfPermission(MODIFY_PHONE_STATE, null);\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            Log.i(\n                    TAG,\n                    \"connectAllEnabledProfiles: device=\"\n                            + device\n                            + \", from \"\n                            + Utils.getUidPidString());\n            MetricsLogger.getInstance()\n                    .logBluetoothEvent(\n                            device,\n                            BluetoothStatsLog\n                                    .BLUETOOTH_CROSS_LAYER_EVENT_REPORTED__EVENT_TYPE__INITIATOR_CONNECTION,\n                            BluetoothStatsLog.BLUETOOTH_CROSS_LAYER_EVENT_REPORTED__STATE__START,\n                            source.getUid());\n\n            try {\n                return service.connectAllEnabledProfiles(device);\n            } catch (Exception e) {\n                Log.v(TAG, \"connectAllEnabledProfiles() failed\", e);\n                SneakyThrow.sneakyThrow(e);\n                throw new RuntimeException(e);\n            }\n        }\n\n        @Override\n        public int disconnectAllEnabledProfiles(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveOrManagedUser(\n                    service, TAG, \"disconnectAllEnabledProfiles\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            if (device == null) {\n                throw new IllegalArgumentException(\"device cannot be null\");\n            }\n            if (!BluetoothAdapter.checkBluetoothAddress(device.getAddress())) {\n                throw new IllegalArgumentException(\"device cannot have an invalid address\");\n            }\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            Log.i(\n                    TAG,\n                    \"disconnectAllEnabledProfiles: device=\"\n                            + device\n                            + \", from \"\n                            + Utils.getUidPidString());\n\n            try {\n                return service.disconnectAllEnabledProfiles(device);\n            } catch (Exception e) {\n                Log.v(TAG, \"disconnectAllEnabledProfiles() failed\", e);\n                SneakyThrow.sneakyThrow(e);\n                throw new RuntimeException(e);\n            }\n        }\n\n        @Override\n        public String getRemoteName(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteName\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getRemoteName\")) {\n                return null;\n            }\n\n            return service.getRemoteName(device);\n        }\n\n        @Override\n        public int getRemoteType(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteType\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getRemoteType\")) {\n                return BluetoothDevice.DEVICE_TYPE_UNKNOWN;\n            }\n\n            return service.getRemoteType(device);\n        }\n\n        @Override\n        public String getRemoteAlias(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteAlias\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getRemoteAlias\")) {\n                return null;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            return deviceProp != null ? deviceProp.getAlias() : null;\n        }\n\n        @Override\n        public int setRemoteAlias(BluetoothDevice device, String name, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveOrManagedUser(service, TAG, \"setRemoteAlias\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            if (name != null && name.isEmpty()) {\n                throw new IllegalArgumentException(\"alias cannot be the empty string\");\n            }\n\n            if (!Utils.checkConnectPermissionForDataDelivery(\n                    service, source, \"AdapterService setRemoteAlias\")) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n\n            Utils.enforceCdmAssociationIfNotBluetoothPrivileged(\n                    service, service.mCompanionDeviceManager, source, device);\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null) {\n                return BluetoothStatusCodes.ERROR_DEVICE_NOT_BONDED;\n            }\n            deviceProp.setAlias(device, name);\n            return BluetoothStatusCodes.SUCCESS;\n        }\n\n        @Override\n        public int getRemoteClass(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteClass\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getRemoteClass\")) {\n                return 0;\n            }\n\n            return service.getRemoteClass(device);\n        }\n\n        @Override\n        public List<ParcelUuid> getRemoteUuids(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteUuids\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getRemoteUuids\")) {\n                return Collections.emptyList();\n            }\n\n            final ParcelUuid[] parcels = service.getRemoteUuids(device);\n            if (parcels == null) {\n                return null;\n            }\n            return Arrays.asList(parcels);\n        }\n\n        @Override\n        public boolean fetchRemoteUuids(\n                BluetoothDevice device, int transport, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"fetchRemoteUuids\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService fetchRemoteUuids\")) {\n                return false;\n            }\n            if (transport != TRANSPORT_AUTO) {\n                service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            }\n\n            Log.i(\n                    TAG,\n                    \"fetchRemoteUuids: device=\"\n                            + device\n                            + \", transport=\"\n                            + transport\n                            + \", from \"\n                            + Utils.getUidPidString());\n\n            service.mRemoteDevices.fetchUuids(device, transport);\n            MetricsLogger.getInstance().cacheCount(BluetoothProtoEnums.SDP_FETCH_UUID_REQUEST, 1);\n            return true;\n        }\n\n        @Override\n        public boolean setPin(\n                BluetoothDevice device,\n                boolean accept,\n                int len,\n                byte[] pinCode,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"setPin\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService setPin\")) {\n                return false;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            // Only allow setting a pin in bonding state, or bonded state in case of security\n            // upgrade.\n            if (deviceProp == null || !deviceProp.isBondingOrBonded()) {\n                Log.e(TAG, \"setPin: device=\" + device + \", not bonding\");\n                return false;\n            }\n            if (pinCode.length != len) {\n                android.util.EventLog.writeEvent(\n                        0x534e4554, \"139287605\", -1, \"PIN code length mismatch\");\n                return false;\n            }\n            service.logUserBondResponse(\n                    device, accept, BluetoothProtoEnums.BOND_SUB_STATE_LOCAL_PIN_REPLIED);\n            Log.i(\n                    TAG,\n                    \"setPin: device=\"\n                            + device\n                            + \", accept=\"\n                            + accept\n                            + \", from \"\n                            + Utils.getUidPidString());\n            return service.mNativeInterface.pinReply(\n                    getBytesFromAddress(device.getAddress()), accept, len, pinCode);\n        }\n\n        @Override\n        public boolean setPasskey(\n                BluetoothDevice device,\n                boolean accept,\n                int len,\n                byte[] passkey,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"setPasskey\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService setPasskey\")) {\n                return false;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null || !deviceProp.isBonding()) {\n                Log.e(TAG, \"setPasskey: device=\" + device + \", not bonding\");\n                return false;\n            }\n            if (passkey.length != len) {\n                android.util.EventLog.writeEvent(\n                        0x534e4554, \"139287605\", -1, \"Passkey length mismatch\");\n                return false;\n            }\n            service.logUserBondResponse(\n                    device, accept, BluetoothProtoEnums.BOND_SUB_STATE_LOCAL_SSP_REPLIED);\n            Log.i(\n                    TAG,\n                    \"setPasskey: device=\"\n                            + device\n                            + \", accept=\"\n                            + accept\n                            + \", from \"\n                            + Utils.getUidPidString());\n\n            return service.mNativeInterface.sspReply(\n                    getBytesFromAddress(device.getAddress()),\n                    AbstractionLayer.BT_SSP_VARIANT_PASSKEY_ENTRY,\n                    accept,\n                    Utils.byteArrayToInt(passkey));\n        }\n\n        @Override\n        public boolean setPairingConfirmation(\n                BluetoothDevice device, boolean accept, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"setPairingConfirmation\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null || !deviceProp.isBonding()) {\n                Log.e(TAG, \"setPairingConfirmation: device=\" + device + \", not bonding\");\n                return false;\n            }\n            service.logUserBondResponse(\n                    device, accept, BluetoothProtoEnums.BOND_SUB_STATE_LOCAL_SSP_REPLIED);\n            Log.i(\n                    TAG,\n                    \"setPairingConfirmation: device=\"\n                            + device\n                            + \", accept=\"\n                            + accept\n                            + \", from \"\n                            + Utils.getUidPidString());\n\n            return service.mNativeInterface.sspReply(\n                    getBytesFromAddress(device.getAddress()),\n                    AbstractionLayer.BT_SSP_VARIANT_PASSKEY_CONFIRMATION,\n                    accept,\n                    0);\n        }\n\n        @Override\n        public boolean getSilenceMode(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getSilenceMode\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            return service.mSilenceDeviceManager.getSilenceMode(device);\n        }\n\n        @Override\n        public boolean setSilenceMode(\n                BluetoothDevice device, boolean silence, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"setSilenceMode\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            service.mSilenceDeviceManager.setSilenceMode(device, silence);\n            return true;\n        }\n\n        @Override\n        public int getPhonebookAccessPermission(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"getPhonebookAccessPermission\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getPhonebookAccessPermission\")) {\n                return BluetoothDevice.ACCESS_UNKNOWN;\n            }\n\n            return service.getPhonebookAccessPermission(device);\n        }\n\n        @Override\n        public boolean setPhonebookAccessPermission(\n                BluetoothDevice device, int value, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"setPhonebookAccessPermission\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            service.setPhonebookAccessPermission(device, value);\n            return true;\n        }\n\n        @Override\n        public int getMessageAccessPermission(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"getMessageAccessPermission\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getMessageAccessPermission\")) {\n                return BluetoothDevice.ACCESS_UNKNOWN;\n            }\n\n            return service.getMessageAccessPermission(device);\n        }\n\n        @Override\n        public boolean setMessageAccessPermission(\n                BluetoothDevice device, int value, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"setMessageAccessPermission\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            service.setMessageAccessPermission(device, value);\n            return true;\n        }\n\n        @Override\n        public int getSimAccessPermission(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getSimAccessPermission\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getSimAccessPermission\")) {\n                return BluetoothDevice.ACCESS_UNKNOWN;\n            }\n\n            return service.getSimAccessPermission(device);\n        }\n\n        @Override\n        public boolean setSimAccessPermission(\n                BluetoothDevice device, int value, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"setSimAccessPermission\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            service.setSimAccessPermission(device, value);\n            return true;\n        }\n\n        @Override\n        public void logL2capcocServerConnection(\n                BluetoothDevice device,\n                int port,\n                boolean isSecured,\n                int result,\n                long socketCreationTimeMillis,\n                long socketCreationLatencyMillis,\n                long socketConnectionTimeMillis,\n                long timeoutMillis) {\n            AdapterService service = getService();\n            if (service == null) {\n                return;\n            }\n            service.logL2capcocServerConnection(\n                    device,\n                    port,\n                    isSecured,\n                    result,\n                    socketCreationTimeMillis,\n                    socketCreationLatencyMillis,\n                    socketConnectionTimeMillis,\n                    timeoutMillis,\n                    Binder.getCallingUid());\n        }\n\n        @Override\n        public IBluetoothSocketManager getSocketManager() {\n            AdapterService service = getService();\n            if (service == null) {\n                return null;\n            }\n\n            return IBluetoothSocketManager.Stub.asInterface(service.mBluetoothSocketManagerBinder);\n        }\n\n        @Override\n        public void logL2capcocClientConnection(\n                BluetoothDevice device,\n                int port,\n                boolean isSecured,\n                int result,\n                long socketCreationTimeNanos,\n                long socketCreationLatencyNanos,\n                long socketConnectionTimeNanos) {\n            AdapterService service = getService();\n            if (service == null) {\n                return;\n            }\n            service.logL2capcocClientConnection(\n                    device,\n                    port,\n                    isSecured,\n                    result,\n                    socketCreationTimeNanos,\n                    socketCreationLatencyNanos,\n                    socketConnectionTimeNanos,\n                    Binder.getCallingUid());\n        }\n\n        @Override\n        public void logRfcommConnectionAttempt(\n                BluetoothDevice device,\n                boolean isSecured,\n                int resultCode,\n                long socketCreationTimeNanos,\n                boolean isSerialPort) {\n            AdapterService service = getService();\n            if (service == null) {\n                return;\n            }\n            service.logRfcommConnectionAttempt(\n                    device,\n                    isSecured,\n                    resultCode,\n                    socketCreationTimeNanos,\n                    isSerialPort,\n                    Binder.getCallingUid());\n        }\n\n        @Override\n        public boolean sdpSearch(\n                BluetoothDevice device, ParcelUuid uuid, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"sdpSearch\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService sdpSearch\")) {\n                return false;\n            }\n            return service.sdpSearch(device, uuid);\n        }\n\n        @Override\n        public int getBatteryLevel(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getBatteryLevel\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getBatteryLevel\")) {\n                return BluetoothDevice.BATTERY_LEVEL_UNKNOWN;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null) {\n                return BluetoothDevice.BATTERY_LEVEL_UNKNOWN;\n            }\n            return deviceProp.getBatteryLevel();\n        }\n\n        @Override\n        public int getMaxConnectedAudioDevices(AttributionSource source) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getMaxConnectedAudioDevices\")) {\n                return -1;\n            }\n\n            return service.getMaxConnectedAudioDevices();\n        }\n\n        @Override\n        public boolean factoryReset(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            return service.factoryReset();\n        }\n\n        @Override\n        public void registerBluetoothConnectionCallback(\n                IBluetoothConnectionCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"registerBluetoothConnectionCallback\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            service.mBluetoothConnectionCallbacks.register(callback);\n        }\n\n        @Override\n        public void unregisterBluetoothConnectionCallback(\n                IBluetoothConnectionCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"unregisterBluetoothConnectionCallback\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            service.mBluetoothConnectionCallbacks.unregister(callback);\n        }\n\n        @Override\n        public void registerCallback(IBluetoothCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"registerCallback\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            service.registerRemoteCallback(callback);\n        }\n\n        @Override\n        public void unregisterCallback(IBluetoothCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"unregisterCallback\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            service.unregisterRemoteCallback(callback);\n        }\n\n        @Override\n        public boolean isMultiAdvertisementSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            int val = service.mAdapterProperties.getNumOfAdvertisementInstancesSupported();\n            return val >= MIN_ADVT_INSTANCES_FOR_MA;\n        }\n\n        /**\n         * This method has an associated binder cache. The invalidation methods must be changed if\n         * the logic behind this method changes.\n         */\n        @Override\n        public boolean isOffloadedFilteringSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            int val = service.getNumOfOffloadedScanFilterSupported();\n            return val >= MIN_OFFLOADED_FILTERS;\n        }\n\n        @Override\n        public boolean isOffloadedScanBatchingSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            int val = service.getOffloadedScanResultStorage();\n            return val >= MIN_OFFLOADED_SCAN_STORAGE_BYTES;\n        }\n\n        @Override\n        public boolean isLe2MPhySupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.isLe2MPhySupported();\n        }\n\n        @Override\n        public boolean isLeCodedPhySupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.isLeCodedPhySupported();\n        }\n\n        @Override\n        public boolean isLeExtendedAdvertisingSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.isLeExtendedAdvertisingSupported();\n        }\n\n        @Override\n        public boolean isLePeriodicAdvertisingSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.isLePeriodicAdvertisingSupported();\n        }\n\n        @Override\n        public int isLeAudioSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n\n            Set<Integer> supportedProfileServices =\n                    Arrays.stream(Config.getSupportedProfiles())\n                            .boxed()\n                            .collect(Collectors.toSet());\n            int[] leAudioUnicastProfiles = Config.getLeAudioUnicastProfiles();\n\n            if (Arrays.stream(leAudioUnicastProfiles)\n                    .allMatch(supportedProfileServices::contains)) {\n                return BluetoothStatusCodes.FEATURE_SUPPORTED;\n            }\n\n            return BluetoothStatusCodes.FEATURE_NOT_SUPPORTED;\n        }\n\n        @Override\n        public int isLeAudioBroadcastSourceSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n\n            long supportBitMask = Config.getSupportedProfilesBitMask();\n            if ((supportBitMask & (1 << BluetoothProfile.LE_AUDIO_BROADCAST)) != 0) {\n                return BluetoothStatusCodes.FEATURE_SUPPORTED;\n            }\n\n            return BluetoothStatusCodes.FEATURE_NOT_SUPPORTED;\n        }\n\n        @Override\n        public int isLeAudioBroadcastAssistantSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n\n            int[] supportedProfileServices = Config.getSupportedProfiles();\n\n            if (Arrays.stream(supportedProfileServices)\n                    .anyMatch(\n                            profileId ->\n                                    profileId == BluetoothProfile.LE_AUDIO_BROADCAST_ASSISTANT)) {\n                return BluetoothStatusCodes.FEATURE_SUPPORTED;\n            }\n\n            return BluetoothStatusCodes.FEATURE_NOT_SUPPORTED;\n        }\n\n        @Override\n        public int isDistanceMeasurementSupported(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            } else if (!callerIsSystemOrActiveOrManagedUser(\n                    service, TAG, \"isDistanceMeasurementSupported\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            } else if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            return BluetoothStatusCodes.FEATURE_SUPPORTED;\n        }\n\n        @Override\n        public int getLeMaximumAdvertisingDataLength() {\n            AdapterService service = getService();\n            if (service == null) {\n                return 0;\n            }\n\n            return service.getLeMaximumAdvertisingDataLength();\n        }\n\n        @Override\n        public boolean isActivityAndEnergyReportingSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.mAdapterProperties.isActivityAndEnergyReportingSupported();\n        }\n\n        @Override\n        public BluetoothActivityEnergyInfo reportActivityInfo(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return null;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            return service.reportActivityInfo();\n        }\n\n        @Override\n        public boolean registerMetadataListener(\n                IBluetoothMetadataListener listener,\n                BluetoothDevice device,\n                AttributionSource source) {\n            requireNonNull(device);\n            requireNonNull(listener);\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"registerMetadataListener\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            service.mHandler.post(\n                    () ->\n                            service.mMetadataListeners\n                                    .computeIfAbsent(device, k -> new RemoteCallbackList())\n                                    .register(listener));\n\n            return true;\n        }\n\n        @Override\n        public boolean unregisterMetadataListener(\n                IBluetoothMetadataListener listener,\n                BluetoothDevice device,\n                AttributionSource source) {\n            requireNonNull(device);\n            requireNonNull(listener);\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"unregisterMetadataListener\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            service.mHandler.post(\n                    () ->\n                            service.mMetadataListeners.computeIfPresent(\n                                    device,\n                                    (k, v) -> {\n                                        v.unregister(listener);\n                                        if (v.getRegisteredCallbackCount() == 0) {\n                                            return null;\n                                        }\n                                        return v;\n                                    }));\n            return true;\n        }\n\n        @Override\n        public boolean setMetadata(\n                BluetoothDevice device, int key, byte[] value, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"setMetadata\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            return service.setMetadata(device, key, value);\n        }\n\n        @Override\n        public byte[] getMetadata(BluetoothDevice device, int key, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getMetadata\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return null;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            return service.getMetadata(device, key);\n        }\n\n        @Override\n        public int isRequestAudioPolicyAsSinkSupported(\n                BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"isRequestAudioPolicyAsSinkSupported\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.FEATURE_NOT_CONFIGURED;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            return service.isRequestAudioPolicyAsSinkSupported(device);\n        }\n\n        @Override\n        public int requestAudioPolicyAsSink(\n                BluetoothDevice device,\n                BluetoothSinkAudioPolicy policies,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            } else if (!callerIsSystemOrActiveOrManagedUser(\n                    service, TAG, \"requestAudioPolicyAsSink\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            } else if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            return service.requestAudioPolicyAsSink(device, policies);\n        }\n\n        @Override\n        public BluetoothSinkAudioPolicy getRequestedAudioPolicyAsSink(\n                BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"getRequestedAudioPolicyAsSink\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return null;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            return service.getRequestedAudioPolicyAsSink(device);\n        }\n\n        @Override\n        public void requestActivityInfo(\n                IBluetoothActivityEnergyInfoListener listener, AttributionSource source) {\n            BluetoothActivityEnergyInfo info = reportActivityInfo(source);\n            try {\n                listener.onBluetoothActivityEnergyInfoAvailable(info);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"onBluetoothActivityEnergyInfo: RemoteException\", e);\n            }\n        }\n\n        @Override\n        public void bleOnToOn(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"bleOnToOn\")) {\n                return;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            service.bleOnToOn();\n        }\n\n        @Override\n        public void bleOnToOff(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"bleOnToOff\")) {\n                return;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            service.bleOnToOff();\n        }\n\n        @Override\n        public void dump(FileDescriptor fd, String[] args) {\n            PrintWriter writer = new PrintWriter(new FileOutputStream(fd));\n            AdapterService service = getService();\n            if (service == null) {\n                return;\n            }\n\n            service.enforceCallingOrSelfPermission(DUMP, null);\n\n            service.dump(fd, writer, args);\n            writer.close();\n        }\n\n        @Override\n        public boolean allowLowLatencyAudio(boolean allowed, BluetoothDevice device) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"allowLowLatencyAudio\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service,\n                            Utils.getCallingAttributionSource(service),\n                            \"AdapterService allowLowLatencyAudio\")) {\n                return false;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            return service.allowLowLatencyAudio(allowed, device);\n        }\n\n        @Override\n        public int startRfcommListener(\n                String name,\n                ParcelUuid uuid,\n                PendingIntent pendingIntent,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"startRfcommListener\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService startRfcommListener\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            return service.startRfcommListener(name, uuid, pendingIntent, source);\n        }\n\n        @Override\n        public int stopRfcommListener(ParcelUuid uuid, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"stopRfcommListener\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService stopRfcommListener\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            return service.stopRfcommListener(uuid, source);\n        }\n\n        @Override\n        public IncomingRfcommSocketInfo retrievePendingSocketForServiceRecord(\n                ParcelUuid uuid, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"retrievePendingSocketForServiceRecord\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service,\n                            source,\n                            \"AdapterService retrievePendingSocketForServiceRecord\")) {\n                return null;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            return service.retrievePendingSocketForServiceRecord(uuid, source);\n        }\n\n        @Override\n        public void setForegroundUserId(int userId, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service,\n                            Utils.getCallingAttributionSource(mService),\n                            \"AdapterService setForegroundUserId\")) {\n                return;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            Utils.setForegroundUserId(userId);\n        }\n\n        @Override\n        public int setPreferredAudioProfiles(\n                BluetoothDevice device, Bundle modeToProfileBundle, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveOrManagedUser(service, TAG, \"setPreferredAudioProfiles\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            requireNonNull(device);\n            requireNonNull(modeToProfileBundle);\n            if (!BluetoothAdapter.checkBluetoothAddress(device.getAddress())) {\n                throw new IllegalArgumentException(\"device cannot have an invalid address\");\n            }\n            if (service.getBondState(device) != BluetoothDevice.BOND_BONDED) {\n                return BluetoothStatusCodes.ERROR_DEVICE_NOT_BONDED;\n            }\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            return service.setPreferredAudioProfiles(device, modeToProfileBundle);\n        }\n\n        @Override\n        public Bundle getPreferredAudioProfiles(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return Bundle.EMPTY;\n            }\n            if (!callerIsSystemOrActiveOrManagedUser(service, TAG, \"getPreferredAudioProfiles\")) {\n                return Bundle.EMPTY;\n            }\n            requireNonNull(device);\n            if (!BluetoothAdapter.checkBluetoothAddress(device.getAddress())) {\n                throw new IllegalArgumentException(\"device cannot have an invalid address\");\n            }\n            if (service.getBondState(device) != BluetoothDevice.BOND_BONDED) {\n                return Bundle.EMPTY;\n            }\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return Bundle.EMPTY;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            return service.getPreferredAudioProfiles(device);\n        }\n\n        @Override\n        public int notifyActiveDeviceChangeApplied(\n                BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystem(TAG, \"notifyActiveDeviceChangeApplied\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            requireNonNull(device);\n            if (!BluetoothAdapter.checkBluetoothAddress(device.getAddress())) {\n                throw new IllegalArgumentException(\"device cannot have an invalid address\");\n            }\n            if (service.getBondState(device) != BluetoothDevice.BOND_BONDED) {\n                return BluetoothStatusCodes.ERROR_DEVICE_NOT_BONDED;\n            }\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            return service.notifyActiveDeviceChangeApplied(device);\n        }\n\n        @Override\n        public int isDualModeAudioEnabled(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            if (!Utils.isDualModeAudioEnabled()) {\n                return BluetoothStatusCodes.FEATURE_NOT_SUPPORTED;\n            }\n\n            return BluetoothStatusCodes.SUCCESS;\n        }\n\n        @Override\n        public int registerPreferredAudioProfilesChangedCallback(\n                IBluetoothPreferredAudioProfilesCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveOrManagedUser(\n                    service, TAG, \"registerPreferredAudioProfilesChangedCallback\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            requireNonNull(callback);\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            // If LE only mode is enabled, the dual mode audio feature is disabled\n            if (!Utils.isDualModeAudioEnabled()) {\n                return BluetoothStatusCodes.FEATURE_NOT_SUPPORTED;\n            }\n\n            service.mPreferredAudioProfilesCallbacks.register(callback);\n            return BluetoothStatusCodes.SUCCESS;\n        }\n\n        @Override\n        public int unregisterPreferredAudioProfilesChangedCallback(\n                IBluetoothPreferredAudioProfilesCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveOrManagedUser(\n                    service, TAG, \"unregisterPreferredAudioProfilesChangedCallback\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            requireNonNull(callback);\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            if (!service.mPreferredAudioProfilesCallbacks.unregister(callback)) {\n                Log.e(\n                        TAG,\n                        \"unregisterPreferredAudioProfilesChangedCallback: callback was never \"\n                                + \"registered\");\n                return BluetoothStatusCodes.ERROR_CALLBACK_NOT_REGISTERED;\n            }\n            return BluetoothStatusCodes.SUCCESS;\n        }\n\n        @Override\n        public int registerBluetoothQualityReportReadyCallback(\n                IBluetoothQualityReportReadyCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveOrManagedUser(\n                    service, TAG, \"registerBluetoothQualityReportReadyCallback\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            requireNonNull(callback);\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            service.mBluetoothQualityReportReadyCallbacks.register(callback);\n            return BluetoothStatusCodes.SUCCESS;\n        }\n\n        @Override\n        public int unregisterBluetoothQualityReportReadyCallback(\n                IBluetoothQualityReportReadyCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveOrManagedUser(\n                    service, TAG, \"unregisterBluetoothQualityReportReadyCallback\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            requireNonNull(callback);\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            if (!service.mBluetoothQualityReportReadyCallbacks.unregister(callback)) {\n                Log.e(\n                        TAG,\n                        \"unregisterBluetoothQualityReportReadyCallback: callback was never \"\n                                + \"registered\");\n                return BluetoothStatusCodes.ERROR_CALLBACK_NOT_REGISTERED;\n            }\n            return BluetoothStatusCodes.SUCCESS;\n        }\n\n        @Override\n        public int getOffloadedTransportDiscoveryDataScanSupported(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"getOffloadedTransportDiscoveryDataScanSupported\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, source, \"getOffloadedTransportDiscoveryDataScanSupported\")) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_SCAN_PERMISSION;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            return service.getOffloadedTransportDiscoveryDataScanSupported();\n        }\n\n        @Override\n        public boolean isMediaProfileConnected(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService.isMediaProfileConnected\")) {\n                return false;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            return service.isMediaProfileConnected();\n        }\n\n        @Override\n        public IBinder getBluetoothGatt() {\n            AdapterService service = getService();\n            return service == null ? null : service.getBluetoothGatt();\n        }\n\n        @Override\n        public IBinder getBluetoothScan() {\n            AdapterService service = getService();\n            return service == null ? null : service.getBluetoothScan();\n        }\n\n        @Override\n        public void unregAllGattClient(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            service.unregAllGattClient(source);\n        }\n\n        @Override\n        public IBinder getProfile(int profileId) {\n            AdapterService service = getService();\n            if (service == null) {\n                return null;\n            }\n\n            return service.getProfile(profileId);\n        }\n\n        @Override\n        public int setActiveAudioDevicePolicy(\n                BluetoothDevice device, int activeAudioDevicePolicy, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveOrManagedUser(service, TAG, \"setActiveAudioDevicePolicy\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            if (!BluetoothAdapter.checkBluetoothAddress(device.getAddress())) {\n                throw new IllegalArgumentException(\"device cannot have an invalid address\");\n            }\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            return service.mDatabaseManager.setActiveAudioDevicePolicy(\n                    device, activeAudioDevicePolicy);\n        }\n\n        @Override\n        public int getActiveAudioDevicePolicy(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothDevice.ACTIVE_AUDIO_DEVICE_POLICY_DEFAULT;\n            }\n            if (!callerIsSystemOrActiveOrManagedUser(service, TAG, \"getActiveAudioDevicePolicy\")) {\n                throw new IllegalStateException(\n                        \"Caller is not the system or part of the active/managed user\");\n            }\n            if (!BluetoothAdapter.checkBluetoothAddress(device.getAddress())) {\n                throw new IllegalArgumentException(\"device cannot have an invalid address\");\n            }\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothDevice.ACTIVE_AUDIO_DEVICE_POLICY_DEFAULT;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            return service.mDatabaseManager.getActiveAudioDevicePolicy(device);\n        }\n    }\n\n    /**\n     * Gets the preferred audio profiles for the device. See {@link\n     * BluetoothAdapter#getPreferredAudioProfiles(BluetoothDevice)} for more details.\n     *\n     * @param device is the remote device whose preferences we want to fetch\n     * @return a Bundle containing the preferred audio profiles for the device\n     */\n    public Bundle getPreferredAudioProfiles(BluetoothDevice device) {\n        if (!isDualModeAudioEnabled()\n                || mLeAudioService == null\n                || !isDualModeAudioSinkDevice(device)) {\n            return Bundle.EMPTY;\n        }\n        // Checks if the device is part of an LE Audio group\n        List<BluetoothDevice> groupDevices = mLeAudioService.getGroupDevices(device);\n        if (groupDevices.isEmpty()) {\n            return Bundle.EMPTY;\n        }\n\n        // If there are no preferences stored, return the defaults\n        Bundle storedBundle = Bundle.EMPTY;\n        for (BluetoothDevice groupDevice : groupDevices) {\n            Bundle groupDevicePreferences = mDatabaseManager.getPreferredAudioProfiles(groupDevice);\n            if (!groupDevicePreferences.isEmpty()) {\n                storedBundle = groupDevicePreferences;\n                break;\n            }\n        }\n\n        if (storedBundle.isEmpty()) {\n            Bundle defaultPreferencesBundle = new Bundle();\n            boolean useDefaultPreferences = false;\n            if (isOutputOnlyAudioSupported(groupDevices)) {\n                // Gets the default output only audio profile or defaults to LE_AUDIO if not present\n                int outputOnlyDefault =\n                        BluetoothProperties.getDefaultOutputOnlyAudioProfile()\n                                .orElse(BluetoothProfile.LE_AUDIO);\n                if (outputOnlyDefault != BluetoothProfile.A2DP\n                        && outputOnlyDefault != BluetoothProfile.LE_AUDIO) {\n                    outputOnlyDefault = BluetoothProfile.LE_AUDIO;\n                }\n                defaultPreferencesBundle.putInt(\n                        BluetoothAdapter.AUDIO_MODE_OUTPUT_ONLY, outputOnlyDefault);\n                useDefaultPreferences = true;\n            }\n            if (isDuplexAudioSupported(groupDevices)) {\n                // Gets the default duplex audio profile or defaults to LE_AUDIO if not present\n                int duplexDefault =\n                        BluetoothProperties.getDefaultDuplexAudioProfile()\n                                .orElse(BluetoothProfile.LE_AUDIO);\n                if (duplexDefault != BluetoothProfile.HEADSET\n                        && duplexDefault != BluetoothProfile.LE_AUDIO) {\n                    duplexDefault = BluetoothProfile.LE_AUDIO;\n                }\n                defaultPreferencesBundle.putInt(BluetoothAdapter.AUDIO_MODE_DUPLEX, duplexDefault);\n                useDefaultPreferences = true;\n            }\n\n            if (useDefaultPreferences) {\n                return defaultPreferencesBundle;\n            }\n        }\n        return storedBundle;\n    }\n\n    /**\n     * Sets the preferred audio profiles for the device. See {@link\n     * BluetoothAdapter#setPreferredAudioProfiles(BluetoothDevice, Bundle)} for more details.\n     *\n     * @param device is the remote device whose preferences we want to fetch\n     * @param modeToProfileBundle is the preferences we want to set for the device\n     * @return whether the preferences were successfully requested\n     */\n    private int setPreferredAudioProfiles(BluetoothDevice device, Bundle modeToProfileBundle) {\n        Log.i(TAG, \"setPreferredAudioProfiles for device=\" + device);\n        if (!isDualModeAudioEnabled()) {\n            Log.e(TAG, \"setPreferredAudioProfiles called while sysprop is disabled\");\n            return BluetoothStatusCodes.FEATURE_NOT_SUPPORTED;\n        }\n        if (mLeAudioService == null) {\n            Log.e(TAG, \"setPreferredAudioProfiles: LEA service is not up\");\n            return BluetoothStatusCodes.ERROR_PROFILE_NOT_CONNECTED;\n        }\n        if (!isDualModeAudioSinkDevice(device)) {\n            Log.e(TAG, \"setPreferredAudioProfiles: Not a dual mode audio device\");\n            return BluetoothStatusCodes.ERROR_NOT_DUAL_MODE_AUDIO_DEVICE;\n        }\n        // Checks if the device is part of an LE Audio group\n        int groupId = mLeAudioService.getGroupId(device);\n        List<BluetoothDevice> groupDevices = mLeAudioService.getGroupDevices(groupId);\n        if (groupDevices.isEmpty()) {\n            return BluetoothStatusCodes.ERROR_DEVICE_NOT_BONDED;\n        }\n\n        // Copies relevant keys & values from modeToProfile bundle\n        Bundle strippedPreferences = new Bundle();\n        if (modeToProfileBundle.containsKey(BluetoothAdapter.AUDIO_MODE_OUTPUT_ONLY)\n                && isOutputOnlyAudioSupported(groupDevices)) {\n            int outputOnlyProfile =\n                    modeToProfileBundle.getInt(BluetoothAdapter.AUDIO_MODE_OUTPUT_ONLY);\n            if (outputOnlyProfile != BluetoothProfile.A2DP\n                    && outputOnlyProfile != BluetoothProfile.LE_AUDIO) {\n                throw new IllegalArgumentException(\n                        \"AUDIO_MODE_OUTPUT_ONLY has invalid value: \" + outputOnlyProfile);\n            }\n            strippedPreferences.putInt(BluetoothAdapter.AUDIO_MODE_OUTPUT_ONLY, outputOnlyProfile);\n        }\n        if (modeToProfileBundle.containsKey(BluetoothAdapter.AUDIO_MODE_DUPLEX)\n                && isDuplexAudioSupported(groupDevices)) {\n            int duplexProfile = modeToProfileBundle.getInt(BluetoothAdapter.AUDIO_MODE_DUPLEX);\n            if (duplexProfile != BluetoothProfile.HEADSET\n                    && duplexProfile != BluetoothProfile.LE_AUDIO) {\n                throw new IllegalArgumentException(\n                        \"AUDIO_MODE_DUPLEX has invalid value: \" + duplexProfile);\n            }\n            strippedPreferences.putInt(BluetoothAdapter.AUDIO_MODE_DUPLEX, duplexProfile);\n        }\n\n        synchronized (mCsipGroupsPendingAudioProfileChanges) {\n            if (mCsipGroupsPendingAudioProfileChanges.containsKey(groupId)) {\n                return BluetoothStatusCodes.ERROR_ANOTHER_ACTIVE_REQUEST;\n            }\n\n            Bundle previousPreferences = getPreferredAudioProfiles(device);\n\n            int dbResult =\n                    mDatabaseManager.setPreferredAudioProfiles(groupDevices, strippedPreferences);\n            if (dbResult != BluetoothStatusCodes.SUCCESS) {\n                return dbResult;\n            }\n\n            int outputOnlyPreference =\n                    strippedPreferences.getInt(BluetoothAdapter.AUDIO_MODE_OUTPUT_ONLY);\n            if (outputOnlyPreference == 0) {\n                outputOnlyPreference =\n                        previousPreferences.getInt(BluetoothAdapter.AUDIO_MODE_OUTPUT_ONLY);\n            }\n            int duplexPreference = strippedPreferences.getInt(BluetoothAdapter.AUDIO_MODE_DUPLEX);\n            if (duplexPreference == 0) {\n                duplexPreference = previousPreferences.getInt(BluetoothAdapter.AUDIO_MODE_DUPLEX);\n            }\n\n            mLeAudioService.sendAudioProfilePreferencesToNative(\n                    groupId,\n                    outputOnlyPreference == BluetoothProfile.LE_AUDIO,\n                    duplexPreference == BluetoothProfile.LE_AUDIO);\n\n            /* Populates the HashMap to hold requests on the groupId. We will update\n            numRequestsToAudioFramework after we make requests to the audio framework */\n            PendingAudioProfilePreferenceRequest holdRequest =\n                    new PendingAudioProfilePreferenceRequest(strippedPreferences, 0, device);\n            mCsipGroupsPendingAudioProfileChanges.put(groupId, holdRequest);\n\n            // Notifies audio framework via the handler thread to avoid this blocking calls\n            mHandler.post(\n                    () ->\n                            sendPreferredAudioProfileChangeToAudioFramework(\n                                    device, strippedPreferences, previousPreferences));\n            return BluetoothStatusCodes.SUCCESS;\n        }\n    }\n\n    /**\n     * Sends the updated preferred audio profiles to the audio framework.\n     *\n     * @param device is the device with updated audio preferences\n     * @param strippedPreferences is a {@link Bundle} containing the preferences\n     */\n    private void sendPreferredAudioProfileChangeToAudioFramework(\n            BluetoothDevice device, Bundle strippedPreferences, Bundle previousPreferences) {\n        int newOutput = strippedPreferences.getInt(BluetoothAdapter.AUDIO_MODE_OUTPUT_ONLY);\n        int newDuplex = strippedPreferences.getInt(BluetoothAdapter.AUDIO_MODE_DUPLEX);\n        int previousOutput = previousPreferences.getInt(BluetoothAdapter.AUDIO_MODE_OUTPUT_ONLY);\n        int previousDuplex = previousPreferences.getInt(BluetoothAdapter.AUDIO_MODE_DUPLEX);\n\n        Log.i(\n                TAG,\n                \"sendPreferredAudioProfileChangeToAudioFramework: changing output from \"\n                        + BluetoothProfile.getProfileName(previousOutput)\n                        + \" to \"\n                        + BluetoothProfile.getProfileName(newOutput)\n                        + \" and duplex from \"\n                        + BluetoothProfile.getProfileName(previousDuplex)\n                        + \" to \"\n                        + BluetoothProfile.getProfileName(newDuplex));\n\n        // If no change from existing preferences, do not inform audio framework\n        if (previousOutput == newOutput && previousDuplex == newDuplex) {\n            Log.i(TAG, \"No change to preferred audio profiles, no requests to Audio FW\");\n            sendPreferredAudioProfilesCallbackToApps(\n                    device, strippedPreferences, BluetoothStatusCodes.SUCCESS);\n            return;\n        }\n\n        int numRequestsToAudioFw = 0;\n\n        // Checks if the device is part of an LE Audio group\n        int groupId = mLeAudioService.getGroupId(device);\n        List<BluetoothDevice> groupDevices = mLeAudioService.getGroupDevices(groupId);\n        if (groupDevices.isEmpty()) {\n            Log.i(\n                    TAG,\n                    \"sendPreferredAudioProfileChangeToAudioFramework: Empty LEA group for \"\n                            + \"device - \"\n                            + device);\n            sendPreferredAudioProfilesCallbackToApps(\n                    device, strippedPreferences, BluetoothStatusCodes.ERROR_DEVICE_NOT_BONDED);\n            return;\n        }\n\n        synchronized (mCsipGroupsPendingAudioProfileChanges) {\n            if (previousOutput != newOutput) {\n                if (newOutput == BluetoothProfile.A2DP\n                        && mA2dpService.getActiveDevice() != null\n                        && groupDevices.contains(mA2dpService.getActiveDevice())) {\n                    Log.i(TAG, \"Sent change for AUDIO_MODE_OUTPUT_ONLY to A2DP to Audio FW\");\n                    numRequestsToAudioFw +=\n                            mA2dpService.sendPreferredAudioProfileChangeToAudioFramework();\n                } else if (newOutput == BluetoothProfile.LE_AUDIO\n                        && mLeAudioService.getActiveGroupId() == groupId) {\n                    Log.i(TAG, \"Sent change for AUDIO_MODE_OUTPUT_ONLY to LE_AUDIO to Audio FW\");\n                    numRequestsToAudioFw +=\n                            mLeAudioService.sendPreferredAudioProfileChangeToAudioFramework();\n                }\n            }\n\n            if (previousDuplex != newDuplex) {\n                if (newDuplex == BluetoothProfile.HEADSET\n                        && mHeadsetService.getActiveDevice() != null\n                        && groupDevices.contains(mHeadsetService.getActiveDevice())) {\n                    Log.i(TAG, \"Sent change for AUDIO_MODE_DUPLEX to HFP to Audio FW\");\n                    // TODO(b/275426145): Add similar HFP method in BluetoothProfileConnectionInfo\n                    numRequestsToAudioFw +=\n                            mA2dpService.sendPreferredAudioProfileChangeToAudioFramework();\n                } else if (newDuplex == BluetoothProfile.LE_AUDIO\n                        && mLeAudioService.getActiveGroupId() == groupId) {\n                    Log.i(TAG, \"Sent change for AUDIO_MODE_DUPLEX to LE_AUDIO to Audio FW\");\n                    numRequestsToAudioFw +=\n                            mLeAudioService.sendPreferredAudioProfileChangeToAudioFramework();\n                }\n            }\n\n            Log.i(\n                    TAG,\n                    \"sendPreferredAudioProfileChangeToAudioFramework: sent \"\n                            + numRequestsToAudioFw\n                            + \" request(s) to the Audio Framework for device: \"\n                            + device);\n\n            if (numRequestsToAudioFw > 0) {\n                mCsipGroupsPendingAudioProfileChanges.put(\n                        groupId,\n                        new PendingAudioProfilePreferenceRequest(\n                                strippedPreferences, numRequestsToAudioFw, device));\n\n                Message m =\n                        mHandler.obtainMessage(\n                                MESSAGE_PREFERRED_AUDIO_PROFILES_AUDIO_FRAMEWORK_TIMEOUT);\n                m.obj = groupId;\n                mHandler.sendMessageDelayed(m, PREFERRED_AUDIO_PROFILE_CHANGE_TIMEOUT.toMillis());\n                return;\n            }\n        }\n        sendPreferredAudioProfilesCallbackToApps(\n                device, strippedPreferences, BluetoothStatusCodes.SUCCESS);\n    }\n\n    private void removeFromPendingAudioProfileChanges(int groupId) {\n        synchronized (mCsipGroupsPendingAudioProfileChanges) {\n            Log.i(\n                    TAG,\n                    \"removeFromPendingAudioProfileChanges: Timeout on change for groupId=\"\n                            + groupId);\n            if (!mCsipGroupsPendingAudioProfileChanges.containsKey(groupId)) {\n                Log.e(\n                        TAG,\n                        \"removeFromPendingAudioProfileChanges( \"\n                                + groupId\n                                + \", \"\n                                + groupId\n                                + \") is not pending\");\n                return;\n            }\n        }\n    }\n\n    /**\n     * Notification from the audio framework that an active device change has taken effect. See\n     * {@link BluetoothAdapter#notifyActiveDeviceChangeApplied(BluetoothDevice)} for more details.\n     *\n     * @param device the remote device whose preferred audio profiles have been changed\n     * @return whether the Bluetooth stack acknowledged the change successfully\n     */\n    private int notifyActiveDeviceChangeApplied(BluetoothDevice device) {\n        if (mLeAudioService == null) {\n            Log.e(TAG, \"LE Audio profile not enabled\");\n            return BluetoothStatusCodes.ERROR_PROFILE_NOT_CONNECTED;\n        }\n\n        int groupId = mLeAudioService.getGroupId(device);\n        if (groupId == LE_AUDIO_GROUP_ID_INVALID) {\n            return BluetoothStatusCodes.ERROR_DEVICE_NOT_BONDED;\n        }\n\n        synchronized (mCsipGroupsPendingAudioProfileChanges) {\n            if (!mCsipGroupsPendingAudioProfileChanges.containsKey(groupId)) {\n                Log.e(\n                        TAG,\n                        \"notifyActiveDeviceChangeApplied, but no pending request for \"\n                                + \"groupId: \"\n                                + groupId);\n                return BluetoothStatusCodes.ERROR_UNKNOWN;\n            }\n\n            PendingAudioProfilePreferenceRequest pendingRequest =\n                    mCsipGroupsPendingAudioProfileChanges.get(groupId);\n\n            // If this is the final audio framework request, send callback to apps\n            if (pendingRequest.mRemainingRequestsToAudioFramework == 1) {\n                Log.i(\n                        TAG,\n                        \"notifyActiveDeviceChangeApplied: Complete for device \"\n                                + pendingRequest.mDeviceRequested);\n                sendPreferredAudioProfilesCallbackToApps(\n                        pendingRequest.mDeviceRequested,\n                        pendingRequest.mRequestedPreferences,\n                        BluetoothStatusCodes.SUCCESS);\n                // Removes the timeout from the handler\n                mHandler.removeMessages(\n                        MESSAGE_PREFERRED_AUDIO_PROFILES_AUDIO_FRAMEWORK_TIMEOUT, groupId);\n            } else if (pendingRequest.mRemainingRequestsToAudioFramework > 1) {\n                PendingAudioProfilePreferenceRequest updatedPendingRequest =\n                        new PendingAudioProfilePreferenceRequest(\n                                pendingRequest.mRequestedPreferences,\n                                pendingRequest.mRemainingRequestsToAudioFramework - 1,\n                                pendingRequest.mDeviceRequested);\n                Log.i(\n                        TAG,\n                        \"notifyActiveDeviceChangeApplied: Updating device \"\n                                + updatedPendingRequest.mDeviceRequested\n                                + \" with new remaining requests count=\"\n                                + updatedPendingRequest.mRemainingRequestsToAudioFramework);\n                mCsipGroupsPendingAudioProfileChanges.put(groupId, updatedPendingRequest);\n            } else {\n                Log.i(\n                        TAG,\n                        \"notifyActiveDeviceChangeApplied: \"\n                                + pendingRequest.mDeviceRequested\n                                + \" has no remaining requests to audio framework, but is still\"\n                                + \" present in mCsipGroupsPendingAudioProfileChanges\");\n            }\n        }\n\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    private void sendPreferredAudioProfilesCallbackToApps(\n            BluetoothDevice device, Bundle preferredAudioProfiles, int status) {\n        int n = mPreferredAudioProfilesCallbacks.beginBroadcast();\n        Log.d(\n                TAG,\n                \"sendPreferredAudioProfilesCallbackToApps() - Broadcasting audio profile \"\n                        + (\"change callback to device: \" + device)\n                        + (\" and status=\" + status)\n                        + (\" to \" + n + \" receivers.\"));\n        for (int i = 0; i < n; i++) {\n            try {\n                mPreferredAudioProfilesCallbacks\n                        .getBroadcastItem(i)\n                        .onPreferredAudioProfilesChanged(device, preferredAudioProfiles, status);\n            } catch (RemoteException e) {\n                Log.d(\n                        TAG,\n                        \"sendPreferredAudioProfilesCallbackToApps() - Callback #\"\n                                + i\n                                + \" failed (\"\n                                + e\n                                + \")\");\n            }\n        }\n        mPreferredAudioProfilesCallbacks.finishBroadcast();\n    }\n\n    // ----API Methods--------\n\n    public boolean isEnabled() {\n        return getState() == BluetoothAdapter.STATE_ON;\n    }\n\n    public int getState() {\n        if (mAdapterProperties != null) {\n            return mAdapterProperties.getState();\n        }\n        return BluetoothAdapter.STATE_OFF;\n    }\n\n    public synchronized void offToBleOn(boolean quietMode) {\n        // Enforce the user restriction for disallowing Bluetooth if it was set.\n        if (mUserManager.hasUserRestrictionForUser(\n                UserManager.DISALLOW_BLUETOOTH, UserHandle.SYSTEM)) {\n            Log.d(TAG, \"offToBleOn() called when Bluetooth was disallowed\");\n            return;\n        }\n        if (Flags.fastBindToApp()) {\n            // The call to init must be done on the main thread\n            mHandler.post(() -> init());\n        }\n\n        Log.i(TAG, \"offToBleOn() - Enable called with quiet mode status =  \" + quietMode);\n        mQuietmode = quietMode;\n        mAdapterStateMachine.sendMessage(AdapterState.BLE_TURN_ON);\n    }\n\n    void onToBleOn() {\n        Log.d(TAG, \"onToBleOn() called with mRunningProfiles.size() = \" + mRunningProfiles.size());\n        mAdapterStateMachine.sendMessage(AdapterState.USER_TURN_OFF);\n    }\n\n    public String getName() {\n        return mAdapterProperties.getName();\n    }\n\n    public int getNameLengthForAdvertise() {\n        return mAdapterProperties.getName().length();\n    }\n\n    List<DiscoveringPackage> getDiscoveringPackages() {\n        return mDiscoveringPackages;\n    }\n\n    void clearDiscoveringPackages() {\n        synchronized (mDiscoveringPackages) {\n            mDiscoveringPackages.clear();\n        }\n    }\n\n    boolean startDiscovery(AttributionSource source) {\n        UserHandle callingUser = Binder.getCallingUserHandle();\n        Log.d(TAG, \"startDiscovery\");\n        String callingPackage = source.getPackageName();\n        mAppOps.checkPackage(Binder.getCallingUid(), callingPackage);\n        boolean isQApp = Utils.checkCallerTargetSdk(this, callingPackage, Build.VERSION_CODES.Q);\n        boolean hasDisavowedLocation =\n                Utils.hasDisavowedLocationForScan(this, source, mTestModeEnabled);\n        String permission = null;\n        if (Utils.checkCallerHasNetworkSettingsPermission(this)) {\n            permission = android.Manifest.permission.NETWORK_SETTINGS;\n        } else if (Utils.checkCallerHasNetworkSetupWizardPermission(this)) {\n            permission = android.Manifest.permission.NETWORK_SETUP_WIZARD;\n        } else if (!hasDisavowedLocation) {\n            if (isQApp) {\n                if (!Utils.checkCallerHasFineLocation(this, source, callingUser)) {\n                    return false;\n                }\n                permission = android.Manifest.permission.ACCESS_FINE_LOCATION;\n            } else {\n                if (!Utils.checkCallerHasCoarseLocation(this, source, callingUser)) {\n                    return false;\n                }\n                permission = android.Manifest.permission.ACCESS_COARSE_LOCATION;\n            }\n        }\n\n        synchronized (mDiscoveringPackages) {\n            mDiscoveringPackages.add(\n                    new DiscoveringPackage(callingPackage, permission, hasDisavowedLocation));\n        }\n        return mNativeInterface.startDiscovery();\n    }\n\n    /**\n     * Same as API method {@link BluetoothAdapter#getBondedDevices()}\n     *\n     * @return array of bonded {@link BluetoothDevice} or null on error\n     */\n    public BluetoothDevice[] getBondedDevices() {\n        return mAdapterProperties.getBondedDevices();\n    }\n\n    /**\n     * Get the database manager to access Bluetooth storage\n     *\n     * @return {@link DatabaseManager} or null on error\n     */\n    public DatabaseManager getDatabase() {\n        return mDatabaseManager;\n    }\n\n    public byte[] getByteIdentityAddress(BluetoothDevice device) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp != null && deviceProp.getIdentityAddress() != null) {\n            return Utils.getBytesFromAddress(deviceProp.getIdentityAddress());\n        }\n\n        if (Flags.identityAddressNullIfNotKnown()) {\n            // Return null if identity address unknown\n            return null;\n        } else {\n            return Utils.getByteAddress(device);\n        }\n    }\n\n    public BluetoothDevice getDeviceFromByte(byte[] address) {\n        BluetoothDevice device = mRemoteDevices.getDevice(address);\n        if (device == null) {\n            device = BluetoothAdapter.getDefaultAdapter().getRemoteDevice(address);\n        }\n        return device;\n    }\n\n    public String getIdentityAddress(String address) {\n        BluetoothDevice device =\n                BluetoothAdapter.getDefaultAdapter().getRemoteDevice(Ascii.toUpperCase(address));\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp != null && deviceProp.getIdentityAddress() != null) {\n            return deviceProp.getIdentityAddress();\n        } else {\n            if (Flags.identityAddressNullIfNotKnown()) {\n                // Return null if identity address unknown\n                return null;\n            } else {\n                return address;\n            }\n        }\n    }\n\n    private static class CallerInfo {\n        public String callerPackageName;\n        public UserHandle user;\n    }\n\n    boolean createBond(\n            BluetoothDevice device,\n            int transport,\n            OobData remoteP192Data,\n            OobData remoteP256Data,\n            String callingPackage) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp != null && deviceProp.getBondState() != BluetoothDevice.BOND_NONE) {\n            // true for BONDING, false for BONDED\n            return deviceProp.getBondState() == BluetoothDevice.BOND_BONDING;\n        }\n\n        if (!isEnabled()) {\n            Log.e(TAG, \"Impossible to call createBond when Bluetooth is not enabled\");\n            return false;\n        }\n\n        if (!isPackageNameAccurate(this, callingPackage, Binder.getCallingUid())) {\n            return false;\n        }\n\n        CallerInfo createBondCaller = new CallerInfo();\n        createBondCaller.callerPackageName = callingPackage;\n        createBondCaller.user = Binder.getCallingUserHandle();\n        mBondAttemptCallerInfo.put(device.getAddress(), createBondCaller);\n\n        mRemoteDevices.setBondingInitiatedLocally(Utils.getByteAddress(device));\n\n        // Pairing is unreliable while scanning, so cancel discovery\n        // Note, remove this when native stack improves\n        mNativeInterface.cancelDiscovery();\n\n        Message msg = mBondStateMachine.obtainMessage(BondStateMachine.CREATE_BOND);\n        msg.obj = device;\n        msg.arg1 = transport;\n\n        Bundle remoteOobDatasBundle = new Bundle();\n        boolean setData = false;\n        if (remoteP192Data != null) {\n            remoteOobDatasBundle.putParcelable(BondStateMachine.OOBDATAP192, remoteP192Data);\n            setData = true;\n        }\n        if (remoteP256Data != null) {\n            remoteOobDatasBundle.putParcelable(BondStateMachine.OOBDATAP256, remoteP256Data);\n            setData = true;\n        }\n        if (setData) {\n            msg.setData(remoteOobDatasBundle);\n        } else {\n            MetricsLogger.getInstance()\n                    .logBluetoothEvent(\n                            device,\n                            BluetoothStatsLog\n                                    .BLUETOOTH_CROSS_LAYER_EVENT_REPORTED__EVENT_TYPE__BONDING,\n                            BluetoothStatsLog.BLUETOOTH_CROSS_LAYER_EVENT_REPORTED__STATE__START,\n                            Binder.getCallingUid());\n        }\n        mBondStateMachine.sendMessage(msg);\n        return true;\n    }\n\n    /**\n     * Fetches the local OOB data to give out to remote.\n     *\n     * @param transport - specify data transport.\n     * @param callback - callback used to receive the requested {@link OobData}; null will be\n     *     ignored silently.\n     */\n    public synchronized void generateLocalOobData(\n            int transport, IBluetoothOobDataCallback callback) {\n        if (callback == null) {\n            Log.e(TAG, \"'callback' argument must not be null!\");\n            return;\n        }\n        if (mOobDataCallbackQueue.peek() != null) {\n            try {\n                callback.onError(BluetoothStatusCodes.ERROR_ANOTHER_ACTIVE_OOB_REQUEST);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Failed to make callback\", e);\n            }\n            return;\n        }\n        mOobDataCallbackQueue.offer(callback);\n        mHandler.postDelayed(\n                () -> removeFromOobDataCallbackQueue(callback),\n                GENERATE_LOCAL_OOB_DATA_TIMEOUT.toMillis());\n        mNativeInterface.generateLocalOobData(transport);\n    }\n\n    private synchronized void removeFromOobDataCallbackQueue(IBluetoothOobDataCallback callback) {\n        if (callback == null) {\n            return;\n        }\n\n        if (mOobDataCallbackQueue.peek() == callback) {\n            try {\n                mOobDataCallbackQueue.poll().onError(BluetoothStatusCodes.ERROR_UNKNOWN);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Failed to make OobDataCallback to remove callback from queue\", e);\n            }\n        }\n    }\n\n    /* package */ synchronized void notifyOobDataCallback(int transport, OobData oobData) {\n        if (mOobDataCallbackQueue.peek() == null) {\n            Log.e(TAG, \"Failed to make callback, no callback exists\");\n            return;\n        }\n        if (oobData == null) {\n            try {\n                mOobDataCallbackQueue.poll().onError(BluetoothStatusCodes.ERROR_UNKNOWN);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Failed to make callback\", e);\n            }\n        } else {\n            try {\n                mOobDataCallbackQueue.poll().onOobData(transport, oobData);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Failed to make callback\", e);\n            }\n        }\n    }\n\n    public boolean isQuietModeEnabled() {\n        Log.d(TAG, \"isQuietModeEnabled() - Enabled = \" + mQuietmode);\n        return mQuietmode;\n    }\n\n    public void updateUuids() {\n        Log.d(TAG, \"updateUuids() - Updating UUIDs for bonded devices\");\n        BluetoothDevice[] bondedDevices = getBondedDevices();\n        if (bondedDevices == null) {\n            return;\n        }\n\n        for (BluetoothDevice device : bondedDevices) {\n            mRemoteDevices.updateUuids(device);\n        }\n    }\n\n    /**\n     * Update device UUID changed to {@link BondStateMachine}\n     *\n     * @param device remote device of interest\n     */\n    public void deviceUuidUpdated(BluetoothDevice device) {\n        // Notify BondStateMachine for SDP complete / UUID changed.\n        Message msg = mBondStateMachine.obtainMessage(BondStateMachine.UUID_UPDATE);\n        msg.obj = device;\n        mBondStateMachine.sendMessage(msg);\n    }\n\n    /**\n     * Get the bond state of a particular {@link BluetoothDevice}\n     *\n     * @param device remote device of interest\n     * @return bond state\n     *     <p>Possible values are {@link BluetoothDevice#BOND_NONE}, {@link\n     *     BluetoothDevice#BOND_BONDING}, {@link BluetoothDevice#BOND_BONDED}.\n     */\n    public int getBondState(BluetoothDevice device) {\n        return mRemoteDevices.getBondState(device);\n    }\n\n    public boolean isConnected(BluetoothDevice device) {\n        return getConnectionState(device) != BluetoothDevice.CONNECTION_STATE_DISCONNECTED;\n    }\n\n    public int getConnectionState(BluetoothDevice device) {\n        final String address = device.getAddress();\n        if (Flags.apiGetConnectionStateUsingIdentityAddress()) {\n            int connectionState = mNativeInterface.getConnectionState(getBytesFromAddress(address));\n            final String identityAddress = getIdentityAddress(address);\n            if (identityAddress != null) {\n                connectionState |=\n                        mNativeInterface.getConnectionState(getBytesFromAddress(identityAddress));\n            }\n            return connectionState;\n        }\n        return mNativeInterface.getConnectionState(getBytesFromAddress(address));\n    }\n\n    int getConnectionHandle(BluetoothDevice device, int transport) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp == null) {\n            return BluetoothDevice.ERROR;\n        }\n        return deviceProp.getConnectionHandle(transport);\n    }\n\n    /**\n     * Get ASHA Capability\n     *\n     * @param device discovered bluetooth device\n     * @return ASHA capability\n     */\n    public int getAshaCapability(BluetoothDevice device) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp == null) {\n            return BluetoothDevice.ERROR;\n        }\n        return deviceProp.getAshaCapability();\n    }\n\n    /**\n     * Get ASHA truncated HiSyncId\n     *\n     * @param device discovered bluetooth device\n     * @return ASHA truncated HiSyncId\n     */\n    public int getAshaTruncatedHiSyncId(BluetoothDevice device) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp == null) {\n            return BluetoothDevice.ERROR;\n        }\n        return deviceProp.getAshaTruncatedHiSyncId();\n    }\n\n    /**\n     * Checks whether the device was recently associated with the comapnion app that called {@link\n     * BluetoothDevice#createBond}. This allows these devices to skip the pairing dialog if their\n     * pairing variant is {@link BluetoothDevice#PAIRING_VARIANT_CONSENT}.\n     *\n     * @param device the bluetooth device that is being bonded\n     * @return true if it was recently associated and we can bypass the dialog, false otherwise\n     */\n    public boolean canBondWithoutDialog(BluetoothDevice device) {\n        if (mBondAttemptCallerInfo.containsKey(device.getAddress())) {\n            CallerInfo bondCallerInfo = mBondAttemptCallerInfo.get(device.getAddress());\n\n            return mCompanionDeviceManager.canPairWithoutPrompt(\n                    bondCallerInfo.callerPackageName, device.getAddress(), bondCallerInfo.user);\n        }\n        return false;\n    }\n\n    /**\n     * Returns the package name of the most recent caller that called {@link\n     * BluetoothDevice#createBond} on the given device.\n     */\n    @Nullable\n    public String getPackageNameOfBondingApplication(BluetoothDevice device) {\n        CallerInfo info = mBondAttemptCallerInfo.get(device.getAddress());\n        if (info == null) {\n            return null;\n        }\n        return info.callerPackageName;\n    }\n\n    /**\n     * Sets device as the active devices for the profiles passed into the function.\n     *\n     * @param device is the remote bluetooth device\n     * @param profiles is a constant that references for which profiles we'll be setting the remote\n     *     device as our active device. One of the following: {@link\n     *     BluetoothAdapter#ACTIVE_DEVICE_AUDIO}, {@link BluetoothAdapter#ACTIVE_DEVICE_PHONE_CALL}\n     *     {@link BluetoothAdapter#ACTIVE_DEVICE_ALL}\n     * @return false if profiles value is not one of the constants we accept, true otherwise\n     */\n    public boolean setActiveDevice(BluetoothDevice device, @ActiveDeviceUse int profiles) {\n        if (getState() != BluetoothAdapter.STATE_ON) {\n            Log.e(TAG, \"setActiveDevice: Bluetooth is not enabled\");\n            return false;\n        }\n        boolean setA2dp = false;\n        boolean setHeadset = false;\n\n        // Determine for which profiles we want to set device as our active device\n        switch (profiles) {\n            case BluetoothAdapter.ACTIVE_DEVICE_AUDIO:\n                setA2dp = true;\n                break;\n            case BluetoothAdapter.ACTIVE_DEVICE_PHONE_CALL:\n                setHeadset = true;\n                break;\n            case BluetoothAdapter.ACTIVE_DEVICE_ALL:\n                setA2dp = true;\n                setHeadset = true;\n                break;\n            default:\n                return false;\n        }\n\n        boolean a2dpSupported =\n                mA2dpService != null\n                        && (device == null\n                                || mA2dpService.getConnectionPolicy(device)\n                                        == BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n        boolean hfpSupported =\n                mHeadsetService != null\n                        && (device == null\n                                || mHeadsetService.getConnectionPolicy(device)\n                                        == BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n        boolean leAudioSupported =\n                mLeAudioService != null\n                        && (device == null\n                                || mLeAudioService.getConnectionPolicy(device)\n                                        == BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n\n        if (leAudioSupported) {\n            Log.i(TAG, \"setActiveDevice: Setting active Le Audio device \" + device);\n            if (device == null) {\n                /* If called by BluetoothAdapter it means Audio should not be stopped.\n                 * For this reason let's say that fallback device exists\n                 */\n                mLeAudioService.removeActiveDevice(true /* hasFallbackDevice */);\n            } else {\n                mLeAudioService.setActiveDevice(device);\n            }\n        }\n\n        if (setA2dp && a2dpSupported) {\n            Log.i(TAG, \"setActiveDevice: Setting active A2dp device \" + device);\n            if (device == null) {\n                mA2dpService.removeActiveDevice(false);\n            } else {\n                /* Workaround for the controller issue which is not able to handle correctly\n                 * A2DP offloader vendor specific command while ISO Data path is set.\n                 * Proper solutions should be delivered in b/312396770\n                 */\n                if (mLeAudioService != null) {\n                    List<BluetoothDevice> activeLeAudioDevices = mLeAudioService.getActiveDevices();\n                    if (activeLeAudioDevices.get(0) != null) {\n                        mLeAudioService.removeActiveDevice(true);\n                    }\n                }\n                mA2dpService.setActiveDevice(device);\n            }\n        }\n\n        if (mHearingAidService != null\n                && (device == null\n                        || mHearingAidService.getConnectionPolicy(device)\n                                == BluetoothProfile.CONNECTION_POLICY_ALLOWED)) {\n            Log.i(TAG, \"setActiveDevice: Setting active Hearing Aid \" + device);\n            if (device == null) {\n                mHearingAidService.removeActiveDevice(false);\n            } else {\n                mHearingAidService.setActiveDevice(device);\n            }\n        }\n\n        if (setHeadset && hfpSupported) {\n            Log.i(TAG, \"setActiveDevice: Setting active Headset \" + device);\n            mHeadsetService.setActiveDevice(device);\n        }\n\n        return true;\n    }\n\n    /**\n     * Checks if all supported classic audio profiles are active on this LE Audio device.\n     *\n     * @param leAudioDevice the remote device\n     * @return {@code true} if all supported classic audio profiles are active on this device,\n     *     {@code false} otherwise\n     */\n    public boolean isAllSupportedClassicAudioProfilesActive(BluetoothDevice leAudioDevice) {\n        if (mLeAudioService == null) {\n            return false;\n        }\n        boolean a2dpSupported = isProfileSupported(leAudioDevice, BluetoothProfile.A2DP);\n        boolean hfpSupported = isProfileSupported(leAudioDevice, BluetoothProfile.HEADSET);\n\n        List<BluetoothDevice> groupDevices = mLeAudioService.getGroupDevices(leAudioDevice);\n        if (hfpSupported && mHeadsetService != null) {\n            BluetoothDevice activeHfpDevice = mHeadsetService.getActiveDevice();\n            if (activeHfpDevice == null || !groupDevices.contains(activeHfpDevice)) {\n                return false;\n            }\n        }\n        if (a2dpSupported && mA2dpService != null) {\n            BluetoothDevice activeA2dpDevice = mA2dpService.getActiveDevice();\n            if (activeA2dpDevice == null || !groupDevices.contains(activeA2dpDevice)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Get the active devices for the BluetoothProfile specified\n     *\n     * @param profile is the profile from which we want the active devices. Possible values are:\n     *     {@link BluetoothProfile#HEADSET}, {@link BluetoothProfile#A2DP}, {@link\n     *     BluetoothProfile#HEARING_AID} {@link BluetoothProfile#LE_AUDIO}\n     * @return A list of active bluetooth devices\n     */\n    public List<BluetoothDevice> getActiveDevices(@ActiveDeviceProfile int profile) {\n        List<BluetoothDevice> activeDevices = new ArrayList<>();\n\n        switch (profile) {\n            case BluetoothProfile.HEADSET:\n                if (mHeadsetService == null) {\n                    Log.e(TAG, \"getActiveDevices: HeadsetService is null\");\n                } else {\n                    BluetoothDevice device = mHeadsetService.getActiveDevice();\n                    if (device != null) {\n                        activeDevices.add(device);\n                    }\n                    Log.i(TAG, \"getActiveDevices: Headset device: \" + device);\n                }\n                break;\n            case BluetoothProfile.A2DP:\n                if (mA2dpService == null) {\n                    Log.e(TAG, \"getActiveDevices: A2dpService is null\");\n                } else {\n                    BluetoothDevice device = mA2dpService.getActiveDevice();\n                    if (device != null) {\n                        activeDevices.add(device);\n                    }\n                    Log.i(TAG, \"getActiveDevices: A2dp device: \" + device);\n                }\n                break;\n            case BluetoothProfile.HEARING_AID:\n                if (mHearingAidService == null) {\n                    Log.e(TAG, \"getActiveDevices: HearingAidService is null\");\n                } else {\n                    activeDevices = mHearingAidService.getActiveDevices();\n                    Log.i(\n                            TAG,\n                            \"getActiveDevices: Hearing Aid devices:\"\n                                    + (\" Left[\" + activeDevices.get(0) + \"] -\")\n                                    + (\" Right[\" + activeDevices.get(1) + \"]\"));\n                }\n                break;\n            case BluetoothProfile.LE_AUDIO:\n                if (mLeAudioService == null) {\n                    Log.e(TAG, \"getActiveDevices: LeAudioService is null\");\n                } else {\n                    activeDevices = mLeAudioService.getActiveDevices();\n                    Log.i(\n                            TAG,\n                            \"getActiveDevices: LeAudio devices:\"\n                                    + (\" Lead[\" + activeDevices.get(0) + \"] -\")\n                                    + (\" member_1[\" + activeDevices.get(1) + \"]\"));\n                }\n                break;\n            default:\n                Log.e(TAG, \"getActiveDevices: profile value is not valid\");\n        }\n        return activeDevices;\n    }\n\n    /**\n     * Attempts connection to all enabled and supported bluetooth profiles between the local and\n     * remote device\n     *\n     * @param device is the remote device with which to connect these profiles\n     * @return {@link BluetoothStatusCodes#SUCCESS} if all profiles connections are attempted, false\n     *     if an error occurred\n     */\n    public int connectAllEnabledProfiles(BluetoothDevice device) {\n        if (!profileServicesRunning()) {\n            Log.e(TAG, \"connectAllEnabledProfiles: Not all profile services running\");\n            return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n        }\n\n        // Checks if any profiles are enablde or disabled and if so, only connect enabled profiles\n        if (!isAllProfilesUnknown(device)) {\n            return connectEnabledProfiles(device);\n        }\n\n        connectAllSupportedProfiles(device);\n\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    /**\n     * Connect all supported bluetooth profiles between the local and remote device\n     *\n     * @param device is the remote device with which to connect all supported profiles\n     */\n    void connectAllSupportedProfiles(BluetoothDevice device) {\n        int numProfilesConnected = 0;\n\n        // All profile toggles disabled, so connects all supported profiles\n        if (mA2dpService != null && isProfileSupported(device, BluetoothProfile.A2DP)) {\n            Log.i(TAG, \"connectAllSupportedProfiles: Connecting A2dp\");\n            // Set connection policy also connects the profile with CONNECTION_POLICY_ALLOWED\n            mA2dpService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mA2dpSinkService != null && isProfileSupported(device, BluetoothProfile.A2DP_SINK)) {\n            Log.i(TAG, \"connectAllSupportedProfiles: Connecting A2dp Sink\");\n            mA2dpSinkService.setConnectionPolicy(\n                    device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHeadsetService != null && isProfileSupported(device, BluetoothProfile.HEADSET)) {\n            Log.i(TAG, \"connectAllSupportedProfiles: Connecting Headset Profile\");\n            mHeadsetService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHeadsetClientService != null\n                && isProfileSupported(device, BluetoothProfile.HEADSET_CLIENT)) {\n            Log.i(TAG, \"connectAllSupportedProfiles: Connecting HFP\");\n            mHeadsetClientService.setConnectionPolicy(\n                    device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mMapClientService != null && isProfileSupported(device, BluetoothProfile.MAP_CLIENT)) {\n            Log.i(TAG, \"connectAllSupportedProfiles: Connecting MAP\");\n            mMapClientService.setConnectionPolicy(\n                    device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHidHostService != null && isProfileSupported(device, BluetoothProfile.HID_HOST)) {\n            Log.i(TAG, \"connectAllSupportedProfiles: Connecting Hid Host Profile\");\n            mHidHostService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mPanService != null && isProfileSupported(device, BluetoothProfile.PAN)) {\n            Log.i(TAG, \"connectAllSupportedProfiles: Connecting Pan Profile\");\n            mPanService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mPbapClientService != null\n                && isProfileSupported(device, BluetoothProfile.PBAP_CLIENT)) {\n            Log.i(TAG, \"connectAllSupportedProfiles: Connecting Pbap\");\n            mPbapClientService.setConnectionPolicy(\n                    device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHearingAidService != null\n                && isProfileSupported(device, BluetoothProfile.HEARING_AID)) {\n            if (mHapClientService != null\n                    && isProfileSupported(device, BluetoothProfile.HAP_CLIENT)) {\n                Log.i(\n                        TAG,\n                        \"connectAllSupportedProfiles: Hearing Access Client Profile is enabled at\"\n                                + \" the same time with Hearing Aid Profile, ignore Hearing Aid\"\n                                + \" Profile\");\n            } else {\n                Log.i(TAG, \"connectAllSupportedProfiles: Connecting Hearing Aid Profile\");\n                mHearingAidService.setConnectionPolicy(\n                        device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n                numProfilesConnected++;\n            }\n        }\n        if (mHapClientService != null && isProfileSupported(device, BluetoothProfile.HAP_CLIENT)) {\n            Log.i(TAG, \"connectAllSupportedProfiles: Connecting Hearing Access Client Profile\");\n            mHapClientService.setConnectionPolicy(\n                    device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mVolumeControlService != null\n                && isProfileSupported(device, BluetoothProfile.VOLUME_CONTROL)) {\n            Log.i(TAG, \"connectAllSupportedProfiles: Connecting Volume Control Profile\");\n            mVolumeControlService.setConnectionPolicy(\n                    device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mCsipSetCoordinatorService != null\n                && isProfileSupported(device, BluetoothProfile.CSIP_SET_COORDINATOR)) {\n            Log.i(TAG, \"connectAllSupportedProfiles: Connecting Coordinated Set Profile\");\n            mCsipSetCoordinatorService.setConnectionPolicy(\n                    device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mLeAudioService != null && isProfileSupported(device, BluetoothProfile.LE_AUDIO)) {\n            Log.i(TAG, \"connectAllSupportedProfiles: Connecting LeAudio profile (BAP)\");\n            mLeAudioService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mBassClientService != null\n                && isProfileSupported(device, BluetoothProfile.LE_AUDIO_BROADCAST_ASSISTANT)) {\n            Log.i(TAG, \"connectAllSupportedProfiles: Connecting LE Broadcast Assistant Profile\");\n            mBassClientService.setConnectionPolicy(\n                    device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mBatteryService != null && isProfileSupported(device, BluetoothProfile.BATTERY)) {\n            Log.i(TAG, \"connectAllSupportedProfiles: Connecting Battery Service\");\n            mBatteryService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n\n        Log.i(\n                TAG,\n                \"connectAllSupportedProfiles: Number of Profiles Connected: \"\n                        + numProfilesConnected);\n    }\n\n    /**\n     * Disconnects all enabled and supported bluetooth profiles between the local and remote device\n     *\n     * @param device is the remote device with which to disconnect these profiles\n     * @return true if all profiles successfully disconnected, false if an error occurred\n     */\n    public int disconnectAllEnabledProfiles(BluetoothDevice device) {\n        if (!profileServicesRunning()) {\n            Log.e(TAG, \"disconnectAllEnabledProfiles: Not all profile services bound\");\n            return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n        }\n\n        if (mA2dpService != null\n                && (mA2dpService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED\n                        || mA2dpService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting A2dp\");\n            mA2dpService.disconnect(device);\n        }\n        if (mA2dpSinkService != null\n                && (mA2dpSinkService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED\n                        || mA2dpSinkService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting A2dp Sink\");\n            mA2dpSinkService.disconnect(device);\n        }\n        if (mHeadsetService != null\n                && (mHeadsetService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED\n                        || mHeadsetService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Headset Profile\");\n            mHeadsetService.disconnect(device);\n        }\n        if (mHeadsetClientService != null\n                && (mHeadsetClientService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTED\n                        || mHeadsetClientService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting HFP\");\n            mHeadsetClientService.disconnect(device);\n        }\n        if (mMapClientService != null\n                && (mMapClientService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED\n                        || mMapClientService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting MAP Client\");\n            mMapClientService.disconnect(device);\n        }\n        if (mMapService != null\n                && (mMapService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED\n                        || mMapService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting MAP\");\n            mMapService.disconnect(device);\n        }\n        if (mHidDeviceService != null\n                && (mHidDeviceService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED\n                        || mHidDeviceService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Hid Device Profile\");\n            mHidDeviceService.disconnect(device);\n        }\n        if (mHidHostService != null\n                && (mHidHostService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED\n                        || mHidHostService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Hid Host Profile\");\n            mHidHostService.disconnect(device);\n        }\n        if (mPanService != null\n                && (mPanService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED\n                        || mPanService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Pan Profile\");\n            mPanService.disconnect(device);\n        }\n        if (mPbapClientService != null\n                && (mPbapClientService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTED\n                        || mPbapClientService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Pbap Client\");\n            mPbapClientService.disconnect(device);\n        }\n        if (mPbapService != null\n                && (mPbapService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED\n                        || mPbapService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Pbap Server\");\n            mPbapService.disconnect(device);\n        }\n        if (mHearingAidService != null\n                && (mHearingAidService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTED\n                        || mHearingAidService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Hearing Aid Profile\");\n            mHearingAidService.disconnect(device);\n        }\n        if (mHapClientService != null\n                && (mHapClientService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED\n                        || mHapClientService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Hearing Access Profile Client\");\n            mHapClientService.disconnect(device);\n        }\n        if (mVolumeControlService != null\n                && (mVolumeControlService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTED\n                        || mVolumeControlService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Volume Control Profile\");\n            mVolumeControlService.disconnect(device);\n        }\n        if (mSapService != null\n                && (mSapService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED\n                        || mSapService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Sap Profile\");\n            mSapService.disconnect(device);\n        }\n        if (mCsipSetCoordinatorService != null\n                && (mCsipSetCoordinatorService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTED\n                        || mCsipSetCoordinatorService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Coordinator Set Profile\");\n            mCsipSetCoordinatorService.disconnect(device);\n        }\n        if (mLeAudioService != null\n                && (mLeAudioService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED\n                        || mLeAudioService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting LeAudio profile (BAP)\");\n            mLeAudioService.disconnect(device);\n        }\n        if (mBassClientService != null\n                && (mBassClientService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTED\n                        || mBassClientService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(\n                    TAG,\n                    \"disconnectAllEnabledProfiles: Disconnecting \"\n                            + \"LE Broadcast Assistant Profile\");\n            mBassClientService.disconnect(device);\n        }\n        if (mBatteryService != null\n                && (mBatteryService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED\n                        || mBatteryService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting \" + \"Battery Service\");\n            mBatteryService.disconnect(device);\n        }\n\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    /**\n     * Same as API method {@link BluetoothDevice#getName()}\n     *\n     * @param device remote device of interest\n     * @return remote device name\n     */\n    public String getRemoteName(BluetoothDevice device) {\n        return mRemoteDevices.getName(device);\n    }\n\n    public int getRemoteClass(BluetoothDevice device) {\n        return mRemoteDevices.getBluetoothClass(device);\n    }\n\n    /**\n     * Get UUIDs for service supported by a remote device\n     *\n     * @param device the remote device that we want to get UUIDs from\n     * @return the uuids of the remote device\n     */\n    public ParcelUuid[] getRemoteUuids(BluetoothDevice device) {\n        return mRemoteDevices.getUuids(device);\n    }\n\n    void aclStateChangeBroadcastCallback(Consumer<IBluetoothConnectionCallback> cb) {\n        int n = mBluetoothConnectionCallbacks.beginBroadcast();\n        Log.d(TAG, \"aclStateChangeBroadcastCallback() - Broadcasting to \" + n + \" receivers.\");\n        for (int i = 0; i < n; i++) {\n            cb.accept(mBluetoothConnectionCallbacks.getBroadcastItem(i));\n        }\n        mBluetoothConnectionCallbacks.finishBroadcast();\n    }\n\n    /**\n     * Converts HCI disconnect reasons to Android disconnect reasons.\n     *\n     * <p>The HCI Error Codes used for ACL disconnect reasons propagated up from native code were\n     * copied from: packages/modules/Bluetooth/system/stack/include/hci_error_code.h\n     *\n     * <p>These error codes are specified and described in Bluetooth Core Spec v5.1, Vol 2, Part D.\n     *\n     * @param hciReason is the raw HCI disconnect reason from native.\n     * @return the Android disconnect reason for apps.\n     */\n    static @BluetoothAdapter.BluetoothConnectionCallback.DisconnectReason int\n            hciToAndroidDisconnectReason(int hciReason) {\n        switch (hciReason) {\n            case /*HCI_SUCCESS*/ 0x00:\n            case /*HCI_ERR_UNSPECIFIED*/ 0x1F:\n            case /*HCI_ERR_UNDEFINED*/ 0xff:\n                return BluetoothStatusCodes.ERROR_UNKNOWN;\n            case /*HCI_ERR_ILLEGAL_COMMAND*/ 0x01:\n            case /*HCI_ERR_NO_CONNECTION*/ 0x02:\n            case /*HCI_ERR_HW_FAILURE*/ 0x03:\n            case /*HCI_ERR_DIFF_TRANSACTION_COLLISION*/ 0x2A:\n            case /*HCI_ERR_ROLE_SWITCH_PENDING*/ 0x32:\n            case /*HCI_ERR_ROLE_SWITCH_FAILED*/ 0x35:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_LOCAL;\n            case /*HCI_ERR_PAGE_TIMEOUT*/ 0x04:\n            case /*HCI_ERR_CONNECTION_TOUT*/ 0x08:\n            case /*HCI_ERR_HOST_TIMEOUT*/ 0x10:\n            case /*HCI_ERR_LMP_RESPONSE_TIMEOUT*/ 0x22:\n            case /*HCI_ERR_ADVERTISING_TIMEOUT*/ 0x3C:\n            case /*HCI_ERR_CONN_FAILED_ESTABLISHMENT*/ 0x3E:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_TIMEOUT;\n            case /*HCI_ERR_AUTH_FAILURE*/ 0x05:\n            case /*HCI_ERR_KEY_MISSING*/ 0x06:\n            case /*HCI_ERR_HOST_REJECT_SECURITY*/ 0x0E:\n            case /*HCI_ERR_REPEATED_ATTEMPTS*/ 0x17:\n            case /*HCI_ERR_PAIRING_NOT_ALLOWED*/ 0x18:\n            case /*HCI_ERR_ENCRY_MODE_NOT_ACCEPTABLE*/ 0x25:\n            case /*HCI_ERR_UNIT_KEY_USED*/ 0x26:\n            case /*HCI_ERR_PAIRING_WITH_UNIT_KEY_NOT_SUPPORTED*/ 0x29:\n            case /*HCI_ERR_INSUFFCIENT_SECURITY*/ 0x2F:\n            case /*HCI_ERR_HOST_BUSY_PAIRING*/ 0x38:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_SECURITY;\n            case /*HCI_ERR_MEMORY_FULL*/ 0x07:\n            case /*HCI_ERR_MAX_NUM_OF_CONNECTIONS*/ 0x09:\n            case /*HCI_ERR_MAX_NUM_OF_SCOS*/ 0x0A:\n            case /*HCI_ERR_COMMAND_DISALLOWED*/ 0x0C:\n            case /*HCI_ERR_HOST_REJECT_RESOURCES*/ 0x0D:\n            case /*HCI_ERR_LIMIT_REACHED*/ 0x43:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_RESOURCE_LIMIT_REACHED;\n            case /*HCI_ERR_CONNECTION_EXISTS*/ 0x0B:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_CONNECTION_ALREADY_EXISTS;\n            case /*HCI_ERR_HOST_REJECT_DEVICE*/ 0x0F:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_SYSTEM_POLICY;\n            case /*HCI_ERR_ILLEGAL_PARAMETER_FMT*/ 0x12:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_BAD_PARAMETERS;\n            case /*HCI_ERR_PEER_USER*/ 0x13:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_REMOTE_REQUEST;\n            case /*HCI_ERR_REMOTE_POWER_OFF*/ 0x15:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_REMOTE_REQUEST;\n            case /*HCI_ERR_CONN_CAUSE_LOCAL_HOST*/ 0x16:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_LOCAL_REQUEST;\n            case /*HCI_ERR_UNSUPPORTED_REM_FEATURE*/ 0x1A:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_REMOTE;\n            case /*HCI_ERR_UNACCEPT_CONN_INTERVAL*/ 0x3B:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_BAD_PARAMETERS;\n            default:\n                Log.e(TAG, \"Invalid HCI disconnect reason: \" + hciReason);\n                return BluetoothStatusCodes.ERROR_UNKNOWN;\n        }\n    }\n\n    void logUserBondResponse(BluetoothDevice device, boolean accepted, int event) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            BluetoothStatsLog.write(\n                    BluetoothStatsLog.BLUETOOTH_BOND_STATE_CHANGED,\n                    obfuscateAddress(device),\n                    0,\n                    device.getType(),\n                    BluetoothDevice.BOND_BONDING,\n                    event,\n                    accepted ? 0 : BluetoothDevice.UNBOND_REASON_AUTH_REJECTED);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    public int getPhonebookAccessPermission(BluetoothDevice device) {\n        return getDeviceAccessFromPrefs(device, PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE);\n    }\n\n    public int getMessageAccessPermission(BluetoothDevice device) {\n        return getDeviceAccessFromPrefs(device, MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE);\n    }\n\n    public int getSimAccessPermission(BluetoothDevice device) {\n        return getDeviceAccessFromPrefs(device, SIM_ACCESS_PERMISSION_PREFERENCE_FILE);\n    }\n\n    int getDeviceAccessFromPrefs(BluetoothDevice device, String prefFile) {\n        SharedPreferences prefs = getSharedPreferences(prefFile, Context.MODE_PRIVATE);\n        if (!prefs.contains(device.getAddress())) {\n            return BluetoothDevice.ACCESS_UNKNOWN;\n        }\n        return prefs.getBoolean(device.getAddress(), false)\n                ? BluetoothDevice.ACCESS_ALLOWED\n                : BluetoothDevice.ACCESS_REJECTED;\n    }\n\n    void setDeviceAccessFromPrefs(BluetoothDevice device, int value, String prefFile) {\n        SharedPreferences pref = getSharedPreferences(prefFile, Context.MODE_PRIVATE);\n        SharedPreferences.Editor editor = pref.edit();\n        if (value == BluetoothDevice.ACCESS_UNKNOWN) {\n            editor.remove(device.getAddress());\n        } else {\n            editor.putBoolean(device.getAddress(), value == BluetoothDevice.ACCESS_ALLOWED);\n        }\n        editor.apply();\n    }\n\n    public void setPhonebookAccessPermission(BluetoothDevice device, int value) {\n        setDeviceAccessFromPrefs(device, value, PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE);\n    }\n\n    public void setMessageAccessPermission(BluetoothDevice device, int value) {\n        setDeviceAccessFromPrefs(device, value, MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE);\n    }\n\n    public void setSimAccessPermission(BluetoothDevice device, int value) {\n        setDeviceAccessFromPrefs(device, value, SIM_ACCESS_PERMISSION_PREFERENCE_FILE);\n    }\n\n    public boolean isRpaOffloadSupported() {\n        return mAdapterProperties.isRpaOffloadSupported();\n    }\n\n    public int getNumOfOffloadedIrkSupported() {\n        return mAdapterProperties.getNumOfOffloadedIrkSupported();\n    }\n\n    public int getNumOfOffloadedScanFilterSupported() {\n        return mAdapterProperties.getNumOfOffloadedScanFilterSupported();\n    }\n\n    public int getOffloadedScanResultStorage() {\n        return mAdapterProperties.getOffloadedScanResultStorage();\n    }\n\n    public boolean isLe2MPhySupported() {\n        return mAdapterProperties.isLe2MPhySupported();\n    }\n\n    public boolean isLeCodedPhySupported() {\n        return mAdapterProperties.isLeCodedPhySupported();\n    }\n\n    public boolean isLeExtendedAdvertisingSupported() {\n        return mAdapterProperties.isLeExtendedAdvertisingSupported();\n    }\n\n    public boolean isLePeriodicAdvertisingSupported() {\n        return mAdapterProperties.isLePeriodicAdvertisingSupported();\n    }\n\n    /**\n     * Check if the LE audio broadcast source feature is supported.\n     *\n     * @return true, if the LE audio broadcast source is supported\n     */\n    public boolean isLeAudioBroadcastSourceSupported() {\n        return mAdapterProperties.isLePeriodicAdvertisingSupported()\n                && mAdapterProperties.isLeExtendedAdvertisingSupported()\n                && mAdapterProperties.isLeIsochronousBroadcasterSupported();\n    }\n\n    /**\n     * Check if the LE audio broadcast assistant feature is supported.\n     *\n     * @return true, if the LE audio broadcast assistant is supported\n     */\n    public boolean isLeAudioBroadcastAssistantSupported() {\n        return mAdapterProperties.isLePeriodicAdvertisingSupported()\n                && mAdapterProperties.isLeExtendedAdvertisingSupported()\n                && (mAdapterProperties.isLePeriodicAdvertisingSyncTransferSenderSupported()\n                        || mAdapterProperties\n                                .isLePeriodicAdvertisingSyncTransferRecipientSupported());\n    }\n\n    /**\n     * Check if the LE channel sounding feature is supported.\n     *\n     * @return true, if the LE channel sounding is supported\n     */\n    public boolean isLeChannelSoundingSupported() {\n        return mAdapterProperties.isLeChannelSoundingSupported();\n    }\n\n    public long getSupportedProfilesBitMask() {\n        return Config.getSupportedProfilesBitMask();\n    }\n\n    /**\n     * Check if the LE audio CIS central feature is supported.\n     *\n     * @return true, if the LE audio CIS central is supported\n     */\n    public boolean isLeConnectedIsochronousStreamCentralSupported() {\n        return mAdapterProperties.isLeConnectedIsochronousStreamCentralSupported();\n    }\n\n    public int getLeMaximumAdvertisingDataLength() {\n        return mAdapterProperties.getLeMaximumAdvertisingDataLength();\n    }\n\n    /**\n     * Get the maximum number of connected audio devices.\n     *\n     * @return the maximum number of connected audio devices\n     */\n    public int getMaxConnectedAudioDevices() {\n        return mAdapterProperties.getMaxConnectedAudioDevices();\n    }\n\n    /**\n     * Check whether A2DP offload is enabled.\n     *\n     * @return true if A2DP offload is enabled\n     */\n    public boolean isA2dpOffloadEnabled() {\n        return mAdapterProperties.isA2dpOffloadEnabled();\n    }\n\n    /** Register a bluetooth state callback */\n    public void registerBluetoothStateCallback(Executor executor, BluetoothStateCallback callback) {\n        mLocalCallbacks.put(callback, executor);\n    }\n\n    /** Unregister a bluetooth state callback */\n    public void unregisterBluetoothStateCallback(BluetoothStateCallback callback) {\n        mLocalCallbacks.remove(callback);\n    }\n\n    @VisibleForTesting\n    void registerRemoteCallback(IBluetoothCallback callback) {\n        mRemoteCallbacks.register(callback);\n    }\n\n    @VisibleForTesting\n    void unregisterRemoteCallback(IBluetoothCallback callback) {\n        mRemoteCallbacks.unregister(callback);\n    }\n\n    @VisibleForTesting\n    void bleOnToOn() {\n        mAdapterStateMachine.sendMessage(AdapterState.USER_TURN_ON);\n    }\n\n    @VisibleForTesting\n    void bleOnToOff() {\n        mAdapterStateMachine.sendMessage(AdapterState.BLE_TURN_OFF);\n    }\n\n    @VisibleForTesting\n    boolean factoryReset() {\n        mDatabaseManager.factoryReset();\n\n        if (mBluetoothKeystoreService != null) {\n            mBluetoothKeystoreService.factoryReset();\n        }\n\n        if (mBtCompanionManager != null) {\n            mBtCompanionManager.factoryReset();\n        }\n\n        return mNativeInterface.factoryReset();\n    }\n\n    @VisibleForTesting\n    int getScanMode() {\n        return mScanMode;\n    }\n\n    private boolean setScanMode(int mode, String from) {\n        mScanModeChanges.add(Utils.getLocalTimeString() + \" (\" + from + \") \" + dumpScanMode(mode));\n        if (!mNativeInterface.setScanMode(convertScanModeToHal(mode))) {\n            return false;\n        }\n        mScanMode = mode;\n        Intent intent =\n                new Intent(BluetoothAdapter.ACTION_SCAN_MODE_CHANGED)\n                        .putExtra(BluetoothAdapter.EXTRA_SCAN_MODE, mScanMode)\n                        .addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);\n        sendBroadcast(intent, BLUETOOTH_SCAN, Utils.getTempBroadcastOptions().toBundle());\n        return true;\n    }\n\n    @VisibleForTesting\n    BluetoothActivityEnergyInfo reportActivityInfo() {\n        if (mAdapterProperties.getState() != BluetoothAdapter.STATE_ON\n                || !mAdapterProperties.isActivityAndEnergyReportingSupported()) {\n            return null;\n        }\n\n        // Pull the data. The callback will notify mEnergyInfoLock.\n        mNativeInterface.readEnergyInfo();\n\n        synchronized (mEnergyInfoLock) {\n            long now = System.currentTimeMillis();\n            final long deadline = now + CONTROLLER_ENERGY_UPDATE_TIMEOUT_MILLIS;\n            while (now < deadline) {\n                try {\n                    mEnergyInfoLock.wait(deadline - now);\n                    break;\n                } catch (InterruptedException e) {\n                    now = System.currentTimeMillis();\n                }\n            }\n\n            final BluetoothActivityEnergyInfo info =\n                    new BluetoothActivityEnergyInfo(\n                            SystemClock.elapsedRealtime(),\n                            mStackReportedState,\n                            mTxTimeTotalMs,\n                            mRxTimeTotalMs,\n                            mIdleTimeTotalMs,\n                            mEnergyUsedTotalVoltAmpSecMicro);\n\n            // Copy the traffic objects whose byte counts are > 0\n            final List<UidTraffic> result = new ArrayList<>();\n            for (int i = 0; i < mUidTraffic.size(); i++) {\n                final UidTraffic traffic = mUidTraffic.valueAt(i);\n                if (traffic.getTxBytes() != 0 || traffic.getRxBytes() != 0) {\n                    result.add(traffic.clone());\n                }\n            }\n\n            info.setUidTraffic(result);\n\n            return info;\n        }\n    }\n\n    public int getTotalNumOfTrackableAdvertisements() {\n        return mAdapterProperties.getTotalNumOfTrackableAdvertisements();\n    }\n\n    /**\n     * Return if offloaded TDS filter is supported.\n     *\n     * @return {@code BluetoothStatusCodes.FEATURE_SUPPORTED} if supported\n     */\n    public int getOffloadedTransportDiscoveryDataScanSupported() {\n        if (mAdapterProperties.isOffloadedTransportDiscoveryDataScanSupported()) {\n            return BluetoothStatusCodes.FEATURE_SUPPORTED;\n        }\n        return BluetoothStatusCodes.FEATURE_NOT_SUPPORTED;\n    }\n\n    IBinder getBluetoothGatt() {\n        return mGattService == null ? null : mGattService.getBinder();\n    }\n\n    public GattService getBluetoothGattService() {\n        return mGattService;\n    }\n\n    IBinder getBluetoothScan() {\n        return mScanController == null ? null : mScanController.getBinder();\n    }\n\n    public ScanController getBluetoothScanController() {\n        return mScanController;\n    }\n\n    @RequiresPermission(BLUETOOTH_CONNECT)\n    void unregAllGattClient(AttributionSource source) {\n        if (mGattService != null) {\n            mGattService.unregAll(source);\n        }\n    }\n\n    IBinder getProfile(int profileId) {\n        if (getState() == BluetoothAdapter.STATE_TURNING_ON) {\n            return null;\n        }\n\n        // LE_AUDIO_BROADCAST is not associated with a service and use LE_AUDIO's Binder\n        if (profileId == BluetoothProfile.LE_AUDIO_BROADCAST) {\n            profileId = BluetoothProfile.LE_AUDIO;\n        }\n\n        ProfileService profile = mStartedProfiles.get(profileId);\n        if (profile != null) {\n            return profile.getBinder();\n        } else {\n            return null;\n        }\n    }\n\n    boolean isMediaProfileConnected() {\n        if (mA2dpService != null && mA2dpService.getConnectedDevices().size() > 0) {\n            Log.d(TAG, \"isMediaProfileConnected. A2dp is connected\");\n            return true;\n        } else if (mHearingAidService != null\n                && mHearingAidService.getConnectedDevices().size() > 0) {\n            Log.d(TAG, \"isMediaProfileConnected. HearingAid is connected\");\n            return true;\n        } else if (mLeAudioService != null && mLeAudioService.getConnectedDevices().size() > 0) {\n            Log.d(TAG, \"isMediaProfileConnected. LeAudio is connected\");\n            return true;\n        } else {\n            Log.d(\n                    TAG,\n                    \"isMediaProfileConnected: no Media connected.\"\n                            + (\" A2dp=\" + mA2dpService)\n                            + (\" HearingAid=\" + mHearingAidService)\n                            + (\" LeAudio=\" + mLeAudioService));\n            return false;\n        }\n    }\n\n    /** Update PhonePolicy when new {@link BluetoothDevice} creates an ACL connection. */\n    public void updatePhonePolicyOnAclConnect(BluetoothDevice device) {\n        if (mPhonePolicy != null) {\n            mPhonePolicy.handleAclConnected(device);\n        }\n    }\n\n    /**\n     * Notify {@link BluetoothProfile} when ACL connection disconnects from {@link BluetoothDevice}\n     * for a given {@code transport}.\n     */\n    public void notifyAclDisconnected(BluetoothDevice device, int transport) {\n        if (mMapService != null && mMapService.isAvailable()) {\n            mMapService.aclDisconnected(device);\n        }\n        if (mMapClientService != null && mMapClientService.isAvailable()) {\n            mMapClientService.aclDisconnected(device, transport);\n        }\n        if (mSapService != null && mSapService.isAvailable()) {\n            mSapService.aclDisconnected(device);\n        }\n        if (mPbapClientService != null && mPbapClientService.isAvailable()) {\n            mPbapClientService.aclDisconnected(device, transport);\n        }\n    }\n\n    /**\n     * Notify GATT of a Bluetooth profile's connection state change for a given {@link\n     * BluetoothProfile}.\n     */\n    public void notifyProfileConnectionStateChangeToGatt(int profile, int fromState, int toState) {\n        if (mGattService == null) {\n            Log.w(TAG, \"GATT Service is not running!\");\n            return;\n        }\n        if (Flags.scanManagerRefactor()) {\n            mScanController.notifyProfileConnectionStateChange(profile, fromState, toState);\n        } else {\n            mGattService.notifyProfileConnectionStateChange(profile, fromState, toState);\n        }\n    }\n\n    /**\n     * Handle Bluetooth app state when connection state changes for a given {@code profile}.\n     *\n     * <p>Currently this function is limited to handling Phone policy but the eventual goal is to\n     * move all connection logic here.\n     */\n    public void handleProfileConnectionStateChange(\n            int profile, BluetoothDevice device, int fromState, int toState) {\n        if (mPhonePolicy != null) {\n            mPhonePolicy.profileConnectionStateChanged(profile, device, fromState, toState);\n        }\n    }\n\n    /** Handle Bluetooth app state when active device changes for a given {@code profile}. */\n    public void handleActiveDeviceChange(int profile, BluetoothDevice device) {\n        mActiveDeviceManager.profileActiveDeviceChanged(profile, device);\n        mSilenceDeviceManager.profileActiveDeviceChanged(profile, device);\n        if (mPhonePolicy != null) {\n            mPhonePolicy.profileActiveDeviceChanged(profile, device);\n        }\n    }\n\n    /** Notify MAP and Pbap when a new sdp search record is found. */\n    public void sendSdpSearchRecord(\n            BluetoothDevice device, int status, Parcelable record, ParcelUuid uuid) {\n        if (mMapService != null && mMapService.isAvailable()) {\n            mMapService.receiveSdpSearchRecord(status, record, uuid);\n        }\n        if (mMapClientService != null && mMapClientService.isAvailable()) {\n            mMapClientService.receiveSdpSearchRecord(device, status, record, uuid);\n        }\n        if (mPbapClientService != null && mPbapClientService.isAvailable()) {\n            mPbapClientService.receiveSdpSearchRecord(device, status, record, uuid);\n        }\n    }\n\n    /** Handle Bluetooth profiles when bond state changes with a {@link BluetoothDevice} */\n    public void handleBondStateChanged(BluetoothDevice device, int fromState, int toState) {\n        if (mA2dpService != null && mA2dpService.isAvailable()) {\n            mA2dpService.handleBondStateChanged(device, fromState, toState);\n        }\n        if (mHeadsetService != null && mHeadsetService.isAvailable()) {\n            mHeadsetService.handleBondStateChanged(device, fromState, toState);\n        }\n        if (mLeAudioService != null && mLeAudioService.isAvailable()) {\n            mLeAudioService.handleBondStateChanged(device, fromState, toState);\n        }\n        if (mHearingAidService != null && mHearingAidService.isAvailable()) {\n            mHearingAidService.handleBondStateChanged(device, fromState, toState);\n        }\n        if (mHapClientService != null && mHapClientService.isAvailable()) {\n            mHapClientService.handleBondStateChanged(device, fromState, toState);\n        }\n        if (mBassClientService != null && mBassClientService.isAvailable()) {\n            mBassClientService.handleBondStateChanged(device, fromState, toState);\n        }\n        if (mBatteryService != null && mBatteryService.isAvailable()) {\n            mBatteryService.handleBondStateChanged(device, fromState, toState);\n        }\n        if (mVolumeControlService != null && mVolumeControlService.isAvailable()) {\n            mVolumeControlService.handleBondStateChanged(device, fromState, toState);\n        }\n        if (mPbapService != null && mPbapService.isAvailable()) {\n            mPbapService.handleBondStateChanged(device, fromState, toState);\n        }\n        if (mCsipSetCoordinatorService != null && mCsipSetCoordinatorService.isAvailable()) {\n            mCsipSetCoordinatorService.handleBondStateChanged(device, fromState, toState);\n        }\n        mDatabaseManager.handleBondStateChanged(device, fromState, toState);\n\n        if (toState == BOND_NONE) {\n            // Remove the permissions for unbonded devices\n            setMessageAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n            setPhonebookAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n            setSimAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n        }\n    }\n\n    static int convertScanModeToHal(int mode) {\n        switch (mode) {\n            case SCAN_MODE_NONE:\n                return AbstractionLayer.BT_SCAN_MODE_NONE;\n            case SCAN_MODE_CONNECTABLE:\n                return AbstractionLayer.BT_SCAN_MODE_CONNECTABLE;\n            case SCAN_MODE_CONNECTABLE_DISCOVERABLE:\n                return AbstractionLayer.BT_SCAN_MODE_CONNECTABLE_DISCOVERABLE;\n        }\n        return -1;\n    }\n\n    static int convertScanModeFromHal(int mode) {\n        switch (mode) {\n            case AbstractionLayer.BT_SCAN_MODE_NONE:\n                return SCAN_MODE_NONE;\n            case AbstractionLayer.BT_SCAN_MODE_CONNECTABLE:\n                return SCAN_MODE_CONNECTABLE;\n            case AbstractionLayer.BT_SCAN_MODE_CONNECTABLE_DISCOVERABLE:\n                return SCAN_MODE_CONNECTABLE_DISCOVERABLE;\n        }\n        return -1;\n    }\n\n    // This function is called from JNI. It allows native code to acquire a single wake lock.\n    // If the wake lock is already held, this function returns success. Although this function\n    // only supports acquiring a single wake lock at a time right now, it will eventually be\n    // extended to allow acquiring an arbitrary number of wake locks. The current interface\n    // takes |lockName| as a parameter in anticipation of that implementation.\n    boolean acquireWakeLock(String lockName) {\n        synchronized (this) {\n            if (mWakeLock == null) {\n                mWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, lockName);\n            }\n\n            if (!mWakeLock.isHeld()) {\n                mWakeLock.acquire();\n            }\n        }\n        return true;\n    }\n\n    // This function is called from JNI. It allows native code to release a wake lock acquired\n    // by |acquireWakeLock|. If the wake lock is not held, this function returns failure.\n    // Note that the release() call is also invoked by {@link #cleanup()} so a synchronization is\n    // needed here. See the comment for |acquireWakeLock| for an explanation of the interface.\n    boolean releaseWakeLock(String lockName) {\n        synchronized (this) {\n            if (mWakeLock == null) {\n                Log.e(TAG, \"Repeated wake lock release; aborting release: \" + lockName);\n                return false;\n            }\n\n            if (mWakeLock.isHeld()) {\n                mWakeLock.release();\n            }\n        }\n        return true;\n    }\n\n    void energyInfoCallbackInternal(\n            int status,\n            int ctrlState,\n            long txTime,\n            long rxTime,\n            long idleTime,\n            long energyUsed,\n            UidTraffic[] data) {\n        // Energy is product of mA, V and ms. If the chipset doesn't\n        // report it, we have to compute it from time\n        if (energyUsed == 0) {\n            try {\n                final long txMah = Math.multiplyExact(txTime, getTxCurrentMa());\n                final long rxMah = Math.multiplyExact(rxTime, getRxCurrentMa());\n                final long idleMah = Math.multiplyExact(idleTime, getIdleCurrentMa());\n                energyUsed =\n                        (long)\n                                (Math.addExact(Math.addExact(txMah, rxMah), idleMah)\n                                        * getOperatingVolt());\n            } catch (ArithmeticException e) {\n                Log.wtf(TAG, \"overflow in bluetooth energy callback\", e);\n                // Energy is already 0 if the exception was thrown.\n            }\n        }\n\n        synchronized (mEnergyInfoLock) {\n            mStackReportedState = ctrlState;\n            long totalTxTimeMs;\n            long totalRxTimeMs;\n            long totalIdleTimeMs;\n            long totalEnergy;\n            try {\n                totalTxTimeMs = Math.addExact(mTxTimeTotalMs, txTime);\n                totalRxTimeMs = Math.addExact(mRxTimeTotalMs, rxTime);\n                totalIdleTimeMs = Math.addExact(mIdleTimeTotalMs, idleTime);\n                totalEnergy = Math.addExact(mEnergyUsedTotalVoltAmpSecMicro, energyUsed);\n            } catch (ArithmeticException e) {\n                // This could be because we accumulated a lot of time, or we got a very strange\n                // value from the controller (more likely). Discard this data.\n                Log.wtf(TAG, \"overflow in bluetooth energy callback\", e);\n                totalTxTimeMs = mTxTimeTotalMs;\n                totalRxTimeMs = mRxTimeTotalMs;\n                totalIdleTimeMs = mIdleTimeTotalMs;\n                totalEnergy = mEnergyUsedTotalVoltAmpSecMicro;\n            }\n\n            mTxTimeTotalMs = totalTxTimeMs;\n            mRxTimeTotalMs = totalRxTimeMs;\n            mIdleTimeTotalMs = totalIdleTimeMs;\n            mEnergyUsedTotalVoltAmpSecMicro = totalEnergy;\n\n            for (UidTraffic traffic : data) {\n                UidTraffic existingTraffic = mUidTraffic.get(traffic.getUid());\n                if (existingTraffic == null) {\n                    mUidTraffic.put(traffic.getUid(), traffic);\n                } else {\n                    existingTraffic.addRxBytes(traffic.getRxBytes());\n                    existingTraffic.addTxBytes(traffic.getTxBytes());\n                }\n            }\n            mEnergyInfoLock.notifyAll();\n        }\n    }\n\n    void energyInfoCallback(\n            int status,\n            int ctrlState,\n            long txTime,\n            long rxTime,\n            long idleTime,\n            long energyUsed,\n            UidTraffic[] data) {\n        if (Flags.btSystemContextReport()) {\n            energyInfoCallbackInternal(\n                    status, ctrlState, txTime, rxTime, idleTime, energyUsed, data);\n        } else if (ctrlState >= BluetoothActivityEnergyInfo.BT_STACK_STATE_INVALID\n                && ctrlState <= BluetoothActivityEnergyInfo.BT_STACK_STATE_STATE_IDLE) {\n            energyInfoCallbackInternal(\n                    status, ctrlState, txTime, rxTime, idleTime, energyUsed, data);\n        }\n        Log.v(\n                TAG,\n                \"energyInfoCallback()\"\n                        + (\" status = \" + status)\n                        + (\" txTime = \" + txTime)\n                        + (\" rxTime = \" + rxTime)\n                        + (\" idleTime = \" + idleTime)\n                        + (\" energyUsed = \" + energyUsed)\n                        + (\" ctrlState = \" + Utils.formatSimple(\"0x%08x\", ctrlState))\n                        + (\" traffic = \" + Arrays.toString(data)));\n    }\n\n    /** Update metadata change to registered listeners */\n    @VisibleForTesting\n    public void metadataChanged(String address, int key, byte[] value) {\n        BluetoothDevice device = mRemoteDevices.getDevice(Utils.getBytesFromAddress(address));\n\n        // pass just interesting metadata to native, to reduce spam\n        if (key == BluetoothDevice.METADATA_LE_AUDIO) {\n            mNativeInterface.metadataChanged(Utils.getBytesFromAddress(address), key, value);\n        }\n\n        RemoteCallbackList<IBluetoothMetadataListener> list = mMetadataListeners.get(device);\n        if (list == null) {\n            return;\n        }\n        int n = list.beginBroadcast();\n        for (int i = 0; i < n; i++) {\n            try {\n                list.getBroadcastItem(i).onMetadataChanged(device, key, value);\n            } catch (RemoteException e) {\n                Log.d(TAG, \"metadataChanged() - Callback #\" + i + \" failed (\" + e + \")\");\n            }\n        }\n        list.finishBroadcast();\n    }\n\n    private int getIdleCurrentMa() {\n        return BluetoothProperties.getHardwareIdleCurrentMa().orElse(0);\n    }\n\n    private int getTxCurrentMa() {\n        return BluetoothProperties.getHardwareTxCurrentMa().orElse(0);\n    }\n\n    private int getRxCurrentMa() {\n        return BluetoothProperties.getHardwareRxCurrentMa().orElse(0);\n    }\n\n    private double getOperatingVolt() {\n        return BluetoothProperties.getHardwareOperatingVoltageMv().orElse(0) / 1000.0;\n    }\n\n    public RemoteDevices getRemoteDevices() {\n        return mRemoteDevices;\n    }\n\n    private String dumpScanMode(int scanMode) {\n        switch (scanMode) {\n            case SCAN_MODE_NONE:\n                return \"SCAN_MODE_NONE\";\n            case SCAN_MODE_CONNECTABLE:\n                return \"SCAN_MODE_CONNECTABLE\";\n            case SCAN_MODE_CONNECTABLE_DISCOVERABLE:\n                return \"SCAN_MODE_CONNECTABLE_DISCOVERABLE\";\n            default:\n                return \"Unknown Scan Mode \" + scanMode;\n        }\n    }\n\n    @Override\n    protected void dump(FileDescriptor fd, PrintWriter writer, String[] args) {\n        if (args.length == 0) {\n            writer.println(\"Skipping dump in APP SERVICES, see bluetooth_manager section.\");\n            writer.println(\"Use --print argument for dumpsys direct from AdapterService.\");\n            return;\n        }\n\n        if (\"set-test-mode\".equals(args[0])) {\n            final boolean testModeEnabled = \"enabled\".equalsIgnoreCase(args[1]);\n            for (ProfileService profile : mRunningProfiles) {\n                profile.setTestModeEnabled(testModeEnabled);\n            }\n            if (Flags.scanManagerRefactor() && mScanController != null) {\n                mScanController.setTestModeEnabled(testModeEnabled);\n            }\n            mTestModeEnabled = testModeEnabled;\n            return;\n        }\n\n        Log.v(TAG, \"dumpsys arguments, check for protobuf output: \" + TextUtils.join(\" \", args));\n        if (args[0].equals(\"--proto-bin\")) {\n            dumpMetrics(fd);\n            return;\n        }\n\n        writer.println();\n        mAdapterProperties.dump(fd, writer, args);\n\n        writer.println(\"ScanMode: \" + dumpScanMode(getScanMode()));\n        writer.println(\"Scan Mode Changes:\");\n        for (String log : mScanModeChanges) {\n            writer.println(\"    \" + log);\n        }\n        writer.println();\n        writer.println(\"sSnoopLogSettingAtEnable = \" + sSnoopLogSettingAtEnable);\n        writer.println(\"sDefaultSnoopLogSettingAtEnable = \" + sDefaultSnoopLogSettingAtEnable);\n\n        writer.println();\n        writer.println(\"Enabled Profile Services:\");\n        for (int profileId : Config.getSupportedProfiles()) {\n            writer.println(\"  \" + BluetoothProfile.getProfileName(profileId));\n        }\n        writer.println();\n\n        mAdapterStateMachine.dump(fd, writer, args);\n\n        StringBuilder sb = new StringBuilder();\n        for (ProfileService profile : mRegisteredProfiles) {\n            profile.dump(sb);\n        }\n        mSilenceDeviceManager.dump(fd, writer, args);\n        mDatabaseManager.dump(writer);\n\n        writer.write(sb.toString());\n        writer.flush();\n\n        final int currentState = mAdapterProperties.getState();\n        if (currentState == BluetoothAdapter.STATE_OFF\n                || currentState == BluetoothAdapter.STATE_BLE_TURNING_ON\n                || currentState == BluetoothAdapter.STATE_TURNING_OFF\n                || currentState == BluetoothAdapter.STATE_BLE_TURNING_OFF) {\n            writer.println();\n            writer.println(\n                    \"Impossible to dump native stack. state=\"\n                            + BluetoothAdapter.nameForState(currentState));\n            writer.println();\n        } else {\n            mNativeInterface.dump(fd, args);\n        }\n    }\n\n    private void dumpMetrics(FileDescriptor fd) {\n        BluetoothMetricsProto.BluetoothLog.Builder metricsBuilder =\n                BluetoothMetricsProto.BluetoothLog.newBuilder();\n        byte[] nativeMetricsBytes = mNativeInterface.dumpMetrics();\n        Log.d(TAG, \"dumpMetrics: native metrics size is \" + nativeMetricsBytes.length);\n        if (nativeMetricsBytes.length > 0) {\n            try {\n                metricsBuilder.mergeFrom(nativeMetricsBytes);\n            } catch (InvalidProtocolBufferException ex) {\n                Log.w(TAG, \"dumpMetrics: problem parsing metrics protobuf, \" + ex.getMessage());\n                return;\n            }\n        }\n        metricsBuilder.setNumBondedDevices(getBondedDevices().length);\n        MetricsLogger.dumpProto(metricsBuilder);\n        for (ProfileService profile : mRegisteredProfiles) {\n            profile.dumpProto(metricsBuilder);\n        }\n        byte[] metricsBytes = Base64.encode(metricsBuilder.build().toByteArray(), Base64.DEFAULT);\n        Log.d(TAG, \"dumpMetrics: combined metrics size is \" + metricsBytes.length);\n        try (FileOutputStream protoOut = new FileOutputStream(fd)) {\n            protoOut.write(metricsBytes);\n        } catch (IOException e) {\n            Log.e(TAG, \"dumpMetrics: error writing combined protobuf to fd, \" + e.getMessage());\n        }\n    }\n\n    @SuppressLint(\"AndroidFrameworkRequiresPermission\")\n    private void enforceBluetoothPrivilegedPermissionIfNeeded(\n            OobData remoteP192Data, OobData remoteP256Data) {\n        if (remoteP192Data != null || remoteP256Data != null) {\n            this.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n        }\n    }\n\n    private final Object mDeviceConfigLock = new Object();\n\n    /**\n     * Predicate that can be applied to names to determine if a device is well-known to be used for\n     * physical location.\n     */\n    @GuardedBy(\"mDeviceConfigLock\")\n    private Predicate<String> mLocationDenylistName = (v) -> false;\n\n    /**\n     * Predicate that can be applied to MAC addresses to determine if a device is well-known to be\n     * used for physical location.\n     */\n    @GuardedBy(\"mDeviceConfigLock\")\n    private Predicate<byte[]> mLocationDenylistMac = (v) -> false;\n\n    /**\n     * Predicate that can be applied to Advertising Data payloads to determine if a device is\n     * well-known to be used for physical location.\n     */\n    @GuardedBy(\"mDeviceConfigLock\")\n    private Predicate<byte[]> mLocationDenylistAdvertisingData = (v) -> false;\n\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScanQuotaCount = DeviceConfigListener.DEFAULT_SCAN_QUOTA_COUNT;\n\n    @GuardedBy(\"mDeviceConfigLock\")\n    private long mScanQuotaWindowMillis = DeviceConfigListener.DEFAULT_SCAN_QUOTA_WINDOW_MILLIS;\n\n    @GuardedBy(\"mDeviceConfigLock\")\n    private long mScanTimeoutMillis = DeviceConfigListener.DEFAULT_SCAN_TIMEOUT_MILLIS;\n\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScanUpgradeDurationMillis =\n            DeviceConfigListener.DEFAULT_SCAN_UPGRADE_DURATION_MILLIS;\n\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScanDowngradeDurationMillis =\n            DeviceConfigListener.DEFAULT_SCAN_DOWNGRADE_DURATION_BT_CONNECTING_MILLIS;\n\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScreenOffLowPowerWindowMillis =\n            ScanManager.SCAN_MODE_SCREEN_OFF_LOW_POWER_WINDOW_MS;\n\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScreenOffLowPowerIntervalMillis =\n            ScanManager.SCAN_MODE_SCREEN_OFF_LOW_POWER_INTERVAL_MS;\n\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScreenOffBalancedWindowMillis =\n            ScanManager.SCAN_MODE_SCREEN_OFF_BALANCED_WINDOW_MS;\n\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScreenOffBalancedIntervalMillis =\n            ScanManager.SCAN_MODE_SCREEN_OFF_BALANCED_INTERVAL_MS;\n\n    @GuardedBy(\"mDeviceConfigLock\")\n    private String mLeAudioAllowList;\n\n    public @NonNull Predicate<String> getLocationDenylistName() {\n        synchronized (mDeviceConfigLock) {\n            return mLocationDenylistName;\n        }\n    }\n\n    public @NonNull Predicate<byte[]> getLocationDenylistMac() {\n        synchronized (mDeviceConfigLock) {\n            return mLocationDenylistMac;\n        }\n    }\n\n    public @NonNull Predicate<byte[]> getLocationDenylistAdvertisingData() {\n        synchronized (mDeviceConfigLock) {\n            return mLocationDenylistAdvertisingData;\n        }\n    }\n\n    /** Returns scan quota count. */\n    public int getScanQuotaCount() {\n        synchronized (mDeviceConfigLock) {\n            return mScanQuotaCount;\n        }\n    }\n\n    /** Returns scan quota window in millis. */\n    public long getScanQuotaWindowMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScanQuotaWindowMillis;\n        }\n    }\n\n    /** Returns scan timeout in millis. */\n    public long getScanTimeoutMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScanTimeoutMillis;\n        }\n    }\n\n    /** Returns scan upgrade duration in millis. */\n    public long getScanUpgradeDurationMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScanUpgradeDurationMillis;\n        }\n    }\n\n    /** Returns scan downgrade duration in millis. */\n    public long getScanDowngradeDurationMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScanDowngradeDurationMillis;\n        }\n    }\n\n    /** Returns SCREEN_OFF_BALANCED scan window in millis. */\n    public int getScreenOffBalancedWindowMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScreenOffBalancedWindowMillis;\n        }\n    }\n\n    /** Returns SCREEN_OFF_BALANCED scan interval in millis. */\n    public int getScreenOffBalancedIntervalMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScreenOffBalancedIntervalMillis;\n        }\n    }\n\n    /** Returns SCREEN_OFF low power scan window in millis. */\n    public int getScreenOffLowPowerWindowMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScreenOffLowPowerWindowMillis;\n        }\n    }\n\n    /** Returns SCREEN_OFF low power scan interval in millis. */\n    public int getScreenOffLowPowerIntervalMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScreenOffLowPowerIntervalMillis;\n        }\n    }\n\n    private class DeviceConfigListener implements DeviceConfig.OnPropertiesChangedListener {\n        private static final String LOCATION_DENYLIST_NAME = \"location_denylist_name\";\n        private static final String LOCATION_DENYLIST_MAC = \"location_denylist_mac\";\n        private static final String LOCATION_DENYLIST_ADVERTISING_DATA =\n                \"location_denylist_advertising_data\";\n        private static final String SCAN_QUOTA_COUNT = \"scan_quota_count\";\n        private static final String SCAN_QUOTA_WINDOW_MILLIS = \"scan_quota_window_millis\";\n        private static final String SCAN_TIMEOUT_MILLIS = \"scan_timeout_millis\";\n        private static final String SCAN_UPGRADE_DURATION_MILLIS = \"scan_upgrade_duration_millis\";\n        private static final String SCAN_DOWNGRADE_DURATION_MILLIS =\n                \"scan_downgrade_duration_millis\";\n        private static final String SCREEN_OFF_LOW_POWER_WINDOW_MILLIS =\n                \"screen_off_low_power_window_millis\";\n        private static final String SCREEN_OFF_LOW_POWER_INTERVAL_MILLIS =\n                \"screen_off_low_power_interval_millis\";\n        private static final String SCREEN_OFF_BALANCED_WINDOW_MILLIS =\n                \"screen_off_balanced_window_millis\";\n        private static final String SCREEN_OFF_BALANCED_INTERVAL_MILLIS =\n                \"screen_off_balanced_interval_millis\";\n        private static final String LE_AUDIO_ALLOW_LIST = \"le_audio_allow_list\";\n\n        /**\n         * Default denylist which matches Eddystone (except for Eddystone-E2EE-EID) and iBeacon\n         * payloads.\n         */\n        private static final String DEFAULT_LOCATION_DENYLIST_ADVERTISING_DATA =\n                \"\u22880016AAFE40/00FFFFFFF0,\u22860016AAFE/00FFFFFF,\u228600FF4C0002/00FFFFFFFF\";\n\n        private static final int DEFAULT_SCAN_QUOTA_COUNT = 5;\n        private static final long DEFAULT_SCAN_QUOTA_WINDOW_MILLIS = 30 * SECOND_IN_MILLIS;\n        private static final long DEFAULT_SCAN_TIMEOUT_MILLIS = 10 * MINUTE_IN_MILLIS;\n        private static final int DEFAULT_SCAN_UPGRADE_DURATION_MILLIS = (int) SECOND_IN_MILLIS * 6;\n        private static final int DEFAULT_SCAN_DOWNGRADE_DURATION_BT_CONNECTING_MILLIS =\n                (int) SECOND_IN_MILLIS * 6;\n\n        public void start() {\n            DeviceConfig.addOnPropertiesChangedListener(\n                    DeviceConfig.NAMESPACE_BLUETOOTH, BackgroundThread.getExecutor(), this);\n            onPropertiesChanged(DeviceConfig.getProperties(DeviceConfig.NAMESPACE_BLUETOOTH));\n        }\n\n        @Override\n        public void onPropertiesChanged(DeviceConfig.Properties properties) {\n            synchronized (mDeviceConfigLock) {\n                final String name = properties.getString(LOCATION_DENYLIST_NAME, null);\n                mLocationDenylistName =\n                        !TextUtils.isEmpty(name)\n                                ? Pattern.compile(name).asPredicate()\n                                : (v) -> false;\n                mLocationDenylistMac =\n                        BytesMatcher.decode(properties.getString(LOCATION_DENYLIST_MAC, null));\n                mLocationDenylistAdvertisingData =\n                        BytesMatcher.decode(\n                                properties.getString(\n                                        LOCATION_DENYLIST_ADVERTISING_DATA,\n                                        DEFAULT_LOCATION_DENYLIST_ADVERTISING_DATA));\n                mScanQuotaCount = properties.getInt(SCAN_QUOTA_COUNT, DEFAULT_SCAN_QUOTA_COUNT);\n                mScanQuotaWindowMillis =\n                        properties.getLong(\n                                SCAN_QUOTA_WINDOW_MILLIS, DEFAULT_SCAN_QUOTA_WINDOW_MILLIS);\n                mScanTimeoutMillis =\n                        properties.getLong(SCAN_TIMEOUT_MILLIS, DEFAULT_SCAN_TIMEOUT_MILLIS);\n                mScanUpgradeDurationMillis =\n                        properties.getInt(\n                                SCAN_UPGRADE_DURATION_MILLIS, DEFAULT_SCAN_UPGRADE_DURATION_MILLIS);\n                mScanDowngradeDurationMillis =\n                        properties.getInt(\n                                SCAN_DOWNGRADE_DURATION_MILLIS,\n                                DEFAULT_SCAN_DOWNGRADE_DURATION_BT_CONNECTING_MILLIS);\n                mScreenOffLowPowerWindowMillis =\n                        properties.getInt(\n                                SCREEN_OFF_LOW_POWER_WINDOW_MILLIS,\n                                ScanManager.SCAN_MODE_SCREEN_OFF_LOW_POWER_WINDOW_MS);\n                mScreenOffLowPowerIntervalMillis =\n                        properties.getInt(\n                                SCREEN_OFF_LOW_POWER_INTERVAL_MILLIS,\n                                ScanManager.SCAN_MODE_SCREEN_OFF_LOW_POWER_INTERVAL_MS);\n                mScreenOffBalancedWindowMillis =\n                        properties.getInt(\n                                SCREEN_OFF_BALANCED_WINDOW_MILLIS,\n                                ScanManager.SCAN_MODE_SCREEN_OFF_BALANCED_WINDOW_MS);\n                mScreenOffBalancedIntervalMillis =\n                        properties.getInt(\n                                SCREEN_OFF_BALANCED_INTERVAL_MILLIS,\n                                ScanManager.SCAN_MODE_SCREEN_OFF_BALANCED_INTERVAL_MS);\n                mLeAudioAllowList = properties.getString(LE_AUDIO_ALLOW_LIST, \"\");\n\n                if (!mLeAudioAllowList.isEmpty()) {\n                    List<String> leAudioAllowlistFromDeviceConfig =\n                            Arrays.asList(mLeAudioAllowList.split(\",\"));\n                    BluetoothProperties.le_audio_allow_list(leAudioAllowlistFromDeviceConfig);\n                }\n\n                List<String> leAudioAllowlistProp = BluetoothProperties.le_audio_allow_list();\n                if (leAudioAllowlistProp != null && !leAudioAllowlistProp.isEmpty()) {\n                    mLeAudioAllowDevices.clear();\n                    mLeAudioAllowDevices.addAll(leAudioAllowlistProp);\n                }\n            }\n        }\n    }\n\n    /** A callback that will be called when AdapterState is changed */\n    public interface BluetoothStateCallback {\n        /**\n         * Called when the status of bluetooth adapter is changing. {@code prevState} and {@code\n         * newState} takes one of following values defined in BluetoothAdapter.java: STATE_OFF,\n         * STATE_TURNING_ON, STATE_ON, STATE_TURNING_OFF, STATE_BLE_TURNING_ON, STATE_BLE_ON,\n         * STATE_BLE_TURNING_OFF\n         *\n         * @param prevState the previous Bluetooth state.\n         * @param newState the new Bluetooth state.\n         */\n        void onBluetoothStateChange(int prevState, int newState);\n    }\n\n    /**\n     * Obfuscate Bluetooth MAC address into a PII free ID string\n     *\n     * @param device Bluetooth device whose MAC address will be obfuscated\n     * @return a byte array that is unique to this MAC address on this device, or empty byte array\n     *     when either device is null or obfuscateAddressNative fails\n     */\n    public byte[] obfuscateAddress(BluetoothDevice device) {\n        if (device == null) {\n            return new byte[0];\n        }\n        return mNativeInterface.obfuscateAddress(Utils.getByteAddress(device));\n    }\n\n    /**\n     * Get dynamic audio buffer size supported type\n     *\n     * @return support\n     *     <p>Possible values are {@link BluetoothA2dp#DYNAMIC_BUFFER_SUPPORT_NONE}, {@link\n     *     BluetoothA2dp#DYNAMIC_BUFFER_SUPPORT_A2DP_OFFLOAD}, {@link\n     *     BluetoothA2dp#DYNAMIC_BUFFER_SUPPORT_A2DP_SOFTWARE_ENCODING}.\n     */\n    public int getDynamicBufferSupport() {\n        return mAdapterProperties.getDynamicBufferSupport();\n    }\n\n    /**\n     * Get dynamic audio buffer size\n     *\n     * @return BufferConstraints\n     */\n    public BufferConstraints getBufferConstraints() {\n        return mAdapterProperties.getBufferConstraints();\n    }\n\n    /**\n     * Set dynamic audio buffer size\n     *\n     * @param codec Audio codec\n     * @param value buffer millis\n     * @return true if the settings is successful, false otherwise\n     */\n    public boolean setBufferLengthMillis(int codec, int value) {\n        return mAdapterProperties.setBufferLengthMillis(codec, value);\n    }\n\n    /**\n     * Get an incremental id of Bluetooth metrics and log\n     *\n     * @param device Bluetooth device\n     * @return int of id for Bluetooth metrics and logging, 0 if the device is invalid\n     */\n    public int getMetricId(BluetoothDevice device) {\n        if (device == null) {\n            return 0;\n        }\n        return mNativeInterface.getMetricId(Utils.getByteAddress(device));\n    }\n\n    public CompanionManager getCompanionManager() {\n        return mBtCompanionManager;\n    }\n\n    /**\n     * Call for the AdapterService receives bond state change\n     *\n     * @param device Bluetooth device\n     * @param state bond state\n     */\n    public void onBondStateChanged(BluetoothDevice device, int state) {\n        if (mBtCompanionManager != null) {\n            mBtCompanionManager.onBondStateChanged(device, state);\n        }\n    }\n\n    /**\n     * Get audio policy feature support status\n     *\n     * @param device Bluetooth device to be checked for audio policy support\n     * @return int status of the remote support for audio policy feature\n     */\n    public int isRequestAudioPolicyAsSinkSupported(BluetoothDevice device) {\n        if (mHeadsetClientService != null) {\n            return mHeadsetClientService.getAudioPolicyRemoteSupported(device);\n        } else {\n            Log.e(TAG, \"No audio transport connected\");\n            return BluetoothStatusCodes.FEATURE_NOT_CONFIGURED;\n        }\n    }\n\n    /**\n     * Set audio policy for remote device\n     *\n     * @param device Bluetooth device to be set policy for\n     * @return int result status for requestAudioPolicyAsSink API\n     */\n    public int requestAudioPolicyAsSink(BluetoothDevice device, BluetoothSinkAudioPolicy policies) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp == null) {\n            return BluetoothStatusCodes.ERROR_DEVICE_NOT_BONDED;\n        }\n\n        if (mHeadsetClientService != null) {\n            if (isRequestAudioPolicyAsSinkSupported(device)\n                    != BluetoothStatusCodes.FEATURE_SUPPORTED) {\n                throw new UnsupportedOperationException(\n                        \"Request Audio Policy As Sink not supported\");\n            }\n            deviceProp.setHfAudioPolicyForRemoteAg(policies);\n            mHeadsetClientService.setAudioPolicy(device, policies);\n            return BluetoothStatusCodes.SUCCESS;\n        } else {\n            Log.e(TAG, \"HeadsetClient not connected\");\n            return BluetoothStatusCodes.ERROR_PROFILE_NOT_CONNECTED;\n        }\n    }\n\n    /**\n     * Get audio policy for remote device\n     *\n     * @param device Bluetooth device to be set policy for\n     * @return {@link BluetoothSinkAudioPolicy} policy stored for the device\n     */\n    public BluetoothSinkAudioPolicy getRequestedAudioPolicyAsSink(BluetoothDevice device) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp == null) {\n            return null;\n        }\n\n        if (mHeadsetClientService != null) {\n            return deviceProp.getHfAudioPolicyForRemoteAg();\n        } else {\n            Log.e(TAG, \"HeadsetClient not connected\");\n            return null;\n        }\n    }\n\n    /**\n     * Allow audio low latency\n     *\n     * @param allowed true if audio low latency is being allowed\n     * @param device device whose audio low latency will be allowed or disallowed\n     * @return boolean true if audio low latency is successfully allowed or disallowed\n     */\n    public boolean allowLowLatencyAudio(boolean allowed, BluetoothDevice device) {\n        return mNativeInterface.allowLowLatencyAudio(allowed, Utils.getByteAddress(device));\n    }\n\n    /**\n     * get remote PBAP PCE version.\n     *\n     * @param address of remote device\n     * @return int value other than 0 if remote PBAP PCE version is found\n     */\n    public int getRemotePbapPceVersion(String address) {\n        return mNativeInterface.getRemotePbapPceVersion(address);\n    }\n\n    /**\n     * check, if PBAP PSE dynamic version upgrade is enabled.\n     *\n     * @return true/false.\n     */\n    public boolean pbapPseDynamicVersionUpgradeIsEnabled() {\n        return mNativeInterface.pbapPseDynamicVersionUpgradeIsEnabled();\n    }\n\n    /** Sets the battery level of the remote device */\n    public void setBatteryLevel(BluetoothDevice device, int batteryLevel, boolean isBas) {\n        if (batteryLevel == BATTERY_LEVEL_UNKNOWN) {\n            mRemoteDevices.resetBatteryLevel(device, isBas);\n        } else {\n            mRemoteDevices.updateBatteryLevel(device, batteryLevel, isBas);\n        }\n    }\n\n    public boolean interopMatchAddr(InteropFeature feature, String address) {\n        return mNativeInterface.interopMatchAddr(feature.name(), address);\n    }\n\n    public boolean interopMatchName(InteropFeature feature, String name) {\n        return mNativeInterface.interopMatchName(feature.name(), name);\n    }\n\n    public boolean interopMatchAddrOrName(InteropFeature feature, String address) {\n        return mNativeInterface.interopMatchAddrOrName(feature.name(), address);\n    }\n\n    public void interopDatabaseAddAddr(InteropFeature feature, String address, int length) {\n        mNativeInterface.interopDatabaseAddRemoveAddr(true, feature.name(), address, length);\n    }\n\n    public void interopDatabaseRemoveAddr(InteropFeature feature, String address) {\n        mNativeInterface.interopDatabaseAddRemoveAddr(false, feature.name(), address, 0);\n    }\n\n    public void interopDatabaseAddName(InteropFeature feature, String name) {\n        mNativeInterface.interopDatabaseAddRemoveName(true, feature.name(), name);\n    }\n\n    public void interopDatabaseRemoveName(InteropFeature feature, String name) {\n        mNativeInterface.interopDatabaseAddRemoveName(false, feature.name(), name);\n    }\n\n    /**\n     * Checks the remote device is in the LE Audio allow list or not.\n     *\n     * @param device the device to check\n     * @return boolean true if the device is in the allow list, false otherwise.\n     */\n    public boolean isLeAudioAllowed(BluetoothDevice device) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n\n        if (deviceProp == null\n                || deviceProp.getModelName() == null\n                || !mLeAudioAllowDevices.contains(deviceProp.getModelName())) {\n\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Get type of the remote device\n     *\n     * @param device the device to check\n     * @return int device type\n     */\n    public int getRemoteType(BluetoothDevice device) {\n        return mRemoteDevices.getType(device);\n    }\n\n    /**\n     * Sends service discovery UUIDs internally within the stack. This is meant to remove internal\n     * dependencies on the broadcast {@link BluetoothDevice#ACTION_UUID}.\n     *\n     * @param device is the remote device whose UUIDs have been discovered\n     * @param uuids are the services supported on the remote device\n     */\n    void sendUuidsInternal(BluetoothDevice device, ParcelUuid[] uuids) {\n        if (device == null) {\n            Log.w(TAG, \"sendUuidsInternal: null device\");\n            return;\n        }\n        if (uuids == null) {\n            Log.w(TAG, \"sendUuidsInternal: uuids is null\");\n            return;\n        }\n        Log.i(TAG, \"sendUuidsInternal: Received service discovery UUIDs for device \" + device);\n        for (int i = 0; i < uuids.length; i++) {\n            Log.d(TAG, \"sendUuidsInternal: index=\" + i + \" uuid=\" + uuids[i]);\n        }\n        if (mPhonePolicy != null) {\n            mPhonePolicy.onUuidsDiscovered(device, uuids);\n        }\n    }\n}\n```",
                        "downstream_file_content": "```java\n/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.bluetooth.btservice;\n\nimport static android.bluetooth.BluetoothDevice.TRANSPORT_AUTO;\nimport static android.text.format.DateUtils.MINUTE_IN_MILLIS;\nimport static android.text.format.DateUtils.SECOND_IN_MILLIS;\n\nimport static com.android.bluetooth.Utils.callerIsSystemOrActiveOrManagedUser;\nimport static com.android.bluetooth.Utils.callerIsSystemOrActiveUser;\nimport static com.android.bluetooth.Utils.enforceBluetoothPrivilegedPermission;\nimport static com.android.bluetooth.Utils.enforceCdmAssociation;\nimport static com.android.bluetooth.Utils.enforceDumpPermission;\nimport static com.android.bluetooth.Utils.enforceLocalMacAddressPermission;\nimport static com.android.bluetooth.Utils.getBytesFromAddress;\nimport static com.android.bluetooth.Utils.hasBluetoothPrivilegedPermission;\nimport static com.android.bluetooth.Utils.isPackageNameAccurate;\n\nimport android.annotation.NonNull;\nimport android.annotation.RequiresPermission;\nimport android.annotation.SuppressLint;\nimport android.app.AlarmManager;\nimport android.app.AppOpsManager;\nimport android.app.PendingIntent;\nimport android.app.Service;\nimport android.app.admin.DevicePolicyManager;\nimport android.bluetooth.BluetoothA2dp;\nimport android.bluetooth.BluetoothActivityEnergyInfo;\nimport android.bluetooth.BluetoothAdapter;\nimport android.bluetooth.BluetoothAdapter.ActiveDeviceProfile;\nimport android.bluetooth.BluetoothAdapter.ActiveDeviceUse;\nimport android.bluetooth.BluetoothClass;\nimport android.bluetooth.BluetoothDevice;\nimport android.bluetooth.BluetoothFrameworkInitializer;\nimport android.bluetooth.BluetoothMap;\nimport android.bluetooth.BluetoothProfile;\nimport android.bluetooth.BluetoothProtoEnums;\nimport android.bluetooth.BluetoothSap;\nimport android.bluetooth.BluetoothServerSocket;\nimport android.bluetooth.BluetoothSocket;\nimport android.bluetooth.BluetoothStatusCodes;\nimport android.bluetooth.BluetoothUuid;\nimport android.bluetooth.BufferConstraints;\nimport android.bluetooth.IBluetooth;\nimport android.bluetooth.IBluetoothActivityEnergyInfoListener;\nimport android.bluetooth.IBluetoothCallback;\nimport android.bluetooth.IBluetoothConnectionCallback;\nimport android.bluetooth.IBluetoothMetadataListener;\nimport android.bluetooth.IBluetoothOobDataCallback;\nimport android.bluetooth.IBluetoothSocketManager;\nimport android.bluetooth.IncomingRfcommSocketInfo;\nimport android.bluetooth.OobData;\nimport android.bluetooth.UidTraffic;\nimport android.companion.CompanionDeviceManager;\nimport android.content.AttributionSource;\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.SharedPreferences;\nimport android.content.pm.PackageManager;\nimport android.os.AsyncTask;\nimport android.os.BatteryStatsManager;\nimport android.os.Binder;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.ParcelUuid;\nimport android.os.PowerManager;\nimport android.os.RemoteCallbackList;\nimport android.os.RemoteException;\nimport android.os.SystemClock;\nimport android.os.SystemProperties;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.provider.DeviceConfig;\nimport android.provider.Settings;\nimport android.sysprop.BluetoothProperties;\nimport android.text.TextUtils;\nimport android.util.Base64;\nimport android.util.Log;\nimport android.util.SparseArray;\n\nimport com.android.bluetooth.BluetoothMetricsProto;\nimport com.android.bluetooth.BluetoothStatsLog;\nimport com.android.bluetooth.R;\nimport com.android.bluetooth.Utils;\nimport com.android.bluetooth.a2dp.A2dpService;\nimport com.android.bluetooth.a2dpsink.A2dpSinkService;\nimport com.android.bluetooth.bas.BatteryService;\nimport com.android.bluetooth.bass_client.BassClientService;\nimport com.android.bluetooth.btservice.RemoteDevices.DeviceProperties;\nimport com.android.bluetooth.btservice.activityattribution.ActivityAttributionService;\nimport com.android.bluetooth.btservice.bluetoothkeystore.BluetoothKeystoreService;\nimport com.android.bluetooth.btservice.storage.DatabaseManager;\nimport com.android.bluetooth.btservice.storage.MetadataDatabase;\nimport com.android.bluetooth.csip.CsipSetCoordinatorService;\nimport com.android.bluetooth.gatt.GattService;\nimport com.android.bluetooth.gatt.ScanManager;\nimport com.android.bluetooth.hap.HapClientService;\nimport com.android.bluetooth.hearingaid.HearingAidService;\nimport com.android.bluetooth.hfp.HeadsetService;\nimport com.android.bluetooth.hfpclient.HeadsetClientService;\nimport com.android.bluetooth.hid.HidDeviceService;\nimport com.android.bluetooth.hid.HidHostService;\nimport com.android.bluetooth.le_audio.LeAudioService;\nimport com.android.bluetooth.map.BluetoothMapService;\nimport com.android.bluetooth.mapclient.MapClientService;\nimport com.android.bluetooth.pan.PanService;\nimport com.android.bluetooth.pbap.BluetoothPbapService;\nimport com.android.bluetooth.pbapclient.PbapClientService;\nimport com.android.bluetooth.sap.SapService;\nimport com.android.bluetooth.sdp.SdpManager;\nimport com.android.bluetooth.telephony.BluetoothInCallService;\nimport com.android.bluetooth.vc.VolumeControlService;\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.modules.utils.BackgroundThread;\nimport com.android.modules.utils.BytesMatcher;\nimport com.android.modules.utils.SynchronousResultReceiver;\n\nimport com.google.protobuf.InvalidProtocolBufferException;\n\nimport libcore.util.SneakyThrow;\n\nimport java.io.FileDescriptor;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.time.Duration;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.Executor;\nimport java.util.function.Predicate;\nimport java.util.regex.Pattern;\n\npublic class AdapterService extends Service {\n    private static final String TAG = \"BluetoothAdapterService\";\n    private static final boolean DBG = true;\n    private static final boolean VERBOSE = false;\n    private static final int MIN_ADVT_INSTANCES_FOR_MA = 5;\n    private static final int MIN_OFFLOADED_FILTERS = 10;\n    private static final int MIN_OFFLOADED_SCAN_STORAGE_BYTES = 1024;\n    private static final Duration PENDING_SOCKET_HANDOFF_TIMEOUT = Duration.ofMinutes(1);\n\n    private final Object mEnergyInfoLock = new Object();\n    private int mStackReportedState;\n    private long mTxTimeTotalMs;\n    private long mRxTimeTotalMs;\n    private long mIdleTimeTotalMs;\n    private long mEnergyUsedTotalVoltAmpSecMicro;\n    private final SparseArray<UidTraffic> mUidTraffic = new SparseArray<>();\n\n    private final ArrayList<String> mStartedProfiles = new ArrayList<>();\n    private final ArrayList<ProfileService> mRegisteredProfiles = new ArrayList<>();\n    private final ArrayList<ProfileService> mRunningProfiles = new ArrayList<>();\n\n    public static final String ACTION_LOAD_ADAPTER_PROPERTIES =\n            \"com.android.bluetooth.btservice.action.LOAD_ADAPTER_PROPERTIES\";\n    public static final String ACTION_SERVICE_STATE_CHANGED =\n            \"com.android.bluetooth.btservice.action.STATE_CHANGED\";\n    public static final String EXTRA_ACTION = \"action\";\n    public static final int PROFILE_CONN_REJECTED = 2;\n\n    private static final String ACTION_ALARM_WAKEUP =\n            \"com.android.bluetooth.btservice.action.ALARM_WAKEUP\";\n\n    static final String BLUETOOTH_BTSNOOP_LOG_MODE_PROPERTY = \"persist.bluetooth.btsnooplogmode\";\n    static final String BLUETOOTH_BTSNOOP_DEFAULT_MODE_PROPERTY =\n            \"persist.bluetooth.btsnoopdefaultmode\";\n    private String mSnoopLogSettingAtEnable = \"empty\";\n    private String mDefaultSnoopLogSettingAtEnable = \"empty\";\n\n    public static final String BLUETOOTH_PRIVILEGED =\n            android.Manifest.permission.BLUETOOTH_PRIVILEGED;\n    static final String BLUETOOTH_PERM = android.Manifest.permission.BLUETOOTH;\n    static final String LOCAL_MAC_ADDRESS_PERM = android.Manifest.permission.LOCAL_MAC_ADDRESS;\n    static final String RECEIVE_MAP_PERM = android.Manifest.permission.RECEIVE_BLUETOOTH_MAP;\n\n    private static final String PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE =\n            \"phonebook_access_permission\";\n    private static final String MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE =\n            \"message_access_permission\";\n    private static final String SIM_ACCESS_PERMISSION_PREFERENCE_FILE = \"sim_access_permission\";\n\n    private static final int CONTROLLER_ENERGY_UPDATE_TIMEOUT_MILLIS = 30;\n\n    public static final String ACTIVITY_ATTRIBUTION_NO_ACTIVE_DEVICE_ADDRESS =\n            \"no_active_device_address\";\n\n    // Report ID definition\n    public enum BqrQualityReportId {\n        QUALITY_REPORT_ID_MONITOR_MODE(0x01),\n        QUALITY_REPORT_ID_APPROACH_LSTO(0x02),\n        QUALITY_REPORT_ID_A2DP_AUDIO_CHOPPY(0x03),\n        QUALITY_REPORT_ID_SCO_VOICE_CHOPPY(0x04),\n        QUALITY_REPORT_ID_ROOT_INFLAMMATION(0x05),\n        QUALITY_REPORT_ID_LMP_LL_MESSAGE_TRACE(0x11),\n        QUALITY_REPORT_ID_BT_SCHEDULING_TRACE(0x12),\n        QUALITY_REPORT_ID_CONTROLLER_DBG_INFO(0x13);\n\n        private final int value;\n        private BqrQualityReportId(int value) {\n            this.value = value;\n        }\n        public int getValue() {\n            return value;\n        }\n    };\n\n    private final ArrayList<DiscoveringPackage> mDiscoveringPackages = new ArrayList<>();\n\n    static {\n        classInitNative();\n    }\n\n    private static AdapterService sAdapterService;\n\n    public static synchronized AdapterService getAdapterService() {\n        return sAdapterService;\n    }\n\n    private static synchronized void setAdapterService(AdapterService instance) {\n        Log.d(TAG, \"setAdapterService() - trying to set service to \" + instance);\n        if (instance == null) {\n            return;\n        }\n        sAdapterService = instance;\n    }\n\n    private static synchronized void clearAdapterService(AdapterService current) {\n        if (sAdapterService == current) {\n            sAdapterService = null;\n        }\n    }\n\n    private BluetoothAdapter mAdapter;\n    private AdapterProperties mAdapterProperties;\n    private AdapterState mAdapterStateMachine;\n    private BondStateMachine mBondStateMachine;\n    private JniCallbacks mJniCallbacks;\n    private RemoteDevices mRemoteDevices;\n\n    /* TODO: Consider to remove the search API from this class, if changed to use call-back */\n    private SdpManager mSdpManager = null;\n\n    private boolean mNativeAvailable;\n    private boolean mCleaningUp;\n    private final HashMap<BluetoothDevice, ArrayList<IBluetoothMetadataListener>>\n            mMetadataListeners = new HashMap<>();\n    private final HashMap<String, Integer> mProfileServicesState = new HashMap<String, Integer>();\n    private Set<IBluetoothConnectionCallback> mBluetoothConnectionCallbacks = new HashSet<>();\n    //Only BluetoothManagerService should be registered\n    private RemoteCallbackList<IBluetoothCallback> mCallbacks;\n    private int mCurrentRequestId;\n    private boolean mQuietmode = false;\n    private HashMap<String, CallerInfo> mBondAttemptCallerInfo = new HashMap<>();\n\n    private final Map<UUID, RfcommListenerData> mBluetoothServerSockets = new ConcurrentHashMap<>();\n    private final Executor mSocketServersExecutor = r -> new Thread(r).start();\n\n    private AlarmManager mAlarmManager;\n    private PendingIntent mPendingAlarm;\n    private BatteryStatsManager mBatteryStatsManager;\n    private PowerManager mPowerManager;\n    private PowerManager.WakeLock mWakeLock;\n    private String mWakeLockName;\n    private UserManager mUserManager;\n    private CompanionDeviceManager mCompanionDeviceManager;\n\n    private PhonePolicy mPhonePolicy;\n    private ActiveDeviceManager mActiveDeviceManager;\n    private DatabaseManager mDatabaseManager;\n    private SilenceDeviceManager mSilenceDeviceManager;\n    private AppOpsManager mAppOps;\n\n    private BluetoothSocketManagerBinder mBluetoothSocketManagerBinder;\n\n    private BluetoothKeystoreService mBluetoothKeystoreService;\n    private A2dpService mA2dpService;\n    private A2dpSinkService mA2dpSinkService;\n    private ActivityAttributionService mActivityAttributionService;\n    private HeadsetService mHeadsetService;\n    private HeadsetClientService mHeadsetClientService;\n    private BluetoothMapService mMapService;\n    private MapClientService mMapClientService;\n    private HidDeviceService mHidDeviceService;\n    private HidHostService mHidHostService;\n    private PanService mPanService;\n    private BluetoothPbapService mPbapService;\n    private PbapClientService mPbapClientService;\n    private HearingAidService mHearingAidService;\n    private HapClientService mHapClientService;\n    private SapService mSapService;\n    private VolumeControlService mVolumeControlService;\n    private CsipSetCoordinatorService mCsipSetCoordinatorService;\n    private LeAudioService mLeAudioService;\n    private BassClientService mBassClientService;\n    private BatteryService mBatteryService;\n\n    private volatile boolean mTestModeEnabled = false;\n\n    private MetricsLogger mMetricsLogger;\n\n    /**\n     * Register a {@link ProfileService} with AdapterService.\n     *\n     * @param profile the service being added.\n     */\n    public void addProfile(ProfileService profile) {\n        mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_REGISTERED, profile).sendToTarget();\n    }\n\n    /**\n     * Unregister a ProfileService with AdapterService.\n     *\n     * @param profile the service being removed.\n     */\n    public void removeProfile(ProfileService profile) {\n        mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_UNREGISTERED, profile).sendToTarget();\n    }\n\n    /**\n     * Notify AdapterService that a ProfileService has started or stopped.\n     *\n     * @param profile the service being removed.\n     * @param state {@link BluetoothAdapter#STATE_ON} or {@link BluetoothAdapter#STATE_OFF}\n     */\n    public void onProfileServiceStateChanged(ProfileService profile, int state) {\n        if (state != BluetoothAdapter.STATE_ON && state != BluetoothAdapter.STATE_OFF) {\n            throw new IllegalArgumentException(BluetoothAdapter.nameForState(state));\n        }\n        Message m = mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_STATE_CHANGED);\n        m.obj = profile;\n        m.arg1 = state;\n        mHandler.sendMessage(m);\n    }\n\n    /**\n     * Confirm whether the ProfileService is started expectedly.\n     *\n     * @param serviceSampleName the service simple name.\n     * @return true if the service is started expectedly, false otherwise.\n     */\n    public boolean isStartedProfile(String serviceSampleName) {\n        return mStartedProfiles.contains(serviceSampleName);\n    }\n\n    private static final int MESSAGE_PROFILE_SERVICE_STATE_CHANGED = 1;\n    private static final int MESSAGE_PROFILE_SERVICE_REGISTERED = 2;\n    private static final int MESSAGE_PROFILE_SERVICE_UNREGISTERED = 3;\n\n    class AdapterServiceHandler extends Handler {\n        @Override\n        public void handleMessage(Message msg) {\n            verboseLog(\"handleMessage() - Message: \" + msg.what);\n\n            switch (msg.what) {\n                case MESSAGE_PROFILE_SERVICE_STATE_CHANGED:\n                    verboseLog(\"handleMessage() - MESSAGE_PROFILE_SERVICE_STATE_CHANGED\");\n                    processProfileServiceStateChanged((ProfileService) msg.obj, msg.arg1);\n                    break;\n                case MESSAGE_PROFILE_SERVICE_REGISTERED:\n                    verboseLog(\"handleMessage() - MESSAGE_PROFILE_SERVICE_REGISTERED\");\n                    registerProfileService((ProfileService) msg.obj);\n                    break;\n                case MESSAGE_PROFILE_SERVICE_UNREGISTERED:\n                    verboseLog(\"handleMessage() - MESSAGE_PROFILE_SERVICE_UNREGISTERED\");\n                    unregisterProfileService((ProfileService) msg.obj);\n                    break;\n            }\n        }\n\n        private void registerProfileService(ProfileService profile) {\n            if (mRegisteredProfiles.contains(profile)) {\n                Log.e(TAG, profile.getName() + \" already registered.\");\n                return;\n            }\n            mRegisteredProfiles.add(profile);\n        }\n\n        private void unregisterProfileService(ProfileService profile) {\n            if (!mRegisteredProfiles.contains(profile)) {\n                Log.e(TAG, profile.getName() + \" not registered (UNREGISTER).\");\n                return;\n            }\n            mRegisteredProfiles.remove(profile);\n        }\n\n        private void processProfileServiceStateChanged(ProfileService profile, int state) {\n            switch (state) {\n                case BluetoothAdapter.STATE_ON:\n                    if (!mRegisteredProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" not registered (STATE_ON).\");\n                        return;\n                    }\n                    if (mRunningProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" already running.\");\n                        return;\n                    }\n                    mRunningProfiles.add(profile);\n                    // TODO(b/228875190): GATT is assumed supported. GATT starting triggers hardware\n                    // initializtion. Configuring a device without GATT causes start up failures.\n                    if (GattService.class.getSimpleName().equals(profile.getName())) {\n                        enableNative();\n                    } else if (mRegisteredProfiles.size() == Config.getSupportedProfiles().length\n                            && mRegisteredProfiles.size() == mRunningProfiles.size()) {\n                        mAdapterProperties.onBluetoothReady();\n                        updateUuids();\n                        setBluetoothClassFromConfig();\n                        initProfileServices();\n                        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_LOCAL_IO_CAPS);\n                        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_LOCAL_IO_CAPS_BLE);\n                        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_DYNAMIC_AUDIO_BUFFER);\n                        mAdapterStateMachine.sendMessage(AdapterState.BREDR_STARTED);\n                    }\n                    break;\n                case BluetoothAdapter.STATE_OFF:\n                    if (!mRegisteredProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" not registered (STATE_OFF).\");\n                        return;\n                    }\n                    if (!mRunningProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" not running.\");\n                        return;\n                    }\n                    mRunningProfiles.remove(profile);\n                    // TODO(b/228875190): GATT is assumed supported. GATT is expected to be the only\n                    // profile available in the \"BLE ON\" state. If only GATT is left, send\n                    // BREDR_STOPPED. If GATT is stopped, deinitialize the hardware.\n                    if ((mRunningProfiles.size() == 1 && (GattService.class.getSimpleName()\n                            .equals(mRunningProfiles.get(0).getName())))) {\n                        mAdapterStateMachine.sendMessage(AdapterState.BREDR_STOPPED);\n                    } else if (mRunningProfiles.size() == 0) {\n                        disableNative();\n                    }\n                    break;\n                default:\n                    Log.e(TAG, \"Unhandled profile state: \" + state);\n            }\n        }\n    }\n\n    private final AdapterServiceHandler mHandler = new AdapterServiceHandler();\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        initMetricsLogger();\n        debugLog(\"onCreate()\");\n        mDeviceConfigListener.start();\n        mRemoteDevices = new RemoteDevices(this, Looper.getMainLooper());\n        mRemoteDevices.init();\n        clearDiscoveringPackages();\n        mBinder = new AdapterServiceBinder(this);\n        mAdapter = BluetoothAdapter.getDefaultAdapter();\n        mAdapterProperties = new AdapterProperties(this);\n        mAdapterStateMachine = AdapterState.make(this);\n        mJniCallbacks = new JniCallbacks(this, mAdapterProperties);\n        mBluetoothKeystoreService = new BluetoothKeystoreService(isCommonCriteriaMode());\n        mBluetoothKeystoreService.start();\n        int configCompareResult = mBluetoothKeystoreService.getCompareResult();\n\n        // Start tracking Binder latency for the bluetooth process.\n        BluetoothFrameworkInitializer.initializeBinderCallsStats(getApplicationContext());\n\n        // Android TV doesn't show consent dialogs for just works and encryption only le pairing\n        boolean isAtvDevice = getApplicationContext().getPackageManager().hasSystemFeature(\n                PackageManager.FEATURE_LEANBACK_ONLY);\n        mUserManager = getSystemService(UserManager.class);\n        initNative(mUserManager.isGuestUser(), isCommonCriteriaMode(), configCompareResult,\n                getInitFlags(), isAtvDevice, getApplicationInfo().dataDir);\n        mNativeAvailable = true;\n        mCallbacks = new RemoteCallbackList<IBluetoothCallback>();\n        mAppOps = getSystemService(AppOpsManager.class);\n        //Load the name and address\n        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_BDADDR);\n        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_BDNAME);\n        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_CLASS_OF_DEVICE);\n        mAlarmManager = getSystemService(AlarmManager.class);\n        mPowerManager = getSystemService(PowerManager.class);\n        mBatteryStatsManager = getSystemService(BatteryStatsManager.class);\n        mCompanionDeviceManager = getSystemService(CompanionDeviceManager.class);\n\n        mBluetoothKeystoreService.initJni();\n\n        mSdpManager = SdpManager.init(this);\n        registerReceiver(mAlarmBroadcastReceiver, new IntentFilter(ACTION_ALARM_WAKEUP));\n\n        mDatabaseManager = new DatabaseManager(this);\n        mDatabaseManager.start(MetadataDatabase.createDatabase(this));\n\n        boolean isAutomotiveDevice = getApplicationContext().getPackageManager().hasSystemFeature(\n                PackageManager.FEATURE_AUTOMOTIVE);\n\n        /*\n         * Phone policy is specific to phone implementations and hence if a device wants to exclude\n         * it out then it can be disabled by using the flag below. Phone policy is never used on\n         * Android Automotive OS builds, in favor of a policy currently located in\n         * CarBluetoothService.\n         */\n        if (!isAutomotiveDevice && getResources().getBoolean(R.bool.enable_phone_policy)) {\n            Log.i(TAG, \"Phone policy enabled\");\n            mPhonePolicy = new PhonePolicy(this, new ServiceFactory());\n            mPhonePolicy.start();\n        } else {\n            Log.i(TAG, \"Phone policy disabled\");\n        }\n\n        mActiveDeviceManager = new ActiveDeviceManager(this, new ServiceFactory());\n        mActiveDeviceManager.start();\n\n        mSilenceDeviceManager = new SilenceDeviceManager(this, new ServiceFactory(),\n                Looper.getMainLooper());\n        mSilenceDeviceManager.start();\n\n        mBluetoothSocketManagerBinder = new BluetoothSocketManagerBinder(this);\n\n        mActivityAttributionService = new ActivityAttributionService();\n        mActivityAttributionService.start();\n\n        setAdapterService(this);\n\n        invalidateBluetoothCaches();\n\n        // First call to getSharedPreferences will result in a file read into\n        // memory cache. Call it here asynchronously to avoid potential ANR\n        // in the future\n        new AsyncTask<Void, Void, Void>() {\n            @Override\n            protected Void doInBackground(Void... params) {\n                getSharedPreferences(PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE,\n                        Context.MODE_PRIVATE);\n                getSharedPreferences(MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE,\n                        Context.MODE_PRIVATE);\n                getSharedPreferences(SIM_ACCESS_PERMISSION_PREFERENCE_FILE, Context.MODE_PRIVATE);\n                return null;\n            }\n        }.execute();\n\n        try {\n            int systemUiUid = getApplicationContext()\n                    .createContextAsUser(UserHandle.SYSTEM, /* flags= */ 0)\n                    .getPackageManager()\n                    .getPackageUid(\"com.android.systemui\", PackageManager.MATCH_SYSTEM_ONLY);\n\n            Utils.setSystemUiUid(systemUiUid);\n        } catch (PackageManager.NameNotFoundException e) {\n            // Some platforms, such as wearables do not have a system ui.\n            Log.w(TAG, \"Unable to resolve SystemUI's UID.\", e);\n        }\n    }\n\n    @Override\n    public IBinder onBind(Intent intent) {\n        debugLog(\"onBind()\");\n        return mBinder;\n    }\n\n    @Override\n    public boolean onUnbind(Intent intent) {\n        debugLog(\"onUnbind() - calling cleanup\");\n        cleanup();\n        return super.onUnbind(intent);\n    }\n\n    @Override\n    public void onDestroy() {\n        debugLog(\"onDestroy()\");\n        if (!isMock()) {\n            // TODO(b/27859763)\n            Log.i(TAG, \"Force exit to cleanup internal state in Bluetooth stack\");\n            System.exit(0);\n        }\n    }\n\n    private boolean initMetricsLogger() {\n        if (mMetricsLogger != null) {\n            return false;\n        }\n        mMetricsLogger = MetricsLogger.getInstance();\n        return mMetricsLogger.init(this);\n    }\n\n    private boolean closeMetricsLogger() {\n        if (mMetricsLogger == null) {\n            return false;\n        }\n        boolean result = mMetricsLogger.close();\n        mMetricsLogger = null;\n        return result;\n    }\n\n    public void setMetricsLogger(MetricsLogger metricsLogger) {\n        mMetricsLogger = metricsLogger;\n    }\n\n    void bringUpBle() {\n        debugLog(\"bleOnProcessStart()\");\n\n        if (getResources().getBoolean(\n                R.bool.config_bluetooth_reload_supported_profiles_when_enabled)) {\n            Config.init(getApplicationContext());\n        }\n\n        // Reset |mRemoteDevices| whenever BLE is turned off then on\n        // This is to replace the fact that |mRemoteDevices| was\n        // reinitialized in previous code.\n        //\n        // TODO(apanicke): The reason is unclear but\n        // I believe it is to clear the variable every time BLE was\n        // turned off then on. The same effect can be achieved by\n        // calling cleanup but this may not be necessary at all\n        // We should figure out why this is needed later\n        mRemoteDevices.reset();\n        mAdapterProperties.init(mRemoteDevices);\n\n        debugLog(\"bleOnProcessStart() - Make Bond State Machine\");\n        mBondStateMachine = BondStateMachine.make(this, mAdapterProperties, mRemoteDevices);\n\n        mJniCallbacks.init(mBondStateMachine, mRemoteDevices);\n\n        mBatteryStatsManager.reportBleScanReset();\n        BluetoothStatsLog.write_non_chained(BluetoothStatsLog.BLE_SCAN_STATE_CHANGED, -1, null,\n                BluetoothStatsLog.BLE_SCAN_STATE_CHANGED__STATE__RESET, false, false, false);\n\n        // TODO(b/228875190): GATT is assumed supported. As a result, we don't respect the\n        // configuration sysprop. Configuring a device without GATT, although rare, will cause stack\n        // start up errors yielding init loops.\n        if (!GattService.isEnabled()) {\n            Log.w(TAG,\n                    \"GATT is configured off but the stack assumes it to be enabled. Start anyway.\");\n        }\n        setProfileServiceState(GattService.class, BluetoothAdapter.STATE_ON);\n    }\n\n    void bringDownBle() {\n        stopGattProfileService();\n    }\n\n    void stateChangeCallback(int status) {\n        if (status == AbstractionLayer.BT_STATE_OFF) {\n            debugLog(\"stateChangeCallback: disableNative() completed\");\n            mAdapterStateMachine.sendMessage(AdapterState.BLE_STOPPED);\n        } else if (status == AbstractionLayer.BT_STATE_ON) {\n            mAdapterStateMachine.sendMessage(AdapterState.BLE_STARTED);\n        } else {\n            Log.e(TAG, \"Incorrect status \" + status + \" in stateChangeCallback\");\n        }\n    }\n\n    /**\n     * Sets the Bluetooth CoD value of the local adapter if there exists a config value for it.\n     */\n    void setBluetoothClassFromConfig() {\n        int bluetoothClassConfig = retrieveBluetoothClassConfig();\n        if (bluetoothClassConfig != 0) {\n            mAdapterProperties.setBluetoothClass(new BluetoothClass(bluetoothClassConfig));\n        }\n    }\n\n    private int retrieveBluetoothClassConfig() {\n        return Settings.Global.getInt(\n                getContentResolver(), Settings.Global.BLUETOOTH_CLASS_OF_DEVICE, 0);\n    }\n\n    void startProfileServices() {\n        debugLog(\"startCoreServices()\");\n        Class[] supportedProfileServices = Config.getSupportedProfiles();\n        // TODO(b/228875190): GATT is assumed supported. If we support no other profiles then just\n        // move on to BREDR_STARTED. Note that configuring GATT to NOT supported will cause adapter\n        // initialization failures\n        if (supportedProfileServices.length == 1 && GattService.class.getSimpleName()\n                .equals(supportedProfileServices[0].getSimpleName())) {\n            mAdapterProperties.onBluetoothReady();\n            updateUuids();\n            setBluetoothClassFromConfig();\n            mAdapterStateMachine.sendMessage(AdapterState.BREDR_STARTED);\n        } else {\n            setAllProfileServiceStates(supportedProfileServices, BluetoothAdapter.STATE_ON);\n        }\n    }\n\n    void stopProfileServices() {\n        // Make sure to stop classic background tasks now\n        cancelDiscoveryNative();\n        mAdapterProperties.setScanMode(AbstractionLayer.BT_SCAN_MODE_NONE);\n\n        Class[] supportedProfileServices = Config.getSupportedProfiles();\n        // TODO(b/228875190): GATT is assumed supported. If we support no profiles then just move on\n        // to BREDR_STOPPED\n        if (supportedProfileServices.length == 1 && (mRunningProfiles.size() == 1\n                && GattService.class.getSimpleName().equals(mRunningProfiles.get(0).getName()))) {\n            debugLog(\"stopProfileServices() - No profiles services to stop or already stopped.\");\n            mAdapterStateMachine.sendMessage(AdapterState.BREDR_STOPPED);\n        } else {\n            setAllProfileServiceStates(supportedProfileServices, BluetoothAdapter.STATE_OFF);\n        }\n    }\n\n    private void stopGattProfileService() {\n        mAdapterProperties.onBleDisable();\n        if (mRunningProfiles.size() == 0) {\n            debugLog(\"stopGattProfileService() - No profiles services to stop.\");\n            mAdapterStateMachine.sendMessage(AdapterState.BLE_STOPPED);\n        }\n        setProfileServiceState(GattService.class, BluetoothAdapter.STATE_OFF);\n    }\n\n    private void invalidateBluetoothGetStateCache() {\n        BluetoothAdapter.invalidateBluetoothGetStateCache();\n    }\n\n    void updateLeAudioProfileServiceState() {\n        HashSet<Class> nonSupportedProfiles = new HashSet<>();\n\n        if (!isLeConnectedIsochronousStreamCentralSupported()) {\n            nonSupportedProfiles.addAll(Config.geLeAudioUnicastProfiles());\n        }\n\n        if (!isLeAudioBroadcastAssistantSupported()) {\n            nonSupportedProfiles.add(BassClientService.class);\n        }\n\n        if (isLeAudioBroadcastSourceSupported()) {\n            Config.addSupportedProfile(BluetoothProfile.LE_AUDIO_BROADCAST);\n        }\n\n        if (!nonSupportedProfiles.isEmpty()) {\n            // Remove non-supported profiles from the supported list\n            // since the controller doesn't support\n            Config.removeProfileFromSupportedList(nonSupportedProfiles);\n\n            // Disable the non-supported profiles service\n            for (Class profileService : nonSupportedProfiles) {\n                if (isStartedProfile(profileService.getSimpleName())) {\n                    setProfileServiceState(profileService, BluetoothAdapter.STATE_OFF);\n                }\n            }\n        }\n    }\n\n    void updateAdapterState(int prevState, int newState) {\n        mAdapterProperties.setState(newState);\n        invalidateBluetoothGetStateCache();\n        if (mCallbacks != null) {\n            int n = mCallbacks.beginBroadcast();\n            debugLog(\"updateAdapterState() - Broadcasting state \" + BluetoothAdapter.nameForState(\n                    newState) + \" to \" + n + \" receivers.\");\n            for (int i = 0; i < n; i++) {\n                try {\n                    mCallbacks.getBroadcastItem(i).onBluetoothStateChange(prevState, newState);\n                } catch (RemoteException e) {\n                    debugLog(\"updateAdapterState() - Callback #\" + i + \" failed (\" + e + \")\");\n                }\n            }\n            mCallbacks.finishBroadcast();\n        }\n\n        // Turn the Adapter all the way off if we are disabling and the snoop log setting changed.\n        if (newState == BluetoothAdapter.STATE_BLE_TURNING_ON) {\n            mSnoopLogSettingAtEnable =\n                    SystemProperties.get(BLUETOOTH_BTSNOOP_LOG_MODE_PROPERTY, \"empty\");\n            mDefaultSnoopLogSettingAtEnable =\n                    Settings.Global.getString(getContentResolver(),\n                            Settings.Global.BLUETOOTH_BTSNOOP_DEFAULT_MODE);\n            BluetoothProperties.snoop_default_mode(\n                    BluetoothProperties.snoop_default_mode_values.DISABLED);\n            for (BluetoothProperties.snoop_default_mode_values value :\n                    BluetoothProperties.snoop_default_mode_values.values()) {\n                if (value.getPropValue().equals(mDefaultSnoopLogSettingAtEnable)) {\n                    BluetoothProperties.snoop_default_mode(value);\n                }\n            }\n        } else if (newState == BluetoothAdapter.STATE_BLE_ON\n                   && prevState != BluetoothAdapter.STATE_OFF) {\n            String snoopLogSetting =\n                    SystemProperties.get(BLUETOOTH_BTSNOOP_LOG_MODE_PROPERTY, \"empty\");\n            String snoopDefaultModeSetting =\n                    Settings.Global.getString(getContentResolver(),\n                            Settings.Global.BLUETOOTH_BTSNOOP_DEFAULT_MODE);\n\n            if (!TextUtils.equals(mSnoopLogSettingAtEnable, snoopLogSetting)\n                    || !TextUtils.equals(mDefaultSnoopLogSettingAtEnable,\n                            snoopDefaultModeSetting)) {\n                mAdapterStateMachine.sendMessage(AdapterState.BLE_TURN_OFF);\n            }\n        }\n    }\n\n    void linkQualityReportCallback(\n            long timestamp,\n            int reportId,\n            int rssi,\n            int snr,\n            int retransmissionCount,\n            int packetsNotReceiveCount,\n            int negativeAcknowledgementCount) {\n        BluetoothInCallService bluetoothInCallService = BluetoothInCallService.getInstance();\n\n        if (reportId == BqrQualityReportId.QUALITY_REPORT_ID_SCO_VOICE_CHOPPY.getValue()) {\n            if (bluetoothInCallService == null) {\n                Log.w(TAG, \"No BluetoothInCallService while trying to send BQR.\"\n                        + \" timestamp: \" + timestamp + \" reportId: \" + reportId\n                        + \" rssi: \" + rssi + \" snr: \" + snr\n                        + \" retransmissionCount: \" + retransmissionCount\n                        + \" packetsNotReceiveCount: \" + packetsNotReceiveCount\n                        + \" negativeAcknowledgementCount: \" + negativeAcknowledgementCount);\n                return;\n            }\n            bluetoothInCallService.sendBluetoothCallQualityReport(\n                    timestamp, rssi, snr, retransmissionCount,\n                    packetsNotReceiveCount, negativeAcknowledgementCount);\n        }\n    }\n\n    void switchBufferSizeCallback(boolean isLowLatencyBufferSize) {\n        List<BluetoothDevice> activeDevices = getActiveDevices(BluetoothProfile.A2DP);\n        if (activeDevices.size() != 1) {\n            errorLog(\n                    \"Cannot switch buffer size. The number of A2DP active devices is \"\n                            + activeDevices.size());\n        }\n\n        // Send intent to fastpair\n        Intent switchBufferSizeIntent = new Intent(BluetoothDevice.ACTION_SWITCH_BUFFER_SIZE);\n        switchBufferSizeIntent.setClassName(\n                getString(com.android.bluetooth.R.string.peripheral_link_package),\n                getString(com.android.bluetooth.R.string.peripheral_link_package)\n                        + getString(com.android.bluetooth.R.string.peripheral_link_service));\n        switchBufferSizeIntent.putExtra(BluetoothDevice.EXTRA_DEVICE, activeDevices.get(0));\n        switchBufferSizeIntent.putExtra(\n                BluetoothDevice.EXTRA_LOW_LATENCY_BUFFER_SIZE, isLowLatencyBufferSize);\n        sendBroadcast(switchBufferSizeIntent);\n    }\n\n    void switchCodecCallback(boolean isLowLatencyBufferSize) {\n        List<BluetoothDevice> activeDevices = getActiveDevices(BluetoothProfile.A2DP);\n        if (activeDevices.size() != 1) {\n            errorLog(\n                    \"Cannot switch buffer size. The number of A2DP active devices is \"\n                            + activeDevices.size());\n            return;\n        }\n        mA2dpService.switchCodecByBufferSize(activeDevices.get(0), isLowLatencyBufferSize);\n    }\n\n    void cleanup() {\n        debugLog(\"cleanup()\");\n        if (mCleaningUp) {\n            errorLog(\"cleanup() - Service already starting to cleanup, ignoring request...\");\n            return;\n        }\n\n        closeMetricsLogger();\n\n        clearAdapterService(this);\n\n        mCleaningUp = true;\n        invalidateBluetoothCaches();\n\n        unregisterReceiver(mAlarmBroadcastReceiver);\n\n        stopRfcommServerSockets();\n\n        if (mPendingAlarm != null) {\n            mAlarmManager.cancel(mPendingAlarm);\n            mPendingAlarm = null;\n        }\n\n        // This wake lock release may also be called concurrently by\n        // {@link #releaseWakeLock(String lockName)}, so a synchronization is needed here.\n        synchronized (this) {\n            if (mWakeLock != null) {\n                if (mWakeLock.isHeld()) {\n                    mWakeLock.release();\n                }\n                mWakeLock = null;\n            }\n        }\n\n        if (mDatabaseManager != null) {\n            mDatabaseManager.cleanup();\n        }\n\n        if (mAdapterStateMachine != null) {\n            mAdapterStateMachine.doQuit();\n        }\n\n        if (mBondStateMachine != null) {\n            mBondStateMachine.doQuit();\n        }\n\n        if (mRemoteDevices != null) {\n            mRemoteDevices.cleanup();\n        }\n\n        if (mSdpManager != null) {\n            mSdpManager.cleanup();\n            mSdpManager = null;\n        }\n\n        if (mActivityAttributionService != null) {\n            mActivityAttributionService.cleanup();\n        }\n\n        if (mNativeAvailable) {\n            debugLog(\"cleanup() - Cleaning up adapter native\");\n            cleanupNative();\n            mNativeAvailable = false;\n        }\n\n        if (mAdapterProperties != null) {\n            mAdapterProperties.cleanup();\n        }\n\n        if (mJniCallbacks != null) {\n            mJniCallbacks.cleanup();\n        }\n\n        if (mBluetoothKeystoreService != null) {\n            debugLog(\"cleanup(): mBluetoothKeystoreService.cleanup()\");\n            mBluetoothKeystoreService.cleanup();\n        }\n\n        if (mPhonePolicy != null) {\n            mPhonePolicy.cleanup();\n        }\n\n        if (mSilenceDeviceManager != null) {\n            mSilenceDeviceManager.cleanup();\n        }\n\n        if (mActiveDeviceManager != null) {\n            mActiveDeviceManager.cleanup();\n        }\n\n        if (mProfileServicesState != null) {\n            mProfileServicesState.clear();\n        }\n\n        if (mBluetoothSocketManagerBinder != null) {\n            mBluetoothSocketManagerBinder.cleanUp();\n            mBluetoothSocketManagerBinder = null;\n        }\n\n        if (mBinder != null) {\n            mBinder.cleanup();\n            mBinder = null;  //Do not remove. Otherwise Binder leak!\n        }\n\n        if (mCallbacks != null) {\n            mCallbacks.kill();\n        }\n    }\n\n    private void invalidateBluetoothCaches() {\n        BluetoothAdapter.invalidateGetProfileConnectionStateCache();\n        BluetoothAdapter.invalidateIsOffloadedFilteringSupportedCache();\n        BluetoothDevice.invalidateBluetoothGetBondStateCache();\n        BluetoothAdapter.invalidateBluetoothGetStateCache();\n        BluetoothAdapter.invalidateGetAdapterConnectionStateCache();\n        BluetoothMap.invalidateBluetoothGetConnectionStateCache();\n        BluetoothSap.invalidateBluetoothGetConnectionStateCache();\n    }\n\n    private void setProfileServiceState(Class service, int state) {\n        if (state == BluetoothAdapter.STATE_ON) {\n            mStartedProfiles.add(service.getSimpleName());\n        } else if (state == BluetoothAdapter.STATE_OFF) {\n            mStartedProfiles.remove(service.getSimpleName());\n        }\n        Intent intent = new Intent(this, service);\n        intent.putExtra(EXTRA_ACTION, ACTION_SERVICE_STATE_CHANGED);\n        intent.putExtra(BluetoothAdapter.EXTRA_STATE, state);\n        startService(intent);\n    }\n\n    private void setAllProfileServiceStates(Class[] services, int state) {\n        for (Class service : services) {\n            // TODO(b/228875190): GATT is assumed supported and treated differently as part of the\n            // \"BLE ON\" state, despite GATT not being BLE specific.\n            if (GattService.class.getSimpleName().equals(service.getSimpleName())) {\n                continue;\n            }\n            setProfileServiceState(service, state);\n        }\n    }\n\n    /**\n     * Verifies whether the profile is supported by the local bluetooth adapter by checking a\n     * bitmask of its supported profiles\n     *\n     * @param remoteDeviceUuids is an array of all supported profiles by the remote device\n     * @param localDeviceUuids  is an array of all supported profiles by the local device\n     * @param profile           is the profile we are checking for support\n     * @param device            is the remote device we wish to connect to\n     * @return true if the profile is supported by both the local and remote device, false otherwise\n     */\n    @RequiresPermission(android.Manifest.permission.BLUETOOTH_PRIVILEGED)\n    private boolean isSupported(ParcelUuid[] localDeviceUuids, ParcelUuid[] remoteDeviceUuids,\n            int profile, BluetoothDevice device) {\n        if (remoteDeviceUuids == null || remoteDeviceUuids.length == 0) {\n            Log.e(TAG, \"isSupported: Remote Device Uuids Empty\");\n        }\n\n        if (profile == BluetoothProfile.HEADSET) {\n            return (Utils.arrayContains(localDeviceUuids, BluetoothUuid.HSP_AG)\n                    && Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HSP))\n                    || (Utils.arrayContains(localDeviceUuids, BluetoothUuid.HFP_AG)\n                    && Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HFP));\n        }\n        if (profile == BluetoothProfile.HEADSET_CLIENT) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HFP_AG)\n                    && Utils.arrayContains(localDeviceUuids, BluetoothUuid.HFP);\n        }\n        if (profile == BluetoothProfile.A2DP) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.ADV_AUDIO_DIST)\n                    || Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.A2DP_SINK);\n        }\n        if (profile == BluetoothProfile.A2DP_SINK) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.ADV_AUDIO_DIST)\n                    || Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.A2DP_SOURCE);\n        }\n        if (profile == BluetoothProfile.OPP) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.OBEX_OBJECT_PUSH);\n        }\n        if (profile == BluetoothProfile.HID_HOST) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HID)\n                    || Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HOGP);\n        }\n        if (profile == BluetoothProfile.HID_DEVICE) {\n            return mHidDeviceService.getConnectionState(device)\n                    == BluetoothProfile.STATE_DISCONNECTED;\n        }\n        if (profile == BluetoothProfile.PAN) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.NAP);\n        }\n        if (profile == BluetoothProfile.MAP) {\n            return mMapService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED;\n        }\n        if (profile == BluetoothProfile.PBAP) {\n            return mPbapService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED;\n        }\n        if (profile == BluetoothProfile.MAP_CLIENT) {\n            return true;\n        }\n        if (profile == BluetoothProfile.PBAP_CLIENT) {\n            return Utils.arrayContains(localDeviceUuids, BluetoothUuid.PBAP_PCE)\n                    && Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.PBAP_PSE);\n        }\n        if (profile == BluetoothProfile.HEARING_AID) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HEARING_AID);\n        }\n        if (profile == BluetoothProfile.SAP) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.SAP);\n        }\n        if (profile == BluetoothProfile.VOLUME_CONTROL) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.VOLUME_CONTROL);\n        }\n        if (profile == BluetoothProfile.CSIP_SET_COORDINATOR) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.COORDINATED_SET);\n        }\n        if (profile == BluetoothProfile.LE_AUDIO) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.LE_AUDIO);\n        }\n        if (profile == BluetoothProfile.HAP_CLIENT) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HAS);\n        }\n        if (profile == BluetoothProfile.LE_AUDIO_BROADCAST_ASSISTANT) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.BASS);\n        }\n        if (profile == BluetoothProfile.BATTERY) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.BATTERY);\n        }\n\n        Log.e(TAG, \"isSupported: Unexpected profile passed in to function: \" + profile);\n        return false;\n    }\n\n    /**\n     * Checks if any profile is enabled for the given device\n     *\n     * @param device is the device for which we are checking if any profiles are enabled\n     * @return true if any profile is enabled, false otherwise\n     */\n    @RequiresPermission(android.Manifest.permission.BLUETOOTH_PRIVILEGED)\n    boolean isAnyProfileEnabled(BluetoothDevice device) {\n        if (mA2dpService != null && mA2dpService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mA2dpSinkService != null && mA2dpSinkService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mHeadsetService != null && mHeadsetService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mHeadsetClientService != null && mHeadsetClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mMapClientService != null && mMapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mHidHostService != null && mHidHostService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mPanService != null && mPanService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mPbapClientService != null && mPbapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mHearingAidService != null && mHearingAidService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mHapClientService != null && mHapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mVolumeControlService != null && mVolumeControlService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mCsipSetCoordinatorService != null\n                && mCsipSetCoordinatorService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mLeAudioService != null && mLeAudioService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mBassClientService != null && mBassClientService.getConnectionPolicy(device)\n                 > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mBatteryService != null && mBatteryService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Connects only available profiles\n     * (those with {@link BluetoothProfile#CONNECTION_POLICY_ALLOWED})\n     *\n     * @param device is the device with which we are connecting the profiles\n     * @return {@link BluetoothStatusCodes#SUCCESS}\n     */\n    @RequiresPermission(allOf = {\n            android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n            android.Manifest.permission.MODIFY_PHONE_STATE,\n    })\n    private int connectEnabledProfiles(BluetoothDevice device) {\n        ParcelUuid[] remoteDeviceUuids = getRemoteUuids(device);\n        ParcelUuid[] localDeviceUuids = mAdapterProperties.getUuids();\n\n        if (mA2dpService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.A2DP, device) && mA2dpService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting A2dp\");\n            mA2dpService.connect(device);\n        }\n        if (mA2dpSinkService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.A2DP_SINK, device) && mA2dpSinkService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting A2dp Sink\");\n            mA2dpSinkService.connect(device);\n        }\n        if (mHeadsetService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEADSET, device) && mHeadsetService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Headset Profile\");\n            mHeadsetService.connect(device);\n        }\n        if (mHeadsetClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEADSET_CLIENT, device)\n                && mHeadsetClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting HFP\");\n            mHeadsetClientService.connect(device);\n        }\n        if (mMapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.MAP_CLIENT, device)\n                && mMapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting MAP\");\n            mMapClientService.connect(device);\n        }\n        if (mHidHostService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HID_HOST, device) && mHidHostService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Hid Host Profile\");\n            mHidHostService.connect(device);\n        }\n        if (mPanService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.PAN, device) && mPanService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Pan Profile\");\n            mPanService.connect(device);\n        }\n        if (mPbapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.PBAP_CLIENT, device)\n                && mPbapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Pbap\");\n            mPbapClientService.connect(device);\n        }\n        if (mHearingAidService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEARING_AID, device)\n                && mHearingAidService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Hearing Aid Profile\");\n            mHearingAidService.connect(device);\n        }\n        if (mHapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HAP_CLIENT, device)\n                && mHapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting HAS Profile\");\n            mHapClientService.connect(device);\n        }\n        if (mVolumeControlService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.VOLUME_CONTROL, device)\n                && mVolumeControlService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Volume Control Profile\");\n            mVolumeControlService.connect(device);\n        }\n        if (mCsipSetCoordinatorService != null\n                && isSupported(localDeviceUuids, remoteDeviceUuids,\n                        BluetoothProfile.CSIP_SET_COORDINATOR, device)\n                && mCsipSetCoordinatorService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Coordinated Set Profile\");\n            mCsipSetCoordinatorService.connect(device);\n        }\n        if (mLeAudioService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.LE_AUDIO, device)\n                && mLeAudioService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting LeAudio profile (BAP)\");\n            mLeAudioService.connect(device);\n        }\n        if (mBassClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.LE_AUDIO_BROADCAST_ASSISTANT, device)\n                && mBassClientService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting LE Broadcast Assistant Profile\");\n            mBassClientService.connect(device);\n        }\n        if (mBatteryService != null\n                && isSupported(\n                        localDeviceUuids, remoteDeviceUuids, BluetoothProfile.BATTERY, device)\n                && mBatteryService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Battery Service\");\n            mBatteryService.connect(device);\n        }\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    /**\n     * Verifies that all bluetooth profile services are running\n     *\n     * @return true if all bluetooth profile services running, false otherwise\n     */\n    private boolean profileServicesRunning() {\n        if (mRegisteredProfiles.size() == Config.getSupportedProfiles().length\n                && mRegisteredProfiles.size() == mRunningProfiles.size()) {\n            return true;\n        }\n\n        Log.e(TAG, \"profileServicesRunning: One or more supported services not running\");\n        return false;\n    }\n\n    /**\n     * Initializes all the profile services fields\n     */\n    private void initProfileServices() {\n        Log.i(TAG, \"initProfileServices: Initializing all bluetooth profile services\");\n        mA2dpService = A2dpService.getA2dpService();\n        mA2dpSinkService = A2dpSinkService.getA2dpSinkService();\n        mHeadsetService = HeadsetService.getHeadsetService();\n        mHeadsetClientService = HeadsetClientService.getHeadsetClientService();\n        mMapService = BluetoothMapService.getBluetoothMapService();\n        mMapClientService = MapClientService.getMapClientService();\n        mHidDeviceService = HidDeviceService.getHidDeviceService();\n        mHidHostService = HidHostService.getHidHostService();\n        mPanService = PanService.getPanService();\n        mPbapService = BluetoothPbapService.getBluetoothPbapService();\n        mPbapClientService = PbapClientService.getPbapClientService();\n        mHearingAidService = HearingAidService.getHearingAidService();\n        mHapClientService = HapClientService.getHapClientService();\n        mSapService = SapService.getSapService();\n        mVolumeControlService = VolumeControlService.getVolumeControlService();\n        mCsipSetCoordinatorService = CsipSetCoordinatorService.getCsipSetCoordinatorService();\n        mLeAudioService = LeAudioService.getLeAudioService();\n        mBassClientService = BassClientService.getBassClientService();\n        mBatteryService = BatteryService.getBatteryService();\n    }\n\n    @BluetoothAdapter.RfcommListenerResult\n    private int startRfcommListener(\n            String name,\n            ParcelUuid uuid,\n            PendingIntent pendingIntent,\n            AttributionSource attributionSource) {\n        if (mBluetoothServerSockets.containsKey(uuid.getUuid())) {\n            Log.d(TAG, String.format(\n                        \"Cannot start RFCOMM listener: UUID %s already in use.\", uuid.getUuid()));\n            return BluetoothStatusCodes.RFCOMM_LISTENER_START_FAILED_UUID_IN_USE;\n        }\n\n        try {\n            startRfcommListenerInternal(name, uuid.getUuid(), pendingIntent, attributionSource);\n        } catch (IOException e) {\n            return BluetoothStatusCodes.RFCOMM_LISTENER_FAILED_TO_CREATE_SERVER_SOCKET;\n        }\n\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    @BluetoothAdapter.RfcommListenerResult\n    private int stopRfcommListener(ParcelUuid uuid, AttributionSource attributionSource) {\n        RfcommListenerData listenerData = mBluetoothServerSockets.get(uuid.getUuid());\n\n        if (listenerData == null) {\n            Log.d(TAG, String.format(\n                        \"Cannot stop RFCOMM listener: UUID %s is not registered.\", uuid.getUuid()));\n            return BluetoothStatusCodes.RFCOMM_LISTENER_OPERATION_FAILED_NO_MATCHING_SERVICE_RECORD;\n        }\n\n        if (attributionSource.getUid() != listenerData.mAttributionSource.getUid()) {\n            return BluetoothStatusCodes.RFCOMM_LISTENER_OPERATION_FAILED_DIFFERENT_APP;\n        }\n\n        // Remove the entry so that it does not try and restart the server socket.\n        mBluetoothServerSockets.remove(uuid.getUuid());\n\n        return listenerData.closeServerAndPendingSockets(mHandler);\n    }\n\n    private IncomingRfcommSocketInfo retrievePendingSocketForServiceRecord(\n            ParcelUuid uuid, AttributionSource attributionSource) {\n        IncomingRfcommSocketInfo socketInfo = new IncomingRfcommSocketInfo();\n\n        RfcommListenerData listenerData = mBluetoothServerSockets.get(uuid.getUuid());\n\n        if (listenerData == null) {\n            socketInfo.status =\n                    BluetoothStatusCodes\n                            .RFCOMM_LISTENER_OPERATION_FAILED_NO_MATCHING_SERVICE_RECORD;\n            return socketInfo;\n        }\n\n        if (attributionSource.getUid() != listenerData.mAttributionSource.getUid()) {\n            socketInfo.status = BluetoothStatusCodes.RFCOMM_LISTENER_OPERATION_FAILED_DIFFERENT_APP;\n            return socketInfo;\n        }\n\n        BluetoothSocket socket = listenerData.mPendingSockets.poll();\n\n        if (socket == null) {\n            socketInfo.status = BluetoothStatusCodes.RFCOMM_LISTENER_NO_SOCKET_AVAILABLE;\n            return socketInfo;\n        }\n\n        mHandler.removeCallbacksAndMessages(socket);\n\n        socketInfo.bluetoothDevice = socket.getRemoteDevice();\n        socketInfo.pfd = socket.getParcelFileDescriptor();\n        socketInfo.status = BluetoothStatusCodes.SUCCESS;\n\n        return socketInfo;\n    }\n\n    private void handleIncomingRfcommConnections(UUID uuid) {\n        RfcommListenerData listenerData = mBluetoothServerSockets.get(uuid);\n        for (;;) {\n            BluetoothSocket socket;\n            try {\n                socket = listenerData.mServerSocket.accept();\n            } catch (IOException e) {\n                if (mBluetoothServerSockets.containsKey(uuid)) {\n                    // The uuid still being in the map indicates that the accept failure is\n                    // unexpected. Try and restart the listener.\n                    Log.e(TAG, \"Failed to accept socket on \" + listenerData.mServerSocket, e);\n                    restartRfcommListener(listenerData, uuid);\n                }\n                return;\n            }\n\n            listenerData.mPendingSockets.add(socket);\n            try {\n                listenerData.mPendingIntent.send();\n            } catch (PendingIntent.CanceledException e) {\n                Log.e(TAG, \"PendingIntent for RFCOMM socket notifications cancelled.\", e);\n                // The pending intent was cancelled, close the server as there is no longer any way\n                // to notify the app that registered the listener.\n                listenerData.closeServerAndPendingSockets(mHandler);\n                mBluetoothServerSockets.remove(uuid);\n                return;\n            }\n            mHandler.postDelayed(\n                    () -> pendingSocketTimeoutRunnable(listenerData, socket),\n                    socket,\n                    PENDING_SOCKET_HANDOFF_TIMEOUT.toMillis());\n        }\n    }\n\n    // Tries to restart the rfcomm listener for the given UUID\n    private void restartRfcommListener(RfcommListenerData listenerData, UUID uuid) {\n        listenerData.closeServerAndPendingSockets(mHandler);\n        try {\n            startRfcommListenerInternal(\n                    listenerData.mName,\n                    uuid,\n                    listenerData.mPendingIntent,\n                    listenerData.mAttributionSource);\n        } catch (IOException e) {\n            Log.e(TAG, \"Failed to recreate rfcomm server socket\", e);\n\n            mBluetoothServerSockets.remove(uuid);\n        }\n    }\n\n    private void pendingSocketTimeoutRunnable(\n            RfcommListenerData listenerData, BluetoothSocket socket) {\n        boolean socketFound = listenerData.mPendingSockets.remove(socket);\n        if (socketFound) {\n            try {\n                socket.close();\n            } catch (IOException e) {\n                Log.e(TAG, \"Failed to close bt socket\", e);\n                // We don't care if closing the socket failed, just continue on.\n            }\n        }\n    }\n\n    private void startRfcommListenerInternal(\n            String name, UUID uuid, PendingIntent intent, AttributionSource attributionSource)\n            throws IOException {\n        BluetoothServerSocket bluetoothServerSocket =\n                mAdapter.listenUsingRfcommWithServiceRecord(name, uuid);\n\n        RfcommListenerData listenerData =\n                new RfcommListenerData(bluetoothServerSocket, name, intent, attributionSource);\n\n        mBluetoothServerSockets.put(uuid, listenerData);\n\n        mSocketServersExecutor.execute(() -> handleIncomingRfcommConnections(uuid));\n    }\n\n    private void stopRfcommServerSockets() {\n        Iterator<Map.Entry<UUID, RfcommListenerData>> socketsIterator =\n                mBluetoothServerSockets.entrySet().iterator();\n        while (socketsIterator.hasNext()) {\n            socketsIterator.next().getValue().closeServerAndPendingSockets(mHandler);\n            socketsIterator.remove();\n        }\n    }\n\n    private static class RfcommListenerData {\n        final BluetoothServerSocket mServerSocket;\n        // Service record name\n        final String mName;\n        // The Intent which contains the Service info to which the incoming socket connections are\n        // handed off to.\n        final PendingIntent mPendingIntent;\n        // AttributionSource for the requester of the RFCOMM listener\n        final AttributionSource mAttributionSource;\n        // Contains the connected sockets which are pending transfer to the app which requested the\n        // listener.\n        final ConcurrentLinkedQueue<BluetoothSocket> mPendingSockets =\n                new ConcurrentLinkedQueue<>();\n\n        RfcommListenerData(\n                BluetoothServerSocket serverSocket,\n                String name,\n                PendingIntent pendingIntent,\n                AttributionSource attributionSource) {\n            mServerSocket = serverSocket;\n            mName = name;\n            mPendingIntent = pendingIntent;\n            mAttributionSource = attributionSource;\n        }\n\n        int closeServerAndPendingSockets(Handler handler) {\n            int result = BluetoothStatusCodes.SUCCESS;\n            try {\n                mServerSocket.close();\n            } catch (IOException e) {\n                Log.e(TAG, \"Failed to call close on rfcomm server socket\", e);\n                result = BluetoothStatusCodes.RFCOMM_LISTENER_FAILED_TO_CLOSE_SERVER_SOCKET;\n            }\n            mPendingSockets.forEach(\n                    pendingSocket -> {\n                        handler.removeCallbacksAndMessages(pendingSocket);\n                        try {\n                            pendingSocket.close();\n                        } catch (IOException e) {\n                            Log.e(TAG, \"Failed to close socket\", e);\n                        }\n                    });\n            mPendingSockets.clear();\n\n            return result;\n        }\n    }\n\n    private boolean isAvailable() {\n        return !mCleaningUp;\n    }\n\n    /**\n     * Handlers for incoming service calls\n     */\n    private AdapterServiceBinder mBinder;\n\n    /**\n     * The Binder implementation must be declared to be a static class, with\n     * the AdapterService instance passed in the constructor. Furthermore,\n     * when the AdapterService shuts down, the reference to the AdapterService\n     * must be explicitly removed.\n     *\n     * Otherwise, a memory leak can occur from repeated starting/stopping the\n     * service...Please refer to android.os.Binder for further details on\n     * why an inner instance class should be avoided.\n     *\n     */\n    @VisibleForTesting\n    public static class AdapterServiceBinder extends IBluetooth.Stub {\n        private AdapterService mService;\n\n        AdapterServiceBinder(AdapterService svc) {\n            mService = svc;\n            mService.invalidateBluetoothGetStateCache();\n            BluetoothAdapter.getDefaultAdapter().disableBluetoothGetStateCache();\n        }\n\n        public void cleanup() {\n            mService = null;\n        }\n\n        public AdapterService getService() {\n            if (mService != null && mService.isAvailable()) {\n                return mService;\n            }\n            return null;\n        }\n\n        @Override\n        public void getState(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getState());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getState() {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothAdapter.STATE_OFF;\n            }\n\n            return service.getState();\n        }\n\n        @Override\n        public void enable(boolean quietMode, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(enable(quietMode, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean enable(boolean quietMode, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"enable\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService enable\")) {\n                return false;\n            }\n\n            return service.enable(quietMode);\n        }\n\n        @Override\n        public void disable(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(disable(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean disable(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"disable\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService disable\")) {\n                return false;\n            }\n\n            return service.disable();\n        }\n\n        @Override\n        public String getAddress() {\n            if (mService == null) {\n                return null;\n            }\n            return getAddressWithAttribution(Utils.getCallingAttributionSource(mService));\n        }\n\n        @Override\n        public void getAddressWithAttribution(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getAddressWithAttribution(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private String getAddressWithAttribution(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getAddress\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getAddress\")) {\n                return null;\n            }\n\n            enforceLocalMacAddressPermission(service);\n\n            return Utils.getAddressStringFromByte(service.mAdapterProperties.getAddress());\n        }\n\n        @Override\n        public void getUuids(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getUuids(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private List<ParcelUuid> getUuids(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getUuids\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getUuids\")) {\n                return new ArrayList<>();\n            }\n\n            ParcelUuid[] parcels = service.mAdapterProperties.getUuids();\n            if (parcels == null) {\n                parcels = new ParcelUuid[0];\n            }\n            return Arrays.asList(parcels);\n        }\n\n        @Override\n        public void getIdentityAddress(String address, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getIdentityAddress(address));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        public String getIdentityAddress(String address) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getIdentityAddress\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, Utils.getCallingAttributionSource(mService),\n                                \"AdapterService getIdentityAddress\")) {\n                return null;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.getIdentityAddress(address);\n        }\n\n        @Override\n        public void getName(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getName(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private String getName(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getName\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getName\")) {\n                return null;\n            }\n\n            return service.getName();\n        }\n\n        @Override\n        public void getNameLengthForAdvertise(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getNameLengthForAdvertise(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getNameLengthForAdvertise(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getNameLengthForAdvertise\")\n                    || !Utils.checkAdvertisePermissionForDataDelivery(\n                            service, attributionSource, TAG)) {\n                return -1;\n            }\n\n            return service.getNameLengthForAdvertise();\n        }\n\n        @Override\n        public void setName(String name, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setName(name, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setName(String name, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"setName\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService setName\")) {\n                return false;\n            }\n\n            return service.mAdapterProperties.setName(name);\n        }\n\n        @Override\n        public void getBluetoothClass(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getBluetoothClass(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private BluetoothClass getBluetoothClass(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getBluetoothClass\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterSource getBluetoothClass\")) {\n                return null;\n            }\n\n            return service.mAdapterProperties.getBluetoothClass();\n        }\n\n        @Override\n        public void setBluetoothClass(BluetoothClass bluetoothClass, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setBluetoothClass(bluetoothClass, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setBluetoothClass(BluetoothClass bluetoothClass, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (!service.mAdapterProperties.setBluetoothClass(bluetoothClass)) {\n              return false;\n            }\n\n            return Settings.Global.putInt(\n                    service.getContentResolver(),\n                    Settings.Global.BLUETOOTH_CLASS_OF_DEVICE,\n                    bluetoothClass.getClassOfDevice());\n        }\n\n        @Override\n        public void getIoCapability(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getIoCapability(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getIoCapability(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getIoCapability\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getIoCapability\")) {\n                return BluetoothAdapter.IO_CAPABILITY_UNKNOWN;\n            }\n\n            return service.mAdapterProperties.getIoCapability();\n        }\n\n        @Override\n        public void setIoCapability(int capability, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setIoCapability(capability, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setIoCapability(int capability, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (!isValidIoCapability(capability)) {\n              return false;\n            }\n\n            return service.mAdapterProperties.setIoCapability(capability);\n        }\n\n        @Override\n        public void getLeIoCapability(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getLeIoCapability(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getLeIoCapability(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getLeIoCapability\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getLeIoCapability\")) {\n                return BluetoothAdapter.IO_CAPABILITY_UNKNOWN;\n            }\n\n            return service.mAdapterProperties.getLeIoCapability();\n        }\n\n        @Override\n        public void setLeIoCapability(int capability, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setLeIoCapability(capability, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setLeIoCapability(int capability, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (!isValidIoCapability(capability)) {\n              return false;\n            }\n\n            return service.mAdapterProperties.setLeIoCapability(capability);\n        }\n\n        @Override\n        public void getScanMode(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getScanMode(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        int getScanMode(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getScanMode\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getScanMode\")) {\n                return BluetoothAdapter.SCAN_MODE_NONE;\n            }\n\n            return service.mAdapterProperties.getScanMode();\n        }\n\n        @Override\n        public void setScanMode(int mode, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setScanMode(mode, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int setScanMode(int mode, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"setScanMode\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService setScanMode\")) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_SCAN_PERMISSION;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mAdapterProperties.setScanMode(convertScanModeToHal(mode))\n                    ? BluetoothStatusCodes.SUCCESS : BluetoothStatusCodes.ERROR_UNKNOWN;\n        }\n\n        @Override\n        public void getDiscoverableTimeout(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getDiscoverableTimeout(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private long getDiscoverableTimeout(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getDiscoverableTimeout\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getDiscoverableTimeout\")) {\n                return -1;\n            }\n\n            return service.mAdapterProperties.getDiscoverableTimeout();\n        }\n\n        @Override\n        public void setDiscoverableTimeout(long timeout, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setDiscoverableTimeout(timeout, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int setDiscoverableTimeout(long timeout, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"setDiscoverableTimeout\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService setDiscoverableTimeout\")) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_SCAN_PERMISSION;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mAdapterProperties.setDiscoverableTimeout((int) timeout)\n                    ? BluetoothStatusCodes.SUCCESS : BluetoothStatusCodes.ERROR_UNKNOWN;\n        }\n\n        @Override\n        public void startDiscovery(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(startDiscovery(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean startDiscovery(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"startDiscovery\")) {\n                return false;\n            }\n\n            if (!Utils.checkScanPermissionForDataDelivery(\n                    service, attributionSource, \"Starting discovery.\")) {\n                return false;\n            }\n\n            return service.startDiscovery(attributionSource);\n        }\n\n        @Override\n        public void cancelDiscovery(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(cancelDiscovery(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean cancelDiscovery(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"cancelDiscovery\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService cancelDiscovery\")) {\n                return false;\n            }\n\n            service.debugLog(\"cancelDiscovery\");\n            return service.cancelDiscoveryNative();\n        }\n\n        @Override\n        public void isDiscovering(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isDiscovering(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isDiscovering(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"isDiscovering\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService isDiscovering\")) {\n                return false;\n            }\n\n            return service.mAdapterProperties.isDiscovering();\n        }\n\n        @Override\n        public void getDiscoveryEndMillis(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getDiscoveryEndMillis(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private long getDiscoveryEndMillis(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return -1;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mAdapterProperties.discoveryEndMillis();\n        }\n\n        @Override\n        public void getMostRecentlyConnectedDevices(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getMostRecentlyConnectedDevices(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private List<BluetoothDevice> getMostRecentlyConnectedDevices(\n                AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getMostRecentlyConnectedDevices\")) {\n                return new ArrayList<>();\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mDatabaseManager.getMostRecentlyConnectedDevices();\n        }\n\n        @Override\n        public void getBondedDevices(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getBondedDevices(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private List<BluetoothDevice> getBondedDevices(AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getBondedDevices\")) {\n                return new ArrayList<>();\n            }\n\n            return Arrays.asList(service.getBondedDevices());\n        }\n\n        @Override\n        public void getAdapterConnectionState(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getAdapterConnectionState());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getAdapterConnectionState() {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothAdapter.STATE_DISCONNECTED;\n            }\n\n            return service.mAdapterProperties.getConnectionState();\n        }\n\n        /**\n         * This method has an associated binder cache.  The invalidation\n         * methods must be changed if the logic behind this method changes.\n         */\n        @Override\n        public void getProfileConnectionState(int profile, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getProfileConnectionState(profile));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getProfileConnectionState(int profile) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"getProfileConnectionState\")) {\n                return BluetoothProfile.STATE_DISCONNECTED;\n            }\n\n            return service.mAdapterProperties.getProfileConnectionState(profile);\n        }\n\n        @Override\n        public void createBond(BluetoothDevice device, int transport, OobData remoteP192Data,\n                OobData remoteP256Data, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(createBond(device, transport, remoteP192Data, remoteP256Data,\n                            source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean createBond(BluetoothDevice device, int transport, OobData remoteP192Data,\n                OobData remoteP256Data, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"createBond\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService createBond\")) {\n                return false;\n            }\n\n            // This conditional is required to satisfy permission dependencies\n            // since createBond calls createBondOutOfBand with null value passed as data.\n            // BluetoothDevice#createBond requires BLUETOOTH_ADMIN only.\n            service.enforceBluetoothPrivilegedPermissionIfNeeded(remoteP192Data, remoteP256Data);\n\n            return service.createBond(device, transport, remoteP192Data, remoteP256Data,\n                    attributionSource.getPackageName());\n        }\n\n        @Override\n        public void cancelBondProcess(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(cancelBondProcess(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean cancelBondProcess(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"cancelBondProcess\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService cancelBondProcess\")) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp != null) {\n                deviceProp.setBondingInitiatedLocally(false);\n            }\n\n            return service.cancelBondNative(getBytesFromAddress(device.getAddress()));\n        }\n\n        @Override\n        public void removeBond(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(removeBond(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean removeBond(BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"removeBond\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService removeBond\")) {\n                return false;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null || deviceProp.getBondState() != BluetoothDevice.BOND_BONDED) {\n                return false;\n            }\n            service.mBondAttemptCallerInfo.remove(device.getAddress());\n            deviceProp.setBondingInitiatedLocally(false);\n\n            Message msg = service.mBondStateMachine.obtainMessage(BondStateMachine.REMOVE_BOND);\n            msg.obj = device;\n            service.mBondStateMachine.sendMessage(msg);\n            return true;\n        }\n\n        @Override\n        public void getBondState(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getBondState(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getBondState(BluetoothDevice device, AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getBondState\")) {\n                return BluetoothDevice.BOND_NONE;\n            }\n\n            return service.getBondState(device);\n        }\n\n        @Override\n        public void isBondingInitiatedLocally(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isBondingInitiatedLocally(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isBondingInitiatedLocally(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService isBondingInitiatedLocally\")) {\n                return false;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            return deviceProp != null && deviceProp.isBondingInitiatedLocally();\n        }\n\n        @Override\n        public void generateLocalOobData(int transport, IBluetoothOobDataCallback callback,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                generateLocalOobData(transport, callback, source);\n                receiver.send(null);\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private void generateLocalOobData(int transport, IBluetoothOobDataCallback callback,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveOrManagedUser(service, TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            service.generateLocalOobData(transport, callback);\n        }\n\n        @Override\n        public void getSupportedProfiles(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getSupportedProfiles(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private long getSupportedProfiles(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return 0;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n\n            return Config.getSupportedProfilesBitMask();\n        }\n\n        @Override\n        public int getConnectionState(BluetoothDevice device) {\n            if (mService == null) {\n                return BluetoothProfile.STATE_DISCONNECTED;\n            }\n            return getConnectionStateWithAttribution(device,\n                        Utils.getCallingAttributionSource(mService));\n        }\n\n        @Override\n        public void getConnectionStateWithAttribution(BluetoothDevice device,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getConnectionStateWithAttribution(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        public int getConnectionStateWithAttribution(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getConnectionState\")) {\n                return BluetoothProfile.STATE_DISCONNECTED;\n            }\n\n            return service.getConnectionState(device);\n        }\n\n        @Override\n        public void canBondWithoutDialog(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(canBondWithoutDialog(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean canBondWithoutDialog(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.canBondWithoutDialog(device);\n        }\n\n        @Override\n        public void removeActiveDevice(@ActiveDeviceUse int profiles,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(removeActiveDevice(profiles, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean removeActiveDevice(@ActiveDeviceUse int profiles,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n            return service.setActiveDevice(null, profiles);\n        }\n\n        @Override\n        public void setActiveDevice(BluetoothDevice device, @ActiveDeviceUse int profiles,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setActiveDevice(device, profiles, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setActiveDevice(BluetoothDevice device, @ActiveDeviceUse int profiles,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.setActiveDevice(device, profiles);\n        }\n\n        @Override\n        public void getActiveDevices(@ActiveDeviceProfile int profile,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getActiveDevices(profile, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private List<BluetoothDevice> getActiveDevices(@ActiveDeviceProfile int profile,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return new ArrayList<>();\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.getActiveDevices(profile);\n        }\n\n        @Override\n        public void connectAllEnabledProfiles(BluetoothDevice device,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(connectAllEnabledProfiles(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int connectAllEnabledProfiles(BluetoothDevice device,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveUser(TAG, \"connectAllEnabledProfiles\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            if (device == null) {\n                throw new IllegalArgumentException(\"device cannot be null\");\n            }\n            if (!BluetoothAdapter.checkBluetoothAddress(device.getAddress())) {\n                throw new IllegalArgumentException(\"device cannot have an invalid address\");\n            }\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            try {\n                return service.connectAllEnabledProfiles(device);\n            } catch (Exception e) {\n                Log.v(TAG, \"connectAllEnabledProfiles() failed\", e);\n                SneakyThrow.sneakyThrow(e);\n                throw new RuntimeException(e);\n            }\n        }\n\n        @Override\n        public void disconnectAllEnabledProfiles(BluetoothDevice device,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(disconnectAllEnabledProfiles(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int disconnectAllEnabledProfiles(BluetoothDevice device,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveUser(TAG, \"disconnectAllEnabledProfiles\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            if (device == null) {\n                throw new IllegalArgumentException(\"device cannot be null\");\n            }\n            if (!BluetoothAdapter.checkBluetoothAddress(device.getAddress())) {\n                throw new IllegalArgumentException(\"device cannot have an invalid address\");\n            }\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            try {\n                return service.disconnectAllEnabledProfiles(device);\n            } catch (Exception e) {\n                Log.v(TAG, \"disconnectAllEnabledProfiles() failed\", e);\n                SneakyThrow.sneakyThrow(e);\n                throw new RuntimeException(e);\n            }\n        }\n\n        @Override\n        public void getRemoteName(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getRemoteName(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private String getRemoteName(BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteName\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getRemoteName\")) {\n                return null;\n            }\n\n            return service.getRemoteName(device);\n        }\n\n        @Override\n        public void getRemoteType(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getRemoteType(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getRemoteType(BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteType\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getRemoteType\")) {\n                return BluetoothDevice.DEVICE_TYPE_UNKNOWN;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            return deviceProp != null\n                    ? deviceProp.getDeviceType() : BluetoothDevice.DEVICE_TYPE_UNKNOWN;\n        }\n\n        @Override\n        public String getRemoteAlias(BluetoothDevice device) {\n            if (mService == null) {\n                return null;\n            }\n            return getRemoteAliasWithAttribution(device,\n                    Utils.getCallingAttributionSource(mService));\n        }\n\n        @Override\n        public void getRemoteAliasWithAttribution(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getRemoteAliasWithAttribution(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private String getRemoteAliasWithAttribution(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteAlias\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getRemoteAlias\")) {\n                return null;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            return deviceProp != null ? deviceProp.getAlias() : null;\n        }\n\n        @Override\n        public void setRemoteAlias(BluetoothDevice device, String name, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setRemoteAlias(device, name, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int setRemoteAlias(BluetoothDevice device, String name,\n                AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveUser(TAG, \"setRemoteAlias\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            if (name != null && name.isEmpty()) {\n                throw new IllegalArgumentException(\"alias cannot be the empty string\");\n            }\n\n            if (!hasBluetoothPrivilegedPermission(service)) {\n                if (!Utils.checkConnectPermissionForDataDelivery(\n                        service, attributionSource, \"AdapterService setRemoteAlias\")) {\n                    return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n                }\n                enforceCdmAssociation(service.mCompanionDeviceManager, service,\n                        attributionSource.getPackageName(), Binder.getCallingUid(), device);\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null) {\n                return BluetoothStatusCodes.ERROR_DEVICE_NOT_BONDED;\n            }\n            deviceProp.setAlias(device, name);\n            return BluetoothStatusCodes.SUCCESS;\n        }\n\n        @Override\n        public void getRemoteClass(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getRemoteClass(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getRemoteClass(BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteClass\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getRemoteClass\")) {\n                return 0;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            return deviceProp != null ? deviceProp.getBluetoothClass() : 0;\n        }\n\n        @Override\n        public void getRemoteUuids(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getRemoteUuids(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private List<ParcelUuid> getRemoteUuids(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteUuids\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getRemoteUuids\")) {\n                return new ArrayList<>();\n            }\n\n            ParcelUuid[] parcels = service.getRemoteUuids(device);\n            if (parcels == null) {\n                return null;\n            }\n            return Arrays.asList(parcels);\n        }\n\n        @Override\n        public boolean fetchRemoteUuids(BluetoothDevice device) {\n            if (mService == null) {\n                return false;\n            }\n            return fetchRemoteUuidsWithAttribution(device, TRANSPORT_AUTO,\n                    Utils.getCallingAttributionSource(mService));\n        }\n\n        @Override\n        public void fetchRemoteUuidsWithAttribution(BluetoothDevice device, int transport,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(fetchRemoteUuidsWithAttribution(device, transport, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean fetchRemoteUuidsWithAttribution(\n                BluetoothDevice device, int transport, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"fetchRemoteUuids\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService fetchRemoteUuids\")) {\n                return false;\n            }\n            if (transport != TRANSPORT_AUTO) {\n                enforceBluetoothPrivilegedPermission(service);\n            }\n\n            service.mRemoteDevices.fetchUuids(device, transport);\n            return true;\n        }\n\n        @Override\n        public void setPin(BluetoothDevice device, boolean accept, int len, byte[] pinCode,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setPin(device, accept, len, pinCode, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setPin(BluetoothDevice device, boolean accept, int len, byte[] pinCode,\n                AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"setPin\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService setPin\")) {\n                return false;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            // Only allow setting a pin in bonding state, or bonded state in case of security\n            // upgrade.\n            if (deviceProp == null || !deviceProp.isBondingOrBonded()) {\n                return false;\n            }\n            if (pinCode.length != len) {\n                android.util.EventLog.writeEvent(0x534e4554, \"139287605\", -1,\n                        \"PIN code length mismatch\");\n                return false;\n            }\n            service.logUserBondResponse(device, accept,\n                    BluetoothProtoEnums.BOND_SUB_STATE_LOCAL_PIN_REPLIED);\n            return service.pinReplyNative(\n                    getBytesFromAddress(device.getAddress()), accept, len, pinCode);\n        }\n\n        @Override\n        public void setPasskey(BluetoothDevice device, boolean accept, int len, byte[] passkey,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setPasskey(device, accept, len, passkey, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setPasskey(BluetoothDevice device, boolean accept, int len, byte[] passkey,\n                AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"setPasskey\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService setPasskey\")) {\n                return false;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null || !deviceProp.isBonding()) {\n                return false;\n            }\n            if (passkey.length != len) {\n                android.util.EventLog.writeEvent(0x534e4554, \"139287605\", -1,\n                        \"Passkey length mismatch\");\n                return false;\n            }\n            service.logUserBondResponse(device, accept, BluetoothProtoEnums.BOND_SUB_STATE_LOCAL_SSP_REPLIED);\n            return service.sspReplyNative(\n                    getBytesFromAddress(device.getAddress()),\n                    AbstractionLayer.BT_SSP_VARIANT_PASSKEY_ENTRY,\n                    accept,\n                    Utils.byteArrayToInt(passkey));\n        }\n\n        @Override\n        public void setPairingConfirmation(BluetoothDevice device, boolean accept,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setPairingConfirmation(device, accept, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setPairingConfirmation(BluetoothDevice device, boolean accept,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null || !deviceProp.isBonding()) {\n                return false;\n            }\n            service.logUserBondResponse(device, accept, BluetoothProtoEnums.BOND_SUB_STATE_LOCAL_SSP_REPLIED);\n            return service.sspReplyNative(\n                    getBytesFromAddress(device.getAddress()),\n                    AbstractionLayer.BT_SSP_VARIANT_PASSKEY_CONFIRMATION,\n                    accept,\n                    0);\n        }\n\n        @Override\n        public void getSilenceMode(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getSilenceMode(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean getSilenceMode(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mSilenceDeviceManager.getSilenceMode(device);\n        }\n\n        @Override\n        public void setSilenceMode(BluetoothDevice device, boolean silence,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setSilenceMode(device, silence, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setSilenceMode(BluetoothDevice device, boolean silence,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.mSilenceDeviceManager.setSilenceMode(device, silence);\n            return true;\n        }\n\n        @Override\n        public void getPhonebookAccessPermission(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getPhonebookAccessPermission(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getPhonebookAccessPermission(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getPhonebookAccessPermission\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getPhonebookAccessPermission\")) {\n                return BluetoothDevice.ACCESS_UNKNOWN;\n            }\n\n            return service.getDeviceAccessFromPrefs(device, PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE);\n        }\n\n        @Override\n        public void setPhonebookAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setPhonebookAccessPermission(device, value, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setPhonebookAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.setPhonebookAccessPermission(device, value);\n            return true;\n        }\n\n        @Override\n        public void getMessageAccessPermission(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getMessageAccessPermission(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getMessageAccessPermission(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getMessageAccessPermission\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getMessageAccessPermission\")) {\n                return BluetoothDevice.ACCESS_UNKNOWN;\n            }\n\n            return service.getDeviceAccessFromPrefs(device, MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE);\n        }\n\n        @Override\n        public void setMessageAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setMessageAccessPermission(device, value, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setMessageAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.setMessageAccessPermission(device, value);\n            return true;\n        }\n\n        @Override\n        public void getSimAccessPermission(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getSimAccessPermission(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getSimAccessPermission(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getSimAccessPermission\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getSimAccessPermission\")) {\n                return BluetoothDevice.ACCESS_UNKNOWN;\n            }\n\n            return service.getDeviceAccessFromPrefs(device, SIM_ACCESS_PERMISSION_PREFERENCE_FILE);\n        }\n\n        @Override\n        public void setSimAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setSimAccessPermission(device, value, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setSimAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.setSimAccessPermission(device, value);\n            return true;\n        }\n\n        @Override\n        public IBluetoothSocketManager getSocketManager() {\n            AdapterService service = getService();\n            if (service == null) {\n                return null;\n            }\n\n            return IBluetoothSocketManager.Stub.asInterface(service.mBluetoothSocketManagerBinder);\n        }\n\n        @Override\n        public void sdpSearch(BluetoothDevice device, ParcelUuid uuid, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(sdpSearch(device, uuid, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean sdpSearch(\n                BluetoothDevice device, ParcelUuid uuid, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"sdpSearch\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService sdpSearch\")) {\n                return false;\n            }\n\n            if (service.mSdpManager == null) {\n                return false;\n            }\n            service.mSdpManager.sdpSearch(device, uuid);\n            return true;\n        }\n\n        @Override\n        public void getBatteryLevel(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getBatteryLevel(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getBatteryLevel(BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getBatteryLevel\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getBatteryLevel\")) {\n                return BluetoothDevice.BATTERY_LEVEL_UNKNOWN;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null) {\n                return BluetoothDevice.BATTERY_LEVEL_UNKNOWN;\n            }\n            return deviceProp.getBatteryLevel();\n        }\n\n        @Override\n        public void getMaxConnectedAudioDevices(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getMaxConnectedAudioDevices(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getMaxConnectedAudioDevices(AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getMaxConnectedAudioDevices\")) {\n                return -1;\n            }\n\n            return service.getMaxConnectedAudioDevices();\n        }\n\n        //@Override\n        @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)\n        public void isA2dpOffloadEnabled(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isA2dpOffloadEnabled(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isA2dpOffloadEnabled(AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService isA2dpOffloadEnabled\")) {\n                return false;\n            }\n\n            return service.isA2dpOffloadEnabled();\n        }\n\n        @Override\n        public void factoryReset(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(factoryReset(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        boolean factoryReset(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (service.mDatabaseManager != null) {\n                service.mDatabaseManager.factoryReset();\n            }\n\n            if (service.mBluetoothKeystoreService != null) {\n                service.mBluetoothKeystoreService.factoryReset();\n            }\n\n            return service.factoryResetNative();\n        }\n\n        @Override\n        public void registerBluetoothConnectionCallback(IBluetoothConnectionCallback callback,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(registerBluetoothConnectionCallback(callback, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean registerBluetoothConnectionCallback(IBluetoothConnectionCallback callback,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            service.mBluetoothConnectionCallbacks.add(callback);\n            return true;\n        }\n\n        @Override\n        public void unregisterBluetoothConnectionCallback(IBluetoothConnectionCallback callback,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(unregisterBluetoothConnectionCallback(callback, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean unregisterBluetoothConnectionCallback(\n                IBluetoothConnectionCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.mBluetoothConnectionCallbacks.remove(callback);\n        }\n\n        @Override\n        public void registerCallback(IBluetoothCallback callback, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                registerCallback(callback, source);\n                receiver.send(null);\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        void registerCallback(IBluetoothCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.mCallbacks.register(callback);\n        }\n\n        @Override\n        public void unregisterCallback(IBluetoothCallback callback, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                unregisterCallback(callback, source);\n                receiver.send(null);\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        void unregisterCallback(IBluetoothCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null || service.mCallbacks == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.mCallbacks.unregister(callback);\n        }\n\n        @Override\n        public void isMultiAdvertisementSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isMultiAdvertisementSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isMultiAdvertisementSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            int val = service.mAdapterProperties.getNumOfAdvertisementInstancesSupported();\n            return val >= MIN_ADVT_INSTANCES_FOR_MA;\n        }\n\n        /**\n         * This method has an associated binder cache.  The invalidation\n         * methods must be changed if the logic behind this method changes.\n         */\n        @Override\n        public void isOffloadedFilteringSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isOffloadedFilteringSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isOffloadedFilteringSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            int val = service.getNumOfOffloadedScanFilterSupported();\n            return val >= MIN_OFFLOADED_FILTERS;\n        }\n\n        @Override\n        public void isOffloadedScanBatchingSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isOffloadedScanBatchingSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isOffloadedScanBatchingSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            int val = service.getOffloadedScanResultStorage();\n            return val >= MIN_OFFLOADED_SCAN_STORAGE_BYTES;\n        }\n\n        @Override\n        public void isLe2MPhySupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLe2MPhySupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isLe2MPhySupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.isLe2MPhySupported();\n        }\n\n        @Override\n        public void isLeCodedPhySupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLeCodedPhySupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isLeCodedPhySupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.isLeCodedPhySupported();\n        }\n\n        @Override\n        public void isLeExtendedAdvertisingSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLeExtendedAdvertisingSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isLeExtendedAdvertisingSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.isLeExtendedAdvertisingSupported();\n        }\n\n        @Override\n        public void isLePeriodicAdvertisingSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLePeriodicAdvertisingSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isLePeriodicAdvertisingSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.isLePeriodicAdvertisingSupported();\n        }\n\n        @Override\n        public void isLeAudioSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLeAudioSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int isLeAudioSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n\n            HashSet<Class> supportedProfileServices =\n                    new HashSet<Class>(Arrays.asList(Config.getSupportedProfiles()));\n            HashSet<Class> leAudioUnicastProfiles = Config.geLeAudioUnicastProfiles();\n\n            if (supportedProfileServices.containsAll(leAudioUnicastProfiles)) {\n                return BluetoothStatusCodes.FEATURE_SUPPORTED;\n            }\n\n            return BluetoothStatusCodes.FEATURE_NOT_SUPPORTED;\n        }\n\n        @Override\n        public void isLeAudioBroadcastSourceSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLeAudioBroadcastSourceSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int isLeAudioBroadcastSourceSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n\n            if (service.isLeAudioBroadcastSourceSupported()) {\n                return BluetoothStatusCodes.FEATURE_SUPPORTED;\n            }\n\n            return BluetoothStatusCodes.FEATURE_NOT_SUPPORTED;\n        }\n\n        @Override\n        public void isLeAudioBroadcastAssistantSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLeAudioBroadcastAssistantSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        public int isLeAudioBroadcastAssistantSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n\n            HashSet<Class> supportedProfileServices =\n                    new HashSet<Class>(Arrays.asList(Config.getSupportedProfiles()));\n\n            if (supportedProfileServices.contains(BassClientService.class)) {\n                return BluetoothStatusCodes.FEATURE_SUPPORTED;\n            }\n\n            return BluetoothStatusCodes.FEATURE_NOT_SUPPORTED;\n        }\n\n        @Override\n        public void getLeMaximumAdvertisingDataLength(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getLeMaximumAdvertisingDataLength());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getLeMaximumAdvertisingDataLength() {\n            AdapterService service = getService();\n            if (service == null) {\n                return 0;\n            }\n\n            return service.getLeMaximumAdvertisingDataLength();\n        }\n\n        @Override\n        public void isActivityAndEnergyReportingSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isActivityAndEnergyReportingSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isActivityAndEnergyReportingSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.mAdapterProperties.isActivityAndEnergyReportingSupported();\n        }\n\n        @Override\n        public void reportActivityInfo(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(reportActivityInfo(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private BluetoothActivityEnergyInfo reportActivityInfo(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return null;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.reportActivityInfo();\n        }\n\n        @Override\n        public void registerMetadataListener(IBluetoothMetadataListener listener,\n                BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(registerMetadataListener(listener, device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean registerMetadataListener(IBluetoothMetadataListener listener,\n                BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (service.mMetadataListeners == null) {\n                return false;\n            }\n            ArrayList<IBluetoothMetadataListener> list = service.mMetadataListeners.get(device);\n            if (list == null) {\n                list = new ArrayList<>();\n            } else if (list.contains(listener)) {\n                // The device is already registered with this listener\n                return true;\n            }\n            list.add(listener);\n            service.mMetadataListeners.put(device, list);\n            return true;\n        }\n\n        @Override\n        public void unregisterMetadataListener(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(unregisterMetadataListener(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean unregisterMetadataListener(BluetoothDevice device,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (service.mMetadataListeners == null) {\n                return false;\n            }\n            if (service.mMetadataListeners.containsKey(device)) {\n                service.mMetadataListeners.remove(device);\n            }\n            return true;\n        }\n\n        @Override\n        public void setMetadata(BluetoothDevice device, int key, byte[] value,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setMetadata(device, key, value, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setMetadata(BluetoothDevice device, int key, byte[] value,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (value.length > BluetoothDevice.METADATA_MAX_LENGTH) {\n                return false;\n            }\n            return service.mDatabaseManager.setCustomMeta(device, key, value);\n        }\n\n        @Override\n        public void getMetadata(BluetoothDevice device, int key, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getMetadata(device, key, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private byte[] getMetadata(BluetoothDevice device, int key,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return null;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mDatabaseManager.getCustomMeta(device, key);\n        }\n\n        @Override\n        public void requestActivityInfo(IBluetoothActivityEnergyInfoListener listener,\n                    AttributionSource source) {\n            BluetoothActivityEnergyInfo info = reportActivityInfo(source);\n            try {\n                listener.onBluetoothActivityEnergyInfoAvailable(info);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"onBluetoothActivityEnergyInfo: RemoteException\", e);\n            }\n        }\n\n        @Override\n        public void onLeServiceUp(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                onLeServiceUp(source);\n                receiver.send(null);\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        void onLeServiceUp(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.mAdapterStateMachine.sendMessage(AdapterState.USER_TURN_ON);\n        }\n\n        @Override\n        public void onBrEdrDown(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                onBrEdrDown(source);\n                receiver.send(null);\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        void onBrEdrDown(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.mAdapterStateMachine.sendMessage(AdapterState.BLE_TURN_OFF);\n        }\n\n        @Override\n        public void dump(FileDescriptor fd, String[] args) {\n            PrintWriter writer = new PrintWriter(new FileOutputStream(fd));\n            AdapterService service = getService();\n            if (service == null) {\n                return;\n            }\n\n            enforceDumpPermission(service);\n\n            service.dump(fd, writer, args);\n            writer.close();\n        }\n\n        @Override\n        public void allowLowLatencyAudio(boolean allowed, BluetoothDevice device,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(allowLowLatencyAudio(allowed, device));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @RequiresPermission(allOf = {\n                android.Manifest.permission.BLUETOOTH_CONNECT,\n                android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n        })\n        private boolean allowLowLatencyAudio(boolean allowed, BluetoothDevice device) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, Utils.getCallingAttributionSource(service),\n                                \"AdapterService allowLowLatencyAudio\")) {\n                return false;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.allowLowLatencyAudio(allowed, device);\n        }\n\n        @Override\n        public void startRfcommListener(String name, ParcelUuid uuid, PendingIntent pendingIntent,\n                AttributionSource attributionSource, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(startRfcommListener(name, uuid, pendingIntent, attributionSource));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @RequiresPermission(allOf = {\n                android.Manifest.permission.BLUETOOTH_CONNECT,\n                android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n        })\n        private int startRfcommListener(\n                String name,\n                ParcelUuid uuid,\n                PendingIntent pendingIntent,\n                AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService startRfcommListener\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.startRfcommListener(name, uuid, pendingIntent, attributionSource);\n        }\n\n        @Override\n        public void stopRfcommListener(ParcelUuid uuid, AttributionSource attributionSource,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(stopRfcommListener(uuid, attributionSource));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @RequiresPermission(allOf = {\n                android.Manifest.permission.BLUETOOTH_CONNECT,\n                android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n        })\n        private int stopRfcommListener(ParcelUuid uuid, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService stopRfcommListener\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.stopRfcommListener(uuid, attributionSource);\n        }\n\n        @Override\n        public void retrievePendingSocketForServiceRecord(ParcelUuid uuid,\n                AttributionSource attributionSource, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(retrievePendingSocketForServiceRecord(uuid, attributionSource));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @RequiresPermission(allOf = {\n                android.Manifest.permission.BLUETOOTH_CONNECT,\n                android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n        })\n        private IncomingRfcommSocketInfo retrievePendingSocketForServiceRecord(\n                ParcelUuid uuid, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource,\n                            \"AdapterService retrievePendingSocketForServiceRecord\")) {\n                return null;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.retrievePendingSocketForServiceRecord(uuid, attributionSource);\n        }\n\n        @Override\n        public void setForegroundUserId(int userId, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, Utils.getCallingAttributionSource(mService),\n                    \"AdapterService setForegroundUserId\")) {\n                return;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            Utils.setForegroundUserId(userId);\n        }\n    }\n\n    // ----API Methods--------\n\n    public boolean isEnabled() {\n        return getState() == BluetoothAdapter.STATE_ON;\n    }\n\n    public int getState() {\n        if (mAdapterProperties != null) {\n            return mAdapterProperties.getState();\n        }\n        return BluetoothAdapter.STATE_OFF;\n    }\n\n    public synchronized boolean enable(boolean quietMode) {\n        // Enforce the user restriction for disallowing Bluetooth if it was set.\n        if (mUserManager.hasUserRestrictionForUser(UserManager.DISALLOW_BLUETOOTH,\n                    UserHandle.SYSTEM)) {\n            debugLog(\"enable() called when Bluetooth was disallowed\");\n            return false;\n        }\n\n        debugLog(\"enable() - Enable called with quiet mode status =  \" + quietMode);\n        mQuietmode = quietMode;\n        mAdapterStateMachine.sendMessage(AdapterState.BLE_TURN_ON);\n        return true;\n    }\n\n    boolean disable() {\n        debugLog(\"disable() called with mRunningProfiles.size() = \" + mRunningProfiles.size());\n        mAdapterStateMachine.sendMessage(AdapterState.USER_TURN_OFF);\n        return true;\n    }\n\n    public String getName() {\n        return mAdapterProperties.getName();\n    }\n\n    public int getNameLengthForAdvertise() {\n        return mAdapterProperties.getName().length();\n    }\n\n    private static boolean isValidIoCapability(int capability) {\n        if (capability < 0 || capability >= BluetoothAdapter.IO_CAPABILITY_MAX) {\n            Log.e(TAG, \"Invalid IO capability value - \" + capability);\n            return false;\n        }\n\n        return true;\n    }\n\n    ArrayList<DiscoveringPackage> getDiscoveringPackages() {\n        return mDiscoveringPackages;\n    }\n\n    void clearDiscoveringPackages() {\n        synchronized (mDiscoveringPackages) {\n            mDiscoveringPackages.clear();\n        }\n    }\n\n    boolean startDiscovery(AttributionSource attributionSource) {\n        UserHandle callingUser = Binder.getCallingUserHandle();\n        debugLog(\"startDiscovery\");\n        String callingPackage = attributionSource.getPackageName();\n        mAppOps.checkPackage(Binder.getCallingUid(), callingPackage);\n        boolean isQApp = Utils.checkCallerTargetSdk(this, callingPackage, Build.VERSION_CODES.Q);\n        boolean hasDisavowedLocation =\n                Utils.hasDisavowedLocationForScan(this, attributionSource, mTestModeEnabled);\n        String permission = null;\n        if (Utils.checkCallerHasNetworkSettingsPermission(this)) {\n            permission = android.Manifest.permission.NETWORK_SETTINGS;\n        } else if (Utils.checkCallerHasNetworkSetupWizardPermission(this)) {\n            permission = android.Manifest.permission.NETWORK_SETUP_WIZARD;\n        } else if (!hasDisavowedLocation) {\n            if (isQApp) {\n                if (!Utils.checkCallerHasFineLocation(this, attributionSource, callingUser)) {\n                    return false;\n                }\n                permission = android.Manifest.permission.ACCESS_FINE_LOCATION;\n            } else {\n                if (!Utils.checkCallerHasCoarseLocation(this, attributionSource, callingUser)) {\n                    return false;\n                }\n                permission = android.Manifest.permission.ACCESS_COARSE_LOCATION;\n            }\n        }\n\n        synchronized (mDiscoveringPackages) {\n            mDiscoveringPackages.add(\n                    new DiscoveringPackage(callingPackage, permission, hasDisavowedLocation));\n        }\n        return startDiscoveryNative();\n    }\n\n    /**\n     * Same as API method {@link BluetoothAdapter#getBondedDevices()}\n     *\n     * @return array of bonded {@link BluetoothDevice} or null on error\n     */\n    public BluetoothDevice[] getBondedDevices() {\n        return mAdapterProperties.getBondedDevices();\n    }\n\n    /**\n     * Get the database manager to access Bluetooth storage\n     *\n     * @return {@link DatabaseManager} or null on error\n     */\n    @VisibleForTesting\n    public DatabaseManager getDatabase() {\n        return mDatabaseManager;\n    }\n\n    public byte[] getByteIdentityAddress(BluetoothDevice device) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp != null && deviceProp.isConsolidated()) {\n            return Utils.getBytesFromAddress(deviceProp.getIdentityAddress());\n        } else {\n            return Utils.getByteAddress(device);\n        }\n    }\n\n    public BluetoothDevice getDeviceFromByte(byte[] address) {\n        BluetoothDevice device = mRemoteDevices.getDevice(address);\n        if (device == null) {\n            device = BluetoothAdapter.getDefaultAdapter().getRemoteDevice(address);\n        }\n        return device;\n    }\n\n    public String getIdentityAddress(String address) {\n        BluetoothDevice device = BluetoothAdapter.getDefaultAdapter().getRemoteDevice(address.toUpperCase());\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp != null && deviceProp.isConsolidated()) {\n            return deviceProp.getIdentityAddress();\n        } else {\n            return address;\n        }\n    }\n\n    private class CallerInfo {\n        public String callerPackageName;\n        public UserHandle user;\n    }\n\n    boolean createBond(BluetoothDevice device, int transport, OobData remoteP192Data,\n            OobData remoteP256Data, String callingPackage) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp != null && deviceProp.getBondState() != BluetoothDevice.BOND_NONE) {\n            return false;\n        }\n\n        if (!isPackageNameAccurate(this, callingPackage, Binder.getCallingUid())) {\n            return false;\n        }\n\n        CallerInfo createBondCaller = new CallerInfo();\n        createBondCaller.callerPackageName = callingPackage;\n        createBondCaller.user = Binder.getCallingUserHandle();\n        mBondAttemptCallerInfo.put(device.getAddress(), createBondCaller);\n\n        mRemoteDevices.setBondingInitiatedLocally(Utils.getByteAddress(device));\n\n        // Pairing is unreliable while scanning, so cancel discovery\n        // Note, remove this when native stack improves\n        cancelDiscoveryNative();\n\n        Message msg = mBondStateMachine.obtainMessage(BondStateMachine.CREATE_BOND);\n        msg.obj = device;\n        msg.arg1 = transport;\n\n        Bundle remoteOobDatasBundle = new Bundle();\n        boolean setData = false;\n        if (remoteP192Data != null) {\n            remoteOobDatasBundle.putParcelable(BondStateMachine.OOBDATAP192, remoteP192Data);\n            setData = true;\n        }\n        if (remoteP256Data != null) {\n            remoteOobDatasBundle.putParcelable(BondStateMachine.OOBDATAP256, remoteP256Data);\n            setData = true;\n        }\n        if (setData) {\n            msg.setData(remoteOobDatasBundle);\n        }\n        mBondStateMachine.sendMessage(msg);\n        return true;\n    }\n\n    private final ArrayDeque<IBluetoothOobDataCallback> mOobDataCallbackQueue =\n            new ArrayDeque<>();\n\n    /**\n     * Fetches the local OOB data to give out to remote.\n     *\n     * @param transport - specify data transport.\n     * @param callback - callback used to receive the requested {@link OobData}; null will be\n     * ignored silently.\n     *\n     * @hide\n     */\n    public synchronized void generateLocalOobData(int transport,\n            IBluetoothOobDataCallback callback) {\n        if (callback == null) {\n            Log.e(TAG, \"'callback' argument must not be null!\");\n            return;\n        }\n        if (mOobDataCallbackQueue.peek() != null) {\n            try {\n                callback.onError(BluetoothStatusCodes.ERROR_ANOTHER_ACTIVE_OOB_REQUEST);\n                return;\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Failed to make callback\", e);\n            }\n        }\n        mOobDataCallbackQueue.offer(callback);\n        generateLocalOobDataNative(transport);\n    }\n\n    /* package */ synchronized void notifyOobDataCallback(int transport, OobData oobData) {\n        if (mOobDataCallbackQueue.peek() == null) {\n            Log.e(TAG, \"Failed to make callback, no callback exists\");\n            return;\n        }\n        if (oobData == null) {\n            try {\n                mOobDataCallbackQueue.poll().onError(BluetoothStatusCodes.ERROR_UNKNOWN);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Failed to make callback\", e);\n            }\n        } else {\n            try {\n                mOobDataCallbackQueue.poll().onOobData(transport, oobData);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Failed to make callback\", e);\n            }\n        }\n    }\n\n    public boolean isQuietModeEnabled() {\n        debugLog(\"isQuietModeEnabled() - Enabled = \" + mQuietmode);\n        return mQuietmode;\n    }\n\n    public void updateUuids() {\n        debugLog(\"updateUuids() - Updating UUIDs for bonded devices\");\n        BluetoothDevice[] bondedDevices = getBondedDevices();\n        if (bondedDevices == null) {\n            return;\n        }\n\n        for (BluetoothDevice device : bondedDevices) {\n            mRemoteDevices.updateUuids(device);\n        }\n    }\n\n    /**\n     * Update device UUID changed to {@link BondStateMachine}\n     *\n     * @param device remote device of interest\n     */\n    public void deviceUuidUpdated(BluetoothDevice device) {\n        // Notify BondStateMachine for SDP complete / UUID changed.\n        Message msg = mBondStateMachine.obtainMessage(BondStateMachine.UUID_UPDATE);\n        msg.obj = device;\n        mBondStateMachine.sendMessage(msg);\n    }\n\n    /**\n     * Get the bond state of a particular {@link BluetoothDevice}\n     *\n     * @param device remote device of interest\n     * @return bond state <p>Possible values are\n     * {@link BluetoothDevice#BOND_NONE},\n     * {@link BluetoothDevice#BOND_BONDING},\n     * {@link BluetoothDevice#BOND_BONDED}.\n     */\n    @VisibleForTesting\n    public int getBondState(BluetoothDevice device) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp == null) {\n            return BluetoothDevice.BOND_NONE;\n        }\n        return deviceProp.getBondState();\n    }\n\n    int getConnectionState(BluetoothDevice device) {\n        return getConnectionStateNative(getBytesFromAddress(device.getAddress()));\n    }\n\n    /**\n     * Checks whether the device was recently associated with the comapnion app that called\n     * {@link BluetoothDevice#createBond}. This allows these devices to skip the pairing dialog if\n     * their pairing variant is {@link BluetoothDevice#PAIRING_VARIANT_CONSENT}.\n     *\n     * @param device the bluetooth device that is being bonded\n     * @return true if it was recently associated and we can bypass the dialog, false otherwise\n     */\n    public boolean canBondWithoutDialog(BluetoothDevice device) {\n        if (mBondAttemptCallerInfo.containsKey(device.getAddress())) {\n            CallerInfo bondCallerInfo = mBondAttemptCallerInfo.get(device.getAddress());\n\n            return mCompanionDeviceManager.canPairWithoutPrompt(bondCallerInfo.callerPackageName,\n                    device.getAddress(), bondCallerInfo.user);\n        }\n        return false;\n    }\n\n    /**\n     * Sets device as the active devices for the profiles passed into the function\n     *\n     * @param device is the remote bluetooth device\n     * @param profiles is a constant that references for which profiles we'll be setting the remote\n     *                 device as our active device. One of the following:\n     *                 {@link BluetoothAdapter#ACTIVE_DEVICE_AUDIO},\n     *                 {@link BluetoothAdapter#ACTIVE_DEVICE_PHONE_CALL}\n     *                 {@link BluetoothAdapter#ACTIVE_DEVICE_ALL}\n     * @return false if profiles value is not one of the constants we accept, true otherwise\n     */\n    @RequiresPermission(allOf = {\n            android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n            android.Manifest.permission.MODIFY_PHONE_STATE,\n    })\n    public boolean setActiveDevice(BluetoothDevice device, @ActiveDeviceUse int profiles) {\n        boolean setA2dp = false;\n        boolean setHeadset = false;\n\n        // Determine for which profiles we want to set device as our active device\n        switch(profiles) {\n            case BluetoothAdapter.ACTIVE_DEVICE_AUDIO:\n                setA2dp = true;\n                break;\n            case BluetoothAdapter.ACTIVE_DEVICE_PHONE_CALL:\n                setHeadset = true;\n                break;\n            case BluetoothAdapter.ACTIVE_DEVICE_ALL:\n                setA2dp = true;\n                setHeadset = true;\n                break;\n            default:\n                return false;\n        }\n\n        if (mLeAudioService != null && (device == null\n                || mLeAudioService.getConnectionPolicy(device)\n                == BluetoothProfile.CONNECTION_POLICY_ALLOWED)) {\n            Log.i(TAG, \"setActiveDevice: Setting active Le Audio device \" + device);\n            mLeAudioService.setActiveDevice(device);\n        }\n\n        if (setA2dp && mA2dpService != null && (device == null\n                || mA2dpService.getConnectionPolicy(device)\n                == BluetoothProfile.CONNECTION_POLICY_ALLOWED)) {\n            Log.i(TAG, \"setActiveDevice: Setting active A2dp device \" + device);\n            mA2dpService.setActiveDevice(device);\n        }\n\n        if (mHearingAidService != null && (device == null\n                || mHearingAidService.getConnectionPolicy(device)\n                == BluetoothProfile.CONNECTION_POLICY_ALLOWED)) {\n            Log.i(TAG, \"setActiveDevice: Setting active Hearing Aid \" + device);\n            mHearingAidService.setActiveDevice(device);\n        }\n\n        if (setHeadset && mHeadsetService != null && (device == null\n                || mHeadsetService.getConnectionPolicy(device)\n                == BluetoothProfile.CONNECTION_POLICY_ALLOWED)) {\n            Log.i(TAG, \"setActiveDevice: Setting active Headset \" + device);\n            mHeadsetService.setActiveDevice(device);\n        }\n\n        return true;\n    }\n\n    /**\n     * Get the active devices for the BluetoothProfile specified\n     *\n     * @param profile is the profile from which we want the active devices.\n     *                Possible values are:\n     *                {@link BluetoothProfile#HEADSET},\n     *                {@link BluetoothProfile#A2DP},\n     *                {@link BluetoothProfile#HEARING_AID}\n     *                {@link BluetoothProfile#LE_AUDIO}\n     * @return A list of active bluetooth devices\n     */\n    @RequiresPermission(android.Manifest.permission.BLUETOOTH_PRIVILEGED)\n    public List<BluetoothDevice> getActiveDevices(@ActiveDeviceProfile int profile) {\n        List<BluetoothDevice> activeDevices = new ArrayList<>();\n\n        switch (profile) {\n            case BluetoothProfile.HEADSET:\n                if (mHeadsetService == null) {\n                    Log.e(TAG, \"getActiveDevices: HeadsetService is null\");\n                } else {\n                    BluetoothDevice device = mHeadsetService.getActiveDevice();\n                    if (device != null) {\n                        activeDevices.add(device);\n                    }\n                    Log.i(TAG, \"getActiveDevices: Headset device: \" + device);\n                }\n                break;\n            case BluetoothProfile.A2DP:\n                if (mA2dpService == null) {\n                    Log.e(TAG, \"getActiveDevices: A2dpService is null\");\n                } else {\n                    BluetoothDevice device = mA2dpService.getActiveDevice();\n                    if (device != null) {\n                        activeDevices.add(device);\n                    }\n                    Log.i(TAG, \"getActiveDevices: A2dp device: \" + device);\n                }\n                break;\n            case BluetoothProfile.HEARING_AID:\n                if (mHearingAidService == null) {\n                    Log.e(TAG, \"getActiveDevices: HearingAidService is null\");\n                } else {\n                    activeDevices = mHearingAidService.getActiveDevices();\n                    Log.i(TAG, \"getActiveDevices: Hearing Aid devices: Left[\"\n                            + activeDevices.get(0) + \"] - Right[\" + activeDevices.get(1) + \"]\");\n                }\n                break;\n            case BluetoothProfile.LE_AUDIO:\n                if (mLeAudioService == null) {\n                Log.e(TAG, \"getActiveDevices: LeAudioService is null\");\n                } else {\n                    activeDevices = mLeAudioService.getActiveDevices();\n                    Log.i(TAG, \"getActiveDevices: LeAudio devices: Out[\"\n                            + activeDevices.get(0) + \"] - In[\" + activeDevices.get(1) + \"]\");\n                }\n                break;\n            default:\n                Log.e(TAG, \"getActiveDevices: profile value is not valid\");\n        }\n        return activeDevices;\n    }\n\n    /**\n     * Attempts connection to all enabled and supported bluetooth profiles between the local and\n     * remote device\n     *\n     * @param device is the remote device with which to connect these profiles\n     * @return {@link BluetoothStatusCodes#SUCCESS} if all profiles connections are attempted, false\n     *         if an error occurred\n     */\n    @RequiresPermission(allOf = {\n            android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n            android.Manifest.permission.MODIFY_PHONE_STATE,\n    })\n    public int connectAllEnabledProfiles(BluetoothDevice device) {\n        if (!profileServicesRunning()) {\n            Log.e(TAG, \"connectAllEnabledProfiles: Not all profile services running\");\n            return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n        }\n\n        // Checks if any profiles are enabled and if so, only connect enabled profiles\n        if (isAnyProfileEnabled(device)) {\n            return connectEnabledProfiles(device);\n        }\n\n        int numProfilesConnected = 0;\n        ParcelUuid[] remoteDeviceUuids = getRemoteUuids(device);\n        ParcelUuid[] localDeviceUuids = mAdapterProperties.getUuids();\n\n        // All profile toggles disabled, so connects all supported profiles\n        if (mA2dpService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.A2DP, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting A2dp\");\n            // Set connection policy also connects the profile with CONNECTION_POLICY_ALLOWED\n            mA2dpService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mA2dpSinkService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.A2DP_SINK, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting A2dp Sink\");\n            mA2dpSinkService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHeadsetService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEADSET, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Headset Profile\");\n            mHeadsetService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHeadsetClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEADSET_CLIENT, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting HFP\");\n            mHeadsetClientService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mMapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.MAP_CLIENT, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting MAP\");\n            mMapClientService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHidHostService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HID_HOST, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Hid Host Profile\");\n            mHidHostService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mPanService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.PAN, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Pan Profile\");\n            mPanService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mPbapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.PBAP_CLIENT, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Pbap\");\n            mPbapClientService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHearingAidService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEARING_AID, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Hearing Aid Profile\");\n            mHearingAidService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HAP_CLIENT, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Hearing Access Client Profile\");\n            mHapClientService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mVolumeControlService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.VOLUME_CONTROL, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Volume Control Profile\");\n            mVolumeControlService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mCsipSetCoordinatorService != null\n                && isSupported(localDeviceUuids, remoteDeviceUuids,\n                        BluetoothProfile.CSIP_SET_COORDINATOR, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Coordinated Set Profile\");\n            mCsipSetCoordinatorService.setConnectionPolicy(\n                    device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mLeAudioService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.LE_AUDIO, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting LeAudio profile (BAP)\");\n            mLeAudioService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mBassClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.LE_AUDIO_BROADCAST_ASSISTANT, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting LE Broadcast Assistant Profile\");\n            mBassClientService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n\n        Log.i(TAG, \"connectAllEnabledProfiles: Number of Profiles Connected: \"\n                + numProfilesConnected);\n\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    /**\n     * Disconnects all enabled and supported bluetooth profiles between the local and remote device\n     *\n     * @param device is the remote device with which to disconnect these profiles\n     * @return true if all profiles successfully disconnected, false if an error occurred\n     */\n    @RequiresPermission(android.Manifest.permission.BLUETOOTH_PRIVILEGED)\n    public int disconnectAllEnabledProfiles(BluetoothDevice device) {\n        if (!profileServicesRunning()) {\n            Log.e(TAG, \"disconnectAllEnabledProfiles: Not all profile services bound\");\n            return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n        }\n\n        if (mA2dpService != null && mA2dpService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting A2dp\");\n            mA2dpService.disconnect(device);\n        }\n        if (mA2dpSinkService != null && mA2dpSinkService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting A2dp Sink\");\n            mA2dpSinkService.disconnect(device);\n        }\n        if (mHeadsetService != null && mHeadsetService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG,\n                    \"disconnectAllEnabledProfiles: Disconnecting Headset Profile\");\n            mHeadsetService.disconnect(device);\n        }\n        if (mHeadsetClientService != null && mHeadsetClientService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting HFP\");\n            mHeadsetClientService.disconnect(device);\n        }\n        if (mMapClientService != null && mMapClientService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting MAP Client\");\n            mMapClientService.disconnect(device);\n        }\n        if (mMapService != null && mMapService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting MAP\");\n            mMapService.disconnect(device);\n        }\n        if (mHidDeviceService != null && mHidDeviceService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Hid Device Profile\");\n            mHidDeviceService.disconnect(device);\n        }\n        if (mHidHostService != null && mHidHostService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Hid Host Profile\");\n            mHidHostService.disconnect(device);\n        }\n        if (mPanService != null && mPanService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Pan Profile\");\n            mPanService.disconnect(device);\n        }\n        if (mPbapClientService != null && mPbapClientService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Pbap Client\");\n            mPbapClientService.disconnect(device);\n        }\n        if (mPbapService != null && mPbapService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Pbap Server\");\n            mPbapService.disconnect(device);\n        }\n        if (mHearingAidService != null && mHearingAidService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Hearing Aid Profile\");\n            mHearingAidService.disconnect(device);\n        }\n        if (mHapClientService != null && mHapClientService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Hearing Access Profile Client\");\n            mHapClientService.disconnect(device);\n        }\n        if (mVolumeControlService != null && mVolumeControlService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Volume Control Profile\");\n            mVolumeControlService.disconnect(device);\n        }\n        if (mSapService != null && mSapService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Sap Profile\");\n            mSapService.disconnect(device);\n        }\n        if (mCsipSetCoordinatorService != null\n                && mCsipSetCoordinatorService.getConnectionState(device)\n                        == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Coordinater Set Profile\");\n            mCsipSetCoordinatorService.disconnect(device);\n        }\n        if (mLeAudioService != null && mLeAudioService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting LeAudio profile (BAP)\");\n            mLeAudioService.disconnect(device);\n        }\n        if (mBassClientService != null && mBassClientService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting \"\n                            + \"LE Broadcast Assistant Profile\");\n            mBassClientService.disconnect(device);\n        }\n\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    /**\n     * Same as API method {@link BluetoothDevice#getName()}\n     *\n     * @param device remote device of interest\n     * @return remote device name\n     */\n    public String getRemoteName(BluetoothDevice device) {\n        if (mRemoteDevices == null) {\n            return null;\n        }\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp == null) {\n            return null;\n        }\n        return deviceProp.getName();\n    }\n\n    /**\n     * Get UUIDs for service supported by a remote device\n     *\n     * @param device the remote device that we want to get UUIDs from\n     * @return\n     */\n    @VisibleForTesting\n    public ParcelUuid[] getRemoteUuids(BluetoothDevice device) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp == null) {\n            return null;\n        }\n        return deviceProp.getUuids();\n    }\n\n    public Set<IBluetoothConnectionCallback> getBluetoothConnectionCallbacks() {\n        return mBluetoothConnectionCallbacks;\n    }\n\n    /**\n     * Converts HCI disconnect reasons to Android disconnect reasons.\n     * <p>\n     * The HCI Error Codes used for ACL disconnect reasons propagated up from native code were\n     * copied from: {@link system/bt/stack/include/hci_error_code.h}.\n     * <p>\n     * These error codes are specified and described in Bluetooth Core Spec v5.1, Vol 2, Part D.\n     *\n     * @param hciReason is the raw HCI disconnect reason from native.\n     * @return the Android disconnect reason for apps.\n     */\n    static @BluetoothAdapter.BluetoothConnectionCallback.DisconnectReason int\n            hciToAndroidDisconnectReason(int hciReason) {\n        switch(hciReason) {\n            case /*HCI_SUCCESS*/ 0x00:\n            case /*HCI_ERR_UNSPECIFIED*/ 0x1F:\n            case /*HCI_ERR_UNDEFINED*/ 0xff:\n                return BluetoothStatusCodes.ERROR_UNKNOWN;\n            case /*HCI_ERR_ILLEGAL_COMMAND*/ 0x01:\n            case /*HCI_ERR_NO_CONNECTION*/ 0x02:\n            case /*HCI_ERR_HW_FAILURE*/ 0x03:\n            case /*HCI_ERR_DIFF_TRANSACTION_COLLISION*/ 0x2A:\n            case /*HCI_ERR_ROLE_SWITCH_PENDING*/ 0x32:\n            case /*HCI_ERR_ROLE_SWITCH_FAILED*/ 0x35:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_LOCAL;\n            case /*HCI_ERR_PAGE_TIMEOUT*/ 0x04:\n            case /*HCI_ERR_CONNECTION_TOUT*/ 0x08:\n            case /*HCI_ERR_HOST_TIMEOUT*/ 0x10:\n            case /*HCI_ERR_LMP_RESPONSE_TIMEOUT*/ 0x22:\n            case /*HCI_ERR_ADVERTISING_TIMEOUT*/ 0x3C:\n            case /*HCI_ERR_CONN_FAILED_ESTABLISHMENT*/ 0x3E:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_TIMEOUT;\n            case /*HCI_ERR_AUTH_FAILURE*/ 0x05:\n            case /*HCI_ERR_KEY_MISSING*/ 0x06:\n            case /*HCI_ERR_HOST_REJECT_SECURITY*/ 0x0E:\n            case /*HCI_ERR_REPEATED_ATTEMPTS*/ 0x17:\n            case /*HCI_ERR_PAIRING_NOT_ALLOWED*/ 0x18:\n            case /*HCI_ERR_ENCRY_MODE_NOT_ACCEPTABLE*/ 0x25:\n            case /*HCI_ERR_UNIT_KEY_USED*/ 0x26:\n            case /*HCI_ERR_PAIRING_WITH_UNIT_KEY_NOT_SUPPORTED*/ 0x29:\n            case /*HCI_ERR_INSUFFCIENT_SECURITY*/ 0x2F:\n            case /*HCI_ERR_HOST_BUSY_PAIRING*/ 0x38:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_SECURITY;\n            case /*HCI_ERR_MEMORY_FULL*/ 0x07:\n            case /*HCI_ERR_MAX_NUM_OF_CONNECTIONS*/ 0x09:\n            case /*HCI_ERR_MAX_NUM_OF_SCOS*/ 0x0A:\n            case /*HCI_ERR_COMMAND_DISALLOWED*/ 0x0C:\n            case /*HCI_ERR_HOST_REJECT_RESOURCES*/ 0x0D:\n            case /*HCI_ERR_LIMIT_REACHED*/ 0x43:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_RESOURCE_LIMIT_REACHED;\n            case /*HCI_ERR_CONNECTION_EXISTS*/ 0x0B:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_CONNECTION_ALREADY_EXISTS;\n            case /*HCI_ERR_HOST_REJECT_DEVICE*/ 0x0F:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_SYSTEM_POLICY;\n            case /*HCI_ERR_ILLEGAL_PARAMETER_FMT*/ 0x12:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_BAD_PARAMETERS;\n            case /*HCI_ERR_PEER_USER*/ 0x13:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_REMOTE_REQUEST;\n            case /*HCI_ERR_CONN_CAUSE_LOCAL_HOST*/ 0x16:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_LOCAL_REQUEST;\n            case /*HCI_ERR_UNSUPPORTED_REM_FEATURE*/ 0x1A:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_REMOTE;\n            case /*HCI_ERR_UNACCEPT_CONN_INTERVAL*/ 0x3B:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_BAD_PARAMETERS;\n            default:\n                Log.e(TAG, \"Invalid HCI disconnect reason: \" + hciReason);\n                return BluetoothStatusCodes.ERROR_UNKNOWN;\n        }\n    }\n\n    void logUserBondResponse(BluetoothDevice device, boolean accepted, int event) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            BluetoothStatsLog.write(BluetoothStatsLog.BLUETOOTH_BOND_STATE_CHANGED,\n                    obfuscateAddress(device), 0, device.getType(),\n                    BluetoothDevice.BOND_BONDING,\n                    event,\n                    accepted ? 0 : BluetoothDevice.UNBOND_REASON_AUTH_REJECTED);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    int getDeviceAccessFromPrefs(BluetoothDevice device, String prefFile) {\n        SharedPreferences prefs = getSharedPreferences(prefFile, Context.MODE_PRIVATE);\n        if (!prefs.contains(device.getAddress())) {\n            return BluetoothDevice.ACCESS_UNKNOWN;\n        }\n        return prefs.getBoolean(device.getAddress(), false)\n                ? BluetoothDevice.ACCESS_ALLOWED\n                : BluetoothDevice.ACCESS_REJECTED;\n    }\n\n    void setDeviceAccessFromPrefs(BluetoothDevice device, int value, String prefFile) {\n        SharedPreferences pref = getSharedPreferences(prefFile, Context.MODE_PRIVATE);\n        SharedPreferences.Editor editor = pref.edit();\n        if (value == BluetoothDevice.ACCESS_UNKNOWN) {\n            editor.remove(device.getAddress());\n        } else {\n            editor.putBoolean(device.getAddress(), value == BluetoothDevice.ACCESS_ALLOWED);\n        }\n        editor.apply();\n    }\n\n    public void setPhonebookAccessPermission(BluetoothDevice device, int value) {\n        setDeviceAccessFromPrefs(device, value, PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE);\n    }\n\n    public void setMessageAccessPermission(BluetoothDevice device, int value) {\n        setDeviceAccessFromPrefs(device, value, MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE);\n    }\n\n    public void setSimAccessPermission(BluetoothDevice device, int value) {\n        setDeviceAccessFromPrefs(device, value, SIM_ACCESS_PERMISSION_PREFERENCE_FILE);\n    }\n\n    public boolean isRpaOffloadSupported() {\n        return mAdapterProperties.isRpaOffloadSupported();\n    }\n\n    public int getNumOfOffloadedIrkSupported() {\n        return mAdapterProperties.getNumOfOffloadedIrkSupported();\n    }\n\n    public int getNumOfOffloadedScanFilterSupported() {\n        return mAdapterProperties.getNumOfOffloadedScanFilterSupported();\n    }\n\n    public int getOffloadedScanResultStorage() {\n        return mAdapterProperties.getOffloadedScanResultStorage();\n    }\n\n    public boolean isLe2MPhySupported() {\n        return mAdapterProperties.isLe2MPhySupported();\n    }\n\n    public boolean isLeCodedPhySupported() {\n        return mAdapterProperties.isLeCodedPhySupported();\n    }\n\n    public boolean isLeExtendedAdvertisingSupported() {\n        return mAdapterProperties.isLeExtendedAdvertisingSupported();\n    }\n\n    public boolean isLePeriodicAdvertisingSupported() {\n        return mAdapterProperties.isLePeriodicAdvertisingSupported();\n    }\n\n    /**\n     * Check if the LE audio broadcast source feature is supported.\n     *\n     * @return true, if the LE audio broadcast source is supported\n     */\n    public boolean isLeAudioBroadcastSourceSupported() {\n        return  BluetoothProperties.isProfileBapBroadcastSourceEnabled().orElse(false)\n                && mAdapterProperties.isLePeriodicAdvertisingSupported()\n                && mAdapterProperties.isLeExtendedAdvertisingSupported()\n                && mAdapterProperties.isLeIsochronousBroadcasterSupported();\n    }\n\n    /**\n     * Check if the LE audio broadcast assistant feature is supported.\n     *\n     * @return true, if the LE audio broadcast assistant is supported\n     */\n    public boolean isLeAudioBroadcastAssistantSupported() {\n        return mAdapterProperties.isLePeriodicAdvertisingSupported()\n            && mAdapterProperties.isLeExtendedAdvertisingSupported()\n            && (mAdapterProperties.isLePeriodicAdvertisingSyncTransferSenderSupported()\n                || mAdapterProperties.isLePeriodicAdvertisingSyncTransferRecipientSupported());\n    }\n\n    /**\n     * Check if the LE audio CIS central feature is supported.\n     *\n     * @return true, if the LE audio CIS central is supported\n     */\n    public boolean isLeConnectedIsochronousStreamCentralSupported() {\n        return mAdapterProperties.isLeConnectedIsochronousStreamCentralSupported();\n    }\n\n    public int getLeMaximumAdvertisingDataLength() {\n        return mAdapterProperties.getLeMaximumAdvertisingDataLength();\n    }\n\n    /**\n     * Get the maximum number of connected audio devices.\n     *\n     * @return the maximum number of connected audio devices\n     */\n    public int getMaxConnectedAudioDevices() {\n        return mAdapterProperties.getMaxConnectedAudioDevices();\n    }\n\n    /**\n     * Check whether A2DP offload is enabled.\n     *\n     * @return true if A2DP offload is enabled\n     */\n    public boolean isA2dpOffloadEnabled() {\n        return mAdapterProperties.isA2dpOffloadEnabled();\n    }\n\n    private BluetoothActivityEnergyInfo reportActivityInfo() {\n        if (mAdapterProperties.getState() != BluetoothAdapter.STATE_ON\n                || !mAdapterProperties.isActivityAndEnergyReportingSupported()) {\n            return null;\n        }\n\n        // Pull the data. The callback will notify mEnergyInfoLock.\n        readEnergyInfo();\n\n        synchronized (mEnergyInfoLock) {\n            try {\n                mEnergyInfoLock.wait(CONTROLLER_ENERGY_UPDATE_TIMEOUT_MILLIS);\n            } catch (InterruptedException e) {\n                // Just continue, the energy data may be stale but we won't miss anything next time\n                // we query.\n            }\n\n            final BluetoothActivityEnergyInfo info =\n                    new BluetoothActivityEnergyInfo(SystemClock.elapsedRealtime(),\n                            mStackReportedState, mTxTimeTotalMs, mRxTimeTotalMs, mIdleTimeTotalMs,\n                            mEnergyUsedTotalVoltAmpSecMicro);\n\n            // Count the number of entries that have byte counts > 0\n            int arrayLen = 0;\n            for (int i = 0; i < mUidTraffic.size(); i++) {\n                final UidTraffic traffic = mUidTraffic.valueAt(i);\n                if (traffic.getTxBytes() != 0 || traffic.getRxBytes() != 0) {\n                    arrayLen++;\n                }\n            }\n\n            // Copy the traffic objects whose byte counts are > 0\n            final List<UidTraffic> result = new ArrayList<>();\n            int putIdx = 0;\n            for (int i = 0; i < mUidTraffic.size(); i++) {\n                final UidTraffic traffic = mUidTraffic.valueAt(i);\n                if (traffic.getTxBytes() != 0 || traffic.getRxBytes() != 0) {\n                    result.add(traffic.clone());\n                }\n            }\n\n            info.setUidTraffic(result);\n\n            return info;\n        }\n    }\n\n    public int getTotalNumOfTrackableAdvertisements() {\n        return mAdapterProperties.getTotalNumOfTrackableAdvertisements();\n    }\n\n    /**\n     * Notify the UID and package name of the app, and the address of associated active device\n     *\n     * @param source The attribution source that starts the activity\n     * @param deviceAddress The address of the active device associated with the app\n     */\n    public void notifyActivityAttributionInfo(AttributionSource source, String deviceAddress) {\n        mActivityAttributionService.notifyActivityAttributionInfo(\n                source.getUid(), source.getPackageName(), deviceAddress);\n    }\n\n    private static int convertScanModeToHal(int mode) {\n        switch (mode) {\n            case BluetoothAdapter.SCAN_MODE_NONE:\n                return AbstractionLayer.BT_SCAN_MODE_NONE;\n            case BluetoothAdapter.SCAN_MODE_CONNECTABLE:\n                return AbstractionLayer.BT_SCAN_MODE_CONNECTABLE;\n            case BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE:\n                return AbstractionLayer.BT_SCAN_MODE_CONNECTABLE_DISCOVERABLE;\n        }\n        // errorLog(\"Incorrect scan mode in convertScanModeToHal\");\n        return -1;\n    }\n\n    static int convertScanModeFromHal(int mode) {\n        switch (mode) {\n            case AbstractionLayer.BT_SCAN_MODE_NONE:\n                return BluetoothAdapter.SCAN_MODE_NONE;\n            case AbstractionLayer.BT_SCAN_MODE_CONNECTABLE:\n                return BluetoothAdapter.SCAN_MODE_CONNECTABLE;\n            case AbstractionLayer.BT_SCAN_MODE_CONNECTABLE_DISCOVERABLE:\n                return BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE;\n        }\n        //errorLog(\"Incorrect scan mode in convertScanModeFromHal\");\n        return -1;\n    }\n\n    // This function is called from JNI. It allows native code to set a single wake\n    // alarm. If an alarm is already pending and a new request comes in, the alarm\n    // will be rescheduled (i.e. the previously set alarm will be cancelled).\n    private boolean setWakeAlarm(long delayMillis, boolean shouldWake) {\n        synchronized (this) {\n            if (mPendingAlarm != null) {\n                mAlarmManager.cancel(mPendingAlarm);\n            }\n\n            long wakeupTime = SystemClock.elapsedRealtime() + delayMillis;\n            int type = shouldWake ? AlarmManager.ELAPSED_REALTIME_WAKEUP\n                    : AlarmManager.ELAPSED_REALTIME;\n\n            Intent intent = new Intent(ACTION_ALARM_WAKEUP);\n            mPendingAlarm =\n                    PendingIntent.getBroadcast(this, 0, intent, PendingIntent.FLAG_ONE_SHOT\n                            | PendingIntent.FLAG_IMMUTABLE);\n            mAlarmManager.setExact(type, wakeupTime, mPendingAlarm);\n            return true;\n        }\n    }\n\n    // This function is called from JNI. It allows native code to acquire a single wake lock.\n    // If the wake lock is already held, this function returns success. Although this function\n    // only supports acquiring a single wake lock at a time right now, it will eventually be\n    // extended to allow acquiring an arbitrary number of wake locks. The current interface\n    // takes |lockName| as a parameter in anticipation of that implementation.\n    private boolean acquireWakeLock(String lockName) {\n        synchronized (this) {\n            if (mWakeLock == null) {\n                mWakeLockName = lockName;\n                mWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, lockName);\n            }\n\n            if (!mWakeLock.isHeld()) {\n                mWakeLock.acquire();\n            }\n        }\n        return true;\n    }\n\n    // This function is called from JNI. It allows native code to release a wake lock acquired\n    // by |acquireWakeLock|. If the wake lock is not held, this function returns failure.\n    // Note that the release() call is also invoked by {@link #cleanup()} so a synchronization is\n    // needed here. See the comment for |acquireWakeLock| for an explanation of the interface.\n    private boolean releaseWakeLock(String lockName) {\n        synchronized (this) {\n            if (mWakeLock == null) {\n                errorLog(\"Repeated wake lock release; aborting release: \" + lockName);\n                return false;\n            }\n\n            if (mWakeLock.isHeld()) {\n                mWakeLock.release();\n            }\n        }\n        return true;\n    }\n\n    private void energyInfoCallback(int status, int ctrlState, long txTime, long rxTime,\n            long idleTime, long energyUsed, UidTraffic[] data) throws RemoteException {\n        if (ctrlState >= BluetoothActivityEnergyInfo.BT_STACK_STATE_INVALID\n                && ctrlState <= BluetoothActivityEnergyInfo.BT_STACK_STATE_STATE_IDLE) {\n            // Energy is product of mA, V and ms. If the chipset doesn't\n            // report it, we have to compute it from time\n            if (energyUsed == 0) {\n                try {\n                    final long txMah = Math.multiplyExact(txTime, getTxCurrentMa());\n                    final long rxMah = Math.multiplyExact(rxTime, getRxCurrentMa());\n                    final long idleMah = Math.multiplyExact(idleTime, getIdleCurrentMa());\n                    energyUsed = (long) (Math.addExact(Math.addExact(txMah, rxMah), idleMah)\n                            * getOperatingVolt());\n                } catch (ArithmeticException e) {\n                    Log.wtf(TAG, \"overflow in bluetooth energy callback\", e);\n                    // Energy is already 0 if the exception was thrown.\n                }\n            }\n\n            synchronized (mEnergyInfoLock) {\n                mStackReportedState = ctrlState;\n                long totalTxTimeMs;\n                long totalRxTimeMs;\n                long totalIdleTimeMs;\n                long totalEnergy;\n                try {\n                    totalTxTimeMs = Math.addExact(mTxTimeTotalMs, txTime);\n                    totalRxTimeMs = Math.addExact(mRxTimeTotalMs, rxTime);\n                    totalIdleTimeMs = Math.addExact(mIdleTimeTotalMs, idleTime);\n                    totalEnergy = Math.addExact(mEnergyUsedTotalVoltAmpSecMicro, energyUsed);\n                } catch (ArithmeticException e) {\n                    // This could be because we accumulated a lot of time, or we got a very strange\n                    // value from the controller (more likely). Discard this data.\n                    Log.wtf(TAG, \"overflow in bluetooth energy callback\", e);\n                    totalTxTimeMs = mTxTimeTotalMs;\n                    totalRxTimeMs = mRxTimeTotalMs;\n                    totalIdleTimeMs = mIdleTimeTotalMs;\n                    totalEnergy = mEnergyUsedTotalVoltAmpSecMicro;\n                }\n\n                mTxTimeTotalMs = totalTxTimeMs;\n                mRxTimeTotalMs = totalRxTimeMs;\n                mIdleTimeTotalMs = totalIdleTimeMs;\n                mEnergyUsedTotalVoltAmpSecMicro = totalEnergy;\n\n                for (UidTraffic traffic : data) {\n                    UidTraffic existingTraffic = mUidTraffic.get(traffic.getUid());\n                    if (existingTraffic == null) {\n                        mUidTraffic.put(traffic.getUid(), traffic);\n                    } else {\n                        existingTraffic.addRxBytes(traffic.getRxBytes());\n                        existingTraffic.addTxBytes(traffic.getTxBytes());\n                    }\n                }\n                mEnergyInfoLock.notifyAll();\n            }\n        }\n\n        verboseLog(\"energyInfoCallback() status = \" + status + \"txTime = \" + txTime + \"rxTime = \"\n                + rxTime + \"idleTime = \" + idleTime + \"energyUsed = \" + energyUsed + \"ctrlState = \"\n                + ctrlState + \"traffic = \" + Arrays.toString(data));\n    }\n\n    /**\n     * Update metadata change to registered listeners\n     */\n    @VisibleForTesting\n    public void metadataChanged(String address, int key, byte[] value) {\n        BluetoothDevice device = mRemoteDevices.getDevice(Utils.getBytesFromAddress(address));\n        if (mMetadataListeners.containsKey(device)) {\n            ArrayList<IBluetoothMetadataListener> list = mMetadataListeners.get(device);\n            for (IBluetoothMetadataListener listener : list) {\n                try {\n                    listener.onMetadataChanged(device, key, value);\n                } catch (RemoteException e) {\n                    Log.w(TAG, \"RemoteException when onMetadataChanged\");\n                }\n            }\n        }\n    }\n\n    private int getIdleCurrentMa() {\n        return BluetoothProperties.getHardwareIdleCurrentMa().orElse(0);\n    }\n\n    private int getTxCurrentMa() {\n        return BluetoothProperties.getHardwareTxCurrentMa().orElse(0);\n    }\n\n    private int getRxCurrentMa() {\n        return BluetoothProperties.getHardwareRxCurrentMa().orElse(0);\n    }\n\n    private double getOperatingVolt() {\n        return BluetoothProperties.getHardwareOperatingVoltageMv().orElse(0) / 1000.0;\n    }\n\n    @VisibleForTesting\n    protected RemoteDevices getRemoteDevices() {\n        return mRemoteDevices;\n    }\n\n    @Override\n    protected void dump(FileDescriptor fd, PrintWriter writer, String[] args) {\n        if (args.length == 0) {\n            writer.println(\"Skipping dump in APP SERVICES, see bluetooth_manager section.\");\n            writer.println(\"Use --print argument for dumpsys direct from AdapterService.\");\n            return;\n        }\n\n        if (\"set-test-mode\".equals(args[0])) {\n            final boolean testModeEnabled = \"enabled\".equalsIgnoreCase(args[1]);\n            for (ProfileService profile : mRunningProfiles) {\n                profile.setTestModeEnabled(testModeEnabled);\n            }\n            mTestModeEnabled = testModeEnabled;\n            return;\n        }\n\n        verboseLog(\"dumpsys arguments, check for protobuf output: \" + TextUtils.join(\" \", args));\n        if (args[0].equals(\"--proto-bin\")) {\n            dumpMetrics(fd);\n            return;\n        }\n\n        writer.println();\n        mAdapterProperties.dump(fd, writer, args);\n        writer.println(\"mSnoopLogSettingAtEnable = \" + mSnoopLogSettingAtEnable);\n        writer.println(\"mDefaultSnoopLogSettingAtEnable = \" + mDefaultSnoopLogSettingAtEnable);\n\n        writer.println();\n        writer.println(\"Enabled Profile Services:\");\n        for (Class profile : Config.getSupportedProfiles()) {\n            writer.println(\"  \" + profile.getSimpleName());\n        }\n        writer.println();\n\n        mAdapterStateMachine.dump(fd, writer, args);\n\n        StringBuilder sb = new StringBuilder();\n        for (ProfileService profile : mRegisteredProfiles) {\n            profile.dump(sb);\n        }\n        mSilenceDeviceManager.dump(fd, writer, args);\n        mDatabaseManager.dump(writer);\n\n        writer.write(sb.toString());\n        writer.flush();\n\n        dumpNative(fd, args);\n    }\n\n    private void dumpMetrics(FileDescriptor fd) {\n        BluetoothMetricsProto.BluetoothLog.Builder metricsBuilder =\n                BluetoothMetricsProto.BluetoothLog.newBuilder();\n        byte[] nativeMetricsBytes = dumpMetricsNative();\n        debugLog(\"dumpMetrics: native metrics size is \" + nativeMetricsBytes.length);\n        if (nativeMetricsBytes.length > 0) {\n            try {\n                metricsBuilder.mergeFrom(nativeMetricsBytes);\n            } catch (InvalidProtocolBufferException ex) {\n                Log.w(TAG, \"dumpMetrics: problem parsing metrics protobuf, \" + ex.getMessage());\n                return;\n            }\n        }\n        metricsBuilder.setNumBondedDevices(getBondedDevices().length);\n        MetricsLogger.dumpProto(metricsBuilder);\n        for (ProfileService profile : mRegisteredProfiles) {\n            profile.dumpProto(metricsBuilder);\n        }\n        byte[] metricsBytes = Base64.encode(metricsBuilder.build().toByteArray(), Base64.DEFAULT);\n        debugLog(\"dumpMetrics: combined metrics size is \" + metricsBytes.length);\n        try (FileOutputStream protoOut = new FileOutputStream(fd)) {\n            protoOut.write(metricsBytes);\n        } catch (IOException e) {\n            errorLog(\"dumpMetrics: error writing combined protobuf to fd, \" + e.getMessage());\n        }\n    }\n\n    private void debugLog(String msg) {\n        if (DBG) {\n            Log.d(TAG, msg);\n        }\n    }\n\n    private void verboseLog(String msg) {\n        if (VERBOSE) {\n            Log.v(TAG, msg);\n        }\n    }\n\n    private void errorLog(String msg) {\n        Log.e(TAG, msg);\n    }\n\n    private final BroadcastReceiver mAlarmBroadcastReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            synchronized (AdapterService.this) {\n                mPendingAlarm = null;\n                alarmFiredNative();\n            }\n        }\n    };\n\n    private boolean isCommonCriteriaMode() {\n        return getSystemService(DevicePolicyManager.class).isCommonCriteriaModeEnabled(null);\n    }\n\n    @SuppressLint(\"AndroidFrameworkRequiresPermission\")\n    private void enforceBluetoothPrivilegedPermissionIfNeeded(OobData remoteP192Data,\n            OobData remoteP256Data) {\n        if (remoteP192Data != null || remoteP256Data != null) {\n            enforceBluetoothPrivilegedPermission(this);\n        }\n    }\n\n    // Boolean flags\n    private static final String GD_CORE_FLAG = \"INIT_gd_core\";\n    private static final String GD_ADVERTISING_FLAG = \"INIT_gd_advertising\";\n    private static final String GD_SCANNING_FLAG = \"INIT_gd_scanning\";\n    private static final String GD_HCI_FLAG = \"INIT_gd_hci\";\n    private static final String GD_CONTROLLER_FLAG = \"INIT_gd_controller\";\n    private static final String GD_ACL_FLAG = \"INIT_gd_acl\";\n    private static final String GD_L2CAP_FLAG = \"INIT_gd_l2cap\";\n    private static final String GD_RUST_FLAG = \"INIT_gd_rust\";\n    private static final String GD_LINK_POLICY_FLAG = \"INIT_gd_link_policy\";\n    private static final String GATT_ROBUST_CACHING_FLAG = \"INIT_gatt_robust_caching\";\n    private static final String IRK_ROTATION_FLAG = \"INIT_irk_rotation\";\n\n    /**\n     * Logging flags logic (only applies to DEBUG and VERBOSE levels):\n     * if LOG_TAG in LOGGING_DEBUG_DISABLED_FOR_TAGS_FLAG:\n     *   DO NOT LOG\n     * else if LOG_TAG in LOGGING_DEBUG_ENABLED_FOR_TAGS_FLAG:\n     *   DO LOG\n     * else if LOGGING_DEBUG_ENABLED_FOR_ALL_FLAG:\n     *   DO LOG\n     * else:\n     *   DO NOT LOG\n     */\n    private static final String LOGGING_DEBUG_ENABLED_FOR_ALL_FLAG =\n            \"INIT_logging_debug_enabled_for_all\";\n    // String flags\n    // Comma separated tags\n    private static final String LOGGING_DEBUG_ENABLED_FOR_TAGS_FLAG =\n            \"INIT_logging_debug_enabled_for_tags\";\n    private static final String LOGGING_DEBUG_DISABLED_FOR_TAGS_FLAG =\n            \"INIT_logging_debug_disabled_for_tags\";\n    private static final String BTAA_HCI_LOG_FLAG = \"INIT_btaa_hci\";\n\n    private String[] getInitFlags() {\n        ArrayList<String> initFlags = new ArrayList<>();\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_CORE_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_CORE_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_ADVERTISING_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_ADVERTISING_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_SCANNING_FLAG,\n                Config.isGdEnabledUpToScanningLayer())) {\n            initFlags.add(String.format(\"%s=%s\", GD_SCANNING_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_HCI_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_HCI_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_CONTROLLER_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_CONTROLLER_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_ACL_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_ACL_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_L2CAP_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_L2CAP_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_RUST_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_RUST_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_LINK_POLICY_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_LINK_POLICY_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH,\n                GATT_ROBUST_CACHING_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GATT_ROBUST_CACHING_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, IRK_ROTATION_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", IRK_ROTATION_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH,\n                LOGGING_DEBUG_ENABLED_FOR_ALL_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", LOGGING_DEBUG_ENABLED_FOR_ALL_FLAG, \"true\"));\n        }\n        String debugLoggingEnabledTags = DeviceConfig.getString(DeviceConfig.NAMESPACE_BLUETOOTH,\n                LOGGING_DEBUG_ENABLED_FOR_TAGS_FLAG, \"\");\n        if (!debugLoggingEnabledTags.isEmpty()) {\n            initFlags.add(String.format(\"%s=%s\", LOGGING_DEBUG_ENABLED_FOR_TAGS_FLAG,\n                    debugLoggingEnabledTags));\n        }\n        String debugLoggingDisabledTags = DeviceConfig.getString(DeviceConfig.NAMESPACE_BLUETOOTH,\n                LOGGING_DEBUG_DISABLED_FOR_TAGS_FLAG, \"\");\n        if (!debugLoggingDisabledTags.isEmpty()) {\n            initFlags.add(String.format(\"%s=%s\", LOGGING_DEBUG_DISABLED_FOR_TAGS_FLAG,\n                    debugLoggingDisabledTags));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, BTAA_HCI_LOG_FLAG, true)) {\n            initFlags.add(String.format(\"%s=%s\", BTAA_HCI_LOG_FLAG, \"true\"));\n        }\n        return initFlags.toArray(new String[0]);\n    }\n\n    private final Object mDeviceConfigLock = new Object();\n\n    /**\n     * Predicate that can be applied to names to determine if a device is\n     * well-known to be used for physical location.\n     */\n    @GuardedBy(\"mDeviceConfigLock\")\n    private Predicate<String> mLocationDenylistName = (v) -> false;\n\n    /**\n     * Predicate that can be applied to MAC addresses to determine if a device\n     * is well-known to be used for physical location.\n     */\n    @GuardedBy(\"mDeviceConfigLock\")\n    private Predicate<byte[]> mLocationDenylistMac = (v) -> false;\n\n    /**\n     * Predicate that can be applied to Advertising Data payloads to determine\n     * if a device is well-known to be used for physical location.\n     */\n    @GuardedBy(\"mDeviceConfigLock\")\n    private Predicate<byte[]> mLocationDenylistAdvertisingData = (v) -> false;\n\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScanQuotaCount = DeviceConfigListener.DEFAULT_SCAN_QUOTA_COUNT;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private long mScanQuotaWindowMillis = DeviceConfigListener.DEFAULT_SCAN_QUOTA_WINDOW_MILLIS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private long mScanTimeoutMillis = DeviceConfigListener.DEFAULT_SCAN_TIMEOUT_MILLIS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScanUpgradeDurationMillis =\n            DeviceConfigListener.DEFAULT_SCAN_UPGRADE_DURATION_MILLIS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScreenOffLowPowerWindowMillis =\n            ScanManager.SCAN_MODE_SCREEN_OFF_LOW_POWER_WINDOW_MS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScreenOffLowPowerIntervalMillis =\n            ScanManager.SCAN_MODE_SCREEN_OFF_LOW_POWER_INTERVAL_MS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScreenOffBalancedWindowMillis =\n            ScanManager.SCAN_MODE_SCREEN_OFF_BALANCED_WINDOW_MS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScreenOffBalancedIntervalMillis =\n            ScanManager.SCAN_MODE_SCREEN_OFF_BALANCED_INTERVAL_MS;\n\n    public @NonNull Predicate<String> getLocationDenylistName() {\n        synchronized (mDeviceConfigLock) {\n            return mLocationDenylistName;\n        }\n    }\n\n    public @NonNull Predicate<byte[]> getLocationDenylistMac() {\n        synchronized (mDeviceConfigLock) {\n            return mLocationDenylistMac;\n        }\n    }\n\n    public @NonNull Predicate<byte[]> getLocationDenylistAdvertisingData() {\n        synchronized (mDeviceConfigLock) {\n            return mLocationDenylistAdvertisingData;\n        }\n    }\n\n    public static int getScanQuotaCount() {\n        if (sAdapterService == null) {\n            return DeviceConfigListener.DEFAULT_SCAN_QUOTA_COUNT;\n        }\n\n        synchronized (sAdapterService.mDeviceConfigLock) {\n            return sAdapterService.mScanQuotaCount;\n        }\n    }\n\n    public static long getScanQuotaWindowMillis() {\n        if (sAdapterService == null) {\n            return DeviceConfigListener.DEFAULT_SCAN_QUOTA_WINDOW_MILLIS;\n        }\n\n        synchronized (sAdapterService.mDeviceConfigLock) {\n            return sAdapterService.mScanQuotaWindowMillis;\n        }\n    }\n\n    public static long getScanTimeoutMillis() {\n        if (sAdapterService == null) {\n            return DeviceConfigListener.DEFAULT_SCAN_TIMEOUT_MILLIS;\n        }\n\n        synchronized (sAdapterService.mDeviceConfigLock) {\n            return sAdapterService.mScanTimeoutMillis;\n        }\n    }\n\n    /**\n     * Returns scan upgrade duration in millis.\n     */\n    public long getScanUpgradeDurationMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScanUpgradeDurationMillis;\n        }\n    }\n\n    /**\n     * Returns SCREEN_OFF_BALANCED scan window in millis.\n     */\n    public int getScreenOffBalancedWindowMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScreenOffBalancedWindowMillis;\n        }\n    }\n\n    /**\n     * Returns SCREEN_OFF_BALANCED scan interval in millis.\n     */\n    public int getScreenOffBalancedIntervalMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScreenOffBalancedIntervalMillis;\n        }\n    }\n\n    /**\n     * Returns SCREEN_OFF low power scan window in millis.\n     */\n    public int getScreenOffLowPowerWindowMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScreenOffLowPowerWindowMillis;\n        }\n    }\n\n    /**\n     * Returns SCREEN_OFF low power scan interval in millis.\n     */\n    public int getScreenOffLowPowerIntervalMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScreenOffLowPowerIntervalMillis;\n        }\n    }\n\n    private final DeviceConfigListener mDeviceConfigListener = new DeviceConfigListener();\n\n    private class DeviceConfigListener implements DeviceConfig.OnPropertiesChangedListener {\n        private static final String LOCATION_DENYLIST_NAME =\n                \"location_denylist_name\";\n        private static final String LOCATION_DENYLIST_MAC =\n                \"location_denylist_mac\";\n        private static final String LOCATION_DENYLIST_ADVERTISING_DATA =\n                \"location_denylist_advertising_data\";\n        private static final String SCAN_QUOTA_COUNT =\n                \"scan_quota_count\";\n        private static final String SCAN_QUOTA_WINDOW_MILLIS =\n                \"scan_quota_window_millis\";\n        private static final String SCAN_TIMEOUT_MILLIS =\n                \"scan_timeout_millis\";\n        private static final String SCAN_UPGRADE_DURATION_MILLIS =\n                \"scan_upgrade_duration_millis\";\n        private static final String SCREEN_OFF_LOW_POWER_WINDOW_MILLIS =\n                \"screen_off_low_power_window_millis\";\n        private static final String SCREEN_OFF_LOW_POWER_INTERVAL_MILLIS =\n                \"screen_off_low_power_interval_millis\";\n        private static final String SCREEN_OFF_BALANCED_WINDOW_MILLIS =\n                \"screen_off_balanced_window_millis\";\n        private static final String SCREEN_OFF_BALANCED_INTERVAL_MILLIS =\n                \"screen_off_balanced_interval_millis\";\n\n        /**\n         * Default denylist which matches Eddystone and iBeacon payloads.\n         */\n        private static final String DEFAULT_LOCATION_DENYLIST_ADVERTISING_DATA =\n                \"\u22860016AAFE/00FFFFFF,\u228600FF4C0002/00FFFFFFFF\";\n\n        private static final int DEFAULT_SCAN_QUOTA_COUNT = 5;\n        private static final long DEFAULT_SCAN_QUOTA_WINDOW_MILLIS = 30 * SECOND_IN_MILLIS;\n        private static final long DEFAULT_SCAN_TIMEOUT_MILLIS = 30 * MINUTE_IN_MILLIS;\n        private static final int DEFAULT_SCAN_UPGRADE_DURATION_MILLIS = (int) SECOND_IN_MILLIS * 6;\n\n        public void start() {\n            DeviceConfig.addOnPropertiesChangedListener(DeviceConfig.NAMESPACE_BLUETOOTH,\n                    BackgroundThread.getExecutor(), this);\n            onPropertiesChanged(DeviceConfig.getProperties(DeviceConfig.NAMESPACE_BLUETOOTH));\n        }\n\n        @Override\n        public void onPropertiesChanged(DeviceConfig.Properties properties) {\n            synchronized (mDeviceConfigLock) {\n                final String name = properties.getString(LOCATION_DENYLIST_NAME, null);\n                mLocationDenylistName = !TextUtils.isEmpty(name)\n                        ? Pattern.compile(name).asPredicate()\n                        : (v) -> false;\n                mLocationDenylistMac = BytesMatcher\n                        .decode(properties.getString(LOCATION_DENYLIST_MAC, null));\n                mLocationDenylistAdvertisingData = BytesMatcher\n                        .decode(properties.getString(LOCATION_DENYLIST_ADVERTISING_DATA,\n                                DEFAULT_LOCATION_DENYLIST_ADVERTISING_DATA));\n                mScanQuotaCount = properties.getInt(SCAN_QUOTA_COUNT,\n                        DEFAULT_SCAN_QUOTA_COUNT);\n                mScanQuotaWindowMillis = properties.getLong(SCAN_QUOTA_WINDOW_MILLIS,\n                        DEFAULT_SCAN_QUOTA_WINDOW_MILLIS);\n                mScanTimeoutMillis = properties.getLong(SCAN_TIMEOUT_MILLIS,\n                        DEFAULT_SCAN_TIMEOUT_MILLIS);\n                mScanUpgradeDurationMillis = properties.getInt(SCAN_UPGRADE_DURATION_MILLIS,\n                        DEFAULT_SCAN_UPGRADE_DURATION_MILLIS);\n                mScreenOffLowPowerWindowMillis = properties.getInt(\n                        SCREEN_OFF_LOW_POWER_WINDOW_MILLIS,\n                        ScanManager.SCAN_MODE_SCREEN_OFF_LOW_POWER_WINDOW_MS);\n                mScreenOffLowPowerIntervalMillis = properties.getInt(\n                        SCREEN_OFF_LOW_POWER_INTERVAL_MILLIS,\n                        ScanManager.SCAN_MODE_SCREEN_OFF_LOW_POWER_INTERVAL_MS);\n                mScreenOffBalancedWindowMillis = properties.getInt(\n                        SCREEN_OFF_BALANCED_WINDOW_MILLIS,\n                        ScanManager.SCAN_MODE_SCREEN_OFF_BALANCED_WINDOW_MS);\n                mScreenOffBalancedIntervalMillis = properties.getInt(\n                        SCREEN_OFF_BALANCED_INTERVAL_MILLIS,\n                        ScanManager.SCAN_MODE_SCREEN_OFF_BALANCED_INTERVAL_MS);\n            }\n        }\n    }\n\n    /**\n     *  Obfuscate Bluetooth MAC address into a PII free ID string\n     *\n     *  @param device Bluetooth device whose MAC address will be obfuscated\n     *  @return a byte array that is unique to this MAC address on this device,\n     *          or empty byte array when either device is null or obfuscateAddressNative fails\n     */\n    public byte[] obfuscateAddress(BluetoothDevice device) {\n        if (device == null) {\n            return new byte[0];\n        }\n        return obfuscateAddressNative(Utils.getByteAddress(device));\n    }\n\n    /**\n     * Get dynamic audio buffer size supported type\n     *\n     * @return support <p>Possible values are\n     * {@link BluetoothA2dp#DYNAMIC_BUFFER_SUPPORT_NONE},\n     * {@link BluetoothA2dp#DYNAMIC_BUFFER_SUPPORT_A2DP_OFFLOAD},\n     * {@link BluetoothA2dp#DYNAMIC_BUFFER_SUPPORT_A2DP_SOFTWARE_ENCODING}.\n     */\n    public int getDynamicBufferSupport() {\n        return mAdapterProperties.getDynamicBufferSupport();\n    }\n\n    /**\n     * Get dynamic audio buffer size\n     *\n     * @return BufferConstraints\n     */\n    public BufferConstraints getBufferConstraints() {\n        return mAdapterProperties.getBufferConstraints();\n    }\n\n    /**\n     * Set dynamic audio buffer size\n     *\n     * @param codec Audio codec\n     * @param value buffer millis\n     * @return true if the settings is successful, false otherwise\n     */\n    public boolean setBufferLengthMillis(int codec, int value) {\n        return mAdapterProperties.setBufferLengthMillis(codec, value);\n    }\n\n    /**\n     *  Get an incremental id of Bluetooth metrics and log\n     *\n     *  @param device Bluetooth device\n     *  @return int of id for Bluetooth metrics and logging, 0 if the device is invalid\n     */\n    public int getMetricId(BluetoothDevice device) {\n        if (device == null) {\n            return 0;\n        }\n        return getMetricIdNative(Utils.getByteAddress(device));\n    }\n\n    /**\n     *  Allow audio low latency\n     *\n     *  @param allowed true if audio low latency is being allowed\n     *  @param device device whose audio low latency will be allowed or disallowed\n     *  @return boolean true if audio low latency is successfully allowed or disallowed\n     */\n    public boolean allowLowLatencyAudio(boolean allowed, BluetoothDevice device) {\n        return allowLowLatencyAudioNative(allowed, Utils.getByteAddress(device));\n    }\n\n    /**\n     * Sets the battery level of the remote device\n     */\n    public void setBatteryLevel(BluetoothDevice device, int batteryLevel) {\n        mRemoteDevices.updateBatteryLevel(device, batteryLevel);\n    }\n\n    static native void classInitNative();\n\n    native boolean initNative(boolean startRestricted, boolean isCommonCriteriaMode,\n            int configCompareResult, String[] initFlags, boolean isAtvDevice,\n            String userDataDirectory);\n\n    native void cleanupNative();\n\n    /*package*/\n    native boolean enableNative();\n\n    /*package*/\n    native boolean disableNative();\n\n    /*package*/\n    native boolean setAdapterPropertyNative(int type, byte[] val);\n\n    /*package*/\n    native boolean getAdapterPropertiesNative();\n\n    /*package*/\n    native boolean getAdapterPropertyNative(int type);\n\n    /*package*/\n    native boolean setAdapterPropertyNative(int type);\n\n    /*package*/\n    native boolean setDevicePropertyNative(byte[] address, int type, byte[] val);\n\n    /*package*/\n    native boolean getDevicePropertyNative(byte[] address, int type);\n\n    /*package*/\n    public native boolean createBondNative(byte[] address, int transport);\n\n    /*package*/\n    native boolean createBondOutOfBandNative(byte[] address, int transport,\n            OobData p192Data, OobData p256Data);\n\n    /*package*/\n    public native boolean removeBondNative(byte[] address);\n\n    /*package*/\n    native boolean cancelBondNative(byte[] address);\n\n    /*package*/\n    native void generateLocalOobDataNative(int transport);\n\n    /*package*/\n    native boolean sdpSearchNative(byte[] address, byte[] uuid);\n\n    /*package*/\n    native int getConnectionStateNative(byte[] address);\n\n    private native boolean startDiscoveryNative();\n\n    private native boolean cancelDiscoveryNative();\n\n    private native boolean pinReplyNative(byte[] address, boolean accept, int len, byte[] pin);\n\n    private native boolean sspReplyNative(byte[] address, int type, boolean accept, int passkey);\n\n    /*package*/\n    native boolean getRemoteServicesNative(byte[] address, int transport);\n\n    /*package*/\n    native boolean getRemoteMasInstancesNative(byte[] address);\n\n    private native int readEnergyInfo();\n\n    /*package*/\n    native boolean factoryResetNative();\n\n    private native void alarmFiredNative();\n\n    private native void dumpNative(FileDescriptor fd, String[] arguments);\n\n    private native byte[] dumpMetricsNative();\n\n    private native byte[] obfuscateAddressNative(byte[] address);\n\n    native boolean setBufferLengthMillisNative(int codec, int value);\n\n    private native int getMetricIdNative(byte[] address);\n\n    /*package*/ native int connectSocketNative(\n            byte[] address, int type, byte[] uuid, int port, int flag, int callingUid);\n\n    /*package*/ native int createSocketChannelNative(\n            int type, String serviceName, byte[] uuid, int port, int flag, int callingUid);\n\n    /*package*/ native void requestMaximumTxDataLengthNative(byte[] address);\n\n    private native boolean allowLowLatencyAudioNative(boolean allowed, byte[] address);\n\n    // Returns if this is a mock object. This is currently used in testing so that we may not call\n    // System.exit() while finalizing the object. Otherwise GC of mock objects unfortunately ends up\n    // calling finalize() which in turn calls System.exit() and the process crashes.\n    //\n    // Mock this in your testing framework to return true to avoid the mentioned behavior. In\n    // production this has no effect.\n    public boolean isMock() {\n        return false;\n    }\n}\n```"
                    }
                ]
            },
            {
                "downstream_version": "14",
                "branch_used": "android14-release",
                "downstream_patch": "038b1e8626399ff3f374d5af987e3efd64a19321",
                "repo_path": "android_repos/Bluetooth",
                "result": "failure",
                "downstream_patch_content": "commit 038b1e8626399ff3f374d5af987e3efd64a19321\nAuthor: Brian Delwiche <delwiche@google.com>\nDate:   Thu Nov 14 00:35:48 2024 +0000\n\n    Reset permissions for not bonded device\n    \n    According to the PBAP specification,\n    The PSE user shall have to confirm at least the first Phone Book Access\n    Profile connection from each new PCE.\n    \n    According to the MAP specification,\n    The MCE and MSE shall be bonded before setting up a Message Access Profile\n    connection.\n    \n    Let's remove the permissions when the device is unbonded.\n    \n    This is a backport of change ag/30386015 but requires minor changes to\n    logic.\n    \n    Flag: EXEMPT, security fix\n    Bug: 289375038\n    Bug: 289811388\n    Test: atest BluetoothInstrumentationTests\n    Ignore-AOSP-First: security fix\n    Merged-In: I94478a4a45a434732d4bc4810da31ef45ef891af\n    Change-Id: I8b9b29310db2d14e5dfaddc81a682366fbef42d3\n\ndiff --git a/android/app/src/com/android/bluetooth/btservice/BondStateMachine.java b/android/app/src/com/android/bluetooth/btservice/BondStateMachine.java\nindex d62d7ba06d..1a1c912f3f 100644\n--- a/android/app/src/com/android/bluetooth/btservice/BondStateMachine.java\n+++ b/android/app/src/com/android/bluetooth/btservice/BondStateMachine.java\n@@ -439,6 +439,13 @@ final class BondStateMachine extends StateMachine {\n             }\n         }\n \n+        if (newState == BluetoothDevice.BOND_NONE) {\n+            // Remove the permissions for unbonded devices\n+            mAdapterService.setMessageAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+            mAdapterService.setPhonebookAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+            mAdapterService.setSimAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+        }\n+\n         Intent intent = new Intent(BluetoothDevice.ACTION_BOND_STATE_CHANGED);\n         intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);\n         intent.putExtra(BluetoothDevice.EXTRA_BOND_STATE, newState);\n",
                "file_conflicts": [
                    {
                        "file_name": "android/app/src/com/android/bluetooth/btservice/AdapterService.java",
                        "total_hunks": 2,
                        "failed_hunks": [
                            1,
                            2
                        ],
                        "inline_merge_conflicts": [
                            {
                                "hunk_number": 1,
                                "merge_conflict": "<<<<<<< DOWNSTREAM (version 14)\n\n=======\n\n        if (toState == BOND_NONE) {\n            // Remove the permissions for unbonded devices\n            setMessageAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n            setPhonebookAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n            setSimAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n        }\n    }\n>>>>>>> UPSTREAM PATCH (commit 771aed3ea225d9ca2ef91e88f45f330ced952772)"
                            }
                        ],
                        "rej_file_content": "```diff\n--- android/app/src/com/android/bluetooth/btservice/AdapterService.java\n+++ android/app/src/com/android/bluetooth/btservice/AdapterService.java\n@@ -27,6 +27,7 @@ import static android.bluetooth.BluetoothAdapter.SCAN_MODE_CONNECTABLE;\n import static android.bluetooth.BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE;\n import static android.bluetooth.BluetoothAdapter.SCAN_MODE_NONE;\n import static android.bluetooth.BluetoothDevice.BATTERY_LEVEL_UNKNOWN;\n+import static android.bluetooth.BluetoothDevice.BOND_NONE;\n import static android.bluetooth.BluetoothDevice.TRANSPORT_AUTO;\n import static android.bluetooth.IBluetoothLeAudio.LE_AUDIO_GROUP_ID_INVALID;\n import static android.text.format.DateUtils.MINUTE_IN_MILLIS;\n@@ -6121,6 +6122,13 @@ public class AdapterService extends Service {\n             mCsipSetCoordinatorService.handleBondStateChanged(device, fromState, toState);\n         }\n         mDatabaseManager.handleBondStateChanged(device, fromState, toState);\n+\n+        if (toState == BOND_NONE) {\n+            // Remove the permissions for unbonded devices\n+            setMessageAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+            setPhonebookAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+            setSimAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+        }\n     }\n \n     static int convertScanModeToHal(int mode) {\n```",
                        "patch_apply_output": "patching file android/app/src/com/android/bluetooth/btservice/AdapterService.java\nHunk #1 FAILED at 27.\nHunk #2 FAILED at 6121.\n2 out of 2 hunks FAILED -- saving rejects to file android/app/src/com/android/bluetooth/btservice/AdapterService.java.rej",
                        "inline_merge_output": "patching file android/app/src/com/android/bluetooth/btservice/AdapterService.java\nHunk #1 already applied at 30.\nHunk #2 NOT MERGED at 6125-6135.",
                        "upstream_file_content": "```java\n/*\n * Copyright (C) 2012 The Android Open Source Project\n * Copyright (C) 2016-2017 The Linux Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.bluetooth.btservice;\n\nimport static android.Manifest.permission.BLUETOOTH_CONNECT;\nimport static android.Manifest.permission.BLUETOOTH_PRIVILEGED;\nimport static android.Manifest.permission.BLUETOOTH_SCAN;\nimport static android.Manifest.permission.DUMP;\nimport static android.Manifest.permission.LOCAL_MAC_ADDRESS;\nimport static android.Manifest.permission.MODIFY_PHONE_STATE;\nimport static android.bluetooth.BluetoothAdapter.SCAN_MODE_CONNECTABLE;\nimport static android.bluetooth.BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE;\nimport static android.bluetooth.BluetoothAdapter.SCAN_MODE_NONE;\nimport static android.bluetooth.BluetoothDevice.BATTERY_LEVEL_UNKNOWN;\nimport static android.bluetooth.BluetoothDevice.BOND_NONE;\nimport static android.bluetooth.BluetoothDevice.TRANSPORT_AUTO;\nimport static android.bluetooth.IBluetoothLeAudio.LE_AUDIO_GROUP_ID_INVALID;\nimport static android.text.format.DateUtils.MINUTE_IN_MILLIS;\nimport static android.text.format.DateUtils.SECOND_IN_MILLIS;\n\nimport static com.android.bluetooth.ChangeIds.ENFORCE_CONNECT;\nimport static com.android.bluetooth.Utils.callerIsSystem;\nimport static com.android.bluetooth.Utils.callerIsSystemOrActiveOrManagedUser;\nimport static com.android.bluetooth.Utils.getBytesFromAddress;\nimport static com.android.bluetooth.Utils.isDualModeAudioEnabled;\nimport static com.android.bluetooth.Utils.isPackageNameAccurate;\n\nimport static java.util.Objects.requireNonNull;\n\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.annotation.RequiresPermission;\nimport android.annotation.SuppressLint;\nimport android.app.AppOpsManager;\nimport android.app.PendingIntent;\nimport android.app.Service;\nimport android.app.admin.DevicePolicyManager;\nimport android.app.compat.CompatChanges;\nimport android.bluetooth.BluetoothA2dp;\nimport android.bluetooth.BluetoothActivityEnergyInfo;\nimport android.bluetooth.BluetoothAdapter;\nimport android.bluetooth.BluetoothAdapter.ActiveDeviceProfile;\nimport android.bluetooth.BluetoothAdapter.ActiveDeviceUse;\nimport android.bluetooth.BluetoothDevice;\nimport android.bluetooth.BluetoothFrameworkInitializer;\nimport android.bluetooth.BluetoothMap;\nimport android.bluetooth.BluetoothProfile;\nimport android.bluetooth.BluetoothProtoEnums;\nimport android.bluetooth.BluetoothQualityReport;\nimport android.bluetooth.BluetoothSap;\nimport android.bluetooth.BluetoothServerSocket;\nimport android.bluetooth.BluetoothSinkAudioPolicy;\nimport android.bluetooth.BluetoothSocket;\nimport android.bluetooth.BluetoothStatusCodes;\nimport android.bluetooth.BluetoothUtils;\nimport android.bluetooth.BluetoothUuid;\nimport android.bluetooth.BufferConstraints;\nimport android.bluetooth.IBluetooth;\nimport android.bluetooth.IBluetoothActivityEnergyInfoListener;\nimport android.bluetooth.IBluetoothCallback;\nimport android.bluetooth.IBluetoothConnectionCallback;\nimport android.bluetooth.IBluetoothMetadataListener;\nimport android.bluetooth.IBluetoothOobDataCallback;\nimport android.bluetooth.IBluetoothPreferredAudioProfilesCallback;\nimport android.bluetooth.IBluetoothQualityReportReadyCallback;\nimport android.bluetooth.IBluetoothSocketManager;\nimport android.bluetooth.IncomingRfcommSocketInfo;\nimport android.bluetooth.OobData;\nimport android.bluetooth.UidTraffic;\nimport android.bluetooth.rfcomm.BluetoothRfcommProtoEnums;\nimport android.companion.CompanionDeviceManager;\nimport android.content.AttributionSource;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.SharedPreferences;\nimport android.content.pm.PackageManager;\nimport android.hardware.display.DisplayManager;\nimport android.os.AsyncTask;\nimport android.os.BatteryStatsManager;\nimport android.os.Binder;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.ParcelUuid;\nimport android.os.Parcelable;\nimport android.os.PowerManager;\nimport android.os.Process;\nimport android.os.RemoteCallbackList;\nimport android.os.RemoteException;\nimport android.os.SystemClock;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.provider.DeviceConfig;\nimport android.provider.Settings;\nimport android.sysprop.BluetoothProperties;\nimport android.text.TextUtils;\nimport android.util.Base64;\nimport android.util.Log;\nimport android.util.SparseArray;\n\nimport com.android.bluetooth.BluetoothMetricsProto;\nimport com.android.bluetooth.BluetoothStatsLog;\nimport com.android.bluetooth.R;\nimport com.android.bluetooth.Utils;\nimport com.android.bluetooth.a2dp.A2dpService;\nimport com.android.bluetooth.a2dpsink.A2dpSinkService;\nimport com.android.bluetooth.avrcp.AvrcpTargetService;\nimport com.android.bluetooth.avrcpcontroller.AvrcpControllerService;\nimport com.android.bluetooth.bas.BatteryService;\nimport com.android.bluetooth.bass_client.BassClientService;\nimport com.android.bluetooth.btservice.InteropUtil.InteropFeature;\nimport com.android.bluetooth.btservice.RemoteDevices.DeviceProperties;\nimport com.android.bluetooth.btservice.bluetoothkeystore.BluetoothKeystoreNativeInterface;\nimport com.android.bluetooth.btservice.bluetoothkeystore.BluetoothKeystoreService;\nimport com.android.bluetooth.btservice.storage.DatabaseManager;\nimport com.android.bluetooth.btservice.storage.MetadataDatabase;\nimport com.android.bluetooth.csip.CsipSetCoordinatorService;\nimport com.android.bluetooth.flags.Flags;\nimport com.android.bluetooth.gatt.GattService;\nimport com.android.bluetooth.hap.HapClientService;\nimport com.android.bluetooth.hearingaid.HearingAidService;\nimport com.android.bluetooth.hfp.HeadsetService;\nimport com.android.bluetooth.hfpclient.HeadsetClientService;\nimport com.android.bluetooth.hid.HidDeviceService;\nimport com.android.bluetooth.hid.HidHostService;\nimport com.android.bluetooth.le_audio.LeAudioService;\nimport com.android.bluetooth.le_scan.ScanController;\nimport com.android.bluetooth.le_scan.ScanManager;\nimport com.android.bluetooth.map.BluetoothMapService;\nimport com.android.bluetooth.mapclient.MapClientService;\nimport com.android.bluetooth.mcp.McpService;\nimport com.android.bluetooth.opp.BluetoothOppService;\nimport com.android.bluetooth.pan.PanService;\nimport com.android.bluetooth.pbap.BluetoothPbapService;\nimport com.android.bluetooth.pbapclient.PbapClientService;\nimport com.android.bluetooth.sap.SapService;\nimport com.android.bluetooth.sdp.SdpManager;\nimport com.android.bluetooth.tbs.TbsService;\nimport com.android.bluetooth.telephony.BluetoothInCallService;\nimport com.android.bluetooth.vc.VolumeControlService;\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.modules.expresslog.Counter;\nimport com.android.modules.utils.BackgroundThread;\nimport com.android.modules.utils.BytesMatcher;\n\nimport libcore.util.SneakyThrow;\n\nimport com.google.common.base.Ascii;\nimport com.google.common.collect.EvictingQueue;\nimport com.google.protobuf.InvalidProtocolBufferException;\n\nimport java.io.FileDescriptor;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.time.Duration;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.Executor;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\n\npublic class AdapterService extends Service {\n    private static final String TAG = \"BluetoothAdapterService\";\n\n    private static final int MESSAGE_PROFILE_SERVICE_STATE_CHANGED = 1;\n    private static final int MESSAGE_PROFILE_SERVICE_REGISTERED = 2;\n    private static final int MESSAGE_PROFILE_SERVICE_UNREGISTERED = 3;\n    private static final int MESSAGE_PREFERRED_AUDIO_PROFILES_AUDIO_FRAMEWORK_TIMEOUT = 4;\n\n    private static final int CONTROLLER_ENERGY_UPDATE_TIMEOUT_MILLIS = 100;\n    private static final int MIN_ADVT_INSTANCES_FOR_MA = 5;\n    private static final int MIN_OFFLOADED_FILTERS = 10;\n    private static final int MIN_OFFLOADED_SCAN_STORAGE_BYTES = 1024;\n\n    private static final Duration PENDING_SOCKET_HANDOFF_TIMEOUT = Duration.ofMinutes(1);\n    private static final Duration GENERATE_LOCAL_OOB_DATA_TIMEOUT = Duration.ofSeconds(2);\n    private static final Duration PREFERRED_AUDIO_PROFILE_CHANGE_TIMEOUT = Duration.ofSeconds(10);\n\n    static final String PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE = \"phonebook_access_permission\";\n    static final String MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE = \"message_access_permission\";\n    static final String SIM_ACCESS_PERMISSION_PREFERENCE_FILE = \"sim_access_permission\";\n\n    private static BluetoothProperties.snoop_log_mode_values sSnoopLogSettingAtEnable =\n            BluetoothProperties.snoop_log_mode_values.EMPTY;\n    private static String sDefaultSnoopLogSettingAtEnable = \"empty\";\n    private static boolean sSnoopLogFilterHeadersSettingAtEnable = false;\n    private static boolean sSnoopLogFilterProfileA2dpSettingAtEnable = false;\n    private static boolean sSnoopLogFilterProfileRfcommSettingAtEnable = false;\n\n    private static BluetoothProperties.snoop_log_filter_profile_pbap_values\n            sSnoopLogFilterProfilePbapModeSettingAtEnable =\n                    BluetoothProperties.snoop_log_filter_profile_pbap_values.EMPTY;\n    private static BluetoothProperties.snoop_log_filter_profile_map_values\n            sSnoopLogFilterProfileMapModeSettingAtEnable =\n                    BluetoothProperties.snoop_log_filter_profile_map_values.EMPTY;\n\n    private static AdapterService sAdapterService;\n\n    private final Object mEnergyInfoLock = new Object();\n    private final SparseArray<UidTraffic> mUidTraffic = new SparseArray<>();\n\n    private final Map<Integer, ProfileService> mStartedProfiles = new HashMap<>();\n    private final List<ProfileService> mRegisteredProfiles = new ArrayList<>();\n    private final List<ProfileService> mRunningProfiles = new ArrayList<>();\n\n    private final List<DiscoveringPackage> mDiscoveringPackages = new ArrayList<>();\n\n    private final AdapterNativeInterface mNativeInterface = AdapterNativeInterface.getInstance();\n\n    private final Map<BluetoothDevice, RemoteCallbackList<IBluetoothMetadataListener>>\n            mMetadataListeners = new HashMap<>();\n\n    // Map<groupId, PendingAudioProfilePreferenceRequest>\n    @GuardedBy(\"mCsipGroupsPendingAudioProfileChanges\")\n    private final Map<Integer, PendingAudioProfilePreferenceRequest>\n            mCsipGroupsPendingAudioProfileChanges = new HashMap<>();\n\n    private final Map<BluetoothStateCallback, Executor> mLocalCallbacks = new ConcurrentHashMap<>();\n    private final Map<UUID, RfcommListenerData> mBluetoothServerSockets = new ConcurrentHashMap<>();\n    private final ArrayDeque<IBluetoothOobDataCallback> mOobDataCallbackQueue = new ArrayDeque<>();\n\n    private final RemoteCallbackList<IBluetoothPreferredAudioProfilesCallback>\n            mPreferredAudioProfilesCallbacks = new RemoteCallbackList<>();\n    private final RemoteCallbackList<IBluetoothQualityReportReadyCallback>\n            mBluetoothQualityReportReadyCallbacks = new RemoteCallbackList<>();\n    private final RemoteCallbackList<IBluetoothCallback> mRemoteCallbacks =\n            new RemoteCallbackList<>();\n    private final RemoteCallbackList<IBluetoothConnectionCallback> mBluetoothConnectionCallbacks =\n            new RemoteCallbackList<>();\n\n    private final EvictingQueue<String> mScanModeChanges = EvictingQueue.create(10);\n\n    private final DeviceConfigListener mDeviceConfigListener = new DeviceConfigListener();\n\n    private final Looper mLooper;\n    private final AdapterServiceHandler mHandler;\n\n    private int mStackReportedState;\n    private long mTxTimeTotalMs;\n    private long mRxTimeTotalMs;\n    private long mIdleTimeTotalMs;\n    private long mEnergyUsedTotalVoltAmpSecMicro;\n    private HashSet<String> mLeAudioAllowDevices = new HashSet<>();\n\n    private BluetoothAdapter mAdapter;\n    @VisibleForTesting AdapterProperties mAdapterProperties;\n    private AdapterState mAdapterStateMachine;\n    private BondStateMachine mBondStateMachine;\n    private RemoteDevices mRemoteDevices;\n    private AdapterSuspend mAdapterSuspend;\n\n    /* TODO: Consider to remove the search API from this class, if changed to use call-back */\n    private SdpManager mSdpManager = null;\n\n    private boolean mNativeAvailable;\n    private boolean mCleaningUp;\n    private boolean mQuietmode = false;\n    private Map<String, CallerInfo> mBondAttemptCallerInfo = new HashMap<>();\n\n    private BatteryStatsManager mBatteryStatsManager;\n    private PowerManager mPowerManager;\n    private PowerManager.WakeLock mWakeLock;\n    private UserManager mUserManager;\n    private CompanionDeviceManager mCompanionDeviceManager;\n\n    // Phone Policy is not used on all devices. Ensure you null check before using it\n    @Nullable private PhonePolicy mPhonePolicy;\n\n    private ActiveDeviceManager mActiveDeviceManager;\n    private final DatabaseManager mDatabaseManager;\n    private final SilenceDeviceManager mSilenceDeviceManager;\n    private CompanionManager mBtCompanionManager;\n    private AppOpsManager mAppOps;\n\n    private BluetoothSocketManagerBinder mBluetoothSocketManagerBinder;\n\n    private BluetoothKeystoreService mBluetoothKeystoreService;\n    private A2dpService mA2dpService;\n    private A2dpSinkService mA2dpSinkService;\n    private HeadsetService mHeadsetService;\n    private HeadsetClientService mHeadsetClientService;\n    private BluetoothMapService mMapService;\n    private MapClientService mMapClientService;\n    private HidDeviceService mHidDeviceService;\n    private HidHostService mHidHostService;\n    private PanService mPanService;\n    private BluetoothPbapService mPbapService;\n    private PbapClientService mPbapClientService;\n    private HearingAidService mHearingAidService;\n    private HapClientService mHapClientService;\n    private SapService mSapService;\n    private VolumeControlService mVolumeControlService;\n    private CsipSetCoordinatorService mCsipSetCoordinatorService;\n    private LeAudioService mLeAudioService;\n    private BassClientService mBassClientService;\n    private BatteryService mBatteryService;\n    private BluetoothQualityReportNativeInterface mBluetoothQualityReportNativeInterface;\n    private GattService mGattService;\n    private ScanController mScanController;\n\n    private volatile boolean mTestModeEnabled = false;\n\n    private MetricsLogger mMetricsLogger;\n\n    /** Handlers for incoming service calls */\n    private AdapterServiceBinder mBinder;\n\n    private volatile int mScanMode;\n\n    // Report ID definition\n    public enum BqrQualityReportId {\n        QUALITY_REPORT_ID_MONITOR_MODE(0x01),\n        QUALITY_REPORT_ID_APPROACH_LSTO(0x02),\n        QUALITY_REPORT_ID_A2DP_AUDIO_CHOPPY(0x03),\n        QUALITY_REPORT_ID_SCO_VOICE_CHOPPY(0x04),\n        QUALITY_REPORT_ID_ROOT_INFLAMMATION(0x05),\n        QUALITY_REPORT_ID_CONNECT_FAIL(0x08),\n        QUALITY_REPORT_ID_LMP_LL_MESSAGE_TRACE(0x11),\n        QUALITY_REPORT_ID_BT_SCHEDULING_TRACE(0x12),\n        QUALITY_REPORT_ID_CONTROLLER_DBG_INFO(0x13);\n\n        private final int mValue;\n\n        BqrQualityReportId(int value) {\n            mValue = value;\n        }\n\n        public int getValue() {\n            return mValue;\n        }\n    };\n\n    static {\n        if (!Flags.avoidStaticLoadingOfNative()) {\n            Log.d(TAG, \"Loading JNI Library\");\n            if (Utils.isInstrumentationTestMode()) {\n                Log.w(TAG, \"App is instrumented. Skip loading the native\");\n            } else {\n                System.loadLibrary(\"bluetooth_jni\");\n            }\n        }\n    }\n\n    // Keep a constructor for ActivityThread.handleCreateService\n    AdapterService() {\n        this(Looper.getMainLooper());\n    }\n\n    @VisibleForTesting\n    AdapterService(Looper looper) {\n        mLooper = requireNonNull(looper);\n        mHandler = new AdapterServiceHandler(mLooper);\n        mSilenceDeviceManager = new SilenceDeviceManager(this, new ServiceFactory(), mLooper);\n        mDatabaseManager = new DatabaseManager(this);\n    }\n\n    @VisibleForTesting\n    public AdapterService(Context ctx) {\n        this(Looper.getMainLooper());\n        attachBaseContext(ctx);\n    }\n\n    public static synchronized AdapterService getAdapterService() {\n        return sAdapterService;\n    }\n\n    AdapterNativeInterface getNative() {\n        return mNativeInterface;\n    }\n\n    /** Allow test to set an AdapterService to be return by AdapterService.getAdapterService() */\n    @VisibleForTesting\n    public static synchronized void setAdapterService(AdapterService instance) {\n        if (instance == null) {\n            Log.e(TAG, \"setAdapterService() - instance is null\");\n            return;\n        }\n        Log.d(TAG, \"setAdapterService() - set service to \" + instance);\n        sAdapterService = instance;\n    }\n\n    /** Clear test Adapter service. See {@code setAdapterService} */\n    @VisibleForTesting\n    public static synchronized void clearAdapterService(AdapterService instance) {\n        if (sAdapterService == instance) {\n            Log.d(TAG, \"clearAdapterService() - This adapter was cleared \" + instance);\n            sAdapterService = null;\n        } else {\n            Log.d(\n                    TAG,\n                    \"clearAdapterService() - incorrect cleared adapter.\"\n                            + (\" Instance=\" + instance)\n                            + (\" vs sAdapterService=\" + sAdapterService));\n        }\n    }\n\n    /**\n     * Register a {@link ProfileService} with AdapterService.\n     *\n     * @param profile the service being added.\n     */\n    public void addProfile(ProfileService profile) {\n        mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_REGISTERED, profile).sendToTarget();\n    }\n\n    /**\n     * Unregister a ProfileService with AdapterService.\n     *\n     * @param profile the service being removed.\n     */\n    public void removeProfile(ProfileService profile) {\n        mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_UNREGISTERED, profile).sendToTarget();\n    }\n\n    /**\n     * Notify AdapterService that a ProfileService has started or stopped.\n     *\n     * @param profile the service being removed.\n     * @param state {@link BluetoothAdapter#STATE_ON} or {@link BluetoothAdapter#STATE_OFF}\n     */\n    public void onProfileServiceStateChanged(ProfileService profile, int state) {\n        if (state != BluetoothAdapter.STATE_ON && state != BluetoothAdapter.STATE_OFF) {\n            throw new IllegalArgumentException(BluetoothAdapter.nameForState(state));\n        }\n        Message m = mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_STATE_CHANGED);\n        m.obj = profile;\n        m.arg1 = state;\n        mHandler.sendMessage(m);\n    }\n\n    class AdapterServiceHandler extends Handler {\n        AdapterServiceHandler(Looper looper) {\n            super(looper);\n        }\n\n        @Override\n        public void handleMessage(Message msg) {\n            Log.v(TAG, \"handleMessage() - Message: \" + msg.what);\n\n            switch (msg.what) {\n                case MESSAGE_PROFILE_SERVICE_STATE_CHANGED:\n                    Log.v(TAG, \"handleMessage() - MESSAGE_PROFILE_SERVICE_STATE_CHANGED\");\n                    processProfileServiceStateChanged((ProfileService) msg.obj, msg.arg1);\n                    break;\n                case MESSAGE_PROFILE_SERVICE_REGISTERED:\n                    Log.v(TAG, \"handleMessage() - MESSAGE_PROFILE_SERVICE_REGISTERED\");\n                    registerProfileService((ProfileService) msg.obj);\n                    break;\n                case MESSAGE_PROFILE_SERVICE_UNREGISTERED:\n                    Log.v(TAG, \"handleMessage() - MESSAGE_PROFILE_SERVICE_UNREGISTERED\");\n                    unregisterProfileService((ProfileService) msg.obj);\n                    break;\n                case MESSAGE_PREFERRED_AUDIO_PROFILES_AUDIO_FRAMEWORK_TIMEOUT:\n                    Log.e(\n                            TAG,\n                            \"handleMessage() - \"\n                                    + \"MESSAGE_PREFERRED_PROFILE_CHANGE_AUDIO_FRAMEWORK_TIMEOUT\");\n                    int groupId = (int) msg.obj;\n\n                    synchronized (mCsipGroupsPendingAudioProfileChanges) {\n                        removeFromPendingAudioProfileChanges(groupId);\n                        PendingAudioProfilePreferenceRequest request =\n                                mCsipGroupsPendingAudioProfileChanges.remove(groupId);\n                        Log.e(\n                                TAG,\n                                \"Preferred audio profiles change audio framework timeout for \"\n                                        + (\"device \" + request.mDeviceRequested));\n                        sendPreferredAudioProfilesCallbackToApps(\n                                request.mDeviceRequested,\n                                request.mRequestedPreferences,\n                                BluetoothStatusCodes.ERROR_TIMEOUT);\n                    }\n                    break;\n            }\n        }\n\n        private void registerProfileService(ProfileService profile) {\n            if (mRegisteredProfiles.contains(profile)) {\n                Log.e(TAG, profile.getName() + \" already registered.\");\n                return;\n            }\n            mRegisteredProfiles.add(profile);\n        }\n\n        private void unregisterProfileService(ProfileService profile) {\n            if (!mRegisteredProfiles.contains(profile)) {\n                Log.e(TAG, profile.getName() + \" not registered (UNREGISTER).\");\n                return;\n            }\n            mRegisteredProfiles.remove(profile);\n        }\n\n        private void processProfileServiceStateChanged(ProfileService profile, int state) {\n            switch (state) {\n                case BluetoothAdapter.STATE_ON:\n                    if (!mRegisteredProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" not registered (STATE_ON).\");\n                        return;\n                    }\n                    if (mRunningProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" already running.\");\n                        return;\n                    }\n                    mRunningProfiles.add(profile);\n                    // TODO(b/228875190): GATT is assumed supported. GATT starting triggers hardware\n                    // initialization. Configuring a device without GATT causes start up failures.\n                    if (GattService.class.getSimpleName().equals(profile.getName())\n                            && !Flags.scanManagerRefactor()) {\n                        mNativeInterface.enable();\n                    } else if (mRegisteredProfiles.size() == Config.getSupportedProfiles().length\n                            && mRegisteredProfiles.size() == mRunningProfiles.size()) {\n                        mAdapterProperties.onBluetoothReady();\n                        setScanMode(SCAN_MODE_CONNECTABLE, \"processProfileServiceStateChanged\");\n                        updateUuids();\n                        initProfileServices();\n                        mNativeInterface.getAdapterProperty(\n                                AbstractionLayer.BT_PROPERTY_DYNAMIC_AUDIO_BUFFER);\n                        mAdapterStateMachine.sendMessage(AdapterState.BREDR_STARTED);\n                        mBtCompanionManager.loadCompanionInfo();\n                    }\n                    break;\n                case BluetoothAdapter.STATE_OFF:\n                    if (!mRegisteredProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" not registered (STATE_OFF).\");\n                        return;\n                    }\n                    if (!mRunningProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" not running.\");\n                        return;\n                    }\n                    mRunningProfiles.remove(profile);\n\n                    if (Flags.scanManagerRefactor()) {\n                        if (mRunningProfiles.size() == 0) {\n                            mAdapterStateMachine.sendMessage(AdapterState.BREDR_STOPPED);\n                        }\n                    } else {\n                        // TODO(b/228875190): GATT is assumed supported. GATT is expected to be the\n                        // only profile available in the \"BLE ON\" state. If only GATT is left, send\n                        // BREDR_STOPPED. If GATT is stopped, deinitialize the hardware.\n                        if ((mRunningProfiles.size() == 1\n                                && (GattService.class\n                                        .getSimpleName()\n                                        .equals(mRunningProfiles.get(0).getName())))) {\n                            mAdapterStateMachine.sendMessage(AdapterState.BREDR_STOPPED);\n                        } else if (mRunningProfiles.size() == 0) {\n                            mNativeInterface.disable();\n                        }\n                    }\n                    break;\n                default:\n                    Log.e(TAG, \"Unhandled profile state: \" + state);\n            }\n        }\n    }\n\n    /**\n     * Stores information about requests made to the audio framework arising from calls to {@link\n     * BluetoothAdapter#setPreferredAudioProfiles(BluetoothDevice, Bundle)}.\n     */\n    private static class PendingAudioProfilePreferenceRequest {\n        // The newly requested preferences\n        final Bundle mRequestedPreferences;\n        // Reference counter for how many calls are pending completion in the audio framework\n        int mRemainingRequestsToAudioFramework;\n        // The device with which the request was made. Used for sending the callback.\n        final BluetoothDevice mDeviceRequested;\n\n        /**\n         * Constructs an entity to store information about pending preferred audio profile changes.\n         *\n         * @param preferences newly requested preferences\n         * @param numRequestsToAudioFramework how many active device changed requests are sent to\n         *     the audio framework\n         * @param device the device with which the request was made\n         */\n        PendingAudioProfilePreferenceRequest(\n                Bundle preferences, int numRequestsToAudioFramework, BluetoothDevice device) {\n            mRequestedPreferences = preferences;\n            mRemainingRequestsToAudioFramework = numRequestsToAudioFramework;\n            mDeviceRequested = device;\n        }\n    }\n\n    final @NonNull <T> T getNonNullSystemService(@NonNull Class<T> clazz) {\n        return requireNonNull(getSystemService(clazz));\n    }\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        Log.d(TAG, \"onCreate()\");\n        if (!Flags.fastBindToApp()) {\n            init();\n            return;\n        }\n        // OnCreate must perform the minimum of infaillible and mandatory initialization\n        mRemoteDevices = new RemoteDevices(this, mLooper);\n        mAdapterProperties = new AdapterProperties(this);\n        mAdapterStateMachine = new AdapterState(this, mLooper);\n        mBinder = new AdapterServiceBinder(this);\n        mUserManager = getNonNullSystemService(UserManager.class);\n        mAppOps = getNonNullSystemService(AppOpsManager.class);\n        mPowerManager = getNonNullSystemService(PowerManager.class);\n        mBatteryStatsManager = getNonNullSystemService(BatteryStatsManager.class);\n        mCompanionDeviceManager = getNonNullSystemService(CompanionDeviceManager.class);\n        setAdapterService(this);\n    }\n\n    @SuppressLint(\"AndroidFrameworkRequiresPermission\")\n    private void init() {\n        Log.d(TAG, \"init()\");\n        Config.init(this);\n        initMetricsLogger();\n        mDeviceConfigListener.start();\n\n        if (!Flags.fastBindToApp()) {\n            // Moved to OnCreate\n            mUserManager = getNonNullSystemService(UserManager.class);\n            mAppOps = getNonNullSystemService(AppOpsManager.class);\n            mPowerManager = getNonNullSystemService(PowerManager.class);\n            mBatteryStatsManager = getNonNullSystemService(BatteryStatsManager.class);\n            mCompanionDeviceManager = getNonNullSystemService(CompanionDeviceManager.class);\n            mRemoteDevices = new RemoteDevices(this, mLooper);\n        }\n\n        clearDiscoveringPackages();\n        if (!Flags.fastBindToApp()) {\n            mBinder = new AdapterServiceBinder(this);\n        }\n        mAdapter = BluetoothAdapter.getDefaultAdapter();\n        if (!Flags.fastBindToApp()) {\n            // Moved to OnCreate\n            mAdapterProperties = new AdapterProperties(this);\n            mAdapterStateMachine = new AdapterState(this, mLooper);\n        }\n        boolean isCommonCriteriaMode =\n                getNonNullSystemService(DevicePolicyManager.class)\n                        .isCommonCriteriaModeEnabled(null);\n        mBluetoothKeystoreService =\n                new BluetoothKeystoreService(\n                        BluetoothKeystoreNativeInterface.getInstance(), isCommonCriteriaMode);\n        mBluetoothKeystoreService.start();\n        int configCompareResult = mBluetoothKeystoreService.getCompareResult();\n\n        // Start tracking Binder latency for the bluetooth process.\n        BluetoothFrameworkInitializer.initializeBinderCallsStats(getApplicationContext());\n\n        // Android TV doesn't show consent dialogs for just works and encryption only le pairing\n        boolean isAtvDevice =\n                getApplicationContext()\n                        .getPackageManager()\n                        .hasSystemFeature(PackageManager.FEATURE_LEANBACK_ONLY);\n        if (Flags.avoidStaticLoadingOfNative()) {\n            if (Utils.isInstrumentationTestMode()) {\n                Log.w(TAG, \"This Bluetooth App is instrumented. ** Skip loading the native **\");\n            } else {\n                Log.d(TAG, \"Loading JNI Library\");\n                System.loadLibrary(\"bluetooth_jni\");\n            }\n        }\n        mNativeInterface.init(\n                this,\n                mAdapterProperties,\n                mUserManager.isGuestUser(),\n                isCommonCriteriaMode,\n                configCompareResult,\n                isAtvDevice,\n                getApplicationInfo().dataDir);\n        mNativeAvailable = true;\n        // Load the name and address\n        mNativeInterface.getAdapterProperty(AbstractionLayer.BT_PROPERTY_BDADDR);\n        mNativeInterface.getAdapterProperty(AbstractionLayer.BT_PROPERTY_BDNAME);\n        mNativeInterface.getAdapterProperty(AbstractionLayer.BT_PROPERTY_CLASS_OF_DEVICE);\n\n        mBluetoothKeystoreService.initJni();\n\n        mBluetoothQualityReportNativeInterface =\n                requireNonNull(\n                        BluetoothQualityReportNativeInterface.getInstance(),\n                        \"BluetoothQualityReportNativeInterface cannot be null when BQR starts\");\n        mBluetoothQualityReportNativeInterface.init();\n\n        if (Flags.fastBindToApp()) {\n            mSdpManager = new SdpManager(this, mLooper);\n        } else {\n            mSdpManager = new SdpManager(this);\n        }\n\n        mDatabaseManager.start(MetadataDatabase.createDatabase(this));\n\n        boolean isAutomotiveDevice =\n                getApplicationContext()\n                        .getPackageManager()\n                        .hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE);\n\n        /*\n         * Phone policy is specific to phone implementations and hence if a device wants to exclude\n         * it out then it can be disabled by using the flag below. Phone policy is never used on\n         * Android Automotive OS builds, in favor of a policy currently located in\n         * CarBluetoothService.\n         */\n        if (!isAutomotiveDevice && getResources().getBoolean(R.bool.enable_phone_policy)) {\n            Log.i(TAG, \"Phone policy enabled\");\n            mPhonePolicy = new PhonePolicy(this, new ServiceFactory());\n            mPhonePolicy.start();\n        } else {\n            Log.i(TAG, \"Phone policy disabled\");\n        }\n\n        if (Flags.audioRoutingCentralization()) {\n            mActiveDeviceManager = new AudioRoutingManager(this, new ServiceFactory());\n        } else {\n            mActiveDeviceManager = new ActiveDeviceManager(this, new ServiceFactory());\n        }\n        mActiveDeviceManager.start();\n\n        mSilenceDeviceManager.start();\n\n        mBtCompanionManager = new CompanionManager(this, new ServiceFactory());\n\n        mBluetoothSocketManagerBinder = new BluetoothSocketManagerBinder(this);\n\n        if (Flags.adapterSuspendMgmt()) {\n            mAdapterSuspend =\n                    new AdapterSuspend(\n                            mNativeInterface, mLooper, getSystemService(DisplayManager.class));\n        }\n\n        if (!Flags.fastBindToApp()) {\n            setAdapterService(this);\n        }\n\n        invalidateBluetoothCaches();\n\n        // First call to getSharedPreferences will result in a file read into\n        // memory cache. Call it here asynchronously to avoid potential ANR\n        // in the future\n        new AsyncTask<Void, Void, Void>() {\n            @Override\n            protected Void doInBackground(Void... params) {\n                getSharedPreferences(\n                        PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE, Context.MODE_PRIVATE);\n                getSharedPreferences(\n                        MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE, Context.MODE_PRIVATE);\n                getSharedPreferences(SIM_ACCESS_PERMISSION_PREFERENCE_FILE, Context.MODE_PRIVATE);\n                return null;\n            }\n        }.execute();\n\n        try {\n            int systemUiUid =\n                    getApplicationContext()\n                            .createContextAsUser(UserHandle.SYSTEM, /* flags= */ 0)\n                            .getPackageManager()\n                            .getPackageUid(\n                                    \"com.android.systemui\", PackageManager.MATCH_SYSTEM_ONLY);\n\n            Utils.setSystemUiUid(systemUiUid);\n        } catch (PackageManager.NameNotFoundException e) {\n            // Some platforms, such as wearables do not have a system ui.\n            Log.w(TAG, \"Unable to resolve SystemUI's UID.\", e);\n        }\n    }\n\n    @Override\n    public IBinder onBind(Intent intent) {\n        Log.d(TAG, \"onBind()\");\n        return mBinder;\n    }\n\n    @Override\n    public boolean onUnbind(Intent intent) {\n        Log.d(TAG, \"onUnbind()\");\n        return super.onUnbind(intent);\n    }\n\n    @Override\n    public void onDestroy() {\n        Log.d(TAG, \"onDestroy()\");\n    }\n\n    public ActiveDeviceManager getActiveDeviceManager() {\n        return mActiveDeviceManager;\n    }\n\n    public SilenceDeviceManager getSilenceDeviceManager() {\n        return mSilenceDeviceManager;\n    }\n\n    private boolean initMetricsLogger() {\n        if (mMetricsLogger != null) {\n            return false;\n        }\n        mMetricsLogger = MetricsLogger.getInstance();\n        return mMetricsLogger.init(this);\n    }\n\n    private boolean closeMetricsLogger() {\n        if (mMetricsLogger == null) {\n            return false;\n        }\n        boolean result = mMetricsLogger.close();\n        mMetricsLogger = null;\n        return result;\n    }\n\n    /**\n     * Log L2CAP CoC Server Connection Metrics\n     *\n     * @param port port of socket\n     * @param isSecured if secured API is called\n     * @param result transaction result of the connection\n     * @param socketCreationLatencyMillis latency of the connection\n     * @param timeoutMillis timeout set by the app\n     */\n    public void logL2capcocServerConnection(\n            BluetoothDevice device,\n            int port,\n            boolean isSecured,\n            int result,\n            long socketCreationTimeMillis,\n            long socketCreationLatencyMillis,\n            long socketConnectionTimeMillis,\n            long timeoutMillis,\n            int appUid) {\n\n        int metricId = 0;\n        if (device != null) {\n            metricId = getMetricId(device);\n        }\n        long currentTime = System.currentTimeMillis();\n        long endToEndLatencyMillis = currentTime - socketCreationTimeMillis;\n        long socketAcceptanceLatencyMillis = currentTime - socketConnectionTimeMillis;\n        Log.i(\n                TAG,\n                \"Statslog L2capcoc server connection.\"\n                        + (\" metricId \" + metricId)\n                        + (\" port \" + port)\n                        + (\" isSecured \" + isSecured)\n                        + (\" result \" + result)\n                        + (\" endToEndLatencyMillis \" + endToEndLatencyMillis)\n                        + (\" socketCreationLatencyMillis \" + socketCreationLatencyMillis)\n                        + (\" socketAcceptanceLatencyMillis \" + socketAcceptanceLatencyMillis)\n                        + (\" timeout set by app \" + timeoutMillis)\n                        + (\" appUid \" + appUid));\n        BluetoothStatsLog.write(\n                BluetoothStatsLog.BLUETOOTH_L2CAP_COC_SERVER_CONNECTION,\n                metricId,\n                port,\n                isSecured,\n                result,\n                endToEndLatencyMillis,\n                timeoutMillis,\n                appUid,\n                socketCreationLatencyMillis,\n                socketAcceptanceLatencyMillis);\n    }\n\n    public void setMetricsLogger(MetricsLogger metricsLogger) {\n        mMetricsLogger = metricsLogger;\n    }\n\n    /**\n     * Log L2CAP CoC Client Connection Metrics\n     *\n     * @param device Bluetooth device\n     * @param port port of socket\n     * @param isSecured if secured API is called\n     * @param result transaction result of the connection\n     * @param socketCreationLatencyNanos latency of the connection\n     */\n    public void logL2capcocClientConnection(\n            BluetoothDevice device,\n            int port,\n            boolean isSecured,\n            int result,\n            long socketCreationTimeNanos,\n            long socketCreationLatencyNanos,\n            long socketConnectionTimeNanos,\n            int appUid) {\n\n        int metricId = getMetricId(device);\n        long currentTime = System.nanoTime();\n        long endToEndLatencyMillis = (currentTime - socketCreationTimeNanos) / 1000000;\n        long socketCreationLatencyMillis = socketCreationLatencyNanos / 1000000;\n        long socketConnectionLatencyMillis = (currentTime - socketConnectionTimeNanos) / 1000000;\n        Log.i(\n                TAG,\n                \"Statslog L2capcoc client connection.\"\n                        + (\" metricId \" + metricId)\n                        + (\" port \" + port)\n                        + (\" isSecured \" + isSecured)\n                        + (\" result \" + result)\n                        + (\" endToEndLatencyMillis \" + endToEndLatencyMillis)\n                        + (\" socketCreationLatencyMillis \" + socketCreationLatencyMillis)\n                        + (\" socketConnectionLatencyMillis \" + socketConnectionLatencyMillis)\n                        + (\" appUid \" + appUid));\n        BluetoothStatsLog.write(\n                BluetoothStatsLog.BLUETOOTH_L2CAP_COC_CLIENT_CONNECTION,\n                metricId,\n                port,\n                isSecured,\n                result,\n                endToEndLatencyMillis,\n                appUid,\n                socketCreationLatencyMillis,\n                socketConnectionLatencyMillis);\n    }\n\n    /**\n     * Log RFCOMM Connection Metrics\n     *\n     * @param device Bluetooth device\n     * @param isSecured if secured API is called\n     * @param resultCode transaction result of the connection\n     * @param isSerialPort true if service class UUID is 0x1101\n     */\n    public void logRfcommConnectionAttempt(\n            BluetoothDevice device,\n            boolean isSecured,\n            int resultCode,\n            long socketCreationTimeNanos,\n            boolean isSerialPort,\n            int appUid) {\n        int metricId = getMetricId(device);\n        long currentTime = System.nanoTime();\n        long endToEndLatencyNanos = currentTime - socketCreationTimeNanos;\n        byte[] remoteDeviceInfoBytes = MetricsLogger.getInstance().getRemoteDeviceInfoProto(device);\n        BluetoothStatsLog.write(\n                BluetoothStatsLog.BLUETOOTH_RFCOMM_CONNECTION_ATTEMPTED,\n                metricId,\n                endToEndLatencyNanos,\n                isSecured\n                        ? BluetoothRfcommProtoEnums.SOCKET_SECURITY_SECURE\n                        : BluetoothRfcommProtoEnums.SOCKET_SECURITY_INSECURE,\n                resultCode,\n                isSerialPort,\n                appUid,\n                remoteDeviceInfoBytes);\n    }\n\n    public boolean sdpSearch(BluetoothDevice device, ParcelUuid uuid) {\n        if (mSdpManager == null) {\n            return false;\n        }\n        mSdpManager.sdpSearch(device, uuid);\n        return true;\n    }\n\n    @RequiresPermission(BLUETOOTH_CONNECT)\n    void bringUpBle() {\n        Log.d(TAG, \"bleOnProcessStart()\");\n\n        if (getResources()\n                .getBoolean(R.bool.config_bluetooth_reload_supported_profiles_when_enabled)) {\n            Config.init(getApplicationContext());\n        }\n\n        // Reset |mRemoteDevices| whenever BLE is turned off then on\n        // This is to replace the fact that |mRemoteDevices| was\n        // reinitialized in previous code.\n        //\n        // TODO(apanicke): The reason is unclear but\n        // I believe it is to clear the variable every time BLE was\n        // turned off then on. The same effect can be achieved by\n        // calling cleanup but this may not be necessary at all\n        // We should figure out why this is needed later\n        mRemoteDevices.reset();\n        mAdapterProperties.init(mRemoteDevices);\n\n        Log.d(TAG, \"bleOnProcessStart() - Make Bond State Machine\");\n        mBondStateMachine = BondStateMachine.make(this, mAdapterProperties, mRemoteDevices);\n\n        mNativeInterface.getCallbacks().init(mBondStateMachine, mRemoteDevices);\n\n        mBatteryStatsManager.reportBleScanReset();\n        BluetoothStatsLog.write_non_chained(\n                BluetoothStatsLog.BLE_SCAN_STATE_CHANGED,\n                -1,\n                null,\n                BluetoothStatsLog.BLE_SCAN_STATE_CHANGED__STATE__RESET,\n                false,\n                false,\n                false);\n\n        // TODO(b/228875190): GATT is assumed supported. As a result, we don't respect the\n        // configuration sysprop. Configuring a device without GATT, although rare, will cause stack\n        // start up errors yielding init loops.\n        if (!GattService.isEnabled()) {\n            Log.w(\n                    TAG,\n                    \"GATT is configured off but the stack assumes it to be enabled. Start anyway.\");\n        }\n        if (Flags.scanManagerRefactor()) {\n            startScanController();\n        } else {\n            startGattProfileService();\n        }\n    }\n\n    void bringDownBle() {\n        if (Flags.scanManagerRefactor()) {\n            stopScanController();\n        } else {\n            stopGattProfileService();\n        }\n    }\n\n    void stateChangeCallback(int status) {\n        if (status == AbstractionLayer.BT_STATE_OFF) {\n            Log.d(TAG, \"stateChangeCallback: disableNative() completed\");\n            mAdapterStateMachine.sendMessage(AdapterState.BLE_STOPPED);\n        } else if (status == AbstractionLayer.BT_STATE_ON) {\n            mAdapterStateMachine.sendMessage(AdapterState.BLE_STARTED);\n        } else {\n            Log.e(TAG, \"Incorrect status \" + status + \" in stateChangeCallback\");\n        }\n    }\n\n    void startProfileServices() {\n        Log.d(TAG, \"startCoreServices()\");\n        int[] supportedProfileServices = Config.getSupportedProfiles();\n        if (Flags.scanManagerRefactor()) {\n            // Scanning is always supported, started separately, and is not a profile service.\n            // This will check other profile services.\n            if (supportedProfileServices.length == 0) {\n                mAdapterProperties.onBluetoothReady();\n                setScanMode(SCAN_MODE_CONNECTABLE, \"startProfileServices\");\n                updateUuids();\n                mAdapterStateMachine.sendMessage(AdapterState.BREDR_STARTED);\n            } else {\n                setAllProfileServiceStates(supportedProfileServices, BluetoothAdapter.STATE_ON);\n            }\n        } else {\n            // TODO(b/228875190): GATT is assumed supported. If we support no other profiles then\n            // just move on to BREDR_STARTED. Note that configuring GATT to NOT supported will cause\n            // adapter initialization failures\n            if (supportedProfileServices.length == 1\n                    && supportedProfileServices[0] == BluetoothProfile.GATT) {\n                mAdapterProperties.onBluetoothReady();\n                setScanMode(SCAN_MODE_CONNECTABLE, \"startProfileServices\");\n                updateUuids();\n                mAdapterStateMachine.sendMessage(AdapterState.BREDR_STARTED);\n            } else {\n                setAllProfileServiceStates(supportedProfileServices, BluetoothAdapter.STATE_ON);\n            }\n        }\n    }\n\n    void stopProfileServices() {\n        // Make sure to stop classic background tasks now\n        mNativeInterface.cancelDiscovery();\n        setScanMode(SCAN_MODE_NONE, \"StopProfileServices\");\n\n        int[] supportedProfileServices = Config.getSupportedProfiles();\n        if (Flags.scanManagerRefactor()) {\n            // Scanning is always supported, started separately, and is not a profile service.\n            // This will check other profile services.\n            if (supportedProfileServices.length == 0) {\n                mAdapterStateMachine.sendMessage(AdapterState.BREDR_STOPPED);\n            } else {\n                setAllProfileServiceStates(supportedProfileServices, BluetoothAdapter.STATE_OFF);\n            }\n        } else {\n            // TODO(b/228875190): GATT is assumed supported. If we support no profiles then just\n            // move on to BREDR_STOPPED\n            if (supportedProfileServices.length == 1\n                    && (mRunningProfiles.size() == 1\n                            && GattService.class\n                                    .getSimpleName()\n                                    .equals(mRunningProfiles.get(0).getName()))) {\n                Log.d(\n                        TAG,\n                        \"stopProfileServices() - No profiles services to stop or already stopped.\");\n                mAdapterStateMachine.sendMessage(AdapterState.BREDR_STOPPED);\n            } else {\n                setAllProfileServiceStates(supportedProfileServices, BluetoothAdapter.STATE_OFF);\n            }\n        }\n    }\n\n    private void startGattProfileService() {\n        Log.d(TAG, \"startGattProfileService() called\");\n        mGattService = new GattService(this);\n\n        mStartedProfiles.put(BluetoothProfile.GATT, mGattService);\n        addProfile(mGattService);\n        mGattService.start();\n        mGattService.setAvailable(true);\n        onProfileServiceStateChanged(mGattService, BluetoothAdapter.STATE_ON);\n    }\n\n    private void startScanController() {\n        Log.d(TAG, \"startScanController() called\");\n        mScanController = new ScanController(this);\n        mNativeInterface.enable();\n    }\n\n    private void stopGattProfileService() {\n        Log.d(TAG, \"stopGattProfileService() called\");\n        setScanMode(SCAN_MODE_NONE, \"stopGattProfileService\");\n\n        if (mRunningProfiles.size() == 0) {\n            Log.d(TAG, \"stopGattProfileService() - No profiles services to stop.\");\n            mAdapterStateMachine.sendMessage(AdapterState.BLE_STOPPED);\n        }\n\n        mStartedProfiles.remove(BluetoothProfile.GATT);\n        if (mGattService != null) {\n            mGattService.setAvailable(false);\n            onProfileServiceStateChanged(mGattService, BluetoothAdapter.STATE_OFF);\n            mGattService.stop();\n            removeProfile(mGattService);\n            mGattService.cleanup();\n            mGattService.getBinder().cleanup();\n            mGattService = null;\n        }\n    }\n\n    private void stopScanController() {\n        Log.d(TAG, \"stopScanController() called\");\n        setScanMode(SCAN_MODE_NONE, \"stopScanController\");\n\n        if (mScanController == null) {\n            mAdapterStateMachine.sendMessage(AdapterState.BLE_STOPPED);\n        } else {\n            mScanController.stop();\n            mScanController = null;\n            mNativeInterface.disable();\n        }\n    }\n\n    private void invalidateBluetoothGetStateCache() {\n        if (Flags.getStateFromSystemServer()) {\n            // State is managed by the system server\n            return;\n        }\n        BluetoothAdapter.invalidateBluetoothGetStateCache();\n    }\n\n    void updateLeAudioProfileServiceState() {\n        Set<Integer> nonSupportedProfiles = new HashSet<>();\n\n        if (!isLeConnectedIsochronousStreamCentralSupported()) {\n            for (int profileId : Config.getLeAudioUnicastProfiles()) {\n                nonSupportedProfiles.add(profileId);\n            }\n        }\n\n        if (!isLeAudioBroadcastAssistantSupported()) {\n            nonSupportedProfiles.add(BluetoothProfile.LE_AUDIO_BROADCAST_ASSISTANT);\n        }\n\n        if (!isLeAudioBroadcastSourceSupported()) {\n            Config.setProfileEnabled(BluetoothProfile.LE_AUDIO_BROADCAST, false);\n        }\n\n        // Disable the non-supported profiles service\n        for (int profileId : nonSupportedProfiles) {\n            Config.setProfileEnabled(profileId, false);\n            if (mStartedProfiles.containsKey(profileId)) {\n                setProfileServiceState(profileId, BluetoothAdapter.STATE_OFF);\n            }\n        }\n    }\n\n    void updateAdapterName(String name) {\n        int n = mRemoteCallbacks.beginBroadcast();\n        Log.d(TAG, \"updateAdapterName(\" + name + \")\");\n        for (int i = 0; i < n; i++) {\n            try {\n                mRemoteCallbacks.getBroadcastItem(i).onAdapterNameChange(name);\n            } catch (RemoteException e) {\n                Log.d(TAG, \"updateAdapterName() - Callback #\" + i + \" failed (\" + e + \")\");\n            }\n        }\n        mRemoteCallbacks.finishBroadcast();\n    }\n\n    void updateAdapterAddress(String address) {\n        int n = mRemoteCallbacks.beginBroadcast();\n        Log.d(TAG, \"updateAdapterAddress(\" + BluetoothUtils.toAnonymizedAddress(address) + \")\");\n        for (int i = 0; i < n; i++) {\n            try {\n                mRemoteCallbacks.getBroadcastItem(i).onAdapterAddressChange(address);\n            } catch (RemoteException e) {\n                Log.d(TAG, \"updateAdapterAddress() - Callback #\" + i + \" failed (\" + e + \")\");\n            }\n        }\n        mRemoteCallbacks.finishBroadcast();\n    }\n\n    void updateAdapterState(int prevState, int newState) {\n        mAdapterProperties.setState(newState);\n        invalidateBluetoothGetStateCache();\n\n        // Only BluetoothManagerService should be registered\n        int n = mRemoteCallbacks.beginBroadcast();\n        Log.d(\n                TAG,\n                \"updateAdapterState() - Broadcasting state \"\n                        + BluetoothAdapter.nameForState(newState)\n                        + \" to \"\n                        + n\n                        + \" receivers.\");\n        for (int i = 0; i < n; i++) {\n            try {\n                mRemoteCallbacks.getBroadcastItem(i).onBluetoothStateChange(prevState, newState);\n            } catch (RemoteException e) {\n                Log.d(TAG, \"updateAdapterState() - Callback #\" + i + \" failed (\" + e + \")\");\n            }\n        }\n        mRemoteCallbacks.finishBroadcast();\n\n        for (Map.Entry<BluetoothStateCallback, Executor> e : mLocalCallbacks.entrySet()) {\n            e.getValue().execute(() -> e.getKey().onBluetoothStateChange(prevState, newState));\n        }\n\n        // Turn the Adapter all the way off if we are disabling and the snoop log setting changed.\n        if (newState == BluetoothAdapter.STATE_BLE_TURNING_ON) {\n            sSnoopLogSettingAtEnable =\n                    BluetoothProperties.snoop_log_mode()\n                            .orElse(BluetoothProperties.snoop_log_mode_values.EMPTY);\n            sDefaultSnoopLogSettingAtEnable =\n                    Settings.Global.getString(\n                            getContentResolver(), Settings.Global.BLUETOOTH_BTSNOOP_DEFAULT_MODE);\n\n            sSnoopLogFilterHeadersSettingAtEnable =\n                    BluetoothProperties.snoop_log_filter_snoop_headers_enabled().orElse(false);\n            sSnoopLogFilterProfileA2dpSettingAtEnable =\n                    BluetoothProperties.snoop_log_filter_profile_a2dp_enabled().orElse(false);\n            sSnoopLogFilterProfileRfcommSettingAtEnable =\n                    BluetoothProperties.snoop_log_filter_profile_rfcomm_enabled().orElse(false);\n            sSnoopLogFilterProfilePbapModeSettingAtEnable =\n                    BluetoothProperties.snoop_log_filter_profile_pbap()\n                            .orElse(BluetoothProperties.snoop_log_filter_profile_pbap_values.EMPTY);\n            sSnoopLogFilterProfileMapModeSettingAtEnable =\n                    BluetoothProperties.snoop_log_filter_profile_map()\n                            .orElse(BluetoothProperties.snoop_log_filter_profile_map_values.EMPTY);\n\n            BluetoothProperties.snoop_default_mode(\n                    BluetoothProperties.snoop_default_mode_values.DISABLED);\n            for (BluetoothProperties.snoop_default_mode_values value :\n                    BluetoothProperties.snoop_default_mode_values.values()) {\n                if (value.getPropValue().equals(sDefaultSnoopLogSettingAtEnable)) {\n                    BluetoothProperties.snoop_default_mode(value);\n                }\n            }\n        } else if (newState == BluetoothAdapter.STATE_BLE_ON\n                && prevState != BluetoothAdapter.STATE_OFF) {\n            var snoopLogSetting =\n                    BluetoothProperties.snoop_log_mode()\n                            .orElse(BluetoothProperties.snoop_log_mode_values.EMPTY);\n            var snoopDefaultModeSetting =\n                    Settings.Global.getString(\n                            getContentResolver(), Settings.Global.BLUETOOTH_BTSNOOP_DEFAULT_MODE);\n\n            var snoopLogFilterHeadersSettingAtEnable =\n                    BluetoothProperties.snoop_log_filter_snoop_headers_enabled().orElse(false);\n            var snoopLogFilterProfileA2dpSettingAtEnable =\n                    BluetoothProperties.snoop_log_filter_profile_a2dp_enabled().orElse(false);\n            var snoopLogFilterProfileRfcommSettingAtEnable =\n                    BluetoothProperties.snoop_log_filter_profile_rfcomm_enabled().orElse(false);\n\n            var snoopLogFilterProfilePbapModeSetting =\n                    BluetoothProperties.snoop_log_filter_profile_pbap()\n                            .orElse(BluetoothProperties.snoop_log_filter_profile_pbap_values.EMPTY);\n            var snoopLogFilterProfileMapModeSetting =\n                    BluetoothProperties.snoop_log_filter_profile_map()\n                            .orElse(BluetoothProperties.snoop_log_filter_profile_map_values.EMPTY);\n\n            if (!(sSnoopLogSettingAtEnable == snoopLogSetting)\n                    || !(Objects.equals(sDefaultSnoopLogSettingAtEnable, snoopDefaultModeSetting))\n                    || !(sSnoopLogFilterHeadersSettingAtEnable\n                            == snoopLogFilterHeadersSettingAtEnable)\n                    || !(sSnoopLogFilterProfileA2dpSettingAtEnable\n                            == snoopLogFilterProfileA2dpSettingAtEnable)\n                    || !(sSnoopLogFilterProfileRfcommSettingAtEnable\n                            == snoopLogFilterProfileRfcommSettingAtEnable)\n                    || !(sSnoopLogFilterProfilePbapModeSettingAtEnable\n                            == snoopLogFilterProfilePbapModeSetting)\n                    || !(sSnoopLogFilterProfileMapModeSettingAtEnable\n                            == snoopLogFilterProfileMapModeSetting)) {\n                mAdapterStateMachine.sendMessage(AdapterState.BLE_TURN_OFF);\n            }\n        }\n    }\n\n    void linkQualityReportCallback(\n            long timestamp,\n            int reportId,\n            int rssi,\n            int snr,\n            int retransmissionCount,\n            int packetsNotReceiveCount,\n            int negativeAcknowledgementCount) {\n        BluetoothInCallService bluetoothInCallService = BluetoothInCallService.getInstance();\n\n        if (reportId == BqrQualityReportId.QUALITY_REPORT_ID_SCO_VOICE_CHOPPY.getValue()) {\n            if (bluetoothInCallService == null) {\n                Log.w(\n                        TAG,\n                        \"No BluetoothInCallService while trying to send BQR.\"\n                                + (\" timestamp: \" + timestamp)\n                                + (\" reportId: \" + reportId)\n                                + (\" rssi: \" + rssi)\n                                + (\" snr: \" + snr)\n                                + (\" retransmissionCount: \" + retransmissionCount)\n                                + (\" packetsNotReceiveCount: \" + packetsNotReceiveCount)\n                                + (\" negativeAcknowledgementCount: \"\n                                        + negativeAcknowledgementCount));\n                return;\n            }\n            bluetoothInCallService.sendBluetoothCallQualityReport(\n                    timestamp,\n                    rssi,\n                    snr,\n                    retransmissionCount,\n                    packetsNotReceiveCount,\n                    negativeAcknowledgementCount);\n        }\n    }\n\n    /**\n     * Callback from Bluetooth Quality Report Native Interface to inform the listeners about\n     * Bluetooth Quality.\n     *\n     * @param device is the BluetoothDevice which connection quality is being reported\n     * @param bluetoothQualityReport a Parcel that contains information about Bluetooth Quality\n     * @return whether the Bluetooth stack acknowledged the change successfully\n     */\n    public int bluetoothQualityReportReadyCallback(\n            BluetoothDevice device, BluetoothQualityReport bluetoothQualityReport) {\n        synchronized (mBluetoothQualityReportReadyCallbacks) {\n            int n = mBluetoothQualityReportReadyCallbacks.beginBroadcast();\n            Log.d(\n                    TAG,\n                    \"bluetoothQualityReportReadyCallback() - \"\n                            + \"Broadcasting Bluetooth Quality Report to \"\n                            + n\n                            + \" receivers.\");\n            for (int i = 0; i < n; i++) {\n                try {\n                    mBluetoothQualityReportReadyCallbacks\n                            .getBroadcastItem(i)\n                            .onBluetoothQualityReportReady(\n                                    device, bluetoothQualityReport, BluetoothStatusCodes.SUCCESS);\n                } catch (RemoteException e) {\n                    Log.d(\n                            TAG,\n                            \"bluetoothQualityReportReadyCallback() - Callback #\"\n                                    + i\n                                    + \" failed (\"\n                                    + e\n                                    + \")\");\n                }\n            }\n            mBluetoothQualityReportReadyCallbacks.finishBroadcast();\n        }\n\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    void switchBufferSizeCallback(boolean isLowLatencyBufferSize) {\n        List<BluetoothDevice> activeDevices = getActiveDevices(BluetoothProfile.A2DP);\n        if (activeDevices.size() != 1) {\n            Log.e(\n                    TAG,\n                    \"Cannot switch buffer size. The number of A2DP active devices is \"\n                            + activeDevices.size());\n            return;\n        }\n\n        // Send intent to fastpair\n        Intent switchBufferSizeIntent = new Intent(BluetoothDevice.ACTION_SWITCH_BUFFER_SIZE);\n        switchBufferSizeIntent.setClassName(\n                getString(com.android.bluetooth.R.string.peripheral_link_package),\n                getString(com.android.bluetooth.R.string.peripheral_link_package)\n                        + getString(com.android.bluetooth.R.string.peripheral_link_service));\n        switchBufferSizeIntent.putExtra(BluetoothDevice.EXTRA_DEVICE, activeDevices.get(0));\n        switchBufferSizeIntent.putExtra(\n                BluetoothDevice.EXTRA_LOW_LATENCY_BUFFER_SIZE, isLowLatencyBufferSize);\n        sendBroadcastMultiplePermissions(\n                switchBufferSizeIntent,\n                new String[] {BLUETOOTH_CONNECT, BLUETOOTH_PRIVILEGED},\n                null);\n    }\n\n    void switchCodecCallback(boolean isLowLatencyBufferSize) {\n        List<BluetoothDevice> activeDevices = getActiveDevices(BluetoothProfile.A2DP);\n        if (activeDevices.size() != 1) {\n            Log.e(\n                    TAG,\n                    \"Cannot switch buffer size. The number of A2DP active devices is \"\n                            + activeDevices.size());\n            return;\n        }\n        mA2dpService.switchCodecByBufferSize(activeDevices.get(0), isLowLatencyBufferSize);\n    }\n\n    @RequiresPermission(BLUETOOTH_CONNECT)\n    void cleanup() {\n        Log.d(TAG, \"cleanup()\");\n        if (mCleaningUp) {\n            Log.e(TAG, \"cleanup() - Service already starting to cleanup, ignoring request...\");\n            return;\n        }\n\n        closeMetricsLogger();\n\n        clearAdapterService(this);\n\n        mCleaningUp = true;\n        invalidateBluetoothCaches();\n\n        stopRfcommServerSockets();\n\n        // This wake lock release may also be called concurrently by\n        // {@link #releaseWakeLock(String lockName)}, so a synchronization is needed here.\n        synchronized (this) {\n            if (mWakeLock != null) {\n                if (mWakeLock.isHeld()) {\n                    mWakeLock.release();\n                }\n                mWakeLock = null;\n            }\n        }\n\n        mDatabaseManager.cleanup();\n\n        if (mAdapterStateMachine != null) {\n            mAdapterStateMachine.doQuit();\n        }\n\n        if (mBondStateMachine != null) {\n            mBondStateMachine.doQuit();\n        }\n\n        if (mRemoteDevices != null) {\n            mRemoteDevices.reset();\n        }\n\n        if (mSdpManager != null) {\n            mSdpManager.cleanup();\n            mSdpManager = null;\n        }\n\n        if (mNativeAvailable) {\n            Log.d(TAG, \"cleanup() - Cleaning up adapter native\");\n            mNativeInterface.cleanup();\n            mNativeAvailable = false;\n        }\n\n        if (mAdapterProperties != null) {\n            mAdapterProperties.cleanup();\n        }\n\n        if (mNativeInterface.getCallbacks() != null) {\n            mNativeInterface.getCallbacks().cleanup();\n        }\n\n        if (mBluetoothKeystoreService != null) {\n            Log.d(TAG, \"cleanup(): mBluetoothKeystoreService.cleanup()\");\n            mBluetoothKeystoreService.cleanup();\n        }\n\n        if (mPhonePolicy != null) {\n            mPhonePolicy.cleanup();\n        }\n\n        mSilenceDeviceManager.cleanup();\n\n        if (mActiveDeviceManager != null) {\n            mActiveDeviceManager.cleanup();\n        }\n\n        if (mBluetoothSocketManagerBinder != null) {\n            mBluetoothSocketManagerBinder.cleanUp();\n            mBluetoothSocketManagerBinder = null;\n        }\n\n        if (mAdapterSuspend != null) {\n            mAdapterSuspend.cleanup();\n            mAdapterSuspend = null;\n        }\n\n        mPreferredAudioProfilesCallbacks.kill();\n\n        mBluetoothQualityReportReadyCallbacks.kill();\n\n        mBluetoothConnectionCallbacks.kill();\n\n        mRemoteCallbacks.kill();\n\n        mMetadataListeners.values().forEach(v -> v.kill());\n    }\n\n    private void invalidateBluetoothCaches() {\n        BluetoothAdapter.invalidateGetProfileConnectionStateCache();\n        BluetoothAdapter.invalidateIsOffloadedFilteringSupportedCache();\n        BluetoothDevice.invalidateBluetoothGetBondStateCache();\n        if (!Flags.getStateFromSystemServer()) {\n            BluetoothAdapter.invalidateBluetoothGetStateCache();\n        }\n        BluetoothAdapter.invalidateGetAdapterConnectionStateCache();\n        BluetoothMap.invalidateBluetoothGetConnectionStateCache();\n        BluetoothSap.invalidateBluetoothGetConnectionStateCache();\n    }\n\n    private static final Map<Integer, Function<AdapterService, ProfileService>>\n            PROFILE_CONSTRUCTORS =\n                    Map.ofEntries(\n                            Map.entry(BluetoothProfile.A2DP, A2dpService::new),\n                            Map.entry(BluetoothProfile.A2DP_SINK, A2dpSinkService::new),\n                            Map.entry(BluetoothProfile.AVRCP, AvrcpTargetService::new),\n                            Map.entry(\n                                    BluetoothProfile.AVRCP_CONTROLLER, AvrcpControllerService::new),\n                            Map.entry(\n                                    BluetoothProfile.LE_AUDIO_BROADCAST_ASSISTANT,\n                                    BassClientService::new),\n                            Map.entry(BluetoothProfile.BATTERY, BatteryService::new),\n                            Map.entry(\n                                    BluetoothProfile.CSIP_SET_COORDINATOR,\n                                    CsipSetCoordinatorService::new),\n                            Map.entry(BluetoothProfile.HAP_CLIENT, HapClientService::new),\n                            Map.entry(BluetoothProfile.HEADSET, HeadsetService::new),\n                            Map.entry(BluetoothProfile.HEADSET_CLIENT, HeadsetClientService::new),\n                            Map.entry(BluetoothProfile.HEARING_AID, HearingAidService::new),\n                            Map.entry(BluetoothProfile.HID_DEVICE, HidDeviceService::new),\n                            Map.entry(BluetoothProfile.HID_HOST, HidHostService::new),\n                            Map.entry(BluetoothProfile.GATT, GattService::new),\n                            Map.entry(BluetoothProfile.LE_AUDIO, LeAudioService::new),\n                            Map.entry(BluetoothProfile.LE_CALL_CONTROL, TbsService::new),\n                            Map.entry(BluetoothProfile.MAP, BluetoothMapService::new),\n                            Map.entry(BluetoothProfile.MAP_CLIENT, MapClientService::new),\n                            Map.entry(BluetoothProfile.MCP_SERVER, McpService::new),\n                            Map.entry(BluetoothProfile.OPP, BluetoothOppService::new),\n                            Map.entry(BluetoothProfile.PAN, PanService::new),\n                            Map.entry(BluetoothProfile.PBAP, BluetoothPbapService::new),\n                            Map.entry(BluetoothProfile.PBAP_CLIENT, PbapClientService::new),\n                            Map.entry(BluetoothProfile.SAP, SapService::new),\n                            Map.entry(BluetoothProfile.VOLUME_CONTROL, VolumeControlService::new));\n\n    @VisibleForTesting\n    void setProfileServiceState(int profileId, int state) {\n        if (state == BluetoothAdapter.STATE_ON) {\n            if (!mStartedProfiles.containsKey(profileId)) {\n                ProfileService profileService = PROFILE_CONSTRUCTORS.get(profileId).apply(this);\n                mStartedProfiles.put(profileId, profileService);\n                addProfile(profileService);\n                profileService.start();\n                profileService.setAvailable(true);\n                // With `Flags.scanManagerRefactor()` GattService initialization is pushed back to\n                // `ON` state instead of `BLE_ON`. Here we ensure mGattService is set prior\n                // to other Profiles using it.\n                if (profileId == BluetoothProfile.GATT && Flags.scanManagerRefactor()) {\n                    mGattService = GattService.getGattService();\n                }\n                onProfileServiceStateChanged(profileService, BluetoothAdapter.STATE_ON);\n            } else {\n                Log.e(\n                        TAG,\n                        \"setProfileServiceState(\"\n                                + BluetoothProfile.getProfileName(profileId)\n                                + \", STATE_ON): profile is already started\");\n            }\n        } else if (state == BluetoothAdapter.STATE_OFF) {\n            ProfileService profileService = mStartedProfiles.remove(profileId);\n            if (profileService != null) {\n                profileService.setAvailable(false);\n                onProfileServiceStateChanged(profileService, BluetoothAdapter.STATE_OFF);\n                profileService.stop();\n                removeProfile(profileService);\n                profileService.cleanup();\n                if (profileService.getBinder() != null) {\n                    profileService.getBinder().cleanup();\n                }\n            } else {\n                Log.e(\n                        TAG,\n                        \"setProfileServiceState(\"\n                                + BluetoothProfile.getProfileName(profileId)\n                                + \", STATE_OFF): profile is already stopped\");\n            }\n        }\n    }\n\n    private void setAllProfileServiceStates(int[] profileIds, int state) {\n        for (int profileId : profileIds) {\n            if (!Flags.scanManagerRefactor()) {\n                // TODO(b/228875190): GATT is assumed supported and treated differently as part of\n                //  the \"BLE ON\" state, despite GATT not being BLE specific.\n                if (profileId == BluetoothProfile.GATT) {\n                    continue;\n                }\n            }\n            setProfileServiceState(profileId, state);\n        }\n    }\n\n    /**\n     * Checks whether the remote device is a dual mode audio sink device (supports both classic and\n     * LE Audio sink roles.\n     *\n     * @param device the remote device\n     * @return {@code true} if it's a dual mode audio device, {@code false} otherwise\n     */\n    public boolean isDualModeAudioSinkDevice(BluetoothDevice device) {\n        if (mLeAudioService == null\n                || mLeAudioService.getGroupId(device) == LE_AUDIO_GROUP_ID_INVALID) {\n            return false;\n        }\n\n        // Check if any device in the CSIP group is a dual mode audio sink device\n        for (BluetoothDevice groupDevice :\n                mLeAudioService.getGroupDevices(mLeAudioService.getGroupId(device))) {\n            if (isProfileSupported(groupDevice, BluetoothProfile.LE_AUDIO)\n                    && (isProfileSupported(groupDevice, BluetoothProfile.HEADSET)\n                            || isProfileSupported(groupDevice, BluetoothProfile.A2DP))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Checks whether the local and remote device support a connection for duplex audio (input and\n     * output) over HFP or LE Audio.\n     *\n     * @param groupDevices the devices in the CSIP group\n     * @return {@code true} if duplex is supported on the remote device, {@code false} otherwise\n     */\n    private boolean isDuplexAudioSupported(List<BluetoothDevice> groupDevices) {\n        for (BluetoothDevice device : groupDevices) {\n            if (isProfileSupported(device, BluetoothProfile.HEADSET)\n                    || (isProfileSupported(device, BluetoothProfile.LE_AUDIO)\n                            && mLeAudioService != null\n                            && mLeAudioService.isLeAudioDuplexSupported(device))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Checks whether the local and remote device support a connection for output only audio over\n     * A2DP or LE Audio.\n     *\n     * @param groupDevices the devices in the CSIP group\n     * @return {@code true} if output only is supported, {@code false} otherwise\n     */\n    private boolean isOutputOnlyAudioSupported(List<BluetoothDevice> groupDevices) {\n        for (BluetoothDevice device : groupDevices) {\n            if (isProfileSupported(device, BluetoothProfile.A2DP)\n                    || (isProfileSupported(device, BluetoothProfile.LE_AUDIO)\n                            && mLeAudioService != null\n                            && mLeAudioService.isLeAudioOutputSupported(device))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Verifies whether the profile is supported by the local bluetooth adapter by checking a\n     * bitmask of its supported profiles\n     *\n     * @param device is the remote device we wish to connect to\n     * @param profile is the profile we are checking for support\n     * @return true if the profile is supported by both the local and remote device, false otherwise\n     */\n    @VisibleForTesting\n    boolean isProfileSupported(BluetoothDevice device, int profile) {\n        final ParcelUuid[] remoteDeviceUuids = getRemoteUuids(device);\n        final ParcelUuid[] localDeviceUuids = mAdapterProperties.getUuids();\n        if (remoteDeviceUuids == null || remoteDeviceUuids.length == 0) {\n            Log.e(\n                    TAG,\n                    \"isProfileSupported(\"\n                            + (\"device=\" + device)\n                            + (\", profile=\" + BluetoothProfile.getProfileName(profile) + \"):\")\n                            + \" remote device Uuids Empty\");\n        }\n\n        Log.v(\n                TAG,\n                \"isProfileSupported(\"\n                        + (\"device=\" + device)\n                        + (\", profile=\" + BluetoothProfile.getProfileName(profile) + \"):\")\n                        + (\" local_uuids=\" + Arrays.toString(localDeviceUuids))\n                        + (\", remote_uuids=\" + Arrays.toString(remoteDeviceUuids)));\n\n        if (profile == BluetoothProfile.HEADSET) {\n            return (Utils.arrayContains(localDeviceUuids, BluetoothUuid.HSP_AG)\n                            && Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HSP))\n                    || (Utils.arrayContains(localDeviceUuids, BluetoothUuid.HFP_AG)\n                            && Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HFP));\n        }\n        if (profile == BluetoothProfile.HEADSET_CLIENT) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HFP_AG)\n                    && Utils.arrayContains(localDeviceUuids, BluetoothUuid.HFP);\n        }\n        if (profile == BluetoothProfile.A2DP) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.ADV_AUDIO_DIST)\n                    || Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.A2DP_SINK);\n        }\n        if (profile == BluetoothProfile.A2DP_SINK) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.ADV_AUDIO_DIST)\n                    || Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.A2DP_SOURCE);\n        }\n        if (profile == BluetoothProfile.OPP) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.OBEX_OBJECT_PUSH);\n        }\n        if (profile == BluetoothProfile.HID_HOST) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HID)\n                    || Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HOGP)\n                    || (Flags.androidHeadtrackerService()\n                            && Utils.arrayContains(\n                                    remoteDeviceUuids, HidHostService.ANDROID_HEADTRACKER_UUID));\n        }\n        if (profile == BluetoothProfile.HID_DEVICE) {\n            return mHidDeviceService.getConnectionState(device)\n                    == BluetoothProfile.STATE_DISCONNECTED;\n        }\n        if (profile == BluetoothProfile.PAN) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.NAP);\n        }\n        if (profile == BluetoothProfile.MAP) {\n            return mMapService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED;\n        }\n        if (profile == BluetoothProfile.PBAP) {\n            return mPbapService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED;\n        }\n        if (profile == BluetoothProfile.MAP_CLIENT) {\n            return Utils.arrayContains(localDeviceUuids, BluetoothUuid.MNS)\n                    && Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.MAS);\n        }\n        if (profile == BluetoothProfile.PBAP_CLIENT) {\n            return Utils.arrayContains(localDeviceUuids, BluetoothUuid.PBAP_PCE)\n                    && Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.PBAP_PSE);\n        }\n        if (profile == BluetoothProfile.HEARING_AID) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HEARING_AID);\n        }\n        if (profile == BluetoothProfile.SAP) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.SAP);\n        }\n        if (profile == BluetoothProfile.VOLUME_CONTROL) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.VOLUME_CONTROL);\n        }\n        if (profile == BluetoothProfile.CSIP_SET_COORDINATOR) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.COORDINATED_SET);\n        }\n        if (profile == BluetoothProfile.LE_AUDIO) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.LE_AUDIO);\n        }\n        if (profile == BluetoothProfile.HAP_CLIENT) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HAS);\n        }\n        if (profile == BluetoothProfile.LE_AUDIO_BROADCAST_ASSISTANT) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.BASS);\n        }\n        if (profile == BluetoothProfile.BATTERY) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.BATTERY);\n        }\n\n        Log.e(TAG, \"isSupported: Unexpected profile passed in to function: \" + profile);\n        return false;\n    }\n\n    /**\n     * Checks if the connection policy of all profiles are unknown for the given device\n     *\n     * @param device is the device for which we are checking if the connection policy of all\n     *     profiles are unknown\n     * @return false if one of profile is enabled or disabled, true otherwise\n     */\n    boolean isAllProfilesUnknown(BluetoothDevice device) {\n        if (mA2dpService != null\n                && mA2dpService.getConnectionPolicy(device)\n                        != BluetoothProfile.CONNECTION_POLICY_UNKNOWN) {\n            return false;\n        }\n        if (mA2dpSinkService != null\n                && mA2dpSinkService.getConnectionPolicy(device)\n                        != BluetoothProfile.CONNECTION_POLICY_UNKNOWN) {\n            return false;\n        }\n        if (mHeadsetService != null\n                && mHeadsetService.getConnectionPolicy(device)\n                        != BluetoothProfile.CONNECTION_POLICY_UNKNOWN) {\n            return false;\n        }\n        if (mHeadsetClientService != null\n                && mHeadsetClientService.getConnectionPolicy(device)\n                        != BluetoothProfile.CONNECTION_POLICY_UNKNOWN) {\n            return false;\n        }\n        if (mMapClientService != null\n                && mMapClientService.getConnectionPolicy(device)\n                        != BluetoothProfile.CONNECTION_POLICY_UNKNOWN) {\n            return false;\n        }\n        if (mHidHostService != null\n                && mHidHostService.getConnectionPolicy(device)\n                        != BluetoothProfile.CONNECTION_POLICY_UNKNOWN) {\n            return false;\n        }\n        if (mPanService != null\n                && mPanService.getConnectionPolicy(device)\n                        != BluetoothProfile.CONNECTION_POLICY_UNKNOWN) {\n            return false;\n        }\n        if (mPbapClientService != null\n                && mPbapClientService.getConnectionPolicy(device)\n                        != BluetoothProfile.CONNECTION_POLICY_UNKNOWN) {\n            return false;\n        }\n        if (mHearingAidService != null\n                && mHearingAidService.getConnectionPolicy(device)\n                        != BluetoothProfile.CONNECTION_POLICY_UNKNOWN) {\n            return false;\n        }\n        if (mHapClientService != null\n                && mHapClientService.getConnectionPolicy(device)\n                        != BluetoothProfile.CONNECTION_POLICY_UNKNOWN) {\n            return false;\n        }\n        if (mVolumeControlService != null\n                && mVolumeControlService.getConnectionPolicy(device)\n                        != BluetoothProfile.CONNECTION_POLICY_UNKNOWN) {\n            return false;\n        }\n        if (mCsipSetCoordinatorService != null\n                && mCsipSetCoordinatorService.getConnectionPolicy(device)\n                        != BluetoothProfile.CONNECTION_POLICY_UNKNOWN) {\n            return false;\n        }\n        if (mLeAudioService != null\n                && mLeAudioService.getConnectionPolicy(device)\n                        != BluetoothProfile.CONNECTION_POLICY_UNKNOWN) {\n            return false;\n        }\n        if (mBassClientService != null\n                && mBassClientService.getConnectionPolicy(device)\n                        != BluetoothProfile.CONNECTION_POLICY_UNKNOWN) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Connects only available profiles (those with {@link\n     * BluetoothProfile#CONNECTION_POLICY_ALLOWED})\n     *\n     * @param device is the device with which we are connecting the profiles\n     * @return {@link BluetoothStatusCodes#SUCCESS}\n     */\n    private int connectEnabledProfiles(BluetoothDevice device) {\n        if (mCsipSetCoordinatorService != null\n                && isProfileSupported(device, BluetoothProfile.CSIP_SET_COORDINATOR)\n                && mCsipSetCoordinatorService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Coordinated Set Profile\");\n            mCsipSetCoordinatorService.connect(device);\n        }\n        if (mA2dpService != null\n                && isProfileSupported(device, BluetoothProfile.A2DP)\n                && mA2dpService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting A2dp\");\n            mA2dpService.connect(device);\n        }\n        if (mA2dpSinkService != null\n                && isProfileSupported(device, BluetoothProfile.A2DP_SINK)\n                && mA2dpSinkService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting A2dp Sink\");\n            mA2dpSinkService.connect(device);\n        }\n        if (mHeadsetService != null\n                && isProfileSupported(device, BluetoothProfile.HEADSET)\n                && mHeadsetService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Headset Profile\");\n            mHeadsetService.connect(device);\n        }\n        if (mHeadsetClientService != null\n                && isProfileSupported(device, BluetoothProfile.HEADSET_CLIENT)\n                && mHeadsetClientService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting HFP\");\n            mHeadsetClientService.connect(device);\n        }\n        if (mMapClientService != null\n                && isProfileSupported(device, BluetoothProfile.MAP_CLIENT)\n                && mMapClientService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting MAP\");\n            mMapClientService.connect(device);\n        }\n        if (mHidHostService != null\n                && isProfileSupported(device, BluetoothProfile.HID_HOST)\n                && mHidHostService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Hid Host Profile\");\n            mHidHostService.connect(device);\n        }\n        if (mPanService != null\n                && isProfileSupported(device, BluetoothProfile.PAN)\n                && mPanService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Pan Profile\");\n            mPanService.connect(device);\n        }\n        if (mPbapClientService != null\n                && isProfileSupported(device, BluetoothProfile.PBAP_CLIENT)\n                && mPbapClientService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Pbap\");\n            mPbapClientService.connect(device);\n        }\n        if (mHearingAidService != null\n                && isProfileSupported(device, BluetoothProfile.HEARING_AID)\n                && mHearingAidService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Hearing Aid Profile\");\n            mHearingAidService.connect(device);\n        }\n        if (mHapClientService != null\n                && isProfileSupported(device, BluetoothProfile.HAP_CLIENT)\n                && mHapClientService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting HAS Profile\");\n            mHapClientService.connect(device);\n        }\n        if (mVolumeControlService != null\n                && isProfileSupported(device, BluetoothProfile.VOLUME_CONTROL)\n                && mVolumeControlService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Volume Control Profile\");\n            mVolumeControlService.connect(device);\n        }\n        if (mLeAudioService != null\n                && isProfileSupported(device, BluetoothProfile.LE_AUDIO)\n                && mLeAudioService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting LeAudio profile (BAP)\");\n            mLeAudioService.connect(device);\n        }\n        if (mBassClientService != null\n                && isProfileSupported(device, BluetoothProfile.LE_AUDIO_BROADCAST_ASSISTANT)\n                && mBassClientService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting LE Broadcast Assistant Profile\");\n            mBassClientService.connect(device);\n        }\n        if (mBatteryService != null\n                && isProfileSupported(device, BluetoothProfile.BATTERY)\n                && mBatteryService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Battery Service\");\n            mBatteryService.connect(device);\n        }\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    /**\n     * Verifies that all bluetooth profile services are running\n     *\n     * @return true if all bluetooth profile services running, false otherwise\n     */\n    private boolean profileServicesRunning() {\n        if (mRegisteredProfiles.size() == Config.getSupportedProfiles().length\n                && mRegisteredProfiles.size() == mRunningProfiles.size()) {\n            return true;\n        }\n\n        Log.e(TAG, \"profileServicesRunning: One or more supported services not running\");\n        return false;\n    }\n\n    /** Initializes all the profile services fields */\n    private void initProfileServices() {\n        Log.i(TAG, \"initProfileServices: Initializing all bluetooth profile services\");\n        mA2dpService = A2dpService.getA2dpService();\n        mA2dpSinkService = A2dpSinkService.getA2dpSinkService();\n        mHeadsetService = HeadsetService.getHeadsetService();\n        mHeadsetClientService = HeadsetClientService.getHeadsetClientService();\n        mMapService = BluetoothMapService.getBluetoothMapService();\n        mMapClientService = MapClientService.getMapClientService();\n        mHidDeviceService = HidDeviceService.getHidDeviceService();\n        mHidHostService = HidHostService.getHidHostService();\n        mPanService = PanService.getPanService();\n        mPbapService = BluetoothPbapService.getBluetoothPbapService();\n        mPbapClientService = PbapClientService.getPbapClientService();\n        mHearingAidService = HearingAidService.getHearingAidService();\n        mHapClientService = HapClientService.getHapClientService();\n        mSapService = SapService.getSapService();\n        mVolumeControlService = VolumeControlService.getVolumeControlService();\n        mCsipSetCoordinatorService = CsipSetCoordinatorService.getCsipSetCoordinatorService();\n        mLeAudioService = LeAudioService.getLeAudioService();\n        mBassClientService = BassClientService.getBassClientService();\n        mBatteryService = BatteryService.getBatteryService();\n    }\n\n    @BluetoothAdapter.RfcommListenerResult\n    @RequiresPermission(BLUETOOTH_CONNECT)\n    private int startRfcommListener(\n            String name, ParcelUuid uuid, PendingIntent pendingIntent, AttributionSource source) {\n        if (mBluetoothServerSockets.containsKey(uuid.getUuid())) {\n            Log.d(TAG, \"Cannot start RFCOMM listener: UUID \" + uuid.getUuid() + \"already in use.\");\n            return BluetoothStatusCodes.RFCOMM_LISTENER_START_FAILED_UUID_IN_USE;\n        }\n\n        try {\n            startRfcommListenerInternal(name, uuid.getUuid(), pendingIntent, source);\n        } catch (IOException e) {\n            return BluetoothStatusCodes.RFCOMM_LISTENER_FAILED_TO_CREATE_SERVER_SOCKET;\n        }\n\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    @BluetoothAdapter.RfcommListenerResult\n    @VisibleForTesting\n    int stopRfcommListener(ParcelUuid uuid, AttributionSource source) {\n        RfcommListenerData listenerData = mBluetoothServerSockets.get(uuid.getUuid());\n\n        if (listenerData == null) {\n            Log.d(TAG, \"Cannot stop RFCOMM listener: UUID \" + uuid.getUuid() + \"is not registered\");\n            return BluetoothStatusCodes.RFCOMM_LISTENER_OPERATION_FAILED_NO_MATCHING_SERVICE_RECORD;\n        }\n\n        if (source.getUid() != listenerData.mAttributionSource.getUid()) {\n            return BluetoothStatusCodes.RFCOMM_LISTENER_OPERATION_FAILED_DIFFERENT_APP;\n        }\n\n        // Remove the entry so that it does not try and restart the server socket.\n        mBluetoothServerSockets.remove(uuid.getUuid());\n\n        return listenerData.closeServerAndPendingSockets(mHandler);\n    }\n\n    @VisibleForTesting\n    IncomingRfcommSocketInfo retrievePendingSocketForServiceRecord(\n            ParcelUuid uuid, AttributionSource source) {\n        IncomingRfcommSocketInfo socketInfo = new IncomingRfcommSocketInfo();\n\n        RfcommListenerData listenerData = mBluetoothServerSockets.get(uuid.getUuid());\n\n        if (listenerData == null) {\n            socketInfo.status =\n                    BluetoothStatusCodes\n                            .RFCOMM_LISTENER_OPERATION_FAILED_NO_MATCHING_SERVICE_RECORD;\n            return socketInfo;\n        }\n\n        if (source.getUid() != listenerData.mAttributionSource.getUid()) {\n            socketInfo.status = BluetoothStatusCodes.RFCOMM_LISTENER_OPERATION_FAILED_DIFFERENT_APP;\n            return socketInfo;\n        }\n\n        BluetoothSocket socket = listenerData.mPendingSockets.poll();\n\n        if (socket == null) {\n            socketInfo.status = BluetoothStatusCodes.RFCOMM_LISTENER_NO_SOCKET_AVAILABLE;\n            return socketInfo;\n        }\n\n        mHandler.removeCallbacksAndMessages(socket);\n\n        socketInfo.bluetoothDevice = socket.getRemoteDevice();\n        socketInfo.pfd = socket.getParcelFileDescriptor();\n        socketInfo.status = BluetoothStatusCodes.SUCCESS;\n\n        return socketInfo;\n    }\n\n    @RequiresPermission(BLUETOOTH_CONNECT)\n    private void handleIncomingRfcommConnections(UUID uuid) {\n        RfcommListenerData listenerData = mBluetoothServerSockets.get(uuid);\n        while (true) {\n            BluetoothSocket socket;\n            try {\n                socket = listenerData.mServerSocket.accept();\n            } catch (IOException e) {\n                if (mBluetoothServerSockets.containsKey(uuid)) {\n                    // The uuid still being in the map indicates that the accept failure is\n                    // unexpected. Try and restart the listener.\n                    Log.e(TAG, \"Failed to accept socket on \" + listenerData.mServerSocket, e);\n                    restartRfcommListener(listenerData, uuid);\n                }\n                return;\n            }\n\n            listenerData.mPendingSockets.add(socket);\n            try {\n                listenerData.mPendingIntent.send();\n            } catch (PendingIntent.CanceledException e) {\n                Log.e(TAG, \"PendingIntent for RFCOMM socket notifications cancelled.\", e);\n                // The pending intent was cancelled, close the server as there is no longer any way\n                // to notify the app that registered the listener.\n                listenerData.closeServerAndPendingSockets(mHandler);\n                mBluetoothServerSockets.remove(uuid);\n                return;\n            }\n            mHandler.postDelayed(\n                    () -> pendingSocketTimeoutRunnable(listenerData, socket),\n                    socket,\n                    PENDING_SOCKET_HANDOFF_TIMEOUT.toMillis());\n        }\n    }\n\n    // Tries to restart the rfcomm listener for the given UUID\n    @RequiresPermission(BLUETOOTH_CONNECT)\n    private void restartRfcommListener(RfcommListenerData listenerData, UUID uuid) {\n        listenerData.closeServerAndPendingSockets(mHandler);\n        try {\n            startRfcommListenerInternal(\n                    listenerData.mName,\n                    uuid,\n                    listenerData.mPendingIntent,\n                    listenerData.mAttributionSource);\n        } catch (IOException e) {\n            Log.e(TAG, \"Failed to recreate rfcomm server socket\", e);\n\n            mBluetoothServerSockets.remove(uuid);\n        }\n    }\n\n    private void pendingSocketTimeoutRunnable(\n            RfcommListenerData listenerData, BluetoothSocket socket) {\n        boolean socketFound = listenerData.mPendingSockets.remove(socket);\n        if (socketFound) {\n            try {\n                socket.close();\n            } catch (IOException e) {\n                Log.e(TAG, \"Failed to close bt socket\", e);\n                // We don't care if closing the socket failed, just continue on.\n            }\n        }\n    }\n\n    @RequiresPermission(BLUETOOTH_CONNECT)\n    private void startRfcommListenerInternal(\n            String name, UUID uuid, PendingIntent intent, AttributionSource source)\n            throws IOException {\n        BluetoothServerSocket bluetoothServerSocket =\n                mAdapter.listenUsingRfcommWithServiceRecord(name, uuid);\n\n        RfcommListenerData listenerData =\n                new RfcommListenerData(bluetoothServerSocket, name, intent, source);\n\n        mBluetoothServerSockets.put(uuid, listenerData);\n\n        new Thread(() -> handleIncomingRfcommConnections(uuid)).start();\n    }\n\n    private void stopRfcommServerSockets() {\n        Iterator<Map.Entry<UUID, RfcommListenerData>> socketsIterator =\n                mBluetoothServerSockets.entrySet().iterator();\n        while (socketsIterator.hasNext()) {\n            socketsIterator.next().getValue().closeServerAndPendingSockets(mHandler);\n            socketsIterator.remove();\n        }\n    }\n\n    private static class RfcommListenerData {\n        final BluetoothServerSocket mServerSocket;\n        // Service record name\n        final String mName;\n        // The Intent which contains the Service info to which the incoming socket connections are\n        // handed off to.\n        final PendingIntent mPendingIntent;\n        // AttributionSource for the requester of the RFCOMM listener\n        final AttributionSource mAttributionSource;\n        // Contains the connected sockets which are pending transfer to the app which requested the\n        // listener.\n        final ConcurrentLinkedQueue<BluetoothSocket> mPendingSockets =\n                new ConcurrentLinkedQueue<>();\n\n        RfcommListenerData(\n                BluetoothServerSocket serverSocket,\n                String name,\n                PendingIntent pendingIntent,\n                AttributionSource source) {\n            mServerSocket = serverSocket;\n            mName = name;\n            mPendingIntent = pendingIntent;\n            mAttributionSource = source;\n        }\n\n        int closeServerAndPendingSockets(Handler handler) {\n            int result = BluetoothStatusCodes.SUCCESS;\n            try {\n                mServerSocket.close();\n            } catch (IOException e) {\n                Log.e(TAG, \"Failed to call close on rfcomm server socket\", e);\n                result = BluetoothStatusCodes.RFCOMM_LISTENER_FAILED_TO_CLOSE_SERVER_SOCKET;\n            }\n            mPendingSockets.forEach(\n                    pendingSocket -> {\n                        handler.removeCallbacksAndMessages(pendingSocket);\n                        try {\n                            pendingSocket.close();\n                        } catch (IOException e) {\n                            Log.e(TAG, \"Failed to close socket\", e);\n                        }\n                    });\n            mPendingSockets.clear();\n\n            return result;\n        }\n    }\n\n    @VisibleForTesting\n    boolean isAvailable() {\n        return !mCleaningUp;\n    }\n\n    /**\n     * Set metadata value for the given device and key\n     *\n     * @return true if metadata is set successfully\n     */\n    public boolean setMetadata(BluetoothDevice device, int key, byte[] value) {\n        if (value == null || value.length > BluetoothDevice.METADATA_MAX_LENGTH) {\n            return false;\n        }\n        return mDatabaseManager.setCustomMeta(device, key, value);\n    }\n\n    /**\n     * Get metadata of given device and key\n     *\n     * @return value of given device and key combination\n     */\n    public byte[] getMetadata(BluetoothDevice device, int key) {\n        return mDatabaseManager.getCustomMeta(device, key);\n    }\n\n    /** Update Adapter Properties when BT profiles connection state changes. */\n    public void updateProfileConnectionAdapterProperties(\n            BluetoothDevice device, int profile, int state, int prevState) {\n        mHandler.post(\n                () ->\n                        mAdapterProperties.updateOnProfileConnectionChanged(\n                                device, profile, state, prevState));\n    }\n\n    /**\n     * There is no leak of this binder since it is never re-used and the process is systematically\n     * killed\n     */\n    @VisibleForTesting\n    public static class AdapterServiceBinder extends IBluetooth.Stub {\n        private final AdapterService mService;\n\n        AdapterServiceBinder(AdapterService svc) {\n            mService = svc;\n            if (Flags.getStateFromSystemServer()) {\n                return;\n            }\n            mService.invalidateBluetoothGetStateCache();\n            BluetoothAdapter.getDefaultAdapter().disableBluetoothGetStateCache();\n        }\n\n        public AdapterService getService() {\n            if (!mService.isAvailable()) {\n                return null;\n            }\n            return mService;\n        }\n\n        @Override\n        public int getState() {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothAdapter.STATE_OFF;\n            }\n\n            return service.getState();\n        }\n\n        @Override\n        public void killBluetoothProcess() {\n            mService.enforceCallingPermission(BLUETOOTH_PRIVILEGED, null);\n\n            Runnable killAction =\n                    () -> {\n                        if (Flags.killInsteadOfExit()) {\n                            Log.i(TAG, \"killBluetoothProcess: Calling killProcess(myPid())\");\n                            Process.killProcess(Process.myPid());\n                        } else {\n                            Log.i(TAG, \"killBluetoothProcess: Calling System.exit\");\n                            System.exit(0);\n                        }\n                    };\n\n            // Post on the main handler to let the cleanup complete before calling exit\n            mService.mHandler.post(killAction);\n\n            try {\n                // Wait for Bluetooth to be killed from its main thread\n                Thread.sleep(1_000); // SystemServer is waiting 2000 ms, we need to wait less here\n            } catch (InterruptedException e) {\n                Log.e(TAG, \"killBluetoothProcess: Interrupted while waiting for kill\");\n            }\n\n            // Bluetooth cannot be killed on the main thread; it is in a deadLock.\n            // Trying to recover by killing the Bluetooth from the binder thread.\n            // This is bad :(\n            Counter.logIncrement(\"bluetooth.value_kill_from_binder_thread\");\n            Log.wtf(TAG, \"Failed to kill Bluetooth using its main thread. Trying from binder\");\n            killAction.run();\n        }\n\n        @Override\n        public void offToBleOn(boolean quietMode, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"offToBleOn\")) {\n                return;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            service.offToBleOn(quietMode);\n        }\n\n        @Override\n        public void onToBleOn(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"onToBleOn\")) {\n                return;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            service.onToBleOn();\n        }\n\n        @Override\n        public String getAddress(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getAddress\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getAddress\")) {\n                return null;\n            }\n\n            service.enforceCallingOrSelfPermission(LOCAL_MAC_ADDRESS, null);\n\n            return Utils.getAddressStringFromByte(service.mAdapterProperties.getAddress());\n        }\n\n        @Override\n        public List<ParcelUuid> getUuids(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getUuids\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getUuids\")) {\n                return Collections.emptyList();\n            }\n\n            ParcelUuid[] parcels = service.mAdapterProperties.getUuids();\n            if (parcels == null) {\n                parcels = new ParcelUuid[0];\n            }\n            return Arrays.asList(parcels);\n        }\n\n        @Override\n        public String getIdentityAddress(String address) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getIdentityAddress\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service,\n                            Utils.getCallingAttributionSource(mService),\n                            \"AdapterService getIdentityAddress\")) {\n                return null;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            return service.getIdentityAddress(address);\n        }\n\n        @Override\n        public String getName(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getName\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getName\")) {\n                return null;\n            }\n\n            return service.getName();\n        }\n\n        @Override\n        public int getNameLengthForAdvertise(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"getNameLengthForAdvertise\")\n                    || !Utils.checkAdvertisePermissionForDataDelivery(service, source, TAG)) {\n                return -1;\n            }\n\n            return service.getNameLengthForAdvertise();\n        }\n\n        @Override\n        public boolean setName(String name, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"setName\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService setName\")) {\n                return false;\n            }\n\n            Log.d(TAG, \"AdapterServiceBinder.setName(\" + name + \")\");\n            return service.mAdapterProperties.setName(name);\n        }\n\n        @Override\n        public int getScanMode(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getScanMode\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, source, \"AdapterService getScanMode\")) {\n                return SCAN_MODE_NONE;\n            }\n\n            return service.getScanMode();\n        }\n\n        @Override\n        public int setScanMode(int mode, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"setScanMode\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, source, \"AdapterService setScanMode\")) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_SCAN_PERMISSION;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            String logCaller = Utils.getUidPidString() + \" packageName=\" + source.getPackageName();\n            CompletableFuture<Boolean> future = new CompletableFuture<>();\n            mService.mHandler.post(\n                    () ->\n                            future.complete(\n                                    service.getState() == BluetoothAdapter.STATE_ON\n                                            && service.setScanMode(mode, logCaller)));\n            return future.join()\n                    ? BluetoothStatusCodes.SUCCESS\n                    : BluetoothStatusCodes.ERROR_UNKNOWN;\n        }\n\n        @Override\n        public long getDiscoverableTimeout(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getDiscoverableTimeout\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, source, \"AdapterService getDiscoverableTimeout\")) {\n                return -1;\n            }\n\n            return service.mAdapterProperties.getDiscoverableTimeout();\n        }\n\n        @Override\n        public int setDiscoverableTimeout(long timeout, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"setDiscoverableTimeout\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, source, \"AdapterService setDiscoverableTimeout\")) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_SCAN_PERMISSION;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            return service.mAdapterProperties.setDiscoverableTimeout((int) timeout)\n                    ? BluetoothStatusCodes.SUCCESS\n                    : BluetoothStatusCodes.ERROR_UNKNOWN;\n        }\n\n        @Override\n        public boolean startDiscovery(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"startDiscovery\")) {\n                return false;\n            }\n\n            if (!Utils.checkScanPermissionForDataDelivery(service, source, \"Starting discovery.\")) {\n                return false;\n            }\n\n            Log.i(TAG, \"startDiscovery: from \" + Utils.getUidPidString());\n            return service.startDiscovery(source);\n        }\n\n        @Override\n        public boolean cancelDiscovery(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"cancelDiscovery\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, source, \"AdapterService cancelDiscovery\")) {\n                return false;\n            }\n\n            Log.i(TAG, \"cancelDiscovery: from \" + Utils.getUidPidString());\n            return service.mNativeInterface.cancelDiscovery();\n        }\n\n        @Override\n        public boolean isDiscovering(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"isDiscovering\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, source, \"AdapterService isDiscovering\")) {\n                return false;\n            }\n\n            return service.mAdapterProperties.isDiscovering();\n        }\n\n        @Override\n        public long getDiscoveryEndMillis(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getDiscoveryEndMillis\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return -1;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            return service.mAdapterProperties.discoveryEndMillis();\n        }\n\n        @Override\n        public List<BluetoothDevice> getMostRecentlyConnectedDevices(AttributionSource source) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getMostRecentlyConnectedDevices\")) {\n                return Collections.emptyList();\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            return service.mDatabaseManager.getMostRecentlyConnectedDevices();\n        }\n\n        @Override\n        public List<BluetoothDevice> getBondedDevices(AttributionSource source) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getBondedDevices\")) {\n                return Collections.emptyList();\n            }\n\n            return Arrays.asList(service.getBondedDevices());\n        }\n\n        @Override\n        public int getAdapterConnectionState() {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothAdapter.STATE_DISCONNECTED;\n            }\n\n            return service.mAdapterProperties.getConnectionState();\n        }\n\n        /**\n         * This method has an associated binder cache. The invalidation methods must be changed if\n         * the logic behind this method changes.\n         */\n        @Override\n        public int getProfileConnectionState(int profile, AttributionSource source) {\n            AdapterService service = getService();\n            boolean checkConnect = false;\n            final int callingUid = Binder.getCallingUid();\n            final long token = Binder.clearCallingIdentity();\n            try {\n                checkConnect = CompatChanges.isChangeEnabled(ENFORCE_CONNECT, callingUid);\n            } finally {\n                Binder.restoreCallingIdentity(token);\n            }\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"getProfileConnectionState\")\n                    || (checkConnect\n                            && !Utils.checkConnectPermissionForDataDelivery(\n                                    service, source, \"AdapterService getProfileConnectionState\"))) {\n                return BluetoothProfile.STATE_DISCONNECTED;\n            }\n\n            return service.mAdapterProperties.getProfileConnectionState(profile);\n        }\n\n        @Override\n        public boolean createBond(\n                BluetoothDevice device,\n                int transport,\n                OobData remoteP192Data,\n                OobData remoteP256Data,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"createBond\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService createBond\")) {\n                return false;\n            }\n\n            // This conditional is required to satisfy permission dependencies\n            // since createBond calls createBondOutOfBand with null value passed as data.\n            // BluetoothDevice#createBond requires BLUETOOTH_ADMIN only.\n            service.enforceBluetoothPrivilegedPermissionIfNeeded(remoteP192Data, remoteP256Data);\n\n            Log.i(\n                    TAG,\n                    \"createBond:\"\n                            + (\" device=\" + device)\n                            + (\" transport=\" + transport)\n                            + (\" from \" + Utils.getUidPidString()));\n            return service.createBond(\n                    device, transport, remoteP192Data, remoteP256Data, source.getPackageName());\n        }\n\n        @Override\n        public boolean cancelBondProcess(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"cancelBondProcess\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService cancelBondProcess\")) {\n                return false;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            Log.i(TAG, \"cancelBondProcess: device=\" + device + \", from \" + Utils.getUidPidString());\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp != null) {\n                deviceProp.setBondingInitiatedLocally(false);\n            }\n\n            return service.mNativeInterface.cancelBond(getBytesFromAddress(device.getAddress()));\n        }\n\n        @Override\n        public boolean removeBond(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"removeBond\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService removeBond\")) {\n                return false;\n            }\n\n            Log.i(TAG, \"removeBond: device=\" + device + \", from \" + Utils.getUidPidString());\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null || deviceProp.getBondState() != BluetoothDevice.BOND_BONDED) {\n                Log.w(\n                        TAG,\n                        device\n                                + \" cannot be removed since \"\n                                + ((deviceProp == null)\n                                        ? \"properties are empty\"\n                                        : \"bond state is \" + deviceProp.getBondState()));\n                return false;\n            }\n            service.mBondAttemptCallerInfo.remove(device.getAddress());\n            deviceProp.setBondingInitiatedLocally(false);\n\n            Message msg = service.mBondStateMachine.obtainMessage(BondStateMachine.REMOVE_BOND);\n            msg.obj = device;\n            service.mBondStateMachine.sendMessage(msg);\n            return true;\n        }\n\n        @Override\n        public int getBondState(BluetoothDevice device, AttributionSource source) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getBondState\")) {\n                return BluetoothDevice.BOND_NONE;\n            }\n\n            return service.getBondState(device);\n        }\n\n        @Override\n        public boolean isBondingInitiatedLocally(BluetoothDevice device, AttributionSource source) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService isBondingInitiatedLocally\")) {\n                return false;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            return deviceProp != null && deviceProp.isBondingInitiatedLocally();\n        }\n\n        @Override\n        public void generateLocalOobData(\n                int transport, IBluetoothOobDataCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"generateLocalOobData\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            service.generateLocalOobData(transport, callback);\n        }\n\n        @Override\n        public long getSupportedProfiles(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return 0;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            return Config.getSupportedProfilesBitMask();\n        }\n\n        @Override\n        public int getConnectionState(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getConnectionState\")) {\n                return BluetoothDevice.CONNECTION_STATE_DISCONNECTED;\n            }\n\n            return service.getConnectionState(device);\n        }\n\n        @Override\n        public int getConnectionHandle(\n                BluetoothDevice device, int transport, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getConnectionHandle\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothDevice.ERROR;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            return service.getConnectionHandle(device, transport);\n        }\n\n        @Override\n        public boolean canBondWithoutDialog(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            return service.canBondWithoutDialog(device);\n        }\n\n        @Override\n        public String getPackageNameOfBondingApplication(\n                BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return null;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            return service.getPackageNameOfBondingApplication(device);\n        }\n\n        @Override\n        public boolean removeActiveDevice(@ActiveDeviceUse int profiles, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"removeActiveDevice\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            service.enforceCallingOrSelfPermission(MODIFY_PHONE_STATE, null);\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            Log.i(\n                    TAG,\n                    \"removeActiveDevice: profiles=\"\n                            + profiles\n                            + \", from \"\n                            + Utils.getUidPidString());\n            return service.setActiveDevice(null, profiles);\n        }\n\n        @Override\n        public boolean setActiveDevice(\n                BluetoothDevice device, @ActiveDeviceUse int profiles, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"setActiveDevice\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            service.enforceCallingOrSelfPermission(MODIFY_PHONE_STATE, null);\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            Log.i(\n                    TAG,\n                    \"setActiveDevice: device=\"\n                            + device\n                            + \", profiles=\"\n                            + profiles\n                            + \", from \"\n                            + Utils.getUidPidString());\n\n            return service.setActiveDevice(device, profiles);\n        }\n\n        @Override\n        public List<BluetoothDevice> getActiveDevices(\n                @ActiveDeviceProfile int profile, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getActiveDevices\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return Collections.emptyList();\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            return service.getActiveDevices(profile);\n        }\n\n        @Override\n        public int connectAllEnabledProfiles(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null || !service.isEnabled()) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveOrManagedUser(service, TAG, \"connectAllEnabledProfiles\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            if (device == null) {\n                throw new IllegalArgumentException(\"device cannot be null\");\n            }\n            if (!BluetoothAdapter.checkBluetoothAddress(device.getAddress())) {\n                throw new IllegalArgumentException(\"device cannot have an invalid address\");\n            }\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n\n            service.enforceCallingOrSelfPermission(MODIFY_PHONE_STATE, null);\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            Log.i(\n                    TAG,\n                    \"connectAllEnabledProfiles: device=\"\n                            + device\n                            + \", from \"\n                            + Utils.getUidPidString());\n            MetricsLogger.getInstance()\n                    .logBluetoothEvent(\n                            device,\n                            BluetoothStatsLog\n                                    .BLUETOOTH_CROSS_LAYER_EVENT_REPORTED__EVENT_TYPE__INITIATOR_CONNECTION,\n                            BluetoothStatsLog.BLUETOOTH_CROSS_LAYER_EVENT_REPORTED__STATE__START,\n                            source.getUid());\n\n            try {\n                return service.connectAllEnabledProfiles(device);\n            } catch (Exception e) {\n                Log.v(TAG, \"connectAllEnabledProfiles() failed\", e);\n                SneakyThrow.sneakyThrow(e);\n                throw new RuntimeException(e);\n            }\n        }\n\n        @Override\n        public int disconnectAllEnabledProfiles(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveOrManagedUser(\n                    service, TAG, \"disconnectAllEnabledProfiles\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            if (device == null) {\n                throw new IllegalArgumentException(\"device cannot be null\");\n            }\n            if (!BluetoothAdapter.checkBluetoothAddress(device.getAddress())) {\n                throw new IllegalArgumentException(\"device cannot have an invalid address\");\n            }\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            Log.i(\n                    TAG,\n                    \"disconnectAllEnabledProfiles: device=\"\n                            + device\n                            + \", from \"\n                            + Utils.getUidPidString());\n\n            try {\n                return service.disconnectAllEnabledProfiles(device);\n            } catch (Exception e) {\n                Log.v(TAG, \"disconnectAllEnabledProfiles() failed\", e);\n                SneakyThrow.sneakyThrow(e);\n                throw new RuntimeException(e);\n            }\n        }\n\n        @Override\n        public String getRemoteName(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteName\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getRemoteName\")) {\n                return null;\n            }\n\n            return service.getRemoteName(device);\n        }\n\n        @Override\n        public int getRemoteType(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteType\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getRemoteType\")) {\n                return BluetoothDevice.DEVICE_TYPE_UNKNOWN;\n            }\n\n            return service.getRemoteType(device);\n        }\n\n        @Override\n        public String getRemoteAlias(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteAlias\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getRemoteAlias\")) {\n                return null;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            return deviceProp != null ? deviceProp.getAlias() : null;\n        }\n\n        @Override\n        public int setRemoteAlias(BluetoothDevice device, String name, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveOrManagedUser(service, TAG, \"setRemoteAlias\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            if (name != null && name.isEmpty()) {\n                throw new IllegalArgumentException(\"alias cannot be the empty string\");\n            }\n\n            if (!Utils.checkConnectPermissionForDataDelivery(\n                    service, source, \"AdapterService setRemoteAlias\")) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n\n            Utils.enforceCdmAssociationIfNotBluetoothPrivileged(\n                    service, service.mCompanionDeviceManager, source, device);\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null) {\n                return BluetoothStatusCodes.ERROR_DEVICE_NOT_BONDED;\n            }\n            deviceProp.setAlias(device, name);\n            return BluetoothStatusCodes.SUCCESS;\n        }\n\n        @Override\n        public int getRemoteClass(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteClass\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getRemoteClass\")) {\n                return 0;\n            }\n\n            return service.getRemoteClass(device);\n        }\n\n        @Override\n        public List<ParcelUuid> getRemoteUuids(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteUuids\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getRemoteUuids\")) {\n                return Collections.emptyList();\n            }\n\n            final ParcelUuid[] parcels = service.getRemoteUuids(device);\n            if (parcels == null) {\n                return null;\n            }\n            return Arrays.asList(parcels);\n        }\n\n        @Override\n        public boolean fetchRemoteUuids(\n                BluetoothDevice device, int transport, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"fetchRemoteUuids\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService fetchRemoteUuids\")) {\n                return false;\n            }\n            if (transport != TRANSPORT_AUTO) {\n                service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            }\n\n            Log.i(\n                    TAG,\n                    \"fetchRemoteUuids: device=\"\n                            + device\n                            + \", transport=\"\n                            + transport\n                            + \", from \"\n                            + Utils.getUidPidString());\n\n            service.mRemoteDevices.fetchUuids(device, transport);\n            MetricsLogger.getInstance().cacheCount(BluetoothProtoEnums.SDP_FETCH_UUID_REQUEST, 1);\n            return true;\n        }\n\n        @Override\n        public boolean setPin(\n                BluetoothDevice device,\n                boolean accept,\n                int len,\n                byte[] pinCode,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"setPin\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService setPin\")) {\n                return false;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            // Only allow setting a pin in bonding state, or bonded state in case of security\n            // upgrade.\n            if (deviceProp == null || !deviceProp.isBondingOrBonded()) {\n                Log.e(TAG, \"setPin: device=\" + device + \", not bonding\");\n                return false;\n            }\n            if (pinCode.length != len) {\n                android.util.EventLog.writeEvent(\n                        0x534e4554, \"139287605\", -1, \"PIN code length mismatch\");\n                return false;\n            }\n            service.logUserBondResponse(\n                    device, accept, BluetoothProtoEnums.BOND_SUB_STATE_LOCAL_PIN_REPLIED);\n            Log.i(\n                    TAG,\n                    \"setPin: device=\"\n                            + device\n                            + \", accept=\"\n                            + accept\n                            + \", from \"\n                            + Utils.getUidPidString());\n            return service.mNativeInterface.pinReply(\n                    getBytesFromAddress(device.getAddress()), accept, len, pinCode);\n        }\n\n        @Override\n        public boolean setPasskey(\n                BluetoothDevice device,\n                boolean accept,\n                int len,\n                byte[] passkey,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"setPasskey\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService setPasskey\")) {\n                return false;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null || !deviceProp.isBonding()) {\n                Log.e(TAG, \"setPasskey: device=\" + device + \", not bonding\");\n                return false;\n            }\n            if (passkey.length != len) {\n                android.util.EventLog.writeEvent(\n                        0x534e4554, \"139287605\", -1, \"Passkey length mismatch\");\n                return false;\n            }\n            service.logUserBondResponse(\n                    device, accept, BluetoothProtoEnums.BOND_SUB_STATE_LOCAL_SSP_REPLIED);\n            Log.i(\n                    TAG,\n                    \"setPasskey: device=\"\n                            + device\n                            + \", accept=\"\n                            + accept\n                            + \", from \"\n                            + Utils.getUidPidString());\n\n            return service.mNativeInterface.sspReply(\n                    getBytesFromAddress(device.getAddress()),\n                    AbstractionLayer.BT_SSP_VARIANT_PASSKEY_ENTRY,\n                    accept,\n                    Utils.byteArrayToInt(passkey));\n        }\n\n        @Override\n        public boolean setPairingConfirmation(\n                BluetoothDevice device, boolean accept, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"setPairingConfirmation\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null || !deviceProp.isBonding()) {\n                Log.e(TAG, \"setPairingConfirmation: device=\" + device + \", not bonding\");\n                return false;\n            }\n            service.logUserBondResponse(\n                    device, accept, BluetoothProtoEnums.BOND_SUB_STATE_LOCAL_SSP_REPLIED);\n            Log.i(\n                    TAG,\n                    \"setPairingConfirmation: device=\"\n                            + device\n                            + \", accept=\"\n                            + accept\n                            + \", from \"\n                            + Utils.getUidPidString());\n\n            return service.mNativeInterface.sspReply(\n                    getBytesFromAddress(device.getAddress()),\n                    AbstractionLayer.BT_SSP_VARIANT_PASSKEY_CONFIRMATION,\n                    accept,\n                    0);\n        }\n\n        @Override\n        public boolean getSilenceMode(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getSilenceMode\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            return service.mSilenceDeviceManager.getSilenceMode(device);\n        }\n\n        @Override\n        public boolean setSilenceMode(\n                BluetoothDevice device, boolean silence, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"setSilenceMode\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            service.mSilenceDeviceManager.setSilenceMode(device, silence);\n            return true;\n        }\n\n        @Override\n        public int getPhonebookAccessPermission(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"getPhonebookAccessPermission\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getPhonebookAccessPermission\")) {\n                return BluetoothDevice.ACCESS_UNKNOWN;\n            }\n\n            return service.getPhonebookAccessPermission(device);\n        }\n\n        @Override\n        public boolean setPhonebookAccessPermission(\n                BluetoothDevice device, int value, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"setPhonebookAccessPermission\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            service.setPhonebookAccessPermission(device, value);\n            return true;\n        }\n\n        @Override\n        public int getMessageAccessPermission(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"getMessageAccessPermission\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getMessageAccessPermission\")) {\n                return BluetoothDevice.ACCESS_UNKNOWN;\n            }\n\n            return service.getMessageAccessPermission(device);\n        }\n\n        @Override\n        public boolean setMessageAccessPermission(\n                BluetoothDevice device, int value, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"setMessageAccessPermission\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            service.setMessageAccessPermission(device, value);\n            return true;\n        }\n\n        @Override\n        public int getSimAccessPermission(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getSimAccessPermission\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getSimAccessPermission\")) {\n                return BluetoothDevice.ACCESS_UNKNOWN;\n            }\n\n            return service.getSimAccessPermission(device);\n        }\n\n        @Override\n        public boolean setSimAccessPermission(\n                BluetoothDevice device, int value, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"setSimAccessPermission\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            service.setSimAccessPermission(device, value);\n            return true;\n        }\n\n        @Override\n        public void logL2capcocServerConnection(\n                BluetoothDevice device,\n                int port,\n                boolean isSecured,\n                int result,\n                long socketCreationTimeMillis,\n                long socketCreationLatencyMillis,\n                long socketConnectionTimeMillis,\n                long timeoutMillis) {\n            AdapterService service = getService();\n            if (service == null) {\n                return;\n            }\n            service.logL2capcocServerConnection(\n                    device,\n                    port,\n                    isSecured,\n                    result,\n                    socketCreationTimeMillis,\n                    socketCreationLatencyMillis,\n                    socketConnectionTimeMillis,\n                    timeoutMillis,\n                    Binder.getCallingUid());\n        }\n\n        @Override\n        public IBluetoothSocketManager getSocketManager() {\n            AdapterService service = getService();\n            if (service == null) {\n                return null;\n            }\n\n            return IBluetoothSocketManager.Stub.asInterface(service.mBluetoothSocketManagerBinder);\n        }\n\n        @Override\n        public void logL2capcocClientConnection(\n                BluetoothDevice device,\n                int port,\n                boolean isSecured,\n                int result,\n                long socketCreationTimeNanos,\n                long socketCreationLatencyNanos,\n                long socketConnectionTimeNanos) {\n            AdapterService service = getService();\n            if (service == null) {\n                return;\n            }\n            service.logL2capcocClientConnection(\n                    device,\n                    port,\n                    isSecured,\n                    result,\n                    socketCreationTimeNanos,\n                    socketCreationLatencyNanos,\n                    socketConnectionTimeNanos,\n                    Binder.getCallingUid());\n        }\n\n        @Override\n        public void logRfcommConnectionAttempt(\n                BluetoothDevice device,\n                boolean isSecured,\n                int resultCode,\n                long socketCreationTimeNanos,\n                boolean isSerialPort) {\n            AdapterService service = getService();\n            if (service == null) {\n                return;\n            }\n            service.logRfcommConnectionAttempt(\n                    device,\n                    isSecured,\n                    resultCode,\n                    socketCreationTimeNanos,\n                    isSerialPort,\n                    Binder.getCallingUid());\n        }\n\n        @Override\n        public boolean sdpSearch(\n                BluetoothDevice device, ParcelUuid uuid, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"sdpSearch\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService sdpSearch\")) {\n                return false;\n            }\n            return service.sdpSearch(device, uuid);\n        }\n\n        @Override\n        public int getBatteryLevel(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getBatteryLevel\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getBatteryLevel\")) {\n                return BluetoothDevice.BATTERY_LEVEL_UNKNOWN;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null) {\n                return BluetoothDevice.BATTERY_LEVEL_UNKNOWN;\n            }\n            return deviceProp.getBatteryLevel();\n        }\n\n        @Override\n        public int getMaxConnectedAudioDevices(AttributionSource source) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService getMaxConnectedAudioDevices\")) {\n                return -1;\n            }\n\n            return service.getMaxConnectedAudioDevices();\n        }\n\n        @Override\n        public boolean factoryReset(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            return service.factoryReset();\n        }\n\n        @Override\n        public void registerBluetoothConnectionCallback(\n                IBluetoothConnectionCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"registerBluetoothConnectionCallback\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            service.mBluetoothConnectionCallbacks.register(callback);\n        }\n\n        @Override\n        public void unregisterBluetoothConnectionCallback(\n                IBluetoothConnectionCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"unregisterBluetoothConnectionCallback\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            service.mBluetoothConnectionCallbacks.unregister(callback);\n        }\n\n        @Override\n        public void registerCallback(IBluetoothCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"registerCallback\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            service.registerRemoteCallback(callback);\n        }\n\n        @Override\n        public void unregisterCallback(IBluetoothCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"unregisterCallback\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            service.unregisterRemoteCallback(callback);\n        }\n\n        @Override\n        public boolean isMultiAdvertisementSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            int val = service.mAdapterProperties.getNumOfAdvertisementInstancesSupported();\n            return val >= MIN_ADVT_INSTANCES_FOR_MA;\n        }\n\n        /**\n         * This method has an associated binder cache. The invalidation methods must be changed if\n         * the logic behind this method changes.\n         */\n        @Override\n        public boolean isOffloadedFilteringSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            int val = service.getNumOfOffloadedScanFilterSupported();\n            return val >= MIN_OFFLOADED_FILTERS;\n        }\n\n        @Override\n        public boolean isOffloadedScanBatchingSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            int val = service.getOffloadedScanResultStorage();\n            return val >= MIN_OFFLOADED_SCAN_STORAGE_BYTES;\n        }\n\n        @Override\n        public boolean isLe2MPhySupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.isLe2MPhySupported();\n        }\n\n        @Override\n        public boolean isLeCodedPhySupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.isLeCodedPhySupported();\n        }\n\n        @Override\n        public boolean isLeExtendedAdvertisingSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.isLeExtendedAdvertisingSupported();\n        }\n\n        @Override\n        public boolean isLePeriodicAdvertisingSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.isLePeriodicAdvertisingSupported();\n        }\n\n        @Override\n        public int isLeAudioSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n\n            Set<Integer> supportedProfileServices =\n                    Arrays.stream(Config.getSupportedProfiles())\n                            .boxed()\n                            .collect(Collectors.toSet());\n            int[] leAudioUnicastProfiles = Config.getLeAudioUnicastProfiles();\n\n            if (Arrays.stream(leAudioUnicastProfiles)\n                    .allMatch(supportedProfileServices::contains)) {\n                return BluetoothStatusCodes.FEATURE_SUPPORTED;\n            }\n\n            return BluetoothStatusCodes.FEATURE_NOT_SUPPORTED;\n        }\n\n        @Override\n        public int isLeAudioBroadcastSourceSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n\n            long supportBitMask = Config.getSupportedProfilesBitMask();\n            if ((supportBitMask & (1 << BluetoothProfile.LE_AUDIO_BROADCAST)) != 0) {\n                return BluetoothStatusCodes.FEATURE_SUPPORTED;\n            }\n\n            return BluetoothStatusCodes.FEATURE_NOT_SUPPORTED;\n        }\n\n        @Override\n        public int isLeAudioBroadcastAssistantSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n\n            int[] supportedProfileServices = Config.getSupportedProfiles();\n\n            if (Arrays.stream(supportedProfileServices)\n                    .anyMatch(\n                            profileId ->\n                                    profileId == BluetoothProfile.LE_AUDIO_BROADCAST_ASSISTANT)) {\n                return BluetoothStatusCodes.FEATURE_SUPPORTED;\n            }\n\n            return BluetoothStatusCodes.FEATURE_NOT_SUPPORTED;\n        }\n\n        @Override\n        public int isDistanceMeasurementSupported(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            } else if (!callerIsSystemOrActiveOrManagedUser(\n                    service, TAG, \"isDistanceMeasurementSupported\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            } else if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            return BluetoothStatusCodes.FEATURE_SUPPORTED;\n        }\n\n        @Override\n        public int getLeMaximumAdvertisingDataLength() {\n            AdapterService service = getService();\n            if (service == null) {\n                return 0;\n            }\n\n            return service.getLeMaximumAdvertisingDataLength();\n        }\n\n        @Override\n        public boolean isActivityAndEnergyReportingSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.mAdapterProperties.isActivityAndEnergyReportingSupported();\n        }\n\n        @Override\n        public BluetoothActivityEnergyInfo reportActivityInfo(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return null;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            return service.reportActivityInfo();\n        }\n\n        @Override\n        public boolean registerMetadataListener(\n                IBluetoothMetadataListener listener,\n                BluetoothDevice device,\n                AttributionSource source) {\n            requireNonNull(device);\n            requireNonNull(listener);\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"registerMetadataListener\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            service.mHandler.post(\n                    () ->\n                            service.mMetadataListeners\n                                    .computeIfAbsent(device, k -> new RemoteCallbackList())\n                                    .register(listener));\n\n            return true;\n        }\n\n        @Override\n        public boolean unregisterMetadataListener(\n                IBluetoothMetadataListener listener,\n                BluetoothDevice device,\n                AttributionSource source) {\n            requireNonNull(device);\n            requireNonNull(listener);\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"unregisterMetadataListener\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            service.mHandler.post(\n                    () ->\n                            service.mMetadataListeners.computeIfPresent(\n                                    device,\n                                    (k, v) -> {\n                                        v.unregister(listener);\n                                        if (v.getRegisteredCallbackCount() == 0) {\n                                            return null;\n                                        }\n                                        return v;\n                                    }));\n            return true;\n        }\n\n        @Override\n        public boolean setMetadata(\n                BluetoothDevice device, int key, byte[] value, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"setMetadata\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            return service.setMetadata(device, key, value);\n        }\n\n        @Override\n        public byte[] getMetadata(BluetoothDevice device, int key, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getMetadata\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return null;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            return service.getMetadata(device, key);\n        }\n\n        @Override\n        public int isRequestAudioPolicyAsSinkSupported(\n                BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"isRequestAudioPolicyAsSinkSupported\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.FEATURE_NOT_CONFIGURED;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            return service.isRequestAudioPolicyAsSinkSupported(device);\n        }\n\n        @Override\n        public int requestAudioPolicyAsSink(\n                BluetoothDevice device,\n                BluetoothSinkAudioPolicy policies,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            } else if (!callerIsSystemOrActiveOrManagedUser(\n                    service, TAG, \"requestAudioPolicyAsSink\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            } else if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            return service.requestAudioPolicyAsSink(device, policies);\n        }\n\n        @Override\n        public BluetoothSinkAudioPolicy getRequestedAudioPolicyAsSink(\n                BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"getRequestedAudioPolicyAsSink\")\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return null;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            return service.getRequestedAudioPolicyAsSink(device);\n        }\n\n        @Override\n        public void requestActivityInfo(\n                IBluetoothActivityEnergyInfoListener listener, AttributionSource source) {\n            BluetoothActivityEnergyInfo info = reportActivityInfo(source);\n            try {\n                listener.onBluetoothActivityEnergyInfoAvailable(info);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"onBluetoothActivityEnergyInfo: RemoteException\", e);\n            }\n        }\n\n        @Override\n        public void bleOnToOn(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"bleOnToOn\")) {\n                return;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            service.bleOnToOn();\n        }\n\n        @Override\n        public void bleOnToOff(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"bleOnToOff\")) {\n                return;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            service.bleOnToOff();\n        }\n\n        @Override\n        public void dump(FileDescriptor fd, String[] args) {\n            PrintWriter writer = new PrintWriter(new FileOutputStream(fd));\n            AdapterService service = getService();\n            if (service == null) {\n                return;\n            }\n\n            service.enforceCallingOrSelfPermission(DUMP, null);\n\n            service.dump(fd, writer, args);\n            writer.close();\n        }\n\n        @Override\n        public boolean allowLowLatencyAudio(boolean allowed, BluetoothDevice device) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"allowLowLatencyAudio\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service,\n                            Utils.getCallingAttributionSource(service),\n                            \"AdapterService allowLowLatencyAudio\")) {\n                return false;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            return service.allowLowLatencyAudio(allowed, device);\n        }\n\n        @Override\n        public int startRfcommListener(\n                String name,\n                ParcelUuid uuid,\n                PendingIntent pendingIntent,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"startRfcommListener\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService startRfcommListener\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            return service.startRfcommListener(name, uuid, pendingIntent, source);\n        }\n\n        @Override\n        public int stopRfcommListener(ParcelUuid uuid, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"stopRfcommListener\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService stopRfcommListener\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            return service.stopRfcommListener(uuid, source);\n        }\n\n        @Override\n        public IncomingRfcommSocketInfo retrievePendingSocketForServiceRecord(\n                ParcelUuid uuid, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"retrievePendingSocketForServiceRecord\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service,\n                            source,\n                            \"AdapterService retrievePendingSocketForServiceRecord\")) {\n                return null;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            return service.retrievePendingSocketForServiceRecord(uuid, source);\n        }\n\n        @Override\n        public void setForegroundUserId(int userId, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service,\n                            Utils.getCallingAttributionSource(mService),\n                            \"AdapterService setForegroundUserId\")) {\n                return;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            Utils.setForegroundUserId(userId);\n        }\n\n        @Override\n        public int setPreferredAudioProfiles(\n                BluetoothDevice device, Bundle modeToProfileBundle, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveOrManagedUser(service, TAG, \"setPreferredAudioProfiles\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            requireNonNull(device);\n            requireNonNull(modeToProfileBundle);\n            if (!BluetoothAdapter.checkBluetoothAddress(device.getAddress())) {\n                throw new IllegalArgumentException(\"device cannot have an invalid address\");\n            }\n            if (service.getBondState(device) != BluetoothDevice.BOND_BONDED) {\n                return BluetoothStatusCodes.ERROR_DEVICE_NOT_BONDED;\n            }\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            return service.setPreferredAudioProfiles(device, modeToProfileBundle);\n        }\n\n        @Override\n        public Bundle getPreferredAudioProfiles(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return Bundle.EMPTY;\n            }\n            if (!callerIsSystemOrActiveOrManagedUser(service, TAG, \"getPreferredAudioProfiles\")) {\n                return Bundle.EMPTY;\n            }\n            requireNonNull(device);\n            if (!BluetoothAdapter.checkBluetoothAddress(device.getAddress())) {\n                throw new IllegalArgumentException(\"device cannot have an invalid address\");\n            }\n            if (service.getBondState(device) != BluetoothDevice.BOND_BONDED) {\n                return Bundle.EMPTY;\n            }\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return Bundle.EMPTY;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            return service.getPreferredAudioProfiles(device);\n        }\n\n        @Override\n        public int notifyActiveDeviceChangeApplied(\n                BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystem(TAG, \"notifyActiveDeviceChangeApplied\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            requireNonNull(device);\n            if (!BluetoothAdapter.checkBluetoothAddress(device.getAddress())) {\n                throw new IllegalArgumentException(\"device cannot have an invalid address\");\n            }\n            if (service.getBondState(device) != BluetoothDevice.BOND_BONDED) {\n                return BluetoothStatusCodes.ERROR_DEVICE_NOT_BONDED;\n            }\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            return service.notifyActiveDeviceChangeApplied(device);\n        }\n\n        @Override\n        public int isDualModeAudioEnabled(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            if (!Utils.isDualModeAudioEnabled()) {\n                return BluetoothStatusCodes.FEATURE_NOT_SUPPORTED;\n            }\n\n            return BluetoothStatusCodes.SUCCESS;\n        }\n\n        @Override\n        public int registerPreferredAudioProfilesChangedCallback(\n                IBluetoothPreferredAudioProfilesCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveOrManagedUser(\n                    service, TAG, \"registerPreferredAudioProfilesChangedCallback\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            requireNonNull(callback);\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            // If LE only mode is enabled, the dual mode audio feature is disabled\n            if (!Utils.isDualModeAudioEnabled()) {\n                return BluetoothStatusCodes.FEATURE_NOT_SUPPORTED;\n            }\n\n            service.mPreferredAudioProfilesCallbacks.register(callback);\n            return BluetoothStatusCodes.SUCCESS;\n        }\n\n        @Override\n        public int unregisterPreferredAudioProfilesChangedCallback(\n                IBluetoothPreferredAudioProfilesCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveOrManagedUser(\n                    service, TAG, \"unregisterPreferredAudioProfilesChangedCallback\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            requireNonNull(callback);\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            if (!service.mPreferredAudioProfilesCallbacks.unregister(callback)) {\n                Log.e(\n                        TAG,\n                        \"unregisterPreferredAudioProfilesChangedCallback: callback was never \"\n                                + \"registered\");\n                return BluetoothStatusCodes.ERROR_CALLBACK_NOT_REGISTERED;\n            }\n            return BluetoothStatusCodes.SUCCESS;\n        }\n\n        @Override\n        public int registerBluetoothQualityReportReadyCallback(\n                IBluetoothQualityReportReadyCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveOrManagedUser(\n                    service, TAG, \"registerBluetoothQualityReportReadyCallback\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            requireNonNull(callback);\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            service.mBluetoothQualityReportReadyCallbacks.register(callback);\n            return BluetoothStatusCodes.SUCCESS;\n        }\n\n        @Override\n        public int unregisterBluetoothQualityReportReadyCallback(\n                IBluetoothQualityReportReadyCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveOrManagedUser(\n                    service, TAG, \"unregisterBluetoothQualityReportReadyCallback\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            requireNonNull(callback);\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            if (!service.mBluetoothQualityReportReadyCallbacks.unregister(callback)) {\n                Log.e(\n                        TAG,\n                        \"unregisterBluetoothQualityReportReadyCallback: callback was never \"\n                                + \"registered\");\n                return BluetoothStatusCodes.ERROR_CALLBACK_NOT_REGISTERED;\n            }\n            return BluetoothStatusCodes.SUCCESS;\n        }\n\n        @Override\n        public int getOffloadedTransportDiscoveryDataScanSupported(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"getOffloadedTransportDiscoveryDataScanSupported\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, source, \"getOffloadedTransportDiscoveryDataScanSupported\")) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_SCAN_PERMISSION;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            return service.getOffloadedTransportDiscoveryDataScanSupported();\n        }\n\n        @Override\n        public boolean isMediaProfileConnected(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, source, \"AdapterService.isMediaProfileConnected\")) {\n                return false;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n\n            return service.isMediaProfileConnected();\n        }\n\n        @Override\n        public IBinder getBluetoothGatt() {\n            AdapterService service = getService();\n            return service == null ? null : service.getBluetoothGatt();\n        }\n\n        @Override\n        public IBinder getBluetoothScan() {\n            AdapterService service = getService();\n            return service == null ? null : service.getBluetoothScan();\n        }\n\n        @Override\n        public void unregAllGattClient(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return;\n            }\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            service.unregAllGattClient(source);\n        }\n\n        @Override\n        public IBinder getProfile(int profileId) {\n            AdapterService service = getService();\n            if (service == null) {\n                return null;\n            }\n\n            return service.getProfile(profileId);\n        }\n\n        @Override\n        public int setActiveAudioDevicePolicy(\n                BluetoothDevice device, int activeAudioDevicePolicy, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveOrManagedUser(service, TAG, \"setActiveAudioDevicePolicy\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            if (!BluetoothAdapter.checkBluetoothAddress(device.getAddress())) {\n                throw new IllegalArgumentException(\"device cannot have an invalid address\");\n            }\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            return service.mDatabaseManager.setActiveAudioDevicePolicy(\n                    device, activeAudioDevicePolicy);\n        }\n\n        @Override\n        public int getActiveAudioDevicePolicy(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothDevice.ACTIVE_AUDIO_DEVICE_POLICY_DEFAULT;\n            }\n            if (!callerIsSystemOrActiveOrManagedUser(service, TAG, \"getActiveAudioDevicePolicy\")) {\n                throw new IllegalStateException(\n                        \"Caller is not the system or part of the active/managed user\");\n            }\n            if (!BluetoothAdapter.checkBluetoothAddress(device.getAddress())) {\n                throw new IllegalArgumentException(\"device cannot have an invalid address\");\n            }\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothDevice.ACTIVE_AUDIO_DEVICE_POLICY_DEFAULT;\n            }\n\n            service.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n            return service.mDatabaseManager.getActiveAudioDevicePolicy(device);\n        }\n    }\n\n    /**\n     * Gets the preferred audio profiles for the device. See {@link\n     * BluetoothAdapter#getPreferredAudioProfiles(BluetoothDevice)} for more details.\n     *\n     * @param device is the remote device whose preferences we want to fetch\n     * @return a Bundle containing the preferred audio profiles for the device\n     */\n    public Bundle getPreferredAudioProfiles(BluetoothDevice device) {\n        if (!isDualModeAudioEnabled()\n                || mLeAudioService == null\n                || !isDualModeAudioSinkDevice(device)) {\n            return Bundle.EMPTY;\n        }\n        // Checks if the device is part of an LE Audio group\n        List<BluetoothDevice> groupDevices = mLeAudioService.getGroupDevices(device);\n        if (groupDevices.isEmpty()) {\n            return Bundle.EMPTY;\n        }\n\n        // If there are no preferences stored, return the defaults\n        Bundle storedBundle = Bundle.EMPTY;\n        for (BluetoothDevice groupDevice : groupDevices) {\n            Bundle groupDevicePreferences = mDatabaseManager.getPreferredAudioProfiles(groupDevice);\n            if (!groupDevicePreferences.isEmpty()) {\n                storedBundle = groupDevicePreferences;\n                break;\n            }\n        }\n\n        if (storedBundle.isEmpty()) {\n            Bundle defaultPreferencesBundle = new Bundle();\n            boolean useDefaultPreferences = false;\n            if (isOutputOnlyAudioSupported(groupDevices)) {\n                // Gets the default output only audio profile or defaults to LE_AUDIO if not present\n                int outputOnlyDefault =\n                        BluetoothProperties.getDefaultOutputOnlyAudioProfile()\n                                .orElse(BluetoothProfile.LE_AUDIO);\n                if (outputOnlyDefault != BluetoothProfile.A2DP\n                        && outputOnlyDefault != BluetoothProfile.LE_AUDIO) {\n                    outputOnlyDefault = BluetoothProfile.LE_AUDIO;\n                }\n                defaultPreferencesBundle.putInt(\n                        BluetoothAdapter.AUDIO_MODE_OUTPUT_ONLY, outputOnlyDefault);\n                useDefaultPreferences = true;\n            }\n            if (isDuplexAudioSupported(groupDevices)) {\n                // Gets the default duplex audio profile or defaults to LE_AUDIO if not present\n                int duplexDefault =\n                        BluetoothProperties.getDefaultDuplexAudioProfile()\n                                .orElse(BluetoothProfile.LE_AUDIO);\n                if (duplexDefault != BluetoothProfile.HEADSET\n                        && duplexDefault != BluetoothProfile.LE_AUDIO) {\n                    duplexDefault = BluetoothProfile.LE_AUDIO;\n                }\n                defaultPreferencesBundle.putInt(BluetoothAdapter.AUDIO_MODE_DUPLEX, duplexDefault);\n                useDefaultPreferences = true;\n            }\n\n            if (useDefaultPreferences) {\n                return defaultPreferencesBundle;\n            }\n        }\n        return storedBundle;\n    }\n\n    /**\n     * Sets the preferred audio profiles for the device. See {@link\n     * BluetoothAdapter#setPreferredAudioProfiles(BluetoothDevice, Bundle)} for more details.\n     *\n     * @param device is the remote device whose preferences we want to fetch\n     * @param modeToProfileBundle is the preferences we want to set for the device\n     * @return whether the preferences were successfully requested\n     */\n    private int setPreferredAudioProfiles(BluetoothDevice device, Bundle modeToProfileBundle) {\n        Log.i(TAG, \"setPreferredAudioProfiles for device=\" + device);\n        if (!isDualModeAudioEnabled()) {\n            Log.e(TAG, \"setPreferredAudioProfiles called while sysprop is disabled\");\n            return BluetoothStatusCodes.FEATURE_NOT_SUPPORTED;\n        }\n        if (mLeAudioService == null) {\n            Log.e(TAG, \"setPreferredAudioProfiles: LEA service is not up\");\n            return BluetoothStatusCodes.ERROR_PROFILE_NOT_CONNECTED;\n        }\n        if (!isDualModeAudioSinkDevice(device)) {\n            Log.e(TAG, \"setPreferredAudioProfiles: Not a dual mode audio device\");\n            return BluetoothStatusCodes.ERROR_NOT_DUAL_MODE_AUDIO_DEVICE;\n        }\n        // Checks if the device is part of an LE Audio group\n        int groupId = mLeAudioService.getGroupId(device);\n        List<BluetoothDevice> groupDevices = mLeAudioService.getGroupDevices(groupId);\n        if (groupDevices.isEmpty()) {\n            return BluetoothStatusCodes.ERROR_DEVICE_NOT_BONDED;\n        }\n\n        // Copies relevant keys & values from modeToProfile bundle\n        Bundle strippedPreferences = new Bundle();\n        if (modeToProfileBundle.containsKey(BluetoothAdapter.AUDIO_MODE_OUTPUT_ONLY)\n                && isOutputOnlyAudioSupported(groupDevices)) {\n            int outputOnlyProfile =\n                    modeToProfileBundle.getInt(BluetoothAdapter.AUDIO_MODE_OUTPUT_ONLY);\n            if (outputOnlyProfile != BluetoothProfile.A2DP\n                    && outputOnlyProfile != BluetoothProfile.LE_AUDIO) {\n                throw new IllegalArgumentException(\n                        \"AUDIO_MODE_OUTPUT_ONLY has invalid value: \" + outputOnlyProfile);\n            }\n            strippedPreferences.putInt(BluetoothAdapter.AUDIO_MODE_OUTPUT_ONLY, outputOnlyProfile);\n        }\n        if (modeToProfileBundle.containsKey(BluetoothAdapter.AUDIO_MODE_DUPLEX)\n                && isDuplexAudioSupported(groupDevices)) {\n            int duplexProfile = modeToProfileBundle.getInt(BluetoothAdapter.AUDIO_MODE_DUPLEX);\n            if (duplexProfile != BluetoothProfile.HEADSET\n                    && duplexProfile != BluetoothProfile.LE_AUDIO) {\n                throw new IllegalArgumentException(\n                        \"AUDIO_MODE_DUPLEX has invalid value: \" + duplexProfile);\n            }\n            strippedPreferences.putInt(BluetoothAdapter.AUDIO_MODE_DUPLEX, duplexProfile);\n        }\n\n        synchronized (mCsipGroupsPendingAudioProfileChanges) {\n            if (mCsipGroupsPendingAudioProfileChanges.containsKey(groupId)) {\n                return BluetoothStatusCodes.ERROR_ANOTHER_ACTIVE_REQUEST;\n            }\n\n            Bundle previousPreferences = getPreferredAudioProfiles(device);\n\n            int dbResult =\n                    mDatabaseManager.setPreferredAudioProfiles(groupDevices, strippedPreferences);\n            if (dbResult != BluetoothStatusCodes.SUCCESS) {\n                return dbResult;\n            }\n\n            int outputOnlyPreference =\n                    strippedPreferences.getInt(BluetoothAdapter.AUDIO_MODE_OUTPUT_ONLY);\n            if (outputOnlyPreference == 0) {\n                outputOnlyPreference =\n                        previousPreferences.getInt(BluetoothAdapter.AUDIO_MODE_OUTPUT_ONLY);\n            }\n            int duplexPreference = strippedPreferences.getInt(BluetoothAdapter.AUDIO_MODE_DUPLEX);\n            if (duplexPreference == 0) {\n                duplexPreference = previousPreferences.getInt(BluetoothAdapter.AUDIO_MODE_DUPLEX);\n            }\n\n            mLeAudioService.sendAudioProfilePreferencesToNative(\n                    groupId,\n                    outputOnlyPreference == BluetoothProfile.LE_AUDIO,\n                    duplexPreference == BluetoothProfile.LE_AUDIO);\n\n            /* Populates the HashMap to hold requests on the groupId. We will update\n            numRequestsToAudioFramework after we make requests to the audio framework */\n            PendingAudioProfilePreferenceRequest holdRequest =\n                    new PendingAudioProfilePreferenceRequest(strippedPreferences, 0, device);\n            mCsipGroupsPendingAudioProfileChanges.put(groupId, holdRequest);\n\n            // Notifies audio framework via the handler thread to avoid this blocking calls\n            mHandler.post(\n                    () ->\n                            sendPreferredAudioProfileChangeToAudioFramework(\n                                    device, strippedPreferences, previousPreferences));\n            return BluetoothStatusCodes.SUCCESS;\n        }\n    }\n\n    /**\n     * Sends the updated preferred audio profiles to the audio framework.\n     *\n     * @param device is the device with updated audio preferences\n     * @param strippedPreferences is a {@link Bundle} containing the preferences\n     */\n    private void sendPreferredAudioProfileChangeToAudioFramework(\n            BluetoothDevice device, Bundle strippedPreferences, Bundle previousPreferences) {\n        int newOutput = strippedPreferences.getInt(BluetoothAdapter.AUDIO_MODE_OUTPUT_ONLY);\n        int newDuplex = strippedPreferences.getInt(BluetoothAdapter.AUDIO_MODE_DUPLEX);\n        int previousOutput = previousPreferences.getInt(BluetoothAdapter.AUDIO_MODE_OUTPUT_ONLY);\n        int previousDuplex = previousPreferences.getInt(BluetoothAdapter.AUDIO_MODE_DUPLEX);\n\n        Log.i(\n                TAG,\n                \"sendPreferredAudioProfileChangeToAudioFramework: changing output from \"\n                        + BluetoothProfile.getProfileName(previousOutput)\n                        + \" to \"\n                        + BluetoothProfile.getProfileName(newOutput)\n                        + \" and duplex from \"\n                        + BluetoothProfile.getProfileName(previousDuplex)\n                        + \" to \"\n                        + BluetoothProfile.getProfileName(newDuplex));\n\n        // If no change from existing preferences, do not inform audio framework\n        if (previousOutput == newOutput && previousDuplex == newDuplex) {\n            Log.i(TAG, \"No change to preferred audio profiles, no requests to Audio FW\");\n            sendPreferredAudioProfilesCallbackToApps(\n                    device, strippedPreferences, BluetoothStatusCodes.SUCCESS);\n            return;\n        }\n\n        int numRequestsToAudioFw = 0;\n\n        // Checks if the device is part of an LE Audio group\n        int groupId = mLeAudioService.getGroupId(device);\n        List<BluetoothDevice> groupDevices = mLeAudioService.getGroupDevices(groupId);\n        if (groupDevices.isEmpty()) {\n            Log.i(\n                    TAG,\n                    \"sendPreferredAudioProfileChangeToAudioFramework: Empty LEA group for \"\n                            + \"device - \"\n                            + device);\n            sendPreferredAudioProfilesCallbackToApps(\n                    device, strippedPreferences, BluetoothStatusCodes.ERROR_DEVICE_NOT_BONDED);\n            return;\n        }\n\n        synchronized (mCsipGroupsPendingAudioProfileChanges) {\n            if (previousOutput != newOutput) {\n                if (newOutput == BluetoothProfile.A2DP\n                        && mA2dpService.getActiveDevice() != null\n                        && groupDevices.contains(mA2dpService.getActiveDevice())) {\n                    Log.i(TAG, \"Sent change for AUDIO_MODE_OUTPUT_ONLY to A2DP to Audio FW\");\n                    numRequestsToAudioFw +=\n                            mA2dpService.sendPreferredAudioProfileChangeToAudioFramework();\n                } else if (newOutput == BluetoothProfile.LE_AUDIO\n                        && mLeAudioService.getActiveGroupId() == groupId) {\n                    Log.i(TAG, \"Sent change for AUDIO_MODE_OUTPUT_ONLY to LE_AUDIO to Audio FW\");\n                    numRequestsToAudioFw +=\n                            mLeAudioService.sendPreferredAudioProfileChangeToAudioFramework();\n                }\n            }\n\n            if (previousDuplex != newDuplex) {\n                if (newDuplex == BluetoothProfile.HEADSET\n                        && mHeadsetService.getActiveDevice() != null\n                        && groupDevices.contains(mHeadsetService.getActiveDevice())) {\n                    Log.i(TAG, \"Sent change for AUDIO_MODE_DUPLEX to HFP to Audio FW\");\n                    // TODO(b/275426145): Add similar HFP method in BluetoothProfileConnectionInfo\n                    numRequestsToAudioFw +=\n                            mA2dpService.sendPreferredAudioProfileChangeToAudioFramework();\n                } else if (newDuplex == BluetoothProfile.LE_AUDIO\n                        && mLeAudioService.getActiveGroupId() == groupId) {\n                    Log.i(TAG, \"Sent change for AUDIO_MODE_DUPLEX to LE_AUDIO to Audio FW\");\n                    numRequestsToAudioFw +=\n                            mLeAudioService.sendPreferredAudioProfileChangeToAudioFramework();\n                }\n            }\n\n            Log.i(\n                    TAG,\n                    \"sendPreferredAudioProfileChangeToAudioFramework: sent \"\n                            + numRequestsToAudioFw\n                            + \" request(s) to the Audio Framework for device: \"\n                            + device);\n\n            if (numRequestsToAudioFw > 0) {\n                mCsipGroupsPendingAudioProfileChanges.put(\n                        groupId,\n                        new PendingAudioProfilePreferenceRequest(\n                                strippedPreferences, numRequestsToAudioFw, device));\n\n                Message m =\n                        mHandler.obtainMessage(\n                                MESSAGE_PREFERRED_AUDIO_PROFILES_AUDIO_FRAMEWORK_TIMEOUT);\n                m.obj = groupId;\n                mHandler.sendMessageDelayed(m, PREFERRED_AUDIO_PROFILE_CHANGE_TIMEOUT.toMillis());\n                return;\n            }\n        }\n        sendPreferredAudioProfilesCallbackToApps(\n                device, strippedPreferences, BluetoothStatusCodes.SUCCESS);\n    }\n\n    private void removeFromPendingAudioProfileChanges(int groupId) {\n        synchronized (mCsipGroupsPendingAudioProfileChanges) {\n            Log.i(\n                    TAG,\n                    \"removeFromPendingAudioProfileChanges: Timeout on change for groupId=\"\n                            + groupId);\n            if (!mCsipGroupsPendingAudioProfileChanges.containsKey(groupId)) {\n                Log.e(\n                        TAG,\n                        \"removeFromPendingAudioProfileChanges( \"\n                                + groupId\n                                + \", \"\n                                + groupId\n                                + \") is not pending\");\n                return;\n            }\n        }\n    }\n\n    /**\n     * Notification from the audio framework that an active device change has taken effect. See\n     * {@link BluetoothAdapter#notifyActiveDeviceChangeApplied(BluetoothDevice)} for more details.\n     *\n     * @param device the remote device whose preferred audio profiles have been changed\n     * @return whether the Bluetooth stack acknowledged the change successfully\n     */\n    private int notifyActiveDeviceChangeApplied(BluetoothDevice device) {\n        if (mLeAudioService == null) {\n            Log.e(TAG, \"LE Audio profile not enabled\");\n            return BluetoothStatusCodes.ERROR_PROFILE_NOT_CONNECTED;\n        }\n\n        int groupId = mLeAudioService.getGroupId(device);\n        if (groupId == LE_AUDIO_GROUP_ID_INVALID) {\n            return BluetoothStatusCodes.ERROR_DEVICE_NOT_BONDED;\n        }\n\n        synchronized (mCsipGroupsPendingAudioProfileChanges) {\n            if (!mCsipGroupsPendingAudioProfileChanges.containsKey(groupId)) {\n                Log.e(\n                        TAG,\n                        \"notifyActiveDeviceChangeApplied, but no pending request for \"\n                                + \"groupId: \"\n                                + groupId);\n                return BluetoothStatusCodes.ERROR_UNKNOWN;\n            }\n\n            PendingAudioProfilePreferenceRequest pendingRequest =\n                    mCsipGroupsPendingAudioProfileChanges.get(groupId);\n\n            // If this is the final audio framework request, send callback to apps\n            if (pendingRequest.mRemainingRequestsToAudioFramework == 1) {\n                Log.i(\n                        TAG,\n                        \"notifyActiveDeviceChangeApplied: Complete for device \"\n                                + pendingRequest.mDeviceRequested);\n                sendPreferredAudioProfilesCallbackToApps(\n                        pendingRequest.mDeviceRequested,\n                        pendingRequest.mRequestedPreferences,\n                        BluetoothStatusCodes.SUCCESS);\n                // Removes the timeout from the handler\n                mHandler.removeMessages(\n                        MESSAGE_PREFERRED_AUDIO_PROFILES_AUDIO_FRAMEWORK_TIMEOUT, groupId);\n            } else if (pendingRequest.mRemainingRequestsToAudioFramework > 1) {\n                PendingAudioProfilePreferenceRequest updatedPendingRequest =\n                        new PendingAudioProfilePreferenceRequest(\n                                pendingRequest.mRequestedPreferences,\n                                pendingRequest.mRemainingRequestsToAudioFramework - 1,\n                                pendingRequest.mDeviceRequested);\n                Log.i(\n                        TAG,\n                        \"notifyActiveDeviceChangeApplied: Updating device \"\n                                + updatedPendingRequest.mDeviceRequested\n                                + \" with new remaining requests count=\"\n                                + updatedPendingRequest.mRemainingRequestsToAudioFramework);\n                mCsipGroupsPendingAudioProfileChanges.put(groupId, updatedPendingRequest);\n            } else {\n                Log.i(\n                        TAG,\n                        \"notifyActiveDeviceChangeApplied: \"\n                                + pendingRequest.mDeviceRequested\n                                + \" has no remaining requests to audio framework, but is still\"\n                                + \" present in mCsipGroupsPendingAudioProfileChanges\");\n            }\n        }\n\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    private void sendPreferredAudioProfilesCallbackToApps(\n            BluetoothDevice device, Bundle preferredAudioProfiles, int status) {\n        int n = mPreferredAudioProfilesCallbacks.beginBroadcast();\n        Log.d(\n                TAG,\n                \"sendPreferredAudioProfilesCallbackToApps() - Broadcasting audio profile \"\n                        + (\"change callback to device: \" + device)\n                        + (\" and status=\" + status)\n                        + (\" to \" + n + \" receivers.\"));\n        for (int i = 0; i < n; i++) {\n            try {\n                mPreferredAudioProfilesCallbacks\n                        .getBroadcastItem(i)\n                        .onPreferredAudioProfilesChanged(device, preferredAudioProfiles, status);\n            } catch (RemoteException e) {\n                Log.d(\n                        TAG,\n                        \"sendPreferredAudioProfilesCallbackToApps() - Callback #\"\n                                + i\n                                + \" failed (\"\n                                + e\n                                + \")\");\n            }\n        }\n        mPreferredAudioProfilesCallbacks.finishBroadcast();\n    }\n\n    // ----API Methods--------\n\n    public boolean isEnabled() {\n        return getState() == BluetoothAdapter.STATE_ON;\n    }\n\n    public int getState() {\n        if (mAdapterProperties != null) {\n            return mAdapterProperties.getState();\n        }\n        return BluetoothAdapter.STATE_OFF;\n    }\n\n    public synchronized void offToBleOn(boolean quietMode) {\n        // Enforce the user restriction for disallowing Bluetooth if it was set.\n        if (mUserManager.hasUserRestrictionForUser(\n                UserManager.DISALLOW_BLUETOOTH, UserHandle.SYSTEM)) {\n            Log.d(TAG, \"offToBleOn() called when Bluetooth was disallowed\");\n            return;\n        }\n        if (Flags.fastBindToApp()) {\n            // The call to init must be done on the main thread\n            mHandler.post(() -> init());\n        }\n\n        Log.i(TAG, \"offToBleOn() - Enable called with quiet mode status =  \" + quietMode);\n        mQuietmode = quietMode;\n        mAdapterStateMachine.sendMessage(AdapterState.BLE_TURN_ON);\n    }\n\n    void onToBleOn() {\n        Log.d(TAG, \"onToBleOn() called with mRunningProfiles.size() = \" + mRunningProfiles.size());\n        mAdapterStateMachine.sendMessage(AdapterState.USER_TURN_OFF);\n    }\n\n    public String getName() {\n        return mAdapterProperties.getName();\n    }\n\n    public int getNameLengthForAdvertise() {\n        return mAdapterProperties.getName().length();\n    }\n\n    List<DiscoveringPackage> getDiscoveringPackages() {\n        return mDiscoveringPackages;\n    }\n\n    void clearDiscoveringPackages() {\n        synchronized (mDiscoveringPackages) {\n            mDiscoveringPackages.clear();\n        }\n    }\n\n    boolean startDiscovery(AttributionSource source) {\n        UserHandle callingUser = Binder.getCallingUserHandle();\n        Log.d(TAG, \"startDiscovery\");\n        String callingPackage = source.getPackageName();\n        mAppOps.checkPackage(Binder.getCallingUid(), callingPackage);\n        boolean isQApp = Utils.checkCallerTargetSdk(this, callingPackage, Build.VERSION_CODES.Q);\n        boolean hasDisavowedLocation =\n                Utils.hasDisavowedLocationForScan(this, source, mTestModeEnabled);\n        String permission = null;\n        if (Utils.checkCallerHasNetworkSettingsPermission(this)) {\n            permission = android.Manifest.permission.NETWORK_SETTINGS;\n        } else if (Utils.checkCallerHasNetworkSetupWizardPermission(this)) {\n            permission = android.Manifest.permission.NETWORK_SETUP_WIZARD;\n        } else if (!hasDisavowedLocation) {\n            if (isQApp) {\n                if (!Utils.checkCallerHasFineLocation(this, source, callingUser)) {\n                    return false;\n                }\n                permission = android.Manifest.permission.ACCESS_FINE_LOCATION;\n            } else {\n                if (!Utils.checkCallerHasCoarseLocation(this, source, callingUser)) {\n                    return false;\n                }\n                permission = android.Manifest.permission.ACCESS_COARSE_LOCATION;\n            }\n        }\n\n        synchronized (mDiscoveringPackages) {\n            mDiscoveringPackages.add(\n                    new DiscoveringPackage(callingPackage, permission, hasDisavowedLocation));\n        }\n        return mNativeInterface.startDiscovery();\n    }\n\n    /**\n     * Same as API method {@link BluetoothAdapter#getBondedDevices()}\n     *\n     * @return array of bonded {@link BluetoothDevice} or null on error\n     */\n    public BluetoothDevice[] getBondedDevices() {\n        return mAdapterProperties.getBondedDevices();\n    }\n\n    /**\n     * Get the database manager to access Bluetooth storage\n     *\n     * @return {@link DatabaseManager} or null on error\n     */\n    public DatabaseManager getDatabase() {\n        return mDatabaseManager;\n    }\n\n    public byte[] getByteIdentityAddress(BluetoothDevice device) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp != null && deviceProp.getIdentityAddress() != null) {\n            return Utils.getBytesFromAddress(deviceProp.getIdentityAddress());\n        }\n\n        if (Flags.identityAddressNullIfNotKnown()) {\n            // Return null if identity address unknown\n            return null;\n        } else {\n            return Utils.getByteAddress(device);\n        }\n    }\n\n    public BluetoothDevice getDeviceFromByte(byte[] address) {\n        BluetoothDevice device = mRemoteDevices.getDevice(address);\n        if (device == null) {\n            device = BluetoothAdapter.getDefaultAdapter().getRemoteDevice(address);\n        }\n        return device;\n    }\n\n    public String getIdentityAddress(String address) {\n        BluetoothDevice device =\n                BluetoothAdapter.getDefaultAdapter().getRemoteDevice(Ascii.toUpperCase(address));\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp != null && deviceProp.getIdentityAddress() != null) {\n            return deviceProp.getIdentityAddress();\n        } else {\n            if (Flags.identityAddressNullIfNotKnown()) {\n                // Return null if identity address unknown\n                return null;\n            } else {\n                return address;\n            }\n        }\n    }\n\n    private static class CallerInfo {\n        public String callerPackageName;\n        public UserHandle user;\n    }\n\n    boolean createBond(\n            BluetoothDevice device,\n            int transport,\n            OobData remoteP192Data,\n            OobData remoteP256Data,\n            String callingPackage) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp != null && deviceProp.getBondState() != BluetoothDevice.BOND_NONE) {\n            // true for BONDING, false for BONDED\n            return deviceProp.getBondState() == BluetoothDevice.BOND_BONDING;\n        }\n\n        if (!isEnabled()) {\n            Log.e(TAG, \"Impossible to call createBond when Bluetooth is not enabled\");\n            return false;\n        }\n\n        if (!isPackageNameAccurate(this, callingPackage, Binder.getCallingUid())) {\n            return false;\n        }\n\n        CallerInfo createBondCaller = new CallerInfo();\n        createBondCaller.callerPackageName = callingPackage;\n        createBondCaller.user = Binder.getCallingUserHandle();\n        mBondAttemptCallerInfo.put(device.getAddress(), createBondCaller);\n\n        mRemoteDevices.setBondingInitiatedLocally(Utils.getByteAddress(device));\n\n        // Pairing is unreliable while scanning, so cancel discovery\n        // Note, remove this when native stack improves\n        mNativeInterface.cancelDiscovery();\n\n        Message msg = mBondStateMachine.obtainMessage(BondStateMachine.CREATE_BOND);\n        msg.obj = device;\n        msg.arg1 = transport;\n\n        Bundle remoteOobDatasBundle = new Bundle();\n        boolean setData = false;\n        if (remoteP192Data != null) {\n            remoteOobDatasBundle.putParcelable(BondStateMachine.OOBDATAP192, remoteP192Data);\n            setData = true;\n        }\n        if (remoteP256Data != null) {\n            remoteOobDatasBundle.putParcelable(BondStateMachine.OOBDATAP256, remoteP256Data);\n            setData = true;\n        }\n        if (setData) {\n            msg.setData(remoteOobDatasBundle);\n        } else {\n            MetricsLogger.getInstance()\n                    .logBluetoothEvent(\n                            device,\n                            BluetoothStatsLog\n                                    .BLUETOOTH_CROSS_LAYER_EVENT_REPORTED__EVENT_TYPE__BONDING,\n                            BluetoothStatsLog.BLUETOOTH_CROSS_LAYER_EVENT_REPORTED__STATE__START,\n                            Binder.getCallingUid());\n        }\n        mBondStateMachine.sendMessage(msg);\n        return true;\n    }\n\n    /**\n     * Fetches the local OOB data to give out to remote.\n     *\n     * @param transport - specify data transport.\n     * @param callback - callback used to receive the requested {@link OobData}; null will be\n     *     ignored silently.\n     */\n    public synchronized void generateLocalOobData(\n            int transport, IBluetoothOobDataCallback callback) {\n        if (callback == null) {\n            Log.e(TAG, \"'callback' argument must not be null!\");\n            return;\n        }\n        if (mOobDataCallbackQueue.peek() != null) {\n            try {\n                callback.onError(BluetoothStatusCodes.ERROR_ANOTHER_ACTIVE_OOB_REQUEST);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Failed to make callback\", e);\n            }\n            return;\n        }\n        mOobDataCallbackQueue.offer(callback);\n        mHandler.postDelayed(\n                () -> removeFromOobDataCallbackQueue(callback),\n                GENERATE_LOCAL_OOB_DATA_TIMEOUT.toMillis());\n        mNativeInterface.generateLocalOobData(transport);\n    }\n\n    private synchronized void removeFromOobDataCallbackQueue(IBluetoothOobDataCallback callback) {\n        if (callback == null) {\n            return;\n        }\n\n        if (mOobDataCallbackQueue.peek() == callback) {\n            try {\n                mOobDataCallbackQueue.poll().onError(BluetoothStatusCodes.ERROR_UNKNOWN);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Failed to make OobDataCallback to remove callback from queue\", e);\n            }\n        }\n    }\n\n    /* package */ synchronized void notifyOobDataCallback(int transport, OobData oobData) {\n        if (mOobDataCallbackQueue.peek() == null) {\n            Log.e(TAG, \"Failed to make callback, no callback exists\");\n            return;\n        }\n        if (oobData == null) {\n            try {\n                mOobDataCallbackQueue.poll().onError(BluetoothStatusCodes.ERROR_UNKNOWN);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Failed to make callback\", e);\n            }\n        } else {\n            try {\n                mOobDataCallbackQueue.poll().onOobData(transport, oobData);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Failed to make callback\", e);\n            }\n        }\n    }\n\n    public boolean isQuietModeEnabled() {\n        Log.d(TAG, \"isQuietModeEnabled() - Enabled = \" + mQuietmode);\n        return mQuietmode;\n    }\n\n    public void updateUuids() {\n        Log.d(TAG, \"updateUuids() - Updating UUIDs for bonded devices\");\n        BluetoothDevice[] bondedDevices = getBondedDevices();\n        if (bondedDevices == null) {\n            return;\n        }\n\n        for (BluetoothDevice device : bondedDevices) {\n            mRemoteDevices.updateUuids(device);\n        }\n    }\n\n    /**\n     * Update device UUID changed to {@link BondStateMachine}\n     *\n     * @param device remote device of interest\n     */\n    public void deviceUuidUpdated(BluetoothDevice device) {\n        // Notify BondStateMachine for SDP complete / UUID changed.\n        Message msg = mBondStateMachine.obtainMessage(BondStateMachine.UUID_UPDATE);\n        msg.obj = device;\n        mBondStateMachine.sendMessage(msg);\n    }\n\n    /**\n     * Get the bond state of a particular {@link BluetoothDevice}\n     *\n     * @param device remote device of interest\n     * @return bond state\n     *     <p>Possible values are {@link BluetoothDevice#BOND_NONE}, {@link\n     *     BluetoothDevice#BOND_BONDING}, {@link BluetoothDevice#BOND_BONDED}.\n     */\n    public int getBondState(BluetoothDevice device) {\n        return mRemoteDevices.getBondState(device);\n    }\n\n    public boolean isConnected(BluetoothDevice device) {\n        return getConnectionState(device) != BluetoothDevice.CONNECTION_STATE_DISCONNECTED;\n    }\n\n    public int getConnectionState(BluetoothDevice device) {\n        final String address = device.getAddress();\n        if (Flags.apiGetConnectionStateUsingIdentityAddress()) {\n            int connectionState = mNativeInterface.getConnectionState(getBytesFromAddress(address));\n            final String identityAddress = getIdentityAddress(address);\n            if (identityAddress != null) {\n                connectionState |=\n                        mNativeInterface.getConnectionState(getBytesFromAddress(identityAddress));\n            }\n            return connectionState;\n        }\n        return mNativeInterface.getConnectionState(getBytesFromAddress(address));\n    }\n\n    int getConnectionHandle(BluetoothDevice device, int transport) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp == null) {\n            return BluetoothDevice.ERROR;\n        }\n        return deviceProp.getConnectionHandle(transport);\n    }\n\n    /**\n     * Get ASHA Capability\n     *\n     * @param device discovered bluetooth device\n     * @return ASHA capability\n     */\n    public int getAshaCapability(BluetoothDevice device) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp == null) {\n            return BluetoothDevice.ERROR;\n        }\n        return deviceProp.getAshaCapability();\n    }\n\n    /**\n     * Get ASHA truncated HiSyncId\n     *\n     * @param device discovered bluetooth device\n     * @return ASHA truncated HiSyncId\n     */\n    public int getAshaTruncatedHiSyncId(BluetoothDevice device) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp == null) {\n            return BluetoothDevice.ERROR;\n        }\n        return deviceProp.getAshaTruncatedHiSyncId();\n    }\n\n    /**\n     * Checks whether the device was recently associated with the comapnion app that called {@link\n     * BluetoothDevice#createBond}. This allows these devices to skip the pairing dialog if their\n     * pairing variant is {@link BluetoothDevice#PAIRING_VARIANT_CONSENT}.\n     *\n     * @param device the bluetooth device that is being bonded\n     * @return true if it was recently associated and we can bypass the dialog, false otherwise\n     */\n    public boolean canBondWithoutDialog(BluetoothDevice device) {\n        if (mBondAttemptCallerInfo.containsKey(device.getAddress())) {\n            CallerInfo bondCallerInfo = mBondAttemptCallerInfo.get(device.getAddress());\n\n            return mCompanionDeviceManager.canPairWithoutPrompt(\n                    bondCallerInfo.callerPackageName, device.getAddress(), bondCallerInfo.user);\n        }\n        return false;\n    }\n\n    /**\n     * Returns the package name of the most recent caller that called {@link\n     * BluetoothDevice#createBond} on the given device.\n     */\n    @Nullable\n    public String getPackageNameOfBondingApplication(BluetoothDevice device) {\n        CallerInfo info = mBondAttemptCallerInfo.get(device.getAddress());\n        if (info == null) {\n            return null;\n        }\n        return info.callerPackageName;\n    }\n\n    /**\n     * Sets device as the active devices for the profiles passed into the function.\n     *\n     * @param device is the remote bluetooth device\n     * @param profiles is a constant that references for which profiles we'll be setting the remote\n     *     device as our active device. One of the following: {@link\n     *     BluetoothAdapter#ACTIVE_DEVICE_AUDIO}, {@link BluetoothAdapter#ACTIVE_DEVICE_PHONE_CALL}\n     *     {@link BluetoothAdapter#ACTIVE_DEVICE_ALL}\n     * @return false if profiles value is not one of the constants we accept, true otherwise\n     */\n    public boolean setActiveDevice(BluetoothDevice device, @ActiveDeviceUse int profiles) {\n        if (getState() != BluetoothAdapter.STATE_ON) {\n            Log.e(TAG, \"setActiveDevice: Bluetooth is not enabled\");\n            return false;\n        }\n        boolean setA2dp = false;\n        boolean setHeadset = false;\n\n        // Determine for which profiles we want to set device as our active device\n        switch (profiles) {\n            case BluetoothAdapter.ACTIVE_DEVICE_AUDIO:\n                setA2dp = true;\n                break;\n            case BluetoothAdapter.ACTIVE_DEVICE_PHONE_CALL:\n                setHeadset = true;\n                break;\n            case BluetoothAdapter.ACTIVE_DEVICE_ALL:\n                setA2dp = true;\n                setHeadset = true;\n                break;\n            default:\n                return false;\n        }\n\n        boolean a2dpSupported =\n                mA2dpService != null\n                        && (device == null\n                                || mA2dpService.getConnectionPolicy(device)\n                                        == BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n        boolean hfpSupported =\n                mHeadsetService != null\n                        && (device == null\n                                || mHeadsetService.getConnectionPolicy(device)\n                                        == BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n        boolean leAudioSupported =\n                mLeAudioService != null\n                        && (device == null\n                                || mLeAudioService.getConnectionPolicy(device)\n                                        == BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n\n        if (leAudioSupported) {\n            Log.i(TAG, \"setActiveDevice: Setting active Le Audio device \" + device);\n            if (device == null) {\n                /* If called by BluetoothAdapter it means Audio should not be stopped.\n                 * For this reason let's say that fallback device exists\n                 */\n                mLeAudioService.removeActiveDevice(true /* hasFallbackDevice */);\n            } else {\n                mLeAudioService.setActiveDevice(device);\n            }\n        }\n\n        if (setA2dp && a2dpSupported) {\n            Log.i(TAG, \"setActiveDevice: Setting active A2dp device \" + device);\n            if (device == null) {\n                mA2dpService.removeActiveDevice(false);\n            } else {\n                /* Workaround for the controller issue which is not able to handle correctly\n                 * A2DP offloader vendor specific command while ISO Data path is set.\n                 * Proper solutions should be delivered in b/312396770\n                 */\n                if (mLeAudioService != null) {\n                    List<BluetoothDevice> activeLeAudioDevices = mLeAudioService.getActiveDevices();\n                    if (activeLeAudioDevices.get(0) != null) {\n                        mLeAudioService.removeActiveDevice(true);\n                    }\n                }\n                mA2dpService.setActiveDevice(device);\n            }\n        }\n\n        if (mHearingAidService != null\n                && (device == null\n                        || mHearingAidService.getConnectionPolicy(device)\n                                == BluetoothProfile.CONNECTION_POLICY_ALLOWED)) {\n            Log.i(TAG, \"setActiveDevice: Setting active Hearing Aid \" + device);\n            if (device == null) {\n                mHearingAidService.removeActiveDevice(false);\n            } else {\n                mHearingAidService.setActiveDevice(device);\n            }\n        }\n\n        if (setHeadset && hfpSupported) {\n            Log.i(TAG, \"setActiveDevice: Setting active Headset \" + device);\n            mHeadsetService.setActiveDevice(device);\n        }\n\n        return true;\n    }\n\n    /**\n     * Checks if all supported classic audio profiles are active on this LE Audio device.\n     *\n     * @param leAudioDevice the remote device\n     * @return {@code true} if all supported classic audio profiles are active on this device,\n     *     {@code false} otherwise\n     */\n    public boolean isAllSupportedClassicAudioProfilesActive(BluetoothDevice leAudioDevice) {\n        if (mLeAudioService == null) {\n            return false;\n        }\n        boolean a2dpSupported = isProfileSupported(leAudioDevice, BluetoothProfile.A2DP);\n        boolean hfpSupported = isProfileSupported(leAudioDevice, BluetoothProfile.HEADSET);\n\n        List<BluetoothDevice> groupDevices = mLeAudioService.getGroupDevices(leAudioDevice);\n        if (hfpSupported && mHeadsetService != null) {\n            BluetoothDevice activeHfpDevice = mHeadsetService.getActiveDevice();\n            if (activeHfpDevice == null || !groupDevices.contains(activeHfpDevice)) {\n                return false;\n            }\n        }\n        if (a2dpSupported && mA2dpService != null) {\n            BluetoothDevice activeA2dpDevice = mA2dpService.getActiveDevice();\n            if (activeA2dpDevice == null || !groupDevices.contains(activeA2dpDevice)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Get the active devices for the BluetoothProfile specified\n     *\n     * @param profile is the profile from which we want the active devices. Possible values are:\n     *     {@link BluetoothProfile#HEADSET}, {@link BluetoothProfile#A2DP}, {@link\n     *     BluetoothProfile#HEARING_AID} {@link BluetoothProfile#LE_AUDIO}\n     * @return A list of active bluetooth devices\n     */\n    public List<BluetoothDevice> getActiveDevices(@ActiveDeviceProfile int profile) {\n        List<BluetoothDevice> activeDevices = new ArrayList<>();\n\n        switch (profile) {\n            case BluetoothProfile.HEADSET:\n                if (mHeadsetService == null) {\n                    Log.e(TAG, \"getActiveDevices: HeadsetService is null\");\n                } else {\n                    BluetoothDevice device = mHeadsetService.getActiveDevice();\n                    if (device != null) {\n                        activeDevices.add(device);\n                    }\n                    Log.i(TAG, \"getActiveDevices: Headset device: \" + device);\n                }\n                break;\n            case BluetoothProfile.A2DP:\n                if (mA2dpService == null) {\n                    Log.e(TAG, \"getActiveDevices: A2dpService is null\");\n                } else {\n                    BluetoothDevice device = mA2dpService.getActiveDevice();\n                    if (device != null) {\n                        activeDevices.add(device);\n                    }\n                    Log.i(TAG, \"getActiveDevices: A2dp device: \" + device);\n                }\n                break;\n            case BluetoothProfile.HEARING_AID:\n                if (mHearingAidService == null) {\n                    Log.e(TAG, \"getActiveDevices: HearingAidService is null\");\n                } else {\n                    activeDevices = mHearingAidService.getActiveDevices();\n                    Log.i(\n                            TAG,\n                            \"getActiveDevices: Hearing Aid devices:\"\n                                    + (\" Left[\" + activeDevices.get(0) + \"] -\")\n                                    + (\" Right[\" + activeDevices.get(1) + \"]\"));\n                }\n                break;\n            case BluetoothProfile.LE_AUDIO:\n                if (mLeAudioService == null) {\n                    Log.e(TAG, \"getActiveDevices: LeAudioService is null\");\n                } else {\n                    activeDevices = mLeAudioService.getActiveDevices();\n                    Log.i(\n                            TAG,\n                            \"getActiveDevices: LeAudio devices:\"\n                                    + (\" Lead[\" + activeDevices.get(0) + \"] -\")\n                                    + (\" member_1[\" + activeDevices.get(1) + \"]\"));\n                }\n                break;\n            default:\n                Log.e(TAG, \"getActiveDevices: profile value is not valid\");\n        }\n        return activeDevices;\n    }\n\n    /**\n     * Attempts connection to all enabled and supported bluetooth profiles between the local and\n     * remote device\n     *\n     * @param device is the remote device with which to connect these profiles\n     * @return {@link BluetoothStatusCodes#SUCCESS} if all profiles connections are attempted, false\n     *     if an error occurred\n     */\n    public int connectAllEnabledProfiles(BluetoothDevice device) {\n        if (!profileServicesRunning()) {\n            Log.e(TAG, \"connectAllEnabledProfiles: Not all profile services running\");\n            return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n        }\n\n        // Checks if any profiles are enablde or disabled and if so, only connect enabled profiles\n        if (!isAllProfilesUnknown(device)) {\n            return connectEnabledProfiles(device);\n        }\n\n        connectAllSupportedProfiles(device);\n\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    /**\n     * Connect all supported bluetooth profiles between the local and remote device\n     *\n     * @param device is the remote device with which to connect all supported profiles\n     */\n    void connectAllSupportedProfiles(BluetoothDevice device) {\n        int numProfilesConnected = 0;\n\n        // All profile toggles disabled, so connects all supported profiles\n        if (mA2dpService != null && isProfileSupported(device, BluetoothProfile.A2DP)) {\n            Log.i(TAG, \"connectAllSupportedProfiles: Connecting A2dp\");\n            // Set connection policy also connects the profile with CONNECTION_POLICY_ALLOWED\n            mA2dpService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mA2dpSinkService != null && isProfileSupported(device, BluetoothProfile.A2DP_SINK)) {\n            Log.i(TAG, \"connectAllSupportedProfiles: Connecting A2dp Sink\");\n            mA2dpSinkService.setConnectionPolicy(\n                    device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHeadsetService != null && isProfileSupported(device, BluetoothProfile.HEADSET)) {\n            Log.i(TAG, \"connectAllSupportedProfiles: Connecting Headset Profile\");\n            mHeadsetService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHeadsetClientService != null\n                && isProfileSupported(device, BluetoothProfile.HEADSET_CLIENT)) {\n            Log.i(TAG, \"connectAllSupportedProfiles: Connecting HFP\");\n            mHeadsetClientService.setConnectionPolicy(\n                    device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mMapClientService != null && isProfileSupported(device, BluetoothProfile.MAP_CLIENT)) {\n            Log.i(TAG, \"connectAllSupportedProfiles: Connecting MAP\");\n            mMapClientService.setConnectionPolicy(\n                    device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHidHostService != null && isProfileSupported(device, BluetoothProfile.HID_HOST)) {\n            Log.i(TAG, \"connectAllSupportedProfiles: Connecting Hid Host Profile\");\n            mHidHostService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mPanService != null && isProfileSupported(device, BluetoothProfile.PAN)) {\n            Log.i(TAG, \"connectAllSupportedProfiles: Connecting Pan Profile\");\n            mPanService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mPbapClientService != null\n                && isProfileSupported(device, BluetoothProfile.PBAP_CLIENT)) {\n            Log.i(TAG, \"connectAllSupportedProfiles: Connecting Pbap\");\n            mPbapClientService.setConnectionPolicy(\n                    device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHearingAidService != null\n                && isProfileSupported(device, BluetoothProfile.HEARING_AID)) {\n            if (mHapClientService != null\n                    && isProfileSupported(device, BluetoothProfile.HAP_CLIENT)) {\n                Log.i(\n                        TAG,\n                        \"connectAllSupportedProfiles: Hearing Access Client Profile is enabled at\"\n                                + \" the same time with Hearing Aid Profile, ignore Hearing Aid\"\n                                + \" Profile\");\n            } else {\n                Log.i(TAG, \"connectAllSupportedProfiles: Connecting Hearing Aid Profile\");\n                mHearingAidService.setConnectionPolicy(\n                        device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n                numProfilesConnected++;\n            }\n        }\n        if (mHapClientService != null && isProfileSupported(device, BluetoothProfile.HAP_CLIENT)) {\n            Log.i(TAG, \"connectAllSupportedProfiles: Connecting Hearing Access Client Profile\");\n            mHapClientService.setConnectionPolicy(\n                    device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mVolumeControlService != null\n                && isProfileSupported(device, BluetoothProfile.VOLUME_CONTROL)) {\n            Log.i(TAG, \"connectAllSupportedProfiles: Connecting Volume Control Profile\");\n            mVolumeControlService.setConnectionPolicy(\n                    device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mCsipSetCoordinatorService != null\n                && isProfileSupported(device, BluetoothProfile.CSIP_SET_COORDINATOR)) {\n            Log.i(TAG, \"connectAllSupportedProfiles: Connecting Coordinated Set Profile\");\n            mCsipSetCoordinatorService.setConnectionPolicy(\n                    device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mLeAudioService != null && isProfileSupported(device, BluetoothProfile.LE_AUDIO)) {\n            Log.i(TAG, \"connectAllSupportedProfiles: Connecting LeAudio profile (BAP)\");\n            mLeAudioService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mBassClientService != null\n                && isProfileSupported(device, BluetoothProfile.LE_AUDIO_BROADCAST_ASSISTANT)) {\n            Log.i(TAG, \"connectAllSupportedProfiles: Connecting LE Broadcast Assistant Profile\");\n            mBassClientService.setConnectionPolicy(\n                    device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mBatteryService != null && isProfileSupported(device, BluetoothProfile.BATTERY)) {\n            Log.i(TAG, \"connectAllSupportedProfiles: Connecting Battery Service\");\n            mBatteryService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n\n        Log.i(\n                TAG,\n                \"connectAllSupportedProfiles: Number of Profiles Connected: \"\n                        + numProfilesConnected);\n    }\n\n    /**\n     * Disconnects all enabled and supported bluetooth profiles between the local and remote device\n     *\n     * @param device is the remote device with which to disconnect these profiles\n     * @return true if all profiles successfully disconnected, false if an error occurred\n     */\n    public int disconnectAllEnabledProfiles(BluetoothDevice device) {\n        if (!profileServicesRunning()) {\n            Log.e(TAG, \"disconnectAllEnabledProfiles: Not all profile services bound\");\n            return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n        }\n\n        if (mA2dpService != null\n                && (mA2dpService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED\n                        || mA2dpService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting A2dp\");\n            mA2dpService.disconnect(device);\n        }\n        if (mA2dpSinkService != null\n                && (mA2dpSinkService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED\n                        || mA2dpSinkService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting A2dp Sink\");\n            mA2dpSinkService.disconnect(device);\n        }\n        if (mHeadsetService != null\n                && (mHeadsetService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED\n                        || mHeadsetService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Headset Profile\");\n            mHeadsetService.disconnect(device);\n        }\n        if (mHeadsetClientService != null\n                && (mHeadsetClientService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTED\n                        || mHeadsetClientService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting HFP\");\n            mHeadsetClientService.disconnect(device);\n        }\n        if (mMapClientService != null\n                && (mMapClientService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED\n                        || mMapClientService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting MAP Client\");\n            mMapClientService.disconnect(device);\n        }\n        if (mMapService != null\n                && (mMapService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED\n                        || mMapService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting MAP\");\n            mMapService.disconnect(device);\n        }\n        if (mHidDeviceService != null\n                && (mHidDeviceService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED\n                        || mHidDeviceService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Hid Device Profile\");\n            mHidDeviceService.disconnect(device);\n        }\n        if (mHidHostService != null\n                && (mHidHostService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED\n                        || mHidHostService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Hid Host Profile\");\n            mHidHostService.disconnect(device);\n        }\n        if (mPanService != null\n                && (mPanService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED\n                        || mPanService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Pan Profile\");\n            mPanService.disconnect(device);\n        }\n        if (mPbapClientService != null\n                && (mPbapClientService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTED\n                        || mPbapClientService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Pbap Client\");\n            mPbapClientService.disconnect(device);\n        }\n        if (mPbapService != null\n                && (mPbapService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED\n                        || mPbapService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Pbap Server\");\n            mPbapService.disconnect(device);\n        }\n        if (mHearingAidService != null\n                && (mHearingAidService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTED\n                        || mHearingAidService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Hearing Aid Profile\");\n            mHearingAidService.disconnect(device);\n        }\n        if (mHapClientService != null\n                && (mHapClientService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED\n                        || mHapClientService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Hearing Access Profile Client\");\n            mHapClientService.disconnect(device);\n        }\n        if (mVolumeControlService != null\n                && (mVolumeControlService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTED\n                        || mVolumeControlService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Volume Control Profile\");\n            mVolumeControlService.disconnect(device);\n        }\n        if (mSapService != null\n                && (mSapService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED\n                        || mSapService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Sap Profile\");\n            mSapService.disconnect(device);\n        }\n        if (mCsipSetCoordinatorService != null\n                && (mCsipSetCoordinatorService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTED\n                        || mCsipSetCoordinatorService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Coordinator Set Profile\");\n            mCsipSetCoordinatorService.disconnect(device);\n        }\n        if (mLeAudioService != null\n                && (mLeAudioService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED\n                        || mLeAudioService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting LeAudio profile (BAP)\");\n            mLeAudioService.disconnect(device);\n        }\n        if (mBassClientService != null\n                && (mBassClientService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTED\n                        || mBassClientService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(\n                    TAG,\n                    \"disconnectAllEnabledProfiles: Disconnecting \"\n                            + \"LE Broadcast Assistant Profile\");\n            mBassClientService.disconnect(device);\n        }\n        if (mBatteryService != null\n                && (mBatteryService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED\n                        || mBatteryService.getConnectionState(device)\n                                == BluetoothProfile.STATE_CONNECTING)) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting \" + \"Battery Service\");\n            mBatteryService.disconnect(device);\n        }\n\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    /**\n     * Same as API method {@link BluetoothDevice#getName()}\n     *\n     * @param device remote device of interest\n     * @return remote device name\n     */\n    public String getRemoteName(BluetoothDevice device) {\n        return mRemoteDevices.getName(device);\n    }\n\n    public int getRemoteClass(BluetoothDevice device) {\n        return mRemoteDevices.getBluetoothClass(device);\n    }\n\n    /**\n     * Get UUIDs for service supported by a remote device\n     *\n     * @param device the remote device that we want to get UUIDs from\n     * @return the uuids of the remote device\n     */\n    public ParcelUuid[] getRemoteUuids(BluetoothDevice device) {\n        return mRemoteDevices.getUuids(device);\n    }\n\n    void aclStateChangeBroadcastCallback(Consumer<IBluetoothConnectionCallback> cb) {\n        int n = mBluetoothConnectionCallbacks.beginBroadcast();\n        Log.d(TAG, \"aclStateChangeBroadcastCallback() - Broadcasting to \" + n + \" receivers.\");\n        for (int i = 0; i < n; i++) {\n            cb.accept(mBluetoothConnectionCallbacks.getBroadcastItem(i));\n        }\n        mBluetoothConnectionCallbacks.finishBroadcast();\n    }\n\n    /**\n     * Converts HCI disconnect reasons to Android disconnect reasons.\n     *\n     * <p>The HCI Error Codes used for ACL disconnect reasons propagated up from native code were\n     * copied from: packages/modules/Bluetooth/system/stack/include/hci_error_code.h\n     *\n     * <p>These error codes are specified and described in Bluetooth Core Spec v5.1, Vol 2, Part D.\n     *\n     * @param hciReason is the raw HCI disconnect reason from native.\n     * @return the Android disconnect reason for apps.\n     */\n    static @BluetoothAdapter.BluetoothConnectionCallback.DisconnectReason int\n            hciToAndroidDisconnectReason(int hciReason) {\n        switch (hciReason) {\n            case /*HCI_SUCCESS*/ 0x00:\n            case /*HCI_ERR_UNSPECIFIED*/ 0x1F:\n            case /*HCI_ERR_UNDEFINED*/ 0xff:\n                return BluetoothStatusCodes.ERROR_UNKNOWN;\n            case /*HCI_ERR_ILLEGAL_COMMAND*/ 0x01:\n            case /*HCI_ERR_NO_CONNECTION*/ 0x02:\n            case /*HCI_ERR_HW_FAILURE*/ 0x03:\n            case /*HCI_ERR_DIFF_TRANSACTION_COLLISION*/ 0x2A:\n            case /*HCI_ERR_ROLE_SWITCH_PENDING*/ 0x32:\n            case /*HCI_ERR_ROLE_SWITCH_FAILED*/ 0x35:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_LOCAL;\n            case /*HCI_ERR_PAGE_TIMEOUT*/ 0x04:\n            case /*HCI_ERR_CONNECTION_TOUT*/ 0x08:\n            case /*HCI_ERR_HOST_TIMEOUT*/ 0x10:\n            case /*HCI_ERR_LMP_RESPONSE_TIMEOUT*/ 0x22:\n            case /*HCI_ERR_ADVERTISING_TIMEOUT*/ 0x3C:\n            case /*HCI_ERR_CONN_FAILED_ESTABLISHMENT*/ 0x3E:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_TIMEOUT;\n            case /*HCI_ERR_AUTH_FAILURE*/ 0x05:\n            case /*HCI_ERR_KEY_MISSING*/ 0x06:\n            case /*HCI_ERR_HOST_REJECT_SECURITY*/ 0x0E:\n            case /*HCI_ERR_REPEATED_ATTEMPTS*/ 0x17:\n            case /*HCI_ERR_PAIRING_NOT_ALLOWED*/ 0x18:\n            case /*HCI_ERR_ENCRY_MODE_NOT_ACCEPTABLE*/ 0x25:\n            case /*HCI_ERR_UNIT_KEY_USED*/ 0x26:\n            case /*HCI_ERR_PAIRING_WITH_UNIT_KEY_NOT_SUPPORTED*/ 0x29:\n            case /*HCI_ERR_INSUFFCIENT_SECURITY*/ 0x2F:\n            case /*HCI_ERR_HOST_BUSY_PAIRING*/ 0x38:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_SECURITY;\n            case /*HCI_ERR_MEMORY_FULL*/ 0x07:\n            case /*HCI_ERR_MAX_NUM_OF_CONNECTIONS*/ 0x09:\n            case /*HCI_ERR_MAX_NUM_OF_SCOS*/ 0x0A:\n            case /*HCI_ERR_COMMAND_DISALLOWED*/ 0x0C:\n            case /*HCI_ERR_HOST_REJECT_RESOURCES*/ 0x0D:\n            case /*HCI_ERR_LIMIT_REACHED*/ 0x43:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_RESOURCE_LIMIT_REACHED;\n            case /*HCI_ERR_CONNECTION_EXISTS*/ 0x0B:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_CONNECTION_ALREADY_EXISTS;\n            case /*HCI_ERR_HOST_REJECT_DEVICE*/ 0x0F:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_SYSTEM_POLICY;\n            case /*HCI_ERR_ILLEGAL_PARAMETER_FMT*/ 0x12:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_BAD_PARAMETERS;\n            case /*HCI_ERR_PEER_USER*/ 0x13:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_REMOTE_REQUEST;\n            case /*HCI_ERR_REMOTE_POWER_OFF*/ 0x15:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_REMOTE_REQUEST;\n            case /*HCI_ERR_CONN_CAUSE_LOCAL_HOST*/ 0x16:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_LOCAL_REQUEST;\n            case /*HCI_ERR_UNSUPPORTED_REM_FEATURE*/ 0x1A:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_REMOTE;\n            case /*HCI_ERR_UNACCEPT_CONN_INTERVAL*/ 0x3B:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_BAD_PARAMETERS;\n            default:\n                Log.e(TAG, \"Invalid HCI disconnect reason: \" + hciReason);\n                return BluetoothStatusCodes.ERROR_UNKNOWN;\n        }\n    }\n\n    void logUserBondResponse(BluetoothDevice device, boolean accepted, int event) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            BluetoothStatsLog.write(\n                    BluetoothStatsLog.BLUETOOTH_BOND_STATE_CHANGED,\n                    obfuscateAddress(device),\n                    0,\n                    device.getType(),\n                    BluetoothDevice.BOND_BONDING,\n                    event,\n                    accepted ? 0 : BluetoothDevice.UNBOND_REASON_AUTH_REJECTED);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    public int getPhonebookAccessPermission(BluetoothDevice device) {\n        return getDeviceAccessFromPrefs(device, PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE);\n    }\n\n    public int getMessageAccessPermission(BluetoothDevice device) {\n        return getDeviceAccessFromPrefs(device, MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE);\n    }\n\n    public int getSimAccessPermission(BluetoothDevice device) {\n        return getDeviceAccessFromPrefs(device, SIM_ACCESS_PERMISSION_PREFERENCE_FILE);\n    }\n\n    int getDeviceAccessFromPrefs(BluetoothDevice device, String prefFile) {\n        SharedPreferences prefs = getSharedPreferences(prefFile, Context.MODE_PRIVATE);\n        if (!prefs.contains(device.getAddress())) {\n            return BluetoothDevice.ACCESS_UNKNOWN;\n        }\n        return prefs.getBoolean(device.getAddress(), false)\n                ? BluetoothDevice.ACCESS_ALLOWED\n                : BluetoothDevice.ACCESS_REJECTED;\n    }\n\n    void setDeviceAccessFromPrefs(BluetoothDevice device, int value, String prefFile) {\n        SharedPreferences pref = getSharedPreferences(prefFile, Context.MODE_PRIVATE);\n        SharedPreferences.Editor editor = pref.edit();\n        if (value == BluetoothDevice.ACCESS_UNKNOWN) {\n            editor.remove(device.getAddress());\n        } else {\n            editor.putBoolean(device.getAddress(), value == BluetoothDevice.ACCESS_ALLOWED);\n        }\n        editor.apply();\n    }\n\n    public void setPhonebookAccessPermission(BluetoothDevice device, int value) {\n        setDeviceAccessFromPrefs(device, value, PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE);\n    }\n\n    public void setMessageAccessPermission(BluetoothDevice device, int value) {\n        setDeviceAccessFromPrefs(device, value, MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE);\n    }\n\n    public void setSimAccessPermission(BluetoothDevice device, int value) {\n        setDeviceAccessFromPrefs(device, value, SIM_ACCESS_PERMISSION_PREFERENCE_FILE);\n    }\n\n    public boolean isRpaOffloadSupported() {\n        return mAdapterProperties.isRpaOffloadSupported();\n    }\n\n    public int getNumOfOffloadedIrkSupported() {\n        return mAdapterProperties.getNumOfOffloadedIrkSupported();\n    }\n\n    public int getNumOfOffloadedScanFilterSupported() {\n        return mAdapterProperties.getNumOfOffloadedScanFilterSupported();\n    }\n\n    public int getOffloadedScanResultStorage() {\n        return mAdapterProperties.getOffloadedScanResultStorage();\n    }\n\n    public boolean isLe2MPhySupported() {\n        return mAdapterProperties.isLe2MPhySupported();\n    }\n\n    public boolean isLeCodedPhySupported() {\n        return mAdapterProperties.isLeCodedPhySupported();\n    }\n\n    public boolean isLeExtendedAdvertisingSupported() {\n        return mAdapterProperties.isLeExtendedAdvertisingSupported();\n    }\n\n    public boolean isLePeriodicAdvertisingSupported() {\n        return mAdapterProperties.isLePeriodicAdvertisingSupported();\n    }\n\n    /**\n     * Check if the LE audio broadcast source feature is supported.\n     *\n     * @return true, if the LE audio broadcast source is supported\n     */\n    public boolean isLeAudioBroadcastSourceSupported() {\n        return mAdapterProperties.isLePeriodicAdvertisingSupported()\n                && mAdapterProperties.isLeExtendedAdvertisingSupported()\n                && mAdapterProperties.isLeIsochronousBroadcasterSupported();\n    }\n\n    /**\n     * Check if the LE audio broadcast assistant feature is supported.\n     *\n     * @return true, if the LE audio broadcast assistant is supported\n     */\n    public boolean isLeAudioBroadcastAssistantSupported() {\n        return mAdapterProperties.isLePeriodicAdvertisingSupported()\n                && mAdapterProperties.isLeExtendedAdvertisingSupported()\n                && (mAdapterProperties.isLePeriodicAdvertisingSyncTransferSenderSupported()\n                        || mAdapterProperties\n                                .isLePeriodicAdvertisingSyncTransferRecipientSupported());\n    }\n\n    /**\n     * Check if the LE channel sounding feature is supported.\n     *\n     * @return true, if the LE channel sounding is supported\n     */\n    public boolean isLeChannelSoundingSupported() {\n        return mAdapterProperties.isLeChannelSoundingSupported();\n    }\n\n    public long getSupportedProfilesBitMask() {\n        return Config.getSupportedProfilesBitMask();\n    }\n\n    /**\n     * Check if the LE audio CIS central feature is supported.\n     *\n     * @return true, if the LE audio CIS central is supported\n     */\n    public boolean isLeConnectedIsochronousStreamCentralSupported() {\n        return mAdapterProperties.isLeConnectedIsochronousStreamCentralSupported();\n    }\n\n    public int getLeMaximumAdvertisingDataLength() {\n        return mAdapterProperties.getLeMaximumAdvertisingDataLength();\n    }\n\n    /**\n     * Get the maximum number of connected audio devices.\n     *\n     * @return the maximum number of connected audio devices\n     */\n    public int getMaxConnectedAudioDevices() {\n        return mAdapterProperties.getMaxConnectedAudioDevices();\n    }\n\n    /**\n     * Check whether A2DP offload is enabled.\n     *\n     * @return true if A2DP offload is enabled\n     */\n    public boolean isA2dpOffloadEnabled() {\n        return mAdapterProperties.isA2dpOffloadEnabled();\n    }\n\n    /** Register a bluetooth state callback */\n    public void registerBluetoothStateCallback(Executor executor, BluetoothStateCallback callback) {\n        mLocalCallbacks.put(callback, executor);\n    }\n\n    /** Unregister a bluetooth state callback */\n    public void unregisterBluetoothStateCallback(BluetoothStateCallback callback) {\n        mLocalCallbacks.remove(callback);\n    }\n\n    @VisibleForTesting\n    void registerRemoteCallback(IBluetoothCallback callback) {\n        mRemoteCallbacks.register(callback);\n    }\n\n    @VisibleForTesting\n    void unregisterRemoteCallback(IBluetoothCallback callback) {\n        mRemoteCallbacks.unregister(callback);\n    }\n\n    @VisibleForTesting\n    void bleOnToOn() {\n        mAdapterStateMachine.sendMessage(AdapterState.USER_TURN_ON);\n    }\n\n    @VisibleForTesting\n    void bleOnToOff() {\n        mAdapterStateMachine.sendMessage(AdapterState.BLE_TURN_OFF);\n    }\n\n    @VisibleForTesting\n    boolean factoryReset() {\n        mDatabaseManager.factoryReset();\n\n        if (mBluetoothKeystoreService != null) {\n            mBluetoothKeystoreService.factoryReset();\n        }\n\n        if (mBtCompanionManager != null) {\n            mBtCompanionManager.factoryReset();\n        }\n\n        return mNativeInterface.factoryReset();\n    }\n\n    @VisibleForTesting\n    int getScanMode() {\n        return mScanMode;\n    }\n\n    private boolean setScanMode(int mode, String from) {\n        mScanModeChanges.add(Utils.getLocalTimeString() + \" (\" + from + \") \" + dumpScanMode(mode));\n        if (!mNativeInterface.setScanMode(convertScanModeToHal(mode))) {\n            return false;\n        }\n        mScanMode = mode;\n        Intent intent =\n                new Intent(BluetoothAdapter.ACTION_SCAN_MODE_CHANGED)\n                        .putExtra(BluetoothAdapter.EXTRA_SCAN_MODE, mScanMode)\n                        .addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);\n        sendBroadcast(intent, BLUETOOTH_SCAN, Utils.getTempBroadcastOptions().toBundle());\n        return true;\n    }\n\n    @VisibleForTesting\n    BluetoothActivityEnergyInfo reportActivityInfo() {\n        if (mAdapterProperties.getState() != BluetoothAdapter.STATE_ON\n                || !mAdapterProperties.isActivityAndEnergyReportingSupported()) {\n            return null;\n        }\n\n        // Pull the data. The callback will notify mEnergyInfoLock.\n        mNativeInterface.readEnergyInfo();\n\n        synchronized (mEnergyInfoLock) {\n            long now = System.currentTimeMillis();\n            final long deadline = now + CONTROLLER_ENERGY_UPDATE_TIMEOUT_MILLIS;\n            while (now < deadline) {\n                try {\n                    mEnergyInfoLock.wait(deadline - now);\n                    break;\n                } catch (InterruptedException e) {\n                    now = System.currentTimeMillis();\n                }\n            }\n\n            final BluetoothActivityEnergyInfo info =\n                    new BluetoothActivityEnergyInfo(\n                            SystemClock.elapsedRealtime(),\n                            mStackReportedState,\n                            mTxTimeTotalMs,\n                            mRxTimeTotalMs,\n                            mIdleTimeTotalMs,\n                            mEnergyUsedTotalVoltAmpSecMicro);\n\n            // Copy the traffic objects whose byte counts are > 0\n            final List<UidTraffic> result = new ArrayList<>();\n            for (int i = 0; i < mUidTraffic.size(); i++) {\n                final UidTraffic traffic = mUidTraffic.valueAt(i);\n                if (traffic.getTxBytes() != 0 || traffic.getRxBytes() != 0) {\n                    result.add(traffic.clone());\n                }\n            }\n\n            info.setUidTraffic(result);\n\n            return info;\n        }\n    }\n\n    public int getTotalNumOfTrackableAdvertisements() {\n        return mAdapterProperties.getTotalNumOfTrackableAdvertisements();\n    }\n\n    /**\n     * Return if offloaded TDS filter is supported.\n     *\n     * @return {@code BluetoothStatusCodes.FEATURE_SUPPORTED} if supported\n     */\n    public int getOffloadedTransportDiscoveryDataScanSupported() {\n        if (mAdapterProperties.isOffloadedTransportDiscoveryDataScanSupported()) {\n            return BluetoothStatusCodes.FEATURE_SUPPORTED;\n        }\n        return BluetoothStatusCodes.FEATURE_NOT_SUPPORTED;\n    }\n\n    IBinder getBluetoothGatt() {\n        return mGattService == null ? null : mGattService.getBinder();\n    }\n\n    public GattService getBluetoothGattService() {\n        return mGattService;\n    }\n\n    IBinder getBluetoothScan() {\n        return mScanController == null ? null : mScanController.getBinder();\n    }\n\n    public ScanController getBluetoothScanController() {\n        return mScanController;\n    }\n\n    @RequiresPermission(BLUETOOTH_CONNECT)\n    void unregAllGattClient(AttributionSource source) {\n        if (mGattService != null) {\n            mGattService.unregAll(source);\n        }\n    }\n\n    IBinder getProfile(int profileId) {\n        if (getState() == BluetoothAdapter.STATE_TURNING_ON) {\n            return null;\n        }\n\n        // LE_AUDIO_BROADCAST is not associated with a service and use LE_AUDIO's Binder\n        if (profileId == BluetoothProfile.LE_AUDIO_BROADCAST) {\n            profileId = BluetoothProfile.LE_AUDIO;\n        }\n\n        ProfileService profile = mStartedProfiles.get(profileId);\n        if (profile != null) {\n            return profile.getBinder();\n        } else {\n            return null;\n        }\n    }\n\n    boolean isMediaProfileConnected() {\n        if (mA2dpService != null && mA2dpService.getConnectedDevices().size() > 0) {\n            Log.d(TAG, \"isMediaProfileConnected. A2dp is connected\");\n            return true;\n        } else if (mHearingAidService != null\n                && mHearingAidService.getConnectedDevices().size() > 0) {\n            Log.d(TAG, \"isMediaProfileConnected. HearingAid is connected\");\n            return true;\n        } else if (mLeAudioService != null && mLeAudioService.getConnectedDevices().size() > 0) {\n            Log.d(TAG, \"isMediaProfileConnected. LeAudio is connected\");\n            return true;\n        } else {\n            Log.d(\n                    TAG,\n                    \"isMediaProfileConnected: no Media connected.\"\n                            + (\" A2dp=\" + mA2dpService)\n                            + (\" HearingAid=\" + mHearingAidService)\n                            + (\" LeAudio=\" + mLeAudioService));\n            return false;\n        }\n    }\n\n    /** Update PhonePolicy when new {@link BluetoothDevice} creates an ACL connection. */\n    public void updatePhonePolicyOnAclConnect(BluetoothDevice device) {\n        if (mPhonePolicy != null) {\n            mPhonePolicy.handleAclConnected(device);\n        }\n    }\n\n    /**\n     * Notify {@link BluetoothProfile} when ACL connection disconnects from {@link BluetoothDevice}\n     * for a given {@code transport}.\n     */\n    public void notifyAclDisconnected(BluetoothDevice device, int transport) {\n        if (mMapService != null && mMapService.isAvailable()) {\n            mMapService.aclDisconnected(device);\n        }\n        if (mMapClientService != null && mMapClientService.isAvailable()) {\n            mMapClientService.aclDisconnected(device, transport);\n        }\n        if (mSapService != null && mSapService.isAvailable()) {\n            mSapService.aclDisconnected(device);\n        }\n        if (mPbapClientService != null && mPbapClientService.isAvailable()) {\n            mPbapClientService.aclDisconnected(device, transport);\n        }\n    }\n\n    /**\n     * Notify GATT of a Bluetooth profile's connection state change for a given {@link\n     * BluetoothProfile}.\n     */\n    public void notifyProfileConnectionStateChangeToGatt(int profile, int fromState, int toState) {\n        if (mGattService == null) {\n            Log.w(TAG, \"GATT Service is not running!\");\n            return;\n        }\n        if (Flags.scanManagerRefactor()) {\n            mScanController.notifyProfileConnectionStateChange(profile, fromState, toState);\n        } else {\n            mGattService.notifyProfileConnectionStateChange(profile, fromState, toState);\n        }\n    }\n\n    /**\n     * Handle Bluetooth app state when connection state changes for a given {@code profile}.\n     *\n     * <p>Currently this function is limited to handling Phone policy but the eventual goal is to\n     * move all connection logic here.\n     */\n    public void handleProfileConnectionStateChange(\n            int profile, BluetoothDevice device, int fromState, int toState) {\n        if (mPhonePolicy != null) {\n            mPhonePolicy.profileConnectionStateChanged(profile, device, fromState, toState);\n        }\n    }\n\n    /** Handle Bluetooth app state when active device changes for a given {@code profile}. */\n    public void handleActiveDeviceChange(int profile, BluetoothDevice device) {\n        mActiveDeviceManager.profileActiveDeviceChanged(profile, device);\n        mSilenceDeviceManager.profileActiveDeviceChanged(profile, device);\n        if (mPhonePolicy != null) {\n            mPhonePolicy.profileActiveDeviceChanged(profile, device);\n        }\n    }\n\n    /** Notify MAP and Pbap when a new sdp search record is found. */\n    public void sendSdpSearchRecord(\n            BluetoothDevice device, int status, Parcelable record, ParcelUuid uuid) {\n        if (mMapService != null && mMapService.isAvailable()) {\n            mMapService.receiveSdpSearchRecord(status, record, uuid);\n        }\n        if (mMapClientService != null && mMapClientService.isAvailable()) {\n            mMapClientService.receiveSdpSearchRecord(device, status, record, uuid);\n        }\n        if (mPbapClientService != null && mPbapClientService.isAvailable()) {\n            mPbapClientService.receiveSdpSearchRecord(device, status, record, uuid);\n        }\n    }\n\n    /** Handle Bluetooth profiles when bond state changes with a {@link BluetoothDevice} */\n    public void handleBondStateChanged(BluetoothDevice device, int fromState, int toState) {\n        if (mA2dpService != null && mA2dpService.isAvailable()) {\n            mA2dpService.handleBondStateChanged(device, fromState, toState);\n        }\n        if (mHeadsetService != null && mHeadsetService.isAvailable()) {\n            mHeadsetService.handleBondStateChanged(device, fromState, toState);\n        }\n        if (mLeAudioService != null && mLeAudioService.isAvailable()) {\n            mLeAudioService.handleBondStateChanged(device, fromState, toState);\n        }\n        if (mHearingAidService != null && mHearingAidService.isAvailable()) {\n            mHearingAidService.handleBondStateChanged(device, fromState, toState);\n        }\n        if (mHapClientService != null && mHapClientService.isAvailable()) {\n            mHapClientService.handleBondStateChanged(device, fromState, toState);\n        }\n        if (mBassClientService != null && mBassClientService.isAvailable()) {\n            mBassClientService.handleBondStateChanged(device, fromState, toState);\n        }\n        if (mBatteryService != null && mBatteryService.isAvailable()) {\n            mBatteryService.handleBondStateChanged(device, fromState, toState);\n        }\n        if (mVolumeControlService != null && mVolumeControlService.isAvailable()) {\n            mVolumeControlService.handleBondStateChanged(device, fromState, toState);\n        }\n        if (mPbapService != null && mPbapService.isAvailable()) {\n            mPbapService.handleBondStateChanged(device, fromState, toState);\n        }\n        if (mCsipSetCoordinatorService != null && mCsipSetCoordinatorService.isAvailable()) {\n            mCsipSetCoordinatorService.handleBondStateChanged(device, fromState, toState);\n        }\n        mDatabaseManager.handleBondStateChanged(device, fromState, toState);\n\n        if (toState == BOND_NONE) {\n            // Remove the permissions for unbonded devices\n            setMessageAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n            setPhonebookAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n            setSimAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n        }\n    }\n\n    static int convertScanModeToHal(int mode) {\n        switch (mode) {\n            case SCAN_MODE_NONE:\n                return AbstractionLayer.BT_SCAN_MODE_NONE;\n            case SCAN_MODE_CONNECTABLE:\n                return AbstractionLayer.BT_SCAN_MODE_CONNECTABLE;\n            case SCAN_MODE_CONNECTABLE_DISCOVERABLE:\n                return AbstractionLayer.BT_SCAN_MODE_CONNECTABLE_DISCOVERABLE;\n        }\n        return -1;\n    }\n\n    static int convertScanModeFromHal(int mode) {\n        switch (mode) {\n            case AbstractionLayer.BT_SCAN_MODE_NONE:\n                return SCAN_MODE_NONE;\n            case AbstractionLayer.BT_SCAN_MODE_CONNECTABLE:\n                return SCAN_MODE_CONNECTABLE;\n            case AbstractionLayer.BT_SCAN_MODE_CONNECTABLE_DISCOVERABLE:\n                return SCAN_MODE_CONNECTABLE_DISCOVERABLE;\n        }\n        return -1;\n    }\n\n    // This function is called from JNI. It allows native code to acquire a single wake lock.\n    // If the wake lock is already held, this function returns success. Although this function\n    // only supports acquiring a single wake lock at a time right now, it will eventually be\n    // extended to allow acquiring an arbitrary number of wake locks. The current interface\n    // takes |lockName| as a parameter in anticipation of that implementation.\n    boolean acquireWakeLock(String lockName) {\n        synchronized (this) {\n            if (mWakeLock == null) {\n                mWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, lockName);\n            }\n\n            if (!mWakeLock.isHeld()) {\n                mWakeLock.acquire();\n            }\n        }\n        return true;\n    }\n\n    // This function is called from JNI. It allows native code to release a wake lock acquired\n    // by |acquireWakeLock|. If the wake lock is not held, this function returns failure.\n    // Note that the release() call is also invoked by {@link #cleanup()} so a synchronization is\n    // needed here. See the comment for |acquireWakeLock| for an explanation of the interface.\n    boolean releaseWakeLock(String lockName) {\n        synchronized (this) {\n            if (mWakeLock == null) {\n                Log.e(TAG, \"Repeated wake lock release; aborting release: \" + lockName);\n                return false;\n            }\n\n            if (mWakeLock.isHeld()) {\n                mWakeLock.release();\n            }\n        }\n        return true;\n    }\n\n    void energyInfoCallbackInternal(\n            int status,\n            int ctrlState,\n            long txTime,\n            long rxTime,\n            long idleTime,\n            long energyUsed,\n            UidTraffic[] data) {\n        // Energy is product of mA, V and ms. If the chipset doesn't\n        // report it, we have to compute it from time\n        if (energyUsed == 0) {\n            try {\n                final long txMah = Math.multiplyExact(txTime, getTxCurrentMa());\n                final long rxMah = Math.multiplyExact(rxTime, getRxCurrentMa());\n                final long idleMah = Math.multiplyExact(idleTime, getIdleCurrentMa());\n                energyUsed =\n                        (long)\n                                (Math.addExact(Math.addExact(txMah, rxMah), idleMah)\n                                        * getOperatingVolt());\n            } catch (ArithmeticException e) {\n                Log.wtf(TAG, \"overflow in bluetooth energy callback\", e);\n                // Energy is already 0 if the exception was thrown.\n            }\n        }\n\n        synchronized (mEnergyInfoLock) {\n            mStackReportedState = ctrlState;\n            long totalTxTimeMs;\n            long totalRxTimeMs;\n            long totalIdleTimeMs;\n            long totalEnergy;\n            try {\n                totalTxTimeMs = Math.addExact(mTxTimeTotalMs, txTime);\n                totalRxTimeMs = Math.addExact(mRxTimeTotalMs, rxTime);\n                totalIdleTimeMs = Math.addExact(mIdleTimeTotalMs, idleTime);\n                totalEnergy = Math.addExact(mEnergyUsedTotalVoltAmpSecMicro, energyUsed);\n            } catch (ArithmeticException e) {\n                // This could be because we accumulated a lot of time, or we got a very strange\n                // value from the controller (more likely). Discard this data.\n                Log.wtf(TAG, \"overflow in bluetooth energy callback\", e);\n                totalTxTimeMs = mTxTimeTotalMs;\n                totalRxTimeMs = mRxTimeTotalMs;\n                totalIdleTimeMs = mIdleTimeTotalMs;\n                totalEnergy = mEnergyUsedTotalVoltAmpSecMicro;\n            }\n\n            mTxTimeTotalMs = totalTxTimeMs;\n            mRxTimeTotalMs = totalRxTimeMs;\n            mIdleTimeTotalMs = totalIdleTimeMs;\n            mEnergyUsedTotalVoltAmpSecMicro = totalEnergy;\n\n            for (UidTraffic traffic : data) {\n                UidTraffic existingTraffic = mUidTraffic.get(traffic.getUid());\n                if (existingTraffic == null) {\n                    mUidTraffic.put(traffic.getUid(), traffic);\n                } else {\n                    existingTraffic.addRxBytes(traffic.getRxBytes());\n                    existingTraffic.addTxBytes(traffic.getTxBytes());\n                }\n            }\n            mEnergyInfoLock.notifyAll();\n        }\n    }\n\n    void energyInfoCallback(\n            int status,\n            int ctrlState,\n            long txTime,\n            long rxTime,\n            long idleTime,\n            long energyUsed,\n            UidTraffic[] data) {\n        if (Flags.btSystemContextReport()) {\n            energyInfoCallbackInternal(\n                    status, ctrlState, txTime, rxTime, idleTime, energyUsed, data);\n        } else if (ctrlState >= BluetoothActivityEnergyInfo.BT_STACK_STATE_INVALID\n                && ctrlState <= BluetoothActivityEnergyInfo.BT_STACK_STATE_STATE_IDLE) {\n            energyInfoCallbackInternal(\n                    status, ctrlState, txTime, rxTime, idleTime, energyUsed, data);\n        }\n        Log.v(\n                TAG,\n                \"energyInfoCallback()\"\n                        + (\" status = \" + status)\n                        + (\" txTime = \" + txTime)\n                        + (\" rxTime = \" + rxTime)\n                        + (\" idleTime = \" + idleTime)\n                        + (\" energyUsed = \" + energyUsed)\n                        + (\" ctrlState = \" + Utils.formatSimple(\"0x%08x\", ctrlState))\n                        + (\" traffic = \" + Arrays.toString(data)));\n    }\n\n    /** Update metadata change to registered listeners */\n    @VisibleForTesting\n    public void metadataChanged(String address, int key, byte[] value) {\n        BluetoothDevice device = mRemoteDevices.getDevice(Utils.getBytesFromAddress(address));\n\n        // pass just interesting metadata to native, to reduce spam\n        if (key == BluetoothDevice.METADATA_LE_AUDIO) {\n            mNativeInterface.metadataChanged(Utils.getBytesFromAddress(address), key, value);\n        }\n\n        RemoteCallbackList<IBluetoothMetadataListener> list = mMetadataListeners.get(device);\n        if (list == null) {\n            return;\n        }\n        int n = list.beginBroadcast();\n        for (int i = 0; i < n; i++) {\n            try {\n                list.getBroadcastItem(i).onMetadataChanged(device, key, value);\n            } catch (RemoteException e) {\n                Log.d(TAG, \"metadataChanged() - Callback #\" + i + \" failed (\" + e + \")\");\n            }\n        }\n        list.finishBroadcast();\n    }\n\n    private int getIdleCurrentMa() {\n        return BluetoothProperties.getHardwareIdleCurrentMa().orElse(0);\n    }\n\n    private int getTxCurrentMa() {\n        return BluetoothProperties.getHardwareTxCurrentMa().orElse(0);\n    }\n\n    private int getRxCurrentMa() {\n        return BluetoothProperties.getHardwareRxCurrentMa().orElse(0);\n    }\n\n    private double getOperatingVolt() {\n        return BluetoothProperties.getHardwareOperatingVoltageMv().orElse(0) / 1000.0;\n    }\n\n    public RemoteDevices getRemoteDevices() {\n        return mRemoteDevices;\n    }\n\n    private String dumpScanMode(int scanMode) {\n        switch (scanMode) {\n            case SCAN_MODE_NONE:\n                return \"SCAN_MODE_NONE\";\n            case SCAN_MODE_CONNECTABLE:\n                return \"SCAN_MODE_CONNECTABLE\";\n            case SCAN_MODE_CONNECTABLE_DISCOVERABLE:\n                return \"SCAN_MODE_CONNECTABLE_DISCOVERABLE\";\n            default:\n                return \"Unknown Scan Mode \" + scanMode;\n        }\n    }\n\n    @Override\n    protected void dump(FileDescriptor fd, PrintWriter writer, String[] args) {\n        if (args.length == 0) {\n            writer.println(\"Skipping dump in APP SERVICES, see bluetooth_manager section.\");\n            writer.println(\"Use --print argument for dumpsys direct from AdapterService.\");\n            return;\n        }\n\n        if (\"set-test-mode\".equals(args[0])) {\n            final boolean testModeEnabled = \"enabled\".equalsIgnoreCase(args[1]);\n            for (ProfileService profile : mRunningProfiles) {\n                profile.setTestModeEnabled(testModeEnabled);\n            }\n            if (Flags.scanManagerRefactor() && mScanController != null) {\n                mScanController.setTestModeEnabled(testModeEnabled);\n            }\n            mTestModeEnabled = testModeEnabled;\n            return;\n        }\n\n        Log.v(TAG, \"dumpsys arguments, check for protobuf output: \" + TextUtils.join(\" \", args));\n        if (args[0].equals(\"--proto-bin\")) {\n            dumpMetrics(fd);\n            return;\n        }\n\n        writer.println();\n        mAdapterProperties.dump(fd, writer, args);\n\n        writer.println(\"ScanMode: \" + dumpScanMode(getScanMode()));\n        writer.println(\"Scan Mode Changes:\");\n        for (String log : mScanModeChanges) {\n            writer.println(\"    \" + log);\n        }\n        writer.println();\n        writer.println(\"sSnoopLogSettingAtEnable = \" + sSnoopLogSettingAtEnable);\n        writer.println(\"sDefaultSnoopLogSettingAtEnable = \" + sDefaultSnoopLogSettingAtEnable);\n\n        writer.println();\n        writer.println(\"Enabled Profile Services:\");\n        for (int profileId : Config.getSupportedProfiles()) {\n            writer.println(\"  \" + BluetoothProfile.getProfileName(profileId));\n        }\n        writer.println();\n\n        mAdapterStateMachine.dump(fd, writer, args);\n\n        StringBuilder sb = new StringBuilder();\n        for (ProfileService profile : mRegisteredProfiles) {\n            profile.dump(sb);\n        }\n        mSilenceDeviceManager.dump(fd, writer, args);\n        mDatabaseManager.dump(writer);\n\n        writer.write(sb.toString());\n        writer.flush();\n\n        final int currentState = mAdapterProperties.getState();\n        if (currentState == BluetoothAdapter.STATE_OFF\n                || currentState == BluetoothAdapter.STATE_BLE_TURNING_ON\n                || currentState == BluetoothAdapter.STATE_TURNING_OFF\n                || currentState == BluetoothAdapter.STATE_BLE_TURNING_OFF) {\n            writer.println();\n            writer.println(\n                    \"Impossible to dump native stack. state=\"\n                            + BluetoothAdapter.nameForState(currentState));\n            writer.println();\n        } else {\n            mNativeInterface.dump(fd, args);\n        }\n    }\n\n    private void dumpMetrics(FileDescriptor fd) {\n        BluetoothMetricsProto.BluetoothLog.Builder metricsBuilder =\n                BluetoothMetricsProto.BluetoothLog.newBuilder();\n        byte[] nativeMetricsBytes = mNativeInterface.dumpMetrics();\n        Log.d(TAG, \"dumpMetrics: native metrics size is \" + nativeMetricsBytes.length);\n        if (nativeMetricsBytes.length > 0) {\n            try {\n                metricsBuilder.mergeFrom(nativeMetricsBytes);\n            } catch (InvalidProtocolBufferException ex) {\n                Log.w(TAG, \"dumpMetrics: problem parsing metrics protobuf, \" + ex.getMessage());\n                return;\n            }\n        }\n        metricsBuilder.setNumBondedDevices(getBondedDevices().length);\n        MetricsLogger.dumpProto(metricsBuilder);\n        for (ProfileService profile : mRegisteredProfiles) {\n            profile.dumpProto(metricsBuilder);\n        }\n        byte[] metricsBytes = Base64.encode(metricsBuilder.build().toByteArray(), Base64.DEFAULT);\n        Log.d(TAG, \"dumpMetrics: combined metrics size is \" + metricsBytes.length);\n        try (FileOutputStream protoOut = new FileOutputStream(fd)) {\n            protoOut.write(metricsBytes);\n        } catch (IOException e) {\n            Log.e(TAG, \"dumpMetrics: error writing combined protobuf to fd, \" + e.getMessage());\n        }\n    }\n\n    @SuppressLint(\"AndroidFrameworkRequiresPermission\")\n    private void enforceBluetoothPrivilegedPermissionIfNeeded(\n            OobData remoteP192Data, OobData remoteP256Data) {\n        if (remoteP192Data != null || remoteP256Data != null) {\n            this.enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, null);\n        }\n    }\n\n    private final Object mDeviceConfigLock = new Object();\n\n    /**\n     * Predicate that can be applied to names to determine if a device is well-known to be used for\n     * physical location.\n     */\n    @GuardedBy(\"mDeviceConfigLock\")\n    private Predicate<String> mLocationDenylistName = (v) -> false;\n\n    /**\n     * Predicate that can be applied to MAC addresses to determine if a device is well-known to be\n     * used for physical location.\n     */\n    @GuardedBy(\"mDeviceConfigLock\")\n    private Predicate<byte[]> mLocationDenylistMac = (v) -> false;\n\n    /**\n     * Predicate that can be applied to Advertising Data payloads to determine if a device is\n     * well-known to be used for physical location.\n     */\n    @GuardedBy(\"mDeviceConfigLock\")\n    private Predicate<byte[]> mLocationDenylistAdvertisingData = (v) -> false;\n\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScanQuotaCount = DeviceConfigListener.DEFAULT_SCAN_QUOTA_COUNT;\n\n    @GuardedBy(\"mDeviceConfigLock\")\n    private long mScanQuotaWindowMillis = DeviceConfigListener.DEFAULT_SCAN_QUOTA_WINDOW_MILLIS;\n\n    @GuardedBy(\"mDeviceConfigLock\")\n    private long mScanTimeoutMillis = DeviceConfigListener.DEFAULT_SCAN_TIMEOUT_MILLIS;\n\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScanUpgradeDurationMillis =\n            DeviceConfigListener.DEFAULT_SCAN_UPGRADE_DURATION_MILLIS;\n\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScanDowngradeDurationMillis =\n            DeviceConfigListener.DEFAULT_SCAN_DOWNGRADE_DURATION_BT_CONNECTING_MILLIS;\n\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScreenOffLowPowerWindowMillis =\n            ScanManager.SCAN_MODE_SCREEN_OFF_LOW_POWER_WINDOW_MS;\n\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScreenOffLowPowerIntervalMillis =\n            ScanManager.SCAN_MODE_SCREEN_OFF_LOW_POWER_INTERVAL_MS;\n\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScreenOffBalancedWindowMillis =\n            ScanManager.SCAN_MODE_SCREEN_OFF_BALANCED_WINDOW_MS;\n\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScreenOffBalancedIntervalMillis =\n            ScanManager.SCAN_MODE_SCREEN_OFF_BALANCED_INTERVAL_MS;\n\n    @GuardedBy(\"mDeviceConfigLock\")\n    private String mLeAudioAllowList;\n\n    public @NonNull Predicate<String> getLocationDenylistName() {\n        synchronized (mDeviceConfigLock) {\n            return mLocationDenylistName;\n        }\n    }\n\n    public @NonNull Predicate<byte[]> getLocationDenylistMac() {\n        synchronized (mDeviceConfigLock) {\n            return mLocationDenylistMac;\n        }\n    }\n\n    public @NonNull Predicate<byte[]> getLocationDenylistAdvertisingData() {\n        synchronized (mDeviceConfigLock) {\n            return mLocationDenylistAdvertisingData;\n        }\n    }\n\n    /** Returns scan quota count. */\n    public int getScanQuotaCount() {\n        synchronized (mDeviceConfigLock) {\n            return mScanQuotaCount;\n        }\n    }\n\n    /** Returns scan quota window in millis. */\n    public long getScanQuotaWindowMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScanQuotaWindowMillis;\n        }\n    }\n\n    /** Returns scan timeout in millis. */\n    public long getScanTimeoutMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScanTimeoutMillis;\n        }\n    }\n\n    /** Returns scan upgrade duration in millis. */\n    public long getScanUpgradeDurationMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScanUpgradeDurationMillis;\n        }\n    }\n\n    /** Returns scan downgrade duration in millis. */\n    public long getScanDowngradeDurationMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScanDowngradeDurationMillis;\n        }\n    }\n\n    /** Returns SCREEN_OFF_BALANCED scan window in millis. */\n    public int getScreenOffBalancedWindowMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScreenOffBalancedWindowMillis;\n        }\n    }\n\n    /** Returns SCREEN_OFF_BALANCED scan interval in millis. */\n    public int getScreenOffBalancedIntervalMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScreenOffBalancedIntervalMillis;\n        }\n    }\n\n    /** Returns SCREEN_OFF low power scan window in millis. */\n    public int getScreenOffLowPowerWindowMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScreenOffLowPowerWindowMillis;\n        }\n    }\n\n    /** Returns SCREEN_OFF low power scan interval in millis. */\n    public int getScreenOffLowPowerIntervalMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScreenOffLowPowerIntervalMillis;\n        }\n    }\n\n    private class DeviceConfigListener implements DeviceConfig.OnPropertiesChangedListener {\n        private static final String LOCATION_DENYLIST_NAME = \"location_denylist_name\";\n        private static final String LOCATION_DENYLIST_MAC = \"location_denylist_mac\";\n        private static final String LOCATION_DENYLIST_ADVERTISING_DATA =\n                \"location_denylist_advertising_data\";\n        private static final String SCAN_QUOTA_COUNT = \"scan_quota_count\";\n        private static final String SCAN_QUOTA_WINDOW_MILLIS = \"scan_quota_window_millis\";\n        private static final String SCAN_TIMEOUT_MILLIS = \"scan_timeout_millis\";\n        private static final String SCAN_UPGRADE_DURATION_MILLIS = \"scan_upgrade_duration_millis\";\n        private static final String SCAN_DOWNGRADE_DURATION_MILLIS =\n                \"scan_downgrade_duration_millis\";\n        private static final String SCREEN_OFF_LOW_POWER_WINDOW_MILLIS =\n                \"screen_off_low_power_window_millis\";\n        private static final String SCREEN_OFF_LOW_POWER_INTERVAL_MILLIS =\n                \"screen_off_low_power_interval_millis\";\n        private static final String SCREEN_OFF_BALANCED_WINDOW_MILLIS =\n                \"screen_off_balanced_window_millis\";\n        private static final String SCREEN_OFF_BALANCED_INTERVAL_MILLIS =\n                \"screen_off_balanced_interval_millis\";\n        private static final String LE_AUDIO_ALLOW_LIST = \"le_audio_allow_list\";\n\n        /**\n         * Default denylist which matches Eddystone (except for Eddystone-E2EE-EID) and iBeacon\n         * payloads.\n         */\n        private static final String DEFAULT_LOCATION_DENYLIST_ADVERTISING_DATA =\n                \"\u22880016AAFE40/00FFFFFFF0,\u22860016AAFE/00FFFFFF,\u228600FF4C0002/00FFFFFFFF\";\n\n        private static final int DEFAULT_SCAN_QUOTA_COUNT = 5;\n        private static final long DEFAULT_SCAN_QUOTA_WINDOW_MILLIS = 30 * SECOND_IN_MILLIS;\n        private static final long DEFAULT_SCAN_TIMEOUT_MILLIS = 10 * MINUTE_IN_MILLIS;\n        private static final int DEFAULT_SCAN_UPGRADE_DURATION_MILLIS = (int) SECOND_IN_MILLIS * 6;\n        private static final int DEFAULT_SCAN_DOWNGRADE_DURATION_BT_CONNECTING_MILLIS =\n                (int) SECOND_IN_MILLIS * 6;\n\n        public void start() {\n            DeviceConfig.addOnPropertiesChangedListener(\n                    DeviceConfig.NAMESPACE_BLUETOOTH, BackgroundThread.getExecutor(), this);\n            onPropertiesChanged(DeviceConfig.getProperties(DeviceConfig.NAMESPACE_BLUETOOTH));\n        }\n\n        @Override\n        public void onPropertiesChanged(DeviceConfig.Properties properties) {\n            synchronized (mDeviceConfigLock) {\n                final String name = properties.getString(LOCATION_DENYLIST_NAME, null);\n                mLocationDenylistName =\n                        !TextUtils.isEmpty(name)\n                                ? Pattern.compile(name).asPredicate()\n                                : (v) -> false;\n                mLocationDenylistMac =\n                        BytesMatcher.decode(properties.getString(LOCATION_DENYLIST_MAC, null));\n                mLocationDenylistAdvertisingData =\n                        BytesMatcher.decode(\n                                properties.getString(\n                                        LOCATION_DENYLIST_ADVERTISING_DATA,\n                                        DEFAULT_LOCATION_DENYLIST_ADVERTISING_DATA));\n                mScanQuotaCount = properties.getInt(SCAN_QUOTA_COUNT, DEFAULT_SCAN_QUOTA_COUNT);\n                mScanQuotaWindowMillis =\n                        properties.getLong(\n                                SCAN_QUOTA_WINDOW_MILLIS, DEFAULT_SCAN_QUOTA_WINDOW_MILLIS);\n                mScanTimeoutMillis =\n                        properties.getLong(SCAN_TIMEOUT_MILLIS, DEFAULT_SCAN_TIMEOUT_MILLIS);\n                mScanUpgradeDurationMillis =\n                        properties.getInt(\n                                SCAN_UPGRADE_DURATION_MILLIS, DEFAULT_SCAN_UPGRADE_DURATION_MILLIS);\n                mScanDowngradeDurationMillis =\n                        properties.getInt(\n                                SCAN_DOWNGRADE_DURATION_MILLIS,\n                                DEFAULT_SCAN_DOWNGRADE_DURATION_BT_CONNECTING_MILLIS);\n                mScreenOffLowPowerWindowMillis =\n                        properties.getInt(\n                                SCREEN_OFF_LOW_POWER_WINDOW_MILLIS,\n                                ScanManager.SCAN_MODE_SCREEN_OFF_LOW_POWER_WINDOW_MS);\n                mScreenOffLowPowerIntervalMillis =\n                        properties.getInt(\n                                SCREEN_OFF_LOW_POWER_INTERVAL_MILLIS,\n                                ScanManager.SCAN_MODE_SCREEN_OFF_LOW_POWER_INTERVAL_MS);\n                mScreenOffBalancedWindowMillis =\n                        properties.getInt(\n                                SCREEN_OFF_BALANCED_WINDOW_MILLIS,\n                                ScanManager.SCAN_MODE_SCREEN_OFF_BALANCED_WINDOW_MS);\n                mScreenOffBalancedIntervalMillis =\n                        properties.getInt(\n                                SCREEN_OFF_BALANCED_INTERVAL_MILLIS,\n                                ScanManager.SCAN_MODE_SCREEN_OFF_BALANCED_INTERVAL_MS);\n                mLeAudioAllowList = properties.getString(LE_AUDIO_ALLOW_LIST, \"\");\n\n                if (!mLeAudioAllowList.isEmpty()) {\n                    List<String> leAudioAllowlistFromDeviceConfig =\n                            Arrays.asList(mLeAudioAllowList.split(\",\"));\n                    BluetoothProperties.le_audio_allow_list(leAudioAllowlistFromDeviceConfig);\n                }\n\n                List<String> leAudioAllowlistProp = BluetoothProperties.le_audio_allow_list();\n                if (leAudioAllowlistProp != null && !leAudioAllowlistProp.isEmpty()) {\n                    mLeAudioAllowDevices.clear();\n                    mLeAudioAllowDevices.addAll(leAudioAllowlistProp);\n                }\n            }\n        }\n    }\n\n    /** A callback that will be called when AdapterState is changed */\n    public interface BluetoothStateCallback {\n        /**\n         * Called when the status of bluetooth adapter is changing. {@code prevState} and {@code\n         * newState} takes one of following values defined in BluetoothAdapter.java: STATE_OFF,\n         * STATE_TURNING_ON, STATE_ON, STATE_TURNING_OFF, STATE_BLE_TURNING_ON, STATE_BLE_ON,\n         * STATE_BLE_TURNING_OFF\n         *\n         * @param prevState the previous Bluetooth state.\n         * @param newState the new Bluetooth state.\n         */\n        void onBluetoothStateChange(int prevState, int newState);\n    }\n\n    /**\n     * Obfuscate Bluetooth MAC address into a PII free ID string\n     *\n     * @param device Bluetooth device whose MAC address will be obfuscated\n     * @return a byte array that is unique to this MAC address on this device, or empty byte array\n     *     when either device is null or obfuscateAddressNative fails\n     */\n    public byte[] obfuscateAddress(BluetoothDevice device) {\n        if (device == null) {\n            return new byte[0];\n        }\n        return mNativeInterface.obfuscateAddress(Utils.getByteAddress(device));\n    }\n\n    /**\n     * Get dynamic audio buffer size supported type\n     *\n     * @return support\n     *     <p>Possible values are {@link BluetoothA2dp#DYNAMIC_BUFFER_SUPPORT_NONE}, {@link\n     *     BluetoothA2dp#DYNAMIC_BUFFER_SUPPORT_A2DP_OFFLOAD}, {@link\n     *     BluetoothA2dp#DYNAMIC_BUFFER_SUPPORT_A2DP_SOFTWARE_ENCODING}.\n     */\n    public int getDynamicBufferSupport() {\n        return mAdapterProperties.getDynamicBufferSupport();\n    }\n\n    /**\n     * Get dynamic audio buffer size\n     *\n     * @return BufferConstraints\n     */\n    public BufferConstraints getBufferConstraints() {\n        return mAdapterProperties.getBufferConstraints();\n    }\n\n    /**\n     * Set dynamic audio buffer size\n     *\n     * @param codec Audio codec\n     * @param value buffer millis\n     * @return true if the settings is successful, false otherwise\n     */\n    public boolean setBufferLengthMillis(int codec, int value) {\n        return mAdapterProperties.setBufferLengthMillis(codec, value);\n    }\n\n    /**\n     * Get an incremental id of Bluetooth metrics and log\n     *\n     * @param device Bluetooth device\n     * @return int of id for Bluetooth metrics and logging, 0 if the device is invalid\n     */\n    public int getMetricId(BluetoothDevice device) {\n        if (device == null) {\n            return 0;\n        }\n        return mNativeInterface.getMetricId(Utils.getByteAddress(device));\n    }\n\n    public CompanionManager getCompanionManager() {\n        return mBtCompanionManager;\n    }\n\n    /**\n     * Call for the AdapterService receives bond state change\n     *\n     * @param device Bluetooth device\n     * @param state bond state\n     */\n    public void onBondStateChanged(BluetoothDevice device, int state) {\n        if (mBtCompanionManager != null) {\n            mBtCompanionManager.onBondStateChanged(device, state);\n        }\n    }\n\n    /**\n     * Get audio policy feature support status\n     *\n     * @param device Bluetooth device to be checked for audio policy support\n     * @return int status of the remote support for audio policy feature\n     */\n    public int isRequestAudioPolicyAsSinkSupported(BluetoothDevice device) {\n        if (mHeadsetClientService != null) {\n            return mHeadsetClientService.getAudioPolicyRemoteSupported(device);\n        } else {\n            Log.e(TAG, \"No audio transport connected\");\n            return BluetoothStatusCodes.FEATURE_NOT_CONFIGURED;\n        }\n    }\n\n    /**\n     * Set audio policy for remote device\n     *\n     * @param device Bluetooth device to be set policy for\n     * @return int result status for requestAudioPolicyAsSink API\n     */\n    public int requestAudioPolicyAsSink(BluetoothDevice device, BluetoothSinkAudioPolicy policies) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp == null) {\n            return BluetoothStatusCodes.ERROR_DEVICE_NOT_BONDED;\n        }\n\n        if (mHeadsetClientService != null) {\n            if (isRequestAudioPolicyAsSinkSupported(device)\n                    != BluetoothStatusCodes.FEATURE_SUPPORTED) {\n                throw new UnsupportedOperationException(\n                        \"Request Audio Policy As Sink not supported\");\n            }\n            deviceProp.setHfAudioPolicyForRemoteAg(policies);\n            mHeadsetClientService.setAudioPolicy(device, policies);\n            return BluetoothStatusCodes.SUCCESS;\n        } else {\n            Log.e(TAG, \"HeadsetClient not connected\");\n            return BluetoothStatusCodes.ERROR_PROFILE_NOT_CONNECTED;\n        }\n    }\n\n    /**\n     * Get audio policy for remote device\n     *\n     * @param device Bluetooth device to be set policy for\n     * @return {@link BluetoothSinkAudioPolicy} policy stored for the device\n     */\n    public BluetoothSinkAudioPolicy getRequestedAudioPolicyAsSink(BluetoothDevice device) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp == null) {\n            return null;\n        }\n\n        if (mHeadsetClientService != null) {\n            return deviceProp.getHfAudioPolicyForRemoteAg();\n        } else {\n            Log.e(TAG, \"HeadsetClient not connected\");\n            return null;\n        }\n    }\n\n    /**\n     * Allow audio low latency\n     *\n     * @param allowed true if audio low latency is being allowed\n     * @param device device whose audio low latency will be allowed or disallowed\n     * @return boolean true if audio low latency is successfully allowed or disallowed\n     */\n    public boolean allowLowLatencyAudio(boolean allowed, BluetoothDevice device) {\n        return mNativeInterface.allowLowLatencyAudio(allowed, Utils.getByteAddress(device));\n    }\n\n    /**\n     * get remote PBAP PCE version.\n     *\n     * @param address of remote device\n     * @return int value other than 0 if remote PBAP PCE version is found\n     */\n    public int getRemotePbapPceVersion(String address) {\n        return mNativeInterface.getRemotePbapPceVersion(address);\n    }\n\n    /**\n     * check, if PBAP PSE dynamic version upgrade is enabled.\n     *\n     * @return true/false.\n     */\n    public boolean pbapPseDynamicVersionUpgradeIsEnabled() {\n        return mNativeInterface.pbapPseDynamicVersionUpgradeIsEnabled();\n    }\n\n    /** Sets the battery level of the remote device */\n    public void setBatteryLevel(BluetoothDevice device, int batteryLevel, boolean isBas) {\n        if (batteryLevel == BATTERY_LEVEL_UNKNOWN) {\n            mRemoteDevices.resetBatteryLevel(device, isBas);\n        } else {\n            mRemoteDevices.updateBatteryLevel(device, batteryLevel, isBas);\n        }\n    }\n\n    public boolean interopMatchAddr(InteropFeature feature, String address) {\n        return mNativeInterface.interopMatchAddr(feature.name(), address);\n    }\n\n    public boolean interopMatchName(InteropFeature feature, String name) {\n        return mNativeInterface.interopMatchName(feature.name(), name);\n    }\n\n    public boolean interopMatchAddrOrName(InteropFeature feature, String address) {\n        return mNativeInterface.interopMatchAddrOrName(feature.name(), address);\n    }\n\n    public void interopDatabaseAddAddr(InteropFeature feature, String address, int length) {\n        mNativeInterface.interopDatabaseAddRemoveAddr(true, feature.name(), address, length);\n    }\n\n    public void interopDatabaseRemoveAddr(InteropFeature feature, String address) {\n        mNativeInterface.interopDatabaseAddRemoveAddr(false, feature.name(), address, 0);\n    }\n\n    public void interopDatabaseAddName(InteropFeature feature, String name) {\n        mNativeInterface.interopDatabaseAddRemoveName(true, feature.name(), name);\n    }\n\n    public void interopDatabaseRemoveName(InteropFeature feature, String name) {\n        mNativeInterface.interopDatabaseAddRemoveName(false, feature.name(), name);\n    }\n\n    /**\n     * Checks the remote device is in the LE Audio allow list or not.\n     *\n     * @param device the device to check\n     * @return boolean true if the device is in the allow list, false otherwise.\n     */\n    public boolean isLeAudioAllowed(BluetoothDevice device) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n\n        if (deviceProp == null\n                || deviceProp.getModelName() == null\n                || !mLeAudioAllowDevices.contains(deviceProp.getModelName())) {\n\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Get type of the remote device\n     *\n     * @param device the device to check\n     * @return int device type\n     */\n    public int getRemoteType(BluetoothDevice device) {\n        return mRemoteDevices.getType(device);\n    }\n\n    /**\n     * Sends service discovery UUIDs internally within the stack. This is meant to remove internal\n     * dependencies on the broadcast {@link BluetoothDevice#ACTION_UUID}.\n     *\n     * @param device is the remote device whose UUIDs have been discovered\n     * @param uuids are the services supported on the remote device\n     */\n    void sendUuidsInternal(BluetoothDevice device, ParcelUuid[] uuids) {\n        if (device == null) {\n            Log.w(TAG, \"sendUuidsInternal: null device\");\n            return;\n        }\n        if (uuids == null) {\n            Log.w(TAG, \"sendUuidsInternal: uuids is null\");\n            return;\n        }\n        Log.i(TAG, \"sendUuidsInternal: Received service discovery UUIDs for device \" + device);\n        for (int i = 0; i < uuids.length; i++) {\n            Log.d(TAG, \"sendUuidsInternal: index=\" + i + \" uuid=\" + uuids[i]);\n        }\n        if (mPhonePolicy != null) {\n            mPhonePolicy.onUuidsDiscovered(device, uuids);\n        }\n    }\n}\n```",
                        "downstream_file_content": "```java\n/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.bluetooth.btservice;\n\nimport static android.bluetooth.BluetoothDevice.TRANSPORT_AUTO;\nimport static android.text.format.DateUtils.MINUTE_IN_MILLIS;\nimport static android.text.format.DateUtils.SECOND_IN_MILLIS;\n\nimport static com.android.bluetooth.Utils.callerIsSystemOrActiveOrManagedUser;\nimport static com.android.bluetooth.Utils.callerIsSystemOrActiveUser;\nimport static com.android.bluetooth.Utils.enforceBluetoothPrivilegedPermission;\nimport static com.android.bluetooth.Utils.enforceCdmAssociation;\nimport static com.android.bluetooth.Utils.enforceDumpPermission;\nimport static com.android.bluetooth.Utils.enforceLocalMacAddressPermission;\nimport static com.android.bluetooth.Utils.getBytesFromAddress;\nimport static com.android.bluetooth.Utils.hasBluetoothPrivilegedPermission;\nimport static com.android.bluetooth.Utils.isPackageNameAccurate;\n\nimport android.annotation.NonNull;\nimport android.annotation.RequiresPermission;\nimport android.annotation.SuppressLint;\nimport android.app.AlarmManager;\nimport android.app.AppOpsManager;\nimport android.app.PendingIntent;\nimport android.app.Service;\nimport android.app.admin.DevicePolicyManager;\nimport android.bluetooth.BluetoothA2dp;\nimport android.bluetooth.BluetoothActivityEnergyInfo;\nimport android.bluetooth.BluetoothAdapter;\nimport android.bluetooth.BluetoothAdapter.ActiveDeviceProfile;\nimport android.bluetooth.BluetoothAdapter.ActiveDeviceUse;\nimport android.bluetooth.BluetoothClass;\nimport android.bluetooth.BluetoothDevice;\nimport android.bluetooth.BluetoothFrameworkInitializer;\nimport android.bluetooth.BluetoothMap;\nimport android.bluetooth.BluetoothProfile;\nimport android.bluetooth.BluetoothProtoEnums;\nimport android.bluetooth.BluetoothSap;\nimport android.bluetooth.BluetoothServerSocket;\nimport android.bluetooth.BluetoothSocket;\nimport android.bluetooth.BluetoothStatusCodes;\nimport android.bluetooth.BluetoothUuid;\nimport android.bluetooth.BufferConstraints;\nimport android.bluetooth.IBluetooth;\nimport android.bluetooth.IBluetoothActivityEnergyInfoListener;\nimport android.bluetooth.IBluetoothCallback;\nimport android.bluetooth.IBluetoothConnectionCallback;\nimport android.bluetooth.IBluetoothMetadataListener;\nimport android.bluetooth.IBluetoothOobDataCallback;\nimport android.bluetooth.IBluetoothSocketManager;\nimport android.bluetooth.IncomingRfcommSocketInfo;\nimport android.bluetooth.OobData;\nimport android.bluetooth.UidTraffic;\nimport android.companion.CompanionDeviceManager;\nimport android.content.AttributionSource;\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.SharedPreferences;\nimport android.content.pm.PackageManager;\nimport android.os.AsyncTask;\nimport android.os.BatteryStatsManager;\nimport android.os.Binder;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.ParcelUuid;\nimport android.os.PowerManager;\nimport android.os.RemoteCallbackList;\nimport android.os.RemoteException;\nimport android.os.SystemClock;\nimport android.os.SystemProperties;\nimport android.os.UserHandle;\nimport android.os.UserManager;\nimport android.provider.DeviceConfig;\nimport android.provider.Settings;\nimport android.sysprop.BluetoothProperties;\nimport android.text.TextUtils;\nimport android.util.Base64;\nimport android.util.Log;\nimport android.util.SparseArray;\n\nimport com.android.bluetooth.BluetoothMetricsProto;\nimport com.android.bluetooth.BluetoothStatsLog;\nimport com.android.bluetooth.R;\nimport com.android.bluetooth.Utils;\nimport com.android.bluetooth.a2dp.A2dpService;\nimport com.android.bluetooth.a2dpsink.A2dpSinkService;\nimport com.android.bluetooth.bas.BatteryService;\nimport com.android.bluetooth.bass_client.BassClientService;\nimport com.android.bluetooth.btservice.RemoteDevices.DeviceProperties;\nimport com.android.bluetooth.btservice.activityattribution.ActivityAttributionService;\nimport com.android.bluetooth.btservice.bluetoothkeystore.BluetoothKeystoreService;\nimport com.android.bluetooth.btservice.storage.DatabaseManager;\nimport com.android.bluetooth.btservice.storage.MetadataDatabase;\nimport com.android.bluetooth.csip.CsipSetCoordinatorService;\nimport com.android.bluetooth.gatt.GattService;\nimport com.android.bluetooth.gatt.ScanManager;\nimport com.android.bluetooth.hap.HapClientService;\nimport com.android.bluetooth.hearingaid.HearingAidService;\nimport com.android.bluetooth.hfp.HeadsetService;\nimport com.android.bluetooth.hfpclient.HeadsetClientService;\nimport com.android.bluetooth.hid.HidDeviceService;\nimport com.android.bluetooth.hid.HidHostService;\nimport com.android.bluetooth.le_audio.LeAudioService;\nimport com.android.bluetooth.map.BluetoothMapService;\nimport com.android.bluetooth.mapclient.MapClientService;\nimport com.android.bluetooth.pan.PanService;\nimport com.android.bluetooth.pbap.BluetoothPbapService;\nimport com.android.bluetooth.pbapclient.PbapClientService;\nimport com.android.bluetooth.sap.SapService;\nimport com.android.bluetooth.sdp.SdpManager;\nimport com.android.bluetooth.telephony.BluetoothInCallService;\nimport com.android.bluetooth.vc.VolumeControlService;\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.modules.utils.BackgroundThread;\nimport com.android.modules.utils.BytesMatcher;\nimport com.android.modules.utils.SynchronousResultReceiver;\n\nimport com.google.protobuf.InvalidProtocolBufferException;\n\nimport libcore.util.SneakyThrow;\n\nimport java.io.FileDescriptor;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.time.Duration;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.Executor;\nimport java.util.function.Predicate;\nimport java.util.regex.Pattern;\n\npublic class AdapterService extends Service {\n    private static final String TAG = \"BluetoothAdapterService\";\n    private static final boolean DBG = true;\n    private static final boolean VERBOSE = false;\n    private static final int MIN_ADVT_INSTANCES_FOR_MA = 5;\n    private static final int MIN_OFFLOADED_FILTERS = 10;\n    private static final int MIN_OFFLOADED_SCAN_STORAGE_BYTES = 1024;\n    private static final Duration PENDING_SOCKET_HANDOFF_TIMEOUT = Duration.ofMinutes(1);\n\n    private final Object mEnergyInfoLock = new Object();\n    private int mStackReportedState;\n    private long mTxTimeTotalMs;\n    private long mRxTimeTotalMs;\n    private long mIdleTimeTotalMs;\n    private long mEnergyUsedTotalVoltAmpSecMicro;\n    private final SparseArray<UidTraffic> mUidTraffic = new SparseArray<>();\n\n    private final ArrayList<String> mStartedProfiles = new ArrayList<>();\n    private final ArrayList<ProfileService> mRegisteredProfiles = new ArrayList<>();\n    private final ArrayList<ProfileService> mRunningProfiles = new ArrayList<>();\n\n    public static final String ACTION_LOAD_ADAPTER_PROPERTIES =\n            \"com.android.bluetooth.btservice.action.LOAD_ADAPTER_PROPERTIES\";\n    public static final String ACTION_SERVICE_STATE_CHANGED =\n            \"com.android.bluetooth.btservice.action.STATE_CHANGED\";\n    public static final String EXTRA_ACTION = \"action\";\n    public static final int PROFILE_CONN_REJECTED = 2;\n\n    private static final String ACTION_ALARM_WAKEUP =\n            \"com.android.bluetooth.btservice.action.ALARM_WAKEUP\";\n\n    static final String BLUETOOTH_BTSNOOP_LOG_MODE_PROPERTY = \"persist.bluetooth.btsnooplogmode\";\n    static final String BLUETOOTH_BTSNOOP_DEFAULT_MODE_PROPERTY =\n            \"persist.bluetooth.btsnoopdefaultmode\";\n    private String mSnoopLogSettingAtEnable = \"empty\";\n    private String mDefaultSnoopLogSettingAtEnable = \"empty\";\n\n    public static final String BLUETOOTH_PRIVILEGED =\n            android.Manifest.permission.BLUETOOTH_PRIVILEGED;\n    static final String BLUETOOTH_PERM = android.Manifest.permission.BLUETOOTH;\n    static final String LOCAL_MAC_ADDRESS_PERM = android.Manifest.permission.LOCAL_MAC_ADDRESS;\n    static final String RECEIVE_MAP_PERM = android.Manifest.permission.RECEIVE_BLUETOOTH_MAP;\n\n    private static final String PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE =\n            \"phonebook_access_permission\";\n    private static final String MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE =\n            \"message_access_permission\";\n    private static final String SIM_ACCESS_PERMISSION_PREFERENCE_FILE = \"sim_access_permission\";\n\n    private static final int CONTROLLER_ENERGY_UPDATE_TIMEOUT_MILLIS = 30;\n\n    public static final String ACTIVITY_ATTRIBUTION_NO_ACTIVE_DEVICE_ADDRESS =\n            \"no_active_device_address\";\n\n    // Report ID definition\n    public enum BqrQualityReportId {\n        QUALITY_REPORT_ID_MONITOR_MODE(0x01),\n        QUALITY_REPORT_ID_APPROACH_LSTO(0x02),\n        QUALITY_REPORT_ID_A2DP_AUDIO_CHOPPY(0x03),\n        QUALITY_REPORT_ID_SCO_VOICE_CHOPPY(0x04),\n        QUALITY_REPORT_ID_ROOT_INFLAMMATION(0x05),\n        QUALITY_REPORT_ID_LMP_LL_MESSAGE_TRACE(0x11),\n        QUALITY_REPORT_ID_BT_SCHEDULING_TRACE(0x12),\n        QUALITY_REPORT_ID_CONTROLLER_DBG_INFO(0x13);\n\n        private final int value;\n        private BqrQualityReportId(int value) {\n            this.value = value;\n        }\n        public int getValue() {\n            return value;\n        }\n    };\n\n    private final ArrayList<DiscoveringPackage> mDiscoveringPackages = new ArrayList<>();\n\n    static {\n        classInitNative();\n    }\n\n    private static AdapterService sAdapterService;\n\n    public static synchronized AdapterService getAdapterService() {\n        return sAdapterService;\n    }\n\n    private static synchronized void setAdapterService(AdapterService instance) {\n        Log.d(TAG, \"setAdapterService() - trying to set service to \" + instance);\n        if (instance == null) {\n            return;\n        }\n        sAdapterService = instance;\n    }\n\n    private static synchronized void clearAdapterService(AdapterService current) {\n        if (sAdapterService == current) {\n            sAdapterService = null;\n        }\n    }\n\n    private BluetoothAdapter mAdapter;\n    private AdapterProperties mAdapterProperties;\n    private AdapterState mAdapterStateMachine;\n    private BondStateMachine mBondStateMachine;\n    private JniCallbacks mJniCallbacks;\n    private RemoteDevices mRemoteDevices;\n\n    /* TODO: Consider to remove the search API from this class, if changed to use call-back */\n    private SdpManager mSdpManager = null;\n\n    private boolean mNativeAvailable;\n    private boolean mCleaningUp;\n    private final HashMap<BluetoothDevice, ArrayList<IBluetoothMetadataListener>>\n            mMetadataListeners = new HashMap<>();\n    private final HashMap<String, Integer> mProfileServicesState = new HashMap<String, Integer>();\n    private Set<IBluetoothConnectionCallback> mBluetoothConnectionCallbacks = new HashSet<>();\n    //Only BluetoothManagerService should be registered\n    private RemoteCallbackList<IBluetoothCallback> mCallbacks;\n    private int mCurrentRequestId;\n    private boolean mQuietmode = false;\n    private HashMap<String, CallerInfo> mBondAttemptCallerInfo = new HashMap<>();\n\n    private final Map<UUID, RfcommListenerData> mBluetoothServerSockets = new ConcurrentHashMap<>();\n    private final Executor mSocketServersExecutor = r -> new Thread(r).start();\n\n    private AlarmManager mAlarmManager;\n    private PendingIntent mPendingAlarm;\n    private BatteryStatsManager mBatteryStatsManager;\n    private PowerManager mPowerManager;\n    private PowerManager.WakeLock mWakeLock;\n    private String mWakeLockName;\n    private UserManager mUserManager;\n    private CompanionDeviceManager mCompanionDeviceManager;\n\n    private PhonePolicy mPhonePolicy;\n    private ActiveDeviceManager mActiveDeviceManager;\n    private DatabaseManager mDatabaseManager;\n    private SilenceDeviceManager mSilenceDeviceManager;\n    private AppOpsManager mAppOps;\n\n    private BluetoothSocketManagerBinder mBluetoothSocketManagerBinder;\n\n    private BluetoothKeystoreService mBluetoothKeystoreService;\n    private A2dpService mA2dpService;\n    private A2dpSinkService mA2dpSinkService;\n    private ActivityAttributionService mActivityAttributionService;\n    private HeadsetService mHeadsetService;\n    private HeadsetClientService mHeadsetClientService;\n    private BluetoothMapService mMapService;\n    private MapClientService mMapClientService;\n    private HidDeviceService mHidDeviceService;\n    private HidHostService mHidHostService;\n    private PanService mPanService;\n    private BluetoothPbapService mPbapService;\n    private PbapClientService mPbapClientService;\n    private HearingAidService mHearingAidService;\n    private HapClientService mHapClientService;\n    private SapService mSapService;\n    private VolumeControlService mVolumeControlService;\n    private CsipSetCoordinatorService mCsipSetCoordinatorService;\n    private LeAudioService mLeAudioService;\n    private BassClientService mBassClientService;\n    private BatteryService mBatteryService;\n\n    private volatile boolean mTestModeEnabled = false;\n\n    private MetricsLogger mMetricsLogger;\n\n    /**\n     * Register a {@link ProfileService} with AdapterService.\n     *\n     * @param profile the service being added.\n     */\n    public void addProfile(ProfileService profile) {\n        mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_REGISTERED, profile).sendToTarget();\n    }\n\n    /**\n     * Unregister a ProfileService with AdapterService.\n     *\n     * @param profile the service being removed.\n     */\n    public void removeProfile(ProfileService profile) {\n        mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_UNREGISTERED, profile).sendToTarget();\n    }\n\n    /**\n     * Notify AdapterService that a ProfileService has started or stopped.\n     *\n     * @param profile the service being removed.\n     * @param state {@link BluetoothAdapter#STATE_ON} or {@link BluetoothAdapter#STATE_OFF}\n     */\n    public void onProfileServiceStateChanged(ProfileService profile, int state) {\n        if (state != BluetoothAdapter.STATE_ON && state != BluetoothAdapter.STATE_OFF) {\n            throw new IllegalArgumentException(BluetoothAdapter.nameForState(state));\n        }\n        Message m = mHandler.obtainMessage(MESSAGE_PROFILE_SERVICE_STATE_CHANGED);\n        m.obj = profile;\n        m.arg1 = state;\n        mHandler.sendMessage(m);\n    }\n\n    /**\n     * Confirm whether the ProfileService is started expectedly.\n     *\n     * @param serviceSampleName the service simple name.\n     * @return true if the service is started expectedly, false otherwise.\n     */\n    public boolean isStartedProfile(String serviceSampleName) {\n        return mStartedProfiles.contains(serviceSampleName);\n    }\n\n    private static final int MESSAGE_PROFILE_SERVICE_STATE_CHANGED = 1;\n    private static final int MESSAGE_PROFILE_SERVICE_REGISTERED = 2;\n    private static final int MESSAGE_PROFILE_SERVICE_UNREGISTERED = 3;\n\n    class AdapterServiceHandler extends Handler {\n        @Override\n        public void handleMessage(Message msg) {\n            verboseLog(\"handleMessage() - Message: \" + msg.what);\n\n            switch (msg.what) {\n                case MESSAGE_PROFILE_SERVICE_STATE_CHANGED:\n                    verboseLog(\"handleMessage() - MESSAGE_PROFILE_SERVICE_STATE_CHANGED\");\n                    processProfileServiceStateChanged((ProfileService) msg.obj, msg.arg1);\n                    break;\n                case MESSAGE_PROFILE_SERVICE_REGISTERED:\n                    verboseLog(\"handleMessage() - MESSAGE_PROFILE_SERVICE_REGISTERED\");\n                    registerProfileService((ProfileService) msg.obj);\n                    break;\n                case MESSAGE_PROFILE_SERVICE_UNREGISTERED:\n                    verboseLog(\"handleMessage() - MESSAGE_PROFILE_SERVICE_UNREGISTERED\");\n                    unregisterProfileService((ProfileService) msg.obj);\n                    break;\n            }\n        }\n\n        private void registerProfileService(ProfileService profile) {\n            if (mRegisteredProfiles.contains(profile)) {\n                Log.e(TAG, profile.getName() + \" already registered.\");\n                return;\n            }\n            mRegisteredProfiles.add(profile);\n        }\n\n        private void unregisterProfileService(ProfileService profile) {\n            if (!mRegisteredProfiles.contains(profile)) {\n                Log.e(TAG, profile.getName() + \" not registered (UNREGISTER).\");\n                return;\n            }\n            mRegisteredProfiles.remove(profile);\n        }\n\n        private void processProfileServiceStateChanged(ProfileService profile, int state) {\n            switch (state) {\n                case BluetoothAdapter.STATE_ON:\n                    if (!mRegisteredProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" not registered (STATE_ON).\");\n                        return;\n                    }\n                    if (mRunningProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" already running.\");\n                        return;\n                    }\n                    mRunningProfiles.add(profile);\n                    // TODO(b/228875190): GATT is assumed supported. GATT starting triggers hardware\n                    // initializtion. Configuring a device without GATT causes start up failures.\n                    if (GattService.class.getSimpleName().equals(profile.getName())) {\n                        enableNative();\n                    } else if (mRegisteredProfiles.size() == Config.getSupportedProfiles().length\n                            && mRegisteredProfiles.size() == mRunningProfiles.size()) {\n                        mAdapterProperties.onBluetoothReady();\n                        updateUuids();\n                        setBluetoothClassFromConfig();\n                        initProfileServices();\n                        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_LOCAL_IO_CAPS);\n                        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_LOCAL_IO_CAPS_BLE);\n                        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_DYNAMIC_AUDIO_BUFFER);\n                        mAdapterStateMachine.sendMessage(AdapterState.BREDR_STARTED);\n                    }\n                    break;\n                case BluetoothAdapter.STATE_OFF:\n                    if (!mRegisteredProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" not registered (STATE_OFF).\");\n                        return;\n                    }\n                    if (!mRunningProfiles.contains(profile)) {\n                        Log.e(TAG, profile.getName() + \" not running.\");\n                        return;\n                    }\n                    mRunningProfiles.remove(profile);\n                    // TODO(b/228875190): GATT is assumed supported. GATT is expected to be the only\n                    // profile available in the \"BLE ON\" state. If only GATT is left, send\n                    // BREDR_STOPPED. If GATT is stopped, deinitialize the hardware.\n                    if ((mRunningProfiles.size() == 1 && (GattService.class.getSimpleName()\n                            .equals(mRunningProfiles.get(0).getName())))) {\n                        mAdapterStateMachine.sendMessage(AdapterState.BREDR_STOPPED);\n                    } else if (mRunningProfiles.size() == 0) {\n                        disableNative();\n                    }\n                    break;\n                default:\n                    Log.e(TAG, \"Unhandled profile state: \" + state);\n            }\n        }\n    }\n\n    private final AdapterServiceHandler mHandler = new AdapterServiceHandler();\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        initMetricsLogger();\n        debugLog(\"onCreate()\");\n        mDeviceConfigListener.start();\n        mRemoteDevices = new RemoteDevices(this, Looper.getMainLooper());\n        mRemoteDevices.init();\n        clearDiscoveringPackages();\n        mBinder = new AdapterServiceBinder(this);\n        mAdapter = BluetoothAdapter.getDefaultAdapter();\n        mAdapterProperties = new AdapterProperties(this);\n        mAdapterStateMachine = AdapterState.make(this);\n        mJniCallbacks = new JniCallbacks(this, mAdapterProperties);\n        mBluetoothKeystoreService = new BluetoothKeystoreService(isCommonCriteriaMode());\n        mBluetoothKeystoreService.start();\n        int configCompareResult = mBluetoothKeystoreService.getCompareResult();\n\n        // Start tracking Binder latency for the bluetooth process.\n        BluetoothFrameworkInitializer.initializeBinderCallsStats(getApplicationContext());\n\n        // Android TV doesn't show consent dialogs for just works and encryption only le pairing\n        boolean isAtvDevice = getApplicationContext().getPackageManager().hasSystemFeature(\n                PackageManager.FEATURE_LEANBACK_ONLY);\n        mUserManager = getSystemService(UserManager.class);\n        initNative(mUserManager.isGuestUser(), isCommonCriteriaMode(), configCompareResult,\n                getInitFlags(), isAtvDevice, getApplicationInfo().dataDir);\n        mNativeAvailable = true;\n        mCallbacks = new RemoteCallbackList<IBluetoothCallback>();\n        mAppOps = getSystemService(AppOpsManager.class);\n        //Load the name and address\n        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_BDADDR);\n        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_BDNAME);\n        getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_CLASS_OF_DEVICE);\n        mAlarmManager = getSystemService(AlarmManager.class);\n        mPowerManager = getSystemService(PowerManager.class);\n        mBatteryStatsManager = getSystemService(BatteryStatsManager.class);\n        mCompanionDeviceManager = getSystemService(CompanionDeviceManager.class);\n\n        mBluetoothKeystoreService.initJni();\n\n        mSdpManager = SdpManager.init(this);\n        registerReceiver(mAlarmBroadcastReceiver, new IntentFilter(ACTION_ALARM_WAKEUP));\n\n        mDatabaseManager = new DatabaseManager(this);\n        mDatabaseManager.start(MetadataDatabase.createDatabase(this));\n\n        boolean isAutomotiveDevice = getApplicationContext().getPackageManager().hasSystemFeature(\n                PackageManager.FEATURE_AUTOMOTIVE);\n\n        /*\n         * Phone policy is specific to phone implementations and hence if a device wants to exclude\n         * it out then it can be disabled by using the flag below. Phone policy is never used on\n         * Android Automotive OS builds, in favor of a policy currently located in\n         * CarBluetoothService.\n         */\n        if (!isAutomotiveDevice && getResources().getBoolean(R.bool.enable_phone_policy)) {\n            Log.i(TAG, \"Phone policy enabled\");\n            mPhonePolicy = new PhonePolicy(this, new ServiceFactory());\n            mPhonePolicy.start();\n        } else {\n            Log.i(TAG, \"Phone policy disabled\");\n        }\n\n        mActiveDeviceManager = new ActiveDeviceManager(this, new ServiceFactory());\n        mActiveDeviceManager.start();\n\n        mSilenceDeviceManager = new SilenceDeviceManager(this, new ServiceFactory(),\n                Looper.getMainLooper());\n        mSilenceDeviceManager.start();\n\n        mBluetoothSocketManagerBinder = new BluetoothSocketManagerBinder(this);\n\n        mActivityAttributionService = new ActivityAttributionService();\n        mActivityAttributionService.start();\n\n        setAdapterService(this);\n\n        invalidateBluetoothCaches();\n\n        // First call to getSharedPreferences will result in a file read into\n        // memory cache. Call it here asynchronously to avoid potential ANR\n        // in the future\n        new AsyncTask<Void, Void, Void>() {\n            @Override\n            protected Void doInBackground(Void... params) {\n                getSharedPreferences(PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE,\n                        Context.MODE_PRIVATE);\n                getSharedPreferences(MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE,\n                        Context.MODE_PRIVATE);\n                getSharedPreferences(SIM_ACCESS_PERMISSION_PREFERENCE_FILE, Context.MODE_PRIVATE);\n                return null;\n            }\n        }.execute();\n\n        try {\n            int systemUiUid = getApplicationContext()\n                    .createContextAsUser(UserHandle.SYSTEM, /* flags= */ 0)\n                    .getPackageManager()\n                    .getPackageUid(\"com.android.systemui\", PackageManager.MATCH_SYSTEM_ONLY);\n\n            Utils.setSystemUiUid(systemUiUid);\n        } catch (PackageManager.NameNotFoundException e) {\n            // Some platforms, such as wearables do not have a system ui.\n            Log.w(TAG, \"Unable to resolve SystemUI's UID.\", e);\n        }\n    }\n\n    @Override\n    public IBinder onBind(Intent intent) {\n        debugLog(\"onBind()\");\n        return mBinder;\n    }\n\n    @Override\n    public boolean onUnbind(Intent intent) {\n        debugLog(\"onUnbind() - calling cleanup\");\n        cleanup();\n        return super.onUnbind(intent);\n    }\n\n    @Override\n    public void onDestroy() {\n        debugLog(\"onDestroy()\");\n        if (!isMock()) {\n            // TODO(b/27859763)\n            Log.i(TAG, \"Force exit to cleanup internal state in Bluetooth stack\");\n            System.exit(0);\n        }\n    }\n\n    private boolean initMetricsLogger() {\n        if (mMetricsLogger != null) {\n            return false;\n        }\n        mMetricsLogger = MetricsLogger.getInstance();\n        return mMetricsLogger.init(this);\n    }\n\n    private boolean closeMetricsLogger() {\n        if (mMetricsLogger == null) {\n            return false;\n        }\n        boolean result = mMetricsLogger.close();\n        mMetricsLogger = null;\n        return result;\n    }\n\n    public void setMetricsLogger(MetricsLogger metricsLogger) {\n        mMetricsLogger = metricsLogger;\n    }\n\n    void bringUpBle() {\n        debugLog(\"bleOnProcessStart()\");\n\n        if (getResources().getBoolean(\n                R.bool.config_bluetooth_reload_supported_profiles_when_enabled)) {\n            Config.init(getApplicationContext());\n        }\n\n        // Reset |mRemoteDevices| whenever BLE is turned off then on\n        // This is to replace the fact that |mRemoteDevices| was\n        // reinitialized in previous code.\n        //\n        // TODO(apanicke): The reason is unclear but\n        // I believe it is to clear the variable every time BLE was\n        // turned off then on. The same effect can be achieved by\n        // calling cleanup but this may not be necessary at all\n        // We should figure out why this is needed later\n        mRemoteDevices.reset();\n        mAdapterProperties.init(mRemoteDevices);\n\n        debugLog(\"bleOnProcessStart() - Make Bond State Machine\");\n        mBondStateMachine = BondStateMachine.make(this, mAdapterProperties, mRemoteDevices);\n\n        mJniCallbacks.init(mBondStateMachine, mRemoteDevices);\n\n        mBatteryStatsManager.reportBleScanReset();\n        BluetoothStatsLog.write_non_chained(BluetoothStatsLog.BLE_SCAN_STATE_CHANGED, -1, null,\n                BluetoothStatsLog.BLE_SCAN_STATE_CHANGED__STATE__RESET, false, false, false);\n\n        // TODO(b/228875190): GATT is assumed supported. As a result, we don't respect the\n        // configuration sysprop. Configuring a device without GATT, although rare, will cause stack\n        // start up errors yielding init loops.\n        if (!GattService.isEnabled()) {\n            Log.w(TAG,\n                    \"GATT is configured off but the stack assumes it to be enabled. Start anyway.\");\n        }\n        setProfileServiceState(GattService.class, BluetoothAdapter.STATE_ON);\n    }\n\n    void bringDownBle() {\n        stopGattProfileService();\n    }\n\n    void stateChangeCallback(int status) {\n        if (status == AbstractionLayer.BT_STATE_OFF) {\n            debugLog(\"stateChangeCallback: disableNative() completed\");\n            mAdapterStateMachine.sendMessage(AdapterState.BLE_STOPPED);\n        } else if (status == AbstractionLayer.BT_STATE_ON) {\n            mAdapterStateMachine.sendMessage(AdapterState.BLE_STARTED);\n        } else {\n            Log.e(TAG, \"Incorrect status \" + status + \" in stateChangeCallback\");\n        }\n    }\n\n    /**\n     * Sets the Bluetooth CoD value of the local adapter if there exists a config value for it.\n     */\n    void setBluetoothClassFromConfig() {\n        int bluetoothClassConfig = retrieveBluetoothClassConfig();\n        if (bluetoothClassConfig != 0) {\n            mAdapterProperties.setBluetoothClass(new BluetoothClass(bluetoothClassConfig));\n        }\n    }\n\n    private int retrieveBluetoothClassConfig() {\n        return Settings.Global.getInt(\n                getContentResolver(), Settings.Global.BLUETOOTH_CLASS_OF_DEVICE, 0);\n    }\n\n    void startProfileServices() {\n        debugLog(\"startCoreServices()\");\n        Class[] supportedProfileServices = Config.getSupportedProfiles();\n        // TODO(b/228875190): GATT is assumed supported. If we support no other profiles then just\n        // move on to BREDR_STARTED. Note that configuring GATT to NOT supported will cause adapter\n        // initialization failures\n        if (supportedProfileServices.length == 1 && GattService.class.getSimpleName()\n                .equals(supportedProfileServices[0].getSimpleName())) {\n            mAdapterProperties.onBluetoothReady();\n            updateUuids();\n            setBluetoothClassFromConfig();\n            mAdapterStateMachine.sendMessage(AdapterState.BREDR_STARTED);\n        } else {\n            setAllProfileServiceStates(supportedProfileServices, BluetoothAdapter.STATE_ON);\n        }\n    }\n\n    void stopProfileServices() {\n        // Make sure to stop classic background tasks now\n        cancelDiscoveryNative();\n        mAdapterProperties.setScanMode(AbstractionLayer.BT_SCAN_MODE_NONE);\n\n        Class[] supportedProfileServices = Config.getSupportedProfiles();\n        // TODO(b/228875190): GATT is assumed supported. If we support no profiles then just move on\n        // to BREDR_STOPPED\n        if (supportedProfileServices.length == 1 && (mRunningProfiles.size() == 1\n                && GattService.class.getSimpleName().equals(mRunningProfiles.get(0).getName()))) {\n            debugLog(\"stopProfileServices() - No profiles services to stop or already stopped.\");\n            mAdapterStateMachine.sendMessage(AdapterState.BREDR_STOPPED);\n        } else {\n            setAllProfileServiceStates(supportedProfileServices, BluetoothAdapter.STATE_OFF);\n        }\n    }\n\n    private void stopGattProfileService() {\n        mAdapterProperties.onBleDisable();\n        if (mRunningProfiles.size() == 0) {\n            debugLog(\"stopGattProfileService() - No profiles services to stop.\");\n            mAdapterStateMachine.sendMessage(AdapterState.BLE_STOPPED);\n        }\n        setProfileServiceState(GattService.class, BluetoothAdapter.STATE_OFF);\n    }\n\n    private void invalidateBluetoothGetStateCache() {\n        BluetoothAdapter.invalidateBluetoothGetStateCache();\n    }\n\n    void updateLeAudioProfileServiceState() {\n        HashSet<Class> nonSupportedProfiles = new HashSet<>();\n\n        if (!isLeConnectedIsochronousStreamCentralSupported()) {\n            nonSupportedProfiles.addAll(Config.geLeAudioUnicastProfiles());\n        }\n\n        if (!isLeAudioBroadcastAssistantSupported()) {\n            nonSupportedProfiles.add(BassClientService.class);\n        }\n\n        if (isLeAudioBroadcastSourceSupported()) {\n            Config.addSupportedProfile(BluetoothProfile.LE_AUDIO_BROADCAST);\n        }\n\n        if (!nonSupportedProfiles.isEmpty()) {\n            // Remove non-supported profiles from the supported list\n            // since the controller doesn't support\n            Config.removeProfileFromSupportedList(nonSupportedProfiles);\n\n            // Disable the non-supported profiles service\n            for (Class profileService : nonSupportedProfiles) {\n                if (isStartedProfile(profileService.getSimpleName())) {\n                    setProfileServiceState(profileService, BluetoothAdapter.STATE_OFF);\n                }\n            }\n        }\n    }\n\n    void updateAdapterState(int prevState, int newState) {\n        mAdapterProperties.setState(newState);\n        invalidateBluetoothGetStateCache();\n        if (mCallbacks != null) {\n            int n = mCallbacks.beginBroadcast();\n            debugLog(\"updateAdapterState() - Broadcasting state \" + BluetoothAdapter.nameForState(\n                    newState) + \" to \" + n + \" receivers.\");\n            for (int i = 0; i < n; i++) {\n                try {\n                    mCallbacks.getBroadcastItem(i).onBluetoothStateChange(prevState, newState);\n                } catch (RemoteException e) {\n                    debugLog(\"updateAdapterState() - Callback #\" + i + \" failed (\" + e + \")\");\n                }\n            }\n            mCallbacks.finishBroadcast();\n        }\n\n        // Turn the Adapter all the way off if we are disabling and the snoop log setting changed.\n        if (newState == BluetoothAdapter.STATE_BLE_TURNING_ON) {\n            mSnoopLogSettingAtEnable =\n                    SystemProperties.get(BLUETOOTH_BTSNOOP_LOG_MODE_PROPERTY, \"empty\");\n            mDefaultSnoopLogSettingAtEnable =\n                    Settings.Global.getString(getContentResolver(),\n                            Settings.Global.BLUETOOTH_BTSNOOP_DEFAULT_MODE);\n            BluetoothProperties.snoop_default_mode(\n                    BluetoothProperties.snoop_default_mode_values.DISABLED);\n            for (BluetoothProperties.snoop_default_mode_values value :\n                    BluetoothProperties.snoop_default_mode_values.values()) {\n                if (value.getPropValue().equals(mDefaultSnoopLogSettingAtEnable)) {\n                    BluetoothProperties.snoop_default_mode(value);\n                }\n            }\n        } else if (newState == BluetoothAdapter.STATE_BLE_ON\n                   && prevState != BluetoothAdapter.STATE_OFF) {\n            String snoopLogSetting =\n                    SystemProperties.get(BLUETOOTH_BTSNOOP_LOG_MODE_PROPERTY, \"empty\");\n            String snoopDefaultModeSetting =\n                    Settings.Global.getString(getContentResolver(),\n                            Settings.Global.BLUETOOTH_BTSNOOP_DEFAULT_MODE);\n\n            if (!TextUtils.equals(mSnoopLogSettingAtEnable, snoopLogSetting)\n                    || !TextUtils.equals(mDefaultSnoopLogSettingAtEnable,\n                            snoopDefaultModeSetting)) {\n                mAdapterStateMachine.sendMessage(AdapterState.BLE_TURN_OFF);\n            }\n        }\n    }\n\n    void linkQualityReportCallback(\n            long timestamp,\n            int reportId,\n            int rssi,\n            int snr,\n            int retransmissionCount,\n            int packetsNotReceiveCount,\n            int negativeAcknowledgementCount) {\n        BluetoothInCallService bluetoothInCallService = BluetoothInCallService.getInstance();\n\n        if (reportId == BqrQualityReportId.QUALITY_REPORT_ID_SCO_VOICE_CHOPPY.getValue()) {\n            if (bluetoothInCallService == null) {\n                Log.w(TAG, \"No BluetoothInCallService while trying to send BQR.\"\n                        + \" timestamp: \" + timestamp + \" reportId: \" + reportId\n                        + \" rssi: \" + rssi + \" snr: \" + snr\n                        + \" retransmissionCount: \" + retransmissionCount\n                        + \" packetsNotReceiveCount: \" + packetsNotReceiveCount\n                        + \" negativeAcknowledgementCount: \" + negativeAcknowledgementCount);\n                return;\n            }\n            bluetoothInCallService.sendBluetoothCallQualityReport(\n                    timestamp, rssi, snr, retransmissionCount,\n                    packetsNotReceiveCount, negativeAcknowledgementCount);\n        }\n    }\n\n    void switchBufferSizeCallback(boolean isLowLatencyBufferSize) {\n        List<BluetoothDevice> activeDevices = getActiveDevices(BluetoothProfile.A2DP);\n        if (activeDevices.size() != 1) {\n            errorLog(\n                    \"Cannot switch buffer size. The number of A2DP active devices is \"\n                            + activeDevices.size());\n        }\n\n        // Send intent to fastpair\n        Intent switchBufferSizeIntent = new Intent(BluetoothDevice.ACTION_SWITCH_BUFFER_SIZE);\n        switchBufferSizeIntent.setClassName(\n                getString(com.android.bluetooth.R.string.peripheral_link_package),\n                getString(com.android.bluetooth.R.string.peripheral_link_package)\n                        + getString(com.android.bluetooth.R.string.peripheral_link_service));\n        switchBufferSizeIntent.putExtra(BluetoothDevice.EXTRA_DEVICE, activeDevices.get(0));\n        switchBufferSizeIntent.putExtra(\n                BluetoothDevice.EXTRA_LOW_LATENCY_BUFFER_SIZE, isLowLatencyBufferSize);\n        sendBroadcast(switchBufferSizeIntent);\n    }\n\n    void switchCodecCallback(boolean isLowLatencyBufferSize) {\n        List<BluetoothDevice> activeDevices = getActiveDevices(BluetoothProfile.A2DP);\n        if (activeDevices.size() != 1) {\n            errorLog(\n                    \"Cannot switch buffer size. The number of A2DP active devices is \"\n                            + activeDevices.size());\n            return;\n        }\n        mA2dpService.switchCodecByBufferSize(activeDevices.get(0), isLowLatencyBufferSize);\n    }\n\n    void cleanup() {\n        debugLog(\"cleanup()\");\n        if (mCleaningUp) {\n            errorLog(\"cleanup() - Service already starting to cleanup, ignoring request...\");\n            return;\n        }\n\n        closeMetricsLogger();\n\n        clearAdapterService(this);\n\n        mCleaningUp = true;\n        invalidateBluetoothCaches();\n\n        unregisterReceiver(mAlarmBroadcastReceiver);\n\n        stopRfcommServerSockets();\n\n        if (mPendingAlarm != null) {\n            mAlarmManager.cancel(mPendingAlarm);\n            mPendingAlarm = null;\n        }\n\n        // This wake lock release may also be called concurrently by\n        // {@link #releaseWakeLock(String lockName)}, so a synchronization is needed here.\n        synchronized (this) {\n            if (mWakeLock != null) {\n                if (mWakeLock.isHeld()) {\n                    mWakeLock.release();\n                }\n                mWakeLock = null;\n            }\n        }\n\n        if (mDatabaseManager != null) {\n            mDatabaseManager.cleanup();\n        }\n\n        if (mAdapterStateMachine != null) {\n            mAdapterStateMachine.doQuit();\n        }\n\n        if (mBondStateMachine != null) {\n            mBondStateMachine.doQuit();\n        }\n\n        if (mRemoteDevices != null) {\n            mRemoteDevices.cleanup();\n        }\n\n        if (mSdpManager != null) {\n            mSdpManager.cleanup();\n            mSdpManager = null;\n        }\n\n        if (mActivityAttributionService != null) {\n            mActivityAttributionService.cleanup();\n        }\n\n        if (mNativeAvailable) {\n            debugLog(\"cleanup() - Cleaning up adapter native\");\n            cleanupNative();\n            mNativeAvailable = false;\n        }\n\n        if (mAdapterProperties != null) {\n            mAdapterProperties.cleanup();\n        }\n\n        if (mJniCallbacks != null) {\n            mJniCallbacks.cleanup();\n        }\n\n        if (mBluetoothKeystoreService != null) {\n            debugLog(\"cleanup(): mBluetoothKeystoreService.cleanup()\");\n            mBluetoothKeystoreService.cleanup();\n        }\n\n        if (mPhonePolicy != null) {\n            mPhonePolicy.cleanup();\n        }\n\n        if (mSilenceDeviceManager != null) {\n            mSilenceDeviceManager.cleanup();\n        }\n\n        if (mActiveDeviceManager != null) {\n            mActiveDeviceManager.cleanup();\n        }\n\n        if (mProfileServicesState != null) {\n            mProfileServicesState.clear();\n        }\n\n        if (mBluetoothSocketManagerBinder != null) {\n            mBluetoothSocketManagerBinder.cleanUp();\n            mBluetoothSocketManagerBinder = null;\n        }\n\n        if (mBinder != null) {\n            mBinder.cleanup();\n            mBinder = null;  //Do not remove. Otherwise Binder leak!\n        }\n\n        if (mCallbacks != null) {\n            mCallbacks.kill();\n        }\n    }\n\n    private void invalidateBluetoothCaches() {\n        BluetoothAdapter.invalidateGetProfileConnectionStateCache();\n        BluetoothAdapter.invalidateIsOffloadedFilteringSupportedCache();\n        BluetoothDevice.invalidateBluetoothGetBondStateCache();\n        BluetoothAdapter.invalidateBluetoothGetStateCache();\n        BluetoothAdapter.invalidateGetAdapterConnectionStateCache();\n        BluetoothMap.invalidateBluetoothGetConnectionStateCache();\n        BluetoothSap.invalidateBluetoothGetConnectionStateCache();\n    }\n\n    private void setProfileServiceState(Class service, int state) {\n        if (state == BluetoothAdapter.STATE_ON) {\n            mStartedProfiles.add(service.getSimpleName());\n        } else if (state == BluetoothAdapter.STATE_OFF) {\n            mStartedProfiles.remove(service.getSimpleName());\n        }\n        Intent intent = new Intent(this, service);\n        intent.putExtra(EXTRA_ACTION, ACTION_SERVICE_STATE_CHANGED);\n        intent.putExtra(BluetoothAdapter.EXTRA_STATE, state);\n        startService(intent);\n    }\n\n    private void setAllProfileServiceStates(Class[] services, int state) {\n        for (Class service : services) {\n            // TODO(b/228875190): GATT is assumed supported and treated differently as part of the\n            // \"BLE ON\" state, despite GATT not being BLE specific.\n            if (GattService.class.getSimpleName().equals(service.getSimpleName())) {\n                continue;\n            }\n            setProfileServiceState(service, state);\n        }\n    }\n\n    /**\n     * Verifies whether the profile is supported by the local bluetooth adapter by checking a\n     * bitmask of its supported profiles\n     *\n     * @param remoteDeviceUuids is an array of all supported profiles by the remote device\n     * @param localDeviceUuids  is an array of all supported profiles by the local device\n     * @param profile           is the profile we are checking for support\n     * @param device            is the remote device we wish to connect to\n     * @return true if the profile is supported by both the local and remote device, false otherwise\n     */\n    @RequiresPermission(android.Manifest.permission.BLUETOOTH_PRIVILEGED)\n    private boolean isSupported(ParcelUuid[] localDeviceUuids, ParcelUuid[] remoteDeviceUuids,\n            int profile, BluetoothDevice device) {\n        if (remoteDeviceUuids == null || remoteDeviceUuids.length == 0) {\n            Log.e(TAG, \"isSupported: Remote Device Uuids Empty\");\n        }\n\n        if (profile == BluetoothProfile.HEADSET) {\n            return (Utils.arrayContains(localDeviceUuids, BluetoothUuid.HSP_AG)\n                    && Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HSP))\n                    || (Utils.arrayContains(localDeviceUuids, BluetoothUuid.HFP_AG)\n                    && Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HFP));\n        }\n        if (profile == BluetoothProfile.HEADSET_CLIENT) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HFP_AG)\n                    && Utils.arrayContains(localDeviceUuids, BluetoothUuid.HFP);\n        }\n        if (profile == BluetoothProfile.A2DP) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.ADV_AUDIO_DIST)\n                    || Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.A2DP_SINK);\n        }\n        if (profile == BluetoothProfile.A2DP_SINK) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.ADV_AUDIO_DIST)\n                    || Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.A2DP_SOURCE);\n        }\n        if (profile == BluetoothProfile.OPP) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.OBEX_OBJECT_PUSH);\n        }\n        if (profile == BluetoothProfile.HID_HOST) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HID)\n                    || Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HOGP);\n        }\n        if (profile == BluetoothProfile.HID_DEVICE) {\n            return mHidDeviceService.getConnectionState(device)\n                    == BluetoothProfile.STATE_DISCONNECTED;\n        }\n        if (profile == BluetoothProfile.PAN) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.NAP);\n        }\n        if (profile == BluetoothProfile.MAP) {\n            return mMapService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED;\n        }\n        if (profile == BluetoothProfile.PBAP) {\n            return mPbapService.getConnectionState(device) == BluetoothProfile.STATE_CONNECTED;\n        }\n        if (profile == BluetoothProfile.MAP_CLIENT) {\n            return true;\n        }\n        if (profile == BluetoothProfile.PBAP_CLIENT) {\n            return Utils.arrayContains(localDeviceUuids, BluetoothUuid.PBAP_PCE)\n                    && Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.PBAP_PSE);\n        }\n        if (profile == BluetoothProfile.HEARING_AID) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HEARING_AID);\n        }\n        if (profile == BluetoothProfile.SAP) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.SAP);\n        }\n        if (profile == BluetoothProfile.VOLUME_CONTROL) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.VOLUME_CONTROL);\n        }\n        if (profile == BluetoothProfile.CSIP_SET_COORDINATOR) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.COORDINATED_SET);\n        }\n        if (profile == BluetoothProfile.LE_AUDIO) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.LE_AUDIO);\n        }\n        if (profile == BluetoothProfile.HAP_CLIENT) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.HAS);\n        }\n        if (profile == BluetoothProfile.LE_AUDIO_BROADCAST_ASSISTANT) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.BASS);\n        }\n        if (profile == BluetoothProfile.BATTERY) {\n            return Utils.arrayContains(remoteDeviceUuids, BluetoothUuid.BATTERY);\n        }\n\n        Log.e(TAG, \"isSupported: Unexpected profile passed in to function: \" + profile);\n        return false;\n    }\n\n    /**\n     * Checks if any profile is enabled for the given device\n     *\n     * @param device is the device for which we are checking if any profiles are enabled\n     * @return true if any profile is enabled, false otherwise\n     */\n    @RequiresPermission(android.Manifest.permission.BLUETOOTH_PRIVILEGED)\n    boolean isAnyProfileEnabled(BluetoothDevice device) {\n        if (mA2dpService != null && mA2dpService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mA2dpSinkService != null && mA2dpSinkService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mHeadsetService != null && mHeadsetService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mHeadsetClientService != null && mHeadsetClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mMapClientService != null && mMapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mHidHostService != null && mHidHostService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mPanService != null && mPanService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mPbapClientService != null && mPbapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mHearingAidService != null && mHearingAidService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mHapClientService != null && mHapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mVolumeControlService != null && mVolumeControlService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mCsipSetCoordinatorService != null\n                && mCsipSetCoordinatorService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mLeAudioService != null && mLeAudioService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mBassClientService != null && mBassClientService.getConnectionPolicy(device)\n                 > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        if (mBatteryService != null && mBatteryService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Connects only available profiles\n     * (those with {@link BluetoothProfile#CONNECTION_POLICY_ALLOWED})\n     *\n     * @param device is the device with which we are connecting the profiles\n     * @return {@link BluetoothStatusCodes#SUCCESS}\n     */\n    @RequiresPermission(allOf = {\n            android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n            android.Manifest.permission.MODIFY_PHONE_STATE,\n    })\n    private int connectEnabledProfiles(BluetoothDevice device) {\n        ParcelUuid[] remoteDeviceUuids = getRemoteUuids(device);\n        ParcelUuid[] localDeviceUuids = mAdapterProperties.getUuids();\n\n        if (mA2dpService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.A2DP, device) && mA2dpService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting A2dp\");\n            mA2dpService.connect(device);\n        }\n        if (mA2dpSinkService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.A2DP_SINK, device) && mA2dpSinkService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting A2dp Sink\");\n            mA2dpSinkService.connect(device);\n        }\n        if (mHeadsetService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEADSET, device) && mHeadsetService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Headset Profile\");\n            mHeadsetService.connect(device);\n        }\n        if (mHeadsetClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEADSET_CLIENT, device)\n                && mHeadsetClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting HFP\");\n            mHeadsetClientService.connect(device);\n        }\n        if (mMapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.MAP_CLIENT, device)\n                && mMapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting MAP\");\n            mMapClientService.connect(device);\n        }\n        if (mHidHostService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HID_HOST, device) && mHidHostService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Hid Host Profile\");\n            mHidHostService.connect(device);\n        }\n        if (mPanService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.PAN, device) && mPanService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Pan Profile\");\n            mPanService.connect(device);\n        }\n        if (mPbapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.PBAP_CLIENT, device)\n                && mPbapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Pbap\");\n            mPbapClientService.connect(device);\n        }\n        if (mHearingAidService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEARING_AID, device)\n                && mHearingAidService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Hearing Aid Profile\");\n            mHearingAidService.connect(device);\n        }\n        if (mHapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HAP_CLIENT, device)\n                && mHapClientService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting HAS Profile\");\n            mHapClientService.connect(device);\n        }\n        if (mVolumeControlService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.VOLUME_CONTROL, device)\n                && mVolumeControlService.getConnectionPolicy(device)\n                > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Volume Control Profile\");\n            mVolumeControlService.connect(device);\n        }\n        if (mCsipSetCoordinatorService != null\n                && isSupported(localDeviceUuids, remoteDeviceUuids,\n                        BluetoothProfile.CSIP_SET_COORDINATOR, device)\n                && mCsipSetCoordinatorService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Coordinated Set Profile\");\n            mCsipSetCoordinatorService.connect(device);\n        }\n        if (mLeAudioService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.LE_AUDIO, device)\n                && mLeAudioService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting LeAudio profile (BAP)\");\n            mLeAudioService.connect(device);\n        }\n        if (mBassClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.LE_AUDIO_BROADCAST_ASSISTANT, device)\n                && mBassClientService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting LE Broadcast Assistant Profile\");\n            mBassClientService.connect(device);\n        }\n        if (mBatteryService != null\n                && isSupported(\n                        localDeviceUuids, remoteDeviceUuids, BluetoothProfile.BATTERY, device)\n                && mBatteryService.getConnectionPolicy(device)\n                        > BluetoothProfile.CONNECTION_POLICY_FORBIDDEN) {\n            Log.i(TAG, \"connectEnabledProfiles: Connecting Battery Service\");\n            mBatteryService.connect(device);\n        }\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    /**\n     * Verifies that all bluetooth profile services are running\n     *\n     * @return true if all bluetooth profile services running, false otherwise\n     */\n    private boolean profileServicesRunning() {\n        if (mRegisteredProfiles.size() == Config.getSupportedProfiles().length\n                && mRegisteredProfiles.size() == mRunningProfiles.size()) {\n            return true;\n        }\n\n        Log.e(TAG, \"profileServicesRunning: One or more supported services not running\");\n        return false;\n    }\n\n    /**\n     * Initializes all the profile services fields\n     */\n    private void initProfileServices() {\n        Log.i(TAG, \"initProfileServices: Initializing all bluetooth profile services\");\n        mA2dpService = A2dpService.getA2dpService();\n        mA2dpSinkService = A2dpSinkService.getA2dpSinkService();\n        mHeadsetService = HeadsetService.getHeadsetService();\n        mHeadsetClientService = HeadsetClientService.getHeadsetClientService();\n        mMapService = BluetoothMapService.getBluetoothMapService();\n        mMapClientService = MapClientService.getMapClientService();\n        mHidDeviceService = HidDeviceService.getHidDeviceService();\n        mHidHostService = HidHostService.getHidHostService();\n        mPanService = PanService.getPanService();\n        mPbapService = BluetoothPbapService.getBluetoothPbapService();\n        mPbapClientService = PbapClientService.getPbapClientService();\n        mHearingAidService = HearingAidService.getHearingAidService();\n        mHapClientService = HapClientService.getHapClientService();\n        mSapService = SapService.getSapService();\n        mVolumeControlService = VolumeControlService.getVolumeControlService();\n        mCsipSetCoordinatorService = CsipSetCoordinatorService.getCsipSetCoordinatorService();\n        mLeAudioService = LeAudioService.getLeAudioService();\n        mBassClientService = BassClientService.getBassClientService();\n        mBatteryService = BatteryService.getBatteryService();\n    }\n\n    @BluetoothAdapter.RfcommListenerResult\n    private int startRfcommListener(\n            String name,\n            ParcelUuid uuid,\n            PendingIntent pendingIntent,\n            AttributionSource attributionSource) {\n        if (mBluetoothServerSockets.containsKey(uuid.getUuid())) {\n            Log.d(TAG, String.format(\n                        \"Cannot start RFCOMM listener: UUID %s already in use.\", uuid.getUuid()));\n            return BluetoothStatusCodes.RFCOMM_LISTENER_START_FAILED_UUID_IN_USE;\n        }\n\n        try {\n            startRfcommListenerInternal(name, uuid.getUuid(), pendingIntent, attributionSource);\n        } catch (IOException e) {\n            return BluetoothStatusCodes.RFCOMM_LISTENER_FAILED_TO_CREATE_SERVER_SOCKET;\n        }\n\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    @BluetoothAdapter.RfcommListenerResult\n    private int stopRfcommListener(ParcelUuid uuid, AttributionSource attributionSource) {\n        RfcommListenerData listenerData = mBluetoothServerSockets.get(uuid.getUuid());\n\n        if (listenerData == null) {\n            Log.d(TAG, String.format(\n                        \"Cannot stop RFCOMM listener: UUID %s is not registered.\", uuid.getUuid()));\n            return BluetoothStatusCodes.RFCOMM_LISTENER_OPERATION_FAILED_NO_MATCHING_SERVICE_RECORD;\n        }\n\n        if (attributionSource.getUid() != listenerData.mAttributionSource.getUid()) {\n            return BluetoothStatusCodes.RFCOMM_LISTENER_OPERATION_FAILED_DIFFERENT_APP;\n        }\n\n        // Remove the entry so that it does not try and restart the server socket.\n        mBluetoothServerSockets.remove(uuid.getUuid());\n\n        return listenerData.closeServerAndPendingSockets(mHandler);\n    }\n\n    private IncomingRfcommSocketInfo retrievePendingSocketForServiceRecord(\n            ParcelUuid uuid, AttributionSource attributionSource) {\n        IncomingRfcommSocketInfo socketInfo = new IncomingRfcommSocketInfo();\n\n        RfcommListenerData listenerData = mBluetoothServerSockets.get(uuid.getUuid());\n\n        if (listenerData == null) {\n            socketInfo.status =\n                    BluetoothStatusCodes\n                            .RFCOMM_LISTENER_OPERATION_FAILED_NO_MATCHING_SERVICE_RECORD;\n            return socketInfo;\n        }\n\n        if (attributionSource.getUid() != listenerData.mAttributionSource.getUid()) {\n            socketInfo.status = BluetoothStatusCodes.RFCOMM_LISTENER_OPERATION_FAILED_DIFFERENT_APP;\n            return socketInfo;\n        }\n\n        BluetoothSocket socket = listenerData.mPendingSockets.poll();\n\n        if (socket == null) {\n            socketInfo.status = BluetoothStatusCodes.RFCOMM_LISTENER_NO_SOCKET_AVAILABLE;\n            return socketInfo;\n        }\n\n        mHandler.removeCallbacksAndMessages(socket);\n\n        socketInfo.bluetoothDevice = socket.getRemoteDevice();\n        socketInfo.pfd = socket.getParcelFileDescriptor();\n        socketInfo.status = BluetoothStatusCodes.SUCCESS;\n\n        return socketInfo;\n    }\n\n    private void handleIncomingRfcommConnections(UUID uuid) {\n        RfcommListenerData listenerData = mBluetoothServerSockets.get(uuid);\n        for (;;) {\n            BluetoothSocket socket;\n            try {\n                socket = listenerData.mServerSocket.accept();\n            } catch (IOException e) {\n                if (mBluetoothServerSockets.containsKey(uuid)) {\n                    // The uuid still being in the map indicates that the accept failure is\n                    // unexpected. Try and restart the listener.\n                    Log.e(TAG, \"Failed to accept socket on \" + listenerData.mServerSocket, e);\n                    restartRfcommListener(listenerData, uuid);\n                }\n                return;\n            }\n\n            listenerData.mPendingSockets.add(socket);\n            try {\n                listenerData.mPendingIntent.send();\n            } catch (PendingIntent.CanceledException e) {\n                Log.e(TAG, \"PendingIntent for RFCOMM socket notifications cancelled.\", e);\n                // The pending intent was cancelled, close the server as there is no longer any way\n                // to notify the app that registered the listener.\n                listenerData.closeServerAndPendingSockets(mHandler);\n                mBluetoothServerSockets.remove(uuid);\n                return;\n            }\n            mHandler.postDelayed(\n                    () -> pendingSocketTimeoutRunnable(listenerData, socket),\n                    socket,\n                    PENDING_SOCKET_HANDOFF_TIMEOUT.toMillis());\n        }\n    }\n\n    // Tries to restart the rfcomm listener for the given UUID\n    private void restartRfcommListener(RfcommListenerData listenerData, UUID uuid) {\n        listenerData.closeServerAndPendingSockets(mHandler);\n        try {\n            startRfcommListenerInternal(\n                    listenerData.mName,\n                    uuid,\n                    listenerData.mPendingIntent,\n                    listenerData.mAttributionSource);\n        } catch (IOException e) {\n            Log.e(TAG, \"Failed to recreate rfcomm server socket\", e);\n\n            mBluetoothServerSockets.remove(uuid);\n        }\n    }\n\n    private void pendingSocketTimeoutRunnable(\n            RfcommListenerData listenerData, BluetoothSocket socket) {\n        boolean socketFound = listenerData.mPendingSockets.remove(socket);\n        if (socketFound) {\n            try {\n                socket.close();\n            } catch (IOException e) {\n                Log.e(TAG, \"Failed to close bt socket\", e);\n                // We don't care if closing the socket failed, just continue on.\n            }\n        }\n    }\n\n    private void startRfcommListenerInternal(\n            String name, UUID uuid, PendingIntent intent, AttributionSource attributionSource)\n            throws IOException {\n        BluetoothServerSocket bluetoothServerSocket =\n                mAdapter.listenUsingRfcommWithServiceRecord(name, uuid);\n\n        RfcommListenerData listenerData =\n                new RfcommListenerData(bluetoothServerSocket, name, intent, attributionSource);\n\n        mBluetoothServerSockets.put(uuid, listenerData);\n\n        mSocketServersExecutor.execute(() -> handleIncomingRfcommConnections(uuid));\n    }\n\n    private void stopRfcommServerSockets() {\n        Iterator<Map.Entry<UUID, RfcommListenerData>> socketsIterator =\n                mBluetoothServerSockets.entrySet().iterator();\n        while (socketsIterator.hasNext()) {\n            socketsIterator.next().getValue().closeServerAndPendingSockets(mHandler);\n            socketsIterator.remove();\n        }\n    }\n\n    private static class RfcommListenerData {\n        final BluetoothServerSocket mServerSocket;\n        // Service record name\n        final String mName;\n        // The Intent which contains the Service info to which the incoming socket connections are\n        // handed off to.\n        final PendingIntent mPendingIntent;\n        // AttributionSource for the requester of the RFCOMM listener\n        final AttributionSource mAttributionSource;\n        // Contains the connected sockets which are pending transfer to the app which requested the\n        // listener.\n        final ConcurrentLinkedQueue<BluetoothSocket> mPendingSockets =\n                new ConcurrentLinkedQueue<>();\n\n        RfcommListenerData(\n                BluetoothServerSocket serverSocket,\n                String name,\n                PendingIntent pendingIntent,\n                AttributionSource attributionSource) {\n            mServerSocket = serverSocket;\n            mName = name;\n            mPendingIntent = pendingIntent;\n            mAttributionSource = attributionSource;\n        }\n\n        int closeServerAndPendingSockets(Handler handler) {\n            int result = BluetoothStatusCodes.SUCCESS;\n            try {\n                mServerSocket.close();\n            } catch (IOException e) {\n                Log.e(TAG, \"Failed to call close on rfcomm server socket\", e);\n                result = BluetoothStatusCodes.RFCOMM_LISTENER_FAILED_TO_CLOSE_SERVER_SOCKET;\n            }\n            mPendingSockets.forEach(\n                    pendingSocket -> {\n                        handler.removeCallbacksAndMessages(pendingSocket);\n                        try {\n                            pendingSocket.close();\n                        } catch (IOException e) {\n                            Log.e(TAG, \"Failed to close socket\", e);\n                        }\n                    });\n            mPendingSockets.clear();\n\n            return result;\n        }\n    }\n\n    private boolean isAvailable() {\n        return !mCleaningUp;\n    }\n\n    /**\n     * Handlers for incoming service calls\n     */\n    private AdapterServiceBinder mBinder;\n\n    /**\n     * The Binder implementation must be declared to be a static class, with\n     * the AdapterService instance passed in the constructor. Furthermore,\n     * when the AdapterService shuts down, the reference to the AdapterService\n     * must be explicitly removed.\n     *\n     * Otherwise, a memory leak can occur from repeated starting/stopping the\n     * service...Please refer to android.os.Binder for further details on\n     * why an inner instance class should be avoided.\n     *\n     */\n    @VisibleForTesting\n    public static class AdapterServiceBinder extends IBluetooth.Stub {\n        private AdapterService mService;\n\n        AdapterServiceBinder(AdapterService svc) {\n            mService = svc;\n            mService.invalidateBluetoothGetStateCache();\n            BluetoothAdapter.getDefaultAdapter().disableBluetoothGetStateCache();\n        }\n\n        public void cleanup() {\n            mService = null;\n        }\n\n        public AdapterService getService() {\n            if (mService != null && mService.isAvailable()) {\n                return mService;\n            }\n            return null;\n        }\n\n        @Override\n        public void getState(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getState());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getState() {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothAdapter.STATE_OFF;\n            }\n\n            return service.getState();\n        }\n\n        @Override\n        public void enable(boolean quietMode, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(enable(quietMode, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean enable(boolean quietMode, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"enable\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService enable\")) {\n                return false;\n            }\n\n            return service.enable(quietMode);\n        }\n\n        @Override\n        public void disable(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(disable(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean disable(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"disable\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService disable\")) {\n                return false;\n            }\n\n            return service.disable();\n        }\n\n        @Override\n        public String getAddress() {\n            if (mService == null) {\n                return null;\n            }\n            return getAddressWithAttribution(Utils.getCallingAttributionSource(mService));\n        }\n\n        @Override\n        public void getAddressWithAttribution(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getAddressWithAttribution(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private String getAddressWithAttribution(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getAddress\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getAddress\")) {\n                return null;\n            }\n\n            enforceLocalMacAddressPermission(service);\n\n            return Utils.getAddressStringFromByte(service.mAdapterProperties.getAddress());\n        }\n\n        @Override\n        public void getUuids(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getUuids(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private List<ParcelUuid> getUuids(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getUuids\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getUuids\")) {\n                return new ArrayList<>();\n            }\n\n            ParcelUuid[] parcels = service.mAdapterProperties.getUuids();\n            if (parcels == null) {\n                parcels = new ParcelUuid[0];\n            }\n            return Arrays.asList(parcels);\n        }\n\n        @Override\n        public void getIdentityAddress(String address, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getIdentityAddress(address));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        public String getIdentityAddress(String address) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getIdentityAddress\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, Utils.getCallingAttributionSource(mService),\n                                \"AdapterService getIdentityAddress\")) {\n                return null;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.getIdentityAddress(address);\n        }\n\n        @Override\n        public void getName(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getName(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private String getName(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getName\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getName\")) {\n                return null;\n            }\n\n            return service.getName();\n        }\n\n        @Override\n        public void getNameLengthForAdvertise(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getNameLengthForAdvertise(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getNameLengthForAdvertise(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getNameLengthForAdvertise\")\n                    || !Utils.checkAdvertisePermissionForDataDelivery(\n                            service, attributionSource, TAG)) {\n                return -1;\n            }\n\n            return service.getNameLengthForAdvertise();\n        }\n\n        @Override\n        public void setName(String name, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setName(name, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setName(String name, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"setName\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService setName\")) {\n                return false;\n            }\n\n            return service.mAdapterProperties.setName(name);\n        }\n\n        @Override\n        public void getBluetoothClass(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getBluetoothClass(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private BluetoothClass getBluetoothClass(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getBluetoothClass\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterSource getBluetoothClass\")) {\n                return null;\n            }\n\n            return service.mAdapterProperties.getBluetoothClass();\n        }\n\n        @Override\n        public void setBluetoothClass(BluetoothClass bluetoothClass, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setBluetoothClass(bluetoothClass, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setBluetoothClass(BluetoothClass bluetoothClass, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (!service.mAdapterProperties.setBluetoothClass(bluetoothClass)) {\n              return false;\n            }\n\n            return Settings.Global.putInt(\n                    service.getContentResolver(),\n                    Settings.Global.BLUETOOTH_CLASS_OF_DEVICE,\n                    bluetoothClass.getClassOfDevice());\n        }\n\n        @Override\n        public void getIoCapability(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getIoCapability(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getIoCapability(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getIoCapability\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getIoCapability\")) {\n                return BluetoothAdapter.IO_CAPABILITY_UNKNOWN;\n            }\n\n            return service.mAdapterProperties.getIoCapability();\n        }\n\n        @Override\n        public void setIoCapability(int capability, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setIoCapability(capability, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setIoCapability(int capability, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (!isValidIoCapability(capability)) {\n              return false;\n            }\n\n            return service.mAdapterProperties.setIoCapability(capability);\n        }\n\n        @Override\n        public void getLeIoCapability(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getLeIoCapability(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getLeIoCapability(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getLeIoCapability\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getLeIoCapability\")) {\n                return BluetoothAdapter.IO_CAPABILITY_UNKNOWN;\n            }\n\n            return service.mAdapterProperties.getLeIoCapability();\n        }\n\n        @Override\n        public void setLeIoCapability(int capability, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setLeIoCapability(capability, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setLeIoCapability(int capability, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (!isValidIoCapability(capability)) {\n              return false;\n            }\n\n            return service.mAdapterProperties.setLeIoCapability(capability);\n        }\n\n        @Override\n        public void getScanMode(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getScanMode(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        int getScanMode(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getScanMode\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getScanMode\")) {\n                return BluetoothAdapter.SCAN_MODE_NONE;\n            }\n\n            return service.mAdapterProperties.getScanMode();\n        }\n\n        @Override\n        public void setScanMode(int mode, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setScanMode(mode, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int setScanMode(int mode, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"setScanMode\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService setScanMode\")) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_SCAN_PERMISSION;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mAdapterProperties.setScanMode(convertScanModeToHal(mode))\n                    ? BluetoothStatusCodes.SUCCESS : BluetoothStatusCodes.ERROR_UNKNOWN;\n        }\n\n        @Override\n        public void getDiscoverableTimeout(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getDiscoverableTimeout(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private long getDiscoverableTimeout(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getDiscoverableTimeout\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getDiscoverableTimeout\")) {\n                return -1;\n            }\n\n            return service.mAdapterProperties.getDiscoverableTimeout();\n        }\n\n        @Override\n        public void setDiscoverableTimeout(long timeout, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setDiscoverableTimeout(timeout, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int setDiscoverableTimeout(long timeout, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"setDiscoverableTimeout\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService setDiscoverableTimeout\")) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_SCAN_PERMISSION;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mAdapterProperties.setDiscoverableTimeout((int) timeout)\n                    ? BluetoothStatusCodes.SUCCESS : BluetoothStatusCodes.ERROR_UNKNOWN;\n        }\n\n        @Override\n        public void startDiscovery(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(startDiscovery(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean startDiscovery(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"startDiscovery\")) {\n                return false;\n            }\n\n            if (!Utils.checkScanPermissionForDataDelivery(\n                    service, attributionSource, \"Starting discovery.\")) {\n                return false;\n            }\n\n            return service.startDiscovery(attributionSource);\n        }\n\n        @Override\n        public void cancelDiscovery(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(cancelDiscovery(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean cancelDiscovery(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"cancelDiscovery\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService cancelDiscovery\")) {\n                return false;\n            }\n\n            service.debugLog(\"cancelDiscovery\");\n            return service.cancelDiscoveryNative();\n        }\n\n        @Override\n        public void isDiscovering(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isDiscovering(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isDiscovering(AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"isDiscovering\")\n                    || !Utils.checkScanPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService isDiscovering\")) {\n                return false;\n            }\n\n            return service.mAdapterProperties.isDiscovering();\n        }\n\n        @Override\n        public void getDiscoveryEndMillis(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getDiscoveryEndMillis(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private long getDiscoveryEndMillis(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return -1;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mAdapterProperties.discoveryEndMillis();\n        }\n\n        @Override\n        public void getMostRecentlyConnectedDevices(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getMostRecentlyConnectedDevices(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private List<BluetoothDevice> getMostRecentlyConnectedDevices(\n                AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getMostRecentlyConnectedDevices\")) {\n                return new ArrayList<>();\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mDatabaseManager.getMostRecentlyConnectedDevices();\n        }\n\n        @Override\n        public void getBondedDevices(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getBondedDevices(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private List<BluetoothDevice> getBondedDevices(AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getBondedDevices\")) {\n                return new ArrayList<>();\n            }\n\n            return Arrays.asList(service.getBondedDevices());\n        }\n\n        @Override\n        public void getAdapterConnectionState(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getAdapterConnectionState());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getAdapterConnectionState() {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothAdapter.STATE_DISCONNECTED;\n            }\n\n            return service.mAdapterProperties.getConnectionState();\n        }\n\n        /**\n         * This method has an associated binder cache.  The invalidation\n         * methods must be changed if the logic behind this method changes.\n         */\n        @Override\n        public void getProfileConnectionState(int profile, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getProfileConnectionState(profile));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getProfileConnectionState(int profile) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(\n                            service, TAG, \"getProfileConnectionState\")) {\n                return BluetoothProfile.STATE_DISCONNECTED;\n            }\n\n            return service.mAdapterProperties.getProfileConnectionState(profile);\n        }\n\n        @Override\n        public void createBond(BluetoothDevice device, int transport, OobData remoteP192Data,\n                OobData remoteP256Data, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(createBond(device, transport, remoteP192Data, remoteP256Data,\n                            source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean createBond(BluetoothDevice device, int transport, OobData remoteP192Data,\n                OobData remoteP256Data, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"createBond\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService createBond\")) {\n                return false;\n            }\n\n            // This conditional is required to satisfy permission dependencies\n            // since createBond calls createBondOutOfBand with null value passed as data.\n            // BluetoothDevice#createBond requires BLUETOOTH_ADMIN only.\n            service.enforceBluetoothPrivilegedPermissionIfNeeded(remoteP192Data, remoteP256Data);\n\n            return service.createBond(device, transport, remoteP192Data, remoteP256Data,\n                    attributionSource.getPackageName());\n        }\n\n        @Override\n        public void cancelBondProcess(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(cancelBondProcess(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean cancelBondProcess(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"cancelBondProcess\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService cancelBondProcess\")) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp != null) {\n                deviceProp.setBondingInitiatedLocally(false);\n            }\n\n            return service.cancelBondNative(getBytesFromAddress(device.getAddress()));\n        }\n\n        @Override\n        public void removeBond(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(removeBond(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean removeBond(BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"removeBond\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService removeBond\")) {\n                return false;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null || deviceProp.getBondState() != BluetoothDevice.BOND_BONDED) {\n                return false;\n            }\n            service.mBondAttemptCallerInfo.remove(device.getAddress());\n            deviceProp.setBondingInitiatedLocally(false);\n\n            Message msg = service.mBondStateMachine.obtainMessage(BondStateMachine.REMOVE_BOND);\n            msg.obj = device;\n            service.mBondStateMachine.sendMessage(msg);\n            return true;\n        }\n\n        @Override\n        public void getBondState(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getBondState(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getBondState(BluetoothDevice device, AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getBondState\")) {\n                return BluetoothDevice.BOND_NONE;\n            }\n\n            return service.getBondState(device);\n        }\n\n        @Override\n        public void isBondingInitiatedLocally(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isBondingInitiatedLocally(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isBondingInitiatedLocally(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService isBondingInitiatedLocally\")) {\n                return false;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            return deviceProp != null && deviceProp.isBondingInitiatedLocally();\n        }\n\n        @Override\n        public void generateLocalOobData(int transport, IBluetoothOobDataCallback callback,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                generateLocalOobData(transport, callback, source);\n                receiver.send(null);\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private void generateLocalOobData(int transport, IBluetoothOobDataCallback callback,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveOrManagedUser(service, TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            service.generateLocalOobData(transport, callback);\n        }\n\n        @Override\n        public void getSupportedProfiles(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getSupportedProfiles(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private long getSupportedProfiles(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return 0;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n\n            return Config.getSupportedProfilesBitMask();\n        }\n\n        @Override\n        public int getConnectionState(BluetoothDevice device) {\n            if (mService == null) {\n                return BluetoothProfile.STATE_DISCONNECTED;\n            }\n            return getConnectionStateWithAttribution(device,\n                        Utils.getCallingAttributionSource(mService));\n        }\n\n        @Override\n        public void getConnectionStateWithAttribution(BluetoothDevice device,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getConnectionStateWithAttribution(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        public int getConnectionStateWithAttribution(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getConnectionState\")) {\n                return BluetoothProfile.STATE_DISCONNECTED;\n            }\n\n            return service.getConnectionState(device);\n        }\n\n        @Override\n        public void canBondWithoutDialog(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(canBondWithoutDialog(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean canBondWithoutDialog(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.canBondWithoutDialog(device);\n        }\n\n        @Override\n        public void removeActiveDevice(@ActiveDeviceUse int profiles,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(removeActiveDevice(profiles, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean removeActiveDevice(@ActiveDeviceUse int profiles,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n            return service.setActiveDevice(null, profiles);\n        }\n\n        @Override\n        public void setActiveDevice(BluetoothDevice device, @ActiveDeviceUse int profiles,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setActiveDevice(device, profiles, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setActiveDevice(BluetoothDevice device, @ActiveDeviceUse int profiles,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.setActiveDevice(device, profiles);\n        }\n\n        @Override\n        public void getActiveDevices(@ActiveDeviceProfile int profile,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getActiveDevices(profile, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private List<BluetoothDevice> getActiveDevices(@ActiveDeviceProfile int profile,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return new ArrayList<>();\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.getActiveDevices(profile);\n        }\n\n        @Override\n        public void connectAllEnabledProfiles(BluetoothDevice device,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(connectAllEnabledProfiles(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int connectAllEnabledProfiles(BluetoothDevice device,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveUser(TAG, \"connectAllEnabledProfiles\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            if (device == null) {\n                throw new IllegalArgumentException(\"device cannot be null\");\n            }\n            if (!BluetoothAdapter.checkBluetoothAddress(device.getAddress())) {\n                throw new IllegalArgumentException(\"device cannot have an invalid address\");\n            }\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            try {\n                return service.connectAllEnabledProfiles(device);\n            } catch (Exception e) {\n                Log.v(TAG, \"connectAllEnabledProfiles() failed\", e);\n                SneakyThrow.sneakyThrow(e);\n                throw new RuntimeException(e);\n            }\n        }\n\n        @Override\n        public void disconnectAllEnabledProfiles(BluetoothDevice device,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(disconnectAllEnabledProfiles(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int disconnectAllEnabledProfiles(BluetoothDevice device,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveUser(TAG, \"disconnectAllEnabledProfiles\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            if (device == null) {\n                throw new IllegalArgumentException(\"device cannot be null\");\n            }\n            if (!BluetoothAdapter.checkBluetoothAddress(device.getAddress())) {\n                throw new IllegalArgumentException(\"device cannot have an invalid address\");\n            }\n            if (!Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            try {\n                return service.disconnectAllEnabledProfiles(device);\n            } catch (Exception e) {\n                Log.v(TAG, \"disconnectAllEnabledProfiles() failed\", e);\n                SneakyThrow.sneakyThrow(e);\n                throw new RuntimeException(e);\n            }\n        }\n\n        @Override\n        public void getRemoteName(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getRemoteName(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private String getRemoteName(BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteName\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getRemoteName\")) {\n                return null;\n            }\n\n            return service.getRemoteName(device);\n        }\n\n        @Override\n        public void getRemoteType(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getRemoteType(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getRemoteType(BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteType\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getRemoteType\")) {\n                return BluetoothDevice.DEVICE_TYPE_UNKNOWN;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            return deviceProp != null\n                    ? deviceProp.getDeviceType() : BluetoothDevice.DEVICE_TYPE_UNKNOWN;\n        }\n\n        @Override\n        public String getRemoteAlias(BluetoothDevice device) {\n            if (mService == null) {\n                return null;\n            }\n            return getRemoteAliasWithAttribution(device,\n                    Utils.getCallingAttributionSource(mService));\n        }\n\n        @Override\n        public void getRemoteAliasWithAttribution(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getRemoteAliasWithAttribution(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private String getRemoteAliasWithAttribution(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteAlias\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getRemoteAlias\")) {\n                return null;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            return deviceProp != null ? deviceProp.getAlias() : null;\n        }\n\n        @Override\n        public void setRemoteAlias(BluetoothDevice device, String name, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setRemoteAlias(device, name, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int setRemoteAlias(BluetoothDevice device, String name,\n                AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n            if (!callerIsSystemOrActiveUser(TAG, \"setRemoteAlias\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            if (name != null && name.isEmpty()) {\n                throw new IllegalArgumentException(\"alias cannot be the empty string\");\n            }\n\n            if (!hasBluetoothPrivilegedPermission(service)) {\n                if (!Utils.checkConnectPermissionForDataDelivery(\n                        service, attributionSource, \"AdapterService setRemoteAlias\")) {\n                    return BluetoothStatusCodes.ERROR_MISSING_BLUETOOTH_CONNECT_PERMISSION;\n                }\n                enforceCdmAssociation(service.mCompanionDeviceManager, service,\n                        attributionSource.getPackageName(), Binder.getCallingUid(), device);\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null) {\n                return BluetoothStatusCodes.ERROR_DEVICE_NOT_BONDED;\n            }\n            deviceProp.setAlias(device, name);\n            return BluetoothStatusCodes.SUCCESS;\n        }\n\n        @Override\n        public void getRemoteClass(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getRemoteClass(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getRemoteClass(BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteClass\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getRemoteClass\")) {\n                return 0;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            return deviceProp != null ? deviceProp.getBluetoothClass() : 0;\n        }\n\n        @Override\n        public void getRemoteUuids(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getRemoteUuids(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private List<ParcelUuid> getRemoteUuids(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"getRemoteUuids\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getRemoteUuids\")) {\n                return new ArrayList<>();\n            }\n\n            ParcelUuid[] parcels = service.getRemoteUuids(device);\n            if (parcels == null) {\n                return null;\n            }\n            return Arrays.asList(parcels);\n        }\n\n        @Override\n        public boolean fetchRemoteUuids(BluetoothDevice device) {\n            if (mService == null) {\n                return false;\n            }\n            return fetchRemoteUuidsWithAttribution(device, TRANSPORT_AUTO,\n                    Utils.getCallingAttributionSource(mService));\n        }\n\n        @Override\n        public void fetchRemoteUuidsWithAttribution(BluetoothDevice device, int transport,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(fetchRemoteUuidsWithAttribution(device, transport, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean fetchRemoteUuidsWithAttribution(\n                BluetoothDevice device, int transport, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !callerIsSystemOrActiveOrManagedUser(service, TAG, \"fetchRemoteUuids\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService fetchRemoteUuids\")) {\n                return false;\n            }\n            if (transport != TRANSPORT_AUTO) {\n                enforceBluetoothPrivilegedPermission(service);\n            }\n\n            service.mRemoteDevices.fetchUuids(device, transport);\n            return true;\n        }\n\n        @Override\n        public void setPin(BluetoothDevice device, boolean accept, int len, byte[] pinCode,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setPin(device, accept, len, pinCode, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setPin(BluetoothDevice device, boolean accept, int len, byte[] pinCode,\n                AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"setPin\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService setPin\")) {\n                return false;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            // Only allow setting a pin in bonding state, or bonded state in case of security\n            // upgrade.\n            if (deviceProp == null || !deviceProp.isBondingOrBonded()) {\n                return false;\n            }\n            if (pinCode.length != len) {\n                android.util.EventLog.writeEvent(0x534e4554, \"139287605\", -1,\n                        \"PIN code length mismatch\");\n                return false;\n            }\n            service.logUserBondResponse(device, accept,\n                    BluetoothProtoEnums.BOND_SUB_STATE_LOCAL_PIN_REPLIED);\n            return service.pinReplyNative(\n                    getBytesFromAddress(device.getAddress()), accept, len, pinCode);\n        }\n\n        @Override\n        public void setPasskey(BluetoothDevice device, boolean accept, int len, byte[] passkey,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setPasskey(device, accept, len, passkey, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setPasskey(BluetoothDevice device, boolean accept, int len, byte[] passkey,\n                AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"setPasskey\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService setPasskey\")) {\n                return false;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null || !deviceProp.isBonding()) {\n                return false;\n            }\n            if (passkey.length != len) {\n                android.util.EventLog.writeEvent(0x534e4554, \"139287605\", -1,\n                        \"Passkey length mismatch\");\n                return false;\n            }\n            service.logUserBondResponse(device, accept, BluetoothProtoEnums.BOND_SUB_STATE_LOCAL_SSP_REPLIED);\n            return service.sspReplyNative(\n                    getBytesFromAddress(device.getAddress()),\n                    AbstractionLayer.BT_SSP_VARIANT_PASSKEY_ENTRY,\n                    accept,\n                    Utils.byteArrayToInt(passkey));\n        }\n\n        @Override\n        public void setPairingConfirmation(BluetoothDevice device, boolean accept,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setPairingConfirmation(device, accept, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setPairingConfirmation(BluetoothDevice device, boolean accept,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null || !deviceProp.isBonding()) {\n                return false;\n            }\n            service.logUserBondResponse(device, accept, BluetoothProtoEnums.BOND_SUB_STATE_LOCAL_SSP_REPLIED);\n            return service.sspReplyNative(\n                    getBytesFromAddress(device.getAddress()),\n                    AbstractionLayer.BT_SSP_VARIANT_PASSKEY_CONFIRMATION,\n                    accept,\n                    0);\n        }\n\n        @Override\n        public void getSilenceMode(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getSilenceMode(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean getSilenceMode(BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mSilenceDeviceManager.getSilenceMode(device);\n        }\n\n        @Override\n        public void setSilenceMode(BluetoothDevice device, boolean silence,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setSilenceMode(device, silence, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setSilenceMode(BluetoothDevice device, boolean silence,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.mSilenceDeviceManager.setSilenceMode(device, silence);\n            return true;\n        }\n\n        @Override\n        public void getPhonebookAccessPermission(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getPhonebookAccessPermission(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getPhonebookAccessPermission(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getPhonebookAccessPermission\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getPhonebookAccessPermission\")) {\n                return BluetoothDevice.ACCESS_UNKNOWN;\n            }\n\n            return service.getDeviceAccessFromPrefs(device, PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE);\n        }\n\n        @Override\n        public void setPhonebookAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setPhonebookAccessPermission(device, value, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setPhonebookAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.setPhonebookAccessPermission(device, value);\n            return true;\n        }\n\n        @Override\n        public void getMessageAccessPermission(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getMessageAccessPermission(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getMessageAccessPermission(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getMessageAccessPermission\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getMessageAccessPermission\")) {\n                return BluetoothDevice.ACCESS_UNKNOWN;\n            }\n\n            return service.getDeviceAccessFromPrefs(device, MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE);\n        }\n\n        @Override\n        public void setMessageAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setMessageAccessPermission(device, value, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setMessageAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.setMessageAccessPermission(device, value);\n            return true;\n        }\n\n        @Override\n        public void getSimAccessPermission(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getSimAccessPermission(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getSimAccessPermission(\n                BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getSimAccessPermission\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getSimAccessPermission\")) {\n                return BluetoothDevice.ACCESS_UNKNOWN;\n            }\n\n            return service.getDeviceAccessFromPrefs(device, SIM_ACCESS_PERMISSION_PREFERENCE_FILE);\n        }\n\n        @Override\n        public void setSimAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setSimAccessPermission(device, value, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setSimAccessPermission(BluetoothDevice device, int value,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.setSimAccessPermission(device, value);\n            return true;\n        }\n\n        @Override\n        public IBluetoothSocketManager getSocketManager() {\n            AdapterService service = getService();\n            if (service == null) {\n                return null;\n            }\n\n            return IBluetoothSocketManager.Stub.asInterface(service.mBluetoothSocketManagerBinder);\n        }\n\n        @Override\n        public void sdpSearch(BluetoothDevice device, ParcelUuid uuid, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(sdpSearch(device, uuid, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean sdpSearch(\n                BluetoothDevice device, ParcelUuid uuid, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"sdpSearch\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService sdpSearch\")) {\n                return false;\n            }\n\n            if (service.mSdpManager == null) {\n                return false;\n            }\n            service.mSdpManager.sdpSearch(device, uuid);\n            return true;\n        }\n\n        @Override\n        public void getBatteryLevel(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getBatteryLevel(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getBatteryLevel(BluetoothDevice device, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !callerIsSystemOrActiveUser(TAG, \"getBatteryLevel\")\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService getBatteryLevel\")) {\n                return BluetoothDevice.BATTERY_LEVEL_UNKNOWN;\n            }\n\n            DeviceProperties deviceProp = service.mRemoteDevices.getDeviceProperties(device);\n            if (deviceProp == null) {\n                return BluetoothDevice.BATTERY_LEVEL_UNKNOWN;\n            }\n            return deviceProp.getBatteryLevel();\n        }\n\n        @Override\n        public void getMaxConnectedAudioDevices(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getMaxConnectedAudioDevices(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getMaxConnectedAudioDevices(AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService getMaxConnectedAudioDevices\")) {\n                return -1;\n            }\n\n            return service.getMaxConnectedAudioDevices();\n        }\n\n        //@Override\n        @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)\n        public void isA2dpOffloadEnabled(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isA2dpOffloadEnabled(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isA2dpOffloadEnabled(AttributionSource attributionSource) {\n            // don't check caller, may be called from system UI\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, attributionSource, \"AdapterService isA2dpOffloadEnabled\")) {\n                return false;\n            }\n\n            return service.isA2dpOffloadEnabled();\n        }\n\n        @Override\n        public void factoryReset(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(factoryReset(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        boolean factoryReset(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (service.mDatabaseManager != null) {\n                service.mDatabaseManager.factoryReset();\n            }\n\n            if (service.mBluetoothKeystoreService != null) {\n                service.mBluetoothKeystoreService.factoryReset();\n            }\n\n            return service.factoryResetNative();\n        }\n\n        @Override\n        public void registerBluetoothConnectionCallback(IBluetoothConnectionCallback callback,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(registerBluetoothConnectionCallback(callback, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean registerBluetoothConnectionCallback(IBluetoothConnectionCallback callback,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            service.mBluetoothConnectionCallbacks.add(callback);\n            return true;\n        }\n\n        @Override\n        public void unregisterBluetoothConnectionCallback(IBluetoothConnectionCallback callback,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(unregisterBluetoothConnectionCallback(callback, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean unregisterBluetoothConnectionCallback(\n                IBluetoothConnectionCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.mBluetoothConnectionCallbacks.remove(callback);\n        }\n\n        @Override\n        public void registerCallback(IBluetoothCallback callback, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                registerCallback(callback, source);\n                receiver.send(null);\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        void registerCallback(IBluetoothCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.mCallbacks.register(callback);\n        }\n\n        @Override\n        public void unregisterCallback(IBluetoothCallback callback, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                unregisterCallback(callback, source);\n                receiver.send(null);\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        void unregisterCallback(IBluetoothCallback callback, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null || service.mCallbacks == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.mCallbacks.unregister(callback);\n        }\n\n        @Override\n        public void isMultiAdvertisementSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isMultiAdvertisementSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isMultiAdvertisementSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            int val = service.mAdapterProperties.getNumOfAdvertisementInstancesSupported();\n            return val >= MIN_ADVT_INSTANCES_FOR_MA;\n        }\n\n        /**\n         * This method has an associated binder cache.  The invalidation\n         * methods must be changed if the logic behind this method changes.\n         */\n        @Override\n        public void isOffloadedFilteringSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isOffloadedFilteringSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isOffloadedFilteringSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            int val = service.getNumOfOffloadedScanFilterSupported();\n            return val >= MIN_OFFLOADED_FILTERS;\n        }\n\n        @Override\n        public void isOffloadedScanBatchingSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isOffloadedScanBatchingSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isOffloadedScanBatchingSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            int val = service.getOffloadedScanResultStorage();\n            return val >= MIN_OFFLOADED_SCAN_STORAGE_BYTES;\n        }\n\n        @Override\n        public void isLe2MPhySupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLe2MPhySupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isLe2MPhySupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.isLe2MPhySupported();\n        }\n\n        @Override\n        public void isLeCodedPhySupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLeCodedPhySupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isLeCodedPhySupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.isLeCodedPhySupported();\n        }\n\n        @Override\n        public void isLeExtendedAdvertisingSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLeExtendedAdvertisingSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isLeExtendedAdvertisingSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.isLeExtendedAdvertisingSupported();\n        }\n\n        @Override\n        public void isLePeriodicAdvertisingSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLePeriodicAdvertisingSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isLePeriodicAdvertisingSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.isLePeriodicAdvertisingSupported();\n        }\n\n        @Override\n        public void isLeAudioSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLeAudioSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int isLeAudioSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n\n            HashSet<Class> supportedProfileServices =\n                    new HashSet<Class>(Arrays.asList(Config.getSupportedProfiles()));\n            HashSet<Class> leAudioUnicastProfiles = Config.geLeAudioUnicastProfiles();\n\n            if (supportedProfileServices.containsAll(leAudioUnicastProfiles)) {\n                return BluetoothStatusCodes.FEATURE_SUPPORTED;\n            }\n\n            return BluetoothStatusCodes.FEATURE_NOT_SUPPORTED;\n        }\n\n        @Override\n        public void isLeAudioBroadcastSourceSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLeAudioBroadcastSourceSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int isLeAudioBroadcastSourceSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n\n            if (service.isLeAudioBroadcastSourceSupported()) {\n                return BluetoothStatusCodes.FEATURE_SUPPORTED;\n            }\n\n            return BluetoothStatusCodes.FEATURE_NOT_SUPPORTED;\n        }\n\n        @Override\n        public void isLeAudioBroadcastAssistantSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isLeAudioBroadcastAssistantSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        public int isLeAudioBroadcastAssistantSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n            }\n\n            HashSet<Class> supportedProfileServices =\n                    new HashSet<Class>(Arrays.asList(Config.getSupportedProfiles()));\n\n            if (supportedProfileServices.contains(BassClientService.class)) {\n                return BluetoothStatusCodes.FEATURE_SUPPORTED;\n            }\n\n            return BluetoothStatusCodes.FEATURE_NOT_SUPPORTED;\n        }\n\n        @Override\n        public void getLeMaximumAdvertisingDataLength(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getLeMaximumAdvertisingDataLength());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private int getLeMaximumAdvertisingDataLength() {\n            AdapterService service = getService();\n            if (service == null) {\n                return 0;\n            }\n\n            return service.getLeMaximumAdvertisingDataLength();\n        }\n\n        @Override\n        public void isActivityAndEnergyReportingSupported(SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(isActivityAndEnergyReportingSupported());\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean isActivityAndEnergyReportingSupported() {\n            AdapterService service = getService();\n            if (service == null) {\n                return false;\n            }\n\n            return service.mAdapterProperties.isActivityAndEnergyReportingSupported();\n        }\n\n        @Override\n        public void reportActivityInfo(AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(reportActivityInfo(source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private BluetoothActivityEnergyInfo reportActivityInfo(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return null;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.reportActivityInfo();\n        }\n\n        @Override\n        public void registerMetadataListener(IBluetoothMetadataListener listener,\n                BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(registerMetadataListener(listener, device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean registerMetadataListener(IBluetoothMetadataListener listener,\n                BluetoothDevice device, AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (service.mMetadataListeners == null) {\n                return false;\n            }\n            ArrayList<IBluetoothMetadataListener> list = service.mMetadataListeners.get(device);\n            if (list == null) {\n                list = new ArrayList<>();\n            } else if (list.contains(listener)) {\n                // The device is already registered with this listener\n                return true;\n            }\n            list.add(listener);\n            service.mMetadataListeners.put(device, list);\n            return true;\n        }\n\n        @Override\n        public void unregisterMetadataListener(BluetoothDevice device, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(unregisterMetadataListener(device, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean unregisterMetadataListener(BluetoothDevice device,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (service.mMetadataListeners == null) {\n                return false;\n            }\n            if (service.mMetadataListeners.containsKey(device)) {\n                service.mMetadataListeners.remove(device);\n            }\n            return true;\n        }\n\n        @Override\n        public void setMetadata(BluetoothDevice device, int key, byte[] value,\n                AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(setMetadata(device, key, value, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private boolean setMetadata(BluetoothDevice device, int key, byte[] value,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return false;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            if (value.length > BluetoothDevice.METADATA_MAX_LENGTH) {\n                return false;\n            }\n            return service.mDatabaseManager.setCustomMeta(device, key, value);\n        }\n\n        @Override\n        public void getMetadata(BluetoothDevice device, int key, AttributionSource source,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(getMetadata(device, key, source));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        private byte[] getMetadata(BluetoothDevice device, int key,\n                AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return null;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            return service.mDatabaseManager.getCustomMeta(device, key);\n        }\n\n        @Override\n        public void requestActivityInfo(IBluetoothActivityEnergyInfoListener listener,\n                    AttributionSource source) {\n            BluetoothActivityEnergyInfo info = reportActivityInfo(source);\n            try {\n                listener.onBluetoothActivityEnergyInfoAvailable(info);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"onBluetoothActivityEnergyInfo: RemoteException\", e);\n            }\n        }\n\n        @Override\n        public void onLeServiceUp(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                onLeServiceUp(source);\n                receiver.send(null);\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        void onLeServiceUp(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.mAdapterStateMachine.sendMessage(AdapterState.USER_TURN_ON);\n        }\n\n        @Override\n        public void onBrEdrDown(AttributionSource source, SynchronousResultReceiver receiver) {\n            try {\n                onBrEdrDown(source);\n                receiver.send(null);\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @VisibleForTesting\n        void onBrEdrDown(AttributionSource source) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(service, source, TAG)) {\n                return;\n            }\n\n            enforceBluetoothPrivilegedPermission(service);\n\n            service.mAdapterStateMachine.sendMessage(AdapterState.BLE_TURN_OFF);\n        }\n\n        @Override\n        public void dump(FileDescriptor fd, String[] args) {\n            PrintWriter writer = new PrintWriter(new FileOutputStream(fd));\n            AdapterService service = getService();\n            if (service == null) {\n                return;\n            }\n\n            enforceDumpPermission(service);\n\n            service.dump(fd, writer, args);\n            writer.close();\n        }\n\n        @Override\n        public void allowLowLatencyAudio(boolean allowed, BluetoothDevice device,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(allowLowLatencyAudio(allowed, device));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @RequiresPermission(allOf = {\n                android.Manifest.permission.BLUETOOTH_CONNECT,\n                android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n        })\n        private boolean allowLowLatencyAudio(boolean allowed, BluetoothDevice device) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, Utils.getCallingAttributionSource(service),\n                                \"AdapterService allowLowLatencyAudio\")) {\n                return false;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.allowLowLatencyAudio(allowed, device);\n        }\n\n        @Override\n        public void startRfcommListener(String name, ParcelUuid uuid, PendingIntent pendingIntent,\n                AttributionSource attributionSource, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(startRfcommListener(name, uuid, pendingIntent, attributionSource));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @RequiresPermission(allOf = {\n                android.Manifest.permission.BLUETOOTH_CONNECT,\n                android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n        })\n        private int startRfcommListener(\n                String name,\n                ParcelUuid uuid,\n                PendingIntent pendingIntent,\n                AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService startRfcommListener\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.startRfcommListener(name, uuid, pendingIntent, attributionSource);\n        }\n\n        @Override\n        public void stopRfcommListener(ParcelUuid uuid, AttributionSource attributionSource,\n                SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(stopRfcommListener(uuid, attributionSource));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @RequiresPermission(allOf = {\n                android.Manifest.permission.BLUETOOTH_CONNECT,\n                android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n        })\n        private int stopRfcommListener(ParcelUuid uuid, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource, \"AdapterService stopRfcommListener\")) {\n                return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ALLOWED;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.stopRfcommListener(uuid, attributionSource);\n        }\n\n        @Override\n        public void retrievePendingSocketForServiceRecord(ParcelUuid uuid,\n                AttributionSource attributionSource, SynchronousResultReceiver receiver) {\n            try {\n                receiver.send(retrievePendingSocketForServiceRecord(uuid, attributionSource));\n            } catch (RuntimeException e) {\n                receiver.propagateException(e);\n            }\n        }\n        @RequiresPermission(allOf = {\n                android.Manifest.permission.BLUETOOTH_CONNECT,\n                android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n        })\n        private IncomingRfcommSocketInfo retrievePendingSocketForServiceRecord(\n                ParcelUuid uuid, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null\n                    || !Utils.checkCallerIsSystemOrActiveUser(TAG)\n                    || !Utils.checkConnectPermissionForDataDelivery(\n                            service, attributionSource,\n                            \"AdapterService retrievePendingSocketForServiceRecord\")) {\n                return null;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            return service.retrievePendingSocketForServiceRecord(uuid, attributionSource);\n        }\n\n        @Override\n        public void setForegroundUserId(int userId, AttributionSource attributionSource) {\n            AdapterService service = getService();\n            if (service == null || !Utils.checkConnectPermissionForDataDelivery(\n                    service, Utils.getCallingAttributionSource(mService),\n                    \"AdapterService setForegroundUserId\")) {\n                return;\n            }\n            enforceBluetoothPrivilegedPermission(service);\n            Utils.setForegroundUserId(userId);\n        }\n    }\n\n    // ----API Methods--------\n\n    public boolean isEnabled() {\n        return getState() == BluetoothAdapter.STATE_ON;\n    }\n\n    public int getState() {\n        if (mAdapterProperties != null) {\n            return mAdapterProperties.getState();\n        }\n        return BluetoothAdapter.STATE_OFF;\n    }\n\n    public synchronized boolean enable(boolean quietMode) {\n        // Enforce the user restriction for disallowing Bluetooth if it was set.\n        if (mUserManager.hasUserRestrictionForUser(UserManager.DISALLOW_BLUETOOTH,\n                    UserHandle.SYSTEM)) {\n            debugLog(\"enable() called when Bluetooth was disallowed\");\n            return false;\n        }\n\n        debugLog(\"enable() - Enable called with quiet mode status =  \" + quietMode);\n        mQuietmode = quietMode;\n        mAdapterStateMachine.sendMessage(AdapterState.BLE_TURN_ON);\n        return true;\n    }\n\n    boolean disable() {\n        debugLog(\"disable() called with mRunningProfiles.size() = \" + mRunningProfiles.size());\n        mAdapterStateMachine.sendMessage(AdapterState.USER_TURN_OFF);\n        return true;\n    }\n\n    public String getName() {\n        return mAdapterProperties.getName();\n    }\n\n    public int getNameLengthForAdvertise() {\n        return mAdapterProperties.getName().length();\n    }\n\n    private static boolean isValidIoCapability(int capability) {\n        if (capability < 0 || capability >= BluetoothAdapter.IO_CAPABILITY_MAX) {\n            Log.e(TAG, \"Invalid IO capability value - \" + capability);\n            return false;\n        }\n\n        return true;\n    }\n\n    ArrayList<DiscoveringPackage> getDiscoveringPackages() {\n        return mDiscoveringPackages;\n    }\n\n    void clearDiscoveringPackages() {\n        synchronized (mDiscoveringPackages) {\n            mDiscoveringPackages.clear();\n        }\n    }\n\n    boolean startDiscovery(AttributionSource attributionSource) {\n        UserHandle callingUser = Binder.getCallingUserHandle();\n        debugLog(\"startDiscovery\");\n        String callingPackage = attributionSource.getPackageName();\n        mAppOps.checkPackage(Binder.getCallingUid(), callingPackage);\n        boolean isQApp = Utils.checkCallerTargetSdk(this, callingPackage, Build.VERSION_CODES.Q);\n        boolean hasDisavowedLocation =\n                Utils.hasDisavowedLocationForScan(this, attributionSource, mTestModeEnabled);\n        String permission = null;\n        if (Utils.checkCallerHasNetworkSettingsPermission(this)) {\n            permission = android.Manifest.permission.NETWORK_SETTINGS;\n        } else if (Utils.checkCallerHasNetworkSetupWizardPermission(this)) {\n            permission = android.Manifest.permission.NETWORK_SETUP_WIZARD;\n        } else if (!hasDisavowedLocation) {\n            if (isQApp) {\n                if (!Utils.checkCallerHasFineLocation(this, attributionSource, callingUser)) {\n                    return false;\n                }\n                permission = android.Manifest.permission.ACCESS_FINE_LOCATION;\n            } else {\n                if (!Utils.checkCallerHasCoarseLocation(this, attributionSource, callingUser)) {\n                    return false;\n                }\n                permission = android.Manifest.permission.ACCESS_COARSE_LOCATION;\n            }\n        }\n\n        synchronized (mDiscoveringPackages) {\n            mDiscoveringPackages.add(\n                    new DiscoveringPackage(callingPackage, permission, hasDisavowedLocation));\n        }\n        return startDiscoveryNative();\n    }\n\n    /**\n     * Same as API method {@link BluetoothAdapter#getBondedDevices()}\n     *\n     * @return array of bonded {@link BluetoothDevice} or null on error\n     */\n    public BluetoothDevice[] getBondedDevices() {\n        return mAdapterProperties.getBondedDevices();\n    }\n\n    /**\n     * Get the database manager to access Bluetooth storage\n     *\n     * @return {@link DatabaseManager} or null on error\n     */\n    @VisibleForTesting\n    public DatabaseManager getDatabase() {\n        return mDatabaseManager;\n    }\n\n    public byte[] getByteIdentityAddress(BluetoothDevice device) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp != null && deviceProp.isConsolidated()) {\n            return Utils.getBytesFromAddress(deviceProp.getIdentityAddress());\n        } else {\n            return Utils.getByteAddress(device);\n        }\n    }\n\n    public BluetoothDevice getDeviceFromByte(byte[] address) {\n        BluetoothDevice device = mRemoteDevices.getDevice(address);\n        if (device == null) {\n            device = BluetoothAdapter.getDefaultAdapter().getRemoteDevice(address);\n        }\n        return device;\n    }\n\n    public String getIdentityAddress(String address) {\n        BluetoothDevice device = BluetoothAdapter.getDefaultAdapter().getRemoteDevice(address.toUpperCase());\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp != null && deviceProp.isConsolidated()) {\n            return deviceProp.getIdentityAddress();\n        } else {\n            return address;\n        }\n    }\n\n    private class CallerInfo {\n        public String callerPackageName;\n        public UserHandle user;\n    }\n\n    boolean createBond(BluetoothDevice device, int transport, OobData remoteP192Data,\n            OobData remoteP256Data, String callingPackage) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp != null && deviceProp.getBondState() != BluetoothDevice.BOND_NONE) {\n            return false;\n        }\n\n        if (!isPackageNameAccurate(this, callingPackage, Binder.getCallingUid())) {\n            return false;\n        }\n\n        CallerInfo createBondCaller = new CallerInfo();\n        createBondCaller.callerPackageName = callingPackage;\n        createBondCaller.user = Binder.getCallingUserHandle();\n        mBondAttemptCallerInfo.put(device.getAddress(), createBondCaller);\n\n        mRemoteDevices.setBondingInitiatedLocally(Utils.getByteAddress(device));\n\n        // Pairing is unreliable while scanning, so cancel discovery\n        // Note, remove this when native stack improves\n        cancelDiscoveryNative();\n\n        Message msg = mBondStateMachine.obtainMessage(BondStateMachine.CREATE_BOND);\n        msg.obj = device;\n        msg.arg1 = transport;\n\n        Bundle remoteOobDatasBundle = new Bundle();\n        boolean setData = false;\n        if (remoteP192Data != null) {\n            remoteOobDatasBundle.putParcelable(BondStateMachine.OOBDATAP192, remoteP192Data);\n            setData = true;\n        }\n        if (remoteP256Data != null) {\n            remoteOobDatasBundle.putParcelable(BondStateMachine.OOBDATAP256, remoteP256Data);\n            setData = true;\n        }\n        if (setData) {\n            msg.setData(remoteOobDatasBundle);\n        }\n        mBondStateMachine.sendMessage(msg);\n        return true;\n    }\n\n    private final ArrayDeque<IBluetoothOobDataCallback> mOobDataCallbackQueue =\n            new ArrayDeque<>();\n\n    /**\n     * Fetches the local OOB data to give out to remote.\n     *\n     * @param transport - specify data transport.\n     * @param callback - callback used to receive the requested {@link OobData}; null will be\n     * ignored silently.\n     *\n     * @hide\n     */\n    public synchronized void generateLocalOobData(int transport,\n            IBluetoothOobDataCallback callback) {\n        if (callback == null) {\n            Log.e(TAG, \"'callback' argument must not be null!\");\n            return;\n        }\n        if (mOobDataCallbackQueue.peek() != null) {\n            try {\n                callback.onError(BluetoothStatusCodes.ERROR_ANOTHER_ACTIVE_OOB_REQUEST);\n                return;\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Failed to make callback\", e);\n            }\n        }\n        mOobDataCallbackQueue.offer(callback);\n        generateLocalOobDataNative(transport);\n    }\n\n    /* package */ synchronized void notifyOobDataCallback(int transport, OobData oobData) {\n        if (mOobDataCallbackQueue.peek() == null) {\n            Log.e(TAG, \"Failed to make callback, no callback exists\");\n            return;\n        }\n        if (oobData == null) {\n            try {\n                mOobDataCallbackQueue.poll().onError(BluetoothStatusCodes.ERROR_UNKNOWN);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Failed to make callback\", e);\n            }\n        } else {\n            try {\n                mOobDataCallbackQueue.poll().onOobData(transport, oobData);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Failed to make callback\", e);\n            }\n        }\n    }\n\n    public boolean isQuietModeEnabled() {\n        debugLog(\"isQuietModeEnabled() - Enabled = \" + mQuietmode);\n        return mQuietmode;\n    }\n\n    public void updateUuids() {\n        debugLog(\"updateUuids() - Updating UUIDs for bonded devices\");\n        BluetoothDevice[] bondedDevices = getBondedDevices();\n        if (bondedDevices == null) {\n            return;\n        }\n\n        for (BluetoothDevice device : bondedDevices) {\n            mRemoteDevices.updateUuids(device);\n        }\n    }\n\n    /**\n     * Update device UUID changed to {@link BondStateMachine}\n     *\n     * @param device remote device of interest\n     */\n    public void deviceUuidUpdated(BluetoothDevice device) {\n        // Notify BondStateMachine for SDP complete / UUID changed.\n        Message msg = mBondStateMachine.obtainMessage(BondStateMachine.UUID_UPDATE);\n        msg.obj = device;\n        mBondStateMachine.sendMessage(msg);\n    }\n\n    /**\n     * Get the bond state of a particular {@link BluetoothDevice}\n     *\n     * @param device remote device of interest\n     * @return bond state <p>Possible values are\n     * {@link BluetoothDevice#BOND_NONE},\n     * {@link BluetoothDevice#BOND_BONDING},\n     * {@link BluetoothDevice#BOND_BONDED}.\n     */\n    @VisibleForTesting\n    public int getBondState(BluetoothDevice device) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp == null) {\n            return BluetoothDevice.BOND_NONE;\n        }\n        return deviceProp.getBondState();\n    }\n\n    int getConnectionState(BluetoothDevice device) {\n        return getConnectionStateNative(getBytesFromAddress(device.getAddress()));\n    }\n\n    /**\n     * Checks whether the device was recently associated with the comapnion app that called\n     * {@link BluetoothDevice#createBond}. This allows these devices to skip the pairing dialog if\n     * their pairing variant is {@link BluetoothDevice#PAIRING_VARIANT_CONSENT}.\n     *\n     * @param device the bluetooth device that is being bonded\n     * @return true if it was recently associated and we can bypass the dialog, false otherwise\n     */\n    public boolean canBondWithoutDialog(BluetoothDevice device) {\n        if (mBondAttemptCallerInfo.containsKey(device.getAddress())) {\n            CallerInfo bondCallerInfo = mBondAttemptCallerInfo.get(device.getAddress());\n\n            return mCompanionDeviceManager.canPairWithoutPrompt(bondCallerInfo.callerPackageName,\n                    device.getAddress(), bondCallerInfo.user);\n        }\n        return false;\n    }\n\n    /**\n     * Sets device as the active devices for the profiles passed into the function\n     *\n     * @param device is the remote bluetooth device\n     * @param profiles is a constant that references for which profiles we'll be setting the remote\n     *                 device as our active device. One of the following:\n     *                 {@link BluetoothAdapter#ACTIVE_DEVICE_AUDIO},\n     *                 {@link BluetoothAdapter#ACTIVE_DEVICE_PHONE_CALL}\n     *                 {@link BluetoothAdapter#ACTIVE_DEVICE_ALL}\n     * @return false if profiles value is not one of the constants we accept, true otherwise\n     */\n    @RequiresPermission(allOf = {\n            android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n            android.Manifest.permission.MODIFY_PHONE_STATE,\n    })\n    public boolean setActiveDevice(BluetoothDevice device, @ActiveDeviceUse int profiles) {\n        boolean setA2dp = false;\n        boolean setHeadset = false;\n\n        // Determine for which profiles we want to set device as our active device\n        switch(profiles) {\n            case BluetoothAdapter.ACTIVE_DEVICE_AUDIO:\n                setA2dp = true;\n                break;\n            case BluetoothAdapter.ACTIVE_DEVICE_PHONE_CALL:\n                setHeadset = true;\n                break;\n            case BluetoothAdapter.ACTIVE_DEVICE_ALL:\n                setA2dp = true;\n                setHeadset = true;\n                break;\n            default:\n                return false;\n        }\n\n        if (mLeAudioService != null && (device == null\n                || mLeAudioService.getConnectionPolicy(device)\n                == BluetoothProfile.CONNECTION_POLICY_ALLOWED)) {\n            Log.i(TAG, \"setActiveDevice: Setting active Le Audio device \" + device);\n            mLeAudioService.setActiveDevice(device);\n        }\n\n        if (setA2dp && mA2dpService != null && (device == null\n                || mA2dpService.getConnectionPolicy(device)\n                == BluetoothProfile.CONNECTION_POLICY_ALLOWED)) {\n            Log.i(TAG, \"setActiveDevice: Setting active A2dp device \" + device);\n            mA2dpService.setActiveDevice(device);\n        }\n\n        if (mHearingAidService != null && (device == null\n                || mHearingAidService.getConnectionPolicy(device)\n                == BluetoothProfile.CONNECTION_POLICY_ALLOWED)) {\n            Log.i(TAG, \"setActiveDevice: Setting active Hearing Aid \" + device);\n            mHearingAidService.setActiveDevice(device);\n        }\n\n        if (setHeadset && mHeadsetService != null && (device == null\n                || mHeadsetService.getConnectionPolicy(device)\n                == BluetoothProfile.CONNECTION_POLICY_ALLOWED)) {\n            Log.i(TAG, \"setActiveDevice: Setting active Headset \" + device);\n            mHeadsetService.setActiveDevice(device);\n        }\n\n        return true;\n    }\n\n    /**\n     * Get the active devices for the BluetoothProfile specified\n     *\n     * @param profile is the profile from which we want the active devices.\n     *                Possible values are:\n     *                {@link BluetoothProfile#HEADSET},\n     *                {@link BluetoothProfile#A2DP},\n     *                {@link BluetoothProfile#HEARING_AID}\n     *                {@link BluetoothProfile#LE_AUDIO}\n     * @return A list of active bluetooth devices\n     */\n    @RequiresPermission(android.Manifest.permission.BLUETOOTH_PRIVILEGED)\n    public List<BluetoothDevice> getActiveDevices(@ActiveDeviceProfile int profile) {\n        List<BluetoothDevice> activeDevices = new ArrayList<>();\n\n        switch (profile) {\n            case BluetoothProfile.HEADSET:\n                if (mHeadsetService == null) {\n                    Log.e(TAG, \"getActiveDevices: HeadsetService is null\");\n                } else {\n                    BluetoothDevice device = mHeadsetService.getActiveDevice();\n                    if (device != null) {\n                        activeDevices.add(device);\n                    }\n                    Log.i(TAG, \"getActiveDevices: Headset device: \" + device);\n                }\n                break;\n            case BluetoothProfile.A2DP:\n                if (mA2dpService == null) {\n                    Log.e(TAG, \"getActiveDevices: A2dpService is null\");\n                } else {\n                    BluetoothDevice device = mA2dpService.getActiveDevice();\n                    if (device != null) {\n                        activeDevices.add(device);\n                    }\n                    Log.i(TAG, \"getActiveDevices: A2dp device: \" + device);\n                }\n                break;\n            case BluetoothProfile.HEARING_AID:\n                if (mHearingAidService == null) {\n                    Log.e(TAG, \"getActiveDevices: HearingAidService is null\");\n                } else {\n                    activeDevices = mHearingAidService.getActiveDevices();\n                    Log.i(TAG, \"getActiveDevices: Hearing Aid devices: Left[\"\n                            + activeDevices.get(0) + \"] - Right[\" + activeDevices.get(1) + \"]\");\n                }\n                break;\n            case BluetoothProfile.LE_AUDIO:\n                if (mLeAudioService == null) {\n                Log.e(TAG, \"getActiveDevices: LeAudioService is null\");\n                } else {\n                    activeDevices = mLeAudioService.getActiveDevices();\n                    Log.i(TAG, \"getActiveDevices: LeAudio devices: Out[\"\n                            + activeDevices.get(0) + \"] - In[\" + activeDevices.get(1) + \"]\");\n                }\n                break;\n            default:\n                Log.e(TAG, \"getActiveDevices: profile value is not valid\");\n        }\n        return activeDevices;\n    }\n\n    /**\n     * Attempts connection to all enabled and supported bluetooth profiles between the local and\n     * remote device\n     *\n     * @param device is the remote device with which to connect these profiles\n     * @return {@link BluetoothStatusCodes#SUCCESS} if all profiles connections are attempted, false\n     *         if an error occurred\n     */\n    @RequiresPermission(allOf = {\n            android.Manifest.permission.BLUETOOTH_PRIVILEGED,\n            android.Manifest.permission.MODIFY_PHONE_STATE,\n    })\n    public int connectAllEnabledProfiles(BluetoothDevice device) {\n        if (!profileServicesRunning()) {\n            Log.e(TAG, \"connectAllEnabledProfiles: Not all profile services running\");\n            return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n        }\n\n        // Checks if any profiles are enabled and if so, only connect enabled profiles\n        if (isAnyProfileEnabled(device)) {\n            return connectEnabledProfiles(device);\n        }\n\n        int numProfilesConnected = 0;\n        ParcelUuid[] remoteDeviceUuids = getRemoteUuids(device);\n        ParcelUuid[] localDeviceUuids = mAdapterProperties.getUuids();\n\n        // All profile toggles disabled, so connects all supported profiles\n        if (mA2dpService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.A2DP, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting A2dp\");\n            // Set connection policy also connects the profile with CONNECTION_POLICY_ALLOWED\n            mA2dpService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mA2dpSinkService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.A2DP_SINK, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting A2dp Sink\");\n            mA2dpSinkService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHeadsetService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEADSET, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Headset Profile\");\n            mHeadsetService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHeadsetClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEADSET_CLIENT, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting HFP\");\n            mHeadsetClientService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mMapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.MAP_CLIENT, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting MAP\");\n            mMapClientService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHidHostService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HID_HOST, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Hid Host Profile\");\n            mHidHostService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mPanService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.PAN, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Pan Profile\");\n            mPanService.setConnectionPolicy(device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mPbapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.PBAP_CLIENT, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Pbap\");\n            mPbapClientService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHearingAidService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HEARING_AID, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Hearing Aid Profile\");\n            mHearingAidService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mHapClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.HAP_CLIENT, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Hearing Access Client Profile\");\n            mHapClientService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mVolumeControlService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.VOLUME_CONTROL, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Volume Control Profile\");\n            mVolumeControlService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mCsipSetCoordinatorService != null\n                && isSupported(localDeviceUuids, remoteDeviceUuids,\n                        BluetoothProfile.CSIP_SET_COORDINATOR, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting Coordinated Set Profile\");\n            mCsipSetCoordinatorService.setConnectionPolicy(\n                    device, BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mLeAudioService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.LE_AUDIO, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting LeAudio profile (BAP)\");\n            mLeAudioService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n        if (mBassClientService != null && isSupported(localDeviceUuids, remoteDeviceUuids,\n                BluetoothProfile.LE_AUDIO_BROADCAST_ASSISTANT, device)) {\n            Log.i(TAG, \"connectAllEnabledProfiles: Connecting LE Broadcast Assistant Profile\");\n            mBassClientService.setConnectionPolicy(device,\n                    BluetoothProfile.CONNECTION_POLICY_ALLOWED);\n            numProfilesConnected++;\n        }\n\n        Log.i(TAG, \"connectAllEnabledProfiles: Number of Profiles Connected: \"\n                + numProfilesConnected);\n\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    /**\n     * Disconnects all enabled and supported bluetooth profiles between the local and remote device\n     *\n     * @param device is the remote device with which to disconnect these profiles\n     * @return true if all profiles successfully disconnected, false if an error occurred\n     */\n    @RequiresPermission(android.Manifest.permission.BLUETOOTH_PRIVILEGED)\n    public int disconnectAllEnabledProfiles(BluetoothDevice device) {\n        if (!profileServicesRunning()) {\n            Log.e(TAG, \"disconnectAllEnabledProfiles: Not all profile services bound\");\n            return BluetoothStatusCodes.ERROR_BLUETOOTH_NOT_ENABLED;\n        }\n\n        if (mA2dpService != null && mA2dpService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting A2dp\");\n            mA2dpService.disconnect(device);\n        }\n        if (mA2dpSinkService != null && mA2dpSinkService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting A2dp Sink\");\n            mA2dpSinkService.disconnect(device);\n        }\n        if (mHeadsetService != null && mHeadsetService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG,\n                    \"disconnectAllEnabledProfiles: Disconnecting Headset Profile\");\n            mHeadsetService.disconnect(device);\n        }\n        if (mHeadsetClientService != null && mHeadsetClientService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting HFP\");\n            mHeadsetClientService.disconnect(device);\n        }\n        if (mMapClientService != null && mMapClientService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting MAP Client\");\n            mMapClientService.disconnect(device);\n        }\n        if (mMapService != null && mMapService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting MAP\");\n            mMapService.disconnect(device);\n        }\n        if (mHidDeviceService != null && mHidDeviceService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Hid Device Profile\");\n            mHidDeviceService.disconnect(device);\n        }\n        if (mHidHostService != null && mHidHostService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Hid Host Profile\");\n            mHidHostService.disconnect(device);\n        }\n        if (mPanService != null && mPanService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Pan Profile\");\n            mPanService.disconnect(device);\n        }\n        if (mPbapClientService != null && mPbapClientService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Pbap Client\");\n            mPbapClientService.disconnect(device);\n        }\n        if (mPbapService != null && mPbapService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Pbap Server\");\n            mPbapService.disconnect(device);\n        }\n        if (mHearingAidService != null && mHearingAidService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Hearing Aid Profile\");\n            mHearingAidService.disconnect(device);\n        }\n        if (mHapClientService != null && mHapClientService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Hearing Access Profile Client\");\n            mHapClientService.disconnect(device);\n        }\n        if (mVolumeControlService != null && mVolumeControlService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Volume Control Profile\");\n            mVolumeControlService.disconnect(device);\n        }\n        if (mSapService != null && mSapService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Sap Profile\");\n            mSapService.disconnect(device);\n        }\n        if (mCsipSetCoordinatorService != null\n                && mCsipSetCoordinatorService.getConnectionState(device)\n                        == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting Coordinater Set Profile\");\n            mCsipSetCoordinatorService.disconnect(device);\n        }\n        if (mLeAudioService != null && mLeAudioService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting LeAudio profile (BAP)\");\n            mLeAudioService.disconnect(device);\n        }\n        if (mBassClientService != null && mBassClientService.getConnectionState(device)\n                == BluetoothProfile.STATE_CONNECTED) {\n            Log.i(TAG, \"disconnectAllEnabledProfiles: Disconnecting \"\n                            + \"LE Broadcast Assistant Profile\");\n            mBassClientService.disconnect(device);\n        }\n\n        return BluetoothStatusCodes.SUCCESS;\n    }\n\n    /**\n     * Same as API method {@link BluetoothDevice#getName()}\n     *\n     * @param device remote device of interest\n     * @return remote device name\n     */\n    public String getRemoteName(BluetoothDevice device) {\n        if (mRemoteDevices == null) {\n            return null;\n        }\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp == null) {\n            return null;\n        }\n        return deviceProp.getName();\n    }\n\n    /**\n     * Get UUIDs for service supported by a remote device\n     *\n     * @param device the remote device that we want to get UUIDs from\n     * @return\n     */\n    @VisibleForTesting\n    public ParcelUuid[] getRemoteUuids(BluetoothDevice device) {\n        DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);\n        if (deviceProp == null) {\n            return null;\n        }\n        return deviceProp.getUuids();\n    }\n\n    public Set<IBluetoothConnectionCallback> getBluetoothConnectionCallbacks() {\n        return mBluetoothConnectionCallbacks;\n    }\n\n    /**\n     * Converts HCI disconnect reasons to Android disconnect reasons.\n     * <p>\n     * The HCI Error Codes used for ACL disconnect reasons propagated up from native code were\n     * copied from: {@link system/bt/stack/include/hci_error_code.h}.\n     * <p>\n     * These error codes are specified and described in Bluetooth Core Spec v5.1, Vol 2, Part D.\n     *\n     * @param hciReason is the raw HCI disconnect reason from native.\n     * @return the Android disconnect reason for apps.\n     */\n    static @BluetoothAdapter.BluetoothConnectionCallback.DisconnectReason int\n            hciToAndroidDisconnectReason(int hciReason) {\n        switch(hciReason) {\n            case /*HCI_SUCCESS*/ 0x00:\n            case /*HCI_ERR_UNSPECIFIED*/ 0x1F:\n            case /*HCI_ERR_UNDEFINED*/ 0xff:\n                return BluetoothStatusCodes.ERROR_UNKNOWN;\n            case /*HCI_ERR_ILLEGAL_COMMAND*/ 0x01:\n            case /*HCI_ERR_NO_CONNECTION*/ 0x02:\n            case /*HCI_ERR_HW_FAILURE*/ 0x03:\n            case /*HCI_ERR_DIFF_TRANSACTION_COLLISION*/ 0x2A:\n            case /*HCI_ERR_ROLE_SWITCH_PENDING*/ 0x32:\n            case /*HCI_ERR_ROLE_SWITCH_FAILED*/ 0x35:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_LOCAL;\n            case /*HCI_ERR_PAGE_TIMEOUT*/ 0x04:\n            case /*HCI_ERR_CONNECTION_TOUT*/ 0x08:\n            case /*HCI_ERR_HOST_TIMEOUT*/ 0x10:\n            case /*HCI_ERR_LMP_RESPONSE_TIMEOUT*/ 0x22:\n            case /*HCI_ERR_ADVERTISING_TIMEOUT*/ 0x3C:\n            case /*HCI_ERR_CONN_FAILED_ESTABLISHMENT*/ 0x3E:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_TIMEOUT;\n            case /*HCI_ERR_AUTH_FAILURE*/ 0x05:\n            case /*HCI_ERR_KEY_MISSING*/ 0x06:\n            case /*HCI_ERR_HOST_REJECT_SECURITY*/ 0x0E:\n            case /*HCI_ERR_REPEATED_ATTEMPTS*/ 0x17:\n            case /*HCI_ERR_PAIRING_NOT_ALLOWED*/ 0x18:\n            case /*HCI_ERR_ENCRY_MODE_NOT_ACCEPTABLE*/ 0x25:\n            case /*HCI_ERR_UNIT_KEY_USED*/ 0x26:\n            case /*HCI_ERR_PAIRING_WITH_UNIT_KEY_NOT_SUPPORTED*/ 0x29:\n            case /*HCI_ERR_INSUFFCIENT_SECURITY*/ 0x2F:\n            case /*HCI_ERR_HOST_BUSY_PAIRING*/ 0x38:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_SECURITY;\n            case /*HCI_ERR_MEMORY_FULL*/ 0x07:\n            case /*HCI_ERR_MAX_NUM_OF_CONNECTIONS*/ 0x09:\n            case /*HCI_ERR_MAX_NUM_OF_SCOS*/ 0x0A:\n            case /*HCI_ERR_COMMAND_DISALLOWED*/ 0x0C:\n            case /*HCI_ERR_HOST_REJECT_RESOURCES*/ 0x0D:\n            case /*HCI_ERR_LIMIT_REACHED*/ 0x43:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_RESOURCE_LIMIT_REACHED;\n            case /*HCI_ERR_CONNECTION_EXISTS*/ 0x0B:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_CONNECTION_ALREADY_EXISTS;\n            case /*HCI_ERR_HOST_REJECT_DEVICE*/ 0x0F:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_SYSTEM_POLICY;\n            case /*HCI_ERR_ILLEGAL_PARAMETER_FMT*/ 0x12:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_BAD_PARAMETERS;\n            case /*HCI_ERR_PEER_USER*/ 0x13:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_REMOTE_REQUEST;\n            case /*HCI_ERR_CONN_CAUSE_LOCAL_HOST*/ 0x16:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_LOCAL_REQUEST;\n            case /*HCI_ERR_UNSUPPORTED_REM_FEATURE*/ 0x1A:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_REMOTE;\n            case /*HCI_ERR_UNACCEPT_CONN_INTERVAL*/ 0x3B:\n                return BluetoothStatusCodes.ERROR_DISCONNECT_REASON_BAD_PARAMETERS;\n            default:\n                Log.e(TAG, \"Invalid HCI disconnect reason: \" + hciReason);\n                return BluetoothStatusCodes.ERROR_UNKNOWN;\n        }\n    }\n\n    void logUserBondResponse(BluetoothDevice device, boolean accepted, int event) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            BluetoothStatsLog.write(BluetoothStatsLog.BLUETOOTH_BOND_STATE_CHANGED,\n                    obfuscateAddress(device), 0, device.getType(),\n                    BluetoothDevice.BOND_BONDING,\n                    event,\n                    accepted ? 0 : BluetoothDevice.UNBOND_REASON_AUTH_REJECTED);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    int getDeviceAccessFromPrefs(BluetoothDevice device, String prefFile) {\n        SharedPreferences prefs = getSharedPreferences(prefFile, Context.MODE_PRIVATE);\n        if (!prefs.contains(device.getAddress())) {\n            return BluetoothDevice.ACCESS_UNKNOWN;\n        }\n        return prefs.getBoolean(device.getAddress(), false)\n                ? BluetoothDevice.ACCESS_ALLOWED\n                : BluetoothDevice.ACCESS_REJECTED;\n    }\n\n    void setDeviceAccessFromPrefs(BluetoothDevice device, int value, String prefFile) {\n        SharedPreferences pref = getSharedPreferences(prefFile, Context.MODE_PRIVATE);\n        SharedPreferences.Editor editor = pref.edit();\n        if (value == BluetoothDevice.ACCESS_UNKNOWN) {\n            editor.remove(device.getAddress());\n        } else {\n            editor.putBoolean(device.getAddress(), value == BluetoothDevice.ACCESS_ALLOWED);\n        }\n        editor.apply();\n    }\n\n    public void setPhonebookAccessPermission(BluetoothDevice device, int value) {\n        setDeviceAccessFromPrefs(device, value, PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE);\n    }\n\n    public void setMessageAccessPermission(BluetoothDevice device, int value) {\n        setDeviceAccessFromPrefs(device, value, MESSAGE_ACCESS_PERMISSION_PREFERENCE_FILE);\n    }\n\n    public void setSimAccessPermission(BluetoothDevice device, int value) {\n        setDeviceAccessFromPrefs(device, value, SIM_ACCESS_PERMISSION_PREFERENCE_FILE);\n    }\n\n    public boolean isRpaOffloadSupported() {\n        return mAdapterProperties.isRpaOffloadSupported();\n    }\n\n    public int getNumOfOffloadedIrkSupported() {\n        return mAdapterProperties.getNumOfOffloadedIrkSupported();\n    }\n\n    public int getNumOfOffloadedScanFilterSupported() {\n        return mAdapterProperties.getNumOfOffloadedScanFilterSupported();\n    }\n\n    public int getOffloadedScanResultStorage() {\n        return mAdapterProperties.getOffloadedScanResultStorage();\n    }\n\n    public boolean isLe2MPhySupported() {\n        return mAdapterProperties.isLe2MPhySupported();\n    }\n\n    public boolean isLeCodedPhySupported() {\n        return mAdapterProperties.isLeCodedPhySupported();\n    }\n\n    public boolean isLeExtendedAdvertisingSupported() {\n        return mAdapterProperties.isLeExtendedAdvertisingSupported();\n    }\n\n    public boolean isLePeriodicAdvertisingSupported() {\n        return mAdapterProperties.isLePeriodicAdvertisingSupported();\n    }\n\n    /**\n     * Check if the LE audio broadcast source feature is supported.\n     *\n     * @return true, if the LE audio broadcast source is supported\n     */\n    public boolean isLeAudioBroadcastSourceSupported() {\n        return  BluetoothProperties.isProfileBapBroadcastSourceEnabled().orElse(false)\n                && mAdapterProperties.isLePeriodicAdvertisingSupported()\n                && mAdapterProperties.isLeExtendedAdvertisingSupported()\n                && mAdapterProperties.isLeIsochronousBroadcasterSupported();\n    }\n\n    /**\n     * Check if the LE audio broadcast assistant feature is supported.\n     *\n     * @return true, if the LE audio broadcast assistant is supported\n     */\n    public boolean isLeAudioBroadcastAssistantSupported() {\n        return mAdapterProperties.isLePeriodicAdvertisingSupported()\n            && mAdapterProperties.isLeExtendedAdvertisingSupported()\n            && (mAdapterProperties.isLePeriodicAdvertisingSyncTransferSenderSupported()\n                || mAdapterProperties.isLePeriodicAdvertisingSyncTransferRecipientSupported());\n    }\n\n    /**\n     * Check if the LE audio CIS central feature is supported.\n     *\n     * @return true, if the LE audio CIS central is supported\n     */\n    public boolean isLeConnectedIsochronousStreamCentralSupported() {\n        return mAdapterProperties.isLeConnectedIsochronousStreamCentralSupported();\n    }\n\n    public int getLeMaximumAdvertisingDataLength() {\n        return mAdapterProperties.getLeMaximumAdvertisingDataLength();\n    }\n\n    /**\n     * Get the maximum number of connected audio devices.\n     *\n     * @return the maximum number of connected audio devices\n     */\n    public int getMaxConnectedAudioDevices() {\n        return mAdapterProperties.getMaxConnectedAudioDevices();\n    }\n\n    /**\n     * Check whether A2DP offload is enabled.\n     *\n     * @return true if A2DP offload is enabled\n     */\n    public boolean isA2dpOffloadEnabled() {\n        return mAdapterProperties.isA2dpOffloadEnabled();\n    }\n\n    private BluetoothActivityEnergyInfo reportActivityInfo() {\n        if (mAdapterProperties.getState() != BluetoothAdapter.STATE_ON\n                || !mAdapterProperties.isActivityAndEnergyReportingSupported()) {\n            return null;\n        }\n\n        // Pull the data. The callback will notify mEnergyInfoLock.\n        readEnergyInfo();\n\n        synchronized (mEnergyInfoLock) {\n            try {\n                mEnergyInfoLock.wait(CONTROLLER_ENERGY_UPDATE_TIMEOUT_MILLIS);\n            } catch (InterruptedException e) {\n                // Just continue, the energy data may be stale but we won't miss anything next time\n                // we query.\n            }\n\n            final BluetoothActivityEnergyInfo info =\n                    new BluetoothActivityEnergyInfo(SystemClock.elapsedRealtime(),\n                            mStackReportedState, mTxTimeTotalMs, mRxTimeTotalMs, mIdleTimeTotalMs,\n                            mEnergyUsedTotalVoltAmpSecMicro);\n\n            // Count the number of entries that have byte counts > 0\n            int arrayLen = 0;\n            for (int i = 0; i < mUidTraffic.size(); i++) {\n                final UidTraffic traffic = mUidTraffic.valueAt(i);\n                if (traffic.getTxBytes() != 0 || traffic.getRxBytes() != 0) {\n                    arrayLen++;\n                }\n            }\n\n            // Copy the traffic objects whose byte counts are > 0\n            final List<UidTraffic> result = new ArrayList<>();\n            int putIdx = 0;\n            for (int i = 0; i < mUidTraffic.size(); i++) {\n                final UidTraffic traffic = mUidTraffic.valueAt(i);\n                if (traffic.getTxBytes() != 0 || traffic.getRxBytes() != 0) {\n                    result.add(traffic.clone());\n                }\n            }\n\n            info.setUidTraffic(result);\n\n            return info;\n        }\n    }\n\n    public int getTotalNumOfTrackableAdvertisements() {\n        return mAdapterProperties.getTotalNumOfTrackableAdvertisements();\n    }\n\n    /**\n     * Notify the UID and package name of the app, and the address of associated active device\n     *\n     * @param source The attribution source that starts the activity\n     * @param deviceAddress The address of the active device associated with the app\n     */\n    public void notifyActivityAttributionInfo(AttributionSource source, String deviceAddress) {\n        mActivityAttributionService.notifyActivityAttributionInfo(\n                source.getUid(), source.getPackageName(), deviceAddress);\n    }\n\n    private static int convertScanModeToHal(int mode) {\n        switch (mode) {\n            case BluetoothAdapter.SCAN_MODE_NONE:\n                return AbstractionLayer.BT_SCAN_MODE_NONE;\n            case BluetoothAdapter.SCAN_MODE_CONNECTABLE:\n                return AbstractionLayer.BT_SCAN_MODE_CONNECTABLE;\n            case BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE:\n                return AbstractionLayer.BT_SCAN_MODE_CONNECTABLE_DISCOVERABLE;\n        }\n        // errorLog(\"Incorrect scan mode in convertScanModeToHal\");\n        return -1;\n    }\n\n    static int convertScanModeFromHal(int mode) {\n        switch (mode) {\n            case AbstractionLayer.BT_SCAN_MODE_NONE:\n                return BluetoothAdapter.SCAN_MODE_NONE;\n            case AbstractionLayer.BT_SCAN_MODE_CONNECTABLE:\n                return BluetoothAdapter.SCAN_MODE_CONNECTABLE;\n            case AbstractionLayer.BT_SCAN_MODE_CONNECTABLE_DISCOVERABLE:\n                return BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE;\n        }\n        //errorLog(\"Incorrect scan mode in convertScanModeFromHal\");\n        return -1;\n    }\n\n    // This function is called from JNI. It allows native code to set a single wake\n    // alarm. If an alarm is already pending and a new request comes in, the alarm\n    // will be rescheduled (i.e. the previously set alarm will be cancelled).\n    private boolean setWakeAlarm(long delayMillis, boolean shouldWake) {\n        synchronized (this) {\n            if (mPendingAlarm != null) {\n                mAlarmManager.cancel(mPendingAlarm);\n            }\n\n            long wakeupTime = SystemClock.elapsedRealtime() + delayMillis;\n            int type = shouldWake ? AlarmManager.ELAPSED_REALTIME_WAKEUP\n                    : AlarmManager.ELAPSED_REALTIME;\n\n            Intent intent = new Intent(ACTION_ALARM_WAKEUP);\n            mPendingAlarm =\n                    PendingIntent.getBroadcast(this, 0, intent, PendingIntent.FLAG_ONE_SHOT\n                            | PendingIntent.FLAG_IMMUTABLE);\n            mAlarmManager.setExact(type, wakeupTime, mPendingAlarm);\n            return true;\n        }\n    }\n\n    // This function is called from JNI. It allows native code to acquire a single wake lock.\n    // If the wake lock is already held, this function returns success. Although this function\n    // only supports acquiring a single wake lock at a time right now, it will eventually be\n    // extended to allow acquiring an arbitrary number of wake locks. The current interface\n    // takes |lockName| as a parameter in anticipation of that implementation.\n    private boolean acquireWakeLock(String lockName) {\n        synchronized (this) {\n            if (mWakeLock == null) {\n                mWakeLockName = lockName;\n                mWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, lockName);\n            }\n\n            if (!mWakeLock.isHeld()) {\n                mWakeLock.acquire();\n            }\n        }\n        return true;\n    }\n\n    // This function is called from JNI. It allows native code to release a wake lock acquired\n    // by |acquireWakeLock|. If the wake lock is not held, this function returns failure.\n    // Note that the release() call is also invoked by {@link #cleanup()} so a synchronization is\n    // needed here. See the comment for |acquireWakeLock| for an explanation of the interface.\n    private boolean releaseWakeLock(String lockName) {\n        synchronized (this) {\n            if (mWakeLock == null) {\n                errorLog(\"Repeated wake lock release; aborting release: \" + lockName);\n                return false;\n            }\n\n            if (mWakeLock.isHeld()) {\n                mWakeLock.release();\n            }\n        }\n        return true;\n    }\n\n    private void energyInfoCallback(int status, int ctrlState, long txTime, long rxTime,\n            long idleTime, long energyUsed, UidTraffic[] data) throws RemoteException {\n        if (ctrlState >= BluetoothActivityEnergyInfo.BT_STACK_STATE_INVALID\n                && ctrlState <= BluetoothActivityEnergyInfo.BT_STACK_STATE_STATE_IDLE) {\n            // Energy is product of mA, V and ms. If the chipset doesn't\n            // report it, we have to compute it from time\n            if (energyUsed == 0) {\n                try {\n                    final long txMah = Math.multiplyExact(txTime, getTxCurrentMa());\n                    final long rxMah = Math.multiplyExact(rxTime, getRxCurrentMa());\n                    final long idleMah = Math.multiplyExact(idleTime, getIdleCurrentMa());\n                    energyUsed = (long) (Math.addExact(Math.addExact(txMah, rxMah), idleMah)\n                            * getOperatingVolt());\n                } catch (ArithmeticException e) {\n                    Log.wtf(TAG, \"overflow in bluetooth energy callback\", e);\n                    // Energy is already 0 if the exception was thrown.\n                }\n            }\n\n            synchronized (mEnergyInfoLock) {\n                mStackReportedState = ctrlState;\n                long totalTxTimeMs;\n                long totalRxTimeMs;\n                long totalIdleTimeMs;\n                long totalEnergy;\n                try {\n                    totalTxTimeMs = Math.addExact(mTxTimeTotalMs, txTime);\n                    totalRxTimeMs = Math.addExact(mRxTimeTotalMs, rxTime);\n                    totalIdleTimeMs = Math.addExact(mIdleTimeTotalMs, idleTime);\n                    totalEnergy = Math.addExact(mEnergyUsedTotalVoltAmpSecMicro, energyUsed);\n                } catch (ArithmeticException e) {\n                    // This could be because we accumulated a lot of time, or we got a very strange\n                    // value from the controller (more likely). Discard this data.\n                    Log.wtf(TAG, \"overflow in bluetooth energy callback\", e);\n                    totalTxTimeMs = mTxTimeTotalMs;\n                    totalRxTimeMs = mRxTimeTotalMs;\n                    totalIdleTimeMs = mIdleTimeTotalMs;\n                    totalEnergy = mEnergyUsedTotalVoltAmpSecMicro;\n                }\n\n                mTxTimeTotalMs = totalTxTimeMs;\n                mRxTimeTotalMs = totalRxTimeMs;\n                mIdleTimeTotalMs = totalIdleTimeMs;\n                mEnergyUsedTotalVoltAmpSecMicro = totalEnergy;\n\n                for (UidTraffic traffic : data) {\n                    UidTraffic existingTraffic = mUidTraffic.get(traffic.getUid());\n                    if (existingTraffic == null) {\n                        mUidTraffic.put(traffic.getUid(), traffic);\n                    } else {\n                        existingTraffic.addRxBytes(traffic.getRxBytes());\n                        existingTraffic.addTxBytes(traffic.getTxBytes());\n                    }\n                }\n                mEnergyInfoLock.notifyAll();\n            }\n        }\n\n        verboseLog(\"energyInfoCallback() status = \" + status + \"txTime = \" + txTime + \"rxTime = \"\n                + rxTime + \"idleTime = \" + idleTime + \"energyUsed = \" + energyUsed + \"ctrlState = \"\n                + ctrlState + \"traffic = \" + Arrays.toString(data));\n    }\n\n    /**\n     * Update metadata change to registered listeners\n     */\n    @VisibleForTesting\n    public void metadataChanged(String address, int key, byte[] value) {\n        BluetoothDevice device = mRemoteDevices.getDevice(Utils.getBytesFromAddress(address));\n        if (mMetadataListeners.containsKey(device)) {\n            ArrayList<IBluetoothMetadataListener> list = mMetadataListeners.get(device);\n            for (IBluetoothMetadataListener listener : list) {\n                try {\n                    listener.onMetadataChanged(device, key, value);\n                } catch (RemoteException e) {\n                    Log.w(TAG, \"RemoteException when onMetadataChanged\");\n                }\n            }\n        }\n    }\n\n    private int getIdleCurrentMa() {\n        return BluetoothProperties.getHardwareIdleCurrentMa().orElse(0);\n    }\n\n    private int getTxCurrentMa() {\n        return BluetoothProperties.getHardwareTxCurrentMa().orElse(0);\n    }\n\n    private int getRxCurrentMa() {\n        return BluetoothProperties.getHardwareRxCurrentMa().orElse(0);\n    }\n\n    private double getOperatingVolt() {\n        return BluetoothProperties.getHardwareOperatingVoltageMv().orElse(0) / 1000.0;\n    }\n\n    @VisibleForTesting\n    protected RemoteDevices getRemoteDevices() {\n        return mRemoteDevices;\n    }\n\n    @Override\n    protected void dump(FileDescriptor fd, PrintWriter writer, String[] args) {\n        if (args.length == 0) {\n            writer.println(\"Skipping dump in APP SERVICES, see bluetooth_manager section.\");\n            writer.println(\"Use --print argument for dumpsys direct from AdapterService.\");\n            return;\n        }\n\n        if (\"set-test-mode\".equals(args[0])) {\n            final boolean testModeEnabled = \"enabled\".equalsIgnoreCase(args[1]);\n            for (ProfileService profile : mRunningProfiles) {\n                profile.setTestModeEnabled(testModeEnabled);\n            }\n            mTestModeEnabled = testModeEnabled;\n            return;\n        }\n\n        verboseLog(\"dumpsys arguments, check for protobuf output: \" + TextUtils.join(\" \", args));\n        if (args[0].equals(\"--proto-bin\")) {\n            dumpMetrics(fd);\n            return;\n        }\n\n        writer.println();\n        mAdapterProperties.dump(fd, writer, args);\n        writer.println(\"mSnoopLogSettingAtEnable = \" + mSnoopLogSettingAtEnable);\n        writer.println(\"mDefaultSnoopLogSettingAtEnable = \" + mDefaultSnoopLogSettingAtEnable);\n\n        writer.println();\n        writer.println(\"Enabled Profile Services:\");\n        for (Class profile : Config.getSupportedProfiles()) {\n            writer.println(\"  \" + profile.getSimpleName());\n        }\n        writer.println();\n\n        mAdapterStateMachine.dump(fd, writer, args);\n\n        StringBuilder sb = new StringBuilder();\n        for (ProfileService profile : mRegisteredProfiles) {\n            profile.dump(sb);\n        }\n        mSilenceDeviceManager.dump(fd, writer, args);\n        mDatabaseManager.dump(writer);\n\n        writer.write(sb.toString());\n        writer.flush();\n\n        dumpNative(fd, args);\n    }\n\n    private void dumpMetrics(FileDescriptor fd) {\n        BluetoothMetricsProto.BluetoothLog.Builder metricsBuilder =\n                BluetoothMetricsProto.BluetoothLog.newBuilder();\n        byte[] nativeMetricsBytes = dumpMetricsNative();\n        debugLog(\"dumpMetrics: native metrics size is \" + nativeMetricsBytes.length);\n        if (nativeMetricsBytes.length > 0) {\n            try {\n                metricsBuilder.mergeFrom(nativeMetricsBytes);\n            } catch (InvalidProtocolBufferException ex) {\n                Log.w(TAG, \"dumpMetrics: problem parsing metrics protobuf, \" + ex.getMessage());\n                return;\n            }\n        }\n        metricsBuilder.setNumBondedDevices(getBondedDevices().length);\n        MetricsLogger.dumpProto(metricsBuilder);\n        for (ProfileService profile : mRegisteredProfiles) {\n            profile.dumpProto(metricsBuilder);\n        }\n        byte[] metricsBytes = Base64.encode(metricsBuilder.build().toByteArray(), Base64.DEFAULT);\n        debugLog(\"dumpMetrics: combined metrics size is \" + metricsBytes.length);\n        try (FileOutputStream protoOut = new FileOutputStream(fd)) {\n            protoOut.write(metricsBytes);\n        } catch (IOException e) {\n            errorLog(\"dumpMetrics: error writing combined protobuf to fd, \" + e.getMessage());\n        }\n    }\n\n    private void debugLog(String msg) {\n        if (DBG) {\n            Log.d(TAG, msg);\n        }\n    }\n\n    private void verboseLog(String msg) {\n        if (VERBOSE) {\n            Log.v(TAG, msg);\n        }\n    }\n\n    private void errorLog(String msg) {\n        Log.e(TAG, msg);\n    }\n\n    private final BroadcastReceiver mAlarmBroadcastReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            synchronized (AdapterService.this) {\n                mPendingAlarm = null;\n                alarmFiredNative();\n            }\n        }\n    };\n\n    private boolean isCommonCriteriaMode() {\n        return getSystemService(DevicePolicyManager.class).isCommonCriteriaModeEnabled(null);\n    }\n\n    @SuppressLint(\"AndroidFrameworkRequiresPermission\")\n    private void enforceBluetoothPrivilegedPermissionIfNeeded(OobData remoteP192Data,\n            OobData remoteP256Data) {\n        if (remoteP192Data != null || remoteP256Data != null) {\n            enforceBluetoothPrivilegedPermission(this);\n        }\n    }\n\n    // Boolean flags\n    private static final String GD_CORE_FLAG = \"INIT_gd_core\";\n    private static final String GD_ADVERTISING_FLAG = \"INIT_gd_advertising\";\n    private static final String GD_SCANNING_FLAG = \"INIT_gd_scanning\";\n    private static final String GD_HCI_FLAG = \"INIT_gd_hci\";\n    private static final String GD_CONTROLLER_FLAG = \"INIT_gd_controller\";\n    private static final String GD_ACL_FLAG = \"INIT_gd_acl\";\n    private static final String GD_L2CAP_FLAG = \"INIT_gd_l2cap\";\n    private static final String GD_RUST_FLAG = \"INIT_gd_rust\";\n    private static final String GD_LINK_POLICY_FLAG = \"INIT_gd_link_policy\";\n    private static final String GATT_ROBUST_CACHING_FLAG = \"INIT_gatt_robust_caching\";\n    private static final String IRK_ROTATION_FLAG = \"INIT_irk_rotation\";\n\n    /**\n     * Logging flags logic (only applies to DEBUG and VERBOSE levels):\n     * if LOG_TAG in LOGGING_DEBUG_DISABLED_FOR_TAGS_FLAG:\n     *   DO NOT LOG\n     * else if LOG_TAG in LOGGING_DEBUG_ENABLED_FOR_TAGS_FLAG:\n     *   DO LOG\n     * else if LOGGING_DEBUG_ENABLED_FOR_ALL_FLAG:\n     *   DO LOG\n     * else:\n     *   DO NOT LOG\n     */\n    private static final String LOGGING_DEBUG_ENABLED_FOR_ALL_FLAG =\n            \"INIT_logging_debug_enabled_for_all\";\n    // String flags\n    // Comma separated tags\n    private static final String LOGGING_DEBUG_ENABLED_FOR_TAGS_FLAG =\n            \"INIT_logging_debug_enabled_for_tags\";\n    private static final String LOGGING_DEBUG_DISABLED_FOR_TAGS_FLAG =\n            \"INIT_logging_debug_disabled_for_tags\";\n    private static final String BTAA_HCI_LOG_FLAG = \"INIT_btaa_hci\";\n\n    private String[] getInitFlags() {\n        ArrayList<String> initFlags = new ArrayList<>();\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_CORE_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_CORE_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_ADVERTISING_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_ADVERTISING_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_SCANNING_FLAG,\n                Config.isGdEnabledUpToScanningLayer())) {\n            initFlags.add(String.format(\"%s=%s\", GD_SCANNING_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_HCI_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_HCI_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_CONTROLLER_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_CONTROLLER_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_ACL_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_ACL_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_L2CAP_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_L2CAP_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_RUST_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_RUST_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, GD_LINK_POLICY_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GD_LINK_POLICY_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH,\n                GATT_ROBUST_CACHING_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", GATT_ROBUST_CACHING_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, IRK_ROTATION_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", IRK_ROTATION_FLAG, \"true\"));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH,\n                LOGGING_DEBUG_ENABLED_FOR_ALL_FLAG, false)) {\n            initFlags.add(String.format(\"%s=%s\", LOGGING_DEBUG_ENABLED_FOR_ALL_FLAG, \"true\"));\n        }\n        String debugLoggingEnabledTags = DeviceConfig.getString(DeviceConfig.NAMESPACE_BLUETOOTH,\n                LOGGING_DEBUG_ENABLED_FOR_TAGS_FLAG, \"\");\n        if (!debugLoggingEnabledTags.isEmpty()) {\n            initFlags.add(String.format(\"%s=%s\", LOGGING_DEBUG_ENABLED_FOR_TAGS_FLAG,\n                    debugLoggingEnabledTags));\n        }\n        String debugLoggingDisabledTags = DeviceConfig.getString(DeviceConfig.NAMESPACE_BLUETOOTH,\n                LOGGING_DEBUG_DISABLED_FOR_TAGS_FLAG, \"\");\n        if (!debugLoggingDisabledTags.isEmpty()) {\n            initFlags.add(String.format(\"%s=%s\", LOGGING_DEBUG_DISABLED_FOR_TAGS_FLAG,\n                    debugLoggingDisabledTags));\n        }\n        if (DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_BLUETOOTH, BTAA_HCI_LOG_FLAG, true)) {\n            initFlags.add(String.format(\"%s=%s\", BTAA_HCI_LOG_FLAG, \"true\"));\n        }\n        return initFlags.toArray(new String[0]);\n    }\n\n    private final Object mDeviceConfigLock = new Object();\n\n    /**\n     * Predicate that can be applied to names to determine if a device is\n     * well-known to be used for physical location.\n     */\n    @GuardedBy(\"mDeviceConfigLock\")\n    private Predicate<String> mLocationDenylistName = (v) -> false;\n\n    /**\n     * Predicate that can be applied to MAC addresses to determine if a device\n     * is well-known to be used for physical location.\n     */\n    @GuardedBy(\"mDeviceConfigLock\")\n    private Predicate<byte[]> mLocationDenylistMac = (v) -> false;\n\n    /**\n     * Predicate that can be applied to Advertising Data payloads to determine\n     * if a device is well-known to be used for physical location.\n     */\n    @GuardedBy(\"mDeviceConfigLock\")\n    private Predicate<byte[]> mLocationDenylistAdvertisingData = (v) -> false;\n\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScanQuotaCount = DeviceConfigListener.DEFAULT_SCAN_QUOTA_COUNT;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private long mScanQuotaWindowMillis = DeviceConfigListener.DEFAULT_SCAN_QUOTA_WINDOW_MILLIS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private long mScanTimeoutMillis = DeviceConfigListener.DEFAULT_SCAN_TIMEOUT_MILLIS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScanUpgradeDurationMillis =\n            DeviceConfigListener.DEFAULT_SCAN_UPGRADE_DURATION_MILLIS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScreenOffLowPowerWindowMillis =\n            ScanManager.SCAN_MODE_SCREEN_OFF_LOW_POWER_WINDOW_MS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScreenOffLowPowerIntervalMillis =\n            ScanManager.SCAN_MODE_SCREEN_OFF_LOW_POWER_INTERVAL_MS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScreenOffBalancedWindowMillis =\n            ScanManager.SCAN_MODE_SCREEN_OFF_BALANCED_WINDOW_MS;\n    @GuardedBy(\"mDeviceConfigLock\")\n    private int mScreenOffBalancedIntervalMillis =\n            ScanManager.SCAN_MODE_SCREEN_OFF_BALANCED_INTERVAL_MS;\n\n    public @NonNull Predicate<String> getLocationDenylistName() {\n        synchronized (mDeviceConfigLock) {\n            return mLocationDenylistName;\n        }\n    }\n\n    public @NonNull Predicate<byte[]> getLocationDenylistMac() {\n        synchronized (mDeviceConfigLock) {\n            return mLocationDenylistMac;\n        }\n    }\n\n    public @NonNull Predicate<byte[]> getLocationDenylistAdvertisingData() {\n        synchronized (mDeviceConfigLock) {\n            return mLocationDenylistAdvertisingData;\n        }\n    }\n\n    public static int getScanQuotaCount() {\n        if (sAdapterService == null) {\n            return DeviceConfigListener.DEFAULT_SCAN_QUOTA_COUNT;\n        }\n\n        synchronized (sAdapterService.mDeviceConfigLock) {\n            return sAdapterService.mScanQuotaCount;\n        }\n    }\n\n    public static long getScanQuotaWindowMillis() {\n        if (sAdapterService == null) {\n            return DeviceConfigListener.DEFAULT_SCAN_QUOTA_WINDOW_MILLIS;\n        }\n\n        synchronized (sAdapterService.mDeviceConfigLock) {\n            return sAdapterService.mScanQuotaWindowMillis;\n        }\n    }\n\n    public static long getScanTimeoutMillis() {\n        if (sAdapterService == null) {\n            return DeviceConfigListener.DEFAULT_SCAN_TIMEOUT_MILLIS;\n        }\n\n        synchronized (sAdapterService.mDeviceConfigLock) {\n            return sAdapterService.mScanTimeoutMillis;\n        }\n    }\n\n    /**\n     * Returns scan upgrade duration in millis.\n     */\n    public long getScanUpgradeDurationMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScanUpgradeDurationMillis;\n        }\n    }\n\n    /**\n     * Returns SCREEN_OFF_BALANCED scan window in millis.\n     */\n    public int getScreenOffBalancedWindowMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScreenOffBalancedWindowMillis;\n        }\n    }\n\n    /**\n     * Returns SCREEN_OFF_BALANCED scan interval in millis.\n     */\n    public int getScreenOffBalancedIntervalMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScreenOffBalancedIntervalMillis;\n        }\n    }\n\n    /**\n     * Returns SCREEN_OFF low power scan window in millis.\n     */\n    public int getScreenOffLowPowerWindowMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScreenOffLowPowerWindowMillis;\n        }\n    }\n\n    /**\n     * Returns SCREEN_OFF low power scan interval in millis.\n     */\n    public int getScreenOffLowPowerIntervalMillis() {\n        synchronized (mDeviceConfigLock) {\n            return mScreenOffLowPowerIntervalMillis;\n        }\n    }\n\n    private final DeviceConfigListener mDeviceConfigListener = new DeviceConfigListener();\n\n    private class DeviceConfigListener implements DeviceConfig.OnPropertiesChangedListener {\n        private static final String LOCATION_DENYLIST_NAME =\n                \"location_denylist_name\";\n        private static final String LOCATION_DENYLIST_MAC =\n                \"location_denylist_mac\";\n        private static final String LOCATION_DENYLIST_ADVERTISING_DATA =\n                \"location_denylist_advertising_data\";\n        private static final String SCAN_QUOTA_COUNT =\n                \"scan_quota_count\";\n        private static final String SCAN_QUOTA_WINDOW_MILLIS =\n                \"scan_quota_window_millis\";\n        private static final String SCAN_TIMEOUT_MILLIS =\n                \"scan_timeout_millis\";\n        private static final String SCAN_UPGRADE_DURATION_MILLIS =\n                \"scan_upgrade_duration_millis\";\n        private static final String SCREEN_OFF_LOW_POWER_WINDOW_MILLIS =\n                \"screen_off_low_power_window_millis\";\n        private static final String SCREEN_OFF_LOW_POWER_INTERVAL_MILLIS =\n                \"screen_off_low_power_interval_millis\";\n        private static final String SCREEN_OFF_BALANCED_WINDOW_MILLIS =\n                \"screen_off_balanced_window_millis\";\n        private static final String SCREEN_OFF_BALANCED_INTERVAL_MILLIS =\n                \"screen_off_balanced_interval_millis\";\n\n        /**\n         * Default denylist which matches Eddystone and iBeacon payloads.\n         */\n        private static final String DEFAULT_LOCATION_DENYLIST_ADVERTISING_DATA =\n                \"\u22860016AAFE/00FFFFFF,\u228600FF4C0002/00FFFFFFFF\";\n\n        private static final int DEFAULT_SCAN_QUOTA_COUNT = 5;\n        private static final long DEFAULT_SCAN_QUOTA_WINDOW_MILLIS = 30 * SECOND_IN_MILLIS;\n        private static final long DEFAULT_SCAN_TIMEOUT_MILLIS = 30 * MINUTE_IN_MILLIS;\n        private static final int DEFAULT_SCAN_UPGRADE_DURATION_MILLIS = (int) SECOND_IN_MILLIS * 6;\n\n        public void start() {\n            DeviceConfig.addOnPropertiesChangedListener(DeviceConfig.NAMESPACE_BLUETOOTH,\n                    BackgroundThread.getExecutor(), this);\n            onPropertiesChanged(DeviceConfig.getProperties(DeviceConfig.NAMESPACE_BLUETOOTH));\n        }\n\n        @Override\n        public void onPropertiesChanged(DeviceConfig.Properties properties) {\n            synchronized (mDeviceConfigLock) {\n                final String name = properties.getString(LOCATION_DENYLIST_NAME, null);\n                mLocationDenylistName = !TextUtils.isEmpty(name)\n                        ? Pattern.compile(name).asPredicate()\n                        : (v) -> false;\n                mLocationDenylistMac = BytesMatcher\n                        .decode(properties.getString(LOCATION_DENYLIST_MAC, null));\n                mLocationDenylistAdvertisingData = BytesMatcher\n                        .decode(properties.getString(LOCATION_DENYLIST_ADVERTISING_DATA,\n                                DEFAULT_LOCATION_DENYLIST_ADVERTISING_DATA));\n                mScanQuotaCount = properties.getInt(SCAN_QUOTA_COUNT,\n                        DEFAULT_SCAN_QUOTA_COUNT);\n                mScanQuotaWindowMillis = properties.getLong(SCAN_QUOTA_WINDOW_MILLIS,\n                        DEFAULT_SCAN_QUOTA_WINDOW_MILLIS);\n                mScanTimeoutMillis = properties.getLong(SCAN_TIMEOUT_MILLIS,\n                        DEFAULT_SCAN_TIMEOUT_MILLIS);\n                mScanUpgradeDurationMillis = properties.getInt(SCAN_UPGRADE_DURATION_MILLIS,\n                        DEFAULT_SCAN_UPGRADE_DURATION_MILLIS);\n                mScreenOffLowPowerWindowMillis = properties.getInt(\n                        SCREEN_OFF_LOW_POWER_WINDOW_MILLIS,\n                        ScanManager.SCAN_MODE_SCREEN_OFF_LOW_POWER_WINDOW_MS);\n                mScreenOffLowPowerIntervalMillis = properties.getInt(\n                        SCREEN_OFF_LOW_POWER_INTERVAL_MILLIS,\n                        ScanManager.SCAN_MODE_SCREEN_OFF_LOW_POWER_INTERVAL_MS);\n                mScreenOffBalancedWindowMillis = properties.getInt(\n                        SCREEN_OFF_BALANCED_WINDOW_MILLIS,\n                        ScanManager.SCAN_MODE_SCREEN_OFF_BALANCED_WINDOW_MS);\n                mScreenOffBalancedIntervalMillis = properties.getInt(\n                        SCREEN_OFF_BALANCED_INTERVAL_MILLIS,\n                        ScanManager.SCAN_MODE_SCREEN_OFF_BALANCED_INTERVAL_MS);\n            }\n        }\n    }\n\n    /**\n     *  Obfuscate Bluetooth MAC address into a PII free ID string\n     *\n     *  @param device Bluetooth device whose MAC address will be obfuscated\n     *  @return a byte array that is unique to this MAC address on this device,\n     *          or empty byte array when either device is null or obfuscateAddressNative fails\n     */\n    public byte[] obfuscateAddress(BluetoothDevice device) {\n        if (device == null) {\n            return new byte[0];\n        }\n        return obfuscateAddressNative(Utils.getByteAddress(device));\n    }\n\n    /**\n     * Get dynamic audio buffer size supported type\n     *\n     * @return support <p>Possible values are\n     * {@link BluetoothA2dp#DYNAMIC_BUFFER_SUPPORT_NONE},\n     * {@link BluetoothA2dp#DYNAMIC_BUFFER_SUPPORT_A2DP_OFFLOAD},\n     * {@link BluetoothA2dp#DYNAMIC_BUFFER_SUPPORT_A2DP_SOFTWARE_ENCODING}.\n     */\n    public int getDynamicBufferSupport() {\n        return mAdapterProperties.getDynamicBufferSupport();\n    }\n\n    /**\n     * Get dynamic audio buffer size\n     *\n     * @return BufferConstraints\n     */\n    public BufferConstraints getBufferConstraints() {\n        return mAdapterProperties.getBufferConstraints();\n    }\n\n    /**\n     * Set dynamic audio buffer size\n     *\n     * @param codec Audio codec\n     * @param value buffer millis\n     * @return true if the settings is successful, false otherwise\n     */\n    public boolean setBufferLengthMillis(int codec, int value) {\n        return mAdapterProperties.setBufferLengthMillis(codec, value);\n    }\n\n    /**\n     *  Get an incremental id of Bluetooth metrics and log\n     *\n     *  @param device Bluetooth device\n     *  @return int of id for Bluetooth metrics and logging, 0 if the device is invalid\n     */\n    public int getMetricId(BluetoothDevice device) {\n        if (device == null) {\n            return 0;\n        }\n        return getMetricIdNative(Utils.getByteAddress(device));\n    }\n\n    /**\n     *  Allow audio low latency\n     *\n     *  @param allowed true if audio low latency is being allowed\n     *  @param device device whose audio low latency will be allowed or disallowed\n     *  @return boolean true if audio low latency is successfully allowed or disallowed\n     */\n    public boolean allowLowLatencyAudio(boolean allowed, BluetoothDevice device) {\n        return allowLowLatencyAudioNative(allowed, Utils.getByteAddress(device));\n    }\n\n    /**\n     * Sets the battery level of the remote device\n     */\n    public void setBatteryLevel(BluetoothDevice device, int batteryLevel) {\n        mRemoteDevices.updateBatteryLevel(device, batteryLevel);\n    }\n\n    static native void classInitNative();\n\n    native boolean initNative(boolean startRestricted, boolean isCommonCriteriaMode,\n            int configCompareResult, String[] initFlags, boolean isAtvDevice,\n            String userDataDirectory);\n\n    native void cleanupNative();\n\n    /*package*/\n    native boolean enableNative();\n\n    /*package*/\n    native boolean disableNative();\n\n    /*package*/\n    native boolean setAdapterPropertyNative(int type, byte[] val);\n\n    /*package*/\n    native boolean getAdapterPropertiesNative();\n\n    /*package*/\n    native boolean getAdapterPropertyNative(int type);\n\n    /*package*/\n    native boolean setAdapterPropertyNative(int type);\n\n    /*package*/\n    native boolean setDevicePropertyNative(byte[] address, int type, byte[] val);\n\n    /*package*/\n    native boolean getDevicePropertyNative(byte[] address, int type);\n\n    /*package*/\n    public native boolean createBondNative(byte[] address, int transport);\n\n    /*package*/\n    native boolean createBondOutOfBandNative(byte[] address, int transport,\n            OobData p192Data, OobData p256Data);\n\n    /*package*/\n    public native boolean removeBondNative(byte[] address);\n\n    /*package*/\n    native boolean cancelBondNative(byte[] address);\n\n    /*package*/\n    native void generateLocalOobDataNative(int transport);\n\n    /*package*/\n    native boolean sdpSearchNative(byte[] address, byte[] uuid);\n\n    /*package*/\n    native int getConnectionStateNative(byte[] address);\n\n    private native boolean startDiscoveryNative();\n\n    private native boolean cancelDiscoveryNative();\n\n    private native boolean pinReplyNative(byte[] address, boolean accept, int len, byte[] pin);\n\n    private native boolean sspReplyNative(byte[] address, int type, boolean accept, int passkey);\n\n    /*package*/\n    native boolean getRemoteServicesNative(byte[] address, int transport);\n\n    /*package*/\n    native boolean getRemoteMasInstancesNative(byte[] address);\n\n    private native int readEnergyInfo();\n\n    /*package*/\n    native boolean factoryResetNative();\n\n    private native void alarmFiredNative();\n\n    private native void dumpNative(FileDescriptor fd, String[] arguments);\n\n    private native byte[] dumpMetricsNative();\n\n    private native byte[] obfuscateAddressNative(byte[] address);\n\n    native boolean setBufferLengthMillisNative(int codec, int value);\n\n    private native int getMetricIdNative(byte[] address);\n\n    /*package*/ native int connectSocketNative(\n            byte[] address, int type, byte[] uuid, int port, int flag, int callingUid);\n\n    /*package*/ native int createSocketChannelNative(\n            int type, String serviceName, byte[] uuid, int port, int flag, int callingUid);\n\n    /*package*/ native void requestMaximumTxDataLengthNative(byte[] address);\n\n    private native boolean allowLowLatencyAudioNative(boolean allowed, byte[] address);\n\n    // Returns if this is a mock object. This is currently used in testing so that we may not call\n    // System.exit() while finalizing the object. Otherwise GC of mock objects unfortunately ends up\n    // calling finalize() which in turn calls System.exit() and the process crashes.\n    //\n    // Mock this in your testing framework to return true to avoid the mentioned behavior. In\n    // production this has no effect.\n    public boolean isMock() {\n        return false;\n    }\n}\n```"
                    }
                ]
            }
        ],
        "upstream_patch_content": "From 771aed3ea225d9ca2ef91e88f45f330ced952772 Mon Sep 17 00:00:00 2001\nFrom: Kyunglyul Hyun <klhyun@google.com>\nDate: Wed, 2 Oct 2024 03:50:00 +0000\nSubject: [PATCH] Reset permissions for not bonded device\n\nAccording to the PBAP specification,\nThe PSE user shall have to confirm at least the first Phone Book Access\nProfile connection from each new PCE.\n\nAccording to the MAP specification,\nThe MCE and MSE shall be bonded before setting up a Message Access Profile\nconnection.\n\nLet's remove the permissions when the device is unbonded.\n\nFlag: EXEMPT, security fix\nBug: 289375038\nBug: 289811388\nTest: atest BluetoothInstrumentationTests\nIgnore-AOSP-First: security fix\n\nChange-Id: I94478a4a45a434732d4bc4810da31ef45ef891af\n---\n .../com/android/bluetooth/btservice/AdapterService.java   | 8 ++++++++\n 1 file changed, 8 insertions(+)\n\ndiff --git a/android/app/src/com/android/bluetooth/btservice/AdapterService.java b/android/app/src/com/android/bluetooth/btservice/AdapterService.java\nindex 19c8aee207..3937a8e881 100644\n--- a/android/app/src/com/android/bluetooth/btservice/AdapterService.java\n+++ b/android/app/src/com/android/bluetooth/btservice/AdapterService.java\n@@ -27,6 +27,7 @@ import static android.bluetooth.BluetoothAdapter.SCAN_MODE_CONNECTABLE;\n import static android.bluetooth.BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE;\n import static android.bluetooth.BluetoothAdapter.SCAN_MODE_NONE;\n import static android.bluetooth.BluetoothDevice.BATTERY_LEVEL_UNKNOWN;\n+import static android.bluetooth.BluetoothDevice.BOND_NONE;\n import static android.bluetooth.BluetoothDevice.TRANSPORT_AUTO;\n import static android.bluetooth.IBluetoothLeAudio.LE_AUDIO_GROUP_ID_INVALID;\n import static android.text.format.DateUtils.MINUTE_IN_MILLIS;\n@@ -6121,6 +6122,13 @@ public class AdapterService extends Service {\n             mCsipSetCoordinatorService.handleBondStateChanged(device, fromState, toState);\n         }\n         mDatabaseManager.handleBondStateChanged(device, fromState, toState);\n+\n+        if (toState == BOND_NONE) {\n+            // Remove the permissions for unbonded devices\n+            setMessageAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+            setPhonebookAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+            setSimAccessPermission(device, BluetoothDevice.ACCESS_UNKNOWN);\n+        }\n     }\n \n     static int convertScanModeToHal(int mode) {\n-- \n2.39.5 (Apple Git-154)\n\n",
        "upstream_commits": [
            "771aed3ea225d9ca2ef91e88f45f330ced952772"
        ]
    },
    {
        "id": "ASB-A-364025411",
        "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-364025411",
        "severity": "Critical",
        "failures": [
            {
                "downstream_version": "13",
                "branch_used": "android13-release",
                "downstream_patch": "2fc3087b9ac3019518c6ceb8a64d181d6bb04907",
                "repo_path": "android_repos/Bluetooth",
                "result": "failure",
                "downstream_patch_content": "commit 2fc3087b9ac3019518c6ceb8a64d181d6bb04907\nAuthor: Brian Delwiche <delwiche@google.com>\nDate:   Fri Oct 4 18:23:45 2024 +0000\n\n    Fix OOB writes in gatt_sr.cc\n    \n    At various points in gatt_sr.cc, the output of the\n    gatt_tcb_get_payload_size function is used without checking for a\n    positive length.  However, in exceptional cases it is possible for the\n    channel to be closed at the time the function is called, which will lead\n    to a zero length and cause an OOB write in subsequent processing.\n    \n    Fix all of these.\n    \n    Bug: 364026473\n    Bug: 364027038\n    Bug: 364027949\n    Bug: 364025411\n    Test: m libbluetooth\n    Test: researcher POC\n    Flag: EXEMPT trivial validity checks\n    Tag: #security\n    Ignore-AOSP-First: Security\n    Merged-In: I9b30499d4aed6ab42f3cdb2c0de7df2c1a827404\n    Change-Id: I9b30499d4aed6ab42f3cdb2c0de7df2c1a827404\n\ndiff --git a/system/stack/gatt/gatt_sr.cc b/system/stack/gatt/gatt_sr.cc\nindex 6f81b90514..c61df52bc8 100644\n--- a/system/stack/gatt/gatt_sr.cc\n+++ b/system/stack/gatt/gatt_sr.cc\n@@ -734,6 +734,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n@@ -769,6 +774,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n@@ -902,6 +913,11 @@ static void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n@@ -1049,6 +1065,11 @@ static void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t* p_data) {\n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   uint16_t offset = 0;\n \n",
                "file_conflicts": [
                    {
                        "file_name": "system/stack/gatt/gatt_sr.cc",
                        "total_hunks": 4,
                        "failed_hunks": [
                            1,
                            2
                        ],
                        "inline_merge_conflicts": [
                            {
                                "hunk_number": 1,
                                "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n\n=======\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n>>>>>>> UPSTREAM PATCH (commit 7de5617f7d5266fe57c990c428621b5d4e92728a)"
                            },
                            {
                                "hunk_number": 2,
                                "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n\n=======\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n>>>>>>> UPSTREAM PATCH (commit 7de5617f7d5266fe57c990c428621b5d4e92728a)"
                            }
                        ],
                        "rej_file_content": "```diff\n--- system/stack/gatt/gatt_sr.cc\n+++ system/stack/gatt/gatt_sr.cc\n@@ -772,6 +772,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_\n \n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl, e_hdl, p_data, value);\n@@ -804,6 +809,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid, uint8_t op_cod\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n```",
                        "patch_apply_output": "patching file system/stack/gatt/gatt_sr.cc\nHunk #1 FAILED at 772.\nHunk #2 FAILED at 804.\nHunk #3 succeeded at 902 with fuzz 2 (offset -47 lines).\nHunk #4 succeeded at 1054 with fuzz 2 (offset -47 lines).\n2 out of 4 hunks FAILED -- saving rejects to file system/stack/gatt/gatt_sr.cc.rej",
                        "inline_merge_output": "patching file system/stack/gatt/gatt_sr.cc\nHunk #1 NOT MERGED at 780-789.\nHunk #2 NOT MERGED at 828-837.\nHunk #3 merged at 988-992.\nHunk #4 merged at 1145-1149.",
                        "upstream_file_content": "```cc\n/******************************************************************************\n *\n *  Copyright 2008-2012 Broadcom Corporation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at:\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n ******************************************************************************/\n\n/******************************************************************************\n *\n *  this file contains the GATT server functions\n *\n ******************************************************************************/\n\n#include <bluetooth/log.h>\n#include <com_android_bluetooth_flags.h>\n#include <string.h>\n\n#include <algorithm>\n\n#include \"gatt_int.h\"\n#include \"hardware/bt_gatt_types.h\"\n#include \"internal_include/bt_target.h\"\n#include \"l2c_api.h\"\n#include \"osi/include/allocator.h\"\n#include \"stack/arbiter/acl_arbiter.h\"\n#include \"stack/eatt/eatt.h\"\n#include \"stack/include/bt_hdr.h\"\n#include \"stack/include/bt_types.h\"\n#include \"stack/include/btm_client_interface.h\"\n#include \"stack/include/l2cdefs.h\"\n#include \"types/bluetooth/uuid.h\"\n\n#define GATT_MTU_REQ_MIN_LEN 2\n#define L2CAP_PKT_OVERHEAD 4\n\nusing bluetooth::Uuid;\nusing bluetooth::eatt::EattChannel;\nusing bluetooth::eatt::EattExtension;\nusing namespace bluetooth;\n\n/*******************************************************************************\n *\n * Function         gatt_sr_enqueue_cmd\n *\n * Description      This function enqueue the request from client which needs a\n *                  application response, and update the transaction ID.\n *\n * Returns          void\n *\n ******************************************************************************/\nuint32_t gatt_sr_enqueue_cmd(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code, uint16_t handle) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel = EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n    if (channel == nullptr) {\n      log::warn(\"{}, cid 0x{:02x} already disconnected\", tcb.peer_bda, cid);\n      return 0;\n    }\n\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  uint32_t trans_id = 0;\n\n  p_cmd->cid = cid;\n\n  if ((p_cmd->op_code == 0) || (op_code == GATT_HANDLE_VALUE_CONF)) /* no pending request */\n  {\n    if (op_code == GATT_CMD_WRITE || op_code == GATT_SIGN_CMD_WRITE || op_code == GATT_REQ_MTU ||\n        op_code == GATT_HANDLE_VALUE_CONF) {\n      trans_id = ++tcb.trans_id;\n    } else {\n      p_cmd->trans_id = ++tcb.trans_id;\n      p_cmd->op_code = op_code;\n      p_cmd->handle = handle;\n      p_cmd->status = GATT_NOT_FOUND;\n      tcb.trans_id %= GATT_TRANS_ID_MAX;\n      trans_id = p_cmd->trans_id;\n    }\n  }\n\n  return trans_id;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_cmd_empty\n *\n * Description      This function checks if the server command queue is empty.\n *\n * Returns          true if empty, false if there is pending command.\n *\n ******************************************************************************/\nbool gatt_sr_cmd_empty(tGATT_TCB& tcb, uint16_t cid) {\n  if (cid == tcb.att_lcid) {\n    return tcb.sr_cmd.op_code == 0;\n  }\n\n  EattChannel* channel = EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n  if (channel == nullptr) {\n    log::warn(\"{}, cid 0x{:02x} already disconnected\", tcb.peer_bda, cid);\n    return false;\n  }\n\n  return channel->server_outstanding_cmd_.op_code == 0;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_dequeue_sr_cmd\n *\n * Description      This function dequeue the request from command queue.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_dequeue_sr_cmd(tGATT_TCB& tcb, uint16_t cid) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel = EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n    if (channel == nullptr) {\n      log::warn(\"{}, cid 0x{:02x} already disconnected\", tcb.peer_bda, cid);\n      return;\n    }\n\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  /* Double check in case any buffers are queued */\n  log::verbose(\"gatt_dequeue_sr_cmd cid: 0x{:x}\", cid);\n  if (p_cmd->p_rsp_msg) {\n    log::error(\"free tcb.sr_cmd.p_rsp_msg = {}\", fmt::ptr(p_cmd->p_rsp_msg));\n  }\n  osi_free_and_reset((void**)&p_cmd->p_rsp_msg);\n\n  while (!fixed_queue_is_empty(p_cmd->multi_rsp_q)) {\n    osi_free(fixed_queue_try_dequeue(p_cmd->multi_rsp_q));\n  }\n  fixed_queue_free(p_cmd->multi_rsp_q, NULL);\n  memset(p_cmd, 0, sizeof(tGATT_SR_CMD));\n}\n\nstatic void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) {\n  uint16_t ii;\n  size_t total_len, len;\n  uint8_t* p;\n  bool is_overflow = false;\n\n  // We need at least one extra byte for the opcode\n  if (mtu == 0) {\n    log::error(\"Invalid MTU\");\n    p_cmd->status = GATT_ILLEGAL_PARAMETER;\n    return;\n  }\n\n  len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu;\n  BT_HDR* p_buf = (BT_HDR*)osi_calloc(len);\n  p_buf->offset = L2CAP_MIN_OFFSET;\n  p = (uint8_t*)(p_buf + 1) + p_buf->offset;\n\n  /* First byte in the response is the opcode */\n  if (p_cmd->multi_req.variable_len) {\n    *p++ = GATT_RSP_READ_MULTI_VAR;\n  } else {\n    *p++ = GATT_RSP_READ_MULTI;\n  }\n\n  p_buf->len = 1;\n\n  // Now walk through the buffers putting the data into the response in order\n  list_t* list = NULL;\n  const list_node_t* node = NULL;\n  if (!fixed_queue_is_empty(p_cmd->multi_rsp_q)) {\n    list = fixed_queue_get_list(p_cmd->multi_rsp_q);\n  }\n  for (ii = 0; ii < p_cmd->multi_req.num_handles; ii++) {\n    tGATTS_RSP* p_rsp = NULL;\n\n    if (list != NULL) {\n      if (ii == 0) {\n        node = list_begin(list);\n      } else {\n        node = list_next(node);\n      }\n      if (node != list_end(list)) {\n        p_rsp = (tGATTS_RSP*)list_node(node);\n      }\n    }\n\n    if (p_rsp != NULL) {\n      total_len = p_buf->len;\n      if (p_cmd->multi_req.variable_len) {\n        total_len += 2;\n      }\n\n      if (total_len > mtu) {\n        log::verbose(\"Buffer space not enough for this data item, skipping\");\n        break;\n      }\n\n      len = std::min((size_t)p_rsp->attr_value.len, mtu - total_len);\n\n      if (total_len == mtu && p_rsp->attr_value.len > 0) {\n        log::verbose(\"Buffer space not enough for this data item, skipping\");\n        break;\n      }\n\n      if (len < p_rsp->attr_value.len) {\n        is_overflow = true;\n        log::verbose(\"multi read overflow available len={} val_len={}\", len, p_rsp->attr_value.len);\n      }\n\n      if (p_cmd->multi_req.variable_len) {\n        UINT16_TO_STREAM(p, (uint16_t)len);\n        p_buf->len += 2;\n      }\n\n      if (p_rsp->attr_value.handle == p_cmd->multi_req.handles[ii]) {\n        ARRAY_TO_STREAM(p, p_rsp->attr_value.value, (uint16_t)len);\n        p_buf->len += (uint16_t)len;\n      } else {\n        p_cmd->status = GATT_NOT_FOUND;\n        break;\n      }\n\n      if (is_overflow) {\n        break;\n      }\n\n    } else {\n      p_cmd->status = GATT_NOT_FOUND;\n      break;\n    }\n\n  } /* loop through all handles*/\n\n  /* Sanity check on the buffer length */\n  if (p_buf->len == 0) {\n    log::error(\"nothing found!!\");\n    p_cmd->status = GATT_NOT_FOUND;\n    osi_free(p_buf);\n    log::verbose(\"osi_free(p_buf)\");\n  } else if (p_cmd->p_rsp_msg != NULL) {\n    osi_free(p_buf);\n  } else {\n    p_cmd->p_rsp_msg = p_buf;\n  }\n}\n\n/*******************************************************************************\n *\n * Function         process_read_multi_rsp\n *\n * Description      This function check the read multiple response.\n *\n * Returns          bool    if all replies have been received\n *\n ******************************************************************************/\nstatic bool process_read_multi_rsp(tGATT_SR_CMD* p_cmd, tGATT_STATUS status, tGATTS_RSP* p_msg,\n                                   uint16_t mtu) {\n  log::verbose(\"status={} mtu={}\", status, mtu);\n\n  if (p_cmd->multi_rsp_q == NULL) {\n    p_cmd->multi_rsp_q = fixed_queue_new(SIZE_MAX);\n  }\n\n  /* Enqueue the response */\n  BT_HDR* p_buf = (BT_HDR*)osi_malloc(sizeof(tGATTS_RSP));\n  memcpy((void*)p_buf, (const void*)p_msg, sizeof(tGATTS_RSP));\n  fixed_queue_enqueue(p_cmd->multi_rsp_q, p_buf);\n\n  p_cmd->status = status;\n  if (status == GATT_SUCCESS) {\n    log::verbose(\"Multi read count={} num_hdls={} variable={}\",\n                 fixed_queue_length(p_cmd->multi_rsp_q), p_cmd->multi_req.num_handles,\n                 p_cmd->multi_req.variable_len);\n    /* Wait till we get all the responses */\n    if (fixed_queue_length(p_cmd->multi_rsp_q) == p_cmd->multi_req.num_handles) {\n      build_read_multi_rsp(p_cmd, mtu);\n      return true;\n    }\n  } else /* any handle read exception occurs, return error */\n  {\n    return true;\n  }\n\n  /* If here, still waiting */\n  return false;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_process_app_rsp\n *\n * Description      This function checks whether the response message from\n *                  application matches any pending request.\n *\n * Returns          void\n *\n ******************************************************************************/\ntGATT_STATUS gatt_sr_process_app_rsp(tGATT_TCB& tcb, tGATT_IF gatt_if, uint32_t /* trans_id */,\n                                     uint8_t op_code, tGATT_STATUS status, tGATTS_RSP* p_msg,\n                                     tGATT_SR_CMD* sr_res_p) {\n  tGATT_STATUS ret_code = GATT_SUCCESS;\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, sr_res_p->cid);\n\n  log::verbose(\"gatt_if={}\", gatt_if);\n\n  gatt_sr_update_cback_cnt(tcb, sr_res_p->cid, gatt_if, false, false);\n\n  if ((op_code == GATT_REQ_READ_MULTI) || (op_code == GATT_REQ_READ_MULTI_VAR)) {\n    /* If no error and still waiting, just return */\n    if (!process_read_multi_rsp(sr_res_p, status, p_msg, payload_size)) {\n      return GATT_SUCCESS;\n    }\n  } else {\n    if (op_code == GATT_REQ_PREPARE_WRITE && status == GATT_SUCCESS) {\n      gatt_sr_update_prep_cnt(tcb, gatt_if, true, false);\n    }\n\n    if (op_code == GATT_REQ_EXEC_WRITE && status != GATT_SUCCESS) {\n      gatt_sr_reset_cback_cnt(tcb, sr_res_p->cid);\n    }\n\n    sr_res_p->status = status;\n\n    if (gatt_sr_is_cback_cnt_zero(tcb) && status == GATT_SUCCESS) {\n      if (sr_res_p->p_rsp_msg == NULL) {\n        sr_res_p->p_rsp_msg =\n                attp_build_sr_msg(tcb, (uint8_t)(op_code + 1), (tGATT_SR_MSG*)p_msg, payload_size);\n      } else {\n        log::error(\"Exception!!! already has respond message\");\n      }\n    }\n  }\n  if (gatt_sr_is_cback_cnt_zero(tcb)) {\n    if ((sr_res_p->status == GATT_SUCCESS) && (sr_res_p->p_rsp_msg)) {\n      ret_code = attp_send_sr_msg(tcb, sr_res_p->cid, sr_res_p->p_rsp_msg);\n      sr_res_p->p_rsp_msg = NULL;\n    } else {\n      ret_code = gatt_send_error_rsp(tcb, sr_res_p->cid, status, op_code, sr_res_p->handle, false);\n    }\n\n    gatt_dequeue_sr_cmd(tcb, sr_res_p->cid);\n  }\n\n  log::verbose(\"ret_code={}\", ret_code);\n\n  return ret_code;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_exec_write_req\n *\n * Description      This function is called to process the execute write request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_exec_write_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code, uint16_t len,\n                                 uint8_t* p_data) {\n  uint8_t *p = p_data, flag, i = 0;\n  uint32_t trans_id = 0;\n  tGATT_IF gatt_if;\n  uint16_t conn_id;\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    log::verbose(\"Conformance tst: forced err rspv for Execute Write: error status={}\",\n                 gatt_cb.err_status);\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code, gatt_cb.handle, false);\n\n    return;\n  }\n#endif\n\n  if (len < sizeof(flag)) {\n    log::error(\"invalid length\");\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_EXEC_WRITE, 0, false);\n    return;\n  }\n\n  STREAM_TO_UINT8(flag, p);\n\n  /* mask the flag */\n  flag &= GATT_PREP_WRITE_EXEC;\n\n  /* no prep write is queued */\n  if (!gatt_sr_is_prep_cnt_zero(tcb)) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, 0);\n    gatt_sr_copy_prep_cnt_to_cback_cnt(tcb);\n\n    if (com::android::bluetooth::flags::gatt_client_dynamic_allocation()) {\n      auto prep_cnt_it = tcb.prep_cnt_map.begin();\n      while (prep_cnt_it != tcb.prep_cnt_map.end()) {\n        gatt_if = i;\n        conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_if);\n        tGATTS_DATA gatts_data;\n        gatts_data.exec_write = flag;\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_WRITE_EXEC, &gatts_data);\n        prep_cnt_it = tcb.prep_cnt_map.erase(prep_cnt_it);\n      }\n    } else {\n      for (i = 0; i < GATT_MAX_APPS; i++) {\n        if (tcb.prep_cnt[i]) {\n          gatt_if = (tGATT_IF)(i + 1);\n          conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_if);\n          tGATTS_DATA gatts_data;\n          gatts_data.exec_write = flag;\n          gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_WRITE_EXEC, &gatts_data);\n          tcb.prep_cnt[i] = 0;\n        }\n      }\n    }\n  } else /* nothing needs to be executed , send response now */\n  {\n    log::error(\"gatt_process_exec_write_req: no prepare write pending\");\n    gatt_send_error_rsp(tcb, cid, GATT_ERROR, GATT_REQ_EXEC_WRITE, 0, false);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_read_multi_req\n *\n * Description      This function is called to process the read multiple request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_read_multi_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code, uint16_t len,\n                                 uint8_t* p_data) {\n  uint32_t trans_id;\n  uint16_t handle = 0, ll = len;\n  uint8_t* p = p_data;\n  tGATT_STATUS err = GATT_SUCCESS;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n\n  log::verbose(\"\");\n\n  tGATT_READ_MULTI* multi_req = gatt_sr_get_read_multi(tcb, cid);\n  if (multi_req == nullptr) {\n    log::error(\"Could not proceed request. {}, 0x{:02x}\", tcb.peer_bda, cid);\n    return;\n  }\n  multi_req->num_handles = 0;\n  multi_req->variable_len = (op_code == GATT_REQ_READ_MULTI_VAR);\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    log::verbose(\"Conformance tst: forced err rspvofr ReadMultiple: error status={}\",\n                 gatt_cb.err_status);\n\n    STREAM_TO_UINT16(handle, p);\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code, handle, false);\n\n    return;\n  }\n#endif\n\n  while (ll >= 2 && multi_req->num_handles < GATT_MAX_READ_MULTI_HANDLES) {\n    STREAM_TO_UINT16(handle, p);\n\n    auto it = gatt_sr_find_i_rcb_by_handle(handle);\n    if (it != gatt_cb.srv_list_info->end()) {\n      multi_req->handles[multi_req->num_handles++] = handle;\n\n      /* check read permission */\n      err = gatts_read_attr_perm_check(it->p_db, false, handle, sec_flag, key_size);\n      if (err != GATT_SUCCESS) {\n        log::verbose(\"read permission denied : 0x{:02x}\", err);\n        break;\n      }\n    } else {\n      /* invalid handle */\n      err = GATT_INVALID_HANDLE;\n      break;\n    }\n    ll -= 2;\n  }\n\n  if (ll != 0) {\n    log::error(\"max attribute handle reached in ReadMultiple Request.\");\n  }\n\n  if (multi_req->num_handles == 0) {\n    err = GATT_INVALID_HANDLE;\n  }\n\n  if (err == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, multi_req->handles[0]);\n    if (trans_id != 0) {\n      tGATT_SR_CMD* sr_cmd_p = gatt_sr_get_cmd_by_cid(tcb, cid);\n      if (sr_cmd_p == nullptr) {\n        log::error(\"Could not send response on CID were request arrived. {}, 0x{:02x}\",\n                   tcb.peer_bda, cid);\n        return;\n      }\n      gatt_sr_reset_cback_cnt(tcb, cid); /* read multiple use multi_rsp_q's count*/\n\n      for (ll = 0; ll < multi_req->num_handles; ll++) {\n        tGATTS_RSP* p_msg = (tGATTS_RSP*)osi_calloc(sizeof(tGATTS_RSP));\n        handle = multi_req->handles[ll];\n        auto it = gatt_sr_find_i_rcb_by_handle(handle);\n\n        p_msg->attr_value.handle = handle;\n        err = gatts_read_attr_value_by_handle(tcb, cid, it->p_db, op_code, handle, 0,\n                                              p_msg->attr_value.value, &p_msg->attr_value.len,\n                                              GATT_MAX_ATTR_LEN, sec_flag, key_size, trans_id);\n\n        if (err == GATT_SUCCESS) {\n          gatt_sr_process_app_rsp(tcb, it->gatt_if, trans_id, op_code, GATT_SUCCESS, p_msg,\n                                  sr_cmd_p);\n        }\n        /* either not using or done using the buffer, release it now */\n        osi_free(p_msg);\n      }\n    } else {\n      err = GATT_NO_RESOURCES;\n    }\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (err != GATT_SUCCESS && err != GATT_PENDING && err != GATT_BUSY) {\n    gatt_send_error_rsp(tcb, cid, err, op_code, handle, false);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatt_build_primary_service_rsp\n *\n * Description      Primamry service request processed internally. Theretically\n *                  only deal with ReadByTypeValue and ReadByGroupType.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic tGATT_STATUS gatt_build_primary_service_rsp(BT_HDR* p_msg, tGATT_TCB& tcb, uint16_t cid,\n                                                   uint8_t op_code, uint16_t s_hdl, uint16_t e_hdl,\n                                                   uint8_t* /* p_data */, const Uuid& value) {\n  tGATT_STATUS status = GATT_NOT_FOUND;\n  uint8_t handle_len = 4;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl < s_hdl || el.s_hdl > e_hdl || el.type != GATT_UUID_PRI_SERVICE) {\n      continue;\n    }\n\n    Uuid* p_uuid = gatts_get_service_uuid(el.p_db);\n    if (!p_uuid) {\n      continue;\n    }\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n      handle_len = 4 + gatt_build_uuid_to_stream_len(*p_uuid);\n    }\n\n    /* get the length byte in the repsonse */\n    if (p_msg->offset == 0) {\n      *p++ = op_code + 1;\n      p_msg->len++;\n      p_msg->offset = handle_len;\n\n      if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n        *p++ = (uint8_t)p_msg->offset; /* length byte */\n        p_msg->len++;\n      }\n    }\n\n    if (p_msg->len + p_msg->offset > payload_size || handle_len != p_msg->offset) {\n      break;\n    }\n\n    if (op_code == GATT_REQ_FIND_TYPE_VALUE && value != *p_uuid) {\n      continue;\n    }\n\n    UINT16_TO_STREAM(p, el.s_hdl);\n\n    if (gatt_cb.last_service_handle && gatt_cb.last_service_handle == el.s_hdl) {\n      log::verbose(\"Use 0xFFFF for the last primary attribute\");\n      /* see GATT ERRATA 4065, 4063, ATT ERRATA 4062 */\n      UINT16_TO_STREAM(p, 0xFFFF);\n    } else {\n      UINT16_TO_STREAM(p, el.e_hdl);\n    }\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n      gatt_build_uuid_to_stream(&p, *p_uuid);\n    }\n\n    status = GATT_SUCCESS;\n    p_msg->len += p_msg->offset;\n  }\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  return status;\n}\n\n/**\n * fill the find information response information in the given buffer.\n *\n * Returns          true: if data filled sucessfully.\n *                  false: packet full, or format mismatch.\n */\nstatic tGATT_STATUS gatt_build_find_info_rsp(tGATT_SRV_LIST_ELEM& el, BT_HDR* p_msg, uint16_t& len,\n                                             uint16_t s_hdl, uint16_t e_hdl) {\n  uint8_t info_pair_len[2] = {4, 18};\n\n  if (!el.p_db) {\n    return GATT_NOT_FOUND;\n  }\n\n  /* check the attribute database */\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET + p_msg->len;\n\n  tGATT_STATUS status = GATT_NOT_FOUND;\n  for (auto& attr : el.p_db->attr_list) {\n    if (attr.handle > e_hdl) {\n      break;\n    }\n\n    if (attr.handle < s_hdl) {\n      continue;\n    }\n\n    uint8_t uuid_len = attr.uuid.GetShortestRepresentationSize();\n    if (p_msg->offset == 0) {\n      p_msg->offset =\n              (uuid_len == Uuid::kNumBytes16) ? GATT_INFO_TYPE_PAIR_16 : GATT_INFO_TYPE_PAIR_128;\n    }\n\n    if (len < info_pair_len[p_msg->offset - 1]) {\n      return GATT_NO_RESOURCES;\n    }\n\n    if (p_msg->offset == GATT_INFO_TYPE_PAIR_16 && uuid_len == Uuid::kNumBytes16) {\n      UINT16_TO_STREAM(p, attr.handle);\n      UINT16_TO_STREAM(p, attr.uuid.As16Bit());\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 && uuid_len == Uuid::kNumBytes128) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 && uuid_len == Uuid::kNumBytes32) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else {\n      log::error(\"format mismatch\");\n      return GATT_NO_RESOURCES;\n      /* format mismatch */\n    }\n    p_msg->len += info_pair_len[p_msg->offset - 1];\n    len -= info_pair_len[p_msg->offset - 1];\n    status = GATT_SUCCESS;\n  }\n\n  return status;\n}\n\nstatic tGATT_STATUS read_handles(uint16_t& len, uint8_t*& p, uint16_t& s_hdl, uint16_t& e_hdl) {\n  if (len < 4) {\n    return GATT_INVALID_PDU;\n  }\n\n  /* obtain starting handle, and ending handle */\n  STREAM_TO_UINT16(s_hdl, p);\n  STREAM_TO_UINT16(e_hdl, p);\n  len -= 4;\n\n  if (s_hdl > e_hdl || !GATT_HANDLE_IS_VALID(s_hdl) || !GATT_HANDLE_IS_VALID(e_hdl)) {\n    return GATT_INVALID_HANDLE;\n  }\n\n  return GATT_SUCCESS;\n}\n\nstatic tGATT_STATUS gatts_validate_packet_format(uint8_t op_code, uint16_t& len, uint8_t*& p,\n                                                 Uuid* p_uuid, uint16_t& s_hdl, uint16_t& e_hdl) {\n  tGATT_STATUS ret = read_handles(len, p, s_hdl, e_hdl);\n  if (ret != GATT_SUCCESS) {\n    return ret;\n  }\n\n  if (len < 2) {\n    return GATT_INVALID_PDU;\n  }\n\n  /* parse uuid now */\n  log::assert_that(p_uuid != nullptr, \"assert failed: p_uuid != nullptr\");\n  uint16_t uuid_len = (op_code == GATT_REQ_FIND_TYPE_VALUE) ? 2 : len;\n  if (!gatt_parse_uuid_from_cmd(p_uuid, uuid_len, &p)) {\n    log::verbose(\"Bad UUID\");\n    return GATT_INVALID_PDU;\n  }\n\n  len -= uuid_len;\n  return GATT_SUCCESS;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_primary_service_req\n *\n * Description      Process ReadByGroupType/ReadByTypeValue request, for\n *                  discovering all primary services or discover primary service\n *                  by UUID request.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code, uint16_t len,\n                                       uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  Uuid uuid = Uuid::kEmpty;\n\n  uint8_t reason = gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  if (uuid != Uuid::From16Bit(GATT_UUID_PRI_SERVICE)) {\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n      gatt_send_error_rsp(tcb, cid, GATT_UNSUPPORT_GRP_TYPE, op_code, s_hdl, false);\n      log::verbose(\"unexpected ReadByGrpType Group: {}\", uuid.ToString());\n      return;\n    }\n\n    // we do not support ReadByTypeValue with any non-primamry_service type\n    gatt_send_error_rsp(tcb, cid, GATT_NOT_FOUND, op_code, s_hdl, false);\n    log::verbose(\"unexpected ReadByTypeValue type: {}\", uuid.ToString());\n    return;\n  }\n\n  // TODO: we assume theh value is UUID, there is no such requirement in spec\n  Uuid value = Uuid::kEmpty;\n  if (op_code == GATT_REQ_FIND_TYPE_VALUE) {\n    if (!gatt_parse_uuid_from_cmd(&value, len, &p_data)) {\n      gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, s_hdl, false);\n    }\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  uint16_t msg_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n  reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl, e_hdl, p_data, value);\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_find_info\n *\n * Description      process find information request, for discover character\n *                  descriptors.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code, uint16_t len,\n                                    uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  uint8_t reason = read_handles(len, p_data, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  uint16_t buf_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n  reason = GATT_NOT_FOUND;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n  *p++ = op_code + 1;\n  p_msg->len = 2;\n\n  buf_len = payload_size - 2;\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl <= e_hdl && el.e_hdl >= s_hdl) {\n      reason = gatt_build_find_info_rsp(el, p_msg, buf_len, s_hdl, e_hdl);\n      if (reason == GATT_NO_RESOURCES) {\n        reason = GATT_SUCCESS;\n        break;\n      }\n    }\n  }\n\n  *p = (uint8_t)p_msg->offset;\n\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n  } else {\n    attp_send_sr_msg(tcb, cid, p_msg);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_mtu_req\n *\n * Description      This function is called to process excahnge MTU request.\n *                  Only used on LE.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_mtu_req(tGATT_TCB& tcb, uint16_t cid, uint16_t len, uint8_t* p_data) {\n  /* BR/EDR conenction, send error response */\n  if (cid != L2CAP_ATT_CID) {\n    gatt_send_error_rsp(tcb, cid, GATT_REQ_NOT_SUPPORTED, GATT_REQ_MTU, 0, false);\n    return;\n  }\n\n  if (len < GATT_MTU_REQ_MIN_LEN) {\n    log::error(\"invalid MTU request PDU received.\");\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_MTU, 0, false);\n    return;\n  }\n\n  tGATT_SR_MSG gatt_sr_msg;\n\n  uint16_t mtu = 0;\n  uint8_t* p = p_data;\n  STREAM_TO_UINT16(mtu, p);\n  /* mtu must be greater than default MTU which is 23/48 */\n  if (mtu < GATT_DEF_BLE_MTU_SIZE) {\n    tcb.payload_size = GATT_DEF_BLE_MTU_SIZE;\n  } else {\n    tcb.payload_size = std::min(mtu, (uint16_t)(gatt_get_local_mtu()));\n  }\n\n  /* Always say to remote our default MTU. */\n  gatt_sr_msg.mtu = gatt_get_local_mtu();\n\n  log::info(\"MTU {} request from remote ({}), resulted MTU {}\", mtu, tcb.peer_bda,\n            tcb.payload_size);\n\n  if (get_btm_client_interface().ble.BTM_SetBleDataLength(\n              tcb.peer_bda, tcb.payload_size + L2CAP_PKT_OVERHEAD) != tBTM_STATUS::BTM_SUCCESS) {\n    log::warn(\"Unable to set BLE data length peer:{} mtu:{}\", tcb.peer_bda,\n              tcb.payload_size + L2CAP_PKT_OVERHEAD);\n  }\n\n  BT_HDR* p_buf = attp_build_sr_msg(tcb, GATT_RSP_MTU, &gatt_sr_msg, GATT_DEF_BLE_MTU_SIZE);\n  attp_send_sr_msg(tcb, cid, p_buf);\n\n  bluetooth::shim::arbiter::GetArbiter().OnIncomingMtuReq(tcb.tcb_idx, tcb.payload_size);\n\n  tGATTS_DATA gatts_data;\n  gatts_data.mtu = tcb.payload_size;\n  /* Notify all registered application with new MTU size. Use a transaction ID */\n  /* of 0, as no response is allowed from applications */\n  if (com::android::bluetooth::flags::gatt_client_dynamic_allocation()) {\n    for (auto& [i, p_reg] : gatt_cb.cl_rcb_map) {\n      if (p_reg->in_use) {\n        uint16_t conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, p_reg->gatt_if);\n        gatt_sr_send_req_callback(conn_id, 0, GATTS_REQ_TYPE_MTU, &gatts_data);\n      }\n    }\n  } else {\n    for (int i = 0; i < GATT_MAX_APPS; i++) {\n      if (gatt_cb.cl_rcb[i].in_use) {\n        uint16_t conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_cb.cl_rcb[i].gatt_if);\n        gatt_sr_send_req_callback(conn_id, 0, GATTS_REQ_TYPE_MTU, &gatts_data);\n      }\n    }\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_read_by_type_req\n *\n * Description      process Read By type request.\n *                  This PDU can be used to perform:\n *                  - read characteristic value\n *                  - read characteristic descriptor value\n *                  - discover characteristic\n *                  - discover characteristic by UUID\n *                  - relationship discovery\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                           uint16_t len, uint8_t* p_data) {\n  Uuid uuid = Uuid::kEmpty;\n  uint16_t s_hdl = 0, e_hdl = 0, err_hdl = 0;\n  tGATT_STATUS reason = gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    log::verbose(\"Conformance tst: forced err rsp for ReadByType: error status={}\",\n                 gatt_cb.err_status);\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code, s_hdl, false);\n\n    return;\n  }\n#endif\n\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  *p++ = op_code + 1;\n  /* reserve length byte */\n  p_msg->len = 2;\n  uint16_t buf_len = payload_size - 2;\n\n  reason = GATT_NOT_FOUND;\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl <= e_hdl && el.e_hdl >= s_hdl) {\n      tGATT_SEC_FLAG sec_flag;\n      uint8_t key_size;\n      gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n      tGATT_STATUS ret =\n              gatts_db_read_attr_value_by_type(tcb, cid, el.p_db, op_code, p_msg, s_hdl, e_hdl,\n                                               uuid, &buf_len, sec_flag, key_size, 0, &err_hdl);\n      if (ret != GATT_NOT_FOUND) {\n        reason = ret;\n        if (ret == GATT_NO_RESOURCES) {\n          reason = GATT_SUCCESS;\n        }\n      }\n\n      if (ret != GATT_SUCCESS && ret != GATT_NOT_FOUND) {\n        s_hdl = err_hdl;\n        break;\n      }\n    }\n  }\n  *p = (uint8_t)p_msg->offset;\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n\n    /* in theroy BUSY is not possible(should already been checked), protected\n     * check */\n    if (reason != GATT_PENDING && reason != GATT_BUSY) {\n      gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    }\n\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/**\n * This function is called to process the write request from client.\n */\nstatic void gatts_process_write_req(tGATT_TCB& tcb, uint16_t cid, tGATT_SRV_LIST_ELEM& el,\n                                    uint16_t handle, uint8_t op_code, uint16_t len, uint8_t* p_data,\n                                    bt_gatt_db_attribute_type_t gatt_type) {\n  tGATTS_DATA sr_data;\n  uint32_t trans_id;\n  tGATT_STATUS status;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size, *p = p_data;\n  uint16_t conn_id;\n\n  memset(&sr_data, 0, sizeof(tGATTS_DATA));\n\n  switch (op_code) {\n    case GATT_REQ_PREPARE_WRITE:\n      if (len < 2 || p == nullptr) {\n        log::error(\"Prepare write request was invalid - missing offset, sending error response\");\n        gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, handle, false);\n        return;\n      }\n      sr_data.write_req.is_prep = true;\n      STREAM_TO_UINT16(sr_data.write_req.offset, p);\n      len -= 2;\n      FALLTHROUGH_INTENDED; /* FALLTHROUGH */\n    case GATT_SIGN_CMD_WRITE:\n      if (op_code == GATT_SIGN_CMD_WRITE) {\n        log::verbose(\"Write CMD with data sigining\");\n        len -= GATT_AUTH_SIGN_LEN;\n      }\n      FALLTHROUGH_INTENDED; /* FALLTHROUGH */\n    case GATT_CMD_WRITE:\n    case GATT_REQ_WRITE:\n      if (op_code == GATT_REQ_WRITE || op_code == GATT_REQ_PREPARE_WRITE) {\n        sr_data.write_req.need_rsp = true;\n      }\n      sr_data.write_req.handle = handle;\n      if (len > GATT_MAX_ATTR_LEN) {\n        len = GATT_MAX_ATTR_LEN;\n      }\n      sr_data.write_req.len = len;\n      if (len != 0 && p != nullptr) {\n        memcpy(sr_data.write_req.value, p, len);\n      }\n      break;\n  }\n\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n  status = gatts_write_attr_perm_check(el.p_db, op_code, handle, sr_data.write_req.offset, p, len,\n                                       sec_flag, key_size);\n\n  if (status == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, handle);\n    if (trans_id != 0) {\n      conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, el.gatt_if);\n\n      uint8_t opcode = 0;\n      if (gatt_type == BTGATT_DB_DESCRIPTOR) {\n        opcode = GATTS_REQ_TYPE_WRITE_DESCRIPTOR;\n      } else if (gatt_type == BTGATT_DB_CHARACTERISTIC) {\n        opcode = GATTS_REQ_TYPE_WRITE_CHARACTERISTIC;\n      } else {\n        log::error(\n                \"Attempt to write attribute that's not tied with \"\n                \"characteristic or descriptor value.\");\n        status = GATT_ERROR;\n      }\n\n      if (opcode) {\n        gatt_sr_send_req_callback(conn_id, trans_id, opcode, &sr_data);\n        status = GATT_PENDING;\n      }\n    } else {\n      log::error(\"max pending command, send error\");\n      status = GATT_BUSY; /* max pending command, application error */\n    }\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (status != GATT_PENDING && status != GATT_BUSY &&\n      (op_code == GATT_REQ_PREPARE_WRITE || op_code == GATT_REQ_WRITE)) {\n    gatt_send_error_rsp(tcb, cid, status, op_code, handle, false);\n  }\n  return;\n}\n\n/**\n * This function is called to process the read request from client.\n */\nstatic void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid, tGATT_SRV_LIST_ELEM& el,\n                                   uint8_t op_code, uint16_t handle, uint16_t len,\n                                   uint8_t* p_data) {\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  uint16_t offset = 0;\n\n  if (op_code == GATT_REQ_READ_BLOB && len < sizeof(uint16_t)) {\n    /* Error: packet length is too short */\n    log::error(\"packet length={} too short. min={}\", len, sizeof(uint16_t));\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, 0, false);\n    return;\n  }\n\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n\n  if (op_code == GATT_REQ_READ_BLOB) {\n    STREAM_TO_UINT16(offset, p_data);\n  }\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n  *p++ = op_code + 1;\n  p_msg->len = 1;\n  buf_len = payload_size - 1;\n\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n  uint16_t value_len = 0;\n  tGATT_STATUS reason =\n          gatts_read_attr_value_by_handle(tcb, cid, el.p_db, op_code, handle, offset, p, &value_len,\n                                          (uint16_t)buf_len, sec_flag, key_size, 0);\n  p_msg->len += value_len;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n\n    /* in theory BUSY is not possible(should already been checked), protected\n     * check */\n    if (reason != GATT_PENDING && reason != GATT_BUSY) {\n      gatt_send_error_rsp(tcb, cid, reason, op_code, handle, false);\n    }\n\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_attribute_req\n *\n * Description      This function is called to process the per attribute handle\n *                  request from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_attribute_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code, uint16_t len,\n                                 uint8_t* p_data) {\n  uint16_t handle = 0;\n  uint8_t* p = p_data;\n  tGATT_STATUS status = GATT_INVALID_HANDLE;\n\n  if (len < 2) {\n    log::error(\"Illegal PDU length, discard request\");\n    status = GATT_INVALID_PDU;\n  } else {\n    STREAM_TO_UINT16(handle, p);\n    len -= 2;\n  }\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  gatt_cb.handle = handle;\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    log::verbose(\"Conformance tst: forced err rsp: error status={}\", gatt_cb.err_status);\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, cid, gatt_cb.req_op_code, handle, false);\n\n    return;\n  }\n#endif\n\n  if (GATT_HANDLE_IS_VALID(handle)) {\n    for (auto& el : *gatt_cb.srv_list_info) {\n      if (el.s_hdl <= handle && el.e_hdl >= handle) {\n        for (const auto& attr : el.p_db->attr_list) {\n          if (attr.handle == handle) {\n            switch (op_code) {\n              case GATT_REQ_READ: /* read char/char descriptor value */\n              case GATT_REQ_READ_BLOB:\n                gatts_process_read_req(tcb, cid, el, op_code, handle, len, p);\n                break;\n\n              case GATT_REQ_WRITE: /* write char/char descriptor value */\n              case GATT_CMD_WRITE:\n              case GATT_SIGN_CMD_WRITE:\n              case GATT_REQ_PREPARE_WRITE:\n                gatts_process_write_req(tcb, cid, el, handle, op_code, len, p, attr.gatt_type);\n                break;\n              default:\n                break;\n            }\n            status = GATT_SUCCESS;\n            break;\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  if (status != GATT_SUCCESS && op_code != GATT_CMD_WRITE && op_code != GATT_SIGN_CMD_WRITE) {\n    gatt_send_error_rsp(tcb, cid, status, op_code, handle, false);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_proc_srv_chg_ind_ack\n *\n * Description      This function process the service changed indicaiton ACK\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_proc_srv_chg_ind_ack(tGATT_TCB tcb) {\n  tGATTS_SRV_CHG_REQ req;\n  tGATTS_SRV_CHG* p_buf = NULL;\n\n  log::verbose(\"\");\n\n  p_buf = gatt_is_bda_in_the_srv_chg_clt_list(tcb.peer_bda);\n  if (p_buf != NULL) {\n    log::verbose(\"NV update set srv chg = false\");\n    p_buf->srv_changed = false;\n    memcpy(&req.srv_chg, p_buf, sizeof(tGATTS_SRV_CHG));\n    if (gatt_cb.cb_info.p_srv_chg_callback) {\n      (*gatt_cb.cb_info.p_srv_chg_callback)(GATTS_SRV_CHG_CMD_UPDATE_CLIENT, &req, NULL);\n    }\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_chk_pending_ind\n *\n * Description      This function check any pending indication needs to be sent\n *                  if there is a pending indication then sent the indication\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_chk_pending_ind(tGATT_TCB& tcb) {\n  log::verbose(\"\");\n\n  tGATT_VALUE* p_buf = (tGATT_VALUE*)fixed_queue_try_peek_first(tcb.pending_ind_q);\n  if (p_buf != NULL) {\n    if (GATTS_HandleValueIndication(p_buf->conn_id, p_buf->handle, p_buf->len, p_buf->value) !=\n        GATT_SUCCESS) {\n      log::warn(\"Unable to send GATT server handle value conn_id:{}\", p_buf->conn_id);\n    }\n    osi_free(fixed_queue_try_remove_from_queue(tcb.pending_ind_q, p_buf));\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_proc_ind_ack\n *\n * Description      This function processes the Indication ack\n *\n * Returns          true continue to process the indication ack by the\n *                  application if the ACK is not a Service Changed Indication\n *\n ******************************************************************************/\nstatic bool gatts_proc_ind_ack(tGATT_TCB& tcb, uint16_t ack_handle) {\n  bool continue_processing = true;\n\n  log::verbose(\"ack handle={}\", ack_handle);\n\n  if (ack_handle == gatt_cb.handle_of_h_r) {\n    gatts_proc_srv_chg_ind_ack(tcb);\n    /* there is no need to inform the application since srv chg is handled\n     * internally by GATT */\n    continue_processing = false;\n\n    // After receiving ack of svc_chg_ind, reset client status\n    gatt_sr_update_cl_status(tcb, /* chg_aware= */ true);\n  }\n\n  gatts_chk_pending_ind(tcb);\n  return continue_processing;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_value_conf\n *\n * Description      This function is called to process the handle value\n *                  confirmation.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_value_conf(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code) {\n  uint16_t handle;\n\n  if (!gatt_tcb_find_indicate_handle(tcb, cid, &handle)) {\n    log::error(\"unexpected handle value confirmation\");\n    return;\n  }\n\n  gatt_stop_conf_timer(tcb, cid);\n\n  bool continue_processing = gatts_proc_ind_ack(tcb, handle);\n\n  if (continue_processing) {\n    tGATTS_DATA gatts_data;\n    gatts_data.handle = handle;\n    for (auto& el : *gatt_cb.srv_list_info) {\n      if (el.s_hdl <= handle && el.e_hdl >= handle) {\n        uint32_t trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, handle);\n        uint16_t conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, el.gatt_if);\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_CONF, &gatts_data);\n      }\n    }\n  }\n}\n\nstatic bool gatts_process_db_out_of_sync(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                         uint16_t len, uint8_t* p_data) {\n  if (gatt_sr_is_cl_change_aware(tcb)) {\n    return false;\n  }\n\n  // default value\n  bool should_ignore = true;\n  bool should_rsp = true;\n\n  switch (op_code) {\n    case GATT_REQ_READ_BY_TYPE: {\n      // Check if read database hash by UUID\n      Uuid uuid = Uuid::kEmpty;\n      uint16_t s_hdl = 0, e_hdl = 0;\n      uint16_t db_hash_handle = gatt_cb.handle_of_database_hash;\n      tGATT_STATUS reason = gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n      if (reason == GATT_SUCCESS && (s_hdl <= db_hash_handle && db_hash_handle <= e_hdl) &&\n          (uuid == Uuid::From16Bit(GATT_UUID_DATABASE_HASH))) {\n        should_ignore = false;\n      }\n\n    } break;\n    case GATT_REQ_READ: {\n      // Check if read database hash by handle\n      uint16_t handle = 0;\n      uint8_t* p = p_data;\n      tGATT_STATUS status = GATT_SUCCESS;\n\n      if (len < 2) {\n        status = GATT_INVALID_PDU;\n      } else {\n        STREAM_TO_UINT16(handle, p);\n        len -= 2;\n      }\n\n      if (status == GATT_SUCCESS && handle == gatt_cb.handle_of_database_hash) {\n        should_ignore = false;\n      }\n\n    } break;\n    case GATT_REQ_READ_BY_GRP_TYPE: /* discover primary services */\n    case GATT_REQ_FIND_TYPE_VALUE:  /* discover service by UUID */\n    case GATT_REQ_FIND_INFO:        /* discover char descrptor */\n    case GATT_REQ_READ_BLOB:        /* read long char */\n    case GATT_REQ_READ_MULTI:       /* read multi char*/\n    case GATT_REQ_WRITE:            /* write char/char descriptor value */\n    case GATT_REQ_PREPARE_WRITE:    /* write long char */\n      // Use default value\n      break;\n    case GATT_CMD_WRITE:      /* cmd */\n    case GATT_SIGN_CMD_WRITE: /* sign cmd */\n      should_rsp = false;\n      break;\n    case GATT_REQ_MTU:           /* configure mtu */\n    case GATT_REQ_EXEC_WRITE:    /* execute write */\n    case GATT_HANDLE_VALUE_CONF: /* confirm for indication */\n    default:\n      should_ignore = false;\n  }\n\n  if (should_ignore) {\n    if (should_rsp) {\n      gatt_send_error_rsp(tcb, cid, GATT_DATABASE_OUT_OF_SYNC, op_code, 0x0000, false);\n    }\n    log::info(\"database out of sync, device={}, op_code=0x{:x}, should_rsp={}\", tcb.peer_bda,\n              (uint16_t)op_code, should_rsp);\n    gatt_sr_update_cl_status(tcb, /* chg_aware= */ should_rsp);\n  }\n\n  return should_ignore;\n}\n\n/** This function is called to handle the client requests to server */\nvoid gatt_server_handle_client_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code, uint16_t len,\n                                   uint8_t* p_data) {\n  /* there is pending command, discard this one */\n  if (!gatt_sr_cmd_empty(tcb, cid) && op_code != GATT_HANDLE_VALUE_CONF) {\n    return;\n  }\n\n  /* the size of the message may not be bigger than the local max PDU size*/\n  /* The message has to be smaller than the agreed MTU, len does not include op\n   * code */\n\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n  if (len >= payload_size) {\n    log::error(\"server receive invalid PDU size:{} pdu size:{}\", len + 1, payload_size);\n    /* for invalid request expecting response, send it now */\n    if (op_code != GATT_CMD_WRITE && op_code != GATT_SIGN_CMD_WRITE &&\n        op_code != GATT_HANDLE_VALUE_CONF) {\n      gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, 0, false);\n    }\n    /* otherwise, ignore the pkt */\n  } else {\n    // handle database out of sync\n    if (gatts_process_db_out_of_sync(tcb, cid, op_code, len, p_data)) {\n      return;\n    }\n\n    switch (op_code) {\n      case GATT_REQ_READ_BY_GRP_TYPE: /* discover primary services */\n      case GATT_REQ_FIND_TYPE_VALUE:  /* discover service by UUID */\n        gatts_process_primary_service_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_FIND_INFO: /* discover char descrptor */\n        gatts_process_find_info(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ_BY_TYPE: /* read characteristic value, char descriptor\n                                     value */\n        /* discover characteristic, discover char by UUID */\n        gatts_process_read_by_type_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ: /* read char/char descriptor value */\n      case GATT_REQ_READ_BLOB:\n      case GATT_REQ_WRITE: /* write char/char descriptor value */\n      case GATT_CMD_WRITE:\n      case GATT_SIGN_CMD_WRITE:\n      case GATT_REQ_PREPARE_WRITE:\n        gatts_process_attribute_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_HANDLE_VALUE_CONF:\n        gatts_process_value_conf(tcb, cid, op_code);\n        break;\n\n      case GATT_REQ_MTU:\n        gatts_process_mtu_req(tcb, cid, len, p_data);\n        break;\n\n      case GATT_REQ_EXEC_WRITE:\n        gatt_process_exec_write_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ_MULTI:\n      case GATT_REQ_READ_MULTI_VAR:\n        gatt_process_read_multi_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      default:\n        break;\n    }\n  }\n}\n```",
                        "downstream_file_content": "```cc\n/******************************************************************************\n *\n *  Copyright 2008-2012 Broadcom Corporation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at:\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n ******************************************************************************/\n\n/******************************************************************************\n *\n *  this file contains the GATT server functions\n *\n ******************************************************************************/\n#include <algorithm>\n#include <string.h>\n\n#include \"bt_target.h\"\n#include \"gatt_int.h\"\n#include \"l2c_api.h\"\n#include \"osi/include/allocator.h\"\n#include \"osi/include/log.h\"\n#include \"osi/include/osi.h\"\n#include \"stack/eatt/eatt.h\"\n#include \"stack/include/bt_hdr.h\"\n#include \"stack/include/bt_types.h\"\n#include \"stack/l2cap/l2c_int.h\"\n#include \"types/bluetooth/uuid.h\"\n#include <base/logging.h>\n\n#define GATT_MTU_REQ_MIN_LEN 2\n#define L2CAP_PKT_OVERHEAD 4\n\nusing base::StringPrintf;\nusing bluetooth::Uuid;\nusing bluetooth::eatt::EattExtension;\nusing bluetooth::eatt::EattChannel;\n\n/*******************************************************************************\n *\n * Function         gatt_sr_enqueue_cmd\n *\n * Description      This function enqueue the request from client which needs a\n *                  application response, and update the transaction ID.\n *\n * Returns          void\n *\n ******************************************************************************/\nuint32_t gatt_sr_enqueue_cmd(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                             uint16_t handle) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel =\n        EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  uint32_t trans_id = 0;\n\n  p_cmd->cid = cid;\n\n  if ((p_cmd->op_code == 0) ||\n      (op_code == GATT_HANDLE_VALUE_CONF)) /* no pending request */\n  {\n    if (op_code == GATT_CMD_WRITE || op_code == GATT_SIGN_CMD_WRITE ||\n        op_code == GATT_REQ_MTU || op_code == GATT_HANDLE_VALUE_CONF) {\n      trans_id = ++tcb.trans_id;\n    } else {\n      p_cmd->trans_id = ++tcb.trans_id;\n      p_cmd->op_code = op_code;\n      p_cmd->handle = handle;\n      p_cmd->status = GATT_NOT_FOUND;\n      tcb.trans_id %= GATT_TRANS_ID_MAX;\n      trans_id = p_cmd->trans_id;\n    }\n  }\n\n  return trans_id;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_cmd_empty\n *\n * Description      This function checks if the server command queue is empty.\n *\n * Returns          true if empty, false if there is pending command.\n *\n ******************************************************************************/\nbool gatt_sr_cmd_empty(tGATT_TCB& tcb, uint16_t cid) {\n  if (cid == tcb.att_lcid) return (tcb.sr_cmd.op_code == 0);\n\n  EattChannel* channel =\n      EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n\n  return (channel->server_outstanding_cmd_.op_code == 0);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_dequeue_sr_cmd\n *\n * Description      This function dequeue the request from command queue.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_dequeue_sr_cmd(tGATT_TCB& tcb, uint16_t cid) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel =\n        EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  /* Double check in case any buffers are queued */\n  VLOG(1) << \"gatt_dequeue_sr_cmd cid: \" << loghex(cid);\n  if (p_cmd->p_rsp_msg)\n    LOG(ERROR) << \"free tcb.sr_cmd.p_rsp_msg = \"\n               << p_cmd->p_rsp_msg;\n  osi_free_and_reset((void**)&p_cmd->p_rsp_msg);\n\n  while (!fixed_queue_is_empty(p_cmd->multi_rsp_q))\n    osi_free(fixed_queue_try_dequeue(p_cmd->multi_rsp_q));\n  fixed_queue_free(p_cmd->multi_rsp_q, NULL);\n  memset(p_cmd, 0, sizeof(tGATT_SR_CMD));\n}\n\nstatic void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) {\n  uint16_t ii;\n  size_t total_len, len;\n  uint8_t* p;\n  bool is_overflow = false;\n\n  // We need at least one extra byte for the opcode\n  if (mtu == 0) {\n    LOG(ERROR) << \"Invalid MTU\";\n    p_cmd->status = GATT_ILLEGAL_PARAMETER;\n    return;\n  }\n\n  len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu;\n  BT_HDR* p_buf = (BT_HDR*)osi_calloc(len);\n  p_buf->offset = L2CAP_MIN_OFFSET;\n  p = (uint8_t*)(p_buf + 1) + p_buf->offset;\n\n  /* First byte in the response is the opcode */\n  if (p_cmd->multi_req.variable_len)\n    *p++ = GATT_RSP_READ_MULTI_VAR;\n  else\n    *p++ = GATT_RSP_READ_MULTI;\n\n  p_buf->len = 1;\n\n  /* Now walk through the buffers putting the data into the response in order\n   */\n  list_t* list = NULL;\n  const list_node_t* node = NULL;\n  if (!fixed_queue_is_empty(p_cmd->multi_rsp_q))\n    list = fixed_queue_get_list(p_cmd->multi_rsp_q);\n  for (ii = 0; ii < p_cmd->multi_req.num_handles; ii++) {\n    tGATTS_RSP* p_rsp = NULL;\n\n    if (list != NULL) {\n      if (ii == 0)\n        node = list_begin(list);\n      else\n        node = list_next(node);\n      if (node != list_end(list)) p_rsp = (tGATTS_RSP*)list_node(node);\n    }\n\n    if (p_rsp != NULL) {\n      total_len = p_buf->len;\n      if (p_cmd->multi_req.variable_len) {\n        total_len += 2;\n      }\n\n      if (total_len > mtu) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      len = std::min((size_t) p_rsp->attr_value.len, mtu - total_len);\n\n      if (total_len == mtu && p_rsp->attr_value.len > 0) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      if (len < p_rsp->attr_value.len) {\n        is_overflow = true;\n        VLOG(1) << StringPrintf(\n            \"multi read overflow available len=%zu val_len=%d\", len,\n            p_rsp->attr_value.len);\n      }\n\n      if (p_cmd->multi_req.variable_len) {\n        UINT16_TO_STREAM(p, (uint16_t) len);\n        p_buf->len += 2;\n      }\n\n      if (p_rsp->attr_value.handle == p_cmd->multi_req.handles[ii]) {\n        ARRAY_TO_STREAM(p, p_rsp->attr_value.value, (uint16_t) len);\n        p_buf->len += (uint16_t) len;\n      } else {\n        p_cmd->status = GATT_NOT_FOUND;\n        break;\n      }\n\n      if (is_overflow) break;\n\n    } else {\n      p_cmd->status = GATT_NOT_FOUND;\n      break;\n    }\n\n  } /* loop through all handles*/\n\n  /* Sanity check on the buffer length */\n  if (p_buf->len == 0) {\n    LOG(ERROR) << __func__ << \" nothing found!!\";\n    p_cmd->status = GATT_NOT_FOUND;\n    osi_free(p_buf);\n    VLOG(1) << __func__ << \"osi_free(p_buf)\";\n  } else if (p_cmd->p_rsp_msg != NULL) {\n    osi_free(p_buf);\n  } else {\n    p_cmd->p_rsp_msg = p_buf;\n  }\n}\n\n/*******************************************************************************\n *\n * Function         process_read_multi_rsp\n *\n * Description      This function check the read multiple response.\n *\n * Returns          bool    if all replies have been received\n *\n ******************************************************************************/\nstatic bool process_read_multi_rsp(tGATT_SR_CMD* p_cmd, tGATT_STATUS status,\n                                   tGATTS_RSP* p_msg, uint16_t mtu) {\n  VLOG(1) << StringPrintf(\"%s status=%d mtu=%d\", __func__, status, mtu);\n\n  if (p_cmd->multi_rsp_q == NULL)\n    p_cmd->multi_rsp_q = fixed_queue_new(SIZE_MAX);\n\n  /* Enqueue the response */\n  BT_HDR* p_buf = (BT_HDR*)osi_malloc(sizeof(tGATTS_RSP));\n  memcpy((void*)p_buf, (const void*)p_msg, sizeof(tGATTS_RSP));\n  fixed_queue_enqueue(p_cmd->multi_rsp_q, p_buf);\n\n  p_cmd->status = status;\n  if (status == GATT_SUCCESS) {\n    VLOG(1) << \"Multi read count=\" << fixed_queue_length(p_cmd->multi_rsp_q)\n            << \" num_hdls=\" << p_cmd->multi_req.num_handles\n            << \" variable=\" << p_cmd->multi_req.variable_len;\n    /* Wait till we get all the responses */\n    if (fixed_queue_length(p_cmd->multi_rsp_q) ==\n        p_cmd->multi_req.num_handles) {\n      build_read_multi_rsp(p_cmd, mtu);\n      return (true);\n    }\n  } else /* any handle read exception occurs, return error */\n  {\n    return (true);\n  }\n\n  /* If here, still waiting */\n  return (false);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_process_app_rsp\n *\n * Description      This function checks whether the response message from\n *                  application matches any pending request.\n *\n * Returns          void\n *\n ******************************************************************************/\ntGATT_STATUS gatt_sr_process_app_rsp(tGATT_TCB& tcb, tGATT_IF gatt_if,\n                                     UNUSED_ATTR uint32_t trans_id,\n                                     uint8_t op_code, tGATT_STATUS status,\n                                     tGATTS_RSP* p_msg,\n                                     tGATT_SR_CMD* sr_res_p) {\n  tGATT_STATUS ret_code = GATT_SUCCESS;\n  uint16_t payload_size = gatt_tcb_get_payload_size_rx(tcb, sr_res_p->cid);\n\n  VLOG(1) << __func__ << \" gatt_if=\" << +gatt_if;\n\n  gatt_sr_update_cback_cnt(tcb, sr_res_p->cid, gatt_if, false, false);\n\n  if ((op_code == GATT_REQ_READ_MULTI) ||\n      (op_code == GATT_REQ_READ_MULTI_VAR)) {\n    /* If no error and still waiting, just return */\n    if (!process_read_multi_rsp(sr_res_p, status, p_msg, payload_size))\n      return (GATT_SUCCESS);\n  } else {\n    if (op_code == GATT_REQ_PREPARE_WRITE && status == GATT_SUCCESS)\n      gatt_sr_update_prep_cnt(tcb, gatt_if, true, false);\n\n    if (op_code == GATT_REQ_EXEC_WRITE && status != GATT_SUCCESS)\n      gatt_sr_reset_cback_cnt(tcb, sr_res_p->cid);\n\n    sr_res_p->status = status;\n\n    if (gatt_sr_is_cback_cnt_zero(tcb) && status == GATT_SUCCESS) {\n      if (sr_res_p->p_rsp_msg == NULL) {\n        sr_res_p->p_rsp_msg = attp_build_sr_msg(tcb, (uint8_t)(op_code + 1),\n                                                (tGATT_SR_MSG*)p_msg);\n      } else {\n        LOG(ERROR) << \"Exception!!! already has respond message\";\n      }\n    }\n  }\n  if (gatt_sr_is_cback_cnt_zero(tcb)) {\n    if ((sr_res_p->status == GATT_SUCCESS) && (sr_res_p->p_rsp_msg)) {\n      ret_code = attp_send_sr_msg(tcb, sr_res_p->cid, sr_res_p->p_rsp_msg);\n      sr_res_p->p_rsp_msg = NULL;\n    } else {\n      ret_code = gatt_send_error_rsp(tcb, sr_res_p->cid, status, op_code,\n                                     sr_res_p->handle, false);\n    }\n\n    gatt_dequeue_sr_cmd(tcb, sr_res_p->cid);\n  }\n\n  VLOG(1) << __func__ << \" ret_code=\" << +ret_code;\n\n  return ret_code;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_exec_write_req\n *\n * Description      This function is called to process the execute write request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_exec_write_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint8_t *p = p_data, flag, i = 0;\n  uint32_t trans_id = 0;\n  tGATT_IF gatt_if;\n  uint16_t conn_id;\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1)\n        << \"Conformance tst: forced err rspv for Execute Write: error status=\"\n        << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        gatt_cb.handle, false);\n\n    return;\n  }\n#endif\n\n  if (len < sizeof(flag)) {\n    android_errorWriteLog(0x534e4554, \"73172115\");\n    LOG(ERROR) << __func__ << \"invalid length\";\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_EXEC_WRITE, 0,\n                        false);\n    return;\n  }\n\n  STREAM_TO_UINT8(flag, p);\n\n  /* mask the flag */\n  flag &= GATT_PREP_WRITE_EXEC;\n\n  /* no prep write is queued */\n  if (!gatt_sr_is_prep_cnt_zero(tcb)) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, 0);\n    gatt_sr_copy_prep_cnt_to_cback_cnt(tcb);\n\n    for (i = 0; i < GATT_MAX_APPS; i++) {\n      if (tcb.prep_cnt[i]) {\n        gatt_if = (tGATT_IF)(i + 1);\n        conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_if);\n        tGATTS_DATA gatts_data;\n        gatts_data.exec_write = flag;\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_WRITE_EXEC,\n                                  &gatts_data);\n        tcb.prep_cnt[i] = 0;\n      }\n    }\n  } else /* nothing needs to be executed , send response now */\n  {\n    LOG(ERROR) << \"gatt_process_exec_write_req: no prepare write pending\";\n    gatt_send_error_rsp(tcb, cid, GATT_ERROR, GATT_REQ_EXEC_WRITE, 0, false);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_read_multi_req\n *\n * Description      This function is called to process the read multiple request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_read_multi_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint32_t trans_id;\n  uint16_t handle = 0, ll = len;\n  uint8_t* p = p_data;\n  tGATT_STATUS err = GATT_SUCCESS;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n\n  VLOG(1) << __func__;\n\n  tGATT_READ_MULTI* multi_req = gatt_sr_get_read_multi(tcb, cid);\n  multi_req->num_handles = 0;\n  multi_req->variable_len = (op_code == GATT_REQ_READ_MULTI_VAR);\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rspvofr ReadMultiple: error status=\"\n            << +gatt_cb.err_status;\n\n    STREAM_TO_UINT16(handle, p);\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        handle, false);\n\n    return;\n  }\n#endif\n\n  while (ll >= 2 && multi_req->num_handles < GATT_MAX_READ_MULTI_HANDLES) {\n    STREAM_TO_UINT16(handle, p);\n\n    auto it = gatt_sr_find_i_rcb_by_handle(handle);\n    if (it != gatt_cb.srv_list_info->end()) {\n      multi_req->handles[multi_req->num_handles++] = handle;\n\n      /* check read permission */\n      err = gatts_read_attr_perm_check(it->p_db, false, handle, sec_flag,\n                                       key_size);\n      if (err != GATT_SUCCESS) {\n        VLOG(1) << StringPrintf(\"read permission denied : 0x%02x\", err);\n        break;\n      }\n    } else {\n      /* invalid handle */\n      err = GATT_INVALID_HANDLE;\n      break;\n    }\n    ll -= 2;\n  }\n\n  if (ll != 0) {\n    LOG(ERROR) << \"max attribute handle reached in ReadMultiple Request.\";\n  }\n\n  if (multi_req->num_handles == 0) err = GATT_INVALID_HANDLE;\n\n  if (err == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, multi_req->handles[0]);\n    if (trans_id != 0) {\n      tGATT_SR_CMD* sr_cmd_p = gatt_sr_get_cmd_by_cid(tcb, cid);\n\n      gatt_sr_reset_cback_cnt(tcb,\n                              cid); /* read multiple use multi_rsp_q's count*/\n\n      for (ll = 0; ll < multi_req->num_handles; ll++) {\n        tGATTS_RSP* p_msg = (tGATTS_RSP*)osi_calloc(sizeof(tGATTS_RSP));\n        handle = multi_req->handles[ll];\n        auto it = gatt_sr_find_i_rcb_by_handle(handle);\n\n        p_msg->attr_value.handle = handle;\n        err = gatts_read_attr_value_by_handle(\n            tcb, cid, it->p_db, op_code, handle, 0, p_msg->attr_value.value,\n            &p_msg->attr_value.len, GATT_MAX_ATTR_LEN, sec_flag, key_size,\n            trans_id);\n\n        if (err == GATT_SUCCESS) {\n          gatt_sr_process_app_rsp(tcb, it->gatt_if, trans_id, op_code,\n                                  GATT_SUCCESS, p_msg, sr_cmd_p);\n        }\n        /* either not using or done using the buffer, release it now */\n        osi_free(p_msg);\n      }\n    } else\n      err = GATT_NO_RESOURCES;\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (err != GATT_SUCCESS && err != GATT_PENDING && err != GATT_BUSY)\n    gatt_send_error_rsp(tcb, cid, err, op_code, handle, false);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_build_primary_service_rsp\n *\n * Description      Primamry service request processed internally. Theretically\n *                  only deal with ReadByTypeVAlue and ReadByGroupType.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic tGATT_STATUS gatt_build_primary_service_rsp(\n    BT_HDR* p_msg, tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n    uint16_t s_hdl, uint16_t e_hdl, UNUSED_ATTR uint8_t* p_data,\n    const Uuid& value) {\n  tGATT_STATUS status = GATT_NOT_FOUND;\n  uint8_t handle_len = 4;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl < s_hdl || el.s_hdl > e_hdl ||\n        el.type != GATT_UUID_PRI_SERVICE) {\n      continue;\n    }\n\n    Uuid* p_uuid = gatts_get_service_uuid(el.p_db);\n    if (!p_uuid) continue;\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE)\n      handle_len = 4 + gatt_build_uuid_to_stream_len(*p_uuid);\n\n    /* get the length byte in the repsonse */\n    if (p_msg->offset == 0) {\n      *p++ = op_code + 1;\n      p_msg->len++;\n      p_msg->offset = handle_len;\n\n      if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n        *p++ = (uint8_t)p_msg->offset; /* length byte */\n        p_msg->len++;\n      }\n    }\n\n    if (p_msg->len + p_msg->offset > payload_size ||\n        handle_len != p_msg->offset) {\n      break;\n    }\n\n    if (op_code == GATT_REQ_FIND_TYPE_VALUE && value != *p_uuid) continue;\n\n    UINT16_TO_STREAM(p, el.s_hdl);\n\n    if (gatt_cb.last_service_handle &&\n        gatt_cb.last_service_handle == el.s_hdl) {\n      VLOG(1) << \"Use 0xFFFF for the last primary attribute\";\n      /* see GATT ERRATA 4065, 4063, ATT ERRATA 4062 */\n      UINT16_TO_STREAM(p, 0xFFFF);\n    } else {\n      UINT16_TO_STREAM(p, el.e_hdl);\n    }\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE)\n      gatt_build_uuid_to_stream(&p, *p_uuid);\n\n    status = GATT_SUCCESS;\n    p_msg->len += p_msg->offset;\n  }\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  return status;\n}\n\n/**\n * fill the find information response information in the given buffer.\n *\n * Returns          true: if data filled sucessfully.\n *                  false: packet full, or format mismatch.\n */\nstatic tGATT_STATUS gatt_build_find_info_rsp(tGATT_SRV_LIST_ELEM& el,\n                                             BT_HDR* p_msg, uint16_t& len,\n                                             uint16_t s_hdl, uint16_t e_hdl) {\n  uint8_t info_pair_len[2] = {4, 18};\n\n  if (!el.p_db) return GATT_NOT_FOUND;\n\n  /* check the attribute database */\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET + p_msg->len;\n\n  for (auto& attr : el.p_db->attr_list) {\n    if (attr.handle > e_hdl) break;\n\n    if (attr.handle < s_hdl) continue;\n\n    uint8_t uuid_len = attr.uuid.GetShortestRepresentationSize();\n    if (p_msg->offset == 0)\n      p_msg->offset = (uuid_len == Uuid::kNumBytes16) ? GATT_INFO_TYPE_PAIR_16\n                                                      : GATT_INFO_TYPE_PAIR_128;\n\n    if (len < info_pair_len[p_msg->offset - 1]) return GATT_NO_RESOURCES;\n\n    if (p_msg->offset == GATT_INFO_TYPE_PAIR_16 &&\n        uuid_len == Uuid::kNumBytes16) {\n      UINT16_TO_STREAM(p, attr.handle);\n      UINT16_TO_STREAM(p, attr.uuid.As16Bit());\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 &&\n               uuid_len == Uuid::kNumBytes128) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 &&\n               uuid_len == Uuid::kNumBytes32) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else {\n      LOG(ERROR) << \"format mismatch\";\n      return GATT_NO_RESOURCES;\n      /* format mismatch */\n    }\n    p_msg->len += info_pair_len[p_msg->offset - 1];\n    len -= info_pair_len[p_msg->offset - 1];\n    return GATT_SUCCESS;\n  }\n\n  return GATT_NOT_FOUND;\n}\n\nstatic tGATT_STATUS read_handles(uint16_t& len, uint8_t*& p, uint16_t& s_hdl,\n                                 uint16_t& e_hdl) {\n  if (len < 4) return GATT_INVALID_PDU;\n\n  /* obtain starting handle, and ending handle */\n  STREAM_TO_UINT16(s_hdl, p);\n  STREAM_TO_UINT16(e_hdl, p);\n  len -= 4;\n\n  if (s_hdl > e_hdl || !GATT_HANDLE_IS_VALID(s_hdl) ||\n      !GATT_HANDLE_IS_VALID(e_hdl)) {\n    return GATT_INVALID_HANDLE;\n  }\n\n  return GATT_SUCCESS;\n}\n\nstatic tGATT_STATUS gatts_validate_packet_format(uint8_t op_code, uint16_t& len,\n                                                 uint8_t*& p, Uuid* p_uuid,\n                                                 uint16_t& s_hdl,\n                                                 uint16_t& e_hdl) {\n  tGATT_STATUS ret = read_handles(len, p, s_hdl, e_hdl);\n  if (ret != GATT_SUCCESS) return ret;\n\n  if (len < 2) return GATT_INVALID_PDU;\n\n  /* parse uuid now */\n  CHECK(p_uuid);\n  uint16_t uuid_len = (op_code == GATT_REQ_FIND_TYPE_VALUE) ? 2 : len;\n  if (!gatt_parse_uuid_from_cmd(p_uuid, uuid_len, &p)) {\n    VLOG(1) << \"Bad UUID\";\n    return GATT_INVALID_PDU;\n  }\n\n  len -= uuid_len;\n  return GATT_SUCCESS;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_primary_service_req\n *\n * Description      Process ReadByGroupType/ReadByTypeValue request, for\n *                  discovering all primary services or discover primary service\n *                  by UUID request.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n                                       uint8_t op_code, uint16_t len,\n                                       uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  Uuid uuid = Uuid::kEmpty;\n\n  uint8_t reason =\n      gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  if (uuid != Uuid::From16Bit(GATT_UUID_PRI_SERVICE)) {\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n      gatt_send_error_rsp(tcb, cid, GATT_UNSUPPORT_GRP_TYPE, op_code, s_hdl,\n                          false);\n      VLOG(1) << StringPrintf(\"unexpected ReadByGrpType Group: %s\",\n                              uuid.ToString().c_str());\n      return;\n    }\n\n    // we do not support ReadByTypeValue with any non-primamry_service type\n    gatt_send_error_rsp(tcb, cid, GATT_NOT_FOUND, op_code, s_hdl, false);\n    VLOG(1) << StringPrintf(\"unexpected ReadByTypeValue type: %s\",\n                            uuid.ToString().c_str());\n    return;\n  }\n\n  // TODO: we assume theh value is UUID, there is no such requirement in spec\n  Uuid value = Uuid::kEmpty;\n  if (op_code == GATT_REQ_FIND_TYPE_VALUE) {\n    if (!gatt_parse_uuid_from_cmd(&value, len, &p_data)) {\n      gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, s_hdl, false);\n    }\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  uint16_t msg_len =\n      (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n  reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl,\n                                          e_hdl, p_data, value);\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_find_info\n *\n * Description      process find information request, for discover character\n *                  descriptors.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t op_code, uint16_t len,\n                                    uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  uint8_t reason = read_handles(len, p_data, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n  uint16_t buf_len =\n      (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n  reason = GATT_NOT_FOUND;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n  *p++ = op_code + 1;\n  p_msg->len = 2;\n\n  buf_len = payload_size - 2;\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl <= e_hdl && el.e_hdl >= s_hdl) {\n      reason = gatt_build_find_info_rsp(el, p_msg, buf_len, s_hdl, e_hdl);\n      if (reason == GATT_NO_RESOURCES) {\n        reason = GATT_SUCCESS;\n        break;\n      }\n    }\n  }\n\n  *p = (uint8_t)p_msg->offset;\n\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n  } else\n    attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_mtu_req\n *\n * Description      This function is called to process excahnge MTU request.\n *                  Only used on LE.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_mtu_req(tGATT_TCB& tcb, uint16_t cid, uint16_t len,\n                                  uint8_t* p_data) {\n  /* BR/EDR conenction, send error response */\n  if (cid != L2CAP_ATT_CID) {\n    gatt_send_error_rsp(tcb, cid, GATT_REQ_NOT_SUPPORTED, GATT_REQ_MTU, 0,\n                        false);\n    return;\n  }\n\n  if (len < GATT_MTU_REQ_MIN_LEN) {\n    LOG(ERROR) << \"invalid MTU request PDU received.\";\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_MTU, 0, false);\n    return;\n  }\n\n  uint16_t mtu = 0;\n  uint8_t* p = p_data;\n  STREAM_TO_UINT16(mtu, p);\n  /* mtu must be greater than default MTU which is 23/48 */\n  if (mtu < GATT_DEF_BLE_MTU_SIZE)\n    tcb.payload_size = GATT_DEF_BLE_MTU_SIZE;\n  else if (mtu > GATT_MAX_MTU_SIZE)\n    tcb.payload_size = GATT_MAX_MTU_SIZE;\n  else\n    tcb.payload_size = mtu;\n\n  LOG(INFO) << \"MTU request PDU with MTU size \" << +tcb.payload_size;\n\n  BTM_SetBleDataLength(tcb.peer_bda, tcb.payload_size + L2CAP_PKT_OVERHEAD);\n\n  tGATT_SR_MSG gatt_sr_msg;\n  gatt_sr_msg.mtu = tcb.payload_size;\n  BT_HDR* p_buf = attp_build_sr_msg(tcb, GATT_RSP_MTU, &gatt_sr_msg);\n  attp_send_sr_msg(tcb, cid, p_buf);\n\n  tGATTS_DATA gatts_data;\n  gatts_data.mtu = tcb.payload_size;\n  /* Notify all registered applicaiton with new MTU size. Us a transaction ID */\n  /* of 0, as no response is allowed from applcations                    */\n  for (int i = 0; i < GATT_MAX_APPS; i++) {\n    if (gatt_cb.cl_rcb[i].in_use) {\n      uint16_t conn_id =\n          GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_cb.cl_rcb[i].gatt_if);\n      gatt_sr_send_req_callback(conn_id, 0, GATTS_REQ_TYPE_MTU, &gatts_data);\n    }\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_read_by_type_req\n *\n * Description      process Read By type request.\n *                  This PDU can be used to perform:\n *                  - read characteristic value\n *                  - read characteristic descriptor value\n *                  - discover characteristic\n *                  - discover characteristic by UUID\n *                  - relationship discovery\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n                                           uint8_t op_code, uint16_t len,\n                                           uint8_t* p_data) {\n  Uuid uuid = Uuid::kEmpty;\n  uint16_t s_hdl = 0, e_hdl = 0, err_hdl = 0;\n  tGATT_STATUS reason =\n      gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rsp for ReadByType: error status=\"\n            << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        s_hdl, false);\n\n    return;\n  }\n#endif\n\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  *p++ = op_code + 1;\n  /* reserve length byte */\n  p_msg->len = 2;\n  uint16_t buf_len = payload_size - 2;\n\n  reason = GATT_NOT_FOUND;\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl <= e_hdl && el.e_hdl >= s_hdl) {\n      tGATT_SEC_FLAG sec_flag;\n      uint8_t key_size;\n      gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n      tGATT_STATUS ret = gatts_db_read_attr_value_by_type(\n          tcb, cid, el.p_db, op_code, p_msg, s_hdl, e_hdl, uuid, &buf_len,\n          sec_flag, key_size, 0, &err_hdl);\n      if (ret != GATT_NOT_FOUND) {\n        reason = ret;\n        if (ret == GATT_NO_RESOURCES) reason = GATT_SUCCESS;\n      }\n\n      if (ret != GATT_SUCCESS && ret != GATT_NOT_FOUND) {\n        s_hdl = err_hdl;\n        break;\n      }\n    }\n  }\n  *p = (uint8_t)p_msg->offset;\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n\n    /* in theroy BUSY is not possible(should already been checked), protected\n     * check */\n    if (reason != GATT_PENDING && reason != GATT_BUSY)\n      gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/**\n * This function is called to process the write request from client.\n */\nstatic void gatts_process_write_req(tGATT_TCB& tcb, uint16_t cid,\n                                    tGATT_SRV_LIST_ELEM& el, uint16_t handle,\n                                    uint8_t op_code, uint16_t len,\n                                    uint8_t* p_data,\n                                    bt_gatt_db_attribute_type_t gatt_type) {\n  tGATTS_DATA sr_data;\n  uint32_t trans_id;\n  tGATT_STATUS status;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size, *p = p_data;\n  uint16_t conn_id;\n\n  memset(&sr_data, 0, sizeof(tGATTS_DATA));\n\n  switch (op_code) {\n    case GATT_REQ_PREPARE_WRITE:\n      if (len < 2 || p == nullptr) {\n        LOG(ERROR) << __func__\n                   << \": Prepare write request was invalid - missing offset, \"\n                      \"sending error response\";\n        gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, handle, false);\n        return;\n      }\n      sr_data.write_req.is_prep = true;\n      STREAM_TO_UINT16(sr_data.write_req.offset, p);\n      len -= 2;\n      FALLTHROUGH_INTENDED; /* FALLTHROUGH */\n    case GATT_SIGN_CMD_WRITE:\n      if (op_code == GATT_SIGN_CMD_WRITE) {\n        VLOG(1) << \"Write CMD with data sigining\";\n        len -= GATT_AUTH_SIGN_LEN;\n      }\n      FALLTHROUGH_INTENDED; /* FALLTHROUGH */\n    case GATT_CMD_WRITE:\n    case GATT_REQ_WRITE:\n      if (op_code == GATT_REQ_WRITE || op_code == GATT_REQ_PREPARE_WRITE)\n        sr_data.write_req.need_rsp = true;\n      sr_data.write_req.handle = handle;\n      if (len > GATT_MAX_ATTR_LEN) len = GATT_MAX_ATTR_LEN;\n      sr_data.write_req.len = len;\n      if (len != 0 && p != nullptr) {\n        memcpy(sr_data.write_req.value, p, len);\n      }\n      break;\n  }\n\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n  status = gatts_write_attr_perm_check(el.p_db, op_code, handle,\n                                       sr_data.write_req.offset, p, len,\n                                       sec_flag, key_size);\n\n  if (status == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, handle);\n    if (trans_id != 0) {\n      conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, el.gatt_if);\n\n      uint8_t opcode = 0;\n      if (gatt_type == BTGATT_DB_DESCRIPTOR) {\n        opcode = GATTS_REQ_TYPE_WRITE_DESCRIPTOR;\n      } else if (gatt_type == BTGATT_DB_CHARACTERISTIC) {\n        opcode = GATTS_REQ_TYPE_WRITE_CHARACTERISTIC;\n      } else {\n        LOG(ERROR) << __func__\n                   << \"%s: Attempt to write attribute that's not tied with\"\n                      \" characteristic or descriptor value.\";\n        status = GATT_ERROR;\n      }\n\n      if (opcode) {\n        gatt_sr_send_req_callback(conn_id, trans_id, opcode, &sr_data);\n        status = GATT_PENDING;\n      }\n    } else {\n      LOG(ERROR) << \"max pending command, send error\";\n      status = GATT_BUSY; /* max pending command, application error */\n    }\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (status != GATT_PENDING && status != GATT_BUSY &&\n      (op_code == GATT_REQ_PREPARE_WRITE || op_code == GATT_REQ_WRITE)) {\n    gatt_send_error_rsp(tcb, cid, status, op_code, handle, false);\n  }\n  return;\n}\n\n/**\n * This function is called to process the read request from client.\n */\nstatic void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                   tGATT_SRV_LIST_ELEM& el, uint8_t op_code,\n                                   uint16_t handle, uint16_t len,\n                                   uint8_t* p_data) {\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  uint16_t offset = 0;\n\n  if (op_code == GATT_REQ_READ_BLOB && len < sizeof(uint16_t)) {\n    /* Error: packet length is too short */\n    LOG(ERROR) << __func__ << \": packet length=\" << len\n               << \" too short. min=\" << sizeof(uint16_t);\n    android_errorWriteWithInfoLog(0x534e4554, \"73172115\", -1, NULL, 0);\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, 0, false);\n    return;\n  }\n\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n\n  if (op_code == GATT_REQ_READ_BLOB) STREAM_TO_UINT16(offset, p_data);\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n  *p++ = op_code + 1;\n  p_msg->len = 1;\n  buf_len = payload_size - 1;\n\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n  uint16_t value_len = 0;\n  tGATT_STATUS reason = gatts_read_attr_value_by_handle(\n      tcb, cid, el.p_db, op_code, handle, offset, p, &value_len,\n      (uint16_t)buf_len, sec_flag, key_size, 0);\n  p_msg->len += value_len;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n\n    /* in theory BUSY is not possible(should already been checked), protected\n     * check */\n    if (reason != GATT_PENDING && reason != GATT_BUSY)\n      gatt_send_error_rsp(tcb, cid, reason, op_code, handle, false);\n\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_attribute_req\n *\n * Description      This function is called to process the per attribute handle\n *                  request from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_attribute_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint16_t handle = 0;\n  uint8_t* p = p_data;\n  tGATT_STATUS status = GATT_INVALID_HANDLE;\n\n  if (len < 2) {\n    LOG(ERROR) << \"Illegal PDU length, discard request\";\n    status = GATT_INVALID_PDU;\n  } else {\n    STREAM_TO_UINT16(handle, p);\n    len -= 2;\n  }\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  gatt_cb.handle = handle;\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rsp: error status=\"\n            << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, cid, gatt_cb.req_op_code,\n                        handle, false);\n\n    return;\n  }\n#endif\n\n  if (GATT_HANDLE_IS_VALID(handle)) {\n    for (auto& el : *gatt_cb.srv_list_info) {\n      if (el.s_hdl <= handle && el.e_hdl >= handle) {\n        for (const auto& attr : el.p_db->attr_list) {\n          if (attr.handle == handle) {\n            switch (op_code) {\n              case GATT_REQ_READ: /* read char/char descriptor value */\n              case GATT_REQ_READ_BLOB:\n                gatts_process_read_req(tcb, cid, el, op_code, handle, len, p);\n                break;\n\n              case GATT_REQ_WRITE: /* write char/char descriptor value */\n              case GATT_CMD_WRITE:\n              case GATT_SIGN_CMD_WRITE:\n              case GATT_REQ_PREPARE_WRITE:\n                gatts_process_write_req(tcb, cid, el, handle, op_code, len, p,\n                                        attr.gatt_type);\n                break;\n              default:\n                break;\n            }\n            status = GATT_SUCCESS;\n            break;\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  if (status != GATT_SUCCESS && op_code != GATT_CMD_WRITE &&\n      op_code != GATT_SIGN_CMD_WRITE)\n    gatt_send_error_rsp(tcb, cid, status, op_code, handle, false);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_proc_srv_chg_ind_ack\n *\n * Description      This function process the service changed indicaiton ACK\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_proc_srv_chg_ind_ack(tGATT_TCB tcb) {\n  tGATTS_SRV_CHG_REQ req;\n  tGATTS_SRV_CHG* p_buf = NULL;\n\n  VLOG(1) << __func__;\n\n  p_buf = gatt_is_bda_in_the_srv_chg_clt_list(tcb.peer_bda);\n  if (p_buf != NULL) {\n    VLOG(1) << \"NV update set srv chg = false\";\n    p_buf->srv_changed = false;\n    memcpy(&req.srv_chg, p_buf, sizeof(tGATTS_SRV_CHG));\n    if (gatt_cb.cb_info.p_srv_chg_callback)\n      (*gatt_cb.cb_info.p_srv_chg_callback)(GATTS_SRV_CHG_CMD_UPDATE_CLIENT,\n                                            &req, NULL);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_chk_pending_ind\n *\n * Description      This function check any pending indication needs to be sent\n *                  if there is a pending indication then sent the indication\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_chk_pending_ind(tGATT_TCB& tcb) {\n  VLOG(1) << __func__;\n\n  tGATT_VALUE* p_buf =\n      (tGATT_VALUE*)fixed_queue_try_peek_first(tcb.pending_ind_q);\n  if (p_buf != NULL) {\n    GATTS_HandleValueIndication(p_buf->conn_id, p_buf->handle, p_buf->len,\n                                p_buf->value);\n    osi_free(fixed_queue_try_remove_from_queue(tcb.pending_ind_q, p_buf));\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_proc_ind_ack\n *\n * Description      This function processes the Indication ack\n *\n * Returns          true continue to process the indication ack by the\n *                  application if the ACK is not a Service Changed Indication\n *\n ******************************************************************************/\nstatic bool gatts_proc_ind_ack(tGATT_TCB& tcb, uint16_t ack_handle) {\n  bool continue_processing = true;\n\n  VLOG(1) << __func__ << \" ack handle=%d\" << ack_handle;\n\n  if (ack_handle == gatt_cb.handle_of_h_r) {\n    gatts_proc_srv_chg_ind_ack(tcb);\n    /* there is no need to inform the application since srv chg is handled\n     * internally by GATT */\n    continue_processing = false;\n\n    // After receiving ack of svc_chg_ind, reset client status\n    gatt_sr_update_cl_status(tcb, /* chg_aware= */ true);\n  }\n\n  gatts_chk_pending_ind(tcb);\n  return continue_processing;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_value_conf\n *\n * Description      This function is called to process the handle value\n *                  confirmation.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_value_conf(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code) {\n  uint16_t handle;\n\n  if (!gatt_tcb_find_indicate_handle(tcb, cid, &handle)) {\n    LOG(ERROR) << \"unexpected handle value confirmation\";\n    return;\n  }\n\n  gatt_stop_conf_timer(tcb, cid);\n\n  bool continue_processing = gatts_proc_ind_ack(tcb, handle);\n\n  if (continue_processing) {\n    tGATTS_DATA gatts_data;\n    gatts_data.handle = handle;\n    for (auto& el : *gatt_cb.srv_list_info) {\n      if (el.s_hdl <= handle && el.e_hdl >= handle) {\n        uint32_t trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, handle);\n        uint16_t conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, el.gatt_if);\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_CONF,\n                                  &gatts_data);\n      }\n    }\n  }\n}\n\nstatic bool gatts_process_db_out_of_sync(tGATT_TCB& tcb, uint16_t cid,\n                                         uint8_t op_code, uint16_t len,\n                                         uint8_t* p_data) {\n  if (gatt_sr_is_cl_change_aware(tcb)) return false;\n\n  // default value\n  bool should_ignore = true;\n  bool should_rsp = true;\n\n  switch (op_code) {\n    case GATT_REQ_READ_BY_TYPE: {\n      // Check if read database hash by UUID\n      Uuid uuid = Uuid::kEmpty;\n      uint16_t s_hdl = 0, e_hdl = 0;\n      uint16_t db_hash_handle = gatt_cb.handle_of_database_hash;\n      tGATT_STATUS reason = gatts_validate_packet_format(op_code, len, p_data,\n                                                         &uuid, s_hdl, e_hdl);\n      if (reason == GATT_SUCCESS &&\n          (s_hdl <= db_hash_handle && db_hash_handle <= e_hdl) &&\n          (uuid == Uuid::From16Bit(GATT_UUID_DATABASE_HASH)))\n        should_ignore = false;\n\n    } break;\n    case GATT_REQ_READ: {\n      // Check if read database hash by handle\n      uint16_t handle = 0;\n      uint8_t* p = p_data;\n      tGATT_STATUS status = GATT_SUCCESS;\n\n      if (len < 2) {\n        status = GATT_INVALID_PDU;\n      } else {\n        STREAM_TO_UINT16(handle, p);\n        len -= 2;\n      }\n\n      if (status == GATT_SUCCESS && handle == gatt_cb.handle_of_database_hash)\n        should_ignore = false;\n\n    } break;\n    case GATT_REQ_READ_BY_GRP_TYPE: /* discover primary services */\n    case GATT_REQ_FIND_TYPE_VALUE:  /* discover service by UUID */\n    case GATT_REQ_FIND_INFO:        /* discover char descrptor */\n    case GATT_REQ_READ_BLOB:        /* read long char */\n    case GATT_REQ_READ_MULTI:       /* read multi char*/\n    case GATT_REQ_WRITE:            /* write char/char descriptor value */\n    case GATT_REQ_PREPARE_WRITE:    /* write long char */\n      // Use default value\n      break;\n    case GATT_CMD_WRITE:      /* cmd */\n    case GATT_SIGN_CMD_WRITE: /* sign cmd */\n      should_rsp = false;\n      break;\n    case GATT_REQ_MTU:           /* configure mtu */\n    case GATT_REQ_EXEC_WRITE:    /* execute write */\n    case GATT_HANDLE_VALUE_CONF: /* confirm for indication */\n    default:\n      should_ignore = false;\n  }\n\n  if (should_ignore) {\n    if (should_rsp) {\n      gatt_send_error_rsp(tcb, cid, GATT_DATABASE_OUT_OF_SYNC, op_code, 0x0000,\n                          false);\n    }\n    LOG(INFO) << __func__ << \": database out of sync, device=\" << tcb.peer_bda\n              << \", op_code=\" << loghex((uint16_t)op_code)\n              << \", should_rsp=\" << should_rsp;\n    gatt_sr_update_cl_status(tcb, /* chg_aware= */ should_rsp);\n  }\n\n  return should_ignore;\n}\n\n/** This function is called to handle the client requests to server */\nvoid gatt_server_handle_client_req(tGATT_TCB& tcb, uint16_t cid,\n                                   uint8_t op_code, uint16_t len,\n                                   uint8_t* p_data) {\n  /* there is pending command, discard this one */\n  if (!gatt_sr_cmd_empty(tcb, cid) && op_code != GATT_HANDLE_VALUE_CONF) return;\n\n  /* the size of the message may not be bigger than the local max PDU size*/\n  /* The message has to be smaller than the agreed MTU, len does not include op\n   * code */\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_rx(tcb, cid);\n  if (len >= payload_size) {\n    LOG(ERROR) << StringPrintf(\"server receive invalid PDU size:%d pdu size:%d\",\n                               len + 1, payload_size);\n    /* for invalid request expecting response, send it now */\n    if (op_code != GATT_CMD_WRITE && op_code != GATT_SIGN_CMD_WRITE &&\n        op_code != GATT_HANDLE_VALUE_CONF) {\n      gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, 0, false);\n    }\n    /* otherwise, ignore the pkt */\n  } else {\n    // handle database out of sync\n    if (gatts_process_db_out_of_sync(tcb, cid, op_code, len, p_data)) return;\n\n    switch (op_code) {\n      case GATT_REQ_READ_BY_GRP_TYPE: /* discover primary services */\n      case GATT_REQ_FIND_TYPE_VALUE:  /* discover service by UUID */\n        gatts_process_primary_service_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_FIND_INFO: /* discover char descrptor */\n        gatts_process_find_info(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ_BY_TYPE: /* read characteristic value, char descriptor\n                                     value */\n        /* discover characteristic, discover char by UUID */\n        gatts_process_read_by_type_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ: /* read char/char descriptor value */\n      case GATT_REQ_READ_BLOB:\n      case GATT_REQ_WRITE: /* write char/char descriptor value */\n      case GATT_CMD_WRITE:\n      case GATT_SIGN_CMD_WRITE:\n      case GATT_REQ_PREPARE_WRITE:\n        gatts_process_attribute_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_HANDLE_VALUE_CONF:\n        gatts_process_value_conf(tcb, cid, op_code);\n        break;\n\n      case GATT_REQ_MTU:\n        gatts_process_mtu_req(tcb, cid, len, p_data);\n        break;\n\n      case GATT_REQ_EXEC_WRITE:\n        gatt_process_exec_write_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ_MULTI:\n      case GATT_REQ_READ_MULTI_VAR:\n        gatt_process_read_multi_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      default:\n        break;\n    }\n  }\n}\n```"
                    }
                ]
            },
            {
                "downstream_version": "14",
                "branch_used": "android14-release",
                "downstream_patch": "2fc3087b9ac3019518c6ceb8a64d181d6bb04907",
                "repo_path": "android_repos/Bluetooth",
                "result": "failure",
                "downstream_patch_content": "commit 2fc3087b9ac3019518c6ceb8a64d181d6bb04907\nAuthor: Brian Delwiche <delwiche@google.com>\nDate:   Fri Oct 4 18:23:45 2024 +0000\n\n    Fix OOB writes in gatt_sr.cc\n    \n    At various points in gatt_sr.cc, the output of the\n    gatt_tcb_get_payload_size function is used without checking for a\n    positive length.  However, in exceptional cases it is possible for the\n    channel to be closed at the time the function is called, which will lead\n    to a zero length and cause an OOB write in subsequent processing.\n    \n    Fix all of these.\n    \n    Bug: 364026473\n    Bug: 364027038\n    Bug: 364027949\n    Bug: 364025411\n    Test: m libbluetooth\n    Test: researcher POC\n    Flag: EXEMPT trivial validity checks\n    Tag: #security\n    Ignore-AOSP-First: Security\n    Merged-In: I9b30499d4aed6ab42f3cdb2c0de7df2c1a827404\n    Change-Id: I9b30499d4aed6ab42f3cdb2c0de7df2c1a827404\n\ndiff --git a/system/stack/gatt/gatt_sr.cc b/system/stack/gatt/gatt_sr.cc\nindex 6f81b90514..c61df52bc8 100644\n--- a/system/stack/gatt/gatt_sr.cc\n+++ b/system/stack/gatt/gatt_sr.cc\n@@ -734,6 +734,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n@@ -769,6 +774,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n@@ -902,6 +913,11 @@ static void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n@@ -1049,6 +1065,11 @@ static void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t* p_data) {\n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   uint16_t offset = 0;\n \n",
                "file_conflicts": [
                    {
                        "file_name": "system/stack/gatt/gatt_sr.cc",
                        "total_hunks": 4,
                        "failed_hunks": [
                            1,
                            2
                        ],
                        "inline_merge_conflicts": [
                            {
                                "hunk_number": 1,
                                "merge_conflict": "<<<<<<< DOWNSTREAM (version 14)\n\n=======\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n>>>>>>> UPSTREAM PATCH (commit 7de5617f7d5266fe57c990c428621b5d4e92728a)"
                            },
                            {
                                "hunk_number": 2,
                                "merge_conflict": "<<<<<<< DOWNSTREAM (version 14)\n\n=======\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n>>>>>>> UPSTREAM PATCH (commit 7de5617f7d5266fe57c990c428621b5d4e92728a)"
                            }
                        ],
                        "rej_file_content": "```diff\n--- system/stack/gatt/gatt_sr.cc\n+++ system/stack/gatt/gatt_sr.cc\n@@ -772,6 +772,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_\n \n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl, e_hdl, p_data, value);\n@@ -804,6 +809,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid, uint8_t op_cod\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n```",
                        "patch_apply_output": "patching file system/stack/gatt/gatt_sr.cc\nHunk #1 FAILED at 772.\nHunk #2 FAILED at 804.\nHunk #3 succeeded at 902 with fuzz 2 (offset -47 lines).\nHunk #4 succeeded at 1054 with fuzz 2 (offset -47 lines).\n2 out of 4 hunks FAILED -- saving rejects to file system/stack/gatt/gatt_sr.cc.rej",
                        "inline_merge_output": "patching file system/stack/gatt/gatt_sr.cc\nHunk #1 NOT MERGED at 780-789.\nHunk #2 NOT MERGED at 828-837.\nHunk #3 merged at 988-992.\nHunk #4 merged at 1145-1149.",
                        "upstream_file_content": "```cc\n/******************************************************************************\n *\n *  Copyright 2008-2012 Broadcom Corporation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at:\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n ******************************************************************************/\n\n/******************************************************************************\n *\n *  this file contains the GATT server functions\n *\n ******************************************************************************/\n\n#include <bluetooth/log.h>\n#include <com_android_bluetooth_flags.h>\n#include <string.h>\n\n#include <algorithm>\n\n#include \"gatt_int.h\"\n#include \"hardware/bt_gatt_types.h\"\n#include \"internal_include/bt_target.h\"\n#include \"l2c_api.h\"\n#include \"osi/include/allocator.h\"\n#include \"stack/arbiter/acl_arbiter.h\"\n#include \"stack/eatt/eatt.h\"\n#include \"stack/include/bt_hdr.h\"\n#include \"stack/include/bt_types.h\"\n#include \"stack/include/btm_client_interface.h\"\n#include \"stack/include/l2cdefs.h\"\n#include \"types/bluetooth/uuid.h\"\n\n#define GATT_MTU_REQ_MIN_LEN 2\n#define L2CAP_PKT_OVERHEAD 4\n\nusing bluetooth::Uuid;\nusing bluetooth::eatt::EattChannel;\nusing bluetooth::eatt::EattExtension;\nusing namespace bluetooth;\n\n/*******************************************************************************\n *\n * Function         gatt_sr_enqueue_cmd\n *\n * Description      This function enqueue the request from client which needs a\n *                  application response, and update the transaction ID.\n *\n * Returns          void\n *\n ******************************************************************************/\nuint32_t gatt_sr_enqueue_cmd(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code, uint16_t handle) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel = EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n    if (channel == nullptr) {\n      log::warn(\"{}, cid 0x{:02x} already disconnected\", tcb.peer_bda, cid);\n      return 0;\n    }\n\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  uint32_t trans_id = 0;\n\n  p_cmd->cid = cid;\n\n  if ((p_cmd->op_code == 0) || (op_code == GATT_HANDLE_VALUE_CONF)) /* no pending request */\n  {\n    if (op_code == GATT_CMD_WRITE || op_code == GATT_SIGN_CMD_WRITE || op_code == GATT_REQ_MTU ||\n        op_code == GATT_HANDLE_VALUE_CONF) {\n      trans_id = ++tcb.trans_id;\n    } else {\n      p_cmd->trans_id = ++tcb.trans_id;\n      p_cmd->op_code = op_code;\n      p_cmd->handle = handle;\n      p_cmd->status = GATT_NOT_FOUND;\n      tcb.trans_id %= GATT_TRANS_ID_MAX;\n      trans_id = p_cmd->trans_id;\n    }\n  }\n\n  return trans_id;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_cmd_empty\n *\n * Description      This function checks if the server command queue is empty.\n *\n * Returns          true if empty, false if there is pending command.\n *\n ******************************************************************************/\nbool gatt_sr_cmd_empty(tGATT_TCB& tcb, uint16_t cid) {\n  if (cid == tcb.att_lcid) {\n    return tcb.sr_cmd.op_code == 0;\n  }\n\n  EattChannel* channel = EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n  if (channel == nullptr) {\n    log::warn(\"{}, cid 0x{:02x} already disconnected\", tcb.peer_bda, cid);\n    return false;\n  }\n\n  return channel->server_outstanding_cmd_.op_code == 0;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_dequeue_sr_cmd\n *\n * Description      This function dequeue the request from command queue.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_dequeue_sr_cmd(tGATT_TCB& tcb, uint16_t cid) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel = EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n    if (channel == nullptr) {\n      log::warn(\"{}, cid 0x{:02x} already disconnected\", tcb.peer_bda, cid);\n      return;\n    }\n\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  /* Double check in case any buffers are queued */\n  log::verbose(\"gatt_dequeue_sr_cmd cid: 0x{:x}\", cid);\n  if (p_cmd->p_rsp_msg) {\n    log::error(\"free tcb.sr_cmd.p_rsp_msg = {}\", fmt::ptr(p_cmd->p_rsp_msg));\n  }\n  osi_free_and_reset((void**)&p_cmd->p_rsp_msg);\n\n  while (!fixed_queue_is_empty(p_cmd->multi_rsp_q)) {\n    osi_free(fixed_queue_try_dequeue(p_cmd->multi_rsp_q));\n  }\n  fixed_queue_free(p_cmd->multi_rsp_q, NULL);\n  memset(p_cmd, 0, sizeof(tGATT_SR_CMD));\n}\n\nstatic void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) {\n  uint16_t ii;\n  size_t total_len, len;\n  uint8_t* p;\n  bool is_overflow = false;\n\n  // We need at least one extra byte for the opcode\n  if (mtu == 0) {\n    log::error(\"Invalid MTU\");\n    p_cmd->status = GATT_ILLEGAL_PARAMETER;\n    return;\n  }\n\n  len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu;\n  BT_HDR* p_buf = (BT_HDR*)osi_calloc(len);\n  p_buf->offset = L2CAP_MIN_OFFSET;\n  p = (uint8_t*)(p_buf + 1) + p_buf->offset;\n\n  /* First byte in the response is the opcode */\n  if (p_cmd->multi_req.variable_len) {\n    *p++ = GATT_RSP_READ_MULTI_VAR;\n  } else {\n    *p++ = GATT_RSP_READ_MULTI;\n  }\n\n  p_buf->len = 1;\n\n  // Now walk through the buffers putting the data into the response in order\n  list_t* list = NULL;\n  const list_node_t* node = NULL;\n  if (!fixed_queue_is_empty(p_cmd->multi_rsp_q)) {\n    list = fixed_queue_get_list(p_cmd->multi_rsp_q);\n  }\n  for (ii = 0; ii < p_cmd->multi_req.num_handles; ii++) {\n    tGATTS_RSP* p_rsp = NULL;\n\n    if (list != NULL) {\n      if (ii == 0) {\n        node = list_begin(list);\n      } else {\n        node = list_next(node);\n      }\n      if (node != list_end(list)) {\n        p_rsp = (tGATTS_RSP*)list_node(node);\n      }\n    }\n\n    if (p_rsp != NULL) {\n      total_len = p_buf->len;\n      if (p_cmd->multi_req.variable_len) {\n        total_len += 2;\n      }\n\n      if (total_len > mtu) {\n        log::verbose(\"Buffer space not enough for this data item, skipping\");\n        break;\n      }\n\n      len = std::min((size_t)p_rsp->attr_value.len, mtu - total_len);\n\n      if (total_len == mtu && p_rsp->attr_value.len > 0) {\n        log::verbose(\"Buffer space not enough for this data item, skipping\");\n        break;\n      }\n\n      if (len < p_rsp->attr_value.len) {\n        is_overflow = true;\n        log::verbose(\"multi read overflow available len={} val_len={}\", len, p_rsp->attr_value.len);\n      }\n\n      if (p_cmd->multi_req.variable_len) {\n        UINT16_TO_STREAM(p, (uint16_t)len);\n        p_buf->len += 2;\n      }\n\n      if (p_rsp->attr_value.handle == p_cmd->multi_req.handles[ii]) {\n        ARRAY_TO_STREAM(p, p_rsp->attr_value.value, (uint16_t)len);\n        p_buf->len += (uint16_t)len;\n      } else {\n        p_cmd->status = GATT_NOT_FOUND;\n        break;\n      }\n\n      if (is_overflow) {\n        break;\n      }\n\n    } else {\n      p_cmd->status = GATT_NOT_FOUND;\n      break;\n    }\n\n  } /* loop through all handles*/\n\n  /* Sanity check on the buffer length */\n  if (p_buf->len == 0) {\n    log::error(\"nothing found!!\");\n    p_cmd->status = GATT_NOT_FOUND;\n    osi_free(p_buf);\n    log::verbose(\"osi_free(p_buf)\");\n  } else if (p_cmd->p_rsp_msg != NULL) {\n    osi_free(p_buf);\n  } else {\n    p_cmd->p_rsp_msg = p_buf;\n  }\n}\n\n/*******************************************************************************\n *\n * Function         process_read_multi_rsp\n *\n * Description      This function check the read multiple response.\n *\n * Returns          bool    if all replies have been received\n *\n ******************************************************************************/\nstatic bool process_read_multi_rsp(tGATT_SR_CMD* p_cmd, tGATT_STATUS status, tGATTS_RSP* p_msg,\n                                   uint16_t mtu) {\n  log::verbose(\"status={} mtu={}\", status, mtu);\n\n  if (p_cmd->multi_rsp_q == NULL) {\n    p_cmd->multi_rsp_q = fixed_queue_new(SIZE_MAX);\n  }\n\n  /* Enqueue the response */\n  BT_HDR* p_buf = (BT_HDR*)osi_malloc(sizeof(tGATTS_RSP));\n  memcpy((void*)p_buf, (const void*)p_msg, sizeof(tGATTS_RSP));\n  fixed_queue_enqueue(p_cmd->multi_rsp_q, p_buf);\n\n  p_cmd->status = status;\n  if (status == GATT_SUCCESS) {\n    log::verbose(\"Multi read count={} num_hdls={} variable={}\",\n                 fixed_queue_length(p_cmd->multi_rsp_q), p_cmd->multi_req.num_handles,\n                 p_cmd->multi_req.variable_len);\n    /* Wait till we get all the responses */\n    if (fixed_queue_length(p_cmd->multi_rsp_q) == p_cmd->multi_req.num_handles) {\n      build_read_multi_rsp(p_cmd, mtu);\n      return true;\n    }\n  } else /* any handle read exception occurs, return error */\n  {\n    return true;\n  }\n\n  /* If here, still waiting */\n  return false;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_process_app_rsp\n *\n * Description      This function checks whether the response message from\n *                  application matches any pending request.\n *\n * Returns          void\n *\n ******************************************************************************/\ntGATT_STATUS gatt_sr_process_app_rsp(tGATT_TCB& tcb, tGATT_IF gatt_if, uint32_t /* trans_id */,\n                                     uint8_t op_code, tGATT_STATUS status, tGATTS_RSP* p_msg,\n                                     tGATT_SR_CMD* sr_res_p) {\n  tGATT_STATUS ret_code = GATT_SUCCESS;\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, sr_res_p->cid);\n\n  log::verbose(\"gatt_if={}\", gatt_if);\n\n  gatt_sr_update_cback_cnt(tcb, sr_res_p->cid, gatt_if, false, false);\n\n  if ((op_code == GATT_REQ_READ_MULTI) || (op_code == GATT_REQ_READ_MULTI_VAR)) {\n    /* If no error and still waiting, just return */\n    if (!process_read_multi_rsp(sr_res_p, status, p_msg, payload_size)) {\n      return GATT_SUCCESS;\n    }\n  } else {\n    if (op_code == GATT_REQ_PREPARE_WRITE && status == GATT_SUCCESS) {\n      gatt_sr_update_prep_cnt(tcb, gatt_if, true, false);\n    }\n\n    if (op_code == GATT_REQ_EXEC_WRITE && status != GATT_SUCCESS) {\n      gatt_sr_reset_cback_cnt(tcb, sr_res_p->cid);\n    }\n\n    sr_res_p->status = status;\n\n    if (gatt_sr_is_cback_cnt_zero(tcb) && status == GATT_SUCCESS) {\n      if (sr_res_p->p_rsp_msg == NULL) {\n        sr_res_p->p_rsp_msg =\n                attp_build_sr_msg(tcb, (uint8_t)(op_code + 1), (tGATT_SR_MSG*)p_msg, payload_size);\n      } else {\n        log::error(\"Exception!!! already has respond message\");\n      }\n    }\n  }\n  if (gatt_sr_is_cback_cnt_zero(tcb)) {\n    if ((sr_res_p->status == GATT_SUCCESS) && (sr_res_p->p_rsp_msg)) {\n      ret_code = attp_send_sr_msg(tcb, sr_res_p->cid, sr_res_p->p_rsp_msg);\n      sr_res_p->p_rsp_msg = NULL;\n    } else {\n      ret_code = gatt_send_error_rsp(tcb, sr_res_p->cid, status, op_code, sr_res_p->handle, false);\n    }\n\n    gatt_dequeue_sr_cmd(tcb, sr_res_p->cid);\n  }\n\n  log::verbose(\"ret_code={}\", ret_code);\n\n  return ret_code;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_exec_write_req\n *\n * Description      This function is called to process the execute write request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_exec_write_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code, uint16_t len,\n                                 uint8_t* p_data) {\n  uint8_t *p = p_data, flag, i = 0;\n  uint32_t trans_id = 0;\n  tGATT_IF gatt_if;\n  uint16_t conn_id;\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    log::verbose(\"Conformance tst: forced err rspv for Execute Write: error status={}\",\n                 gatt_cb.err_status);\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code, gatt_cb.handle, false);\n\n    return;\n  }\n#endif\n\n  if (len < sizeof(flag)) {\n    log::error(\"invalid length\");\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_EXEC_WRITE, 0, false);\n    return;\n  }\n\n  STREAM_TO_UINT8(flag, p);\n\n  /* mask the flag */\n  flag &= GATT_PREP_WRITE_EXEC;\n\n  /* no prep write is queued */\n  if (!gatt_sr_is_prep_cnt_zero(tcb)) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, 0);\n    gatt_sr_copy_prep_cnt_to_cback_cnt(tcb);\n\n    if (com::android::bluetooth::flags::gatt_client_dynamic_allocation()) {\n      auto prep_cnt_it = tcb.prep_cnt_map.begin();\n      while (prep_cnt_it != tcb.prep_cnt_map.end()) {\n        gatt_if = i;\n        conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_if);\n        tGATTS_DATA gatts_data;\n        gatts_data.exec_write = flag;\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_WRITE_EXEC, &gatts_data);\n        prep_cnt_it = tcb.prep_cnt_map.erase(prep_cnt_it);\n      }\n    } else {\n      for (i = 0; i < GATT_MAX_APPS; i++) {\n        if (tcb.prep_cnt[i]) {\n          gatt_if = (tGATT_IF)(i + 1);\n          conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_if);\n          tGATTS_DATA gatts_data;\n          gatts_data.exec_write = flag;\n          gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_WRITE_EXEC, &gatts_data);\n          tcb.prep_cnt[i] = 0;\n        }\n      }\n    }\n  } else /* nothing needs to be executed , send response now */\n  {\n    log::error(\"gatt_process_exec_write_req: no prepare write pending\");\n    gatt_send_error_rsp(tcb, cid, GATT_ERROR, GATT_REQ_EXEC_WRITE, 0, false);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_read_multi_req\n *\n * Description      This function is called to process the read multiple request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_read_multi_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code, uint16_t len,\n                                 uint8_t* p_data) {\n  uint32_t trans_id;\n  uint16_t handle = 0, ll = len;\n  uint8_t* p = p_data;\n  tGATT_STATUS err = GATT_SUCCESS;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n\n  log::verbose(\"\");\n\n  tGATT_READ_MULTI* multi_req = gatt_sr_get_read_multi(tcb, cid);\n  if (multi_req == nullptr) {\n    log::error(\"Could not proceed request. {}, 0x{:02x}\", tcb.peer_bda, cid);\n    return;\n  }\n  multi_req->num_handles = 0;\n  multi_req->variable_len = (op_code == GATT_REQ_READ_MULTI_VAR);\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    log::verbose(\"Conformance tst: forced err rspvofr ReadMultiple: error status={}\",\n                 gatt_cb.err_status);\n\n    STREAM_TO_UINT16(handle, p);\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code, handle, false);\n\n    return;\n  }\n#endif\n\n  while (ll >= 2 && multi_req->num_handles < GATT_MAX_READ_MULTI_HANDLES) {\n    STREAM_TO_UINT16(handle, p);\n\n    auto it = gatt_sr_find_i_rcb_by_handle(handle);\n    if (it != gatt_cb.srv_list_info->end()) {\n      multi_req->handles[multi_req->num_handles++] = handle;\n\n      /* check read permission */\n      err = gatts_read_attr_perm_check(it->p_db, false, handle, sec_flag, key_size);\n      if (err != GATT_SUCCESS) {\n        log::verbose(\"read permission denied : 0x{:02x}\", err);\n        break;\n      }\n    } else {\n      /* invalid handle */\n      err = GATT_INVALID_HANDLE;\n      break;\n    }\n    ll -= 2;\n  }\n\n  if (ll != 0) {\n    log::error(\"max attribute handle reached in ReadMultiple Request.\");\n  }\n\n  if (multi_req->num_handles == 0) {\n    err = GATT_INVALID_HANDLE;\n  }\n\n  if (err == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, multi_req->handles[0]);\n    if (trans_id != 0) {\n      tGATT_SR_CMD* sr_cmd_p = gatt_sr_get_cmd_by_cid(tcb, cid);\n      if (sr_cmd_p == nullptr) {\n        log::error(\"Could not send response on CID were request arrived. {}, 0x{:02x}\",\n                   tcb.peer_bda, cid);\n        return;\n      }\n      gatt_sr_reset_cback_cnt(tcb, cid); /* read multiple use multi_rsp_q's count*/\n\n      for (ll = 0; ll < multi_req->num_handles; ll++) {\n        tGATTS_RSP* p_msg = (tGATTS_RSP*)osi_calloc(sizeof(tGATTS_RSP));\n        handle = multi_req->handles[ll];\n        auto it = gatt_sr_find_i_rcb_by_handle(handle);\n\n        p_msg->attr_value.handle = handle;\n        err = gatts_read_attr_value_by_handle(tcb, cid, it->p_db, op_code, handle, 0,\n                                              p_msg->attr_value.value, &p_msg->attr_value.len,\n                                              GATT_MAX_ATTR_LEN, sec_flag, key_size, trans_id);\n\n        if (err == GATT_SUCCESS) {\n          gatt_sr_process_app_rsp(tcb, it->gatt_if, trans_id, op_code, GATT_SUCCESS, p_msg,\n                                  sr_cmd_p);\n        }\n        /* either not using or done using the buffer, release it now */\n        osi_free(p_msg);\n      }\n    } else {\n      err = GATT_NO_RESOURCES;\n    }\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (err != GATT_SUCCESS && err != GATT_PENDING && err != GATT_BUSY) {\n    gatt_send_error_rsp(tcb, cid, err, op_code, handle, false);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatt_build_primary_service_rsp\n *\n * Description      Primamry service request processed internally. Theretically\n *                  only deal with ReadByTypeValue and ReadByGroupType.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic tGATT_STATUS gatt_build_primary_service_rsp(BT_HDR* p_msg, tGATT_TCB& tcb, uint16_t cid,\n                                                   uint8_t op_code, uint16_t s_hdl, uint16_t e_hdl,\n                                                   uint8_t* /* p_data */, const Uuid& value) {\n  tGATT_STATUS status = GATT_NOT_FOUND;\n  uint8_t handle_len = 4;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl < s_hdl || el.s_hdl > e_hdl || el.type != GATT_UUID_PRI_SERVICE) {\n      continue;\n    }\n\n    Uuid* p_uuid = gatts_get_service_uuid(el.p_db);\n    if (!p_uuid) {\n      continue;\n    }\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n      handle_len = 4 + gatt_build_uuid_to_stream_len(*p_uuid);\n    }\n\n    /* get the length byte in the repsonse */\n    if (p_msg->offset == 0) {\n      *p++ = op_code + 1;\n      p_msg->len++;\n      p_msg->offset = handle_len;\n\n      if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n        *p++ = (uint8_t)p_msg->offset; /* length byte */\n        p_msg->len++;\n      }\n    }\n\n    if (p_msg->len + p_msg->offset > payload_size || handle_len != p_msg->offset) {\n      break;\n    }\n\n    if (op_code == GATT_REQ_FIND_TYPE_VALUE && value != *p_uuid) {\n      continue;\n    }\n\n    UINT16_TO_STREAM(p, el.s_hdl);\n\n    if (gatt_cb.last_service_handle && gatt_cb.last_service_handle == el.s_hdl) {\n      log::verbose(\"Use 0xFFFF for the last primary attribute\");\n      /* see GATT ERRATA 4065, 4063, ATT ERRATA 4062 */\n      UINT16_TO_STREAM(p, 0xFFFF);\n    } else {\n      UINT16_TO_STREAM(p, el.e_hdl);\n    }\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n      gatt_build_uuid_to_stream(&p, *p_uuid);\n    }\n\n    status = GATT_SUCCESS;\n    p_msg->len += p_msg->offset;\n  }\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  return status;\n}\n\n/**\n * fill the find information response information in the given buffer.\n *\n * Returns          true: if data filled sucessfully.\n *                  false: packet full, or format mismatch.\n */\nstatic tGATT_STATUS gatt_build_find_info_rsp(tGATT_SRV_LIST_ELEM& el, BT_HDR* p_msg, uint16_t& len,\n                                             uint16_t s_hdl, uint16_t e_hdl) {\n  uint8_t info_pair_len[2] = {4, 18};\n\n  if (!el.p_db) {\n    return GATT_NOT_FOUND;\n  }\n\n  /* check the attribute database */\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET + p_msg->len;\n\n  tGATT_STATUS status = GATT_NOT_FOUND;\n  for (auto& attr : el.p_db->attr_list) {\n    if (attr.handle > e_hdl) {\n      break;\n    }\n\n    if (attr.handle < s_hdl) {\n      continue;\n    }\n\n    uint8_t uuid_len = attr.uuid.GetShortestRepresentationSize();\n    if (p_msg->offset == 0) {\n      p_msg->offset =\n              (uuid_len == Uuid::kNumBytes16) ? GATT_INFO_TYPE_PAIR_16 : GATT_INFO_TYPE_PAIR_128;\n    }\n\n    if (len < info_pair_len[p_msg->offset - 1]) {\n      return GATT_NO_RESOURCES;\n    }\n\n    if (p_msg->offset == GATT_INFO_TYPE_PAIR_16 && uuid_len == Uuid::kNumBytes16) {\n      UINT16_TO_STREAM(p, attr.handle);\n      UINT16_TO_STREAM(p, attr.uuid.As16Bit());\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 && uuid_len == Uuid::kNumBytes128) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 && uuid_len == Uuid::kNumBytes32) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else {\n      log::error(\"format mismatch\");\n      return GATT_NO_RESOURCES;\n      /* format mismatch */\n    }\n    p_msg->len += info_pair_len[p_msg->offset - 1];\n    len -= info_pair_len[p_msg->offset - 1];\n    status = GATT_SUCCESS;\n  }\n\n  return status;\n}\n\nstatic tGATT_STATUS read_handles(uint16_t& len, uint8_t*& p, uint16_t& s_hdl, uint16_t& e_hdl) {\n  if (len < 4) {\n    return GATT_INVALID_PDU;\n  }\n\n  /* obtain starting handle, and ending handle */\n  STREAM_TO_UINT16(s_hdl, p);\n  STREAM_TO_UINT16(e_hdl, p);\n  len -= 4;\n\n  if (s_hdl > e_hdl || !GATT_HANDLE_IS_VALID(s_hdl) || !GATT_HANDLE_IS_VALID(e_hdl)) {\n    return GATT_INVALID_HANDLE;\n  }\n\n  return GATT_SUCCESS;\n}\n\nstatic tGATT_STATUS gatts_validate_packet_format(uint8_t op_code, uint16_t& len, uint8_t*& p,\n                                                 Uuid* p_uuid, uint16_t& s_hdl, uint16_t& e_hdl) {\n  tGATT_STATUS ret = read_handles(len, p, s_hdl, e_hdl);\n  if (ret != GATT_SUCCESS) {\n    return ret;\n  }\n\n  if (len < 2) {\n    return GATT_INVALID_PDU;\n  }\n\n  /* parse uuid now */\n  log::assert_that(p_uuid != nullptr, \"assert failed: p_uuid != nullptr\");\n  uint16_t uuid_len = (op_code == GATT_REQ_FIND_TYPE_VALUE) ? 2 : len;\n  if (!gatt_parse_uuid_from_cmd(p_uuid, uuid_len, &p)) {\n    log::verbose(\"Bad UUID\");\n    return GATT_INVALID_PDU;\n  }\n\n  len -= uuid_len;\n  return GATT_SUCCESS;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_primary_service_req\n *\n * Description      Process ReadByGroupType/ReadByTypeValue request, for\n *                  discovering all primary services or discover primary service\n *                  by UUID request.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code, uint16_t len,\n                                       uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  Uuid uuid = Uuid::kEmpty;\n\n  uint8_t reason = gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  if (uuid != Uuid::From16Bit(GATT_UUID_PRI_SERVICE)) {\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n      gatt_send_error_rsp(tcb, cid, GATT_UNSUPPORT_GRP_TYPE, op_code, s_hdl, false);\n      log::verbose(\"unexpected ReadByGrpType Group: {}\", uuid.ToString());\n      return;\n    }\n\n    // we do not support ReadByTypeValue with any non-primamry_service type\n    gatt_send_error_rsp(tcb, cid, GATT_NOT_FOUND, op_code, s_hdl, false);\n    log::verbose(\"unexpected ReadByTypeValue type: {}\", uuid.ToString());\n    return;\n  }\n\n  // TODO: we assume theh value is UUID, there is no such requirement in spec\n  Uuid value = Uuid::kEmpty;\n  if (op_code == GATT_REQ_FIND_TYPE_VALUE) {\n    if (!gatt_parse_uuid_from_cmd(&value, len, &p_data)) {\n      gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, s_hdl, false);\n    }\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  uint16_t msg_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n  reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl, e_hdl, p_data, value);\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_find_info\n *\n * Description      process find information request, for discover character\n *                  descriptors.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code, uint16_t len,\n                                    uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  uint8_t reason = read_handles(len, p_data, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  uint16_t buf_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n  reason = GATT_NOT_FOUND;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n  *p++ = op_code + 1;\n  p_msg->len = 2;\n\n  buf_len = payload_size - 2;\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl <= e_hdl && el.e_hdl >= s_hdl) {\n      reason = gatt_build_find_info_rsp(el, p_msg, buf_len, s_hdl, e_hdl);\n      if (reason == GATT_NO_RESOURCES) {\n        reason = GATT_SUCCESS;\n        break;\n      }\n    }\n  }\n\n  *p = (uint8_t)p_msg->offset;\n\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n  } else {\n    attp_send_sr_msg(tcb, cid, p_msg);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_mtu_req\n *\n * Description      This function is called to process excahnge MTU request.\n *                  Only used on LE.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_mtu_req(tGATT_TCB& tcb, uint16_t cid, uint16_t len, uint8_t* p_data) {\n  /* BR/EDR conenction, send error response */\n  if (cid != L2CAP_ATT_CID) {\n    gatt_send_error_rsp(tcb, cid, GATT_REQ_NOT_SUPPORTED, GATT_REQ_MTU, 0, false);\n    return;\n  }\n\n  if (len < GATT_MTU_REQ_MIN_LEN) {\n    log::error(\"invalid MTU request PDU received.\");\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_MTU, 0, false);\n    return;\n  }\n\n  tGATT_SR_MSG gatt_sr_msg;\n\n  uint16_t mtu = 0;\n  uint8_t* p = p_data;\n  STREAM_TO_UINT16(mtu, p);\n  /* mtu must be greater than default MTU which is 23/48 */\n  if (mtu < GATT_DEF_BLE_MTU_SIZE) {\n    tcb.payload_size = GATT_DEF_BLE_MTU_SIZE;\n  } else {\n    tcb.payload_size = std::min(mtu, (uint16_t)(gatt_get_local_mtu()));\n  }\n\n  /* Always say to remote our default MTU. */\n  gatt_sr_msg.mtu = gatt_get_local_mtu();\n\n  log::info(\"MTU {} request from remote ({}), resulted MTU {}\", mtu, tcb.peer_bda,\n            tcb.payload_size);\n\n  if (get_btm_client_interface().ble.BTM_SetBleDataLength(\n              tcb.peer_bda, tcb.payload_size + L2CAP_PKT_OVERHEAD) != tBTM_STATUS::BTM_SUCCESS) {\n    log::warn(\"Unable to set BLE data length peer:{} mtu:{}\", tcb.peer_bda,\n              tcb.payload_size + L2CAP_PKT_OVERHEAD);\n  }\n\n  BT_HDR* p_buf = attp_build_sr_msg(tcb, GATT_RSP_MTU, &gatt_sr_msg, GATT_DEF_BLE_MTU_SIZE);\n  attp_send_sr_msg(tcb, cid, p_buf);\n\n  bluetooth::shim::arbiter::GetArbiter().OnIncomingMtuReq(tcb.tcb_idx, tcb.payload_size);\n\n  tGATTS_DATA gatts_data;\n  gatts_data.mtu = tcb.payload_size;\n  /* Notify all registered application with new MTU size. Use a transaction ID */\n  /* of 0, as no response is allowed from applications */\n  if (com::android::bluetooth::flags::gatt_client_dynamic_allocation()) {\n    for (auto& [i, p_reg] : gatt_cb.cl_rcb_map) {\n      if (p_reg->in_use) {\n        uint16_t conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, p_reg->gatt_if);\n        gatt_sr_send_req_callback(conn_id, 0, GATTS_REQ_TYPE_MTU, &gatts_data);\n      }\n    }\n  } else {\n    for (int i = 0; i < GATT_MAX_APPS; i++) {\n      if (gatt_cb.cl_rcb[i].in_use) {\n        uint16_t conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_cb.cl_rcb[i].gatt_if);\n        gatt_sr_send_req_callback(conn_id, 0, GATTS_REQ_TYPE_MTU, &gatts_data);\n      }\n    }\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_read_by_type_req\n *\n * Description      process Read By type request.\n *                  This PDU can be used to perform:\n *                  - read characteristic value\n *                  - read characteristic descriptor value\n *                  - discover characteristic\n *                  - discover characteristic by UUID\n *                  - relationship discovery\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                           uint16_t len, uint8_t* p_data) {\n  Uuid uuid = Uuid::kEmpty;\n  uint16_t s_hdl = 0, e_hdl = 0, err_hdl = 0;\n  tGATT_STATUS reason = gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    log::verbose(\"Conformance tst: forced err rsp for ReadByType: error status={}\",\n                 gatt_cb.err_status);\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code, s_hdl, false);\n\n    return;\n  }\n#endif\n\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  *p++ = op_code + 1;\n  /* reserve length byte */\n  p_msg->len = 2;\n  uint16_t buf_len = payload_size - 2;\n\n  reason = GATT_NOT_FOUND;\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl <= e_hdl && el.e_hdl >= s_hdl) {\n      tGATT_SEC_FLAG sec_flag;\n      uint8_t key_size;\n      gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n      tGATT_STATUS ret =\n              gatts_db_read_attr_value_by_type(tcb, cid, el.p_db, op_code, p_msg, s_hdl, e_hdl,\n                                               uuid, &buf_len, sec_flag, key_size, 0, &err_hdl);\n      if (ret != GATT_NOT_FOUND) {\n        reason = ret;\n        if (ret == GATT_NO_RESOURCES) {\n          reason = GATT_SUCCESS;\n        }\n      }\n\n      if (ret != GATT_SUCCESS && ret != GATT_NOT_FOUND) {\n        s_hdl = err_hdl;\n        break;\n      }\n    }\n  }\n  *p = (uint8_t)p_msg->offset;\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n\n    /* in theroy BUSY is not possible(should already been checked), protected\n     * check */\n    if (reason != GATT_PENDING && reason != GATT_BUSY) {\n      gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    }\n\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/**\n * This function is called to process the write request from client.\n */\nstatic void gatts_process_write_req(tGATT_TCB& tcb, uint16_t cid, tGATT_SRV_LIST_ELEM& el,\n                                    uint16_t handle, uint8_t op_code, uint16_t len, uint8_t* p_data,\n                                    bt_gatt_db_attribute_type_t gatt_type) {\n  tGATTS_DATA sr_data;\n  uint32_t trans_id;\n  tGATT_STATUS status;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size, *p = p_data;\n  uint16_t conn_id;\n\n  memset(&sr_data, 0, sizeof(tGATTS_DATA));\n\n  switch (op_code) {\n    case GATT_REQ_PREPARE_WRITE:\n      if (len < 2 || p == nullptr) {\n        log::error(\"Prepare write request was invalid - missing offset, sending error response\");\n        gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, handle, false);\n        return;\n      }\n      sr_data.write_req.is_prep = true;\n      STREAM_TO_UINT16(sr_data.write_req.offset, p);\n      len -= 2;\n      FALLTHROUGH_INTENDED; /* FALLTHROUGH */\n    case GATT_SIGN_CMD_WRITE:\n      if (op_code == GATT_SIGN_CMD_WRITE) {\n        log::verbose(\"Write CMD with data sigining\");\n        len -= GATT_AUTH_SIGN_LEN;\n      }\n      FALLTHROUGH_INTENDED; /* FALLTHROUGH */\n    case GATT_CMD_WRITE:\n    case GATT_REQ_WRITE:\n      if (op_code == GATT_REQ_WRITE || op_code == GATT_REQ_PREPARE_WRITE) {\n        sr_data.write_req.need_rsp = true;\n      }\n      sr_data.write_req.handle = handle;\n      if (len > GATT_MAX_ATTR_LEN) {\n        len = GATT_MAX_ATTR_LEN;\n      }\n      sr_data.write_req.len = len;\n      if (len != 0 && p != nullptr) {\n        memcpy(sr_data.write_req.value, p, len);\n      }\n      break;\n  }\n\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n  status = gatts_write_attr_perm_check(el.p_db, op_code, handle, sr_data.write_req.offset, p, len,\n                                       sec_flag, key_size);\n\n  if (status == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, handle);\n    if (trans_id != 0) {\n      conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, el.gatt_if);\n\n      uint8_t opcode = 0;\n      if (gatt_type == BTGATT_DB_DESCRIPTOR) {\n        opcode = GATTS_REQ_TYPE_WRITE_DESCRIPTOR;\n      } else if (gatt_type == BTGATT_DB_CHARACTERISTIC) {\n        opcode = GATTS_REQ_TYPE_WRITE_CHARACTERISTIC;\n      } else {\n        log::error(\n                \"Attempt to write attribute that's not tied with \"\n                \"characteristic or descriptor value.\");\n        status = GATT_ERROR;\n      }\n\n      if (opcode) {\n        gatt_sr_send_req_callback(conn_id, trans_id, opcode, &sr_data);\n        status = GATT_PENDING;\n      }\n    } else {\n      log::error(\"max pending command, send error\");\n      status = GATT_BUSY; /* max pending command, application error */\n    }\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (status != GATT_PENDING && status != GATT_BUSY &&\n      (op_code == GATT_REQ_PREPARE_WRITE || op_code == GATT_REQ_WRITE)) {\n    gatt_send_error_rsp(tcb, cid, status, op_code, handle, false);\n  }\n  return;\n}\n\n/**\n * This function is called to process the read request from client.\n */\nstatic void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid, tGATT_SRV_LIST_ELEM& el,\n                                   uint8_t op_code, uint16_t handle, uint16_t len,\n                                   uint8_t* p_data) {\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  uint16_t offset = 0;\n\n  if (op_code == GATT_REQ_READ_BLOB && len < sizeof(uint16_t)) {\n    /* Error: packet length is too short */\n    log::error(\"packet length={} too short. min={}\", len, sizeof(uint16_t));\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, 0, false);\n    return;\n  }\n\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n\n  if (op_code == GATT_REQ_READ_BLOB) {\n    STREAM_TO_UINT16(offset, p_data);\n  }\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n  *p++ = op_code + 1;\n  p_msg->len = 1;\n  buf_len = payload_size - 1;\n\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n  uint16_t value_len = 0;\n  tGATT_STATUS reason =\n          gatts_read_attr_value_by_handle(tcb, cid, el.p_db, op_code, handle, offset, p, &value_len,\n                                          (uint16_t)buf_len, sec_flag, key_size, 0);\n  p_msg->len += value_len;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n\n    /* in theory BUSY is not possible(should already been checked), protected\n     * check */\n    if (reason != GATT_PENDING && reason != GATT_BUSY) {\n      gatt_send_error_rsp(tcb, cid, reason, op_code, handle, false);\n    }\n\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_attribute_req\n *\n * Description      This function is called to process the per attribute handle\n *                  request from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_attribute_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code, uint16_t len,\n                                 uint8_t* p_data) {\n  uint16_t handle = 0;\n  uint8_t* p = p_data;\n  tGATT_STATUS status = GATT_INVALID_HANDLE;\n\n  if (len < 2) {\n    log::error(\"Illegal PDU length, discard request\");\n    status = GATT_INVALID_PDU;\n  } else {\n    STREAM_TO_UINT16(handle, p);\n    len -= 2;\n  }\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  gatt_cb.handle = handle;\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    log::verbose(\"Conformance tst: forced err rsp: error status={}\", gatt_cb.err_status);\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, cid, gatt_cb.req_op_code, handle, false);\n\n    return;\n  }\n#endif\n\n  if (GATT_HANDLE_IS_VALID(handle)) {\n    for (auto& el : *gatt_cb.srv_list_info) {\n      if (el.s_hdl <= handle && el.e_hdl >= handle) {\n        for (const auto& attr : el.p_db->attr_list) {\n          if (attr.handle == handle) {\n            switch (op_code) {\n              case GATT_REQ_READ: /* read char/char descriptor value */\n              case GATT_REQ_READ_BLOB:\n                gatts_process_read_req(tcb, cid, el, op_code, handle, len, p);\n                break;\n\n              case GATT_REQ_WRITE: /* write char/char descriptor value */\n              case GATT_CMD_WRITE:\n              case GATT_SIGN_CMD_WRITE:\n              case GATT_REQ_PREPARE_WRITE:\n                gatts_process_write_req(tcb, cid, el, handle, op_code, len, p, attr.gatt_type);\n                break;\n              default:\n                break;\n            }\n            status = GATT_SUCCESS;\n            break;\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  if (status != GATT_SUCCESS && op_code != GATT_CMD_WRITE && op_code != GATT_SIGN_CMD_WRITE) {\n    gatt_send_error_rsp(tcb, cid, status, op_code, handle, false);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_proc_srv_chg_ind_ack\n *\n * Description      This function process the service changed indicaiton ACK\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_proc_srv_chg_ind_ack(tGATT_TCB tcb) {\n  tGATTS_SRV_CHG_REQ req;\n  tGATTS_SRV_CHG* p_buf = NULL;\n\n  log::verbose(\"\");\n\n  p_buf = gatt_is_bda_in_the_srv_chg_clt_list(tcb.peer_bda);\n  if (p_buf != NULL) {\n    log::verbose(\"NV update set srv chg = false\");\n    p_buf->srv_changed = false;\n    memcpy(&req.srv_chg, p_buf, sizeof(tGATTS_SRV_CHG));\n    if (gatt_cb.cb_info.p_srv_chg_callback) {\n      (*gatt_cb.cb_info.p_srv_chg_callback)(GATTS_SRV_CHG_CMD_UPDATE_CLIENT, &req, NULL);\n    }\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_chk_pending_ind\n *\n * Description      This function check any pending indication needs to be sent\n *                  if there is a pending indication then sent the indication\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_chk_pending_ind(tGATT_TCB& tcb) {\n  log::verbose(\"\");\n\n  tGATT_VALUE* p_buf = (tGATT_VALUE*)fixed_queue_try_peek_first(tcb.pending_ind_q);\n  if (p_buf != NULL) {\n    if (GATTS_HandleValueIndication(p_buf->conn_id, p_buf->handle, p_buf->len, p_buf->value) !=\n        GATT_SUCCESS) {\n      log::warn(\"Unable to send GATT server handle value conn_id:{}\", p_buf->conn_id);\n    }\n    osi_free(fixed_queue_try_remove_from_queue(tcb.pending_ind_q, p_buf));\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_proc_ind_ack\n *\n * Description      This function processes the Indication ack\n *\n * Returns          true continue to process the indication ack by the\n *                  application if the ACK is not a Service Changed Indication\n *\n ******************************************************************************/\nstatic bool gatts_proc_ind_ack(tGATT_TCB& tcb, uint16_t ack_handle) {\n  bool continue_processing = true;\n\n  log::verbose(\"ack handle={}\", ack_handle);\n\n  if (ack_handle == gatt_cb.handle_of_h_r) {\n    gatts_proc_srv_chg_ind_ack(tcb);\n    /* there is no need to inform the application since srv chg is handled\n     * internally by GATT */\n    continue_processing = false;\n\n    // After receiving ack of svc_chg_ind, reset client status\n    gatt_sr_update_cl_status(tcb, /* chg_aware= */ true);\n  }\n\n  gatts_chk_pending_ind(tcb);\n  return continue_processing;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_value_conf\n *\n * Description      This function is called to process the handle value\n *                  confirmation.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_value_conf(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code) {\n  uint16_t handle;\n\n  if (!gatt_tcb_find_indicate_handle(tcb, cid, &handle)) {\n    log::error(\"unexpected handle value confirmation\");\n    return;\n  }\n\n  gatt_stop_conf_timer(tcb, cid);\n\n  bool continue_processing = gatts_proc_ind_ack(tcb, handle);\n\n  if (continue_processing) {\n    tGATTS_DATA gatts_data;\n    gatts_data.handle = handle;\n    for (auto& el : *gatt_cb.srv_list_info) {\n      if (el.s_hdl <= handle && el.e_hdl >= handle) {\n        uint32_t trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, handle);\n        uint16_t conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, el.gatt_if);\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_CONF, &gatts_data);\n      }\n    }\n  }\n}\n\nstatic bool gatts_process_db_out_of_sync(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                         uint16_t len, uint8_t* p_data) {\n  if (gatt_sr_is_cl_change_aware(tcb)) {\n    return false;\n  }\n\n  // default value\n  bool should_ignore = true;\n  bool should_rsp = true;\n\n  switch (op_code) {\n    case GATT_REQ_READ_BY_TYPE: {\n      // Check if read database hash by UUID\n      Uuid uuid = Uuid::kEmpty;\n      uint16_t s_hdl = 0, e_hdl = 0;\n      uint16_t db_hash_handle = gatt_cb.handle_of_database_hash;\n      tGATT_STATUS reason = gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n      if (reason == GATT_SUCCESS && (s_hdl <= db_hash_handle && db_hash_handle <= e_hdl) &&\n          (uuid == Uuid::From16Bit(GATT_UUID_DATABASE_HASH))) {\n        should_ignore = false;\n      }\n\n    } break;\n    case GATT_REQ_READ: {\n      // Check if read database hash by handle\n      uint16_t handle = 0;\n      uint8_t* p = p_data;\n      tGATT_STATUS status = GATT_SUCCESS;\n\n      if (len < 2) {\n        status = GATT_INVALID_PDU;\n      } else {\n        STREAM_TO_UINT16(handle, p);\n        len -= 2;\n      }\n\n      if (status == GATT_SUCCESS && handle == gatt_cb.handle_of_database_hash) {\n        should_ignore = false;\n      }\n\n    } break;\n    case GATT_REQ_READ_BY_GRP_TYPE: /* discover primary services */\n    case GATT_REQ_FIND_TYPE_VALUE:  /* discover service by UUID */\n    case GATT_REQ_FIND_INFO:        /* discover char descrptor */\n    case GATT_REQ_READ_BLOB:        /* read long char */\n    case GATT_REQ_READ_MULTI:       /* read multi char*/\n    case GATT_REQ_WRITE:            /* write char/char descriptor value */\n    case GATT_REQ_PREPARE_WRITE:    /* write long char */\n      // Use default value\n      break;\n    case GATT_CMD_WRITE:      /* cmd */\n    case GATT_SIGN_CMD_WRITE: /* sign cmd */\n      should_rsp = false;\n      break;\n    case GATT_REQ_MTU:           /* configure mtu */\n    case GATT_REQ_EXEC_WRITE:    /* execute write */\n    case GATT_HANDLE_VALUE_CONF: /* confirm for indication */\n    default:\n      should_ignore = false;\n  }\n\n  if (should_ignore) {\n    if (should_rsp) {\n      gatt_send_error_rsp(tcb, cid, GATT_DATABASE_OUT_OF_SYNC, op_code, 0x0000, false);\n    }\n    log::info(\"database out of sync, device={}, op_code=0x{:x}, should_rsp={}\", tcb.peer_bda,\n              (uint16_t)op_code, should_rsp);\n    gatt_sr_update_cl_status(tcb, /* chg_aware= */ should_rsp);\n  }\n\n  return should_ignore;\n}\n\n/** This function is called to handle the client requests to server */\nvoid gatt_server_handle_client_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code, uint16_t len,\n                                   uint8_t* p_data) {\n  /* there is pending command, discard this one */\n  if (!gatt_sr_cmd_empty(tcb, cid) && op_code != GATT_HANDLE_VALUE_CONF) {\n    return;\n  }\n\n  /* the size of the message may not be bigger than the local max PDU size*/\n  /* The message has to be smaller than the agreed MTU, len does not include op\n   * code */\n\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n  if (len >= payload_size) {\n    log::error(\"server receive invalid PDU size:{} pdu size:{}\", len + 1, payload_size);\n    /* for invalid request expecting response, send it now */\n    if (op_code != GATT_CMD_WRITE && op_code != GATT_SIGN_CMD_WRITE &&\n        op_code != GATT_HANDLE_VALUE_CONF) {\n      gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, 0, false);\n    }\n    /* otherwise, ignore the pkt */\n  } else {\n    // handle database out of sync\n    if (gatts_process_db_out_of_sync(tcb, cid, op_code, len, p_data)) {\n      return;\n    }\n\n    switch (op_code) {\n      case GATT_REQ_READ_BY_GRP_TYPE: /* discover primary services */\n      case GATT_REQ_FIND_TYPE_VALUE:  /* discover service by UUID */\n        gatts_process_primary_service_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_FIND_INFO: /* discover char descrptor */\n        gatts_process_find_info(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ_BY_TYPE: /* read characteristic value, char descriptor\n                                     value */\n        /* discover characteristic, discover char by UUID */\n        gatts_process_read_by_type_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ: /* read char/char descriptor value */\n      case GATT_REQ_READ_BLOB:\n      case GATT_REQ_WRITE: /* write char/char descriptor value */\n      case GATT_CMD_WRITE:\n      case GATT_SIGN_CMD_WRITE:\n      case GATT_REQ_PREPARE_WRITE:\n        gatts_process_attribute_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_HANDLE_VALUE_CONF:\n        gatts_process_value_conf(tcb, cid, op_code);\n        break;\n\n      case GATT_REQ_MTU:\n        gatts_process_mtu_req(tcb, cid, len, p_data);\n        break;\n\n      case GATT_REQ_EXEC_WRITE:\n        gatt_process_exec_write_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ_MULTI:\n      case GATT_REQ_READ_MULTI_VAR:\n        gatt_process_read_multi_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      default:\n        break;\n    }\n  }\n}\n```",
                        "downstream_file_content": "```cc\n/******************************************************************************\n *\n *  Copyright 2008-2012 Broadcom Corporation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at:\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n ******************************************************************************/\n\n/******************************************************************************\n *\n *  this file contains the GATT server functions\n *\n ******************************************************************************/\n#include <algorithm>\n#include <string.h>\n\n#include \"bt_target.h\"\n#include \"gatt_int.h\"\n#include \"l2c_api.h\"\n#include \"osi/include/allocator.h\"\n#include \"osi/include/log.h\"\n#include \"osi/include/osi.h\"\n#include \"stack/eatt/eatt.h\"\n#include \"stack/include/bt_hdr.h\"\n#include \"stack/include/bt_types.h\"\n#include \"stack/l2cap/l2c_int.h\"\n#include \"types/bluetooth/uuid.h\"\n#include <base/logging.h>\n\n#define GATT_MTU_REQ_MIN_LEN 2\n#define L2CAP_PKT_OVERHEAD 4\n\nusing base::StringPrintf;\nusing bluetooth::Uuid;\nusing bluetooth::eatt::EattExtension;\nusing bluetooth::eatt::EattChannel;\n\n/*******************************************************************************\n *\n * Function         gatt_sr_enqueue_cmd\n *\n * Description      This function enqueue the request from client which needs a\n *                  application response, and update the transaction ID.\n *\n * Returns          void\n *\n ******************************************************************************/\nuint32_t gatt_sr_enqueue_cmd(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                             uint16_t handle) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel =\n        EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  uint32_t trans_id = 0;\n\n  p_cmd->cid = cid;\n\n  if ((p_cmd->op_code == 0) ||\n      (op_code == GATT_HANDLE_VALUE_CONF)) /* no pending request */\n  {\n    if (op_code == GATT_CMD_WRITE || op_code == GATT_SIGN_CMD_WRITE ||\n        op_code == GATT_REQ_MTU || op_code == GATT_HANDLE_VALUE_CONF) {\n      trans_id = ++tcb.trans_id;\n    } else {\n      p_cmd->trans_id = ++tcb.trans_id;\n      p_cmd->op_code = op_code;\n      p_cmd->handle = handle;\n      p_cmd->status = GATT_NOT_FOUND;\n      tcb.trans_id %= GATT_TRANS_ID_MAX;\n      trans_id = p_cmd->trans_id;\n    }\n  }\n\n  return trans_id;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_cmd_empty\n *\n * Description      This function checks if the server command queue is empty.\n *\n * Returns          true if empty, false if there is pending command.\n *\n ******************************************************************************/\nbool gatt_sr_cmd_empty(tGATT_TCB& tcb, uint16_t cid) {\n  if (cid == tcb.att_lcid) return (tcb.sr_cmd.op_code == 0);\n\n  EattChannel* channel =\n      EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n\n  return (channel->server_outstanding_cmd_.op_code == 0);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_dequeue_sr_cmd\n *\n * Description      This function dequeue the request from command queue.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_dequeue_sr_cmd(tGATT_TCB& tcb, uint16_t cid) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel =\n        EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  /* Double check in case any buffers are queued */\n  VLOG(1) << \"gatt_dequeue_sr_cmd cid: \" << loghex(cid);\n  if (p_cmd->p_rsp_msg)\n    LOG(ERROR) << \"free tcb.sr_cmd.p_rsp_msg = \"\n               << p_cmd->p_rsp_msg;\n  osi_free_and_reset((void**)&p_cmd->p_rsp_msg);\n\n  while (!fixed_queue_is_empty(p_cmd->multi_rsp_q))\n    osi_free(fixed_queue_try_dequeue(p_cmd->multi_rsp_q));\n  fixed_queue_free(p_cmd->multi_rsp_q, NULL);\n  memset(p_cmd, 0, sizeof(tGATT_SR_CMD));\n}\n\nstatic void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) {\n  uint16_t ii;\n  size_t total_len, len;\n  uint8_t* p;\n  bool is_overflow = false;\n\n  // We need at least one extra byte for the opcode\n  if (mtu == 0) {\n    LOG(ERROR) << \"Invalid MTU\";\n    p_cmd->status = GATT_ILLEGAL_PARAMETER;\n    return;\n  }\n\n  len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu;\n  BT_HDR* p_buf = (BT_HDR*)osi_calloc(len);\n  p_buf->offset = L2CAP_MIN_OFFSET;\n  p = (uint8_t*)(p_buf + 1) + p_buf->offset;\n\n  /* First byte in the response is the opcode */\n  if (p_cmd->multi_req.variable_len)\n    *p++ = GATT_RSP_READ_MULTI_VAR;\n  else\n    *p++ = GATT_RSP_READ_MULTI;\n\n  p_buf->len = 1;\n\n  /* Now walk through the buffers putting the data into the response in order\n   */\n  list_t* list = NULL;\n  const list_node_t* node = NULL;\n  if (!fixed_queue_is_empty(p_cmd->multi_rsp_q))\n    list = fixed_queue_get_list(p_cmd->multi_rsp_q);\n  for (ii = 0; ii < p_cmd->multi_req.num_handles; ii++) {\n    tGATTS_RSP* p_rsp = NULL;\n\n    if (list != NULL) {\n      if (ii == 0)\n        node = list_begin(list);\n      else\n        node = list_next(node);\n      if (node != list_end(list)) p_rsp = (tGATTS_RSP*)list_node(node);\n    }\n\n    if (p_rsp != NULL) {\n      total_len = p_buf->len;\n      if (p_cmd->multi_req.variable_len) {\n        total_len += 2;\n      }\n\n      if (total_len > mtu) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      len = std::min((size_t) p_rsp->attr_value.len, mtu - total_len);\n\n      if (total_len == mtu && p_rsp->attr_value.len > 0) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      if (len < p_rsp->attr_value.len) {\n        is_overflow = true;\n        VLOG(1) << StringPrintf(\n            \"multi read overflow available len=%zu val_len=%d\", len,\n            p_rsp->attr_value.len);\n      }\n\n      if (p_cmd->multi_req.variable_len) {\n        UINT16_TO_STREAM(p, (uint16_t) len);\n        p_buf->len += 2;\n      }\n\n      if (p_rsp->attr_value.handle == p_cmd->multi_req.handles[ii]) {\n        ARRAY_TO_STREAM(p, p_rsp->attr_value.value, (uint16_t) len);\n        p_buf->len += (uint16_t) len;\n      } else {\n        p_cmd->status = GATT_NOT_FOUND;\n        break;\n      }\n\n      if (is_overflow) break;\n\n    } else {\n      p_cmd->status = GATT_NOT_FOUND;\n      break;\n    }\n\n  } /* loop through all handles*/\n\n  /* Sanity check on the buffer length */\n  if (p_buf->len == 0) {\n    LOG(ERROR) << __func__ << \" nothing found!!\";\n    p_cmd->status = GATT_NOT_FOUND;\n    osi_free(p_buf);\n    VLOG(1) << __func__ << \"osi_free(p_buf)\";\n  } else if (p_cmd->p_rsp_msg != NULL) {\n    osi_free(p_buf);\n  } else {\n    p_cmd->p_rsp_msg = p_buf;\n  }\n}\n\n/*******************************************************************************\n *\n * Function         process_read_multi_rsp\n *\n * Description      This function check the read multiple response.\n *\n * Returns          bool    if all replies have been received\n *\n ******************************************************************************/\nstatic bool process_read_multi_rsp(tGATT_SR_CMD* p_cmd, tGATT_STATUS status,\n                                   tGATTS_RSP* p_msg, uint16_t mtu) {\n  VLOG(1) << StringPrintf(\"%s status=%d mtu=%d\", __func__, status, mtu);\n\n  if (p_cmd->multi_rsp_q == NULL)\n    p_cmd->multi_rsp_q = fixed_queue_new(SIZE_MAX);\n\n  /* Enqueue the response */\n  BT_HDR* p_buf = (BT_HDR*)osi_malloc(sizeof(tGATTS_RSP));\n  memcpy((void*)p_buf, (const void*)p_msg, sizeof(tGATTS_RSP));\n  fixed_queue_enqueue(p_cmd->multi_rsp_q, p_buf);\n\n  p_cmd->status = status;\n  if (status == GATT_SUCCESS) {\n    VLOG(1) << \"Multi read count=\" << fixed_queue_length(p_cmd->multi_rsp_q)\n            << \" num_hdls=\" << p_cmd->multi_req.num_handles\n            << \" variable=\" << p_cmd->multi_req.variable_len;\n    /* Wait till we get all the responses */\n    if (fixed_queue_length(p_cmd->multi_rsp_q) ==\n        p_cmd->multi_req.num_handles) {\n      build_read_multi_rsp(p_cmd, mtu);\n      return (true);\n    }\n  } else /* any handle read exception occurs, return error */\n  {\n    return (true);\n  }\n\n  /* If here, still waiting */\n  return (false);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_process_app_rsp\n *\n * Description      This function checks whether the response message from\n *                  application matches any pending request.\n *\n * Returns          void\n *\n ******************************************************************************/\ntGATT_STATUS gatt_sr_process_app_rsp(tGATT_TCB& tcb, tGATT_IF gatt_if,\n                                     UNUSED_ATTR uint32_t trans_id,\n                                     uint8_t op_code, tGATT_STATUS status,\n                                     tGATTS_RSP* p_msg,\n                                     tGATT_SR_CMD* sr_res_p) {\n  tGATT_STATUS ret_code = GATT_SUCCESS;\n  uint16_t payload_size = gatt_tcb_get_payload_size_rx(tcb, sr_res_p->cid);\n\n  VLOG(1) << __func__ << \" gatt_if=\" << +gatt_if;\n\n  gatt_sr_update_cback_cnt(tcb, sr_res_p->cid, gatt_if, false, false);\n\n  if ((op_code == GATT_REQ_READ_MULTI) ||\n      (op_code == GATT_REQ_READ_MULTI_VAR)) {\n    /* If no error and still waiting, just return */\n    if (!process_read_multi_rsp(sr_res_p, status, p_msg, payload_size))\n      return (GATT_SUCCESS);\n  } else {\n    if (op_code == GATT_REQ_PREPARE_WRITE && status == GATT_SUCCESS)\n      gatt_sr_update_prep_cnt(tcb, gatt_if, true, false);\n\n    if (op_code == GATT_REQ_EXEC_WRITE && status != GATT_SUCCESS)\n      gatt_sr_reset_cback_cnt(tcb, sr_res_p->cid);\n\n    sr_res_p->status = status;\n\n    if (gatt_sr_is_cback_cnt_zero(tcb) && status == GATT_SUCCESS) {\n      if (sr_res_p->p_rsp_msg == NULL) {\n        sr_res_p->p_rsp_msg = attp_build_sr_msg(tcb, (uint8_t)(op_code + 1),\n                                                (tGATT_SR_MSG*)p_msg);\n      } else {\n        LOG(ERROR) << \"Exception!!! already has respond message\";\n      }\n    }\n  }\n  if (gatt_sr_is_cback_cnt_zero(tcb)) {\n    if ((sr_res_p->status == GATT_SUCCESS) && (sr_res_p->p_rsp_msg)) {\n      ret_code = attp_send_sr_msg(tcb, sr_res_p->cid, sr_res_p->p_rsp_msg);\n      sr_res_p->p_rsp_msg = NULL;\n    } else {\n      ret_code = gatt_send_error_rsp(tcb, sr_res_p->cid, status, op_code,\n                                     sr_res_p->handle, false);\n    }\n\n    gatt_dequeue_sr_cmd(tcb, sr_res_p->cid);\n  }\n\n  VLOG(1) << __func__ << \" ret_code=\" << +ret_code;\n\n  return ret_code;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_exec_write_req\n *\n * Description      This function is called to process the execute write request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_exec_write_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint8_t *p = p_data, flag, i = 0;\n  uint32_t trans_id = 0;\n  tGATT_IF gatt_if;\n  uint16_t conn_id;\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1)\n        << \"Conformance tst: forced err rspv for Execute Write: error status=\"\n        << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        gatt_cb.handle, false);\n\n    return;\n  }\n#endif\n\n  if (len < sizeof(flag)) {\n    android_errorWriteLog(0x534e4554, \"73172115\");\n    LOG(ERROR) << __func__ << \"invalid length\";\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_EXEC_WRITE, 0,\n                        false);\n    return;\n  }\n\n  STREAM_TO_UINT8(flag, p);\n\n  /* mask the flag */\n  flag &= GATT_PREP_WRITE_EXEC;\n\n  /* no prep write is queued */\n  if (!gatt_sr_is_prep_cnt_zero(tcb)) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, 0);\n    gatt_sr_copy_prep_cnt_to_cback_cnt(tcb);\n\n    for (i = 0; i < GATT_MAX_APPS; i++) {\n      if (tcb.prep_cnt[i]) {\n        gatt_if = (tGATT_IF)(i + 1);\n        conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_if);\n        tGATTS_DATA gatts_data;\n        gatts_data.exec_write = flag;\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_WRITE_EXEC,\n                                  &gatts_data);\n        tcb.prep_cnt[i] = 0;\n      }\n    }\n  } else /* nothing needs to be executed , send response now */\n  {\n    LOG(ERROR) << \"gatt_process_exec_write_req: no prepare write pending\";\n    gatt_send_error_rsp(tcb, cid, GATT_ERROR, GATT_REQ_EXEC_WRITE, 0, false);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_read_multi_req\n *\n * Description      This function is called to process the read multiple request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_read_multi_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint32_t trans_id;\n  uint16_t handle = 0, ll = len;\n  uint8_t* p = p_data;\n  tGATT_STATUS err = GATT_SUCCESS;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n\n  VLOG(1) << __func__;\n\n  tGATT_READ_MULTI* multi_req = gatt_sr_get_read_multi(tcb, cid);\n  multi_req->num_handles = 0;\n  multi_req->variable_len = (op_code == GATT_REQ_READ_MULTI_VAR);\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rspvofr ReadMultiple: error status=\"\n            << +gatt_cb.err_status;\n\n    STREAM_TO_UINT16(handle, p);\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        handle, false);\n\n    return;\n  }\n#endif\n\n  while (ll >= 2 && multi_req->num_handles < GATT_MAX_READ_MULTI_HANDLES) {\n    STREAM_TO_UINT16(handle, p);\n\n    auto it = gatt_sr_find_i_rcb_by_handle(handle);\n    if (it != gatt_cb.srv_list_info->end()) {\n      multi_req->handles[multi_req->num_handles++] = handle;\n\n      /* check read permission */\n      err = gatts_read_attr_perm_check(it->p_db, false, handle, sec_flag,\n                                       key_size);\n      if (err != GATT_SUCCESS) {\n        VLOG(1) << StringPrintf(\"read permission denied : 0x%02x\", err);\n        break;\n      }\n    } else {\n      /* invalid handle */\n      err = GATT_INVALID_HANDLE;\n      break;\n    }\n    ll -= 2;\n  }\n\n  if (ll != 0) {\n    LOG(ERROR) << \"max attribute handle reached in ReadMultiple Request.\";\n  }\n\n  if (multi_req->num_handles == 0) err = GATT_INVALID_HANDLE;\n\n  if (err == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, multi_req->handles[0]);\n    if (trans_id != 0) {\n      tGATT_SR_CMD* sr_cmd_p = gatt_sr_get_cmd_by_cid(tcb, cid);\n\n      gatt_sr_reset_cback_cnt(tcb,\n                              cid); /* read multiple use multi_rsp_q's count*/\n\n      for (ll = 0; ll < multi_req->num_handles; ll++) {\n        tGATTS_RSP* p_msg = (tGATTS_RSP*)osi_calloc(sizeof(tGATTS_RSP));\n        handle = multi_req->handles[ll];\n        auto it = gatt_sr_find_i_rcb_by_handle(handle);\n\n        p_msg->attr_value.handle = handle;\n        err = gatts_read_attr_value_by_handle(\n            tcb, cid, it->p_db, op_code, handle, 0, p_msg->attr_value.value,\n            &p_msg->attr_value.len, GATT_MAX_ATTR_LEN, sec_flag, key_size,\n            trans_id);\n\n        if (err == GATT_SUCCESS) {\n          gatt_sr_process_app_rsp(tcb, it->gatt_if, trans_id, op_code,\n                                  GATT_SUCCESS, p_msg, sr_cmd_p);\n        }\n        /* either not using or done using the buffer, release it now */\n        osi_free(p_msg);\n      }\n    } else\n      err = GATT_NO_RESOURCES;\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (err != GATT_SUCCESS && err != GATT_PENDING && err != GATT_BUSY)\n    gatt_send_error_rsp(tcb, cid, err, op_code, handle, false);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_build_primary_service_rsp\n *\n * Description      Primamry service request processed internally. Theretically\n *                  only deal with ReadByTypeVAlue and ReadByGroupType.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic tGATT_STATUS gatt_build_primary_service_rsp(\n    BT_HDR* p_msg, tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n    uint16_t s_hdl, uint16_t e_hdl, UNUSED_ATTR uint8_t* p_data,\n    const Uuid& value) {\n  tGATT_STATUS status = GATT_NOT_FOUND;\n  uint8_t handle_len = 4;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl < s_hdl || el.s_hdl > e_hdl ||\n        el.type != GATT_UUID_PRI_SERVICE) {\n      continue;\n    }\n\n    Uuid* p_uuid = gatts_get_service_uuid(el.p_db);\n    if (!p_uuid) continue;\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE)\n      handle_len = 4 + gatt_build_uuid_to_stream_len(*p_uuid);\n\n    /* get the length byte in the repsonse */\n    if (p_msg->offset == 0) {\n      *p++ = op_code + 1;\n      p_msg->len++;\n      p_msg->offset = handle_len;\n\n      if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n        *p++ = (uint8_t)p_msg->offset; /* length byte */\n        p_msg->len++;\n      }\n    }\n\n    if (p_msg->len + p_msg->offset > payload_size ||\n        handle_len != p_msg->offset) {\n      break;\n    }\n\n    if (op_code == GATT_REQ_FIND_TYPE_VALUE && value != *p_uuid) continue;\n\n    UINT16_TO_STREAM(p, el.s_hdl);\n\n    if (gatt_cb.last_service_handle &&\n        gatt_cb.last_service_handle == el.s_hdl) {\n      VLOG(1) << \"Use 0xFFFF for the last primary attribute\";\n      /* see GATT ERRATA 4065, 4063, ATT ERRATA 4062 */\n      UINT16_TO_STREAM(p, 0xFFFF);\n    } else {\n      UINT16_TO_STREAM(p, el.e_hdl);\n    }\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE)\n      gatt_build_uuid_to_stream(&p, *p_uuid);\n\n    status = GATT_SUCCESS;\n    p_msg->len += p_msg->offset;\n  }\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  return status;\n}\n\n/**\n * fill the find information response information in the given buffer.\n *\n * Returns          true: if data filled sucessfully.\n *                  false: packet full, or format mismatch.\n */\nstatic tGATT_STATUS gatt_build_find_info_rsp(tGATT_SRV_LIST_ELEM& el,\n                                             BT_HDR* p_msg, uint16_t& len,\n                                             uint16_t s_hdl, uint16_t e_hdl) {\n  uint8_t info_pair_len[2] = {4, 18};\n\n  if (!el.p_db) return GATT_NOT_FOUND;\n\n  /* check the attribute database */\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET + p_msg->len;\n\n  for (auto& attr : el.p_db->attr_list) {\n    if (attr.handle > e_hdl) break;\n\n    if (attr.handle < s_hdl) continue;\n\n    uint8_t uuid_len = attr.uuid.GetShortestRepresentationSize();\n    if (p_msg->offset == 0)\n      p_msg->offset = (uuid_len == Uuid::kNumBytes16) ? GATT_INFO_TYPE_PAIR_16\n                                                      : GATT_INFO_TYPE_PAIR_128;\n\n    if (len < info_pair_len[p_msg->offset - 1]) return GATT_NO_RESOURCES;\n\n    if (p_msg->offset == GATT_INFO_TYPE_PAIR_16 &&\n        uuid_len == Uuid::kNumBytes16) {\n      UINT16_TO_STREAM(p, attr.handle);\n      UINT16_TO_STREAM(p, attr.uuid.As16Bit());\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 &&\n               uuid_len == Uuid::kNumBytes128) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 &&\n               uuid_len == Uuid::kNumBytes32) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else {\n      LOG(ERROR) << \"format mismatch\";\n      return GATT_NO_RESOURCES;\n      /* format mismatch */\n    }\n    p_msg->len += info_pair_len[p_msg->offset - 1];\n    len -= info_pair_len[p_msg->offset - 1];\n    return GATT_SUCCESS;\n  }\n\n  return GATT_NOT_FOUND;\n}\n\nstatic tGATT_STATUS read_handles(uint16_t& len, uint8_t*& p, uint16_t& s_hdl,\n                                 uint16_t& e_hdl) {\n  if (len < 4) return GATT_INVALID_PDU;\n\n  /* obtain starting handle, and ending handle */\n  STREAM_TO_UINT16(s_hdl, p);\n  STREAM_TO_UINT16(e_hdl, p);\n  len -= 4;\n\n  if (s_hdl > e_hdl || !GATT_HANDLE_IS_VALID(s_hdl) ||\n      !GATT_HANDLE_IS_VALID(e_hdl)) {\n    return GATT_INVALID_HANDLE;\n  }\n\n  return GATT_SUCCESS;\n}\n\nstatic tGATT_STATUS gatts_validate_packet_format(uint8_t op_code, uint16_t& len,\n                                                 uint8_t*& p, Uuid* p_uuid,\n                                                 uint16_t& s_hdl,\n                                                 uint16_t& e_hdl) {\n  tGATT_STATUS ret = read_handles(len, p, s_hdl, e_hdl);\n  if (ret != GATT_SUCCESS) return ret;\n\n  if (len < 2) return GATT_INVALID_PDU;\n\n  /* parse uuid now */\n  CHECK(p_uuid);\n  uint16_t uuid_len = (op_code == GATT_REQ_FIND_TYPE_VALUE) ? 2 : len;\n  if (!gatt_parse_uuid_from_cmd(p_uuid, uuid_len, &p)) {\n    VLOG(1) << \"Bad UUID\";\n    return GATT_INVALID_PDU;\n  }\n\n  len -= uuid_len;\n  return GATT_SUCCESS;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_primary_service_req\n *\n * Description      Process ReadByGroupType/ReadByTypeValue request, for\n *                  discovering all primary services or discover primary service\n *                  by UUID request.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n                                       uint8_t op_code, uint16_t len,\n                                       uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  Uuid uuid = Uuid::kEmpty;\n\n  uint8_t reason =\n      gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  if (uuid != Uuid::From16Bit(GATT_UUID_PRI_SERVICE)) {\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n      gatt_send_error_rsp(tcb, cid, GATT_UNSUPPORT_GRP_TYPE, op_code, s_hdl,\n                          false);\n      VLOG(1) << StringPrintf(\"unexpected ReadByGrpType Group: %s\",\n                              uuid.ToString().c_str());\n      return;\n    }\n\n    // we do not support ReadByTypeValue with any non-primamry_service type\n    gatt_send_error_rsp(tcb, cid, GATT_NOT_FOUND, op_code, s_hdl, false);\n    VLOG(1) << StringPrintf(\"unexpected ReadByTypeValue type: %s\",\n                            uuid.ToString().c_str());\n    return;\n  }\n\n  // TODO: we assume theh value is UUID, there is no such requirement in spec\n  Uuid value = Uuid::kEmpty;\n  if (op_code == GATT_REQ_FIND_TYPE_VALUE) {\n    if (!gatt_parse_uuid_from_cmd(&value, len, &p_data)) {\n      gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, s_hdl, false);\n    }\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  uint16_t msg_len =\n      (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n  reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl,\n                                          e_hdl, p_data, value);\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_find_info\n *\n * Description      process find information request, for discover character\n *                  descriptors.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t op_code, uint16_t len,\n                                    uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  uint8_t reason = read_handles(len, p_data, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n  uint16_t buf_len =\n      (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n  reason = GATT_NOT_FOUND;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n  *p++ = op_code + 1;\n  p_msg->len = 2;\n\n  buf_len = payload_size - 2;\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl <= e_hdl && el.e_hdl >= s_hdl) {\n      reason = gatt_build_find_info_rsp(el, p_msg, buf_len, s_hdl, e_hdl);\n      if (reason == GATT_NO_RESOURCES) {\n        reason = GATT_SUCCESS;\n        break;\n      }\n    }\n  }\n\n  *p = (uint8_t)p_msg->offset;\n\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n  } else\n    attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_mtu_req\n *\n * Description      This function is called to process excahnge MTU request.\n *                  Only used on LE.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_mtu_req(tGATT_TCB& tcb, uint16_t cid, uint16_t len,\n                                  uint8_t* p_data) {\n  /* BR/EDR conenction, send error response */\n  if (cid != L2CAP_ATT_CID) {\n    gatt_send_error_rsp(tcb, cid, GATT_REQ_NOT_SUPPORTED, GATT_REQ_MTU, 0,\n                        false);\n    return;\n  }\n\n  if (len < GATT_MTU_REQ_MIN_LEN) {\n    LOG(ERROR) << \"invalid MTU request PDU received.\";\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_MTU, 0, false);\n    return;\n  }\n\n  uint16_t mtu = 0;\n  uint8_t* p = p_data;\n  STREAM_TO_UINT16(mtu, p);\n  /* mtu must be greater than default MTU which is 23/48 */\n  if (mtu < GATT_DEF_BLE_MTU_SIZE)\n    tcb.payload_size = GATT_DEF_BLE_MTU_SIZE;\n  else if (mtu > GATT_MAX_MTU_SIZE)\n    tcb.payload_size = GATT_MAX_MTU_SIZE;\n  else\n    tcb.payload_size = mtu;\n\n  LOG(INFO) << \"MTU request PDU with MTU size \" << +tcb.payload_size;\n\n  BTM_SetBleDataLength(tcb.peer_bda, tcb.payload_size + L2CAP_PKT_OVERHEAD);\n\n  tGATT_SR_MSG gatt_sr_msg;\n  gatt_sr_msg.mtu = tcb.payload_size;\n  BT_HDR* p_buf = attp_build_sr_msg(tcb, GATT_RSP_MTU, &gatt_sr_msg);\n  attp_send_sr_msg(tcb, cid, p_buf);\n\n  tGATTS_DATA gatts_data;\n  gatts_data.mtu = tcb.payload_size;\n  /* Notify all registered applicaiton with new MTU size. Us a transaction ID */\n  /* of 0, as no response is allowed from applcations                    */\n  for (int i = 0; i < GATT_MAX_APPS; i++) {\n    if (gatt_cb.cl_rcb[i].in_use) {\n      uint16_t conn_id =\n          GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_cb.cl_rcb[i].gatt_if);\n      gatt_sr_send_req_callback(conn_id, 0, GATTS_REQ_TYPE_MTU, &gatts_data);\n    }\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_read_by_type_req\n *\n * Description      process Read By type request.\n *                  This PDU can be used to perform:\n *                  - read characteristic value\n *                  - read characteristic descriptor value\n *                  - discover characteristic\n *                  - discover characteristic by UUID\n *                  - relationship discovery\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n                                           uint8_t op_code, uint16_t len,\n                                           uint8_t* p_data) {\n  Uuid uuid = Uuid::kEmpty;\n  uint16_t s_hdl = 0, e_hdl = 0, err_hdl = 0;\n  tGATT_STATUS reason =\n      gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rsp for ReadByType: error status=\"\n            << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        s_hdl, false);\n\n    return;\n  }\n#endif\n\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  *p++ = op_code + 1;\n  /* reserve length byte */\n  p_msg->len = 2;\n  uint16_t buf_len = payload_size - 2;\n\n  reason = GATT_NOT_FOUND;\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl <= e_hdl && el.e_hdl >= s_hdl) {\n      tGATT_SEC_FLAG sec_flag;\n      uint8_t key_size;\n      gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n      tGATT_STATUS ret = gatts_db_read_attr_value_by_type(\n          tcb, cid, el.p_db, op_code, p_msg, s_hdl, e_hdl, uuid, &buf_len,\n          sec_flag, key_size, 0, &err_hdl);\n      if (ret != GATT_NOT_FOUND) {\n        reason = ret;\n        if (ret == GATT_NO_RESOURCES) reason = GATT_SUCCESS;\n      }\n\n      if (ret != GATT_SUCCESS && ret != GATT_NOT_FOUND) {\n        s_hdl = err_hdl;\n        break;\n      }\n    }\n  }\n  *p = (uint8_t)p_msg->offset;\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n\n    /* in theroy BUSY is not possible(should already been checked), protected\n     * check */\n    if (reason != GATT_PENDING && reason != GATT_BUSY)\n      gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/**\n * This function is called to process the write request from client.\n */\nstatic void gatts_process_write_req(tGATT_TCB& tcb, uint16_t cid,\n                                    tGATT_SRV_LIST_ELEM& el, uint16_t handle,\n                                    uint8_t op_code, uint16_t len,\n                                    uint8_t* p_data,\n                                    bt_gatt_db_attribute_type_t gatt_type) {\n  tGATTS_DATA sr_data;\n  uint32_t trans_id;\n  tGATT_STATUS status;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size, *p = p_data;\n  uint16_t conn_id;\n\n  memset(&sr_data, 0, sizeof(tGATTS_DATA));\n\n  switch (op_code) {\n    case GATT_REQ_PREPARE_WRITE:\n      if (len < 2 || p == nullptr) {\n        LOG(ERROR) << __func__\n                   << \": Prepare write request was invalid - missing offset, \"\n                      \"sending error response\";\n        gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, handle, false);\n        return;\n      }\n      sr_data.write_req.is_prep = true;\n      STREAM_TO_UINT16(sr_data.write_req.offset, p);\n      len -= 2;\n      FALLTHROUGH_INTENDED; /* FALLTHROUGH */\n    case GATT_SIGN_CMD_WRITE:\n      if (op_code == GATT_SIGN_CMD_WRITE) {\n        VLOG(1) << \"Write CMD with data sigining\";\n        len -= GATT_AUTH_SIGN_LEN;\n      }\n      FALLTHROUGH_INTENDED; /* FALLTHROUGH */\n    case GATT_CMD_WRITE:\n    case GATT_REQ_WRITE:\n      if (op_code == GATT_REQ_WRITE || op_code == GATT_REQ_PREPARE_WRITE)\n        sr_data.write_req.need_rsp = true;\n      sr_data.write_req.handle = handle;\n      if (len > GATT_MAX_ATTR_LEN) len = GATT_MAX_ATTR_LEN;\n      sr_data.write_req.len = len;\n      if (len != 0 && p != nullptr) {\n        memcpy(sr_data.write_req.value, p, len);\n      }\n      break;\n  }\n\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n  status = gatts_write_attr_perm_check(el.p_db, op_code, handle,\n                                       sr_data.write_req.offset, p, len,\n                                       sec_flag, key_size);\n\n  if (status == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, handle);\n    if (trans_id != 0) {\n      conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, el.gatt_if);\n\n      uint8_t opcode = 0;\n      if (gatt_type == BTGATT_DB_DESCRIPTOR) {\n        opcode = GATTS_REQ_TYPE_WRITE_DESCRIPTOR;\n      } else if (gatt_type == BTGATT_DB_CHARACTERISTIC) {\n        opcode = GATTS_REQ_TYPE_WRITE_CHARACTERISTIC;\n      } else {\n        LOG(ERROR) << __func__\n                   << \"%s: Attempt to write attribute that's not tied with\"\n                      \" characteristic or descriptor value.\";\n        status = GATT_ERROR;\n      }\n\n      if (opcode) {\n        gatt_sr_send_req_callback(conn_id, trans_id, opcode, &sr_data);\n        status = GATT_PENDING;\n      }\n    } else {\n      LOG(ERROR) << \"max pending command, send error\";\n      status = GATT_BUSY; /* max pending command, application error */\n    }\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (status != GATT_PENDING && status != GATT_BUSY &&\n      (op_code == GATT_REQ_PREPARE_WRITE || op_code == GATT_REQ_WRITE)) {\n    gatt_send_error_rsp(tcb, cid, status, op_code, handle, false);\n  }\n  return;\n}\n\n/**\n * This function is called to process the read request from client.\n */\nstatic void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                   tGATT_SRV_LIST_ELEM& el, uint8_t op_code,\n                                   uint16_t handle, uint16_t len,\n                                   uint8_t* p_data) {\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  uint16_t offset = 0;\n\n  if (op_code == GATT_REQ_READ_BLOB && len < sizeof(uint16_t)) {\n    /* Error: packet length is too short */\n    LOG(ERROR) << __func__ << \": packet length=\" << len\n               << \" too short. min=\" << sizeof(uint16_t);\n    android_errorWriteWithInfoLog(0x534e4554, \"73172115\", -1, NULL, 0);\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, 0, false);\n    return;\n  }\n\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n\n  if (op_code == GATT_REQ_READ_BLOB) STREAM_TO_UINT16(offset, p_data);\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n  *p++ = op_code + 1;\n  p_msg->len = 1;\n  buf_len = payload_size - 1;\n\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n  uint16_t value_len = 0;\n  tGATT_STATUS reason = gatts_read_attr_value_by_handle(\n      tcb, cid, el.p_db, op_code, handle, offset, p, &value_len,\n      (uint16_t)buf_len, sec_flag, key_size, 0);\n  p_msg->len += value_len;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n\n    /* in theory BUSY is not possible(should already been checked), protected\n     * check */\n    if (reason != GATT_PENDING && reason != GATT_BUSY)\n      gatt_send_error_rsp(tcb, cid, reason, op_code, handle, false);\n\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_attribute_req\n *\n * Description      This function is called to process the per attribute handle\n *                  request from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_attribute_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint16_t handle = 0;\n  uint8_t* p = p_data;\n  tGATT_STATUS status = GATT_INVALID_HANDLE;\n\n  if (len < 2) {\n    LOG(ERROR) << \"Illegal PDU length, discard request\";\n    status = GATT_INVALID_PDU;\n  } else {\n    STREAM_TO_UINT16(handle, p);\n    len -= 2;\n  }\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  gatt_cb.handle = handle;\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rsp: error status=\"\n            << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, cid, gatt_cb.req_op_code,\n                        handle, false);\n\n    return;\n  }\n#endif\n\n  if (GATT_HANDLE_IS_VALID(handle)) {\n    for (auto& el : *gatt_cb.srv_list_info) {\n      if (el.s_hdl <= handle && el.e_hdl >= handle) {\n        for (const auto& attr : el.p_db->attr_list) {\n          if (attr.handle == handle) {\n            switch (op_code) {\n              case GATT_REQ_READ: /* read char/char descriptor value */\n              case GATT_REQ_READ_BLOB:\n                gatts_process_read_req(tcb, cid, el, op_code, handle, len, p);\n                break;\n\n              case GATT_REQ_WRITE: /* write char/char descriptor value */\n              case GATT_CMD_WRITE:\n              case GATT_SIGN_CMD_WRITE:\n              case GATT_REQ_PREPARE_WRITE:\n                gatts_process_write_req(tcb, cid, el, handle, op_code, len, p,\n                                        attr.gatt_type);\n                break;\n              default:\n                break;\n            }\n            status = GATT_SUCCESS;\n            break;\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  if (status != GATT_SUCCESS && op_code != GATT_CMD_WRITE &&\n      op_code != GATT_SIGN_CMD_WRITE)\n    gatt_send_error_rsp(tcb, cid, status, op_code, handle, false);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_proc_srv_chg_ind_ack\n *\n * Description      This function process the service changed indicaiton ACK\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_proc_srv_chg_ind_ack(tGATT_TCB tcb) {\n  tGATTS_SRV_CHG_REQ req;\n  tGATTS_SRV_CHG* p_buf = NULL;\n\n  VLOG(1) << __func__;\n\n  p_buf = gatt_is_bda_in_the_srv_chg_clt_list(tcb.peer_bda);\n  if (p_buf != NULL) {\n    VLOG(1) << \"NV update set srv chg = false\";\n    p_buf->srv_changed = false;\n    memcpy(&req.srv_chg, p_buf, sizeof(tGATTS_SRV_CHG));\n    if (gatt_cb.cb_info.p_srv_chg_callback)\n      (*gatt_cb.cb_info.p_srv_chg_callback)(GATTS_SRV_CHG_CMD_UPDATE_CLIENT,\n                                            &req, NULL);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_chk_pending_ind\n *\n * Description      This function check any pending indication needs to be sent\n *                  if there is a pending indication then sent the indication\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_chk_pending_ind(tGATT_TCB& tcb) {\n  VLOG(1) << __func__;\n\n  tGATT_VALUE* p_buf =\n      (tGATT_VALUE*)fixed_queue_try_peek_first(tcb.pending_ind_q);\n  if (p_buf != NULL) {\n    GATTS_HandleValueIndication(p_buf->conn_id, p_buf->handle, p_buf->len,\n                                p_buf->value);\n    osi_free(fixed_queue_try_remove_from_queue(tcb.pending_ind_q, p_buf));\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_proc_ind_ack\n *\n * Description      This function processes the Indication ack\n *\n * Returns          true continue to process the indication ack by the\n *                  application if the ACK is not a Service Changed Indication\n *\n ******************************************************************************/\nstatic bool gatts_proc_ind_ack(tGATT_TCB& tcb, uint16_t ack_handle) {\n  bool continue_processing = true;\n\n  VLOG(1) << __func__ << \" ack handle=%d\" << ack_handle;\n\n  if (ack_handle == gatt_cb.handle_of_h_r) {\n    gatts_proc_srv_chg_ind_ack(tcb);\n    /* there is no need to inform the application since srv chg is handled\n     * internally by GATT */\n    continue_processing = false;\n\n    // After receiving ack of svc_chg_ind, reset client status\n    gatt_sr_update_cl_status(tcb, /* chg_aware= */ true);\n  }\n\n  gatts_chk_pending_ind(tcb);\n  return continue_processing;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_value_conf\n *\n * Description      This function is called to process the handle value\n *                  confirmation.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_value_conf(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code) {\n  uint16_t handle;\n\n  if (!gatt_tcb_find_indicate_handle(tcb, cid, &handle)) {\n    LOG(ERROR) << \"unexpected handle value confirmation\";\n    return;\n  }\n\n  gatt_stop_conf_timer(tcb, cid);\n\n  bool continue_processing = gatts_proc_ind_ack(tcb, handle);\n\n  if (continue_processing) {\n    tGATTS_DATA gatts_data;\n    gatts_data.handle = handle;\n    for (auto& el : *gatt_cb.srv_list_info) {\n      if (el.s_hdl <= handle && el.e_hdl >= handle) {\n        uint32_t trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, handle);\n        uint16_t conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, el.gatt_if);\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_CONF,\n                                  &gatts_data);\n      }\n    }\n  }\n}\n\nstatic bool gatts_process_db_out_of_sync(tGATT_TCB& tcb, uint16_t cid,\n                                         uint8_t op_code, uint16_t len,\n                                         uint8_t* p_data) {\n  if (gatt_sr_is_cl_change_aware(tcb)) return false;\n\n  // default value\n  bool should_ignore = true;\n  bool should_rsp = true;\n\n  switch (op_code) {\n    case GATT_REQ_READ_BY_TYPE: {\n      // Check if read database hash by UUID\n      Uuid uuid = Uuid::kEmpty;\n      uint16_t s_hdl = 0, e_hdl = 0;\n      uint16_t db_hash_handle = gatt_cb.handle_of_database_hash;\n      tGATT_STATUS reason = gatts_validate_packet_format(op_code, len, p_data,\n                                                         &uuid, s_hdl, e_hdl);\n      if (reason == GATT_SUCCESS &&\n          (s_hdl <= db_hash_handle && db_hash_handle <= e_hdl) &&\n          (uuid == Uuid::From16Bit(GATT_UUID_DATABASE_HASH)))\n        should_ignore = false;\n\n    } break;\n    case GATT_REQ_READ: {\n      // Check if read database hash by handle\n      uint16_t handle = 0;\n      uint8_t* p = p_data;\n      tGATT_STATUS status = GATT_SUCCESS;\n\n      if (len < 2) {\n        status = GATT_INVALID_PDU;\n      } else {\n        STREAM_TO_UINT16(handle, p);\n        len -= 2;\n      }\n\n      if (status == GATT_SUCCESS && handle == gatt_cb.handle_of_database_hash)\n        should_ignore = false;\n\n    } break;\n    case GATT_REQ_READ_BY_GRP_TYPE: /* discover primary services */\n    case GATT_REQ_FIND_TYPE_VALUE:  /* discover service by UUID */\n    case GATT_REQ_FIND_INFO:        /* discover char descrptor */\n    case GATT_REQ_READ_BLOB:        /* read long char */\n    case GATT_REQ_READ_MULTI:       /* read multi char*/\n    case GATT_REQ_WRITE:            /* write char/char descriptor value */\n    case GATT_REQ_PREPARE_WRITE:    /* write long char */\n      // Use default value\n      break;\n    case GATT_CMD_WRITE:      /* cmd */\n    case GATT_SIGN_CMD_WRITE: /* sign cmd */\n      should_rsp = false;\n      break;\n    case GATT_REQ_MTU:           /* configure mtu */\n    case GATT_REQ_EXEC_WRITE:    /* execute write */\n    case GATT_HANDLE_VALUE_CONF: /* confirm for indication */\n    default:\n      should_ignore = false;\n  }\n\n  if (should_ignore) {\n    if (should_rsp) {\n      gatt_send_error_rsp(tcb, cid, GATT_DATABASE_OUT_OF_SYNC, op_code, 0x0000,\n                          false);\n    }\n    LOG(INFO) << __func__ << \": database out of sync, device=\" << tcb.peer_bda\n              << \", op_code=\" << loghex((uint16_t)op_code)\n              << \", should_rsp=\" << should_rsp;\n    gatt_sr_update_cl_status(tcb, /* chg_aware= */ should_rsp);\n  }\n\n  return should_ignore;\n}\n\n/** This function is called to handle the client requests to server */\nvoid gatt_server_handle_client_req(tGATT_TCB& tcb, uint16_t cid,\n                                   uint8_t op_code, uint16_t len,\n                                   uint8_t* p_data) {\n  /* there is pending command, discard this one */\n  if (!gatt_sr_cmd_empty(tcb, cid) && op_code != GATT_HANDLE_VALUE_CONF) return;\n\n  /* the size of the message may not be bigger than the local max PDU size*/\n  /* The message has to be smaller than the agreed MTU, len does not include op\n   * code */\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_rx(tcb, cid);\n  if (len >= payload_size) {\n    LOG(ERROR) << StringPrintf(\"server receive invalid PDU size:%d pdu size:%d\",\n                               len + 1, payload_size);\n    /* for invalid request expecting response, send it now */\n    if (op_code != GATT_CMD_WRITE && op_code != GATT_SIGN_CMD_WRITE &&\n        op_code != GATT_HANDLE_VALUE_CONF) {\n      gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, 0, false);\n    }\n    /* otherwise, ignore the pkt */\n  } else {\n    // handle database out of sync\n    if (gatts_process_db_out_of_sync(tcb, cid, op_code, len, p_data)) return;\n\n    switch (op_code) {\n      case GATT_REQ_READ_BY_GRP_TYPE: /* discover primary services */\n      case GATT_REQ_FIND_TYPE_VALUE:  /* discover service by UUID */\n        gatts_process_primary_service_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_FIND_INFO: /* discover char descrptor */\n        gatts_process_find_info(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ_BY_TYPE: /* read characteristic value, char descriptor\n                                     value */\n        /* discover characteristic, discover char by UUID */\n        gatts_process_read_by_type_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ: /* read char/char descriptor value */\n      case GATT_REQ_READ_BLOB:\n      case GATT_REQ_WRITE: /* write char/char descriptor value */\n      case GATT_CMD_WRITE:\n      case GATT_SIGN_CMD_WRITE:\n      case GATT_REQ_PREPARE_WRITE:\n        gatts_process_attribute_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_HANDLE_VALUE_CONF:\n        gatts_process_value_conf(tcb, cid, op_code);\n        break;\n\n      case GATT_REQ_MTU:\n        gatts_process_mtu_req(tcb, cid, len, p_data);\n        break;\n\n      case GATT_REQ_EXEC_WRITE:\n        gatt_process_exec_write_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ_MULTI:\n      case GATT_REQ_READ_MULTI_VAR:\n        gatt_process_read_multi_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      default:\n        break;\n    }\n  }\n}\n```"
                    }
                ]
            }
        ],
        "upstream_patch_content": "From 7de5617f7d5266fe57c990c428621b5d4e92728a Mon Sep 17 00:00:00 2001\nFrom: Brian Delwiche <delwiche@google.com>\nDate: Thu, 12 Sep 2024 17:26:55 +0000\nSubject: [PATCH] Fix OOB writes in gatt_sr.cc\n\nAt various points in gatt_sr.cc, the output of the\ngatt_tcb_get_payload_size function is used without checking for a\npositive length.  However, in exceptional cases it is possible for the\nchannel to be closed at the time the function is called, which will lead\nto a zero length and cause an OOB write in subsequent processing.\n\nFix all of these.\n\nBug: 364026473\nBug: 364027038\nBug: 364027949\nBug: 364025411\nTest: m libbluetooth\nTest: researcher POC\nFlag: EXEMPT trivial validity checks\nTag: #security\nIgnore-AOSP-First: Security\nChange-Id: I9b30499d4aed6ab42f3cdb2c0de7df2c1a827404\n---\n system/stack/gatt/gatt_sr.cc | 21 +++++++++++++++++++++\n 1 file changed, 21 insertions(+)\n\ndiff --git a/system/stack/gatt/gatt_sr.cc b/system/stack/gatt/gatt_sr.cc\nindex 995ea810cb..0235ba964e 100644\n--- a/system/stack/gatt/gatt_sr.cc\n+++ b/system/stack/gatt/gatt_sr.cc\n@@ -772,6 +772,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_\n \n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl, e_hdl, p_data, value);\n@@ -804,6 +809,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid, uint8_t op_cod\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n@@ -949,6 +960,11 @@ static void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid, uint8_t\n \n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n@@ -1096,6 +1112,11 @@ static void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid, tGATT_SRV_LIST_\n                                    uint8_t* p_data) {\n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   uint16_t offset = 0;\n \n-- \n2.39.5 (Apple Git-154)\n\n",
        "upstream_commits": [
            "7de5617f7d5266fe57c990c428621b5d4e92728a"
        ]
    },
    {
        "id": "ASB-A-355411348",
        "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-355411348",
        "severity": "High",
        "failures": [
            {
                "downstream_version": "13",
                "branch_used": "android13-release",
                "downstream_patch": "71e09e5ad12d02b3129c7a5ce16f6de734fdd0da",
                "repo_path": "android_repos/Permission",
                "result": "failure",
                "downstream_patch_content": "commit 71e09e5ad12d02b3129c7a5ce16f6de734fdd0da\nAuthor: Manjeet Rulhania <mrulhania@google.com>\nDate:   Wed Oct 30 20:18:46 2024 +0000\n\n    Role re-evaluation should respect ask every time choice by user\n    \n    Role evalation respect USER_SET flag when the role is not\n    supposed to override user choices. Role granting logic\n    is missing ONE_TIME check, ONE_TIME flag should be considered\n    a user choice.\n    \n    Bug: 355411348\n    Change-Id: I4146abff462ef4ed0e67efd04b4182bcf2c04d98\n    Test: RolePermissionOverrideTest\n    Relnote: security bug fix\n    Merged-In: Ie65c2cd62ba3f24e8dd411abca49e397746bc1a9\n\ndiff --git a/PermissionController/src/com/android/permissioncontroller/role/model/Permissions.java b/PermissionController/src/com/android/permissioncontroller/role/model/Permissions.java\nindex dee675bd06..ab56518f32 100644\n--- a/PermissionController/src/com/android/permissioncontroller/role/model/Permissions.java\n+++ b/PermissionController/src/com/android/permissioncontroller/role/model/Permissions.java\n@@ -253,7 +253,8 @@ public class Permissions {\n         if (!wasPermissionOrAppOpGranted) {\n             // If we've granted a permission which wasn't granted, it's no longer user set or fixed.\n             newMask |= PackageManager.FLAG_PERMISSION_USER_FIXED\n-                    | PackageManager.FLAG_PERMISSION_USER_SET;\n+                    | PackageManager.FLAG_PERMISSION_USER_SET\n+                    | PackageManager.FLAG_PERMISSION_ONE_TIME;\n         }\n         // If a component gets a permission for being the default handler A and also default handler\n         // B, we grant the weaker grant form. This only applies to default permission grant.\n@@ -607,7 +608,8 @@ public class Permissions {\n         }\n         if (!overrideUserSetAndFixed) {\n             fixedFlags |= PackageManager.FLAG_PERMISSION_USER_FIXED\n-                    | PackageManager.FLAG_PERMISSION_USER_SET;\n+                    | PackageManager.FLAG_PERMISSION_USER_SET\n+                    | PackageManager.FLAG_PERMISSION_ONE_TIME;\n         }\n         return (flags & fixedFlags) != 0;\n     }\n",
                "file_conflicts": []
            }
        ],
        "upstream_patch_content": "From 7e1f7097f4a6895358bf1472e6d26c5198d00c11 Mon Sep 17 00:00:00 2001\nFrom: mrulhania <mrulhania@google.com>\nDate: Thu, 24 Oct 2024 14:29:30 -0700\nSubject: [PATCH] Role re-evaluation should respect ask every time choice by\n user\n\nRole evalation respect USER_SET flag when the role is not\nsupposed to override user choices. Role granting logic\nis missing ONE_TIME check, ONE_TIME flag should be considered\na user choice.\n\nFix: 355411348\nTest: tbd\nFLAG: EXEMPT bug fix\nRelnote: security bug fix\nChange-Id: Ie65c2cd62ba3f24e8dd411abca49e397746bc1a9\n---\n .../java/com/android/role/controller/model/Permissions.java | 6 ++++--\n 1 file changed, 4 insertions(+), 2 deletions(-)\n\ndiff --git a/PermissionController/role-controller/java/com/android/role/controller/model/Permissions.java b/PermissionController/role-controller/java/com/android/role/controller/model/Permissions.java\nindex ed21db7bb1..820ff3d4e4 100644\n--- a/PermissionController/role-controller/java/com/android/role/controller/model/Permissions.java\n+++ b/PermissionController/role-controller/java/com/android/role/controller/model/Permissions.java\n@@ -263,7 +263,8 @@ public class Permissions {\n         if (!wasPermissionOrAppOpGranted) {\n             // If we've granted a permission which wasn't granted, it's no longer user set or fixed.\n             newMask |= PackageManager.FLAG_PERMISSION_USER_FIXED\n-                    | PackageManager.FLAG_PERMISSION_USER_SET;\n+                    | PackageManager.FLAG_PERMISSION_USER_SET\n+                    | PackageManager.FLAG_PERMISSION_ONE_TIME;\n         }\n         // If a component gets a permission for being the default handler A and also default handler\n         // B, we grant the weaker grant form. This only applies to default permission grant.\n@@ -634,7 +635,8 @@ public class Permissions {\n         }\n         if (!overrideUserSetAndFixed) {\n             fixedFlags |= PackageManager.FLAG_PERMISSION_USER_FIXED\n-                    | PackageManager.FLAG_PERMISSION_USER_SET;\n+                    | PackageManager.FLAG_PERMISSION_USER_SET\n+                    | PackageManager.FLAG_PERMISSION_ONE_TIME;\n         }\n         return (flags & fixedFlags) != 0;\n     }\n-- \n2.39.5 (Apple Git-154)\n\n",
        "upstream_commits": [
            "7e1f7097f4a6895358bf1472e6d26c5198d00c11"
        ]
    },
    {
        "id": "ASB-A-364027949",
        "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-364027949",
        "severity": "Critical",
        "failures": [
            {
                "downstream_version": "13",
                "branch_used": "android13-release",
                "downstream_patch": "2fc3087b9ac3019518c6ceb8a64d181d6bb04907",
                "repo_path": "android_repos/Bluetooth",
                "result": "failure",
                "downstream_patch_content": "commit 2fc3087b9ac3019518c6ceb8a64d181d6bb04907\nAuthor: Brian Delwiche <delwiche@google.com>\nDate:   Fri Oct 4 18:23:45 2024 +0000\n\n    Fix OOB writes in gatt_sr.cc\n    \n    At various points in gatt_sr.cc, the output of the\n    gatt_tcb_get_payload_size function is used without checking for a\n    positive length.  However, in exceptional cases it is possible for the\n    channel to be closed at the time the function is called, which will lead\n    to a zero length and cause an OOB write in subsequent processing.\n    \n    Fix all of these.\n    \n    Bug: 364026473\n    Bug: 364027038\n    Bug: 364027949\n    Bug: 364025411\n    Test: m libbluetooth\n    Test: researcher POC\n    Flag: EXEMPT trivial validity checks\n    Tag: #security\n    Ignore-AOSP-First: Security\n    Merged-In: I9b30499d4aed6ab42f3cdb2c0de7df2c1a827404\n    Change-Id: I9b30499d4aed6ab42f3cdb2c0de7df2c1a827404\n\ndiff --git a/system/stack/gatt/gatt_sr.cc b/system/stack/gatt/gatt_sr.cc\nindex 6f81b90514..c61df52bc8 100644\n--- a/system/stack/gatt/gatt_sr.cc\n+++ b/system/stack/gatt/gatt_sr.cc\n@@ -734,6 +734,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n@@ -769,6 +774,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n@@ -902,6 +913,11 @@ static void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n@@ -1049,6 +1065,11 @@ static void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t* p_data) {\n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   uint16_t offset = 0;\n \n",
                "file_conflicts": [
                    {
                        "file_name": "system/stack/gatt/gatt_sr.cc",
                        "total_hunks": 4,
                        "failed_hunks": [
                            1,
                            2
                        ],
                        "inline_merge_conflicts": [
                            {
                                "hunk_number": 1,
                                "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n\n=======\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n>>>>>>> UPSTREAM PATCH (commit 7de5617f7d5266fe57c990c428621b5d4e92728a)"
                            },
                            {
                                "hunk_number": 2,
                                "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n\n=======\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n>>>>>>> UPSTREAM PATCH (commit 7de5617f7d5266fe57c990c428621b5d4e92728a)"
                            }
                        ],
                        "rej_file_content": "```diff\n--- system/stack/gatt/gatt_sr.cc\n+++ system/stack/gatt/gatt_sr.cc\n@@ -772,6 +772,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_\n \n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl, e_hdl, p_data, value);\n@@ -804,6 +809,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid, uint8_t op_cod\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n```",
                        "patch_apply_output": "patching file system/stack/gatt/gatt_sr.cc\nHunk #1 FAILED at 772.\nHunk #2 FAILED at 804.\nHunk #3 succeeded at 902 with fuzz 2 (offset -47 lines).\nHunk #4 succeeded at 1054 with fuzz 2 (offset -47 lines).\n2 out of 4 hunks FAILED -- saving rejects to file system/stack/gatt/gatt_sr.cc.rej",
                        "inline_merge_output": "patching file system/stack/gatt/gatt_sr.cc\nHunk #1 NOT MERGED at 780-789.\nHunk #2 NOT MERGED at 828-837.\nHunk #3 merged at 988-992.\nHunk #4 merged at 1145-1149.",
                        "upstream_file_content": "```cc\n/******************************************************************************\n *\n *  Copyright 2008-2012 Broadcom Corporation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at:\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n ******************************************************************************/\n\n/******************************************************************************\n *\n *  this file contains the GATT server functions\n *\n ******************************************************************************/\n\n#include <bluetooth/log.h>\n#include <com_android_bluetooth_flags.h>\n#include <string.h>\n\n#include <algorithm>\n\n#include \"gatt_int.h\"\n#include \"hardware/bt_gatt_types.h\"\n#include \"internal_include/bt_target.h\"\n#include \"l2c_api.h\"\n#include \"osi/include/allocator.h\"\n#include \"stack/arbiter/acl_arbiter.h\"\n#include \"stack/eatt/eatt.h\"\n#include \"stack/include/bt_hdr.h\"\n#include \"stack/include/bt_types.h\"\n#include \"stack/include/btm_client_interface.h\"\n#include \"stack/include/l2cdefs.h\"\n#include \"types/bluetooth/uuid.h\"\n\n#define GATT_MTU_REQ_MIN_LEN 2\n#define L2CAP_PKT_OVERHEAD 4\n\nusing bluetooth::Uuid;\nusing bluetooth::eatt::EattChannel;\nusing bluetooth::eatt::EattExtension;\nusing namespace bluetooth;\n\n/*******************************************************************************\n *\n * Function         gatt_sr_enqueue_cmd\n *\n * Description      This function enqueue the request from client which needs a\n *                  application response, and update the transaction ID.\n *\n * Returns          void\n *\n ******************************************************************************/\nuint32_t gatt_sr_enqueue_cmd(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code, uint16_t handle) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel = EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n    if (channel == nullptr) {\n      log::warn(\"{}, cid 0x{:02x} already disconnected\", tcb.peer_bda, cid);\n      return 0;\n    }\n\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  uint32_t trans_id = 0;\n\n  p_cmd->cid = cid;\n\n  if ((p_cmd->op_code == 0) || (op_code == GATT_HANDLE_VALUE_CONF)) /* no pending request */\n  {\n    if (op_code == GATT_CMD_WRITE || op_code == GATT_SIGN_CMD_WRITE || op_code == GATT_REQ_MTU ||\n        op_code == GATT_HANDLE_VALUE_CONF) {\n      trans_id = ++tcb.trans_id;\n    } else {\n      p_cmd->trans_id = ++tcb.trans_id;\n      p_cmd->op_code = op_code;\n      p_cmd->handle = handle;\n      p_cmd->status = GATT_NOT_FOUND;\n      tcb.trans_id %= GATT_TRANS_ID_MAX;\n      trans_id = p_cmd->trans_id;\n    }\n  }\n\n  return trans_id;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_cmd_empty\n *\n * Description      This function checks if the server command queue is empty.\n *\n * Returns          true if empty, false if there is pending command.\n *\n ******************************************************************************/\nbool gatt_sr_cmd_empty(tGATT_TCB& tcb, uint16_t cid) {\n  if (cid == tcb.att_lcid) {\n    return tcb.sr_cmd.op_code == 0;\n  }\n\n  EattChannel* channel = EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n  if (channel == nullptr) {\n    log::warn(\"{}, cid 0x{:02x} already disconnected\", tcb.peer_bda, cid);\n    return false;\n  }\n\n  return channel->server_outstanding_cmd_.op_code == 0;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_dequeue_sr_cmd\n *\n * Description      This function dequeue the request from command queue.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_dequeue_sr_cmd(tGATT_TCB& tcb, uint16_t cid) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel = EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n    if (channel == nullptr) {\n      log::warn(\"{}, cid 0x{:02x} already disconnected\", tcb.peer_bda, cid);\n      return;\n    }\n\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  /* Double check in case any buffers are queued */\n  log::verbose(\"gatt_dequeue_sr_cmd cid: 0x{:x}\", cid);\n  if (p_cmd->p_rsp_msg) {\n    log::error(\"free tcb.sr_cmd.p_rsp_msg = {}\", fmt::ptr(p_cmd->p_rsp_msg));\n  }\n  osi_free_and_reset((void**)&p_cmd->p_rsp_msg);\n\n  while (!fixed_queue_is_empty(p_cmd->multi_rsp_q)) {\n    osi_free(fixed_queue_try_dequeue(p_cmd->multi_rsp_q));\n  }\n  fixed_queue_free(p_cmd->multi_rsp_q, NULL);\n  memset(p_cmd, 0, sizeof(tGATT_SR_CMD));\n}\n\nstatic void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) {\n  uint16_t ii;\n  size_t total_len, len;\n  uint8_t* p;\n  bool is_overflow = false;\n\n  // We need at least one extra byte for the opcode\n  if (mtu == 0) {\n    log::error(\"Invalid MTU\");\n    p_cmd->status = GATT_ILLEGAL_PARAMETER;\n    return;\n  }\n\n  len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu;\n  BT_HDR* p_buf = (BT_HDR*)osi_calloc(len);\n  p_buf->offset = L2CAP_MIN_OFFSET;\n  p = (uint8_t*)(p_buf + 1) + p_buf->offset;\n\n  /* First byte in the response is the opcode */\n  if (p_cmd->multi_req.variable_len) {\n    *p++ = GATT_RSP_READ_MULTI_VAR;\n  } else {\n    *p++ = GATT_RSP_READ_MULTI;\n  }\n\n  p_buf->len = 1;\n\n  // Now walk through the buffers putting the data into the response in order\n  list_t* list = NULL;\n  const list_node_t* node = NULL;\n  if (!fixed_queue_is_empty(p_cmd->multi_rsp_q)) {\n    list = fixed_queue_get_list(p_cmd->multi_rsp_q);\n  }\n  for (ii = 0; ii < p_cmd->multi_req.num_handles; ii++) {\n    tGATTS_RSP* p_rsp = NULL;\n\n    if (list != NULL) {\n      if (ii == 0) {\n        node = list_begin(list);\n      } else {\n        node = list_next(node);\n      }\n      if (node != list_end(list)) {\n        p_rsp = (tGATTS_RSP*)list_node(node);\n      }\n    }\n\n    if (p_rsp != NULL) {\n      total_len = p_buf->len;\n      if (p_cmd->multi_req.variable_len) {\n        total_len += 2;\n      }\n\n      if (total_len > mtu) {\n        log::verbose(\"Buffer space not enough for this data item, skipping\");\n        break;\n      }\n\n      len = std::min((size_t)p_rsp->attr_value.len, mtu - total_len);\n\n      if (total_len == mtu && p_rsp->attr_value.len > 0) {\n        log::verbose(\"Buffer space not enough for this data item, skipping\");\n        break;\n      }\n\n      if (len < p_rsp->attr_value.len) {\n        is_overflow = true;\n        log::verbose(\"multi read overflow available len={} val_len={}\", len, p_rsp->attr_value.len);\n      }\n\n      if (p_cmd->multi_req.variable_len) {\n        UINT16_TO_STREAM(p, (uint16_t)len);\n        p_buf->len += 2;\n      }\n\n      if (p_rsp->attr_value.handle == p_cmd->multi_req.handles[ii]) {\n        ARRAY_TO_STREAM(p, p_rsp->attr_value.value, (uint16_t)len);\n        p_buf->len += (uint16_t)len;\n      } else {\n        p_cmd->status = GATT_NOT_FOUND;\n        break;\n      }\n\n      if (is_overflow) {\n        break;\n      }\n\n    } else {\n      p_cmd->status = GATT_NOT_FOUND;\n      break;\n    }\n\n  } /* loop through all handles*/\n\n  /* Sanity check on the buffer length */\n  if (p_buf->len == 0) {\n    log::error(\"nothing found!!\");\n    p_cmd->status = GATT_NOT_FOUND;\n    osi_free(p_buf);\n    log::verbose(\"osi_free(p_buf)\");\n  } else if (p_cmd->p_rsp_msg != NULL) {\n    osi_free(p_buf);\n  } else {\n    p_cmd->p_rsp_msg = p_buf;\n  }\n}\n\n/*******************************************************************************\n *\n * Function         process_read_multi_rsp\n *\n * Description      This function check the read multiple response.\n *\n * Returns          bool    if all replies have been received\n *\n ******************************************************************************/\nstatic bool process_read_multi_rsp(tGATT_SR_CMD* p_cmd, tGATT_STATUS status, tGATTS_RSP* p_msg,\n                                   uint16_t mtu) {\n  log::verbose(\"status={} mtu={}\", status, mtu);\n\n  if (p_cmd->multi_rsp_q == NULL) {\n    p_cmd->multi_rsp_q = fixed_queue_new(SIZE_MAX);\n  }\n\n  /* Enqueue the response */\n  BT_HDR* p_buf = (BT_HDR*)osi_malloc(sizeof(tGATTS_RSP));\n  memcpy((void*)p_buf, (const void*)p_msg, sizeof(tGATTS_RSP));\n  fixed_queue_enqueue(p_cmd->multi_rsp_q, p_buf);\n\n  p_cmd->status = status;\n  if (status == GATT_SUCCESS) {\n    log::verbose(\"Multi read count={} num_hdls={} variable={}\",\n                 fixed_queue_length(p_cmd->multi_rsp_q), p_cmd->multi_req.num_handles,\n                 p_cmd->multi_req.variable_len);\n    /* Wait till we get all the responses */\n    if (fixed_queue_length(p_cmd->multi_rsp_q) == p_cmd->multi_req.num_handles) {\n      build_read_multi_rsp(p_cmd, mtu);\n      return true;\n    }\n  } else /* any handle read exception occurs, return error */\n  {\n    return true;\n  }\n\n  /* If here, still waiting */\n  return false;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_process_app_rsp\n *\n * Description      This function checks whether the response message from\n *                  application matches any pending request.\n *\n * Returns          void\n *\n ******************************************************************************/\ntGATT_STATUS gatt_sr_process_app_rsp(tGATT_TCB& tcb, tGATT_IF gatt_if, uint32_t /* trans_id */,\n                                     uint8_t op_code, tGATT_STATUS status, tGATTS_RSP* p_msg,\n                                     tGATT_SR_CMD* sr_res_p) {\n  tGATT_STATUS ret_code = GATT_SUCCESS;\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, sr_res_p->cid);\n\n  log::verbose(\"gatt_if={}\", gatt_if);\n\n  gatt_sr_update_cback_cnt(tcb, sr_res_p->cid, gatt_if, false, false);\n\n  if ((op_code == GATT_REQ_READ_MULTI) || (op_code == GATT_REQ_READ_MULTI_VAR)) {\n    /* If no error and still waiting, just return */\n    if (!process_read_multi_rsp(sr_res_p, status, p_msg, payload_size)) {\n      return GATT_SUCCESS;\n    }\n  } else {\n    if (op_code == GATT_REQ_PREPARE_WRITE && status == GATT_SUCCESS) {\n      gatt_sr_update_prep_cnt(tcb, gatt_if, true, false);\n    }\n\n    if (op_code == GATT_REQ_EXEC_WRITE && status != GATT_SUCCESS) {\n      gatt_sr_reset_cback_cnt(tcb, sr_res_p->cid);\n    }\n\n    sr_res_p->status = status;\n\n    if (gatt_sr_is_cback_cnt_zero(tcb) && status == GATT_SUCCESS) {\n      if (sr_res_p->p_rsp_msg == NULL) {\n        sr_res_p->p_rsp_msg =\n                attp_build_sr_msg(tcb, (uint8_t)(op_code + 1), (tGATT_SR_MSG*)p_msg, payload_size);\n      } else {\n        log::error(\"Exception!!! already has respond message\");\n      }\n    }\n  }\n  if (gatt_sr_is_cback_cnt_zero(tcb)) {\n    if ((sr_res_p->status == GATT_SUCCESS) && (sr_res_p->p_rsp_msg)) {\n      ret_code = attp_send_sr_msg(tcb, sr_res_p->cid, sr_res_p->p_rsp_msg);\n      sr_res_p->p_rsp_msg = NULL;\n    } else {\n      ret_code = gatt_send_error_rsp(tcb, sr_res_p->cid, status, op_code, sr_res_p->handle, false);\n    }\n\n    gatt_dequeue_sr_cmd(tcb, sr_res_p->cid);\n  }\n\n  log::verbose(\"ret_code={}\", ret_code);\n\n  return ret_code;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_exec_write_req\n *\n * Description      This function is called to process the execute write request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_exec_write_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code, uint16_t len,\n                                 uint8_t* p_data) {\n  uint8_t *p = p_data, flag, i = 0;\n  uint32_t trans_id = 0;\n  tGATT_IF gatt_if;\n  uint16_t conn_id;\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    log::verbose(\"Conformance tst: forced err rspv for Execute Write: error status={}\",\n                 gatt_cb.err_status);\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code, gatt_cb.handle, false);\n\n    return;\n  }\n#endif\n\n  if (len < sizeof(flag)) {\n    log::error(\"invalid length\");\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_EXEC_WRITE, 0, false);\n    return;\n  }\n\n  STREAM_TO_UINT8(flag, p);\n\n  /* mask the flag */\n  flag &= GATT_PREP_WRITE_EXEC;\n\n  /* no prep write is queued */\n  if (!gatt_sr_is_prep_cnt_zero(tcb)) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, 0);\n    gatt_sr_copy_prep_cnt_to_cback_cnt(tcb);\n\n    if (com::android::bluetooth::flags::gatt_client_dynamic_allocation()) {\n      auto prep_cnt_it = tcb.prep_cnt_map.begin();\n      while (prep_cnt_it != tcb.prep_cnt_map.end()) {\n        gatt_if = i;\n        conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_if);\n        tGATTS_DATA gatts_data;\n        gatts_data.exec_write = flag;\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_WRITE_EXEC, &gatts_data);\n        prep_cnt_it = tcb.prep_cnt_map.erase(prep_cnt_it);\n      }\n    } else {\n      for (i = 0; i < GATT_MAX_APPS; i++) {\n        if (tcb.prep_cnt[i]) {\n          gatt_if = (tGATT_IF)(i + 1);\n          conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_if);\n          tGATTS_DATA gatts_data;\n          gatts_data.exec_write = flag;\n          gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_WRITE_EXEC, &gatts_data);\n          tcb.prep_cnt[i] = 0;\n        }\n      }\n    }\n  } else /* nothing needs to be executed , send response now */\n  {\n    log::error(\"gatt_process_exec_write_req: no prepare write pending\");\n    gatt_send_error_rsp(tcb, cid, GATT_ERROR, GATT_REQ_EXEC_WRITE, 0, false);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_read_multi_req\n *\n * Description      This function is called to process the read multiple request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_read_multi_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code, uint16_t len,\n                                 uint8_t* p_data) {\n  uint32_t trans_id;\n  uint16_t handle = 0, ll = len;\n  uint8_t* p = p_data;\n  tGATT_STATUS err = GATT_SUCCESS;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n\n  log::verbose(\"\");\n\n  tGATT_READ_MULTI* multi_req = gatt_sr_get_read_multi(tcb, cid);\n  if (multi_req == nullptr) {\n    log::error(\"Could not proceed request. {}, 0x{:02x}\", tcb.peer_bda, cid);\n    return;\n  }\n  multi_req->num_handles = 0;\n  multi_req->variable_len = (op_code == GATT_REQ_READ_MULTI_VAR);\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    log::verbose(\"Conformance tst: forced err rspvofr ReadMultiple: error status={}\",\n                 gatt_cb.err_status);\n\n    STREAM_TO_UINT16(handle, p);\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code, handle, false);\n\n    return;\n  }\n#endif\n\n  while (ll >= 2 && multi_req->num_handles < GATT_MAX_READ_MULTI_HANDLES) {\n    STREAM_TO_UINT16(handle, p);\n\n    auto it = gatt_sr_find_i_rcb_by_handle(handle);\n    if (it != gatt_cb.srv_list_info->end()) {\n      multi_req->handles[multi_req->num_handles++] = handle;\n\n      /* check read permission */\n      err = gatts_read_attr_perm_check(it->p_db, false, handle, sec_flag, key_size);\n      if (err != GATT_SUCCESS) {\n        log::verbose(\"read permission denied : 0x{:02x}\", err);\n        break;\n      }\n    } else {\n      /* invalid handle */\n      err = GATT_INVALID_HANDLE;\n      break;\n    }\n    ll -= 2;\n  }\n\n  if (ll != 0) {\n    log::error(\"max attribute handle reached in ReadMultiple Request.\");\n  }\n\n  if (multi_req->num_handles == 0) {\n    err = GATT_INVALID_HANDLE;\n  }\n\n  if (err == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, multi_req->handles[0]);\n    if (trans_id != 0) {\n      tGATT_SR_CMD* sr_cmd_p = gatt_sr_get_cmd_by_cid(tcb, cid);\n      if (sr_cmd_p == nullptr) {\n        log::error(\"Could not send response on CID were request arrived. {}, 0x{:02x}\",\n                   tcb.peer_bda, cid);\n        return;\n      }\n      gatt_sr_reset_cback_cnt(tcb, cid); /* read multiple use multi_rsp_q's count*/\n\n      for (ll = 0; ll < multi_req->num_handles; ll++) {\n        tGATTS_RSP* p_msg = (tGATTS_RSP*)osi_calloc(sizeof(tGATTS_RSP));\n        handle = multi_req->handles[ll];\n        auto it = gatt_sr_find_i_rcb_by_handle(handle);\n\n        p_msg->attr_value.handle = handle;\n        err = gatts_read_attr_value_by_handle(tcb, cid, it->p_db, op_code, handle, 0,\n                                              p_msg->attr_value.value, &p_msg->attr_value.len,\n                                              GATT_MAX_ATTR_LEN, sec_flag, key_size, trans_id);\n\n        if (err == GATT_SUCCESS) {\n          gatt_sr_process_app_rsp(tcb, it->gatt_if, trans_id, op_code, GATT_SUCCESS, p_msg,\n                                  sr_cmd_p);\n        }\n        /* either not using or done using the buffer, release it now */\n        osi_free(p_msg);\n      }\n    } else {\n      err = GATT_NO_RESOURCES;\n    }\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (err != GATT_SUCCESS && err != GATT_PENDING && err != GATT_BUSY) {\n    gatt_send_error_rsp(tcb, cid, err, op_code, handle, false);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatt_build_primary_service_rsp\n *\n * Description      Primamry service request processed internally. Theretically\n *                  only deal with ReadByTypeValue and ReadByGroupType.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic tGATT_STATUS gatt_build_primary_service_rsp(BT_HDR* p_msg, tGATT_TCB& tcb, uint16_t cid,\n                                                   uint8_t op_code, uint16_t s_hdl, uint16_t e_hdl,\n                                                   uint8_t* /* p_data */, const Uuid& value) {\n  tGATT_STATUS status = GATT_NOT_FOUND;\n  uint8_t handle_len = 4;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl < s_hdl || el.s_hdl > e_hdl || el.type != GATT_UUID_PRI_SERVICE) {\n      continue;\n    }\n\n    Uuid* p_uuid = gatts_get_service_uuid(el.p_db);\n    if (!p_uuid) {\n      continue;\n    }\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n      handle_len = 4 + gatt_build_uuid_to_stream_len(*p_uuid);\n    }\n\n    /* get the length byte in the repsonse */\n    if (p_msg->offset == 0) {\n      *p++ = op_code + 1;\n      p_msg->len++;\n      p_msg->offset = handle_len;\n\n      if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n        *p++ = (uint8_t)p_msg->offset; /* length byte */\n        p_msg->len++;\n      }\n    }\n\n    if (p_msg->len + p_msg->offset > payload_size || handle_len != p_msg->offset) {\n      break;\n    }\n\n    if (op_code == GATT_REQ_FIND_TYPE_VALUE && value != *p_uuid) {\n      continue;\n    }\n\n    UINT16_TO_STREAM(p, el.s_hdl);\n\n    if (gatt_cb.last_service_handle && gatt_cb.last_service_handle == el.s_hdl) {\n      log::verbose(\"Use 0xFFFF for the last primary attribute\");\n      /* see GATT ERRATA 4065, 4063, ATT ERRATA 4062 */\n      UINT16_TO_STREAM(p, 0xFFFF);\n    } else {\n      UINT16_TO_STREAM(p, el.e_hdl);\n    }\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n      gatt_build_uuid_to_stream(&p, *p_uuid);\n    }\n\n    status = GATT_SUCCESS;\n    p_msg->len += p_msg->offset;\n  }\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  return status;\n}\n\n/**\n * fill the find information response information in the given buffer.\n *\n * Returns          true: if data filled sucessfully.\n *                  false: packet full, or format mismatch.\n */\nstatic tGATT_STATUS gatt_build_find_info_rsp(tGATT_SRV_LIST_ELEM& el, BT_HDR* p_msg, uint16_t& len,\n                                             uint16_t s_hdl, uint16_t e_hdl) {\n  uint8_t info_pair_len[2] = {4, 18};\n\n  if (!el.p_db) {\n    return GATT_NOT_FOUND;\n  }\n\n  /* check the attribute database */\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET + p_msg->len;\n\n  tGATT_STATUS status = GATT_NOT_FOUND;\n  for (auto& attr : el.p_db->attr_list) {\n    if (attr.handle > e_hdl) {\n      break;\n    }\n\n    if (attr.handle < s_hdl) {\n      continue;\n    }\n\n    uint8_t uuid_len = attr.uuid.GetShortestRepresentationSize();\n    if (p_msg->offset == 0) {\n      p_msg->offset =\n              (uuid_len == Uuid::kNumBytes16) ? GATT_INFO_TYPE_PAIR_16 : GATT_INFO_TYPE_PAIR_128;\n    }\n\n    if (len < info_pair_len[p_msg->offset - 1]) {\n      return GATT_NO_RESOURCES;\n    }\n\n    if (p_msg->offset == GATT_INFO_TYPE_PAIR_16 && uuid_len == Uuid::kNumBytes16) {\n      UINT16_TO_STREAM(p, attr.handle);\n      UINT16_TO_STREAM(p, attr.uuid.As16Bit());\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 && uuid_len == Uuid::kNumBytes128) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 && uuid_len == Uuid::kNumBytes32) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else {\n      log::error(\"format mismatch\");\n      return GATT_NO_RESOURCES;\n      /* format mismatch */\n    }\n    p_msg->len += info_pair_len[p_msg->offset - 1];\n    len -= info_pair_len[p_msg->offset - 1];\n    status = GATT_SUCCESS;\n  }\n\n  return status;\n}\n\nstatic tGATT_STATUS read_handles(uint16_t& len, uint8_t*& p, uint16_t& s_hdl, uint16_t& e_hdl) {\n  if (len < 4) {\n    return GATT_INVALID_PDU;\n  }\n\n  /* obtain starting handle, and ending handle */\n  STREAM_TO_UINT16(s_hdl, p);\n  STREAM_TO_UINT16(e_hdl, p);\n  len -= 4;\n\n  if (s_hdl > e_hdl || !GATT_HANDLE_IS_VALID(s_hdl) || !GATT_HANDLE_IS_VALID(e_hdl)) {\n    return GATT_INVALID_HANDLE;\n  }\n\n  return GATT_SUCCESS;\n}\n\nstatic tGATT_STATUS gatts_validate_packet_format(uint8_t op_code, uint16_t& len, uint8_t*& p,\n                                                 Uuid* p_uuid, uint16_t& s_hdl, uint16_t& e_hdl) {\n  tGATT_STATUS ret = read_handles(len, p, s_hdl, e_hdl);\n  if (ret != GATT_SUCCESS) {\n    return ret;\n  }\n\n  if (len < 2) {\n    return GATT_INVALID_PDU;\n  }\n\n  /* parse uuid now */\n  log::assert_that(p_uuid != nullptr, \"assert failed: p_uuid != nullptr\");\n  uint16_t uuid_len = (op_code == GATT_REQ_FIND_TYPE_VALUE) ? 2 : len;\n  if (!gatt_parse_uuid_from_cmd(p_uuid, uuid_len, &p)) {\n    log::verbose(\"Bad UUID\");\n    return GATT_INVALID_PDU;\n  }\n\n  len -= uuid_len;\n  return GATT_SUCCESS;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_primary_service_req\n *\n * Description      Process ReadByGroupType/ReadByTypeValue request, for\n *                  discovering all primary services or discover primary service\n *                  by UUID request.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code, uint16_t len,\n                                       uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  Uuid uuid = Uuid::kEmpty;\n\n  uint8_t reason = gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  if (uuid != Uuid::From16Bit(GATT_UUID_PRI_SERVICE)) {\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n      gatt_send_error_rsp(tcb, cid, GATT_UNSUPPORT_GRP_TYPE, op_code, s_hdl, false);\n      log::verbose(\"unexpected ReadByGrpType Group: {}\", uuid.ToString());\n      return;\n    }\n\n    // we do not support ReadByTypeValue with any non-primamry_service type\n    gatt_send_error_rsp(tcb, cid, GATT_NOT_FOUND, op_code, s_hdl, false);\n    log::verbose(\"unexpected ReadByTypeValue type: {}\", uuid.ToString());\n    return;\n  }\n\n  // TODO: we assume theh value is UUID, there is no such requirement in spec\n  Uuid value = Uuid::kEmpty;\n  if (op_code == GATT_REQ_FIND_TYPE_VALUE) {\n    if (!gatt_parse_uuid_from_cmd(&value, len, &p_data)) {\n      gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, s_hdl, false);\n    }\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  uint16_t msg_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n  reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl, e_hdl, p_data, value);\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_find_info\n *\n * Description      process find information request, for discover character\n *                  descriptors.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code, uint16_t len,\n                                    uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  uint8_t reason = read_handles(len, p_data, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  uint16_t buf_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n  reason = GATT_NOT_FOUND;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n  *p++ = op_code + 1;\n  p_msg->len = 2;\n\n  buf_len = payload_size - 2;\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl <= e_hdl && el.e_hdl >= s_hdl) {\n      reason = gatt_build_find_info_rsp(el, p_msg, buf_len, s_hdl, e_hdl);\n      if (reason == GATT_NO_RESOURCES) {\n        reason = GATT_SUCCESS;\n        break;\n      }\n    }\n  }\n\n  *p = (uint8_t)p_msg->offset;\n\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n  } else {\n    attp_send_sr_msg(tcb, cid, p_msg);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_mtu_req\n *\n * Description      This function is called to process excahnge MTU request.\n *                  Only used on LE.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_mtu_req(tGATT_TCB& tcb, uint16_t cid, uint16_t len, uint8_t* p_data) {\n  /* BR/EDR conenction, send error response */\n  if (cid != L2CAP_ATT_CID) {\n    gatt_send_error_rsp(tcb, cid, GATT_REQ_NOT_SUPPORTED, GATT_REQ_MTU, 0, false);\n    return;\n  }\n\n  if (len < GATT_MTU_REQ_MIN_LEN) {\n    log::error(\"invalid MTU request PDU received.\");\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_MTU, 0, false);\n    return;\n  }\n\n  tGATT_SR_MSG gatt_sr_msg;\n\n  uint16_t mtu = 0;\n  uint8_t* p = p_data;\n  STREAM_TO_UINT16(mtu, p);\n  /* mtu must be greater than default MTU which is 23/48 */\n  if (mtu < GATT_DEF_BLE_MTU_SIZE) {\n    tcb.payload_size = GATT_DEF_BLE_MTU_SIZE;\n  } else {\n    tcb.payload_size = std::min(mtu, (uint16_t)(gatt_get_local_mtu()));\n  }\n\n  /* Always say to remote our default MTU. */\n  gatt_sr_msg.mtu = gatt_get_local_mtu();\n\n  log::info(\"MTU {} request from remote ({}), resulted MTU {}\", mtu, tcb.peer_bda,\n            tcb.payload_size);\n\n  if (get_btm_client_interface().ble.BTM_SetBleDataLength(\n              tcb.peer_bda, tcb.payload_size + L2CAP_PKT_OVERHEAD) != tBTM_STATUS::BTM_SUCCESS) {\n    log::warn(\"Unable to set BLE data length peer:{} mtu:{}\", tcb.peer_bda,\n              tcb.payload_size + L2CAP_PKT_OVERHEAD);\n  }\n\n  BT_HDR* p_buf = attp_build_sr_msg(tcb, GATT_RSP_MTU, &gatt_sr_msg, GATT_DEF_BLE_MTU_SIZE);\n  attp_send_sr_msg(tcb, cid, p_buf);\n\n  bluetooth::shim::arbiter::GetArbiter().OnIncomingMtuReq(tcb.tcb_idx, tcb.payload_size);\n\n  tGATTS_DATA gatts_data;\n  gatts_data.mtu = tcb.payload_size;\n  /* Notify all registered application with new MTU size. Use a transaction ID */\n  /* of 0, as no response is allowed from applications */\n  if (com::android::bluetooth::flags::gatt_client_dynamic_allocation()) {\n    for (auto& [i, p_reg] : gatt_cb.cl_rcb_map) {\n      if (p_reg->in_use) {\n        uint16_t conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, p_reg->gatt_if);\n        gatt_sr_send_req_callback(conn_id, 0, GATTS_REQ_TYPE_MTU, &gatts_data);\n      }\n    }\n  } else {\n    for (int i = 0; i < GATT_MAX_APPS; i++) {\n      if (gatt_cb.cl_rcb[i].in_use) {\n        uint16_t conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_cb.cl_rcb[i].gatt_if);\n        gatt_sr_send_req_callback(conn_id, 0, GATTS_REQ_TYPE_MTU, &gatts_data);\n      }\n    }\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_read_by_type_req\n *\n * Description      process Read By type request.\n *                  This PDU can be used to perform:\n *                  - read characteristic value\n *                  - read characteristic descriptor value\n *                  - discover characteristic\n *                  - discover characteristic by UUID\n *                  - relationship discovery\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                           uint16_t len, uint8_t* p_data) {\n  Uuid uuid = Uuid::kEmpty;\n  uint16_t s_hdl = 0, e_hdl = 0, err_hdl = 0;\n  tGATT_STATUS reason = gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    log::verbose(\"Conformance tst: forced err rsp for ReadByType: error status={}\",\n                 gatt_cb.err_status);\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code, s_hdl, false);\n\n    return;\n  }\n#endif\n\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  *p++ = op_code + 1;\n  /* reserve length byte */\n  p_msg->len = 2;\n  uint16_t buf_len = payload_size - 2;\n\n  reason = GATT_NOT_FOUND;\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl <= e_hdl && el.e_hdl >= s_hdl) {\n      tGATT_SEC_FLAG sec_flag;\n      uint8_t key_size;\n      gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n      tGATT_STATUS ret =\n              gatts_db_read_attr_value_by_type(tcb, cid, el.p_db, op_code, p_msg, s_hdl, e_hdl,\n                                               uuid, &buf_len, sec_flag, key_size, 0, &err_hdl);\n      if (ret != GATT_NOT_FOUND) {\n        reason = ret;\n        if (ret == GATT_NO_RESOURCES) {\n          reason = GATT_SUCCESS;\n        }\n      }\n\n      if (ret != GATT_SUCCESS && ret != GATT_NOT_FOUND) {\n        s_hdl = err_hdl;\n        break;\n      }\n    }\n  }\n  *p = (uint8_t)p_msg->offset;\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n\n    /* in theroy BUSY is not possible(should already been checked), protected\n     * check */\n    if (reason != GATT_PENDING && reason != GATT_BUSY) {\n      gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    }\n\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/**\n * This function is called to process the write request from client.\n */\nstatic void gatts_process_write_req(tGATT_TCB& tcb, uint16_t cid, tGATT_SRV_LIST_ELEM& el,\n                                    uint16_t handle, uint8_t op_code, uint16_t len, uint8_t* p_data,\n                                    bt_gatt_db_attribute_type_t gatt_type) {\n  tGATTS_DATA sr_data;\n  uint32_t trans_id;\n  tGATT_STATUS status;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size, *p = p_data;\n  uint16_t conn_id;\n\n  memset(&sr_data, 0, sizeof(tGATTS_DATA));\n\n  switch (op_code) {\n    case GATT_REQ_PREPARE_WRITE:\n      if (len < 2 || p == nullptr) {\n        log::error(\"Prepare write request was invalid - missing offset, sending error response\");\n        gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, handle, false);\n        return;\n      }\n      sr_data.write_req.is_prep = true;\n      STREAM_TO_UINT16(sr_data.write_req.offset, p);\n      len -= 2;\n      FALLTHROUGH_INTENDED; /* FALLTHROUGH */\n    case GATT_SIGN_CMD_WRITE:\n      if (op_code == GATT_SIGN_CMD_WRITE) {\n        log::verbose(\"Write CMD with data sigining\");\n        len -= GATT_AUTH_SIGN_LEN;\n      }\n      FALLTHROUGH_INTENDED; /* FALLTHROUGH */\n    case GATT_CMD_WRITE:\n    case GATT_REQ_WRITE:\n      if (op_code == GATT_REQ_WRITE || op_code == GATT_REQ_PREPARE_WRITE) {\n        sr_data.write_req.need_rsp = true;\n      }\n      sr_data.write_req.handle = handle;\n      if (len > GATT_MAX_ATTR_LEN) {\n        len = GATT_MAX_ATTR_LEN;\n      }\n      sr_data.write_req.len = len;\n      if (len != 0 && p != nullptr) {\n        memcpy(sr_data.write_req.value, p, len);\n      }\n      break;\n  }\n\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n  status = gatts_write_attr_perm_check(el.p_db, op_code, handle, sr_data.write_req.offset, p, len,\n                                       sec_flag, key_size);\n\n  if (status == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, handle);\n    if (trans_id != 0) {\n      conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, el.gatt_if);\n\n      uint8_t opcode = 0;\n      if (gatt_type == BTGATT_DB_DESCRIPTOR) {\n        opcode = GATTS_REQ_TYPE_WRITE_DESCRIPTOR;\n      } else if (gatt_type == BTGATT_DB_CHARACTERISTIC) {\n        opcode = GATTS_REQ_TYPE_WRITE_CHARACTERISTIC;\n      } else {\n        log::error(\n                \"Attempt to write attribute that's not tied with \"\n                \"characteristic or descriptor value.\");\n        status = GATT_ERROR;\n      }\n\n      if (opcode) {\n        gatt_sr_send_req_callback(conn_id, trans_id, opcode, &sr_data);\n        status = GATT_PENDING;\n      }\n    } else {\n      log::error(\"max pending command, send error\");\n      status = GATT_BUSY; /* max pending command, application error */\n    }\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (status != GATT_PENDING && status != GATT_BUSY &&\n      (op_code == GATT_REQ_PREPARE_WRITE || op_code == GATT_REQ_WRITE)) {\n    gatt_send_error_rsp(tcb, cid, status, op_code, handle, false);\n  }\n  return;\n}\n\n/**\n * This function is called to process the read request from client.\n */\nstatic void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid, tGATT_SRV_LIST_ELEM& el,\n                                   uint8_t op_code, uint16_t handle, uint16_t len,\n                                   uint8_t* p_data) {\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  uint16_t offset = 0;\n\n  if (op_code == GATT_REQ_READ_BLOB && len < sizeof(uint16_t)) {\n    /* Error: packet length is too short */\n    log::error(\"packet length={} too short. min={}\", len, sizeof(uint16_t));\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, 0, false);\n    return;\n  }\n\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n\n  if (op_code == GATT_REQ_READ_BLOB) {\n    STREAM_TO_UINT16(offset, p_data);\n  }\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n  *p++ = op_code + 1;\n  p_msg->len = 1;\n  buf_len = payload_size - 1;\n\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n  uint16_t value_len = 0;\n  tGATT_STATUS reason =\n          gatts_read_attr_value_by_handle(tcb, cid, el.p_db, op_code, handle, offset, p, &value_len,\n                                          (uint16_t)buf_len, sec_flag, key_size, 0);\n  p_msg->len += value_len;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n\n    /* in theory BUSY is not possible(should already been checked), protected\n     * check */\n    if (reason != GATT_PENDING && reason != GATT_BUSY) {\n      gatt_send_error_rsp(tcb, cid, reason, op_code, handle, false);\n    }\n\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_attribute_req\n *\n * Description      This function is called to process the per attribute handle\n *                  request from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_attribute_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code, uint16_t len,\n                                 uint8_t* p_data) {\n  uint16_t handle = 0;\n  uint8_t* p = p_data;\n  tGATT_STATUS status = GATT_INVALID_HANDLE;\n\n  if (len < 2) {\n    log::error(\"Illegal PDU length, discard request\");\n    status = GATT_INVALID_PDU;\n  } else {\n    STREAM_TO_UINT16(handle, p);\n    len -= 2;\n  }\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  gatt_cb.handle = handle;\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    log::verbose(\"Conformance tst: forced err rsp: error status={}\", gatt_cb.err_status);\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, cid, gatt_cb.req_op_code, handle, false);\n\n    return;\n  }\n#endif\n\n  if (GATT_HANDLE_IS_VALID(handle)) {\n    for (auto& el : *gatt_cb.srv_list_info) {\n      if (el.s_hdl <= handle && el.e_hdl >= handle) {\n        for (const auto& attr : el.p_db->attr_list) {\n          if (attr.handle == handle) {\n            switch (op_code) {\n              case GATT_REQ_READ: /* read char/char descriptor value */\n              case GATT_REQ_READ_BLOB:\n                gatts_process_read_req(tcb, cid, el, op_code, handle, len, p);\n                break;\n\n              case GATT_REQ_WRITE: /* write char/char descriptor value */\n              case GATT_CMD_WRITE:\n              case GATT_SIGN_CMD_WRITE:\n              case GATT_REQ_PREPARE_WRITE:\n                gatts_process_write_req(tcb, cid, el, handle, op_code, len, p, attr.gatt_type);\n                break;\n              default:\n                break;\n            }\n            status = GATT_SUCCESS;\n            break;\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  if (status != GATT_SUCCESS && op_code != GATT_CMD_WRITE && op_code != GATT_SIGN_CMD_WRITE) {\n    gatt_send_error_rsp(tcb, cid, status, op_code, handle, false);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_proc_srv_chg_ind_ack\n *\n * Description      This function process the service changed indicaiton ACK\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_proc_srv_chg_ind_ack(tGATT_TCB tcb) {\n  tGATTS_SRV_CHG_REQ req;\n  tGATTS_SRV_CHG* p_buf = NULL;\n\n  log::verbose(\"\");\n\n  p_buf = gatt_is_bda_in_the_srv_chg_clt_list(tcb.peer_bda);\n  if (p_buf != NULL) {\n    log::verbose(\"NV update set srv chg = false\");\n    p_buf->srv_changed = false;\n    memcpy(&req.srv_chg, p_buf, sizeof(tGATTS_SRV_CHG));\n    if (gatt_cb.cb_info.p_srv_chg_callback) {\n      (*gatt_cb.cb_info.p_srv_chg_callback)(GATTS_SRV_CHG_CMD_UPDATE_CLIENT, &req, NULL);\n    }\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_chk_pending_ind\n *\n * Description      This function check any pending indication needs to be sent\n *                  if there is a pending indication then sent the indication\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_chk_pending_ind(tGATT_TCB& tcb) {\n  log::verbose(\"\");\n\n  tGATT_VALUE* p_buf = (tGATT_VALUE*)fixed_queue_try_peek_first(tcb.pending_ind_q);\n  if (p_buf != NULL) {\n    if (GATTS_HandleValueIndication(p_buf->conn_id, p_buf->handle, p_buf->len, p_buf->value) !=\n        GATT_SUCCESS) {\n      log::warn(\"Unable to send GATT server handle value conn_id:{}\", p_buf->conn_id);\n    }\n    osi_free(fixed_queue_try_remove_from_queue(tcb.pending_ind_q, p_buf));\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_proc_ind_ack\n *\n * Description      This function processes the Indication ack\n *\n * Returns          true continue to process the indication ack by the\n *                  application if the ACK is not a Service Changed Indication\n *\n ******************************************************************************/\nstatic bool gatts_proc_ind_ack(tGATT_TCB& tcb, uint16_t ack_handle) {\n  bool continue_processing = true;\n\n  log::verbose(\"ack handle={}\", ack_handle);\n\n  if (ack_handle == gatt_cb.handle_of_h_r) {\n    gatts_proc_srv_chg_ind_ack(tcb);\n    /* there is no need to inform the application since srv chg is handled\n     * internally by GATT */\n    continue_processing = false;\n\n    // After receiving ack of svc_chg_ind, reset client status\n    gatt_sr_update_cl_status(tcb, /* chg_aware= */ true);\n  }\n\n  gatts_chk_pending_ind(tcb);\n  return continue_processing;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_value_conf\n *\n * Description      This function is called to process the handle value\n *                  confirmation.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_value_conf(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code) {\n  uint16_t handle;\n\n  if (!gatt_tcb_find_indicate_handle(tcb, cid, &handle)) {\n    log::error(\"unexpected handle value confirmation\");\n    return;\n  }\n\n  gatt_stop_conf_timer(tcb, cid);\n\n  bool continue_processing = gatts_proc_ind_ack(tcb, handle);\n\n  if (continue_processing) {\n    tGATTS_DATA gatts_data;\n    gatts_data.handle = handle;\n    for (auto& el : *gatt_cb.srv_list_info) {\n      if (el.s_hdl <= handle && el.e_hdl >= handle) {\n        uint32_t trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, handle);\n        uint16_t conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, el.gatt_if);\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_CONF, &gatts_data);\n      }\n    }\n  }\n}\n\nstatic bool gatts_process_db_out_of_sync(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                         uint16_t len, uint8_t* p_data) {\n  if (gatt_sr_is_cl_change_aware(tcb)) {\n    return false;\n  }\n\n  // default value\n  bool should_ignore = true;\n  bool should_rsp = true;\n\n  switch (op_code) {\n    case GATT_REQ_READ_BY_TYPE: {\n      // Check if read database hash by UUID\n      Uuid uuid = Uuid::kEmpty;\n      uint16_t s_hdl = 0, e_hdl = 0;\n      uint16_t db_hash_handle = gatt_cb.handle_of_database_hash;\n      tGATT_STATUS reason = gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n      if (reason == GATT_SUCCESS && (s_hdl <= db_hash_handle && db_hash_handle <= e_hdl) &&\n          (uuid == Uuid::From16Bit(GATT_UUID_DATABASE_HASH))) {\n        should_ignore = false;\n      }\n\n    } break;\n    case GATT_REQ_READ: {\n      // Check if read database hash by handle\n      uint16_t handle = 0;\n      uint8_t* p = p_data;\n      tGATT_STATUS status = GATT_SUCCESS;\n\n      if (len < 2) {\n        status = GATT_INVALID_PDU;\n      } else {\n        STREAM_TO_UINT16(handle, p);\n        len -= 2;\n      }\n\n      if (status == GATT_SUCCESS && handle == gatt_cb.handle_of_database_hash) {\n        should_ignore = false;\n      }\n\n    } break;\n    case GATT_REQ_READ_BY_GRP_TYPE: /* discover primary services */\n    case GATT_REQ_FIND_TYPE_VALUE:  /* discover service by UUID */\n    case GATT_REQ_FIND_INFO:        /* discover char descrptor */\n    case GATT_REQ_READ_BLOB:        /* read long char */\n    case GATT_REQ_READ_MULTI:       /* read multi char*/\n    case GATT_REQ_WRITE:            /* write char/char descriptor value */\n    case GATT_REQ_PREPARE_WRITE:    /* write long char */\n      // Use default value\n      break;\n    case GATT_CMD_WRITE:      /* cmd */\n    case GATT_SIGN_CMD_WRITE: /* sign cmd */\n      should_rsp = false;\n      break;\n    case GATT_REQ_MTU:           /* configure mtu */\n    case GATT_REQ_EXEC_WRITE:    /* execute write */\n    case GATT_HANDLE_VALUE_CONF: /* confirm for indication */\n    default:\n      should_ignore = false;\n  }\n\n  if (should_ignore) {\n    if (should_rsp) {\n      gatt_send_error_rsp(tcb, cid, GATT_DATABASE_OUT_OF_SYNC, op_code, 0x0000, false);\n    }\n    log::info(\"database out of sync, device={}, op_code=0x{:x}, should_rsp={}\", tcb.peer_bda,\n              (uint16_t)op_code, should_rsp);\n    gatt_sr_update_cl_status(tcb, /* chg_aware= */ should_rsp);\n  }\n\n  return should_ignore;\n}\n\n/** This function is called to handle the client requests to server */\nvoid gatt_server_handle_client_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code, uint16_t len,\n                                   uint8_t* p_data) {\n  /* there is pending command, discard this one */\n  if (!gatt_sr_cmd_empty(tcb, cid) && op_code != GATT_HANDLE_VALUE_CONF) {\n    return;\n  }\n\n  /* the size of the message may not be bigger than the local max PDU size*/\n  /* The message has to be smaller than the agreed MTU, len does not include op\n   * code */\n\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n  if (len >= payload_size) {\n    log::error(\"server receive invalid PDU size:{} pdu size:{}\", len + 1, payload_size);\n    /* for invalid request expecting response, send it now */\n    if (op_code != GATT_CMD_WRITE && op_code != GATT_SIGN_CMD_WRITE &&\n        op_code != GATT_HANDLE_VALUE_CONF) {\n      gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, 0, false);\n    }\n    /* otherwise, ignore the pkt */\n  } else {\n    // handle database out of sync\n    if (gatts_process_db_out_of_sync(tcb, cid, op_code, len, p_data)) {\n      return;\n    }\n\n    switch (op_code) {\n      case GATT_REQ_READ_BY_GRP_TYPE: /* discover primary services */\n      case GATT_REQ_FIND_TYPE_VALUE:  /* discover service by UUID */\n        gatts_process_primary_service_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_FIND_INFO: /* discover char descrptor */\n        gatts_process_find_info(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ_BY_TYPE: /* read characteristic value, char descriptor\n                                     value */\n        /* discover characteristic, discover char by UUID */\n        gatts_process_read_by_type_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ: /* read char/char descriptor value */\n      case GATT_REQ_READ_BLOB:\n      case GATT_REQ_WRITE: /* write char/char descriptor value */\n      case GATT_CMD_WRITE:\n      case GATT_SIGN_CMD_WRITE:\n      case GATT_REQ_PREPARE_WRITE:\n        gatts_process_attribute_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_HANDLE_VALUE_CONF:\n        gatts_process_value_conf(tcb, cid, op_code);\n        break;\n\n      case GATT_REQ_MTU:\n        gatts_process_mtu_req(tcb, cid, len, p_data);\n        break;\n\n      case GATT_REQ_EXEC_WRITE:\n        gatt_process_exec_write_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ_MULTI:\n      case GATT_REQ_READ_MULTI_VAR:\n        gatt_process_read_multi_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      default:\n        break;\n    }\n  }\n}\n```",
                        "downstream_file_content": "```cc\n/******************************************************************************\n *\n *  Copyright 2008-2012 Broadcom Corporation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at:\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n ******************************************************************************/\n\n/******************************************************************************\n *\n *  this file contains the GATT server functions\n *\n ******************************************************************************/\n#include <algorithm>\n#include <string.h>\n\n#include \"bt_target.h\"\n#include \"gatt_int.h\"\n#include \"l2c_api.h\"\n#include \"osi/include/allocator.h\"\n#include \"osi/include/log.h\"\n#include \"osi/include/osi.h\"\n#include \"stack/eatt/eatt.h\"\n#include \"stack/include/bt_hdr.h\"\n#include \"stack/include/bt_types.h\"\n#include \"stack/l2cap/l2c_int.h\"\n#include \"types/bluetooth/uuid.h\"\n#include <base/logging.h>\n\n#define GATT_MTU_REQ_MIN_LEN 2\n#define L2CAP_PKT_OVERHEAD 4\n\nusing base::StringPrintf;\nusing bluetooth::Uuid;\nusing bluetooth::eatt::EattExtension;\nusing bluetooth::eatt::EattChannel;\n\n/*******************************************************************************\n *\n * Function         gatt_sr_enqueue_cmd\n *\n * Description      This function enqueue the request from client which needs a\n *                  application response, and update the transaction ID.\n *\n * Returns          void\n *\n ******************************************************************************/\nuint32_t gatt_sr_enqueue_cmd(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                             uint16_t handle) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel =\n        EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  uint32_t trans_id = 0;\n\n  p_cmd->cid = cid;\n\n  if ((p_cmd->op_code == 0) ||\n      (op_code == GATT_HANDLE_VALUE_CONF)) /* no pending request */\n  {\n    if (op_code == GATT_CMD_WRITE || op_code == GATT_SIGN_CMD_WRITE ||\n        op_code == GATT_REQ_MTU || op_code == GATT_HANDLE_VALUE_CONF) {\n      trans_id = ++tcb.trans_id;\n    } else {\n      p_cmd->trans_id = ++tcb.trans_id;\n      p_cmd->op_code = op_code;\n      p_cmd->handle = handle;\n      p_cmd->status = GATT_NOT_FOUND;\n      tcb.trans_id %= GATT_TRANS_ID_MAX;\n      trans_id = p_cmd->trans_id;\n    }\n  }\n\n  return trans_id;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_cmd_empty\n *\n * Description      This function checks if the server command queue is empty.\n *\n * Returns          true if empty, false if there is pending command.\n *\n ******************************************************************************/\nbool gatt_sr_cmd_empty(tGATT_TCB& tcb, uint16_t cid) {\n  if (cid == tcb.att_lcid) return (tcb.sr_cmd.op_code == 0);\n\n  EattChannel* channel =\n      EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n\n  return (channel->server_outstanding_cmd_.op_code == 0);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_dequeue_sr_cmd\n *\n * Description      This function dequeue the request from command queue.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_dequeue_sr_cmd(tGATT_TCB& tcb, uint16_t cid) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel =\n        EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  /* Double check in case any buffers are queued */\n  VLOG(1) << \"gatt_dequeue_sr_cmd cid: \" << loghex(cid);\n  if (p_cmd->p_rsp_msg)\n    LOG(ERROR) << \"free tcb.sr_cmd.p_rsp_msg = \"\n               << p_cmd->p_rsp_msg;\n  osi_free_and_reset((void**)&p_cmd->p_rsp_msg);\n\n  while (!fixed_queue_is_empty(p_cmd->multi_rsp_q))\n    osi_free(fixed_queue_try_dequeue(p_cmd->multi_rsp_q));\n  fixed_queue_free(p_cmd->multi_rsp_q, NULL);\n  memset(p_cmd, 0, sizeof(tGATT_SR_CMD));\n}\n\nstatic void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) {\n  uint16_t ii;\n  size_t total_len, len;\n  uint8_t* p;\n  bool is_overflow = false;\n\n  // We need at least one extra byte for the opcode\n  if (mtu == 0) {\n    LOG(ERROR) << \"Invalid MTU\";\n    p_cmd->status = GATT_ILLEGAL_PARAMETER;\n    return;\n  }\n\n  len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu;\n  BT_HDR* p_buf = (BT_HDR*)osi_calloc(len);\n  p_buf->offset = L2CAP_MIN_OFFSET;\n  p = (uint8_t*)(p_buf + 1) + p_buf->offset;\n\n  /* First byte in the response is the opcode */\n  if (p_cmd->multi_req.variable_len)\n    *p++ = GATT_RSP_READ_MULTI_VAR;\n  else\n    *p++ = GATT_RSP_READ_MULTI;\n\n  p_buf->len = 1;\n\n  /* Now walk through the buffers putting the data into the response in order\n   */\n  list_t* list = NULL;\n  const list_node_t* node = NULL;\n  if (!fixed_queue_is_empty(p_cmd->multi_rsp_q))\n    list = fixed_queue_get_list(p_cmd->multi_rsp_q);\n  for (ii = 0; ii < p_cmd->multi_req.num_handles; ii++) {\n    tGATTS_RSP* p_rsp = NULL;\n\n    if (list != NULL) {\n      if (ii == 0)\n        node = list_begin(list);\n      else\n        node = list_next(node);\n      if (node != list_end(list)) p_rsp = (tGATTS_RSP*)list_node(node);\n    }\n\n    if (p_rsp != NULL) {\n      total_len = p_buf->len;\n      if (p_cmd->multi_req.variable_len) {\n        total_len += 2;\n      }\n\n      if (total_len > mtu) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      len = std::min((size_t) p_rsp->attr_value.len, mtu - total_len);\n\n      if (total_len == mtu && p_rsp->attr_value.len > 0) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      if (len < p_rsp->attr_value.len) {\n        is_overflow = true;\n        VLOG(1) << StringPrintf(\n            \"multi read overflow available len=%zu val_len=%d\", len,\n            p_rsp->attr_value.len);\n      }\n\n      if (p_cmd->multi_req.variable_len) {\n        UINT16_TO_STREAM(p, (uint16_t) len);\n        p_buf->len += 2;\n      }\n\n      if (p_rsp->attr_value.handle == p_cmd->multi_req.handles[ii]) {\n        ARRAY_TO_STREAM(p, p_rsp->attr_value.value, (uint16_t) len);\n        p_buf->len += (uint16_t) len;\n      } else {\n        p_cmd->status = GATT_NOT_FOUND;\n        break;\n      }\n\n      if (is_overflow) break;\n\n    } else {\n      p_cmd->status = GATT_NOT_FOUND;\n      break;\n    }\n\n  } /* loop through all handles*/\n\n  /* Sanity check on the buffer length */\n  if (p_buf->len == 0) {\n    LOG(ERROR) << __func__ << \" nothing found!!\";\n    p_cmd->status = GATT_NOT_FOUND;\n    osi_free(p_buf);\n    VLOG(1) << __func__ << \"osi_free(p_buf)\";\n  } else if (p_cmd->p_rsp_msg != NULL) {\n    osi_free(p_buf);\n  } else {\n    p_cmd->p_rsp_msg = p_buf;\n  }\n}\n\n/*******************************************************************************\n *\n * Function         process_read_multi_rsp\n *\n * Description      This function check the read multiple response.\n *\n * Returns          bool    if all replies have been received\n *\n ******************************************************************************/\nstatic bool process_read_multi_rsp(tGATT_SR_CMD* p_cmd, tGATT_STATUS status,\n                                   tGATTS_RSP* p_msg, uint16_t mtu) {\n  VLOG(1) << StringPrintf(\"%s status=%d mtu=%d\", __func__, status, mtu);\n\n  if (p_cmd->multi_rsp_q == NULL)\n    p_cmd->multi_rsp_q = fixed_queue_new(SIZE_MAX);\n\n  /* Enqueue the response */\n  BT_HDR* p_buf = (BT_HDR*)osi_malloc(sizeof(tGATTS_RSP));\n  memcpy((void*)p_buf, (const void*)p_msg, sizeof(tGATTS_RSP));\n  fixed_queue_enqueue(p_cmd->multi_rsp_q, p_buf);\n\n  p_cmd->status = status;\n  if (status == GATT_SUCCESS) {\n    VLOG(1) << \"Multi read count=\" << fixed_queue_length(p_cmd->multi_rsp_q)\n            << \" num_hdls=\" << p_cmd->multi_req.num_handles\n            << \" variable=\" << p_cmd->multi_req.variable_len;\n    /* Wait till we get all the responses */\n    if (fixed_queue_length(p_cmd->multi_rsp_q) ==\n        p_cmd->multi_req.num_handles) {\n      build_read_multi_rsp(p_cmd, mtu);\n      return (true);\n    }\n  } else /* any handle read exception occurs, return error */\n  {\n    return (true);\n  }\n\n  /* If here, still waiting */\n  return (false);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_process_app_rsp\n *\n * Description      This function checks whether the response message from\n *                  application matches any pending request.\n *\n * Returns          void\n *\n ******************************************************************************/\ntGATT_STATUS gatt_sr_process_app_rsp(tGATT_TCB& tcb, tGATT_IF gatt_if,\n                                     UNUSED_ATTR uint32_t trans_id,\n                                     uint8_t op_code, tGATT_STATUS status,\n                                     tGATTS_RSP* p_msg,\n                                     tGATT_SR_CMD* sr_res_p) {\n  tGATT_STATUS ret_code = GATT_SUCCESS;\n  uint16_t payload_size = gatt_tcb_get_payload_size_rx(tcb, sr_res_p->cid);\n\n  VLOG(1) << __func__ << \" gatt_if=\" << +gatt_if;\n\n  gatt_sr_update_cback_cnt(tcb, sr_res_p->cid, gatt_if, false, false);\n\n  if ((op_code == GATT_REQ_READ_MULTI) ||\n      (op_code == GATT_REQ_READ_MULTI_VAR)) {\n    /* If no error and still waiting, just return */\n    if (!process_read_multi_rsp(sr_res_p, status, p_msg, payload_size))\n      return (GATT_SUCCESS);\n  } else {\n    if (op_code == GATT_REQ_PREPARE_WRITE && status == GATT_SUCCESS)\n      gatt_sr_update_prep_cnt(tcb, gatt_if, true, false);\n\n    if (op_code == GATT_REQ_EXEC_WRITE && status != GATT_SUCCESS)\n      gatt_sr_reset_cback_cnt(tcb, sr_res_p->cid);\n\n    sr_res_p->status = status;\n\n    if (gatt_sr_is_cback_cnt_zero(tcb) && status == GATT_SUCCESS) {\n      if (sr_res_p->p_rsp_msg == NULL) {\n        sr_res_p->p_rsp_msg = attp_build_sr_msg(tcb, (uint8_t)(op_code + 1),\n                                                (tGATT_SR_MSG*)p_msg);\n      } else {\n        LOG(ERROR) << \"Exception!!! already has respond message\";\n      }\n    }\n  }\n  if (gatt_sr_is_cback_cnt_zero(tcb)) {\n    if ((sr_res_p->status == GATT_SUCCESS) && (sr_res_p->p_rsp_msg)) {\n      ret_code = attp_send_sr_msg(tcb, sr_res_p->cid, sr_res_p->p_rsp_msg);\n      sr_res_p->p_rsp_msg = NULL;\n    } else {\n      ret_code = gatt_send_error_rsp(tcb, sr_res_p->cid, status, op_code,\n                                     sr_res_p->handle, false);\n    }\n\n    gatt_dequeue_sr_cmd(tcb, sr_res_p->cid);\n  }\n\n  VLOG(1) << __func__ << \" ret_code=\" << +ret_code;\n\n  return ret_code;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_exec_write_req\n *\n * Description      This function is called to process the execute write request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_exec_write_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint8_t *p = p_data, flag, i = 0;\n  uint32_t trans_id = 0;\n  tGATT_IF gatt_if;\n  uint16_t conn_id;\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1)\n        << \"Conformance tst: forced err rspv for Execute Write: error status=\"\n        << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        gatt_cb.handle, false);\n\n    return;\n  }\n#endif\n\n  if (len < sizeof(flag)) {\n    android_errorWriteLog(0x534e4554, \"73172115\");\n    LOG(ERROR) << __func__ << \"invalid length\";\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_EXEC_WRITE, 0,\n                        false);\n    return;\n  }\n\n  STREAM_TO_UINT8(flag, p);\n\n  /* mask the flag */\n  flag &= GATT_PREP_WRITE_EXEC;\n\n  /* no prep write is queued */\n  if (!gatt_sr_is_prep_cnt_zero(tcb)) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, 0);\n    gatt_sr_copy_prep_cnt_to_cback_cnt(tcb);\n\n    for (i = 0; i < GATT_MAX_APPS; i++) {\n      if (tcb.prep_cnt[i]) {\n        gatt_if = (tGATT_IF)(i + 1);\n        conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_if);\n        tGATTS_DATA gatts_data;\n        gatts_data.exec_write = flag;\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_WRITE_EXEC,\n                                  &gatts_data);\n        tcb.prep_cnt[i] = 0;\n      }\n    }\n  } else /* nothing needs to be executed , send response now */\n  {\n    LOG(ERROR) << \"gatt_process_exec_write_req: no prepare write pending\";\n    gatt_send_error_rsp(tcb, cid, GATT_ERROR, GATT_REQ_EXEC_WRITE, 0, false);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_read_multi_req\n *\n * Description      This function is called to process the read multiple request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_read_multi_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint32_t trans_id;\n  uint16_t handle = 0, ll = len;\n  uint8_t* p = p_data;\n  tGATT_STATUS err = GATT_SUCCESS;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n\n  VLOG(1) << __func__;\n\n  tGATT_READ_MULTI* multi_req = gatt_sr_get_read_multi(tcb, cid);\n  multi_req->num_handles = 0;\n  multi_req->variable_len = (op_code == GATT_REQ_READ_MULTI_VAR);\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rspvofr ReadMultiple: error status=\"\n            << +gatt_cb.err_status;\n\n    STREAM_TO_UINT16(handle, p);\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        handle, false);\n\n    return;\n  }\n#endif\n\n  while (ll >= 2 && multi_req->num_handles < GATT_MAX_READ_MULTI_HANDLES) {\n    STREAM_TO_UINT16(handle, p);\n\n    auto it = gatt_sr_find_i_rcb_by_handle(handle);\n    if (it != gatt_cb.srv_list_info->end()) {\n      multi_req->handles[multi_req->num_handles++] = handle;\n\n      /* check read permission */\n      err = gatts_read_attr_perm_check(it->p_db, false, handle, sec_flag,\n                                       key_size);\n      if (err != GATT_SUCCESS) {\n        VLOG(1) << StringPrintf(\"read permission denied : 0x%02x\", err);\n        break;\n      }\n    } else {\n      /* invalid handle */\n      err = GATT_INVALID_HANDLE;\n      break;\n    }\n    ll -= 2;\n  }\n\n  if (ll != 0) {\n    LOG(ERROR) << \"max attribute handle reached in ReadMultiple Request.\";\n  }\n\n  if (multi_req->num_handles == 0) err = GATT_INVALID_HANDLE;\n\n  if (err == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, multi_req->handles[0]);\n    if (trans_id != 0) {\n      tGATT_SR_CMD* sr_cmd_p = gatt_sr_get_cmd_by_cid(tcb, cid);\n\n      gatt_sr_reset_cback_cnt(tcb,\n                              cid); /* read multiple use multi_rsp_q's count*/\n\n      for (ll = 0; ll < multi_req->num_handles; ll++) {\n        tGATTS_RSP* p_msg = (tGATTS_RSP*)osi_calloc(sizeof(tGATTS_RSP));\n        handle = multi_req->handles[ll];\n        auto it = gatt_sr_find_i_rcb_by_handle(handle);\n\n        p_msg->attr_value.handle = handle;\n        err = gatts_read_attr_value_by_handle(\n            tcb, cid, it->p_db, op_code, handle, 0, p_msg->attr_value.value,\n            &p_msg->attr_value.len, GATT_MAX_ATTR_LEN, sec_flag, key_size,\n            trans_id);\n\n        if (err == GATT_SUCCESS) {\n          gatt_sr_process_app_rsp(tcb, it->gatt_if, trans_id, op_code,\n                                  GATT_SUCCESS, p_msg, sr_cmd_p);\n        }\n        /* either not using or done using the buffer, release it now */\n        osi_free(p_msg);\n      }\n    } else\n      err = GATT_NO_RESOURCES;\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (err != GATT_SUCCESS && err != GATT_PENDING && err != GATT_BUSY)\n    gatt_send_error_rsp(tcb, cid, err, op_code, handle, false);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_build_primary_service_rsp\n *\n * Description      Primamry service request processed internally. Theretically\n *                  only deal with ReadByTypeVAlue and ReadByGroupType.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic tGATT_STATUS gatt_build_primary_service_rsp(\n    BT_HDR* p_msg, tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n    uint16_t s_hdl, uint16_t e_hdl, UNUSED_ATTR uint8_t* p_data,\n    const Uuid& value) {\n  tGATT_STATUS status = GATT_NOT_FOUND;\n  uint8_t handle_len = 4;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl < s_hdl || el.s_hdl > e_hdl ||\n        el.type != GATT_UUID_PRI_SERVICE) {\n      continue;\n    }\n\n    Uuid* p_uuid = gatts_get_service_uuid(el.p_db);\n    if (!p_uuid) continue;\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE)\n      handle_len = 4 + gatt_build_uuid_to_stream_len(*p_uuid);\n\n    /* get the length byte in the repsonse */\n    if (p_msg->offset == 0) {\n      *p++ = op_code + 1;\n      p_msg->len++;\n      p_msg->offset = handle_len;\n\n      if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n        *p++ = (uint8_t)p_msg->offset; /* length byte */\n        p_msg->len++;\n      }\n    }\n\n    if (p_msg->len + p_msg->offset > payload_size ||\n        handle_len != p_msg->offset) {\n      break;\n    }\n\n    if (op_code == GATT_REQ_FIND_TYPE_VALUE && value != *p_uuid) continue;\n\n    UINT16_TO_STREAM(p, el.s_hdl);\n\n    if (gatt_cb.last_service_handle &&\n        gatt_cb.last_service_handle == el.s_hdl) {\n      VLOG(1) << \"Use 0xFFFF for the last primary attribute\";\n      /* see GATT ERRATA 4065, 4063, ATT ERRATA 4062 */\n      UINT16_TO_STREAM(p, 0xFFFF);\n    } else {\n      UINT16_TO_STREAM(p, el.e_hdl);\n    }\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE)\n      gatt_build_uuid_to_stream(&p, *p_uuid);\n\n    status = GATT_SUCCESS;\n    p_msg->len += p_msg->offset;\n  }\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  return status;\n}\n\n/**\n * fill the find information response information in the given buffer.\n *\n * Returns          true: if data filled sucessfully.\n *                  false: packet full, or format mismatch.\n */\nstatic tGATT_STATUS gatt_build_find_info_rsp(tGATT_SRV_LIST_ELEM& el,\n                                             BT_HDR* p_msg, uint16_t& len,\n                                             uint16_t s_hdl, uint16_t e_hdl) {\n  uint8_t info_pair_len[2] = {4, 18};\n\n  if (!el.p_db) return GATT_NOT_FOUND;\n\n  /* check the attribute database */\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET + p_msg->len;\n\n  for (auto& attr : el.p_db->attr_list) {\n    if (attr.handle > e_hdl) break;\n\n    if (attr.handle < s_hdl) continue;\n\n    uint8_t uuid_len = attr.uuid.GetShortestRepresentationSize();\n    if (p_msg->offset == 0)\n      p_msg->offset = (uuid_len == Uuid::kNumBytes16) ? GATT_INFO_TYPE_PAIR_16\n                                                      : GATT_INFO_TYPE_PAIR_128;\n\n    if (len < info_pair_len[p_msg->offset - 1]) return GATT_NO_RESOURCES;\n\n    if (p_msg->offset == GATT_INFO_TYPE_PAIR_16 &&\n        uuid_len == Uuid::kNumBytes16) {\n      UINT16_TO_STREAM(p, attr.handle);\n      UINT16_TO_STREAM(p, attr.uuid.As16Bit());\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 &&\n               uuid_len == Uuid::kNumBytes128) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 &&\n               uuid_len == Uuid::kNumBytes32) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else {\n      LOG(ERROR) << \"format mismatch\";\n      return GATT_NO_RESOURCES;\n      /* format mismatch */\n    }\n    p_msg->len += info_pair_len[p_msg->offset - 1];\n    len -= info_pair_len[p_msg->offset - 1];\n    return GATT_SUCCESS;\n  }\n\n  return GATT_NOT_FOUND;\n}\n\nstatic tGATT_STATUS read_handles(uint16_t& len, uint8_t*& p, uint16_t& s_hdl,\n                                 uint16_t& e_hdl) {\n  if (len < 4) return GATT_INVALID_PDU;\n\n  /* obtain starting handle, and ending handle */\n  STREAM_TO_UINT16(s_hdl, p);\n  STREAM_TO_UINT16(e_hdl, p);\n  len -= 4;\n\n  if (s_hdl > e_hdl || !GATT_HANDLE_IS_VALID(s_hdl) ||\n      !GATT_HANDLE_IS_VALID(e_hdl)) {\n    return GATT_INVALID_HANDLE;\n  }\n\n  return GATT_SUCCESS;\n}\n\nstatic tGATT_STATUS gatts_validate_packet_format(uint8_t op_code, uint16_t& len,\n                                                 uint8_t*& p, Uuid* p_uuid,\n                                                 uint16_t& s_hdl,\n                                                 uint16_t& e_hdl) {\n  tGATT_STATUS ret = read_handles(len, p, s_hdl, e_hdl);\n  if (ret != GATT_SUCCESS) return ret;\n\n  if (len < 2) return GATT_INVALID_PDU;\n\n  /* parse uuid now */\n  CHECK(p_uuid);\n  uint16_t uuid_len = (op_code == GATT_REQ_FIND_TYPE_VALUE) ? 2 : len;\n  if (!gatt_parse_uuid_from_cmd(p_uuid, uuid_len, &p)) {\n    VLOG(1) << \"Bad UUID\";\n    return GATT_INVALID_PDU;\n  }\n\n  len -= uuid_len;\n  return GATT_SUCCESS;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_primary_service_req\n *\n * Description      Process ReadByGroupType/ReadByTypeValue request, for\n *                  discovering all primary services or discover primary service\n *                  by UUID request.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n                                       uint8_t op_code, uint16_t len,\n                                       uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  Uuid uuid = Uuid::kEmpty;\n\n  uint8_t reason =\n      gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  if (uuid != Uuid::From16Bit(GATT_UUID_PRI_SERVICE)) {\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n      gatt_send_error_rsp(tcb, cid, GATT_UNSUPPORT_GRP_TYPE, op_code, s_hdl,\n                          false);\n      VLOG(1) << StringPrintf(\"unexpected ReadByGrpType Group: %s\",\n                              uuid.ToString().c_str());\n      return;\n    }\n\n    // we do not support ReadByTypeValue with any non-primamry_service type\n    gatt_send_error_rsp(tcb, cid, GATT_NOT_FOUND, op_code, s_hdl, false);\n    VLOG(1) << StringPrintf(\"unexpected ReadByTypeValue type: %s\",\n                            uuid.ToString().c_str());\n    return;\n  }\n\n  // TODO: we assume theh value is UUID, there is no such requirement in spec\n  Uuid value = Uuid::kEmpty;\n  if (op_code == GATT_REQ_FIND_TYPE_VALUE) {\n    if (!gatt_parse_uuid_from_cmd(&value, len, &p_data)) {\n      gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, s_hdl, false);\n    }\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  uint16_t msg_len =\n      (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n  reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl,\n                                          e_hdl, p_data, value);\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_find_info\n *\n * Description      process find information request, for discover character\n *                  descriptors.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t op_code, uint16_t len,\n                                    uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  uint8_t reason = read_handles(len, p_data, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n  uint16_t buf_len =\n      (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n  reason = GATT_NOT_FOUND;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n  *p++ = op_code + 1;\n  p_msg->len = 2;\n\n  buf_len = payload_size - 2;\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl <= e_hdl && el.e_hdl >= s_hdl) {\n      reason = gatt_build_find_info_rsp(el, p_msg, buf_len, s_hdl, e_hdl);\n      if (reason == GATT_NO_RESOURCES) {\n        reason = GATT_SUCCESS;\n        break;\n      }\n    }\n  }\n\n  *p = (uint8_t)p_msg->offset;\n\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n  } else\n    attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_mtu_req\n *\n * Description      This function is called to process excahnge MTU request.\n *                  Only used on LE.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_mtu_req(tGATT_TCB& tcb, uint16_t cid, uint16_t len,\n                                  uint8_t* p_data) {\n  /* BR/EDR conenction, send error response */\n  if (cid != L2CAP_ATT_CID) {\n    gatt_send_error_rsp(tcb, cid, GATT_REQ_NOT_SUPPORTED, GATT_REQ_MTU, 0,\n                        false);\n    return;\n  }\n\n  if (len < GATT_MTU_REQ_MIN_LEN) {\n    LOG(ERROR) << \"invalid MTU request PDU received.\";\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_MTU, 0, false);\n    return;\n  }\n\n  uint16_t mtu = 0;\n  uint8_t* p = p_data;\n  STREAM_TO_UINT16(mtu, p);\n  /* mtu must be greater than default MTU which is 23/48 */\n  if (mtu < GATT_DEF_BLE_MTU_SIZE)\n    tcb.payload_size = GATT_DEF_BLE_MTU_SIZE;\n  else if (mtu > GATT_MAX_MTU_SIZE)\n    tcb.payload_size = GATT_MAX_MTU_SIZE;\n  else\n    tcb.payload_size = mtu;\n\n  LOG(INFO) << \"MTU request PDU with MTU size \" << +tcb.payload_size;\n\n  BTM_SetBleDataLength(tcb.peer_bda, tcb.payload_size + L2CAP_PKT_OVERHEAD);\n\n  tGATT_SR_MSG gatt_sr_msg;\n  gatt_sr_msg.mtu = tcb.payload_size;\n  BT_HDR* p_buf = attp_build_sr_msg(tcb, GATT_RSP_MTU, &gatt_sr_msg);\n  attp_send_sr_msg(tcb, cid, p_buf);\n\n  tGATTS_DATA gatts_data;\n  gatts_data.mtu = tcb.payload_size;\n  /* Notify all registered applicaiton with new MTU size. Us a transaction ID */\n  /* of 0, as no response is allowed from applcations                    */\n  for (int i = 0; i < GATT_MAX_APPS; i++) {\n    if (gatt_cb.cl_rcb[i].in_use) {\n      uint16_t conn_id =\n          GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_cb.cl_rcb[i].gatt_if);\n      gatt_sr_send_req_callback(conn_id, 0, GATTS_REQ_TYPE_MTU, &gatts_data);\n    }\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_read_by_type_req\n *\n * Description      process Read By type request.\n *                  This PDU can be used to perform:\n *                  - read characteristic value\n *                  - read characteristic descriptor value\n *                  - discover characteristic\n *                  - discover characteristic by UUID\n *                  - relationship discovery\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n                                           uint8_t op_code, uint16_t len,\n                                           uint8_t* p_data) {\n  Uuid uuid = Uuid::kEmpty;\n  uint16_t s_hdl = 0, e_hdl = 0, err_hdl = 0;\n  tGATT_STATUS reason =\n      gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rsp for ReadByType: error status=\"\n            << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        s_hdl, false);\n\n    return;\n  }\n#endif\n\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  *p++ = op_code + 1;\n  /* reserve length byte */\n  p_msg->len = 2;\n  uint16_t buf_len = payload_size - 2;\n\n  reason = GATT_NOT_FOUND;\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl <= e_hdl && el.e_hdl >= s_hdl) {\n      tGATT_SEC_FLAG sec_flag;\n      uint8_t key_size;\n      gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n      tGATT_STATUS ret = gatts_db_read_attr_value_by_type(\n          tcb, cid, el.p_db, op_code, p_msg, s_hdl, e_hdl, uuid, &buf_len,\n          sec_flag, key_size, 0, &err_hdl);\n      if (ret != GATT_NOT_FOUND) {\n        reason = ret;\n        if (ret == GATT_NO_RESOURCES) reason = GATT_SUCCESS;\n      }\n\n      if (ret != GATT_SUCCESS && ret != GATT_NOT_FOUND) {\n        s_hdl = err_hdl;\n        break;\n      }\n    }\n  }\n  *p = (uint8_t)p_msg->offset;\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n\n    /* in theroy BUSY is not possible(should already been checked), protected\n     * check */\n    if (reason != GATT_PENDING && reason != GATT_BUSY)\n      gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/**\n * This function is called to process the write request from client.\n */\nstatic void gatts_process_write_req(tGATT_TCB& tcb, uint16_t cid,\n                                    tGATT_SRV_LIST_ELEM& el, uint16_t handle,\n                                    uint8_t op_code, uint16_t len,\n                                    uint8_t* p_data,\n                                    bt_gatt_db_attribute_type_t gatt_type) {\n  tGATTS_DATA sr_data;\n  uint32_t trans_id;\n  tGATT_STATUS status;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size, *p = p_data;\n  uint16_t conn_id;\n\n  memset(&sr_data, 0, sizeof(tGATTS_DATA));\n\n  switch (op_code) {\n    case GATT_REQ_PREPARE_WRITE:\n      if (len < 2 || p == nullptr) {\n        LOG(ERROR) << __func__\n                   << \": Prepare write request was invalid - missing offset, \"\n                      \"sending error response\";\n        gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, handle, false);\n        return;\n      }\n      sr_data.write_req.is_prep = true;\n      STREAM_TO_UINT16(sr_data.write_req.offset, p);\n      len -= 2;\n      FALLTHROUGH_INTENDED; /* FALLTHROUGH */\n    case GATT_SIGN_CMD_WRITE:\n      if (op_code == GATT_SIGN_CMD_WRITE) {\n        VLOG(1) << \"Write CMD with data sigining\";\n        len -= GATT_AUTH_SIGN_LEN;\n      }\n      FALLTHROUGH_INTENDED; /* FALLTHROUGH */\n    case GATT_CMD_WRITE:\n    case GATT_REQ_WRITE:\n      if (op_code == GATT_REQ_WRITE || op_code == GATT_REQ_PREPARE_WRITE)\n        sr_data.write_req.need_rsp = true;\n      sr_data.write_req.handle = handle;\n      if (len > GATT_MAX_ATTR_LEN) len = GATT_MAX_ATTR_LEN;\n      sr_data.write_req.len = len;\n      if (len != 0 && p != nullptr) {\n        memcpy(sr_data.write_req.value, p, len);\n      }\n      break;\n  }\n\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n  status = gatts_write_attr_perm_check(el.p_db, op_code, handle,\n                                       sr_data.write_req.offset, p, len,\n                                       sec_flag, key_size);\n\n  if (status == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, handle);\n    if (trans_id != 0) {\n      conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, el.gatt_if);\n\n      uint8_t opcode = 0;\n      if (gatt_type == BTGATT_DB_DESCRIPTOR) {\n        opcode = GATTS_REQ_TYPE_WRITE_DESCRIPTOR;\n      } else if (gatt_type == BTGATT_DB_CHARACTERISTIC) {\n        opcode = GATTS_REQ_TYPE_WRITE_CHARACTERISTIC;\n      } else {\n        LOG(ERROR) << __func__\n                   << \"%s: Attempt to write attribute that's not tied with\"\n                      \" characteristic or descriptor value.\";\n        status = GATT_ERROR;\n      }\n\n      if (opcode) {\n        gatt_sr_send_req_callback(conn_id, trans_id, opcode, &sr_data);\n        status = GATT_PENDING;\n      }\n    } else {\n      LOG(ERROR) << \"max pending command, send error\";\n      status = GATT_BUSY; /* max pending command, application error */\n    }\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (status != GATT_PENDING && status != GATT_BUSY &&\n      (op_code == GATT_REQ_PREPARE_WRITE || op_code == GATT_REQ_WRITE)) {\n    gatt_send_error_rsp(tcb, cid, status, op_code, handle, false);\n  }\n  return;\n}\n\n/**\n * This function is called to process the read request from client.\n */\nstatic void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                   tGATT_SRV_LIST_ELEM& el, uint8_t op_code,\n                                   uint16_t handle, uint16_t len,\n                                   uint8_t* p_data) {\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  uint16_t offset = 0;\n\n  if (op_code == GATT_REQ_READ_BLOB && len < sizeof(uint16_t)) {\n    /* Error: packet length is too short */\n    LOG(ERROR) << __func__ << \": packet length=\" << len\n               << \" too short. min=\" << sizeof(uint16_t);\n    android_errorWriteWithInfoLog(0x534e4554, \"73172115\", -1, NULL, 0);\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, 0, false);\n    return;\n  }\n\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n\n  if (op_code == GATT_REQ_READ_BLOB) STREAM_TO_UINT16(offset, p_data);\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n  *p++ = op_code + 1;\n  p_msg->len = 1;\n  buf_len = payload_size - 1;\n\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n  uint16_t value_len = 0;\n  tGATT_STATUS reason = gatts_read_attr_value_by_handle(\n      tcb, cid, el.p_db, op_code, handle, offset, p, &value_len,\n      (uint16_t)buf_len, sec_flag, key_size, 0);\n  p_msg->len += value_len;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n\n    /* in theory BUSY is not possible(should already been checked), protected\n     * check */\n    if (reason != GATT_PENDING && reason != GATT_BUSY)\n      gatt_send_error_rsp(tcb, cid, reason, op_code, handle, false);\n\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_attribute_req\n *\n * Description      This function is called to process the per attribute handle\n *                  request from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_attribute_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint16_t handle = 0;\n  uint8_t* p = p_data;\n  tGATT_STATUS status = GATT_INVALID_HANDLE;\n\n  if (len < 2) {\n    LOG(ERROR) << \"Illegal PDU length, discard request\";\n    status = GATT_INVALID_PDU;\n  } else {\n    STREAM_TO_UINT16(handle, p);\n    len -= 2;\n  }\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  gatt_cb.handle = handle;\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rsp: error status=\"\n            << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, cid, gatt_cb.req_op_code,\n                        handle, false);\n\n    return;\n  }\n#endif\n\n  if (GATT_HANDLE_IS_VALID(handle)) {\n    for (auto& el : *gatt_cb.srv_list_info) {\n      if (el.s_hdl <= handle && el.e_hdl >= handle) {\n        for (const auto& attr : el.p_db->attr_list) {\n          if (attr.handle == handle) {\n            switch (op_code) {\n              case GATT_REQ_READ: /* read char/char descriptor value */\n              case GATT_REQ_READ_BLOB:\n                gatts_process_read_req(tcb, cid, el, op_code, handle, len, p);\n                break;\n\n              case GATT_REQ_WRITE: /* write char/char descriptor value */\n              case GATT_CMD_WRITE:\n              case GATT_SIGN_CMD_WRITE:\n              case GATT_REQ_PREPARE_WRITE:\n                gatts_process_write_req(tcb, cid, el, handle, op_code, len, p,\n                                        attr.gatt_type);\n                break;\n              default:\n                break;\n            }\n            status = GATT_SUCCESS;\n            break;\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  if (status != GATT_SUCCESS && op_code != GATT_CMD_WRITE &&\n      op_code != GATT_SIGN_CMD_WRITE)\n    gatt_send_error_rsp(tcb, cid, status, op_code, handle, false);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_proc_srv_chg_ind_ack\n *\n * Description      This function process the service changed indicaiton ACK\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_proc_srv_chg_ind_ack(tGATT_TCB tcb) {\n  tGATTS_SRV_CHG_REQ req;\n  tGATTS_SRV_CHG* p_buf = NULL;\n\n  VLOG(1) << __func__;\n\n  p_buf = gatt_is_bda_in_the_srv_chg_clt_list(tcb.peer_bda);\n  if (p_buf != NULL) {\n    VLOG(1) << \"NV update set srv chg = false\";\n    p_buf->srv_changed = false;\n    memcpy(&req.srv_chg, p_buf, sizeof(tGATTS_SRV_CHG));\n    if (gatt_cb.cb_info.p_srv_chg_callback)\n      (*gatt_cb.cb_info.p_srv_chg_callback)(GATTS_SRV_CHG_CMD_UPDATE_CLIENT,\n                                            &req, NULL);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_chk_pending_ind\n *\n * Description      This function check any pending indication needs to be sent\n *                  if there is a pending indication then sent the indication\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_chk_pending_ind(tGATT_TCB& tcb) {\n  VLOG(1) << __func__;\n\n  tGATT_VALUE* p_buf =\n      (tGATT_VALUE*)fixed_queue_try_peek_first(tcb.pending_ind_q);\n  if (p_buf != NULL) {\n    GATTS_HandleValueIndication(p_buf->conn_id, p_buf->handle, p_buf->len,\n                                p_buf->value);\n    osi_free(fixed_queue_try_remove_from_queue(tcb.pending_ind_q, p_buf));\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_proc_ind_ack\n *\n * Description      This function processes the Indication ack\n *\n * Returns          true continue to process the indication ack by the\n *                  application if the ACK is not a Service Changed Indication\n *\n ******************************************************************************/\nstatic bool gatts_proc_ind_ack(tGATT_TCB& tcb, uint16_t ack_handle) {\n  bool continue_processing = true;\n\n  VLOG(1) << __func__ << \" ack handle=%d\" << ack_handle;\n\n  if (ack_handle == gatt_cb.handle_of_h_r) {\n    gatts_proc_srv_chg_ind_ack(tcb);\n    /* there is no need to inform the application since srv chg is handled\n     * internally by GATT */\n    continue_processing = false;\n\n    // After receiving ack of svc_chg_ind, reset client status\n    gatt_sr_update_cl_status(tcb, /* chg_aware= */ true);\n  }\n\n  gatts_chk_pending_ind(tcb);\n  return continue_processing;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_value_conf\n *\n * Description      This function is called to process the handle value\n *                  confirmation.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_value_conf(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code) {\n  uint16_t handle;\n\n  if (!gatt_tcb_find_indicate_handle(tcb, cid, &handle)) {\n    LOG(ERROR) << \"unexpected handle value confirmation\";\n    return;\n  }\n\n  gatt_stop_conf_timer(tcb, cid);\n\n  bool continue_processing = gatts_proc_ind_ack(tcb, handle);\n\n  if (continue_processing) {\n    tGATTS_DATA gatts_data;\n    gatts_data.handle = handle;\n    for (auto& el : *gatt_cb.srv_list_info) {\n      if (el.s_hdl <= handle && el.e_hdl >= handle) {\n        uint32_t trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, handle);\n        uint16_t conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, el.gatt_if);\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_CONF,\n                                  &gatts_data);\n      }\n    }\n  }\n}\n\nstatic bool gatts_process_db_out_of_sync(tGATT_TCB& tcb, uint16_t cid,\n                                         uint8_t op_code, uint16_t len,\n                                         uint8_t* p_data) {\n  if (gatt_sr_is_cl_change_aware(tcb)) return false;\n\n  // default value\n  bool should_ignore = true;\n  bool should_rsp = true;\n\n  switch (op_code) {\n    case GATT_REQ_READ_BY_TYPE: {\n      // Check if read database hash by UUID\n      Uuid uuid = Uuid::kEmpty;\n      uint16_t s_hdl = 0, e_hdl = 0;\n      uint16_t db_hash_handle = gatt_cb.handle_of_database_hash;\n      tGATT_STATUS reason = gatts_validate_packet_format(op_code, len, p_data,\n                                                         &uuid, s_hdl, e_hdl);\n      if (reason == GATT_SUCCESS &&\n          (s_hdl <= db_hash_handle && db_hash_handle <= e_hdl) &&\n          (uuid == Uuid::From16Bit(GATT_UUID_DATABASE_HASH)))\n        should_ignore = false;\n\n    } break;\n    case GATT_REQ_READ: {\n      // Check if read database hash by handle\n      uint16_t handle = 0;\n      uint8_t* p = p_data;\n      tGATT_STATUS status = GATT_SUCCESS;\n\n      if (len < 2) {\n        status = GATT_INVALID_PDU;\n      } else {\n        STREAM_TO_UINT16(handle, p);\n        len -= 2;\n      }\n\n      if (status == GATT_SUCCESS && handle == gatt_cb.handle_of_database_hash)\n        should_ignore = false;\n\n    } break;\n    case GATT_REQ_READ_BY_GRP_TYPE: /* discover primary services */\n    case GATT_REQ_FIND_TYPE_VALUE:  /* discover service by UUID */\n    case GATT_REQ_FIND_INFO:        /* discover char descrptor */\n    case GATT_REQ_READ_BLOB:        /* read long char */\n    case GATT_REQ_READ_MULTI:       /* read multi char*/\n    case GATT_REQ_WRITE:            /* write char/char descriptor value */\n    case GATT_REQ_PREPARE_WRITE:    /* write long char */\n      // Use default value\n      break;\n    case GATT_CMD_WRITE:      /* cmd */\n    case GATT_SIGN_CMD_WRITE: /* sign cmd */\n      should_rsp = false;\n      break;\n    case GATT_REQ_MTU:           /* configure mtu */\n    case GATT_REQ_EXEC_WRITE:    /* execute write */\n    case GATT_HANDLE_VALUE_CONF: /* confirm for indication */\n    default:\n      should_ignore = false;\n  }\n\n  if (should_ignore) {\n    if (should_rsp) {\n      gatt_send_error_rsp(tcb, cid, GATT_DATABASE_OUT_OF_SYNC, op_code, 0x0000,\n                          false);\n    }\n    LOG(INFO) << __func__ << \": database out of sync, device=\" << tcb.peer_bda\n              << \", op_code=\" << loghex((uint16_t)op_code)\n              << \", should_rsp=\" << should_rsp;\n    gatt_sr_update_cl_status(tcb, /* chg_aware= */ should_rsp);\n  }\n\n  return should_ignore;\n}\n\n/** This function is called to handle the client requests to server */\nvoid gatt_server_handle_client_req(tGATT_TCB& tcb, uint16_t cid,\n                                   uint8_t op_code, uint16_t len,\n                                   uint8_t* p_data) {\n  /* there is pending command, discard this one */\n  if (!gatt_sr_cmd_empty(tcb, cid) && op_code != GATT_HANDLE_VALUE_CONF) return;\n\n  /* the size of the message may not be bigger than the local max PDU size*/\n  /* The message has to be smaller than the agreed MTU, len does not include op\n   * code */\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_rx(tcb, cid);\n  if (len >= payload_size) {\n    LOG(ERROR) << StringPrintf(\"server receive invalid PDU size:%d pdu size:%d\",\n                               len + 1, payload_size);\n    /* for invalid request expecting response, send it now */\n    if (op_code != GATT_CMD_WRITE && op_code != GATT_SIGN_CMD_WRITE &&\n        op_code != GATT_HANDLE_VALUE_CONF) {\n      gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, 0, false);\n    }\n    /* otherwise, ignore the pkt */\n  } else {\n    // handle database out of sync\n    if (gatts_process_db_out_of_sync(tcb, cid, op_code, len, p_data)) return;\n\n    switch (op_code) {\n      case GATT_REQ_READ_BY_GRP_TYPE: /* discover primary services */\n      case GATT_REQ_FIND_TYPE_VALUE:  /* discover service by UUID */\n        gatts_process_primary_service_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_FIND_INFO: /* discover char descrptor */\n        gatts_process_find_info(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ_BY_TYPE: /* read characteristic value, char descriptor\n                                     value */\n        /* discover characteristic, discover char by UUID */\n        gatts_process_read_by_type_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ: /* read char/char descriptor value */\n      case GATT_REQ_READ_BLOB:\n      case GATT_REQ_WRITE: /* write char/char descriptor value */\n      case GATT_CMD_WRITE:\n      case GATT_SIGN_CMD_WRITE:\n      case GATT_REQ_PREPARE_WRITE:\n        gatts_process_attribute_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_HANDLE_VALUE_CONF:\n        gatts_process_value_conf(tcb, cid, op_code);\n        break;\n\n      case GATT_REQ_MTU:\n        gatts_process_mtu_req(tcb, cid, len, p_data);\n        break;\n\n      case GATT_REQ_EXEC_WRITE:\n        gatt_process_exec_write_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ_MULTI:\n      case GATT_REQ_READ_MULTI_VAR:\n        gatt_process_read_multi_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      default:\n        break;\n    }\n  }\n}\n```"
                    }
                ]
            },
            {
                "downstream_version": "14",
                "branch_used": "android14-release",
                "downstream_patch": "2fc3087b9ac3019518c6ceb8a64d181d6bb04907",
                "repo_path": "android_repos/Bluetooth",
                "result": "failure",
                "downstream_patch_content": "commit 2fc3087b9ac3019518c6ceb8a64d181d6bb04907\nAuthor: Brian Delwiche <delwiche@google.com>\nDate:   Fri Oct 4 18:23:45 2024 +0000\n\n    Fix OOB writes in gatt_sr.cc\n    \n    At various points in gatt_sr.cc, the output of the\n    gatt_tcb_get_payload_size function is used without checking for a\n    positive length.  However, in exceptional cases it is possible for the\n    channel to be closed at the time the function is called, which will lead\n    to a zero length and cause an OOB write in subsequent processing.\n    \n    Fix all of these.\n    \n    Bug: 364026473\n    Bug: 364027038\n    Bug: 364027949\n    Bug: 364025411\n    Test: m libbluetooth\n    Test: researcher POC\n    Flag: EXEMPT trivial validity checks\n    Tag: #security\n    Ignore-AOSP-First: Security\n    Merged-In: I9b30499d4aed6ab42f3cdb2c0de7df2c1a827404\n    Change-Id: I9b30499d4aed6ab42f3cdb2c0de7df2c1a827404\n\ndiff --git a/system/stack/gatt/gatt_sr.cc b/system/stack/gatt/gatt_sr.cc\nindex 6f81b90514..c61df52bc8 100644\n--- a/system/stack/gatt/gatt_sr.cc\n+++ b/system/stack/gatt/gatt_sr.cc\n@@ -734,6 +734,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n@@ -769,6 +774,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len =\n       (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n@@ -902,6 +913,11 @@ static void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n \n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n@@ -1049,6 +1065,11 @@ static void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t* p_data) {\n   uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   uint16_t offset = 0;\n \n",
                "file_conflicts": [
                    {
                        "file_name": "system/stack/gatt/gatt_sr.cc",
                        "total_hunks": 4,
                        "failed_hunks": [
                            1,
                            2
                        ],
                        "inline_merge_conflicts": [
                            {
                                "hunk_number": 1,
                                "merge_conflict": "<<<<<<< DOWNSTREAM (version 14)\n\n=======\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n>>>>>>> UPSTREAM PATCH (commit 7de5617f7d5266fe57c990c428621b5d4e92728a)"
                            },
                            {
                                "hunk_number": 2,
                                "merge_conflict": "<<<<<<< DOWNSTREAM (version 14)\n\n=======\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n>>>>>>> UPSTREAM PATCH (commit 7de5617f7d5266fe57c990c428621b5d4e92728a)"
                            }
                        ],
                        "rej_file_content": "```diff\n--- system/stack/gatt/gatt_sr.cc\n+++ system/stack/gatt/gatt_sr.cc\n@@ -772,6 +772,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_\n \n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl, e_hdl, p_data, value);\n@@ -804,6 +809,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid, uint8_t op_cod\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n```",
                        "patch_apply_output": "patching file system/stack/gatt/gatt_sr.cc\nHunk #1 FAILED at 772.\nHunk #2 FAILED at 804.\nHunk #3 succeeded at 902 with fuzz 2 (offset -47 lines).\nHunk #4 succeeded at 1054 with fuzz 2 (offset -47 lines).\n2 out of 4 hunks FAILED -- saving rejects to file system/stack/gatt/gatt_sr.cc.rej",
                        "inline_merge_output": "patching file system/stack/gatt/gatt_sr.cc\nHunk #1 NOT MERGED at 780-789.\nHunk #2 NOT MERGED at 828-837.\nHunk #3 merged at 988-992.\nHunk #4 merged at 1145-1149.",
                        "upstream_file_content": "```cc\n/******************************************************************************\n *\n *  Copyright 2008-2012 Broadcom Corporation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at:\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n ******************************************************************************/\n\n/******************************************************************************\n *\n *  this file contains the GATT server functions\n *\n ******************************************************************************/\n\n#include <bluetooth/log.h>\n#include <com_android_bluetooth_flags.h>\n#include <string.h>\n\n#include <algorithm>\n\n#include \"gatt_int.h\"\n#include \"hardware/bt_gatt_types.h\"\n#include \"internal_include/bt_target.h\"\n#include \"l2c_api.h\"\n#include \"osi/include/allocator.h\"\n#include \"stack/arbiter/acl_arbiter.h\"\n#include \"stack/eatt/eatt.h\"\n#include \"stack/include/bt_hdr.h\"\n#include \"stack/include/bt_types.h\"\n#include \"stack/include/btm_client_interface.h\"\n#include \"stack/include/l2cdefs.h\"\n#include \"types/bluetooth/uuid.h\"\n\n#define GATT_MTU_REQ_MIN_LEN 2\n#define L2CAP_PKT_OVERHEAD 4\n\nusing bluetooth::Uuid;\nusing bluetooth::eatt::EattChannel;\nusing bluetooth::eatt::EattExtension;\nusing namespace bluetooth;\n\n/*******************************************************************************\n *\n * Function         gatt_sr_enqueue_cmd\n *\n * Description      This function enqueue the request from client which needs a\n *                  application response, and update the transaction ID.\n *\n * Returns          void\n *\n ******************************************************************************/\nuint32_t gatt_sr_enqueue_cmd(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code, uint16_t handle) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel = EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n    if (channel == nullptr) {\n      log::warn(\"{}, cid 0x{:02x} already disconnected\", tcb.peer_bda, cid);\n      return 0;\n    }\n\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  uint32_t trans_id = 0;\n\n  p_cmd->cid = cid;\n\n  if ((p_cmd->op_code == 0) || (op_code == GATT_HANDLE_VALUE_CONF)) /* no pending request */\n  {\n    if (op_code == GATT_CMD_WRITE || op_code == GATT_SIGN_CMD_WRITE || op_code == GATT_REQ_MTU ||\n        op_code == GATT_HANDLE_VALUE_CONF) {\n      trans_id = ++tcb.trans_id;\n    } else {\n      p_cmd->trans_id = ++tcb.trans_id;\n      p_cmd->op_code = op_code;\n      p_cmd->handle = handle;\n      p_cmd->status = GATT_NOT_FOUND;\n      tcb.trans_id %= GATT_TRANS_ID_MAX;\n      trans_id = p_cmd->trans_id;\n    }\n  }\n\n  return trans_id;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_cmd_empty\n *\n * Description      This function checks if the server command queue is empty.\n *\n * Returns          true if empty, false if there is pending command.\n *\n ******************************************************************************/\nbool gatt_sr_cmd_empty(tGATT_TCB& tcb, uint16_t cid) {\n  if (cid == tcb.att_lcid) {\n    return tcb.sr_cmd.op_code == 0;\n  }\n\n  EattChannel* channel = EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n  if (channel == nullptr) {\n    log::warn(\"{}, cid 0x{:02x} already disconnected\", tcb.peer_bda, cid);\n    return false;\n  }\n\n  return channel->server_outstanding_cmd_.op_code == 0;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_dequeue_sr_cmd\n *\n * Description      This function dequeue the request from command queue.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_dequeue_sr_cmd(tGATT_TCB& tcb, uint16_t cid) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel = EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n    if (channel == nullptr) {\n      log::warn(\"{}, cid 0x{:02x} already disconnected\", tcb.peer_bda, cid);\n      return;\n    }\n\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  /* Double check in case any buffers are queued */\n  log::verbose(\"gatt_dequeue_sr_cmd cid: 0x{:x}\", cid);\n  if (p_cmd->p_rsp_msg) {\n    log::error(\"free tcb.sr_cmd.p_rsp_msg = {}\", fmt::ptr(p_cmd->p_rsp_msg));\n  }\n  osi_free_and_reset((void**)&p_cmd->p_rsp_msg);\n\n  while (!fixed_queue_is_empty(p_cmd->multi_rsp_q)) {\n    osi_free(fixed_queue_try_dequeue(p_cmd->multi_rsp_q));\n  }\n  fixed_queue_free(p_cmd->multi_rsp_q, NULL);\n  memset(p_cmd, 0, sizeof(tGATT_SR_CMD));\n}\n\nstatic void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) {\n  uint16_t ii;\n  size_t total_len, len;\n  uint8_t* p;\n  bool is_overflow = false;\n\n  // We need at least one extra byte for the opcode\n  if (mtu == 0) {\n    log::error(\"Invalid MTU\");\n    p_cmd->status = GATT_ILLEGAL_PARAMETER;\n    return;\n  }\n\n  len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu;\n  BT_HDR* p_buf = (BT_HDR*)osi_calloc(len);\n  p_buf->offset = L2CAP_MIN_OFFSET;\n  p = (uint8_t*)(p_buf + 1) + p_buf->offset;\n\n  /* First byte in the response is the opcode */\n  if (p_cmd->multi_req.variable_len) {\n    *p++ = GATT_RSP_READ_MULTI_VAR;\n  } else {\n    *p++ = GATT_RSP_READ_MULTI;\n  }\n\n  p_buf->len = 1;\n\n  // Now walk through the buffers putting the data into the response in order\n  list_t* list = NULL;\n  const list_node_t* node = NULL;\n  if (!fixed_queue_is_empty(p_cmd->multi_rsp_q)) {\n    list = fixed_queue_get_list(p_cmd->multi_rsp_q);\n  }\n  for (ii = 0; ii < p_cmd->multi_req.num_handles; ii++) {\n    tGATTS_RSP* p_rsp = NULL;\n\n    if (list != NULL) {\n      if (ii == 0) {\n        node = list_begin(list);\n      } else {\n        node = list_next(node);\n      }\n      if (node != list_end(list)) {\n        p_rsp = (tGATTS_RSP*)list_node(node);\n      }\n    }\n\n    if (p_rsp != NULL) {\n      total_len = p_buf->len;\n      if (p_cmd->multi_req.variable_len) {\n        total_len += 2;\n      }\n\n      if (total_len > mtu) {\n        log::verbose(\"Buffer space not enough for this data item, skipping\");\n        break;\n      }\n\n      len = std::min((size_t)p_rsp->attr_value.len, mtu - total_len);\n\n      if (total_len == mtu && p_rsp->attr_value.len > 0) {\n        log::verbose(\"Buffer space not enough for this data item, skipping\");\n        break;\n      }\n\n      if (len < p_rsp->attr_value.len) {\n        is_overflow = true;\n        log::verbose(\"multi read overflow available len={} val_len={}\", len, p_rsp->attr_value.len);\n      }\n\n      if (p_cmd->multi_req.variable_len) {\n        UINT16_TO_STREAM(p, (uint16_t)len);\n        p_buf->len += 2;\n      }\n\n      if (p_rsp->attr_value.handle == p_cmd->multi_req.handles[ii]) {\n        ARRAY_TO_STREAM(p, p_rsp->attr_value.value, (uint16_t)len);\n        p_buf->len += (uint16_t)len;\n      } else {\n        p_cmd->status = GATT_NOT_FOUND;\n        break;\n      }\n\n      if (is_overflow) {\n        break;\n      }\n\n    } else {\n      p_cmd->status = GATT_NOT_FOUND;\n      break;\n    }\n\n  } /* loop through all handles*/\n\n  /* Sanity check on the buffer length */\n  if (p_buf->len == 0) {\n    log::error(\"nothing found!!\");\n    p_cmd->status = GATT_NOT_FOUND;\n    osi_free(p_buf);\n    log::verbose(\"osi_free(p_buf)\");\n  } else if (p_cmd->p_rsp_msg != NULL) {\n    osi_free(p_buf);\n  } else {\n    p_cmd->p_rsp_msg = p_buf;\n  }\n}\n\n/*******************************************************************************\n *\n * Function         process_read_multi_rsp\n *\n * Description      This function check the read multiple response.\n *\n * Returns          bool    if all replies have been received\n *\n ******************************************************************************/\nstatic bool process_read_multi_rsp(tGATT_SR_CMD* p_cmd, tGATT_STATUS status, tGATTS_RSP* p_msg,\n                                   uint16_t mtu) {\n  log::verbose(\"status={} mtu={}\", status, mtu);\n\n  if (p_cmd->multi_rsp_q == NULL) {\n    p_cmd->multi_rsp_q = fixed_queue_new(SIZE_MAX);\n  }\n\n  /* Enqueue the response */\n  BT_HDR* p_buf = (BT_HDR*)osi_malloc(sizeof(tGATTS_RSP));\n  memcpy((void*)p_buf, (const void*)p_msg, sizeof(tGATTS_RSP));\n  fixed_queue_enqueue(p_cmd->multi_rsp_q, p_buf);\n\n  p_cmd->status = status;\n  if (status == GATT_SUCCESS) {\n    log::verbose(\"Multi read count={} num_hdls={} variable={}\",\n                 fixed_queue_length(p_cmd->multi_rsp_q), p_cmd->multi_req.num_handles,\n                 p_cmd->multi_req.variable_len);\n    /* Wait till we get all the responses */\n    if (fixed_queue_length(p_cmd->multi_rsp_q) == p_cmd->multi_req.num_handles) {\n      build_read_multi_rsp(p_cmd, mtu);\n      return true;\n    }\n  } else /* any handle read exception occurs, return error */\n  {\n    return true;\n  }\n\n  /* If here, still waiting */\n  return false;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_process_app_rsp\n *\n * Description      This function checks whether the response message from\n *                  application matches any pending request.\n *\n * Returns          void\n *\n ******************************************************************************/\ntGATT_STATUS gatt_sr_process_app_rsp(tGATT_TCB& tcb, tGATT_IF gatt_if, uint32_t /* trans_id */,\n                                     uint8_t op_code, tGATT_STATUS status, tGATTS_RSP* p_msg,\n                                     tGATT_SR_CMD* sr_res_p) {\n  tGATT_STATUS ret_code = GATT_SUCCESS;\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, sr_res_p->cid);\n\n  log::verbose(\"gatt_if={}\", gatt_if);\n\n  gatt_sr_update_cback_cnt(tcb, sr_res_p->cid, gatt_if, false, false);\n\n  if ((op_code == GATT_REQ_READ_MULTI) || (op_code == GATT_REQ_READ_MULTI_VAR)) {\n    /* If no error and still waiting, just return */\n    if (!process_read_multi_rsp(sr_res_p, status, p_msg, payload_size)) {\n      return GATT_SUCCESS;\n    }\n  } else {\n    if (op_code == GATT_REQ_PREPARE_WRITE && status == GATT_SUCCESS) {\n      gatt_sr_update_prep_cnt(tcb, gatt_if, true, false);\n    }\n\n    if (op_code == GATT_REQ_EXEC_WRITE && status != GATT_SUCCESS) {\n      gatt_sr_reset_cback_cnt(tcb, sr_res_p->cid);\n    }\n\n    sr_res_p->status = status;\n\n    if (gatt_sr_is_cback_cnt_zero(tcb) && status == GATT_SUCCESS) {\n      if (sr_res_p->p_rsp_msg == NULL) {\n        sr_res_p->p_rsp_msg =\n                attp_build_sr_msg(tcb, (uint8_t)(op_code + 1), (tGATT_SR_MSG*)p_msg, payload_size);\n      } else {\n        log::error(\"Exception!!! already has respond message\");\n      }\n    }\n  }\n  if (gatt_sr_is_cback_cnt_zero(tcb)) {\n    if ((sr_res_p->status == GATT_SUCCESS) && (sr_res_p->p_rsp_msg)) {\n      ret_code = attp_send_sr_msg(tcb, sr_res_p->cid, sr_res_p->p_rsp_msg);\n      sr_res_p->p_rsp_msg = NULL;\n    } else {\n      ret_code = gatt_send_error_rsp(tcb, sr_res_p->cid, status, op_code, sr_res_p->handle, false);\n    }\n\n    gatt_dequeue_sr_cmd(tcb, sr_res_p->cid);\n  }\n\n  log::verbose(\"ret_code={}\", ret_code);\n\n  return ret_code;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_exec_write_req\n *\n * Description      This function is called to process the execute write request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_exec_write_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code, uint16_t len,\n                                 uint8_t* p_data) {\n  uint8_t *p = p_data, flag, i = 0;\n  uint32_t trans_id = 0;\n  tGATT_IF gatt_if;\n  uint16_t conn_id;\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    log::verbose(\"Conformance tst: forced err rspv for Execute Write: error status={}\",\n                 gatt_cb.err_status);\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code, gatt_cb.handle, false);\n\n    return;\n  }\n#endif\n\n  if (len < sizeof(flag)) {\n    log::error(\"invalid length\");\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_EXEC_WRITE, 0, false);\n    return;\n  }\n\n  STREAM_TO_UINT8(flag, p);\n\n  /* mask the flag */\n  flag &= GATT_PREP_WRITE_EXEC;\n\n  /* no prep write is queued */\n  if (!gatt_sr_is_prep_cnt_zero(tcb)) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, 0);\n    gatt_sr_copy_prep_cnt_to_cback_cnt(tcb);\n\n    if (com::android::bluetooth::flags::gatt_client_dynamic_allocation()) {\n      auto prep_cnt_it = tcb.prep_cnt_map.begin();\n      while (prep_cnt_it != tcb.prep_cnt_map.end()) {\n        gatt_if = i;\n        conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_if);\n        tGATTS_DATA gatts_data;\n        gatts_data.exec_write = flag;\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_WRITE_EXEC, &gatts_data);\n        prep_cnt_it = tcb.prep_cnt_map.erase(prep_cnt_it);\n      }\n    } else {\n      for (i = 0; i < GATT_MAX_APPS; i++) {\n        if (tcb.prep_cnt[i]) {\n          gatt_if = (tGATT_IF)(i + 1);\n          conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_if);\n          tGATTS_DATA gatts_data;\n          gatts_data.exec_write = flag;\n          gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_WRITE_EXEC, &gatts_data);\n          tcb.prep_cnt[i] = 0;\n        }\n      }\n    }\n  } else /* nothing needs to be executed , send response now */\n  {\n    log::error(\"gatt_process_exec_write_req: no prepare write pending\");\n    gatt_send_error_rsp(tcb, cid, GATT_ERROR, GATT_REQ_EXEC_WRITE, 0, false);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_read_multi_req\n *\n * Description      This function is called to process the read multiple request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_read_multi_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code, uint16_t len,\n                                 uint8_t* p_data) {\n  uint32_t trans_id;\n  uint16_t handle = 0, ll = len;\n  uint8_t* p = p_data;\n  tGATT_STATUS err = GATT_SUCCESS;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n\n  log::verbose(\"\");\n\n  tGATT_READ_MULTI* multi_req = gatt_sr_get_read_multi(tcb, cid);\n  if (multi_req == nullptr) {\n    log::error(\"Could not proceed request. {}, 0x{:02x}\", tcb.peer_bda, cid);\n    return;\n  }\n  multi_req->num_handles = 0;\n  multi_req->variable_len = (op_code == GATT_REQ_READ_MULTI_VAR);\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    log::verbose(\"Conformance tst: forced err rspvofr ReadMultiple: error status={}\",\n                 gatt_cb.err_status);\n\n    STREAM_TO_UINT16(handle, p);\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code, handle, false);\n\n    return;\n  }\n#endif\n\n  while (ll >= 2 && multi_req->num_handles < GATT_MAX_READ_MULTI_HANDLES) {\n    STREAM_TO_UINT16(handle, p);\n\n    auto it = gatt_sr_find_i_rcb_by_handle(handle);\n    if (it != gatt_cb.srv_list_info->end()) {\n      multi_req->handles[multi_req->num_handles++] = handle;\n\n      /* check read permission */\n      err = gatts_read_attr_perm_check(it->p_db, false, handle, sec_flag, key_size);\n      if (err != GATT_SUCCESS) {\n        log::verbose(\"read permission denied : 0x{:02x}\", err);\n        break;\n      }\n    } else {\n      /* invalid handle */\n      err = GATT_INVALID_HANDLE;\n      break;\n    }\n    ll -= 2;\n  }\n\n  if (ll != 0) {\n    log::error(\"max attribute handle reached in ReadMultiple Request.\");\n  }\n\n  if (multi_req->num_handles == 0) {\n    err = GATT_INVALID_HANDLE;\n  }\n\n  if (err == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, multi_req->handles[0]);\n    if (trans_id != 0) {\n      tGATT_SR_CMD* sr_cmd_p = gatt_sr_get_cmd_by_cid(tcb, cid);\n      if (sr_cmd_p == nullptr) {\n        log::error(\"Could not send response on CID were request arrived. {}, 0x{:02x}\",\n                   tcb.peer_bda, cid);\n        return;\n      }\n      gatt_sr_reset_cback_cnt(tcb, cid); /* read multiple use multi_rsp_q's count*/\n\n      for (ll = 0; ll < multi_req->num_handles; ll++) {\n        tGATTS_RSP* p_msg = (tGATTS_RSP*)osi_calloc(sizeof(tGATTS_RSP));\n        handle = multi_req->handles[ll];\n        auto it = gatt_sr_find_i_rcb_by_handle(handle);\n\n        p_msg->attr_value.handle = handle;\n        err = gatts_read_attr_value_by_handle(tcb, cid, it->p_db, op_code, handle, 0,\n                                              p_msg->attr_value.value, &p_msg->attr_value.len,\n                                              GATT_MAX_ATTR_LEN, sec_flag, key_size, trans_id);\n\n        if (err == GATT_SUCCESS) {\n          gatt_sr_process_app_rsp(tcb, it->gatt_if, trans_id, op_code, GATT_SUCCESS, p_msg,\n                                  sr_cmd_p);\n        }\n        /* either not using or done using the buffer, release it now */\n        osi_free(p_msg);\n      }\n    } else {\n      err = GATT_NO_RESOURCES;\n    }\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (err != GATT_SUCCESS && err != GATT_PENDING && err != GATT_BUSY) {\n    gatt_send_error_rsp(tcb, cid, err, op_code, handle, false);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatt_build_primary_service_rsp\n *\n * Description      Primamry service request processed internally. Theretically\n *                  only deal with ReadByTypeValue and ReadByGroupType.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic tGATT_STATUS gatt_build_primary_service_rsp(BT_HDR* p_msg, tGATT_TCB& tcb, uint16_t cid,\n                                                   uint8_t op_code, uint16_t s_hdl, uint16_t e_hdl,\n                                                   uint8_t* /* p_data */, const Uuid& value) {\n  tGATT_STATUS status = GATT_NOT_FOUND;\n  uint8_t handle_len = 4;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl < s_hdl || el.s_hdl > e_hdl || el.type != GATT_UUID_PRI_SERVICE) {\n      continue;\n    }\n\n    Uuid* p_uuid = gatts_get_service_uuid(el.p_db);\n    if (!p_uuid) {\n      continue;\n    }\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n      handle_len = 4 + gatt_build_uuid_to_stream_len(*p_uuid);\n    }\n\n    /* get the length byte in the repsonse */\n    if (p_msg->offset == 0) {\n      *p++ = op_code + 1;\n      p_msg->len++;\n      p_msg->offset = handle_len;\n\n      if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n        *p++ = (uint8_t)p_msg->offset; /* length byte */\n        p_msg->len++;\n      }\n    }\n\n    if (p_msg->len + p_msg->offset > payload_size || handle_len != p_msg->offset) {\n      break;\n    }\n\n    if (op_code == GATT_REQ_FIND_TYPE_VALUE && value != *p_uuid) {\n      continue;\n    }\n\n    UINT16_TO_STREAM(p, el.s_hdl);\n\n    if (gatt_cb.last_service_handle && gatt_cb.last_service_handle == el.s_hdl) {\n      log::verbose(\"Use 0xFFFF for the last primary attribute\");\n      /* see GATT ERRATA 4065, 4063, ATT ERRATA 4062 */\n      UINT16_TO_STREAM(p, 0xFFFF);\n    } else {\n      UINT16_TO_STREAM(p, el.e_hdl);\n    }\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n      gatt_build_uuid_to_stream(&p, *p_uuid);\n    }\n\n    status = GATT_SUCCESS;\n    p_msg->len += p_msg->offset;\n  }\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  return status;\n}\n\n/**\n * fill the find information response information in the given buffer.\n *\n * Returns          true: if data filled sucessfully.\n *                  false: packet full, or format mismatch.\n */\nstatic tGATT_STATUS gatt_build_find_info_rsp(tGATT_SRV_LIST_ELEM& el, BT_HDR* p_msg, uint16_t& len,\n                                             uint16_t s_hdl, uint16_t e_hdl) {\n  uint8_t info_pair_len[2] = {4, 18};\n\n  if (!el.p_db) {\n    return GATT_NOT_FOUND;\n  }\n\n  /* check the attribute database */\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET + p_msg->len;\n\n  tGATT_STATUS status = GATT_NOT_FOUND;\n  for (auto& attr : el.p_db->attr_list) {\n    if (attr.handle > e_hdl) {\n      break;\n    }\n\n    if (attr.handle < s_hdl) {\n      continue;\n    }\n\n    uint8_t uuid_len = attr.uuid.GetShortestRepresentationSize();\n    if (p_msg->offset == 0) {\n      p_msg->offset =\n              (uuid_len == Uuid::kNumBytes16) ? GATT_INFO_TYPE_PAIR_16 : GATT_INFO_TYPE_PAIR_128;\n    }\n\n    if (len < info_pair_len[p_msg->offset - 1]) {\n      return GATT_NO_RESOURCES;\n    }\n\n    if (p_msg->offset == GATT_INFO_TYPE_PAIR_16 && uuid_len == Uuid::kNumBytes16) {\n      UINT16_TO_STREAM(p, attr.handle);\n      UINT16_TO_STREAM(p, attr.uuid.As16Bit());\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 && uuid_len == Uuid::kNumBytes128) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 && uuid_len == Uuid::kNumBytes32) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else {\n      log::error(\"format mismatch\");\n      return GATT_NO_RESOURCES;\n      /* format mismatch */\n    }\n    p_msg->len += info_pair_len[p_msg->offset - 1];\n    len -= info_pair_len[p_msg->offset - 1];\n    status = GATT_SUCCESS;\n  }\n\n  return status;\n}\n\nstatic tGATT_STATUS read_handles(uint16_t& len, uint8_t*& p, uint16_t& s_hdl, uint16_t& e_hdl) {\n  if (len < 4) {\n    return GATT_INVALID_PDU;\n  }\n\n  /* obtain starting handle, and ending handle */\n  STREAM_TO_UINT16(s_hdl, p);\n  STREAM_TO_UINT16(e_hdl, p);\n  len -= 4;\n\n  if (s_hdl > e_hdl || !GATT_HANDLE_IS_VALID(s_hdl) || !GATT_HANDLE_IS_VALID(e_hdl)) {\n    return GATT_INVALID_HANDLE;\n  }\n\n  return GATT_SUCCESS;\n}\n\nstatic tGATT_STATUS gatts_validate_packet_format(uint8_t op_code, uint16_t& len, uint8_t*& p,\n                                                 Uuid* p_uuid, uint16_t& s_hdl, uint16_t& e_hdl) {\n  tGATT_STATUS ret = read_handles(len, p, s_hdl, e_hdl);\n  if (ret != GATT_SUCCESS) {\n    return ret;\n  }\n\n  if (len < 2) {\n    return GATT_INVALID_PDU;\n  }\n\n  /* parse uuid now */\n  log::assert_that(p_uuid != nullptr, \"assert failed: p_uuid != nullptr\");\n  uint16_t uuid_len = (op_code == GATT_REQ_FIND_TYPE_VALUE) ? 2 : len;\n  if (!gatt_parse_uuid_from_cmd(p_uuid, uuid_len, &p)) {\n    log::verbose(\"Bad UUID\");\n    return GATT_INVALID_PDU;\n  }\n\n  len -= uuid_len;\n  return GATT_SUCCESS;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_primary_service_req\n *\n * Description      Process ReadByGroupType/ReadByTypeValue request, for\n *                  discovering all primary services or discover primary service\n *                  by UUID request.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code, uint16_t len,\n                                       uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  Uuid uuid = Uuid::kEmpty;\n\n  uint8_t reason = gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  if (uuid != Uuid::From16Bit(GATT_UUID_PRI_SERVICE)) {\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n      gatt_send_error_rsp(tcb, cid, GATT_UNSUPPORT_GRP_TYPE, op_code, s_hdl, false);\n      log::verbose(\"unexpected ReadByGrpType Group: {}\", uuid.ToString());\n      return;\n    }\n\n    // we do not support ReadByTypeValue with any non-primamry_service type\n    gatt_send_error_rsp(tcb, cid, GATT_NOT_FOUND, op_code, s_hdl, false);\n    log::verbose(\"unexpected ReadByTypeValue type: {}\", uuid.ToString());\n    return;\n  }\n\n  // TODO: we assume theh value is UUID, there is no such requirement in spec\n  Uuid value = Uuid::kEmpty;\n  if (op_code == GATT_REQ_FIND_TYPE_VALUE) {\n    if (!gatt_parse_uuid_from_cmd(&value, len, &p_data)) {\n      gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, s_hdl, false);\n    }\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  uint16_t msg_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n  reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl, e_hdl, p_data, value);\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_find_info\n *\n * Description      process find information request, for discover character\n *                  descriptors.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code, uint16_t len,\n                                    uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  uint8_t reason = read_handles(len, p_data, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  uint16_t buf_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n  reason = GATT_NOT_FOUND;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n  *p++ = op_code + 1;\n  p_msg->len = 2;\n\n  buf_len = payload_size - 2;\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl <= e_hdl && el.e_hdl >= s_hdl) {\n      reason = gatt_build_find_info_rsp(el, p_msg, buf_len, s_hdl, e_hdl);\n      if (reason == GATT_NO_RESOURCES) {\n        reason = GATT_SUCCESS;\n        break;\n      }\n    }\n  }\n\n  *p = (uint8_t)p_msg->offset;\n\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n  } else {\n    attp_send_sr_msg(tcb, cid, p_msg);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_mtu_req\n *\n * Description      This function is called to process excahnge MTU request.\n *                  Only used on LE.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_mtu_req(tGATT_TCB& tcb, uint16_t cid, uint16_t len, uint8_t* p_data) {\n  /* BR/EDR conenction, send error response */\n  if (cid != L2CAP_ATT_CID) {\n    gatt_send_error_rsp(tcb, cid, GATT_REQ_NOT_SUPPORTED, GATT_REQ_MTU, 0, false);\n    return;\n  }\n\n  if (len < GATT_MTU_REQ_MIN_LEN) {\n    log::error(\"invalid MTU request PDU received.\");\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_MTU, 0, false);\n    return;\n  }\n\n  tGATT_SR_MSG gatt_sr_msg;\n\n  uint16_t mtu = 0;\n  uint8_t* p = p_data;\n  STREAM_TO_UINT16(mtu, p);\n  /* mtu must be greater than default MTU which is 23/48 */\n  if (mtu < GATT_DEF_BLE_MTU_SIZE) {\n    tcb.payload_size = GATT_DEF_BLE_MTU_SIZE;\n  } else {\n    tcb.payload_size = std::min(mtu, (uint16_t)(gatt_get_local_mtu()));\n  }\n\n  /* Always say to remote our default MTU. */\n  gatt_sr_msg.mtu = gatt_get_local_mtu();\n\n  log::info(\"MTU {} request from remote ({}), resulted MTU {}\", mtu, tcb.peer_bda,\n            tcb.payload_size);\n\n  if (get_btm_client_interface().ble.BTM_SetBleDataLength(\n              tcb.peer_bda, tcb.payload_size + L2CAP_PKT_OVERHEAD) != tBTM_STATUS::BTM_SUCCESS) {\n    log::warn(\"Unable to set BLE data length peer:{} mtu:{}\", tcb.peer_bda,\n              tcb.payload_size + L2CAP_PKT_OVERHEAD);\n  }\n\n  BT_HDR* p_buf = attp_build_sr_msg(tcb, GATT_RSP_MTU, &gatt_sr_msg, GATT_DEF_BLE_MTU_SIZE);\n  attp_send_sr_msg(tcb, cid, p_buf);\n\n  bluetooth::shim::arbiter::GetArbiter().OnIncomingMtuReq(tcb.tcb_idx, tcb.payload_size);\n\n  tGATTS_DATA gatts_data;\n  gatts_data.mtu = tcb.payload_size;\n  /* Notify all registered application with new MTU size. Use a transaction ID */\n  /* of 0, as no response is allowed from applications */\n  if (com::android::bluetooth::flags::gatt_client_dynamic_allocation()) {\n    for (auto& [i, p_reg] : gatt_cb.cl_rcb_map) {\n      if (p_reg->in_use) {\n        uint16_t conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, p_reg->gatt_if);\n        gatt_sr_send_req_callback(conn_id, 0, GATTS_REQ_TYPE_MTU, &gatts_data);\n      }\n    }\n  } else {\n    for (int i = 0; i < GATT_MAX_APPS; i++) {\n      if (gatt_cb.cl_rcb[i].in_use) {\n        uint16_t conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_cb.cl_rcb[i].gatt_if);\n        gatt_sr_send_req_callback(conn_id, 0, GATTS_REQ_TYPE_MTU, &gatts_data);\n      }\n    }\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_read_by_type_req\n *\n * Description      process Read By type request.\n *                  This PDU can be used to perform:\n *                  - read characteristic value\n *                  - read characteristic descriptor value\n *                  - discover characteristic\n *                  - discover characteristic by UUID\n *                  - relationship discovery\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                           uint16_t len, uint8_t* p_data) {\n  Uuid uuid = Uuid::kEmpty;\n  uint16_t s_hdl = 0, e_hdl = 0, err_hdl = 0;\n  tGATT_STATUS reason = gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    log::verbose(\"Conformance tst: forced err rsp for ReadByType: error status={}\",\n                 gatt_cb.err_status);\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code, s_hdl, false);\n\n    return;\n  }\n#endif\n\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  *p++ = op_code + 1;\n  /* reserve length byte */\n  p_msg->len = 2;\n  uint16_t buf_len = payload_size - 2;\n\n  reason = GATT_NOT_FOUND;\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl <= e_hdl && el.e_hdl >= s_hdl) {\n      tGATT_SEC_FLAG sec_flag;\n      uint8_t key_size;\n      gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n      tGATT_STATUS ret =\n              gatts_db_read_attr_value_by_type(tcb, cid, el.p_db, op_code, p_msg, s_hdl, e_hdl,\n                                               uuid, &buf_len, sec_flag, key_size, 0, &err_hdl);\n      if (ret != GATT_NOT_FOUND) {\n        reason = ret;\n        if (ret == GATT_NO_RESOURCES) {\n          reason = GATT_SUCCESS;\n        }\n      }\n\n      if (ret != GATT_SUCCESS && ret != GATT_NOT_FOUND) {\n        s_hdl = err_hdl;\n        break;\n      }\n    }\n  }\n  *p = (uint8_t)p_msg->offset;\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n\n    /* in theroy BUSY is not possible(should already been checked), protected\n     * check */\n    if (reason != GATT_PENDING && reason != GATT_BUSY) {\n      gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    }\n\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/**\n * This function is called to process the write request from client.\n */\nstatic void gatts_process_write_req(tGATT_TCB& tcb, uint16_t cid, tGATT_SRV_LIST_ELEM& el,\n                                    uint16_t handle, uint8_t op_code, uint16_t len, uint8_t* p_data,\n                                    bt_gatt_db_attribute_type_t gatt_type) {\n  tGATTS_DATA sr_data;\n  uint32_t trans_id;\n  tGATT_STATUS status;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size, *p = p_data;\n  uint16_t conn_id;\n\n  memset(&sr_data, 0, sizeof(tGATTS_DATA));\n\n  switch (op_code) {\n    case GATT_REQ_PREPARE_WRITE:\n      if (len < 2 || p == nullptr) {\n        log::error(\"Prepare write request was invalid - missing offset, sending error response\");\n        gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, handle, false);\n        return;\n      }\n      sr_data.write_req.is_prep = true;\n      STREAM_TO_UINT16(sr_data.write_req.offset, p);\n      len -= 2;\n      FALLTHROUGH_INTENDED; /* FALLTHROUGH */\n    case GATT_SIGN_CMD_WRITE:\n      if (op_code == GATT_SIGN_CMD_WRITE) {\n        log::verbose(\"Write CMD with data sigining\");\n        len -= GATT_AUTH_SIGN_LEN;\n      }\n      FALLTHROUGH_INTENDED; /* FALLTHROUGH */\n    case GATT_CMD_WRITE:\n    case GATT_REQ_WRITE:\n      if (op_code == GATT_REQ_WRITE || op_code == GATT_REQ_PREPARE_WRITE) {\n        sr_data.write_req.need_rsp = true;\n      }\n      sr_data.write_req.handle = handle;\n      if (len > GATT_MAX_ATTR_LEN) {\n        len = GATT_MAX_ATTR_LEN;\n      }\n      sr_data.write_req.len = len;\n      if (len != 0 && p != nullptr) {\n        memcpy(sr_data.write_req.value, p, len);\n      }\n      break;\n  }\n\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n  status = gatts_write_attr_perm_check(el.p_db, op_code, handle, sr_data.write_req.offset, p, len,\n                                       sec_flag, key_size);\n\n  if (status == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, handle);\n    if (trans_id != 0) {\n      conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, el.gatt_if);\n\n      uint8_t opcode = 0;\n      if (gatt_type == BTGATT_DB_DESCRIPTOR) {\n        opcode = GATTS_REQ_TYPE_WRITE_DESCRIPTOR;\n      } else if (gatt_type == BTGATT_DB_CHARACTERISTIC) {\n        opcode = GATTS_REQ_TYPE_WRITE_CHARACTERISTIC;\n      } else {\n        log::error(\n                \"Attempt to write attribute that's not tied with \"\n                \"characteristic or descriptor value.\");\n        status = GATT_ERROR;\n      }\n\n      if (opcode) {\n        gatt_sr_send_req_callback(conn_id, trans_id, opcode, &sr_data);\n        status = GATT_PENDING;\n      }\n    } else {\n      log::error(\"max pending command, send error\");\n      status = GATT_BUSY; /* max pending command, application error */\n    }\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (status != GATT_PENDING && status != GATT_BUSY &&\n      (op_code == GATT_REQ_PREPARE_WRITE || op_code == GATT_REQ_WRITE)) {\n    gatt_send_error_rsp(tcb, cid, status, op_code, handle, false);\n  }\n  return;\n}\n\n/**\n * This function is called to process the read request from client.\n */\nstatic void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid, tGATT_SRV_LIST_ELEM& el,\n                                   uint8_t op_code, uint16_t handle, uint16_t len,\n                                   uint8_t* p_data) {\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  uint16_t offset = 0;\n\n  if (op_code == GATT_REQ_READ_BLOB && len < sizeof(uint16_t)) {\n    /* Error: packet length is too short */\n    log::error(\"packet length={} too short. min={}\", len, sizeof(uint16_t));\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, 0, false);\n    return;\n  }\n\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n\n  if (op_code == GATT_REQ_READ_BLOB) {\n    STREAM_TO_UINT16(offset, p_data);\n  }\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n  *p++ = op_code + 1;\n  p_msg->len = 1;\n  buf_len = payload_size - 1;\n\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n  uint16_t value_len = 0;\n  tGATT_STATUS reason =\n          gatts_read_attr_value_by_handle(tcb, cid, el.p_db, op_code, handle, offset, p, &value_len,\n                                          (uint16_t)buf_len, sec_flag, key_size, 0);\n  p_msg->len += value_len;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n\n    /* in theory BUSY is not possible(should already been checked), protected\n     * check */\n    if (reason != GATT_PENDING && reason != GATT_BUSY) {\n      gatt_send_error_rsp(tcb, cid, reason, op_code, handle, false);\n    }\n\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_attribute_req\n *\n * Description      This function is called to process the per attribute handle\n *                  request from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_attribute_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code, uint16_t len,\n                                 uint8_t* p_data) {\n  uint16_t handle = 0;\n  uint8_t* p = p_data;\n  tGATT_STATUS status = GATT_INVALID_HANDLE;\n\n  if (len < 2) {\n    log::error(\"Illegal PDU length, discard request\");\n    status = GATT_INVALID_PDU;\n  } else {\n    STREAM_TO_UINT16(handle, p);\n    len -= 2;\n  }\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  gatt_cb.handle = handle;\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    log::verbose(\"Conformance tst: forced err rsp: error status={}\", gatt_cb.err_status);\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, cid, gatt_cb.req_op_code, handle, false);\n\n    return;\n  }\n#endif\n\n  if (GATT_HANDLE_IS_VALID(handle)) {\n    for (auto& el : *gatt_cb.srv_list_info) {\n      if (el.s_hdl <= handle && el.e_hdl >= handle) {\n        for (const auto& attr : el.p_db->attr_list) {\n          if (attr.handle == handle) {\n            switch (op_code) {\n              case GATT_REQ_READ: /* read char/char descriptor value */\n              case GATT_REQ_READ_BLOB:\n                gatts_process_read_req(tcb, cid, el, op_code, handle, len, p);\n                break;\n\n              case GATT_REQ_WRITE: /* write char/char descriptor value */\n              case GATT_CMD_WRITE:\n              case GATT_SIGN_CMD_WRITE:\n              case GATT_REQ_PREPARE_WRITE:\n                gatts_process_write_req(tcb, cid, el, handle, op_code, len, p, attr.gatt_type);\n                break;\n              default:\n                break;\n            }\n            status = GATT_SUCCESS;\n            break;\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  if (status != GATT_SUCCESS && op_code != GATT_CMD_WRITE && op_code != GATT_SIGN_CMD_WRITE) {\n    gatt_send_error_rsp(tcb, cid, status, op_code, handle, false);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_proc_srv_chg_ind_ack\n *\n * Description      This function process the service changed indicaiton ACK\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_proc_srv_chg_ind_ack(tGATT_TCB tcb) {\n  tGATTS_SRV_CHG_REQ req;\n  tGATTS_SRV_CHG* p_buf = NULL;\n\n  log::verbose(\"\");\n\n  p_buf = gatt_is_bda_in_the_srv_chg_clt_list(tcb.peer_bda);\n  if (p_buf != NULL) {\n    log::verbose(\"NV update set srv chg = false\");\n    p_buf->srv_changed = false;\n    memcpy(&req.srv_chg, p_buf, sizeof(tGATTS_SRV_CHG));\n    if (gatt_cb.cb_info.p_srv_chg_callback) {\n      (*gatt_cb.cb_info.p_srv_chg_callback)(GATTS_SRV_CHG_CMD_UPDATE_CLIENT, &req, NULL);\n    }\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_chk_pending_ind\n *\n * Description      This function check any pending indication needs to be sent\n *                  if there is a pending indication then sent the indication\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_chk_pending_ind(tGATT_TCB& tcb) {\n  log::verbose(\"\");\n\n  tGATT_VALUE* p_buf = (tGATT_VALUE*)fixed_queue_try_peek_first(tcb.pending_ind_q);\n  if (p_buf != NULL) {\n    if (GATTS_HandleValueIndication(p_buf->conn_id, p_buf->handle, p_buf->len, p_buf->value) !=\n        GATT_SUCCESS) {\n      log::warn(\"Unable to send GATT server handle value conn_id:{}\", p_buf->conn_id);\n    }\n    osi_free(fixed_queue_try_remove_from_queue(tcb.pending_ind_q, p_buf));\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_proc_ind_ack\n *\n * Description      This function processes the Indication ack\n *\n * Returns          true continue to process the indication ack by the\n *                  application if the ACK is not a Service Changed Indication\n *\n ******************************************************************************/\nstatic bool gatts_proc_ind_ack(tGATT_TCB& tcb, uint16_t ack_handle) {\n  bool continue_processing = true;\n\n  log::verbose(\"ack handle={}\", ack_handle);\n\n  if (ack_handle == gatt_cb.handle_of_h_r) {\n    gatts_proc_srv_chg_ind_ack(tcb);\n    /* there is no need to inform the application since srv chg is handled\n     * internally by GATT */\n    continue_processing = false;\n\n    // After receiving ack of svc_chg_ind, reset client status\n    gatt_sr_update_cl_status(tcb, /* chg_aware= */ true);\n  }\n\n  gatts_chk_pending_ind(tcb);\n  return continue_processing;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_value_conf\n *\n * Description      This function is called to process the handle value\n *                  confirmation.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_value_conf(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code) {\n  uint16_t handle;\n\n  if (!gatt_tcb_find_indicate_handle(tcb, cid, &handle)) {\n    log::error(\"unexpected handle value confirmation\");\n    return;\n  }\n\n  gatt_stop_conf_timer(tcb, cid);\n\n  bool continue_processing = gatts_proc_ind_ack(tcb, handle);\n\n  if (continue_processing) {\n    tGATTS_DATA gatts_data;\n    gatts_data.handle = handle;\n    for (auto& el : *gatt_cb.srv_list_info) {\n      if (el.s_hdl <= handle && el.e_hdl >= handle) {\n        uint32_t trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, handle);\n        uint16_t conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, el.gatt_if);\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_CONF, &gatts_data);\n      }\n    }\n  }\n}\n\nstatic bool gatts_process_db_out_of_sync(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                         uint16_t len, uint8_t* p_data) {\n  if (gatt_sr_is_cl_change_aware(tcb)) {\n    return false;\n  }\n\n  // default value\n  bool should_ignore = true;\n  bool should_rsp = true;\n\n  switch (op_code) {\n    case GATT_REQ_READ_BY_TYPE: {\n      // Check if read database hash by UUID\n      Uuid uuid = Uuid::kEmpty;\n      uint16_t s_hdl = 0, e_hdl = 0;\n      uint16_t db_hash_handle = gatt_cb.handle_of_database_hash;\n      tGATT_STATUS reason = gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n      if (reason == GATT_SUCCESS && (s_hdl <= db_hash_handle && db_hash_handle <= e_hdl) &&\n          (uuid == Uuid::From16Bit(GATT_UUID_DATABASE_HASH))) {\n        should_ignore = false;\n      }\n\n    } break;\n    case GATT_REQ_READ: {\n      // Check if read database hash by handle\n      uint16_t handle = 0;\n      uint8_t* p = p_data;\n      tGATT_STATUS status = GATT_SUCCESS;\n\n      if (len < 2) {\n        status = GATT_INVALID_PDU;\n      } else {\n        STREAM_TO_UINT16(handle, p);\n        len -= 2;\n      }\n\n      if (status == GATT_SUCCESS && handle == gatt_cb.handle_of_database_hash) {\n        should_ignore = false;\n      }\n\n    } break;\n    case GATT_REQ_READ_BY_GRP_TYPE: /* discover primary services */\n    case GATT_REQ_FIND_TYPE_VALUE:  /* discover service by UUID */\n    case GATT_REQ_FIND_INFO:        /* discover char descrptor */\n    case GATT_REQ_READ_BLOB:        /* read long char */\n    case GATT_REQ_READ_MULTI:       /* read multi char*/\n    case GATT_REQ_WRITE:            /* write char/char descriptor value */\n    case GATT_REQ_PREPARE_WRITE:    /* write long char */\n      // Use default value\n      break;\n    case GATT_CMD_WRITE:      /* cmd */\n    case GATT_SIGN_CMD_WRITE: /* sign cmd */\n      should_rsp = false;\n      break;\n    case GATT_REQ_MTU:           /* configure mtu */\n    case GATT_REQ_EXEC_WRITE:    /* execute write */\n    case GATT_HANDLE_VALUE_CONF: /* confirm for indication */\n    default:\n      should_ignore = false;\n  }\n\n  if (should_ignore) {\n    if (should_rsp) {\n      gatt_send_error_rsp(tcb, cid, GATT_DATABASE_OUT_OF_SYNC, op_code, 0x0000, false);\n    }\n    log::info(\"database out of sync, device={}, op_code=0x{:x}, should_rsp={}\", tcb.peer_bda,\n              (uint16_t)op_code, should_rsp);\n    gatt_sr_update_cl_status(tcb, /* chg_aware= */ should_rsp);\n  }\n\n  return should_ignore;\n}\n\n/** This function is called to handle the client requests to server */\nvoid gatt_server_handle_client_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code, uint16_t len,\n                                   uint8_t* p_data) {\n  /* there is pending command, discard this one */\n  if (!gatt_sr_cmd_empty(tcb, cid) && op_code != GATT_HANDLE_VALUE_CONF) {\n    return;\n  }\n\n  /* the size of the message may not be bigger than the local max PDU size*/\n  /* The message has to be smaller than the agreed MTU, len does not include op\n   * code */\n\n  uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n  if (len >= payload_size) {\n    log::error(\"server receive invalid PDU size:{} pdu size:{}\", len + 1, payload_size);\n    /* for invalid request expecting response, send it now */\n    if (op_code != GATT_CMD_WRITE && op_code != GATT_SIGN_CMD_WRITE &&\n        op_code != GATT_HANDLE_VALUE_CONF) {\n      gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, 0, false);\n    }\n    /* otherwise, ignore the pkt */\n  } else {\n    // handle database out of sync\n    if (gatts_process_db_out_of_sync(tcb, cid, op_code, len, p_data)) {\n      return;\n    }\n\n    switch (op_code) {\n      case GATT_REQ_READ_BY_GRP_TYPE: /* discover primary services */\n      case GATT_REQ_FIND_TYPE_VALUE:  /* discover service by UUID */\n        gatts_process_primary_service_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_FIND_INFO: /* discover char descrptor */\n        gatts_process_find_info(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ_BY_TYPE: /* read characteristic value, char descriptor\n                                     value */\n        /* discover characteristic, discover char by UUID */\n        gatts_process_read_by_type_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ: /* read char/char descriptor value */\n      case GATT_REQ_READ_BLOB:\n      case GATT_REQ_WRITE: /* write char/char descriptor value */\n      case GATT_CMD_WRITE:\n      case GATT_SIGN_CMD_WRITE:\n      case GATT_REQ_PREPARE_WRITE:\n        gatts_process_attribute_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_HANDLE_VALUE_CONF:\n        gatts_process_value_conf(tcb, cid, op_code);\n        break;\n\n      case GATT_REQ_MTU:\n        gatts_process_mtu_req(tcb, cid, len, p_data);\n        break;\n\n      case GATT_REQ_EXEC_WRITE:\n        gatt_process_exec_write_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ_MULTI:\n      case GATT_REQ_READ_MULTI_VAR:\n        gatt_process_read_multi_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      default:\n        break;\n    }\n  }\n}\n```",
                        "downstream_file_content": "```cc\n/******************************************************************************\n *\n *  Copyright 2008-2012 Broadcom Corporation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at:\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n ******************************************************************************/\n\n/******************************************************************************\n *\n *  this file contains the GATT server functions\n *\n ******************************************************************************/\n#include <algorithm>\n#include <string.h>\n\n#include \"bt_target.h\"\n#include \"gatt_int.h\"\n#include \"l2c_api.h\"\n#include \"osi/include/allocator.h\"\n#include \"osi/include/log.h\"\n#include \"osi/include/osi.h\"\n#include \"stack/eatt/eatt.h\"\n#include \"stack/include/bt_hdr.h\"\n#include \"stack/include/bt_types.h\"\n#include \"stack/l2cap/l2c_int.h\"\n#include \"types/bluetooth/uuid.h\"\n#include <base/logging.h>\n\n#define GATT_MTU_REQ_MIN_LEN 2\n#define L2CAP_PKT_OVERHEAD 4\n\nusing base::StringPrintf;\nusing bluetooth::Uuid;\nusing bluetooth::eatt::EattExtension;\nusing bluetooth::eatt::EattChannel;\n\n/*******************************************************************************\n *\n * Function         gatt_sr_enqueue_cmd\n *\n * Description      This function enqueue the request from client which needs a\n *                  application response, and update the transaction ID.\n *\n * Returns          void\n *\n ******************************************************************************/\nuint32_t gatt_sr_enqueue_cmd(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                             uint16_t handle) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel =\n        EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  uint32_t trans_id = 0;\n\n  p_cmd->cid = cid;\n\n  if ((p_cmd->op_code == 0) ||\n      (op_code == GATT_HANDLE_VALUE_CONF)) /* no pending request */\n  {\n    if (op_code == GATT_CMD_WRITE || op_code == GATT_SIGN_CMD_WRITE ||\n        op_code == GATT_REQ_MTU || op_code == GATT_HANDLE_VALUE_CONF) {\n      trans_id = ++tcb.trans_id;\n    } else {\n      p_cmd->trans_id = ++tcb.trans_id;\n      p_cmd->op_code = op_code;\n      p_cmd->handle = handle;\n      p_cmd->status = GATT_NOT_FOUND;\n      tcb.trans_id %= GATT_TRANS_ID_MAX;\n      trans_id = p_cmd->trans_id;\n    }\n  }\n\n  return trans_id;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_cmd_empty\n *\n * Description      This function checks if the server command queue is empty.\n *\n * Returns          true if empty, false if there is pending command.\n *\n ******************************************************************************/\nbool gatt_sr_cmd_empty(tGATT_TCB& tcb, uint16_t cid) {\n  if (cid == tcb.att_lcid) return (tcb.sr_cmd.op_code == 0);\n\n  EattChannel* channel =\n      EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n\n  return (channel->server_outstanding_cmd_.op_code == 0);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_dequeue_sr_cmd\n *\n * Description      This function dequeue the request from command queue.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_dequeue_sr_cmd(tGATT_TCB& tcb, uint16_t cid) {\n  tGATT_SR_CMD* p_cmd;\n\n  if (cid == tcb.att_lcid) {\n    p_cmd = &tcb.sr_cmd;\n  } else {\n    EattChannel* channel =\n        EattExtension::GetInstance()->FindEattChannelByCid(tcb.peer_bda, cid);\n\n    p_cmd = &channel->server_outstanding_cmd_;\n  }\n\n  /* Double check in case any buffers are queued */\n  VLOG(1) << \"gatt_dequeue_sr_cmd cid: \" << loghex(cid);\n  if (p_cmd->p_rsp_msg)\n    LOG(ERROR) << \"free tcb.sr_cmd.p_rsp_msg = \"\n               << p_cmd->p_rsp_msg;\n  osi_free_and_reset((void**)&p_cmd->p_rsp_msg);\n\n  while (!fixed_queue_is_empty(p_cmd->multi_rsp_q))\n    osi_free(fixed_queue_try_dequeue(p_cmd->multi_rsp_q));\n  fixed_queue_free(p_cmd->multi_rsp_q, NULL);\n  memset(p_cmd, 0, sizeof(tGATT_SR_CMD));\n}\n\nstatic void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) {\n  uint16_t ii;\n  size_t total_len, len;\n  uint8_t* p;\n  bool is_overflow = false;\n\n  // We need at least one extra byte for the opcode\n  if (mtu == 0) {\n    LOG(ERROR) << \"Invalid MTU\";\n    p_cmd->status = GATT_ILLEGAL_PARAMETER;\n    return;\n  }\n\n  len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu;\n  BT_HDR* p_buf = (BT_HDR*)osi_calloc(len);\n  p_buf->offset = L2CAP_MIN_OFFSET;\n  p = (uint8_t*)(p_buf + 1) + p_buf->offset;\n\n  /* First byte in the response is the opcode */\n  if (p_cmd->multi_req.variable_len)\n    *p++ = GATT_RSP_READ_MULTI_VAR;\n  else\n    *p++ = GATT_RSP_READ_MULTI;\n\n  p_buf->len = 1;\n\n  /* Now walk through the buffers putting the data into the response in order\n   */\n  list_t* list = NULL;\n  const list_node_t* node = NULL;\n  if (!fixed_queue_is_empty(p_cmd->multi_rsp_q))\n    list = fixed_queue_get_list(p_cmd->multi_rsp_q);\n  for (ii = 0; ii < p_cmd->multi_req.num_handles; ii++) {\n    tGATTS_RSP* p_rsp = NULL;\n\n    if (list != NULL) {\n      if (ii == 0)\n        node = list_begin(list);\n      else\n        node = list_next(node);\n      if (node != list_end(list)) p_rsp = (tGATTS_RSP*)list_node(node);\n    }\n\n    if (p_rsp != NULL) {\n      total_len = p_buf->len;\n      if (p_cmd->multi_req.variable_len) {\n        total_len += 2;\n      }\n\n      if (total_len > mtu) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      len = std::min((size_t) p_rsp->attr_value.len, mtu - total_len);\n\n      if (total_len == mtu && p_rsp->attr_value.len > 0) {\n        VLOG(1) << \"Buffer space not enough for this data item, skipping\";\n        break;\n      }\n\n      if (len < p_rsp->attr_value.len) {\n        is_overflow = true;\n        VLOG(1) << StringPrintf(\n            \"multi read overflow available len=%zu val_len=%d\", len,\n            p_rsp->attr_value.len);\n      }\n\n      if (p_cmd->multi_req.variable_len) {\n        UINT16_TO_STREAM(p, (uint16_t) len);\n        p_buf->len += 2;\n      }\n\n      if (p_rsp->attr_value.handle == p_cmd->multi_req.handles[ii]) {\n        ARRAY_TO_STREAM(p, p_rsp->attr_value.value, (uint16_t) len);\n        p_buf->len += (uint16_t) len;\n      } else {\n        p_cmd->status = GATT_NOT_FOUND;\n        break;\n      }\n\n      if (is_overflow) break;\n\n    } else {\n      p_cmd->status = GATT_NOT_FOUND;\n      break;\n    }\n\n  } /* loop through all handles*/\n\n  /* Sanity check on the buffer length */\n  if (p_buf->len == 0) {\n    LOG(ERROR) << __func__ << \" nothing found!!\";\n    p_cmd->status = GATT_NOT_FOUND;\n    osi_free(p_buf);\n    VLOG(1) << __func__ << \"osi_free(p_buf)\";\n  } else if (p_cmd->p_rsp_msg != NULL) {\n    osi_free(p_buf);\n  } else {\n    p_cmd->p_rsp_msg = p_buf;\n  }\n}\n\n/*******************************************************************************\n *\n * Function         process_read_multi_rsp\n *\n * Description      This function check the read multiple response.\n *\n * Returns          bool    if all replies have been received\n *\n ******************************************************************************/\nstatic bool process_read_multi_rsp(tGATT_SR_CMD* p_cmd, tGATT_STATUS status,\n                                   tGATTS_RSP* p_msg, uint16_t mtu) {\n  VLOG(1) << StringPrintf(\"%s status=%d mtu=%d\", __func__, status, mtu);\n\n  if (p_cmd->multi_rsp_q == NULL)\n    p_cmd->multi_rsp_q = fixed_queue_new(SIZE_MAX);\n\n  /* Enqueue the response */\n  BT_HDR* p_buf = (BT_HDR*)osi_malloc(sizeof(tGATTS_RSP));\n  memcpy((void*)p_buf, (const void*)p_msg, sizeof(tGATTS_RSP));\n  fixed_queue_enqueue(p_cmd->multi_rsp_q, p_buf);\n\n  p_cmd->status = status;\n  if (status == GATT_SUCCESS) {\n    VLOG(1) << \"Multi read count=\" << fixed_queue_length(p_cmd->multi_rsp_q)\n            << \" num_hdls=\" << p_cmd->multi_req.num_handles\n            << \" variable=\" << p_cmd->multi_req.variable_len;\n    /* Wait till we get all the responses */\n    if (fixed_queue_length(p_cmd->multi_rsp_q) ==\n        p_cmd->multi_req.num_handles) {\n      build_read_multi_rsp(p_cmd, mtu);\n      return (true);\n    }\n  } else /* any handle read exception occurs, return error */\n  {\n    return (true);\n  }\n\n  /* If here, still waiting */\n  return (false);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_sr_process_app_rsp\n *\n * Description      This function checks whether the response message from\n *                  application matches any pending request.\n *\n * Returns          void\n *\n ******************************************************************************/\ntGATT_STATUS gatt_sr_process_app_rsp(tGATT_TCB& tcb, tGATT_IF gatt_if,\n                                     UNUSED_ATTR uint32_t trans_id,\n                                     uint8_t op_code, tGATT_STATUS status,\n                                     tGATTS_RSP* p_msg,\n                                     tGATT_SR_CMD* sr_res_p) {\n  tGATT_STATUS ret_code = GATT_SUCCESS;\n  uint16_t payload_size = gatt_tcb_get_payload_size_rx(tcb, sr_res_p->cid);\n\n  VLOG(1) << __func__ << \" gatt_if=\" << +gatt_if;\n\n  gatt_sr_update_cback_cnt(tcb, sr_res_p->cid, gatt_if, false, false);\n\n  if ((op_code == GATT_REQ_READ_MULTI) ||\n      (op_code == GATT_REQ_READ_MULTI_VAR)) {\n    /* If no error and still waiting, just return */\n    if (!process_read_multi_rsp(sr_res_p, status, p_msg, payload_size))\n      return (GATT_SUCCESS);\n  } else {\n    if (op_code == GATT_REQ_PREPARE_WRITE && status == GATT_SUCCESS)\n      gatt_sr_update_prep_cnt(tcb, gatt_if, true, false);\n\n    if (op_code == GATT_REQ_EXEC_WRITE && status != GATT_SUCCESS)\n      gatt_sr_reset_cback_cnt(tcb, sr_res_p->cid);\n\n    sr_res_p->status = status;\n\n    if (gatt_sr_is_cback_cnt_zero(tcb) && status == GATT_SUCCESS) {\n      if (sr_res_p->p_rsp_msg == NULL) {\n        sr_res_p->p_rsp_msg = attp_build_sr_msg(tcb, (uint8_t)(op_code + 1),\n                                                (tGATT_SR_MSG*)p_msg);\n      } else {\n        LOG(ERROR) << \"Exception!!! already has respond message\";\n      }\n    }\n  }\n  if (gatt_sr_is_cback_cnt_zero(tcb)) {\n    if ((sr_res_p->status == GATT_SUCCESS) && (sr_res_p->p_rsp_msg)) {\n      ret_code = attp_send_sr_msg(tcb, sr_res_p->cid, sr_res_p->p_rsp_msg);\n      sr_res_p->p_rsp_msg = NULL;\n    } else {\n      ret_code = gatt_send_error_rsp(tcb, sr_res_p->cid, status, op_code,\n                                     sr_res_p->handle, false);\n    }\n\n    gatt_dequeue_sr_cmd(tcb, sr_res_p->cid);\n  }\n\n  VLOG(1) << __func__ << \" ret_code=\" << +ret_code;\n\n  return ret_code;\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_exec_write_req\n *\n * Description      This function is called to process the execute write request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_exec_write_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint8_t *p = p_data, flag, i = 0;\n  uint32_t trans_id = 0;\n  tGATT_IF gatt_if;\n  uint16_t conn_id;\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1)\n        << \"Conformance tst: forced err rspv for Execute Write: error status=\"\n        << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        gatt_cb.handle, false);\n\n    return;\n  }\n#endif\n\n  if (len < sizeof(flag)) {\n    android_errorWriteLog(0x534e4554, \"73172115\");\n    LOG(ERROR) << __func__ << \"invalid length\";\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_EXEC_WRITE, 0,\n                        false);\n    return;\n  }\n\n  STREAM_TO_UINT8(flag, p);\n\n  /* mask the flag */\n  flag &= GATT_PREP_WRITE_EXEC;\n\n  /* no prep write is queued */\n  if (!gatt_sr_is_prep_cnt_zero(tcb)) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, 0);\n    gatt_sr_copy_prep_cnt_to_cback_cnt(tcb);\n\n    for (i = 0; i < GATT_MAX_APPS; i++) {\n      if (tcb.prep_cnt[i]) {\n        gatt_if = (tGATT_IF)(i + 1);\n        conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_if);\n        tGATTS_DATA gatts_data;\n        gatts_data.exec_write = flag;\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_WRITE_EXEC,\n                                  &gatts_data);\n        tcb.prep_cnt[i] = 0;\n      }\n    }\n  } else /* nothing needs to be executed , send response now */\n  {\n    LOG(ERROR) << \"gatt_process_exec_write_req: no prepare write pending\";\n    gatt_send_error_rsp(tcb, cid, GATT_ERROR, GATT_REQ_EXEC_WRITE, 0, false);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatt_process_read_multi_req\n *\n * Description      This function is called to process the read multiple request\n *                  from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatt_process_read_multi_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint32_t trans_id;\n  uint16_t handle = 0, ll = len;\n  uint8_t* p = p_data;\n  tGATT_STATUS err = GATT_SUCCESS;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n\n  VLOG(1) << __func__;\n\n  tGATT_READ_MULTI* multi_req = gatt_sr_get_read_multi(tcb, cid);\n  multi_req->num_handles = 0;\n  multi_req->variable_len = (op_code == GATT_REQ_READ_MULTI_VAR);\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rspvofr ReadMultiple: error status=\"\n            << +gatt_cb.err_status;\n\n    STREAM_TO_UINT16(handle, p);\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        handle, false);\n\n    return;\n  }\n#endif\n\n  while (ll >= 2 && multi_req->num_handles < GATT_MAX_READ_MULTI_HANDLES) {\n    STREAM_TO_UINT16(handle, p);\n\n    auto it = gatt_sr_find_i_rcb_by_handle(handle);\n    if (it != gatt_cb.srv_list_info->end()) {\n      multi_req->handles[multi_req->num_handles++] = handle;\n\n      /* check read permission */\n      err = gatts_read_attr_perm_check(it->p_db, false, handle, sec_flag,\n                                       key_size);\n      if (err != GATT_SUCCESS) {\n        VLOG(1) << StringPrintf(\"read permission denied : 0x%02x\", err);\n        break;\n      }\n    } else {\n      /* invalid handle */\n      err = GATT_INVALID_HANDLE;\n      break;\n    }\n    ll -= 2;\n  }\n\n  if (ll != 0) {\n    LOG(ERROR) << \"max attribute handle reached in ReadMultiple Request.\";\n  }\n\n  if (multi_req->num_handles == 0) err = GATT_INVALID_HANDLE;\n\n  if (err == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, multi_req->handles[0]);\n    if (trans_id != 0) {\n      tGATT_SR_CMD* sr_cmd_p = gatt_sr_get_cmd_by_cid(tcb, cid);\n\n      gatt_sr_reset_cback_cnt(tcb,\n                              cid); /* read multiple use multi_rsp_q's count*/\n\n      for (ll = 0; ll < multi_req->num_handles; ll++) {\n        tGATTS_RSP* p_msg = (tGATTS_RSP*)osi_calloc(sizeof(tGATTS_RSP));\n        handle = multi_req->handles[ll];\n        auto it = gatt_sr_find_i_rcb_by_handle(handle);\n\n        p_msg->attr_value.handle = handle;\n        err = gatts_read_attr_value_by_handle(\n            tcb, cid, it->p_db, op_code, handle, 0, p_msg->attr_value.value,\n            &p_msg->attr_value.len, GATT_MAX_ATTR_LEN, sec_flag, key_size,\n            trans_id);\n\n        if (err == GATT_SUCCESS) {\n          gatt_sr_process_app_rsp(tcb, it->gatt_if, trans_id, op_code,\n                                  GATT_SUCCESS, p_msg, sr_cmd_p);\n        }\n        /* either not using or done using the buffer, release it now */\n        osi_free(p_msg);\n      }\n    } else\n      err = GATT_NO_RESOURCES;\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (err != GATT_SUCCESS && err != GATT_PENDING && err != GATT_BUSY)\n    gatt_send_error_rsp(tcb, cid, err, op_code, handle, false);\n}\n\n/*******************************************************************************\n *\n * Function         gatt_build_primary_service_rsp\n *\n * Description      Primamry service request processed internally. Theretically\n *                  only deal with ReadByTypeVAlue and ReadByGroupType.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic tGATT_STATUS gatt_build_primary_service_rsp(\n    BT_HDR* p_msg, tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n    uint16_t s_hdl, uint16_t e_hdl, UNUSED_ATTR uint8_t* p_data,\n    const Uuid& value) {\n  tGATT_STATUS status = GATT_NOT_FOUND;\n  uint8_t handle_len = 4;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl < s_hdl || el.s_hdl > e_hdl ||\n        el.type != GATT_UUID_PRI_SERVICE) {\n      continue;\n    }\n\n    Uuid* p_uuid = gatts_get_service_uuid(el.p_db);\n    if (!p_uuid) continue;\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE)\n      handle_len = 4 + gatt_build_uuid_to_stream_len(*p_uuid);\n\n    /* get the length byte in the repsonse */\n    if (p_msg->offset == 0) {\n      *p++ = op_code + 1;\n      p_msg->len++;\n      p_msg->offset = handle_len;\n\n      if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n        *p++ = (uint8_t)p_msg->offset; /* length byte */\n        p_msg->len++;\n      }\n    }\n\n    if (p_msg->len + p_msg->offset > payload_size ||\n        handle_len != p_msg->offset) {\n      break;\n    }\n\n    if (op_code == GATT_REQ_FIND_TYPE_VALUE && value != *p_uuid) continue;\n\n    UINT16_TO_STREAM(p, el.s_hdl);\n\n    if (gatt_cb.last_service_handle &&\n        gatt_cb.last_service_handle == el.s_hdl) {\n      VLOG(1) << \"Use 0xFFFF for the last primary attribute\";\n      /* see GATT ERRATA 4065, 4063, ATT ERRATA 4062 */\n      UINT16_TO_STREAM(p, 0xFFFF);\n    } else {\n      UINT16_TO_STREAM(p, el.e_hdl);\n    }\n\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE)\n      gatt_build_uuid_to_stream(&p, *p_uuid);\n\n    status = GATT_SUCCESS;\n    p_msg->len += p_msg->offset;\n  }\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  return status;\n}\n\n/**\n * fill the find information response information in the given buffer.\n *\n * Returns          true: if data filled sucessfully.\n *                  false: packet full, or format mismatch.\n */\nstatic tGATT_STATUS gatt_build_find_info_rsp(tGATT_SRV_LIST_ELEM& el,\n                                             BT_HDR* p_msg, uint16_t& len,\n                                             uint16_t s_hdl, uint16_t e_hdl) {\n  uint8_t info_pair_len[2] = {4, 18};\n\n  if (!el.p_db) return GATT_NOT_FOUND;\n\n  /* check the attribute database */\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET + p_msg->len;\n\n  for (auto& attr : el.p_db->attr_list) {\n    if (attr.handle > e_hdl) break;\n\n    if (attr.handle < s_hdl) continue;\n\n    uint8_t uuid_len = attr.uuid.GetShortestRepresentationSize();\n    if (p_msg->offset == 0)\n      p_msg->offset = (uuid_len == Uuid::kNumBytes16) ? GATT_INFO_TYPE_PAIR_16\n                                                      : GATT_INFO_TYPE_PAIR_128;\n\n    if (len < info_pair_len[p_msg->offset - 1]) return GATT_NO_RESOURCES;\n\n    if (p_msg->offset == GATT_INFO_TYPE_PAIR_16 &&\n        uuid_len == Uuid::kNumBytes16) {\n      UINT16_TO_STREAM(p, attr.handle);\n      UINT16_TO_STREAM(p, attr.uuid.As16Bit());\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 &&\n               uuid_len == Uuid::kNumBytes128) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else if (p_msg->offset == GATT_INFO_TYPE_PAIR_128 &&\n               uuid_len == Uuid::kNumBytes32) {\n      UINT16_TO_STREAM(p, attr.handle);\n      ARRAY_TO_STREAM(p, attr.uuid.To128BitLE(), (int)Uuid::kNumBytes128);\n    } else {\n      LOG(ERROR) << \"format mismatch\";\n      return GATT_NO_RESOURCES;\n      /* format mismatch */\n    }\n    p_msg->len += info_pair_len[p_msg->offset - 1];\n    len -= info_pair_len[p_msg->offset - 1];\n    return GATT_SUCCESS;\n  }\n\n  return GATT_NOT_FOUND;\n}\n\nstatic tGATT_STATUS read_handles(uint16_t& len, uint8_t*& p, uint16_t& s_hdl,\n                                 uint16_t& e_hdl) {\n  if (len < 4) return GATT_INVALID_PDU;\n\n  /* obtain starting handle, and ending handle */\n  STREAM_TO_UINT16(s_hdl, p);\n  STREAM_TO_UINT16(e_hdl, p);\n  len -= 4;\n\n  if (s_hdl > e_hdl || !GATT_HANDLE_IS_VALID(s_hdl) ||\n      !GATT_HANDLE_IS_VALID(e_hdl)) {\n    return GATT_INVALID_HANDLE;\n  }\n\n  return GATT_SUCCESS;\n}\n\nstatic tGATT_STATUS gatts_validate_packet_format(uint8_t op_code, uint16_t& len,\n                                                 uint8_t*& p, Uuid* p_uuid,\n                                                 uint16_t& s_hdl,\n                                                 uint16_t& e_hdl) {\n  tGATT_STATUS ret = read_handles(len, p, s_hdl, e_hdl);\n  if (ret != GATT_SUCCESS) return ret;\n\n  if (len < 2) return GATT_INVALID_PDU;\n\n  /* parse uuid now */\n  CHECK(p_uuid);\n  uint16_t uuid_len = (op_code == GATT_REQ_FIND_TYPE_VALUE) ? 2 : len;\n  if (!gatt_parse_uuid_from_cmd(p_uuid, uuid_len, &p)) {\n    VLOG(1) << \"Bad UUID\";\n    return GATT_INVALID_PDU;\n  }\n\n  len -= uuid_len;\n  return GATT_SUCCESS;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_primary_service_req\n *\n * Description      Process ReadByGroupType/ReadByTypeValue request, for\n *                  discovering all primary services or discover primary service\n *                  by UUID request.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid,\n                                       uint8_t op_code, uint16_t len,\n                                       uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  Uuid uuid = Uuid::kEmpty;\n\n  uint8_t reason =\n      gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  if (uuid != Uuid::From16Bit(GATT_UUID_PRI_SERVICE)) {\n    if (op_code == GATT_REQ_READ_BY_GRP_TYPE) {\n      gatt_send_error_rsp(tcb, cid, GATT_UNSUPPORT_GRP_TYPE, op_code, s_hdl,\n                          false);\n      VLOG(1) << StringPrintf(\"unexpected ReadByGrpType Group: %s\",\n                              uuid.ToString().c_str());\n      return;\n    }\n\n    // we do not support ReadByTypeValue with any non-primamry_service type\n    gatt_send_error_rsp(tcb, cid, GATT_NOT_FOUND, op_code, s_hdl, false);\n    VLOG(1) << StringPrintf(\"unexpected ReadByTypeValue type: %s\",\n                            uuid.ToString().c_str());\n    return;\n  }\n\n  // TODO: we assume theh value is UUID, there is no such requirement in spec\n  Uuid value = Uuid::kEmpty;\n  if (op_code == GATT_REQ_FIND_TYPE_VALUE) {\n    if (!gatt_parse_uuid_from_cmd(&value, len, &p_data)) {\n      gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, s_hdl, false);\n    }\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  uint16_t msg_len =\n      (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n  reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl,\n                                          e_hdl, p_data, value);\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_find_info\n *\n * Description      process find information request, for discover character\n *                  descriptors.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid,\n                                    uint8_t op_code, uint16_t len,\n                                    uint8_t* p_data) {\n  uint16_t s_hdl = 0, e_hdl = 0;\n  uint8_t reason = read_handles(len, p_data, s_hdl, e_hdl);\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n  uint16_t buf_len =\n      (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n  reason = GATT_NOT_FOUND;\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n  *p++ = op_code + 1;\n  p_msg->len = 2;\n\n  buf_len = payload_size - 2;\n\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl <= e_hdl && el.e_hdl >= s_hdl) {\n      reason = gatt_build_find_info_rsp(el, p_msg, buf_len, s_hdl, e_hdl);\n      if (reason == GATT_NO_RESOURCES) {\n        reason = GATT_SUCCESS;\n        break;\n      }\n    }\n  }\n\n  *p = (uint8_t)p_msg->offset;\n\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n  } else\n    attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_mtu_req\n *\n * Description      This function is called to process excahnge MTU request.\n *                  Only used on LE.\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_mtu_req(tGATT_TCB& tcb, uint16_t cid, uint16_t len,\n                                  uint8_t* p_data) {\n  /* BR/EDR conenction, send error response */\n  if (cid != L2CAP_ATT_CID) {\n    gatt_send_error_rsp(tcb, cid, GATT_REQ_NOT_SUPPORTED, GATT_REQ_MTU, 0,\n                        false);\n    return;\n  }\n\n  if (len < GATT_MTU_REQ_MIN_LEN) {\n    LOG(ERROR) << \"invalid MTU request PDU received.\";\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, GATT_REQ_MTU, 0, false);\n    return;\n  }\n\n  uint16_t mtu = 0;\n  uint8_t* p = p_data;\n  STREAM_TO_UINT16(mtu, p);\n  /* mtu must be greater than default MTU which is 23/48 */\n  if (mtu < GATT_DEF_BLE_MTU_SIZE)\n    tcb.payload_size = GATT_DEF_BLE_MTU_SIZE;\n  else if (mtu > GATT_MAX_MTU_SIZE)\n    tcb.payload_size = GATT_MAX_MTU_SIZE;\n  else\n    tcb.payload_size = mtu;\n\n  LOG(INFO) << \"MTU request PDU with MTU size \" << +tcb.payload_size;\n\n  BTM_SetBleDataLength(tcb.peer_bda, tcb.payload_size + L2CAP_PKT_OVERHEAD);\n\n  tGATT_SR_MSG gatt_sr_msg;\n  gatt_sr_msg.mtu = tcb.payload_size;\n  BT_HDR* p_buf = attp_build_sr_msg(tcb, GATT_RSP_MTU, &gatt_sr_msg);\n  attp_send_sr_msg(tcb, cid, p_buf);\n\n  tGATTS_DATA gatts_data;\n  gatts_data.mtu = tcb.payload_size;\n  /* Notify all registered applicaiton with new MTU size. Us a transaction ID */\n  /* of 0, as no response is allowed from applcations                    */\n  for (int i = 0; i < GATT_MAX_APPS; i++) {\n    if (gatt_cb.cl_rcb[i].in_use) {\n      uint16_t conn_id =\n          GATT_CREATE_CONN_ID(tcb.tcb_idx, gatt_cb.cl_rcb[i].gatt_if);\n      gatt_sr_send_req_callback(conn_id, 0, GATTS_REQ_TYPE_MTU, &gatts_data);\n    }\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_read_by_type_req\n *\n * Description      process Read By type request.\n *                  This PDU can be used to perform:\n *                  - read characteristic value\n *                  - read characteristic descriptor value\n *                  - discover characteristic\n *                  - discover characteristic by UUID\n *                  - relationship discovery\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid,\n                                           uint8_t op_code, uint16_t len,\n                                           uint8_t* p_data) {\n  Uuid uuid = Uuid::kEmpty;\n  uint16_t s_hdl = 0, e_hdl = 0, err_hdl = 0;\n  tGATT_STATUS reason =\n      gatts_validate_packet_format(op_code, len, p_data, &uuid, s_hdl, e_hdl);\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rsp for ReadByType: error status=\"\n            << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, gatt_cb.req_op_code,\n                        s_hdl, false);\n\n    return;\n  }\n#endif\n\n  if (reason != GATT_SUCCESS) {\n    gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n    return;\n  }\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n\n  *p++ = op_code + 1;\n  /* reserve length byte */\n  p_msg->len = 2;\n  uint16_t buf_len = payload_size - 2;\n\n  reason = GATT_NOT_FOUND;\n  for (tGATT_SRV_LIST_ELEM& el : *gatt_cb.srv_list_info) {\n    if (el.s_hdl <= e_hdl && el.e_hdl >= s_hdl) {\n      tGATT_SEC_FLAG sec_flag;\n      uint8_t key_size;\n      gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n      tGATT_STATUS ret = gatts_db_read_attr_value_by_type(\n          tcb, cid, el.p_db, op_code, p_msg, s_hdl, e_hdl, uuid, &buf_len,\n          sec_flag, key_size, 0, &err_hdl);\n      if (ret != GATT_NOT_FOUND) {\n        reason = ret;\n        if (ret == GATT_NO_RESOURCES) reason = GATT_SUCCESS;\n      }\n\n      if (ret != GATT_SUCCESS && ret != GATT_NOT_FOUND) {\n        s_hdl = err_hdl;\n        break;\n      }\n    }\n  }\n  *p = (uint8_t)p_msg->offset;\n  p_msg->offset = L2CAP_MIN_OFFSET;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n\n    /* in theroy BUSY is not possible(should already been checked), protected\n     * check */\n    if (reason != GATT_PENDING && reason != GATT_BUSY)\n      gatt_send_error_rsp(tcb, cid, reason, op_code, s_hdl, false);\n\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/**\n * This function is called to process the write request from client.\n */\nstatic void gatts_process_write_req(tGATT_TCB& tcb, uint16_t cid,\n                                    tGATT_SRV_LIST_ELEM& el, uint16_t handle,\n                                    uint8_t op_code, uint16_t len,\n                                    uint8_t* p_data,\n                                    bt_gatt_db_attribute_type_t gatt_type) {\n  tGATTS_DATA sr_data;\n  uint32_t trans_id;\n  tGATT_STATUS status;\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size, *p = p_data;\n  uint16_t conn_id;\n\n  memset(&sr_data, 0, sizeof(tGATTS_DATA));\n\n  switch (op_code) {\n    case GATT_REQ_PREPARE_WRITE:\n      if (len < 2 || p == nullptr) {\n        LOG(ERROR) << __func__\n                   << \": Prepare write request was invalid - missing offset, \"\n                      \"sending error response\";\n        gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, handle, false);\n        return;\n      }\n      sr_data.write_req.is_prep = true;\n      STREAM_TO_UINT16(sr_data.write_req.offset, p);\n      len -= 2;\n      FALLTHROUGH_INTENDED; /* FALLTHROUGH */\n    case GATT_SIGN_CMD_WRITE:\n      if (op_code == GATT_SIGN_CMD_WRITE) {\n        VLOG(1) << \"Write CMD with data sigining\";\n        len -= GATT_AUTH_SIGN_LEN;\n      }\n      FALLTHROUGH_INTENDED; /* FALLTHROUGH */\n    case GATT_CMD_WRITE:\n    case GATT_REQ_WRITE:\n      if (op_code == GATT_REQ_WRITE || op_code == GATT_REQ_PREPARE_WRITE)\n        sr_data.write_req.need_rsp = true;\n      sr_data.write_req.handle = handle;\n      if (len > GATT_MAX_ATTR_LEN) len = GATT_MAX_ATTR_LEN;\n      sr_data.write_req.len = len;\n      if (len != 0 && p != nullptr) {\n        memcpy(sr_data.write_req.value, p, len);\n      }\n      break;\n  }\n\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n  status = gatts_write_attr_perm_check(el.p_db, op_code, handle,\n                                       sr_data.write_req.offset, p, len,\n                                       sec_flag, key_size);\n\n  if (status == GATT_SUCCESS) {\n    trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, handle);\n    if (trans_id != 0) {\n      conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, el.gatt_if);\n\n      uint8_t opcode = 0;\n      if (gatt_type == BTGATT_DB_DESCRIPTOR) {\n        opcode = GATTS_REQ_TYPE_WRITE_DESCRIPTOR;\n      } else if (gatt_type == BTGATT_DB_CHARACTERISTIC) {\n        opcode = GATTS_REQ_TYPE_WRITE_CHARACTERISTIC;\n      } else {\n        LOG(ERROR) << __func__\n                   << \"%s: Attempt to write attribute that's not tied with\"\n                      \" characteristic or descriptor value.\";\n        status = GATT_ERROR;\n      }\n\n      if (opcode) {\n        gatt_sr_send_req_callback(conn_id, trans_id, opcode, &sr_data);\n        status = GATT_PENDING;\n      }\n    } else {\n      LOG(ERROR) << \"max pending command, send error\";\n      status = GATT_BUSY; /* max pending command, application error */\n    }\n  }\n\n  /* in theroy BUSY is not possible(should already been checked), protected\n   * check */\n  if (status != GATT_PENDING && status != GATT_BUSY &&\n      (op_code == GATT_REQ_PREPARE_WRITE || op_code == GATT_REQ_WRITE)) {\n    gatt_send_error_rsp(tcb, cid, status, op_code, handle, false);\n  }\n  return;\n}\n\n/**\n * This function is called to process the read request from client.\n */\nstatic void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid,\n                                   tGATT_SRV_LIST_ELEM& el, uint8_t op_code,\n                                   uint16_t handle, uint16_t len,\n                                   uint8_t* p_data) {\n  uint16_t payload_size = gatt_tcb_get_payload_size_tx(tcb, cid);\n\n  // This can happen if the channel is already closed.\n  if (payload_size == 0) {\n    return;\n  }\n\n  size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n  uint16_t offset = 0;\n\n  if (op_code == GATT_REQ_READ_BLOB && len < sizeof(uint16_t)) {\n    /* Error: packet length is too short */\n    LOG(ERROR) << __func__ << \": packet length=\" << len\n               << \" too short. min=\" << sizeof(uint16_t);\n    android_errorWriteWithInfoLog(0x534e4554, \"73172115\", -1, NULL, 0);\n    gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, 0, false);\n    return;\n  }\n\n  BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n\n  if (op_code == GATT_REQ_READ_BLOB) STREAM_TO_UINT16(offset, p_data);\n\n  uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n  *p++ = op_code + 1;\n  p_msg->len = 1;\n  buf_len = payload_size - 1;\n\n  tGATT_SEC_FLAG sec_flag;\n  uint8_t key_size;\n  gatt_sr_get_sec_info(tcb.peer_bda, tcb.transport, &sec_flag, &key_size);\n\n  uint16_t value_len = 0;\n  tGATT_STATUS reason = gatts_read_attr_value_by_handle(\n      tcb, cid, el.p_db, op_code, handle, offset, p, &value_len,\n      (uint16_t)buf_len, sec_flag, key_size, 0);\n  p_msg->len += value_len;\n\n  if (reason != GATT_SUCCESS) {\n    osi_free(p_msg);\n\n    /* in theory BUSY is not possible(should already been checked), protected\n     * check */\n    if (reason != GATT_PENDING && reason != GATT_BUSY)\n      gatt_send_error_rsp(tcb, cid, reason, op_code, handle, false);\n\n    return;\n  }\n\n  attp_send_sr_msg(tcb, cid, p_msg);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_attribute_req\n *\n * Description      This function is called to process the per attribute handle\n *                  request from client.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_attribute_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code,\n                                 uint16_t len, uint8_t* p_data) {\n  uint16_t handle = 0;\n  uint8_t* p = p_data;\n  tGATT_STATUS status = GATT_INVALID_HANDLE;\n\n  if (len < 2) {\n    LOG(ERROR) << \"Illegal PDU length, discard request\";\n    status = GATT_INVALID_PDU;\n  } else {\n    STREAM_TO_UINT16(handle, p);\n    len -= 2;\n  }\n\n#if (GATT_CONFORMANCE_TESTING == TRUE)\n  gatt_cb.handle = handle;\n  if (gatt_cb.enable_err_rsp && gatt_cb.req_op_code == op_code) {\n    VLOG(1) << \"Conformance tst: forced err rsp: error status=\"\n            << +gatt_cb.err_status;\n\n    gatt_send_error_rsp(tcb, cid, gatt_cb.err_status, cid, gatt_cb.req_op_code,\n                        handle, false);\n\n    return;\n  }\n#endif\n\n  if (GATT_HANDLE_IS_VALID(handle)) {\n    for (auto& el : *gatt_cb.srv_list_info) {\n      if (el.s_hdl <= handle && el.e_hdl >= handle) {\n        for (const auto& attr : el.p_db->attr_list) {\n          if (attr.handle == handle) {\n            switch (op_code) {\n              case GATT_REQ_READ: /* read char/char descriptor value */\n              case GATT_REQ_READ_BLOB:\n                gatts_process_read_req(tcb, cid, el, op_code, handle, len, p);\n                break;\n\n              case GATT_REQ_WRITE: /* write char/char descriptor value */\n              case GATT_CMD_WRITE:\n              case GATT_SIGN_CMD_WRITE:\n              case GATT_REQ_PREPARE_WRITE:\n                gatts_process_write_req(tcb, cid, el, handle, op_code, len, p,\n                                        attr.gatt_type);\n                break;\n              default:\n                break;\n            }\n            status = GATT_SUCCESS;\n            break;\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  if (status != GATT_SUCCESS && op_code != GATT_CMD_WRITE &&\n      op_code != GATT_SIGN_CMD_WRITE)\n    gatt_send_error_rsp(tcb, cid, status, op_code, handle, false);\n}\n\n/*******************************************************************************\n *\n * Function         gatts_proc_srv_chg_ind_ack\n *\n * Description      This function process the service changed indicaiton ACK\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_proc_srv_chg_ind_ack(tGATT_TCB tcb) {\n  tGATTS_SRV_CHG_REQ req;\n  tGATTS_SRV_CHG* p_buf = NULL;\n\n  VLOG(1) << __func__;\n\n  p_buf = gatt_is_bda_in_the_srv_chg_clt_list(tcb.peer_bda);\n  if (p_buf != NULL) {\n    VLOG(1) << \"NV update set srv chg = false\";\n    p_buf->srv_changed = false;\n    memcpy(&req.srv_chg, p_buf, sizeof(tGATTS_SRV_CHG));\n    if (gatt_cb.cb_info.p_srv_chg_callback)\n      (*gatt_cb.cb_info.p_srv_chg_callback)(GATTS_SRV_CHG_CMD_UPDATE_CLIENT,\n                                            &req, NULL);\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_chk_pending_ind\n *\n * Description      This function check any pending indication needs to be sent\n *                  if there is a pending indication then sent the indication\n *\n * Returns          void\n *\n ******************************************************************************/\nstatic void gatts_chk_pending_ind(tGATT_TCB& tcb) {\n  VLOG(1) << __func__;\n\n  tGATT_VALUE* p_buf =\n      (tGATT_VALUE*)fixed_queue_try_peek_first(tcb.pending_ind_q);\n  if (p_buf != NULL) {\n    GATTS_HandleValueIndication(p_buf->conn_id, p_buf->handle, p_buf->len,\n                                p_buf->value);\n    osi_free(fixed_queue_try_remove_from_queue(tcb.pending_ind_q, p_buf));\n  }\n}\n\n/*******************************************************************************\n *\n * Function         gatts_proc_ind_ack\n *\n * Description      This function processes the Indication ack\n *\n * Returns          true continue to process the indication ack by the\n *                  application if the ACK is not a Service Changed Indication\n *\n ******************************************************************************/\nstatic bool gatts_proc_ind_ack(tGATT_TCB& tcb, uint16_t ack_handle) {\n  bool continue_processing = true;\n\n  VLOG(1) << __func__ << \" ack handle=%d\" << ack_handle;\n\n  if (ack_handle == gatt_cb.handle_of_h_r) {\n    gatts_proc_srv_chg_ind_ack(tcb);\n    /* there is no need to inform the application since srv chg is handled\n     * internally by GATT */\n    continue_processing = false;\n\n    // After receiving ack of svc_chg_ind, reset client status\n    gatt_sr_update_cl_status(tcb, /* chg_aware= */ true);\n  }\n\n  gatts_chk_pending_ind(tcb);\n  return continue_processing;\n}\n\n/*******************************************************************************\n *\n * Function         gatts_process_value_conf\n *\n * Description      This function is called to process the handle value\n *                  confirmation.\n *\n * Returns          void\n *\n ******************************************************************************/\nvoid gatts_process_value_conf(tGATT_TCB& tcb, uint16_t cid, uint8_t op_code) {\n  uint16_t handle;\n\n  if (!gatt_tcb_find_indicate_handle(tcb, cid, &handle)) {\n    LOG(ERROR) << \"unexpected handle value confirmation\";\n    return;\n  }\n\n  gatt_stop_conf_timer(tcb, cid);\n\n  bool continue_processing = gatts_proc_ind_ack(tcb, handle);\n\n  if (continue_processing) {\n    tGATTS_DATA gatts_data;\n    gatts_data.handle = handle;\n    for (auto& el : *gatt_cb.srv_list_info) {\n      if (el.s_hdl <= handle && el.e_hdl >= handle) {\n        uint32_t trans_id = gatt_sr_enqueue_cmd(tcb, cid, op_code, handle);\n        uint16_t conn_id = GATT_CREATE_CONN_ID(tcb.tcb_idx, el.gatt_if);\n        gatt_sr_send_req_callback(conn_id, trans_id, GATTS_REQ_TYPE_CONF,\n                                  &gatts_data);\n      }\n    }\n  }\n}\n\nstatic bool gatts_process_db_out_of_sync(tGATT_TCB& tcb, uint16_t cid,\n                                         uint8_t op_code, uint16_t len,\n                                         uint8_t* p_data) {\n  if (gatt_sr_is_cl_change_aware(tcb)) return false;\n\n  // default value\n  bool should_ignore = true;\n  bool should_rsp = true;\n\n  switch (op_code) {\n    case GATT_REQ_READ_BY_TYPE: {\n      // Check if read database hash by UUID\n      Uuid uuid = Uuid::kEmpty;\n      uint16_t s_hdl = 0, e_hdl = 0;\n      uint16_t db_hash_handle = gatt_cb.handle_of_database_hash;\n      tGATT_STATUS reason = gatts_validate_packet_format(op_code, len, p_data,\n                                                         &uuid, s_hdl, e_hdl);\n      if (reason == GATT_SUCCESS &&\n          (s_hdl <= db_hash_handle && db_hash_handle <= e_hdl) &&\n          (uuid == Uuid::From16Bit(GATT_UUID_DATABASE_HASH)))\n        should_ignore = false;\n\n    } break;\n    case GATT_REQ_READ: {\n      // Check if read database hash by handle\n      uint16_t handle = 0;\n      uint8_t* p = p_data;\n      tGATT_STATUS status = GATT_SUCCESS;\n\n      if (len < 2) {\n        status = GATT_INVALID_PDU;\n      } else {\n        STREAM_TO_UINT16(handle, p);\n        len -= 2;\n      }\n\n      if (status == GATT_SUCCESS && handle == gatt_cb.handle_of_database_hash)\n        should_ignore = false;\n\n    } break;\n    case GATT_REQ_READ_BY_GRP_TYPE: /* discover primary services */\n    case GATT_REQ_FIND_TYPE_VALUE:  /* discover service by UUID */\n    case GATT_REQ_FIND_INFO:        /* discover char descrptor */\n    case GATT_REQ_READ_BLOB:        /* read long char */\n    case GATT_REQ_READ_MULTI:       /* read multi char*/\n    case GATT_REQ_WRITE:            /* write char/char descriptor value */\n    case GATT_REQ_PREPARE_WRITE:    /* write long char */\n      // Use default value\n      break;\n    case GATT_CMD_WRITE:      /* cmd */\n    case GATT_SIGN_CMD_WRITE: /* sign cmd */\n      should_rsp = false;\n      break;\n    case GATT_REQ_MTU:           /* configure mtu */\n    case GATT_REQ_EXEC_WRITE:    /* execute write */\n    case GATT_HANDLE_VALUE_CONF: /* confirm for indication */\n    default:\n      should_ignore = false;\n  }\n\n  if (should_ignore) {\n    if (should_rsp) {\n      gatt_send_error_rsp(tcb, cid, GATT_DATABASE_OUT_OF_SYNC, op_code, 0x0000,\n                          false);\n    }\n    LOG(INFO) << __func__ << \": database out of sync, device=\" << tcb.peer_bda\n              << \", op_code=\" << loghex((uint16_t)op_code)\n              << \", should_rsp=\" << should_rsp;\n    gatt_sr_update_cl_status(tcb, /* chg_aware= */ should_rsp);\n  }\n\n  return should_ignore;\n}\n\n/** This function is called to handle the client requests to server */\nvoid gatt_server_handle_client_req(tGATT_TCB& tcb, uint16_t cid,\n                                   uint8_t op_code, uint16_t len,\n                                   uint8_t* p_data) {\n  /* there is pending command, discard this one */\n  if (!gatt_sr_cmd_empty(tcb, cid) && op_code != GATT_HANDLE_VALUE_CONF) return;\n\n  /* the size of the message may not be bigger than the local max PDU size*/\n  /* The message has to be smaller than the agreed MTU, len does not include op\n   * code */\n\n  uint16_t payload_size = gatt_tcb_get_payload_size_rx(tcb, cid);\n  if (len >= payload_size) {\n    LOG(ERROR) << StringPrintf(\"server receive invalid PDU size:%d pdu size:%d\",\n                               len + 1, payload_size);\n    /* for invalid request expecting response, send it now */\n    if (op_code != GATT_CMD_WRITE && op_code != GATT_SIGN_CMD_WRITE &&\n        op_code != GATT_HANDLE_VALUE_CONF) {\n      gatt_send_error_rsp(tcb, cid, GATT_INVALID_PDU, op_code, 0, false);\n    }\n    /* otherwise, ignore the pkt */\n  } else {\n    // handle database out of sync\n    if (gatts_process_db_out_of_sync(tcb, cid, op_code, len, p_data)) return;\n\n    switch (op_code) {\n      case GATT_REQ_READ_BY_GRP_TYPE: /* discover primary services */\n      case GATT_REQ_FIND_TYPE_VALUE:  /* discover service by UUID */\n        gatts_process_primary_service_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_FIND_INFO: /* discover char descrptor */\n        gatts_process_find_info(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ_BY_TYPE: /* read characteristic value, char descriptor\n                                     value */\n        /* discover characteristic, discover char by UUID */\n        gatts_process_read_by_type_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ: /* read char/char descriptor value */\n      case GATT_REQ_READ_BLOB:\n      case GATT_REQ_WRITE: /* write char/char descriptor value */\n      case GATT_CMD_WRITE:\n      case GATT_SIGN_CMD_WRITE:\n      case GATT_REQ_PREPARE_WRITE:\n        gatts_process_attribute_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_HANDLE_VALUE_CONF:\n        gatts_process_value_conf(tcb, cid, op_code);\n        break;\n\n      case GATT_REQ_MTU:\n        gatts_process_mtu_req(tcb, cid, len, p_data);\n        break;\n\n      case GATT_REQ_EXEC_WRITE:\n        gatt_process_exec_write_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      case GATT_REQ_READ_MULTI:\n      case GATT_REQ_READ_MULTI_VAR:\n        gatt_process_read_multi_req(tcb, cid, op_code, len, p_data);\n        break;\n\n      default:\n        break;\n    }\n  }\n}\n```"
                    }
                ]
            }
        ],
        "upstream_patch_content": "From 7de5617f7d5266fe57c990c428621b5d4e92728a Mon Sep 17 00:00:00 2001\nFrom: Brian Delwiche <delwiche@google.com>\nDate: Thu, 12 Sep 2024 17:26:55 +0000\nSubject: [PATCH] Fix OOB writes in gatt_sr.cc\n\nAt various points in gatt_sr.cc, the output of the\ngatt_tcb_get_payload_size function is used without checking for a\npositive length.  However, in exceptional cases it is possible for the\nchannel to be closed at the time the function is called, which will lead\nto a zero length and cause an OOB write in subsequent processing.\n\nFix all of these.\n\nBug: 364026473\nBug: 364027038\nBug: 364027949\nBug: 364025411\nTest: m libbluetooth\nTest: researcher POC\nFlag: EXEMPT trivial validity checks\nTag: #security\nIgnore-AOSP-First: Security\nChange-Id: I9b30499d4aed6ab42f3cdb2c0de7df2c1a827404\n---\n system/stack/gatt/gatt_sr.cc | 21 +++++++++++++++++++++\n 1 file changed, 21 insertions(+)\n\ndiff --git a/system/stack/gatt/gatt_sr.cc b/system/stack/gatt/gatt_sr.cc\nindex 995ea810cb..0235ba964e 100644\n--- a/system/stack/gatt/gatt_sr.cc\n+++ b/system/stack/gatt/gatt_sr.cc\n@@ -772,6 +772,11 @@ void gatts_process_primary_service_req(tGATT_TCB& tcb, uint16_t cid, uint8_t op_\n \n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t msg_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   reason = gatt_build_primary_service_rsp(p_msg, tcb, cid, op_code, s_hdl, e_hdl, p_data, value);\n@@ -804,6 +809,12 @@ static void gatts_process_find_info(tGATT_TCB& tcb, uint16_t cid, uint8_t op_cod\n   }\n \n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n+\n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   uint16_t buf_len = (uint16_t)(sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET);\n \n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(buf_len);\n@@ -949,6 +960,11 @@ static void gatts_process_read_by_type_req(tGATT_TCB& tcb, uint16_t cid, uint8_t\n \n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t msg_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   BT_HDR* p_msg = (BT_HDR*)osi_calloc(msg_len);\n   uint8_t* p = (uint8_t*)(p_msg + 1) + L2CAP_MIN_OFFSET;\n@@ -1096,6 +1112,11 @@ static void gatts_process_read_req(tGATT_TCB& tcb, uint16_t cid, tGATT_SRV_LIST_\n                                    uint8_t* p_data) {\n   uint16_t payload_size = gatt_tcb_get_payload_size(tcb, cid);\n \n+  // This can happen if the channel is already closed.\n+  if (payload_size == 0) {\n+    return;\n+  }\n+\n   size_t buf_len = sizeof(BT_HDR) + payload_size + L2CAP_MIN_OFFSET;\n   uint16_t offset = 0;\n \n-- \n2.39.5 (Apple Git-154)\n\n",
        "upstream_commits": [
            "7de5617f7d5266fe57c990c428621b5d4e92728a"
        ]
    }
]