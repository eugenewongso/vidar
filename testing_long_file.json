[
    {
        "id": "ASB-A-317203980",
        "vulnerability_url": "https://api.osv.dev/v1/vulns/ASB-A-317203980",
        "severity": "High",
        "failures": [
            {
                "downstream_version": "13",
                "branch_used": "android13-release",
                "downstream_patch": "4a1e3f85e00b0b7eba35f70096efe3dbd5287e7f",
                "repo_path": "android_repos/base",
                "result": "failure",
                "downstream_patch_content": "commit 4a1e3f85e00b0b7eba35f70096efe3dbd5287e7f\nAuthor: Iv\u00e1n Budnik <ivanbuper@google.com>\nDate:   Wed Aug 16 16:32:55 2023 +0000\n\n    Prevent media button receivers targeting activities\n    \n    This enforcement prevents a bypass of background activity launches. For\n    versions before Android V, the enforcement just ignores the request and\n    logs a warning.\n    \n    This change is a backport of ag/23810567.\n    \n    Test: Manually.\n    Bug: 272737196\n    Bug: 272024837\n    Bug: 317203980\n    (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:d455e21711c167223f7d0696809a4e411683182c)\n    Merged-In: I2412633c0b3afda6776244c72043d0dd78a4c8a1\n    Change-Id: I2412633c0b3afda6776244c72043d0dd78a4c8a1\n\ndiff --git a/media/java/android/media/session/MediaSession.java b/media/java/android/media/session/MediaSession.java\nindex a14999df666c..7c1b26d904e4 100644\n--- a/media/java/android/media/session/MediaSession.java\n+++ b/media/java/android/media/session/MediaSession.java\n@@ -270,17 +270,22 @@ public final class MediaSession {\n     }\n \n     /**\n-     * Set a pending intent for your media button receiver to allow restarting\n-     * playback after the session has been stopped. If your app is started in\n-     * this way an {@link Intent#ACTION_MEDIA_BUTTON} intent will be sent via\n-     * the pending intent.\n-     * <p>\n-     * The pending intent is recommended to be explicit to follow the security recommendation of\n-     * {@link PendingIntent#getActivity}.\n+     * Set a pending intent for your media button receiver to allow restarting playback after the\n+     * session has been stopped.\n+     *\n+     * <p>If your app is started in this way an {@link Intent#ACTION_MEDIA_BUTTON} intent will be\n+     * sent via the pending intent.\n+     *\n+     * <p>The provided {@link PendingIntent} must not target an activity. Passing an activity\n+     * pending intent will cause the call to be ignored. Refer to this <a\n+     * href=\"https://developer.android.com/guide/components/activities/background-starts\">guide</a>\n+     * for more information.\n+     *\n+     * <p>The pending intent is recommended to be explicit to follow the security recommendation of\n+     * {@link PendingIntent#getService}.\n      *\n      * @param mbr The {@link PendingIntent} to send the media button event to.\n      * @see PendingIntent#getActivity\n-     *\n      * @deprecated Use {@link #setMediaButtonBroadcastReceiver(ComponentName)} instead.\n      */\n     @Deprecated\n@@ -288,7 +293,7 @@ public final class MediaSession {\n         try {\n             mBinder.setMediaButtonReceiver(mbr);\n         } catch (RemoteException e) {\n-            Log.wtf(TAG, \"Failure in setMediaButtonReceiver.\", e);\n+            e.rethrowFromSystemServer();\n         }\n     }\n \ndiff --git a/services/core/java/com/android/server/media/MediaSessionRecord.java b/services/core/java/com/android/server/media/MediaSessionRecord.java\nindex becb944101f2..7db5bf261fe2 100644\n--- a/services/core/java/com/android/server/media/MediaSessionRecord.java\n+++ b/services/core/java/com/android/server/media/MediaSessionRecord.java\n@@ -973,6 +973,14 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR\n                         != 0) {\n                     return;\n                 }\n+\n+                if (pi != null && pi.isActivity()) {\n+                    Log.w(\n+                            TAG,\n+                            \"Ignoring invalid media button receiver targeting an activity: \" + pi);\n+                    return;\n+                }\n+\n                 mMediaButtonReceiverHolder =\n                         MediaButtonReceiverHolder.create(mUserId, pi, mPackageName);\n                 mService.onMediaButtonReceiverChanged(MediaSessionRecord.this);\n",
                "file_conflicts": [
                    {
                        "file_name": "services/core/java/com/android/server/media/MediaSessionRecord.java",
                        "total_hunks": 2,
                        "failed_hunks": [
                            1
                        ],
                        "inline_merge_conflicts": [
                            {
                                "hunk_number": 1,
                                "merge_conflict": "<<<<<<< DOWNSTREAM (version 13)\n\n=======\n\n                if (pi != null && pi.isActivity()) {\n                    if (CompatChanges.isChangeEnabled(\n                            THROW_FOR_ACTIVITY_MEDIA_BUTTON_RECEIVER, uid)) {\n                        throw new IllegalArgumentException(\n                                \"The media button receiver cannot be set to an activity.\");\n                    } else {\n                        Log.w(TAG, \"Ignoring invalid media button receiver targeting an activity.\");\n                        return;\n                    }\n                }\n\n                mMediaButtonReceiverHolder =\n                        MediaButtonReceiverHolder.create(mUserId, pi, mPackageName);\n                mService.onMediaButtonReceiverChanged(MediaSessionRecord.this);\n>>>>>>> UPSTREAM PATCH (commit fda5a94aaf91933f8602e00d78ad9ba4872c72f4)"
                            }
                        ],
                        "rej_file_content": "```diff\n--- services/core/java/com/android/server/media/MediaSessionRecord.java\n+++ services/core/java/com/android/server/media/MediaSessionRecord.java\n@@ -106,6 +106,16 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR\n     @EnabledSince(targetSdkVersion = Build.VERSION_CODES.UPSIDE_DOWN_CAKE)\n     static final long THROW_FOR_INVALID_BROADCAST_RECEIVER = 270049379L;\n \n+    /**\n+     * {@link MediaSession#setMediaButtonReceiver(PendingIntent)} throws an {@link\n+     * IllegalArgumentException} if the provided {@link PendingIntent} targets an {@link\n+     * android.app.Activity activity} for apps targeting Android V and above. For apps targeting\n+     * Android U and below, the request will be ignored.\n+     */\n+    @ChangeId\n+    @EnabledSince(targetSdkVersion = Build.VERSION_CODES.VANILLA_ICE_CREAM)\n+    static final long THROW_FOR_ACTIVITY_MEDIA_BUTTON_RECEIVER = 272737196L;\n+\n     private static final String TAG = \"MediaSessionRecord\";\n     private static final String[] ART_URIS = new String[] {\n             MediaMetadata.METADATA_KEY_ALBUM_ART_URI,\n```",
                        "patch_apply_output": "patching file media/java/android/media/session/MediaSession.java\nHunk #1 succeeded at 270 (offset 3 lines).\npatching file services/core/java/com/android/server/media/MediaSessionRecord.java\nHunk #1 FAILED at 106.\nHunk #2 succeeded at 966 (offset -89 lines).\n1 out of 2 hunks FAILED -- saving rejects to file services/core/java/com/android/server/media/MediaSessionRecord.java.rej",
                        "inline_merge_output": "patching file services/core/java/com/android/server/media/MediaSessionRecord.java\nHunk #1 merged at 119-128.\nHunk #2 already applied at 1078-1079, NOT MERGED at 1086-1103.",
                        "upstream_file_content": "```java\n/*\n * Copyright (C) 2014 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.server.media;\n\nimport static android.media.MediaRoute2Info.PLAYBACK_VOLUME_FIXED;\nimport static android.media.VolumeProvider.VOLUME_CONTROL_ABSOLUTE;\nimport static android.media.VolumeProvider.VOLUME_CONTROL_FIXED;\nimport static android.media.VolumeProvider.VOLUME_CONTROL_RELATIVE;\nimport static android.media.session.MediaController.PlaybackInfo.PLAYBACK_TYPE_LOCAL;\nimport static android.media.session.MediaController.PlaybackInfo.PLAYBACK_TYPE_REMOTE;\n\nimport android.Manifest;\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.annotation.RequiresPermission;\nimport android.app.ActivityManager;\nimport android.app.ActivityManagerInternal;\nimport android.app.PendingIntent;\nimport android.app.compat.CompatChanges;\nimport android.compat.annotation.ChangeId;\nimport android.compat.annotation.EnabledSince;\nimport android.content.ComponentName;\nimport android.content.ContentProvider;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.pm.PackageManager;\nimport android.content.pm.ParceledListSlice;\nimport android.content.pm.ResolveInfo;\nimport android.media.AudioAttributes;\nimport android.media.AudioManager;\nimport android.media.AudioSystem;\nimport android.media.MediaMetadata;\nimport android.media.MediaRouter2Manager;\nimport android.media.Rating;\nimport android.media.RoutingSessionInfo;\nimport android.media.VolumeProvider;\nimport android.media.session.ISession;\nimport android.media.session.ISessionCallback;\nimport android.media.session.ISessionController;\nimport android.media.session.ISessionControllerCallback;\nimport android.media.session.MediaController;\nimport android.media.session.MediaController.PlaybackInfo;\nimport android.media.session.MediaSession;\nimport android.media.session.MediaSession.QueueItem;\nimport android.media.session.ParcelableListBinder;\nimport android.media.session.PlaybackState;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.DeadObjectException;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.Process;\nimport android.os.RemoteException;\nimport android.os.ResultReceiver;\nimport android.os.SystemClock;\nimport android.os.UserHandle;\nimport android.text.TextUtils;\nimport android.util.EventLog;\nimport android.util.Log;\nimport android.view.KeyEvent;\n\nimport com.android.server.LocalServices;\nimport com.android.server.uri.UriGrantsManagerInternal;\n\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport java.util.concurrent.CopyOnWriteArrayList;\n\n/**\n * This is the system implementation of a Session. Apps will interact with the\n * MediaSession wrapper class instead.\n */\n// TODO(jaewan): Do not call service method directly -- introduce listener instead.\npublic class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionRecordImpl {\n\n    /**\n     * {@link MediaSession#setMediaButtonBroadcastReceiver(ComponentName)} throws an {@link\n     * IllegalArgumentException} if the provided {@link ComponentName} does not resolve to a valid\n     * {@link android.content.BroadcastReceiver broadcast receiver} for apps targeting Android U and\n     * above. For apps targeting Android T and below, the request will be ignored.\n     */\n    @ChangeId\n    @EnabledSince(targetSdkVersion = Build.VERSION_CODES.UPSIDE_DOWN_CAKE)\n    static final long THROW_FOR_INVALID_BROADCAST_RECEIVER = 270049379L;\n\n    /**\n     * {@link MediaSession#setMediaButtonReceiver(PendingIntent)} throws an {@link\n     * IllegalArgumentException} if the provided {@link PendingIntent} targets an {@link\n     * android.app.Activity activity} for apps targeting Android V and above. For apps targeting\n     * Android U and below, the request will be ignored.\n     */\n    @ChangeId\n    @EnabledSince(targetSdkVersion = Build.VERSION_CODES.VANILLA_ICE_CREAM)\n    static final long THROW_FOR_ACTIVITY_MEDIA_BUTTON_RECEIVER = 272737196L;\n\n    private static final String TAG = \"MediaSessionRecord\";\n    private static final String[] ART_URIS = new String[] {\n            MediaMetadata.METADATA_KEY_ALBUM_ART_URI,\n            MediaMetadata.METADATA_KEY_ART_URI,\n            MediaMetadata.METADATA_KEY_DISPLAY_ICON_URI};\n    private static final boolean DEBUG = Log.isLoggable(TAG, Log.DEBUG);\n\n    /**\n     * The amount of time we'll send an assumed volume after the last volume\n     * command before reverting to the last reported volume.\n     */\n    private static final int OPTIMISTIC_VOLUME_TIMEOUT = 1000;\n\n    /**\n     * These are states that usually indicate the user took an action and should\n     * bump priority regardless of the old state.\n     */\n    private static final List<Integer> ALWAYS_PRIORITY_STATES = Arrays.asList(\n            PlaybackState.STATE_FAST_FORWARDING,\n            PlaybackState.STATE_REWINDING,\n            PlaybackState.STATE_SKIPPING_TO_PREVIOUS,\n            PlaybackState.STATE_SKIPPING_TO_NEXT);\n    /**\n     * These are states that usually indicate the user took an action if they\n     * were entered from a non-priority state.\n     */\n    private static final List<Integer> TRANSITION_PRIORITY_STATES = Arrays.asList(\n            PlaybackState.STATE_BUFFERING,\n            PlaybackState.STATE_CONNECTING,\n            PlaybackState.STATE_PLAYING);\n\n    private static final AudioAttributes DEFAULT_ATTRIBUTES =\n            new AudioAttributes.Builder().setUsage(AudioAttributes.USAGE_MEDIA).build();\n\n    private static int getVolumeStream(@Nullable AudioAttributes attr) {\n        if (attr == null) {\n            return DEFAULT_ATTRIBUTES.getVolumeControlStream();\n        }\n        final int stream = attr.getVolumeControlStream();\n        if (stream == AudioManager.USE_DEFAULT_STREAM_TYPE) {\n            return DEFAULT_ATTRIBUTES.getVolumeControlStream();\n        }\n        return stream;\n    }\n\n    private final MessageHandler mHandler;\n\n    private final int mOwnerPid;\n    private final int mOwnerUid;\n    private final int mUserId;\n    private final String mPackageName;\n    private final String mTag;\n    private final Bundle mSessionInfo;\n    private final ControllerStub mController;\n    private final MediaSession.Token mSessionToken;\n    private final SessionStub mSession;\n    private final SessionCb mSessionCb;\n    private final MediaSessionService mService;\n    private final UriGrantsManagerInternal mUgmInternal;\n    private final Context mContext;\n    private final boolean mVolumeAdjustmentForRemoteGroupSessions;\n\n    private final Object mLock = new Object();\n    private final CopyOnWriteArrayList<ISessionControllerCallbackHolder>\n            mControllerCallbackHolders = new CopyOnWriteArrayList<>();\n\n    private long mFlags;\n    private MediaButtonReceiverHolder mMediaButtonReceiverHolder;\n    private PendingIntent mLaunchIntent;\n\n    // TransportPerformer fields\n    private Bundle mExtras;\n    // Note: Avoid unparceling the bundle inside MediaMetadata since unparceling in system process\n    // may result in throwing an exception.\n    private MediaMetadata mMetadata;\n    private PlaybackState mPlaybackState;\n    private List<QueueItem> mQueue;\n    private CharSequence mQueueTitle;\n    private int mRatingType;\n    // End TransportPerformer fields\n\n    // Volume handling fields\n    private AudioAttributes mAudioAttrs;\n    private AudioManager mAudioManager;\n    private int mVolumeType = PLAYBACK_TYPE_LOCAL;\n    private int mVolumeControlType = VOLUME_CONTROL_ABSOLUTE;\n    private int mMaxVolume = 0;\n    private int mCurrentVolume = 0;\n    private int mOptimisticVolume = -1;\n    private String mVolumeControlId;\n    // End volume handling fields\n\n    private boolean mIsActive = false;\n    private boolean mDestroyed = false;\n\n    private long mDuration = -1;\n    private String mMetadataDescription;\n\n    private int mPolicies;\n\n    public MediaSessionRecord(int ownerPid, int ownerUid, int userId, String ownerPackageName,\n            ISessionCallback cb, String tag, Bundle sessionInfo,\n            MediaSessionService service, Looper handlerLooper, int policies)\n            throws RemoteException {\n        mOwnerPid = ownerPid;\n        mOwnerUid = ownerUid;\n        mUserId = userId;\n        mPackageName = ownerPackageName;\n        mTag = tag;\n        mSessionInfo = sessionInfo;\n        mController = new ControllerStub();\n        mSessionToken = new MediaSession.Token(ownerUid, mController);\n        mSession = new SessionStub();\n        mSessionCb = new SessionCb(cb);\n        mService = service;\n        mContext = mService.getContext();\n        mHandler = new MessageHandler(handlerLooper);\n        mAudioManager = (AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE);\n        mAudioAttrs = DEFAULT_ATTRIBUTES;\n        mPolicies = policies;\n        mUgmInternal = LocalServices.getService(UriGrantsManagerInternal.class);\n        mVolumeAdjustmentForRemoteGroupSessions = mContext.getResources().getBoolean(\n                com.android.internal.R.bool.config_volumeAdjustmentForRemoteGroupSessions);\n\n        // May throw RemoteException if the session app is killed.\n        mSessionCb.mCb.asBinder().linkToDeath(this, 0);\n    }\n\n    /**\n     * Get the session binder for the {@link MediaSession}.\n     *\n     * @return The session binder apps talk to.\n     */\n    public ISession getSessionBinder() {\n        return mSession;\n    }\n\n    /**\n     * Get the session token for creating {@link MediaController}.\n     *\n     * @return The session token.\n     */\n    public MediaSession.Token getSessionToken() {\n        return mSessionToken;\n    }\n\n    /**\n     * Get the info for this session.\n     *\n     * @return Info that identifies this session.\n     */\n    @Override\n    public String getPackageName() {\n        return mPackageName;\n    }\n\n    /**\n     * Get the intent the app set for their media button receiver.\n     *\n     * @return The pending intent set by the app or null.\n     */\n    public MediaButtonReceiverHolder getMediaButtonReceiver() {\n        return mMediaButtonReceiverHolder;\n    }\n\n    /**\n     * Get the UID this session was created for.\n     *\n     * @return The UID for this session.\n     */\n    @Override\n    public int getUid() {\n        return mOwnerUid;\n    }\n\n    /**\n     * Get the user id this session was created for.\n     *\n     * @return The user id for this session.\n     */\n    @Override\n    public int getUserId() {\n        return mUserId;\n    }\n\n    /**\n     * Check if this session has system priorty and should receive media buttons\n     * before any other sessions.\n     *\n     * @return True if this is a system priority session, false otherwise\n     */\n    @Override\n    public boolean isSystemPriority() {\n        return (mFlags & MediaSession.FLAG_EXCLUSIVE_GLOBAL_PRIORITY) != 0;\n    }\n\n    /**\n     * Send a volume adjustment to the session owner. Direction must be one of\n     * {@link AudioManager#ADJUST_LOWER}, {@link AudioManager#ADJUST_RAISE},\n     * {@link AudioManager#ADJUST_SAME}.\n     *\n     * @param packageName The package that made the original volume request.\n     * @param opPackageName The op package that made the original volume request.\n     * @param pid The pid that made the original volume request.\n     * @param uid The uid that made the original volume request.\n     * @param asSystemService {@code true} if the event sent to the session as if it was come from\n     *          the system service instead of the app process. This helps sessions to distinguish\n     *          between the key injection by the app and key events from the hardware devices.\n     *          Should be used only when the volume key events aren't handled by foreground\n     *          activity. {@code false} otherwise to tell session about the real caller.\n     * @param direction The direction to adjust volume in.\n     * @param flags Any of the flags from {@link AudioManager}.\n     * @param useSuggested True to use adjustSuggestedStreamVolumeForUid instead of\n     *          adjustStreamVolumeForUid\n     */\n    public void adjustVolume(String packageName, String opPackageName, int pid, int uid,\n            boolean asSystemService, int direction, int flags, boolean useSuggested) {\n        int previousFlagPlaySound = flags & AudioManager.FLAG_PLAY_SOUND;\n        if (checkPlaybackActiveState(true) || isSystemPriority()) {\n            flags &= ~AudioManager.FLAG_PLAY_SOUND;\n        }\n        if (mVolumeType == PLAYBACK_TYPE_LOCAL) {\n            // Adjust the volume with a handler not to be blocked by other system service.\n            int stream = getVolumeStream(mAudioAttrs);\n            postAdjustLocalVolume(stream, direction, flags, opPackageName, pid, uid,\n                    asSystemService, useSuggested, previousFlagPlaySound);\n        } else {\n            if (mVolumeControlType == VOLUME_CONTROL_FIXED) {\n                if (DEBUG) {\n                    Log.d(TAG, \"Session does not support volume adjustment\");\n                }\n            } else if (direction == AudioManager.ADJUST_TOGGLE_MUTE\n                    || direction == AudioManager.ADJUST_MUTE\n                    || direction == AudioManager.ADJUST_UNMUTE) {\n                Log.w(TAG, \"Muting remote playback is not supported\");\n            } else {\n                if (DEBUG) {\n                    Log.w(TAG, \"adjusting volume, pkg=\" + packageName + \", asSystemService=\"\n                            + asSystemService + \", dir=\" + direction);\n                }\n                mSessionCb.adjustVolume(packageName, pid, uid, asSystemService, direction);\n\n                int volumeBefore = (mOptimisticVolume < 0 ? mCurrentVolume : mOptimisticVolume);\n                mOptimisticVolume = volumeBefore + direction;\n                mOptimisticVolume = Math.max(0, Math.min(mOptimisticVolume, mMaxVolume));\n                mHandler.removeCallbacks(mClearOptimisticVolumeRunnable);\n                mHandler.postDelayed(mClearOptimisticVolumeRunnable, OPTIMISTIC_VOLUME_TIMEOUT);\n                if (volumeBefore != mOptimisticVolume) {\n                    pushVolumeUpdate();\n                }\n\n                if (DEBUG) {\n                    Log.d(TAG, \"Adjusted optimistic volume to \" + mOptimisticVolume + \" max is \"\n                            + mMaxVolume);\n                }\n            }\n            // Always notify, even if the volume hasn't changed. This is important to ensure that\n            // System UI receives an event if a hardware volume key is pressed but the session that\n            // handles it does not allow volume adjustment. Without such an event, System UI would\n            // not show volume controls to the user.\n            mService.notifyRemoteVolumeChanged(flags, this);\n        }\n    }\n\n    private void setVolumeTo(String packageName, String opPackageName, int pid, int uid, int value,\n            int flags) {\n        if (mVolumeType == PLAYBACK_TYPE_LOCAL) {\n            int stream = getVolumeStream(mAudioAttrs);\n            final int volumeValue = value;\n            mHandler.post(new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        mAudioManager.setStreamVolumeForUid(stream, volumeValue, flags,\n                                opPackageName, uid, pid,\n                                mContext.getApplicationInfo().targetSdkVersion);\n                    } catch (IllegalArgumentException | SecurityException e) {\n                        Log.e(TAG, \"Cannot set volume: stream=\" + stream + \", value=\" + volumeValue\n                                + \", flags=\" + flags, e);\n                    }\n                }\n            });\n        } else {\n            if (mVolumeControlType != VOLUME_CONTROL_ABSOLUTE) {\n                if (DEBUG) {\n                    Log.d(TAG, \"Session does not support setting volume\");\n                }\n            } else {\n                value = Math.max(0, Math.min(value, mMaxVolume));\n                mSessionCb.setVolumeTo(packageName, pid, uid, value);\n\n                int volumeBefore = (mOptimisticVolume < 0 ? mCurrentVolume : mOptimisticVolume);\n                mOptimisticVolume = Math.max(0, Math.min(value, mMaxVolume));\n                mHandler.removeCallbacks(mClearOptimisticVolumeRunnable);\n                mHandler.postDelayed(mClearOptimisticVolumeRunnable, OPTIMISTIC_VOLUME_TIMEOUT);\n                if (volumeBefore != mOptimisticVolume) {\n                    pushVolumeUpdate();\n                }\n\n                if (DEBUG) {\n                    Log.d(TAG, \"Set optimistic volume to \" + mOptimisticVolume + \" max is \"\n                            + mMaxVolume);\n                }\n            }\n            // Always notify, even if the volume hasn't changed.\n            mService.notifyRemoteVolumeChanged(flags, this);\n        }\n    }\n\n    /**\n     * Check if this session has been set to active by the app.\n     * <p>\n     * It's not used to prioritize sessions for dispatching media keys since API 26, but still used\n     * to filter session list in MediaSessionManager#getActiveSessions().\n     *\n     * @return True if the session is active, false otherwise.\n     */\n    @Override\n    public boolean isActive() {\n        return mIsActive && !mDestroyed;\n    }\n\n    /**\n     * Check if the session's playback active state matches with the expectation. This always return\n     * {@code false} if the playback state is {@code null}, where we cannot know the actual playback\n     * state associated with the session.\n     *\n     * @param expected True if playback is expected to be active. false otherwise.\n     * @return True if the session's playback matches with the expectation. false otherwise.\n     */\n    @Override\n    public boolean checkPlaybackActiveState(boolean expected) {\n        if (mPlaybackState == null) {\n            return false;\n        }\n        return mPlaybackState.isActive() == expected;\n    }\n\n    /**\n     * Get whether the playback is local.\n     *\n     * @return {@code true} if the playback is local.\n     */\n    @Override\n    public boolean isPlaybackTypeLocal() {\n        return mVolumeType == PLAYBACK_TYPE_LOCAL;\n    }\n\n    @Override\n    public void binderDied() {\n        mService.onSessionDied(this);\n    }\n\n    /**\n     * Finish cleaning up this session, including disconnecting if connected and\n     * removing the death observer from the callback binder.\n     */\n    @Override\n    public void close() {\n        // Log the session's active state\n        // to measure usage of foreground service resources\n        int callingUid = Binder.getCallingUid();\n        int callingPid = Binder.getCallingPid();\n        LocalServices.getService(ActivityManagerInternal.class)\n                .logFgsApiEnd(ActivityManager.FOREGROUND_SERVICE_API_TYPE_MEDIA_PLAYBACK,\n                callingUid, callingPid);\n        synchronized (mLock) {\n            if (mDestroyed) {\n                return;\n            }\n            mSessionCb.mCb.asBinder().unlinkToDeath(this, 0);\n            mDestroyed = true;\n            mPlaybackState = null;\n            mHandler.post(MessageHandler.MSG_DESTROYED);\n        }\n    }\n\n    @Override\n    public boolean isClosed() {\n        synchronized (mLock) {\n            return mDestroyed;\n        }\n    }\n\n    /**\n     * Sends media button.\n     *\n     * @param packageName caller package name\n     * @param pid caller pid\n     * @param uid caller uid\n     * @param asSystemService {@code true} if the event sent to the session as if it was come from\n     *          the system service instead of the app process.\n     * @param ke key events\n     * @param sequenceId (optional) sequence id. Use this only when a wake lock is needed.\n     * @param cb (optional) result receiver to receive callback. Use this only when a wake lock is\n     *           needed.\n     * @return {@code true} if the attempt to send media button was successfully.\n     *         {@code false} otherwise.\n     */\n    public boolean sendMediaButton(String packageName, int pid, int uid, boolean asSystemService,\n            KeyEvent ke, int sequenceId, ResultReceiver cb) {\n        return mSessionCb.sendMediaButton(packageName, pid, uid, asSystemService, ke, sequenceId,\n                cb);\n    }\n\n    @Override\n    public boolean canHandleVolumeKey() {\n        if (isPlaybackTypeLocal()) {\n            return true;\n        }\n        if (mVolumeControlType == VOLUME_CONTROL_FIXED) {\n            return false;\n        }\n        if (mVolumeAdjustmentForRemoteGroupSessions) {\n            return true;\n        }\n        // See b/228021646 for details.\n        MediaRouter2Manager mRouter2Manager = MediaRouter2Manager.getInstance(mContext);\n        List<RoutingSessionInfo> sessions = mRouter2Manager.getRoutingSessions(mPackageName);\n        boolean foundNonSystemSession = false;\n        boolean remoteSessionAllowVolumeAdjustment = true;\n        for (RoutingSessionInfo session : sessions) {\n            if (!session.isSystemSession()) {\n                foundNonSystemSession = true;\n                if (session.getVolumeHandling() == PLAYBACK_VOLUME_FIXED) {\n                    remoteSessionAllowVolumeAdjustment = false;\n                }\n            }\n        }\n        if (!foundNonSystemSession) {\n            Log.d(TAG, \"Package \" + mPackageName\n                    + \" has a remote media session but no associated routing session\");\n        }\n        return foundNonSystemSession && remoteSessionAllowVolumeAdjustment;\n    }\n\n    @Override\n    public int getSessionPolicies() {\n        synchronized (mLock) {\n            return mPolicies;\n        }\n    }\n\n    @Override\n    public void setSessionPolicies(int policies) {\n        synchronized (mLock) {\n            mPolicies = policies;\n        }\n    }\n\n    @Override\n    public void dump(PrintWriter pw, String prefix) {\n        pw.println(prefix + mTag + \" \" + this);\n\n        final String indent = prefix + \"  \";\n        pw.println(indent + \"ownerPid=\" + mOwnerPid + \", ownerUid=\" + mOwnerUid\n                + \", userId=\" + mUserId);\n        pw.println(indent + \"package=\" + mPackageName);\n        pw.println(indent + \"launchIntent=\" + mLaunchIntent);\n        pw.println(indent + \"mediaButtonReceiver=\" + mMediaButtonReceiverHolder);\n        pw.println(indent + \"active=\" + mIsActive);\n        pw.println(indent + \"flags=\" + mFlags);\n        pw.println(indent + \"rating type=\" + mRatingType);\n        pw.println(indent + \"controllers: \" + mControllerCallbackHolders.size());\n        pw.println(indent + \"state=\" + (mPlaybackState == null ? null : mPlaybackState.toString()));\n        pw.println(indent + \"audioAttrs=\" + mAudioAttrs);\n        pw.append(indent)\n                .append(\"volumeType=\")\n                .append(toVolumeTypeString(mVolumeType))\n                .append(\", controlType=\")\n                .append(toVolumeControlTypeString(mVolumeControlType))\n                .append(\", max=\")\n                .append(Integer.toString(mMaxVolume))\n                .append(\", current=\")\n                .append(Integer.toString(mCurrentVolume))\n                .append(\", volumeControlId=\")\n                .append(mVolumeControlId)\n                .println();\n        pw.println(indent + \"metadata: \" + mMetadataDescription);\n        pw.println(indent + \"queueTitle=\" + mQueueTitle + \", size=\"\n                + (mQueue == null ? 0 : mQueue.size()));\n    }\n\n    private static String toVolumeControlTypeString(\n            @VolumeProvider.ControlType int volumeControlType) {\n        switch (volumeControlType) {\n            case VOLUME_CONTROL_FIXED:\n                return \"FIXED\";\n            case VOLUME_CONTROL_RELATIVE:\n                return \"RELATIVE\";\n            case VOLUME_CONTROL_ABSOLUTE:\n                return \"ABSOLUTE\";\n            default:\n                return TextUtils.formatSimple(\"unknown(%d)\", volumeControlType);\n        }\n    }\n\n    private static String toVolumeTypeString(@PlaybackInfo.PlaybackType int volumeType) {\n        switch (volumeType) {\n            case PLAYBACK_TYPE_LOCAL:\n                return \"LOCAL\";\n            case PLAYBACK_TYPE_REMOTE:\n                return \"REMOTE\";\n            default:\n                return TextUtils.formatSimple(\"unknown(%d)\", volumeType);\n        }\n    }\n\n    @Override\n    public String toString() {\n        return mPackageName + \"/\" + mTag + \" (userId=\" + mUserId + \")\";\n    }\n\n    private void postAdjustLocalVolume(final int stream, final int direction, final int flags,\n            final String callingOpPackageName, final int callingPid, final int callingUid,\n            final boolean asSystemService, final boolean useSuggested,\n            final int previousFlagPlaySound) {\n        if (DEBUG) {\n            Log.w(TAG, \"adjusting local volume, stream=\" + stream + \", dir=\" + direction\n                    + \", asSystemService=\" + asSystemService + \", useSuggested=\" + useSuggested);\n        }\n        // Must use opPackageName for adjusting volumes with UID.\n        final String opPackageName;\n        final int uid;\n        final int pid;\n        if (asSystemService) {\n            opPackageName = mContext.getOpPackageName();\n            uid = Process.SYSTEM_UID;\n            pid = Process.myPid();\n        } else {\n            opPackageName = callingOpPackageName;\n            uid = callingUid;\n            pid = callingPid;\n        }\n        mHandler.post(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    if (useSuggested) {\n                        if (AudioSystem.isStreamActive(stream, 0)) {\n                            mAudioManager.adjustSuggestedStreamVolumeForUid(stream,\n                                    direction, flags, opPackageName, uid, pid,\n                                    mContext.getApplicationInfo().targetSdkVersion);\n                        } else {\n                            mAudioManager.adjustSuggestedStreamVolumeForUid(\n                                    AudioManager.USE_DEFAULT_STREAM_TYPE, direction,\n                                    flags | previousFlagPlaySound, opPackageName, uid, pid,\n                                    mContext.getApplicationInfo().targetSdkVersion);\n                        }\n                    } else {\n                        mAudioManager.adjustStreamVolumeForUid(stream, direction, flags,\n                                opPackageName, uid, pid,\n                                mContext.getApplicationInfo().targetSdkVersion);\n                    }\n                } catch (IllegalArgumentException | SecurityException e) {\n                    Log.e(TAG, \"Cannot adjust volume: direction=\" + direction + \", stream=\"\n                            + stream + \", flags=\" + flags + \", opPackageName=\" + opPackageName\n                            + \", uid=\" + uid + \", useSuggested=\" + useSuggested\n                            + \", previousFlagPlaySound=\" + previousFlagPlaySound, e);\n                }\n            }\n        });\n    }\n\n    private void logCallbackException(\n            String msg, ISessionControllerCallbackHolder holder, Exception e) {\n        Log.v(TAG, msg + \", this=\" + this + \", callback package=\" + holder.mPackageName\n                + \", exception=\" + e);\n    }\n\n    private void pushPlaybackStateUpdate() {\n        PlaybackState playbackState;\n        synchronized (mLock) {\n            if (mDestroyed) {\n                return;\n            }\n            playbackState = mPlaybackState;\n        }\n        Collection<ISessionControllerCallbackHolder> deadCallbackHolders = null;\n        for (ISessionControllerCallbackHolder holder : mControllerCallbackHolders) {\n            try {\n                holder.mCallback.onPlaybackStateChanged(playbackState);\n            } catch (DeadObjectException e) {\n                if (deadCallbackHolders == null) {\n                    deadCallbackHolders = new ArrayList<>();\n                }\n                deadCallbackHolders.add(holder);\n                logCallbackException(\"Removing dead callback in pushPlaybackStateUpdate\", holder,\n                        e);\n            } catch (RemoteException e) {\n                logCallbackException(\"unexpected exception in pushPlaybackStateUpdate\", holder, e);\n            }\n        }\n        if (deadCallbackHolders != null) {\n            mControllerCallbackHolders.removeAll(deadCallbackHolders);\n        }\n    }\n\n    private void pushMetadataUpdate() {\n        MediaMetadata metadata;\n        synchronized (mLock) {\n            if (mDestroyed) {\n                return;\n            }\n            metadata = mMetadata;\n        }\n        Collection<ISessionControllerCallbackHolder> deadCallbackHolders = null;\n        for (ISessionControllerCallbackHolder holder : mControllerCallbackHolders) {\n            try {\n                holder.mCallback.onMetadataChanged(metadata);\n            } catch (DeadObjectException e) {\n                if (deadCallbackHolders == null) {\n                    deadCallbackHolders = new ArrayList<>();\n                }\n                deadCallbackHolders.add(holder);\n                logCallbackException(\"Removing dead callback in pushMetadataUpdate\", holder, e);\n            } catch (RemoteException e) {\n                logCallbackException(\"unexpected exception in pushMetadataUpdate\", holder, e);\n            }\n        }\n        if (deadCallbackHolders != null) {\n            mControllerCallbackHolders.removeAll(deadCallbackHolders);\n        }\n    }\n\n    private void pushQueueUpdate() {\n        ArrayList<QueueItem> toSend;\n        synchronized (mLock) {\n            if (mDestroyed) {\n                return;\n            }\n            toSend = mQueue == null ? null : new ArrayList<>(mQueue);\n        }\n        Collection<ISessionControllerCallbackHolder> deadCallbackHolders = null;\n        for (ISessionControllerCallbackHolder holder : mControllerCallbackHolders) {\n            ParceledListSlice<QueueItem> parcelableQueue = null;\n            if (toSend != null) {\n                parcelableQueue = new ParceledListSlice<>(toSend);\n                // Limit the size of initial Parcel to prevent binder buffer overflow\n                // as onQueueChanged is an async binder call.\n                parcelableQueue.setInlineCountLimit(1);\n            }\n\n            try {\n                holder.mCallback.onQueueChanged(parcelableQueue);\n            } catch (DeadObjectException e) {\n                if (deadCallbackHolders == null) {\n                    deadCallbackHolders = new ArrayList<>();\n                }\n                deadCallbackHolders.add(holder);\n                logCallbackException(\"Removing dead callback in pushQueueUpdate\", holder, e);\n            } catch (RemoteException e) {\n                logCallbackException(\"unexpected exception in pushQueueUpdate\", holder, e);\n            }\n        }\n        if (deadCallbackHolders != null) {\n            mControllerCallbackHolders.removeAll(deadCallbackHolders);\n        }\n    }\n\n    private void pushQueueTitleUpdate() {\n        CharSequence queueTitle;\n        synchronized (mLock) {\n            if (mDestroyed) {\n                return;\n            }\n            queueTitle = mQueueTitle;\n        }\n        Collection<ISessionControllerCallbackHolder> deadCallbackHolders = null;\n        for (ISessionControllerCallbackHolder holder : mControllerCallbackHolders) {\n            try {\n                holder.mCallback.onQueueTitleChanged(queueTitle);\n            } catch (DeadObjectException e) {\n                if (deadCallbackHolders == null) {\n                    deadCallbackHolders = new ArrayList<>();\n                }\n                deadCallbackHolders.add(holder);\n                logCallbackException(\"Removing dead callback in pushQueueTitleUpdate\", holder, e);\n            } catch (RemoteException e) {\n                logCallbackException(\"unexpected exception in pushQueueTitleUpdate\", holder, e);\n            }\n        }\n        if (deadCallbackHolders != null) {\n            mControllerCallbackHolders.removeAll(deadCallbackHolders);\n        }\n    }\n\n    private void pushExtrasUpdate() {\n        Bundle extras;\n        synchronized (mLock) {\n            if (mDestroyed) {\n                return;\n            }\n            extras = mExtras;\n        }\n        Collection<ISessionControllerCallbackHolder> deadCallbackHolders = null;\n        for (ISessionControllerCallbackHolder holder : mControllerCallbackHolders) {\n            try {\n                holder.mCallback.onExtrasChanged(extras);\n            } catch (DeadObjectException e) {\n                if (deadCallbackHolders == null) {\n                    deadCallbackHolders = new ArrayList<>();\n                }\n                deadCallbackHolders.add(holder);\n                logCallbackException(\"Removing dead callback in pushExtrasUpdate\", holder, e);\n            } catch (RemoteException e) {\n                logCallbackException(\"unexpected exception in pushExtrasUpdate\", holder, e);\n            }\n        }\n        if (deadCallbackHolders != null) {\n            mControllerCallbackHolders.removeAll(deadCallbackHolders);\n        }\n    }\n\n    private void pushVolumeUpdate() {\n        PlaybackInfo info;\n        synchronized (mLock) {\n            if (mDestroyed) {\n                return;\n            }\n            info = getVolumeAttributes();\n        }\n        Collection<ISessionControllerCallbackHolder> deadCallbackHolders = null;\n        for (ISessionControllerCallbackHolder holder : mControllerCallbackHolders) {\n            try {\n                holder.mCallback.onVolumeInfoChanged(info);\n            } catch (DeadObjectException e) {\n                if (deadCallbackHolders == null) {\n                    deadCallbackHolders = new ArrayList<>();\n                }\n                deadCallbackHolders.add(holder);\n                logCallbackException(\"Removing dead callback in pushVolumeUpdate\", holder, e);\n            } catch (RemoteException e) {\n                logCallbackException(\"unexpected exception in pushVolumeUpdate\", holder, e);\n            }\n        }\n        if (deadCallbackHolders != null) {\n            mControllerCallbackHolders.removeAll(deadCallbackHolders);\n        }\n    }\n\n    private void pushEvent(String event, Bundle data) {\n        synchronized (mLock) {\n            if (mDestroyed) {\n                return;\n            }\n        }\n        Collection<ISessionControllerCallbackHolder> deadCallbackHolders = null;\n        for (ISessionControllerCallbackHolder holder : mControllerCallbackHolders) {\n            try {\n                holder.mCallback.onEvent(event, data);\n            } catch (DeadObjectException e) {\n                if (deadCallbackHolders == null) {\n                    deadCallbackHolders = new ArrayList<>();\n                }\n                deadCallbackHolders.add(holder);\n                logCallbackException(\"Removing dead callback in pushEvent\", holder, e);\n            } catch (RemoteException e) {\n                logCallbackException(\"unexpected exception in pushEvent\", holder, e);\n            }\n        }\n        if (deadCallbackHolders != null) {\n            mControllerCallbackHolders.removeAll(deadCallbackHolders);\n        }\n    }\n\n    private void pushSessionDestroyed() {\n        synchronized (mLock) {\n            // This is the only method that may be (and can only be) called\n            // after the session is destroyed.\n            if (!mDestroyed) {\n                return;\n            }\n        }\n        for (ISessionControllerCallbackHolder holder : mControllerCallbackHolders) {\n            try {\n                holder.mCallback.asBinder().unlinkToDeath(holder.mDeathMonitor, 0);\n                holder.mCallback.onSessionDestroyed();\n            } catch (NoSuchElementException e) {\n                logCallbackException(\"error unlinking to binder death\", holder, e);\n            } catch (DeadObjectException e) {\n                logCallbackException(\"Removing dead callback in pushSessionDestroyed\", holder, e);\n            } catch (RemoteException e) {\n                logCallbackException(\"unexpected exception in pushSessionDestroyed\", holder, e);\n            }\n        }\n        // After notifying clear all listeners\n        mControllerCallbackHolders.clear();\n    }\n\n    private PlaybackState getStateWithUpdatedPosition() {\n        PlaybackState state;\n        long duration;\n        synchronized (mLock) {\n            if (mDestroyed) {\n                return null;\n            }\n            state = mPlaybackState;\n            duration = mDuration;\n        }\n        PlaybackState result = null;\n        if (state != null) {\n            if (state.getState() == PlaybackState.STATE_PLAYING\n                    || state.getState() == PlaybackState.STATE_FAST_FORWARDING\n                    || state.getState() == PlaybackState.STATE_REWINDING) {\n                long updateTime = state.getLastPositionUpdateTime();\n                long currentTime = SystemClock.elapsedRealtime();\n                if (updateTime > 0) {\n                    long position = (long) (state.getPlaybackSpeed()\n                            * (currentTime - updateTime)) + state.getPosition();\n                    if (duration >= 0 && position > duration) {\n                        position = duration;\n                    } else if (position < 0) {\n                        position = 0;\n                    }\n                    PlaybackState.Builder builder = new PlaybackState.Builder(state);\n                    builder.setState(state.getState(), position, state.getPlaybackSpeed(),\n                            currentTime);\n                    result = builder.build();\n                }\n            }\n        }\n        return result == null ? state : result;\n    }\n\n    private int getControllerHolderIndexForCb(ISessionControllerCallback cb) {\n        IBinder binder = cb.asBinder();\n        for (int i = mControllerCallbackHolders.size() - 1; i >= 0; i--) {\n            if (binder.equals(mControllerCallbackHolders.get(i).mCallback.asBinder())) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    private PlaybackInfo getVolumeAttributes() {\n        int volumeType;\n        AudioAttributes attributes;\n        synchronized (mLock) {\n            if (mVolumeType == PlaybackInfo.PLAYBACK_TYPE_REMOTE) {\n                int current = mOptimisticVolume != -1 ? mOptimisticVolume : mCurrentVolume;\n                return new PlaybackInfo(mVolumeType, mVolumeControlType, mMaxVolume, current,\n                        mAudioAttrs, mVolumeControlId);\n            }\n            volumeType = mVolumeType;\n            attributes = mAudioAttrs;\n        }\n        int stream = getVolumeStream(attributes);\n        int max = mAudioManager.getStreamMaxVolume(stream);\n        int current = mAudioManager.getStreamVolume(stream);\n        return new PlaybackInfo(\n                volumeType, VOLUME_CONTROL_ABSOLUTE, max, current, attributes, null);\n    }\n\n    private final Runnable mClearOptimisticVolumeRunnable = new Runnable() {\n        @Override\n        public void run() {\n            boolean needUpdate = (mOptimisticVolume != mCurrentVolume);\n            mOptimisticVolume = -1;\n            if (needUpdate) {\n                pushVolumeUpdate();\n            }\n        }\n    };\n\n    @RequiresPermission(Manifest.permission.INTERACT_ACROSS_USERS)\n    private static boolean componentNameExists(\n            @NonNull ComponentName componentName, @NonNull Context context, int userId) {\n        Intent mediaButtonIntent = new Intent(Intent.ACTION_MEDIA_BUTTON);\n        mediaButtonIntent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);\n        mediaButtonIntent.setComponent(componentName);\n\n        UserHandle userHandle = UserHandle.of(userId);\n        PackageManager pm = context.getPackageManager();\n\n        List<ResolveInfo> resolveInfos =\n                pm.queryBroadcastReceiversAsUser(\n                        mediaButtonIntent, PackageManager.ResolveInfoFlags.of(0), userHandle);\n        return !resolveInfos.isEmpty();\n    }\n\n    private final class SessionStub extends ISession.Stub {\n        @Override\n        public void destroySession() throws RemoteException {\n            final long token = Binder.clearCallingIdentity();\n            try {\n                mService.onSessionDied(MediaSessionRecord.this);\n            } finally {\n                Binder.restoreCallingIdentity(token);\n            }\n        }\n\n        @Override\n        public void sendEvent(String event, Bundle data) throws RemoteException {\n            mHandler.post(MessageHandler.MSG_SEND_EVENT, event,\n                    data == null ? null : new Bundle(data));\n        }\n\n        @Override\n        public ISessionController getController() throws RemoteException {\n            return mController;\n        }\n\n        @Override\n        public void setActive(boolean active) throws RemoteException {\n            // Log the session's active state\n            // to measure usage of foreground service resources\n            int callingUid = Binder.getCallingUid();\n            int callingPid = Binder.getCallingPid();\n            if (active) {\n                LocalServices.getService(ActivityManagerInternal.class)\n                        .logFgsApiBegin(ActivityManager.FOREGROUND_SERVICE_API_TYPE_MEDIA_PLAYBACK,\n                                callingUid, callingPid);\n            } else {\n                LocalServices.getService(ActivityManagerInternal.class)\n                        .logFgsApiEnd(ActivityManager.FOREGROUND_SERVICE_API_TYPE_MEDIA_PLAYBACK,\n                                callingUid, callingPid);\n            }\n\n            mIsActive = active;\n            long token = Binder.clearCallingIdentity();\n            try {\n                mService.onSessionActiveStateChanged(MediaSessionRecord.this);\n            } finally {\n                Binder.restoreCallingIdentity(token);\n            }\n            mHandler.post(MessageHandler.MSG_UPDATE_SESSION_STATE);\n        }\n\n        @Override\n        public void setFlags(int flags) throws RemoteException {\n            if ((flags & MediaSession.FLAG_EXCLUSIVE_GLOBAL_PRIORITY) != 0) {\n                int pid = Binder.getCallingPid();\n                int uid = Binder.getCallingUid();\n                mService.enforcePhoneStatePermission(pid, uid);\n            }\n            mFlags = flags;\n            if ((flags & MediaSession.FLAG_EXCLUSIVE_GLOBAL_PRIORITY) != 0) {\n                final long token = Binder.clearCallingIdentity();\n                try {\n                    mService.setGlobalPrioritySession(MediaSessionRecord.this);\n                } finally {\n                    Binder.restoreCallingIdentity(token);\n                }\n            }\n            mHandler.post(MessageHandler.MSG_UPDATE_SESSION_STATE);\n        }\n\n        @Override\n        public void setMediaButtonReceiver(@Nullable PendingIntent pi) throws RemoteException {\n            final int uid = Binder.getCallingUid();\n            final long token = Binder.clearCallingIdentity();\n            try {\n                if ((mPolicies & MediaSessionPolicyProvider.SESSION_POLICY_IGNORE_BUTTON_RECEIVER)\n                        != 0) {\n                    return;\n                }\n\n                if (pi != null && pi.isActivity()) {\n                    if (CompatChanges.isChangeEnabled(\n                            THROW_FOR_ACTIVITY_MEDIA_BUTTON_RECEIVER, uid)) {\n                        throw new IllegalArgumentException(\n                                \"The media button receiver cannot be set to an activity.\");\n                    } else {\n                        Log.w(TAG, \"Ignoring invalid media button receiver targeting an activity.\");\n                        return;\n                    }\n                }\n\n                mMediaButtonReceiverHolder =\n                        MediaButtonReceiverHolder.create(mUserId, pi, mPackageName);\n                mService.onMediaButtonReceiverChanged(MediaSessionRecord.this);\n            } finally {\n                Binder.restoreCallingIdentity(token);\n            }\n        }\n\n        @Override\n        @RequiresPermission(Manifest.permission.INTERACT_ACROSS_USERS)\n        public void setMediaButtonBroadcastReceiver(ComponentName receiver) throws RemoteException {\n            final int uid = Binder.getCallingUid();\n            final long token = Binder.clearCallingIdentity();\n            try {\n                //mPackageName has been verified in MediaSessionService.enforcePackageName().\n                if (receiver != null && !TextUtils.equals(\n                        mPackageName, receiver.getPackageName())) {\n                    EventLog.writeEvent(0x534e4554, \"238177121\", -1, \"\"); // SafetyNet logging.\n                    throw new IllegalArgumentException(\"receiver does not belong to \"\n                            + \"package name provided to MediaSessionRecord. Pkg = \" + mPackageName\n                            + \", Receiver Pkg = \" + receiver.getPackageName());\n                }\n                if ((mPolicies & MediaSessionPolicyProvider.SESSION_POLICY_IGNORE_BUTTON_RECEIVER)\n                        != 0) {\n                    return;\n                }\n\n                if (!componentNameExists(receiver, mContext, mUserId)) {\n                    if (CompatChanges.isChangeEnabled(THROW_FOR_INVALID_BROADCAST_RECEIVER, uid)) {\n                        throw new IllegalArgumentException(\"Invalid component name: \" + receiver);\n                    } else {\n                        Log.w(\n                                TAG,\n                                \"setMediaButtonBroadcastReceiver(): \"\n                                        + \"Ignoring invalid component name=\"\n                                        + receiver);\n                    }\n                    return;\n                }\n\n                mMediaButtonReceiverHolder = MediaButtonReceiverHolder.create(mUserId, receiver);\n                mService.onMediaButtonReceiverChanged(MediaSessionRecord.this);\n            } finally {\n                Binder.restoreCallingIdentity(token);\n            }\n        }\n\n        @Override\n        public void setLaunchPendingIntent(PendingIntent pi) throws RemoteException {\n            mLaunchIntent = pi;\n        }\n\n        @Override\n        public void setMetadata(MediaMetadata metadata, long duration, String metadataDescription)\n                throws RemoteException {\n            synchronized (mLock) {\n                mDuration = duration;\n                mMetadataDescription = metadataDescription;\n                mMetadata = sanitizeMediaMetadata(metadata);\n            }\n            mHandler.post(MessageHandler.MSG_UPDATE_METADATA);\n        }\n\n        private MediaMetadata sanitizeMediaMetadata(MediaMetadata metadata) {\n            if (metadata == null) {\n                return null;\n            }\n            MediaMetadata.Builder metadataBuilder = new MediaMetadata.Builder(metadata);\n            for (String key: ART_URIS) {\n                String uriString = metadata.getString(key);\n                if (TextUtils.isEmpty(uriString)) {\n                    continue;\n                }\n                Uri uri = Uri.parse(uriString);\n                if (!ContentResolver.SCHEME_CONTENT.equals(uri.getScheme())) {\n                    continue;\n                }\n                try {\n                    mUgmInternal.checkGrantUriPermission(getUid(),\n                            getPackageName(),\n                            ContentProvider.getUriWithoutUserId(uri),\n                            Intent.FLAG_GRANT_READ_URI_PERMISSION,\n                            ContentProvider.getUserIdFromUri(uri, getUserId()));\n                } catch (SecurityException e) {\n                    metadataBuilder.putString(key, null);\n                }\n            }\n            MediaMetadata sanitizedMetadata = metadataBuilder.build();\n            // sanitizedMetadata.size() guarantees that the underlying bundle is unparceled\n            // before we set it to prevent concurrent reads from throwing an\n            // exception\n            sanitizedMetadata.size();\n            return sanitizedMetadata;\n        }\n\n        @Override\n        public void setPlaybackState(PlaybackState state) throws RemoteException {\n            int oldState = mPlaybackState == null\n                    ? PlaybackState.STATE_NONE : mPlaybackState.getState();\n            int newState = state == null\n                    ? PlaybackState.STATE_NONE : state.getState();\n            boolean shouldUpdatePriority = ALWAYS_PRIORITY_STATES.contains(newState)\n                    || (!TRANSITION_PRIORITY_STATES.contains(oldState)\n                    && TRANSITION_PRIORITY_STATES.contains(newState));\n            synchronized (mLock) {\n                mPlaybackState = state;\n            }\n            final long token = Binder.clearCallingIdentity();\n            try {\n                mService.onSessionPlaybackStateChanged(\n                        MediaSessionRecord.this, shouldUpdatePriority);\n            } finally {\n                Binder.restoreCallingIdentity(token);\n            }\n            mHandler.post(MessageHandler.MSG_UPDATE_PLAYBACK_STATE);\n        }\n\n        @Override\n        public void resetQueue() throws RemoteException {\n            synchronized (mLock) {\n                mQueue = null;\n            }\n            mHandler.post(MessageHandler.MSG_UPDATE_QUEUE);\n        }\n\n        @Override\n        public IBinder getBinderForSetQueue() throws RemoteException {\n            return new ParcelableListBinder<QueueItem>((list) -> {\n                synchronized (mLock) {\n                    mQueue = list;\n                }\n                mHandler.post(MessageHandler.MSG_UPDATE_QUEUE);\n            });\n        }\n\n        @Override\n        public void setQueueTitle(CharSequence title) throws RemoteException {\n            mQueueTitle = title;\n            mHandler.post(MessageHandler.MSG_UPDATE_QUEUE_TITLE);\n        }\n\n        @Override\n        public void setExtras(Bundle extras) throws RemoteException {\n            synchronized (mLock) {\n                mExtras = extras == null ? null : new Bundle(extras);\n            }\n            mHandler.post(MessageHandler.MSG_UPDATE_EXTRAS);\n        }\n\n        @Override\n        public void setRatingType(int type) throws RemoteException {\n            mRatingType = type;\n        }\n\n        @Override\n        public void setCurrentVolume(int volume) throws RemoteException {\n            mCurrentVolume = volume;\n            mHandler.post(MessageHandler.MSG_UPDATE_VOLUME);\n        }\n\n        @Override\n        public void setPlaybackToLocal(AudioAttributes attributes) throws RemoteException {\n            boolean typeChanged;\n            synchronized (mLock) {\n                typeChanged = mVolumeType == PlaybackInfo.PLAYBACK_TYPE_REMOTE;\n                mVolumeType = PLAYBACK_TYPE_LOCAL;\n                mVolumeControlId = null;\n                if (attributes != null) {\n                    mAudioAttrs = attributes;\n                } else {\n                    Log.e(TAG, \"Received null audio attributes, using existing attributes\");\n                }\n            }\n            if (typeChanged) {\n                final long token = Binder.clearCallingIdentity();\n                try {\n                    mService.onSessionPlaybackTypeChanged(MediaSessionRecord.this);\n                } finally {\n                    Binder.restoreCallingIdentity(token);\n                }\n                mHandler.post(MessageHandler.MSG_UPDATE_VOLUME);\n            }\n        }\n\n        @Override\n        public void setPlaybackToRemote(int control, int max, String controlId)\n                throws RemoteException {\n            boolean typeChanged;\n            synchronized (mLock) {\n                typeChanged = mVolumeType == PLAYBACK_TYPE_LOCAL;\n                mVolumeType = PlaybackInfo.PLAYBACK_TYPE_REMOTE;\n                mVolumeControlType = control;\n                mMaxVolume = max;\n                mVolumeControlId = controlId;\n            }\n            if (typeChanged) {\n                final long token = Binder.clearCallingIdentity();\n                try {\n                    mService.onSessionPlaybackTypeChanged(MediaSessionRecord.this);\n                } finally {\n                    Binder.restoreCallingIdentity(token);\n                }\n                mHandler.post(MessageHandler.MSG_UPDATE_VOLUME);\n            }\n        }\n    }\n\n    class SessionCb {\n        private final ISessionCallback mCb;\n\n        SessionCb(ISessionCallback cb) {\n            mCb = cb;\n        }\n\n        public boolean sendMediaButton(String packageName, int pid, int uid,\n                boolean asSystemService, KeyEvent keyEvent, int sequenceId, ResultReceiver cb) {\n            try {\n                if (KeyEvent.isMediaSessionKey(keyEvent.getKeyCode())) {\n                    final String reason = \"action=\" + KeyEvent.actionToString(keyEvent.getAction())\n                            + \";code=\" + KeyEvent.keyCodeToString(keyEvent.getKeyCode());\n                    mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),\n                            pid, uid, packageName, reason);\n                }\n                if (asSystemService) {\n                    mCb.onMediaButton(mContext.getPackageName(), Process.myPid(),\n                            Process.SYSTEM_UID, createMediaButtonIntent(keyEvent), sequenceId, cb);\n                } else {\n                    mCb.onMediaButton(packageName, pid, uid,\n                            createMediaButtonIntent(keyEvent), sequenceId, cb);\n                }\n                return true;\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in sendMediaRequest.\", e);\n            }\n            return false;\n        }\n\n        public boolean sendMediaButton(String packageName, int pid, int uid,\n                boolean asSystemService, KeyEvent keyEvent) {\n            try {\n                if (KeyEvent.isMediaSessionKey(keyEvent.getKeyCode())) {\n                    final String reason = \"action=\" + KeyEvent.actionToString(keyEvent.getAction())\n                            + \";code=\" + KeyEvent.keyCodeToString(keyEvent.getKeyCode());\n                    mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),\n                            pid, uid, packageName, reason);\n                }\n                if (asSystemService) {\n                    mCb.onMediaButton(mContext.getPackageName(), Process.myPid(),\n                            Process.SYSTEM_UID, createMediaButtonIntent(keyEvent), 0, null);\n                } else {\n                    mCb.onMediaButtonFromController(packageName, pid, uid,\n                            createMediaButtonIntent(keyEvent));\n                }\n                return true;\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in sendMediaRequest.\", e);\n            }\n            return false;\n        }\n\n        public void sendCommand(String packageName, int pid, int uid, String command, Bundle args,\n                ResultReceiver cb) {\n            try {\n                final String reason = TAG + \":\" + command;\n                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),\n                        pid, uid, packageName, reason);\n                mCb.onCommand(packageName, pid, uid, command, args, cb);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in sendCommand.\", e);\n            }\n        }\n\n        public void sendCustomAction(String packageName, int pid, int uid, String action,\n                Bundle args) {\n            try {\n                final String reason = TAG + \":custom-\" + action;\n                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),\n                        pid, uid, packageName, reason);\n                mCb.onCustomAction(packageName, pid, uid, action, args);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in sendCustomAction.\", e);\n            }\n        }\n\n        public void prepare(String packageName, int pid, int uid) {\n            try {\n                final String reason = TAG + \":prepare\";\n                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),\n                        pid, uid, packageName, reason);\n                mCb.onPrepare(packageName, pid, uid);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in prepare.\", e);\n            }\n        }\n\n        public void prepareFromMediaId(String packageName, int pid, int uid, String mediaId,\n                Bundle extras) {\n            try {\n                final String reason = TAG + \":prepareFromMediaId\";\n                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),\n                        pid, uid, packageName, reason);\n                mCb.onPrepareFromMediaId(packageName, pid, uid, mediaId, extras);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in prepareFromMediaId.\", e);\n            }\n        }\n\n        public void prepareFromSearch(String packageName, int pid, int uid, String query,\n                Bundle extras) {\n            try {\n                final String reason = TAG + \":prepareFromSearch\";\n                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),\n                        pid, uid, packageName, reason);\n                mCb.onPrepareFromSearch(packageName, pid, uid, query, extras);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in prepareFromSearch.\", e);\n            }\n        }\n\n        public void prepareFromUri(String packageName, int pid, int uid, Uri uri, Bundle extras) {\n            try {\n                final String reason = TAG + \":prepareFromUri\";\n                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),\n                        pid, uid, packageName, reason);\n                mCb.onPrepareFromUri(packageName, pid, uid, uri, extras);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in prepareFromUri.\", e);\n            }\n        }\n\n        public void play(String packageName, int pid, int uid) {\n            try {\n                final String reason = TAG + \":play\";\n                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),\n                        pid, uid, packageName, reason);\n                mCb.onPlay(packageName, pid, uid);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in play.\", e);\n            }\n        }\n\n        public void playFromMediaId(String packageName, int pid, int uid, String mediaId,\n                Bundle extras) {\n            try {\n                final String reason = TAG + \":playFromMediaId\";\n                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),\n                        pid, uid, packageName, reason);\n                mCb.onPlayFromMediaId(packageName, pid, uid, mediaId, extras);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in playFromMediaId.\", e);\n            }\n        }\n\n        public void playFromSearch(String packageName, int pid, int uid, String query,\n                Bundle extras) {\n            try {\n                final String reason = TAG + \":playFromSearch\";\n                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),\n                        pid, uid, packageName, reason);\n                mCb.onPlayFromSearch(packageName, pid, uid, query, extras);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in playFromSearch.\", e);\n            }\n        }\n\n        public void playFromUri(String packageName, int pid, int uid, Uri uri, Bundle extras) {\n            try {\n                final String reason = TAG + \":playFromUri\";\n                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),\n                        pid, uid, packageName, reason);\n                mCb.onPlayFromUri(packageName, pid, uid, uri, extras);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in playFromUri.\", e);\n            }\n        }\n\n        public void skipToTrack(String packageName, int pid, int uid, long id) {\n            try {\n                final String reason = TAG + \":skipToTrack\";\n                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),\n                        pid, uid, packageName, reason);\n                mCb.onSkipToTrack(packageName, pid, uid, id);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in skipToTrack\", e);\n            }\n        }\n\n        public void pause(String packageName, int pid, int uid) {\n            try {\n                final String reason = TAG + \":pause\";\n                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),\n                        pid, uid, packageName, reason);\n                mCb.onPause(packageName, pid, uid);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in pause.\", e);\n            }\n        }\n\n        public void stop(String packageName, int pid, int uid) {\n            try {\n                final String reason = TAG + \":stop\";\n                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),\n                        pid, uid, packageName, reason);\n                mCb.onStop(packageName, pid, uid);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in stop.\", e);\n            }\n        }\n\n        public void next(String packageName, int pid, int uid) {\n            try {\n                final String reason = TAG + \":next\";\n                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),\n                        pid, uid, packageName, reason);\n                mCb.onNext(packageName, pid, uid);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in next.\", e);\n            }\n        }\n\n        public void previous(String packageName, int pid, int uid) {\n            try {\n                final String reason = TAG + \":previous\";\n                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),\n                        pid, uid, packageName, reason);\n                mCb.onPrevious(packageName, pid, uid);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in previous.\", e);\n            }\n        }\n\n        public void fastForward(String packageName, int pid, int uid) {\n            try {\n                final String reason = TAG + \":fastForward\";\n                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),\n                        pid, uid, packageName, reason);\n                mCb.onFastForward(packageName, pid, uid);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in fastForward.\", e);\n            }\n        }\n\n        public void rewind(String packageName, int pid, int uid) {\n            try {\n                final String reason = TAG + \":rewind\";\n                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),\n                        pid, uid, packageName, reason);\n                mCb.onRewind(packageName, pid, uid);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in rewind.\", e);\n            }\n        }\n\n        public void seekTo(String packageName, int pid, int uid, long pos) {\n            try {\n                final String reason = TAG + \":seekTo\";\n                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),\n                        pid, uid, packageName, reason);\n                mCb.onSeekTo(packageName, pid, uid, pos);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in seekTo.\", e);\n            }\n        }\n\n        public void rate(String packageName, int pid, int uid, Rating rating) {\n            try {\n                final String reason = TAG + \":rate\";\n                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),\n                        pid, uid, packageName, reason);\n                mCb.onRate(packageName, pid, uid, rating);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in rate.\", e);\n            }\n        }\n\n        public void setPlaybackSpeed(String packageName, int pid, int uid, float speed) {\n            try {\n                final String reason = TAG + \":setPlaybackSpeed\";\n                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),\n                        pid, uid, packageName, reason);\n                mCb.onSetPlaybackSpeed(packageName, pid, uid, speed);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in setPlaybackSpeed.\", e);\n            }\n        }\n\n        public void adjustVolume(String packageName, int pid, int uid, boolean asSystemService,\n                int direction) {\n            try {\n                final String reason = TAG + \":adjustVolume\";\n                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),\n                        pid, uid, packageName, reason);\n                if (asSystemService) {\n                    mCb.onAdjustVolume(mContext.getPackageName(), Process.myPid(),\n                            Process.SYSTEM_UID, direction);\n                } else {\n                    mCb.onAdjustVolume(packageName, pid, uid, direction);\n                }\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in adjustVolume.\", e);\n            }\n        }\n\n        public void setVolumeTo(String packageName, int pid, int uid, int value) {\n            try {\n                final String reason = TAG + \":setVolumeTo\";\n                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),\n                        pid, uid, packageName, reason);\n                mCb.onSetVolumeTo(packageName, pid, uid, value);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in setVolumeTo.\", e);\n            }\n        }\n\n        private Intent createMediaButtonIntent(KeyEvent keyEvent) {\n            Intent mediaButtonIntent = new Intent(Intent.ACTION_MEDIA_BUTTON);\n            mediaButtonIntent.putExtra(Intent.EXTRA_KEY_EVENT, keyEvent);\n            return mediaButtonIntent;\n        }\n    }\n\n    class ControllerStub extends ISessionController.Stub {\n        @Override\n        public void sendCommand(String packageName, String command, Bundle args,\n                ResultReceiver cb) {\n            mSessionCb.sendCommand(packageName, Binder.getCallingPid(), Binder.getCallingUid(),\n                    command, args, cb);\n        }\n\n        @Override\n        public boolean sendMediaButton(String packageName, KeyEvent keyEvent) {\n            return mSessionCb.sendMediaButton(packageName, Binder.getCallingPid(),\n                    Binder.getCallingUid(), false, keyEvent);\n        }\n\n        @Override\n        public void registerCallback(String packageName, ISessionControllerCallback cb) {\n            synchronized (mLock) {\n                // If this session is already destroyed tell the caller and\n                // don't add them.\n                if (mDestroyed) {\n                    try {\n                        cb.onSessionDestroyed();\n                    } catch (Exception e) {\n                        // ignored\n                    }\n                    return;\n                }\n                if (getControllerHolderIndexForCb(cb) < 0) {\n                    ISessionControllerCallbackHolder holder = new ISessionControllerCallbackHolder(\n                        cb, packageName, Binder.getCallingUid(), () -> unregisterCallback(cb));\n                    mControllerCallbackHolders.add(holder);\n                    if (DEBUG) {\n                        Log.d(TAG, \"registering controller callback \" + cb + \" from controller\"\n                                + packageName);\n                    }\n                    // Avoid callback leaks\n                    try {\n                        // cb is not referenced outside of the MediaSessionRecord, so the death\n                        // handler won't prevent MediaSessionRecord to be garbage collected.\n                        cb.asBinder().linkToDeath(holder.mDeathMonitor, 0);\n                    } catch (RemoteException e) {\n                        unregisterCallback(cb);\n                        Log.w(TAG, \"registerCallback failed to linkToDeath\", e);\n                    }\n                }\n            }\n        }\n\n        @Override\n        public void unregisterCallback(ISessionControllerCallback cb) {\n            synchronized (mLock) {\n                int index = getControllerHolderIndexForCb(cb);\n                if (index != -1) {\n                    try {\n                        cb.asBinder().unlinkToDeath(\n                          mControllerCallbackHolders.get(index).mDeathMonitor, 0);\n                    } catch (NoSuchElementException e) {\n                        Log.w(TAG, \"error unlinking to binder death\", e);\n                    }\n                    mControllerCallbackHolders.remove(index);\n                }\n                if (DEBUG) {\n                    Log.d(TAG, \"unregistering callback \" + cb.asBinder());\n                }\n            }\n        }\n\n        @Override\n        public String getPackageName() {\n            return mPackageName;\n        }\n\n        @Override\n        public String getTag() {\n            return mTag;\n        }\n\n        @Override\n        public Bundle getSessionInfo() {\n            return mSessionInfo;\n        }\n\n        @Override\n        public PendingIntent getLaunchPendingIntent() {\n            return mLaunchIntent;\n        }\n\n        @Override\n        public long getFlags() {\n            return mFlags;\n        }\n\n        @Override\n        public PlaybackInfo getVolumeAttributes() {\n            return MediaSessionRecord.this.getVolumeAttributes();\n        }\n\n        @Override\n        public void adjustVolume(String packageName, String opPackageName, int direction,\n                int flags) {\n            int pid = Binder.getCallingPid();\n            int uid = Binder.getCallingUid();\n            final long token = Binder.clearCallingIdentity();\n            try {\n                MediaSessionRecord.this.adjustVolume(packageName, opPackageName, pid, uid,\n                        false, direction, flags, false /* useSuggested */);\n            } finally {\n                Binder.restoreCallingIdentity(token);\n            }\n        }\n\n        @Override\n        public void setVolumeTo(String packageName, String opPackageName, int value, int flags) {\n            int pid = Binder.getCallingPid();\n            int uid = Binder.getCallingUid();\n            final long token = Binder.clearCallingIdentity();\n            try {\n                MediaSessionRecord.this.setVolumeTo(packageName, opPackageName, pid, uid, value,\n                        flags);\n            } finally {\n                Binder.restoreCallingIdentity(token);\n            }\n        }\n\n        @Override\n        public void prepare(String packageName) {\n            mSessionCb.prepare(packageName, Binder.getCallingPid(), Binder.getCallingUid());\n        }\n\n        @Override\n        public void prepareFromMediaId(String packageName, String mediaId, Bundle extras) {\n            mSessionCb.prepareFromMediaId(packageName, Binder.getCallingPid(),\n                    Binder.getCallingUid(), mediaId, extras);\n        }\n\n        @Override\n        public void prepareFromSearch(String packageName, String query, Bundle extras) {\n            mSessionCb.prepareFromSearch(packageName, Binder.getCallingPid(),\n                    Binder.getCallingUid(), query, extras);\n        }\n\n        @Override\n        public void prepareFromUri(String packageName, Uri uri, Bundle extras) {\n            mSessionCb.prepareFromUri(packageName, Binder.getCallingPid(), Binder.getCallingUid(),\n                    uri, extras);\n        }\n\n        @Override\n        public void play(String packageName) {\n            mSessionCb.play(packageName, Binder.getCallingPid(), Binder.getCallingUid());\n        }\n\n        @Override\n        public void playFromMediaId(String packageName, String mediaId, Bundle extras) {\n            mSessionCb.playFromMediaId(packageName, Binder.getCallingPid(), Binder.getCallingUid(),\n                    mediaId, extras);\n        }\n\n        @Override\n        public void playFromSearch(String packageName, String query, Bundle extras) {\n            mSessionCb.playFromSearch(packageName, Binder.getCallingPid(), Binder.getCallingUid(),\n                     query, extras);\n        }\n\n        @Override\n        public void playFromUri(String packageName, Uri uri, Bundle extras) {\n            mSessionCb.playFromUri(packageName, Binder.getCallingPid(), Binder.getCallingUid(),\n                    uri, extras);\n        }\n\n        @Override\n        public void skipToQueueItem(String packageName, long id) {\n            mSessionCb.skipToTrack(packageName, Binder.getCallingPid(), Binder.getCallingUid(), id);\n        }\n\n        @Override\n        public void pause(String packageName) {\n            mSessionCb.pause(packageName, Binder.getCallingPid(), Binder.getCallingUid());\n        }\n\n        @Override\n        public void stop(String packageName) {\n            mSessionCb.stop(packageName, Binder.getCallingPid(), Binder.getCallingUid());\n        }\n\n        @Override\n        public void next(String packageName) {\n            mSessionCb.next(packageName, Binder.getCallingPid(), Binder.getCallingUid());\n        }\n\n        @Override\n        public void previous(String packageName) {\n            mSessionCb.previous(packageName, Binder.getCallingPid(), Binder.getCallingUid());\n        }\n\n        @Override\n        public void fastForward(String packageName) {\n            mSessionCb.fastForward(packageName, Binder.getCallingPid(), Binder.getCallingUid());\n        }\n\n        @Override\n        public void rewind(String packageName) {\n            mSessionCb.rewind(packageName, Binder.getCallingPid(), Binder.getCallingUid());\n        }\n\n        @Override\n        public void seekTo(String packageName, long pos) {\n            mSessionCb.seekTo(packageName, Binder.getCallingPid(), Binder.getCallingUid(), pos);\n        }\n\n        @Override\n        public void rate(String packageName, Rating rating) {\n            mSessionCb.rate(packageName, Binder.getCallingPid(), Binder.getCallingUid(), rating);\n        }\n\n        @Override\n        public void setPlaybackSpeed(String packageName,\n                float speed) {\n            mSessionCb.setPlaybackSpeed(packageName, Binder.getCallingPid(), Binder.getCallingUid(),\n                    speed);\n        }\n\n        @Override\n        public void sendCustomAction(String packageName, String action, Bundle args) {\n            mSessionCb.sendCustomAction(packageName, Binder.getCallingPid(), Binder.getCallingUid(),\n                    action, args);\n        }\n\n        @Override\n        public MediaMetadata getMetadata() {\n            synchronized (mLock) {\n                return mMetadata;\n            }\n        }\n\n        @Override\n        public PlaybackState getPlaybackState() {\n            return getStateWithUpdatedPosition();\n        }\n\n        @Override\n        public ParceledListSlice getQueue() {\n            synchronized (mLock) {\n                return mQueue == null ? null : new ParceledListSlice<>(mQueue);\n            }\n        }\n\n        @Override\n        public CharSequence getQueueTitle() {\n            return mQueueTitle;\n        }\n\n        @Override\n        public Bundle getExtras() {\n            synchronized (mLock) {\n                return mExtras;\n            }\n        }\n\n        @Override\n        public int getRatingType() {\n            return mRatingType;\n        }\n    }\n\n    private class ISessionControllerCallbackHolder {\n        private final ISessionControllerCallback mCallback;\n        private final String mPackageName;\n        private final int mUid;\n        private final IBinder.DeathRecipient mDeathMonitor;\n\n        ISessionControllerCallbackHolder(ISessionControllerCallback callback, String packageName,\n                int uid, IBinder.DeathRecipient deathMonitor) {\n            mCallback = callback;\n            mPackageName = packageName;\n            mUid = uid;\n            mDeathMonitor = deathMonitor;\n        }\n    }\n\n    private class MessageHandler extends Handler {\n        private static final int MSG_UPDATE_METADATA = 1;\n        private static final int MSG_UPDATE_PLAYBACK_STATE = 2;\n        private static final int MSG_UPDATE_QUEUE = 3;\n        private static final int MSG_UPDATE_QUEUE_TITLE = 4;\n        private static final int MSG_UPDATE_EXTRAS = 5;\n        private static final int MSG_SEND_EVENT = 6;\n        private static final int MSG_UPDATE_SESSION_STATE = 7;\n        private static final int MSG_UPDATE_VOLUME = 8;\n        private static final int MSG_DESTROYED = 9;\n\n        public MessageHandler(Looper looper) {\n            super(looper);\n        }\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MSG_UPDATE_METADATA:\n                    pushMetadataUpdate();\n                    break;\n                case MSG_UPDATE_PLAYBACK_STATE:\n                    pushPlaybackStateUpdate();\n                    break;\n                case MSG_UPDATE_QUEUE:\n                    pushQueueUpdate();\n                    break;\n                case MSG_UPDATE_QUEUE_TITLE:\n                    pushQueueTitleUpdate();\n                    break;\n                case MSG_UPDATE_EXTRAS:\n                    pushExtrasUpdate();\n                    break;\n                case MSG_SEND_EVENT:\n                    pushEvent((String) msg.obj, msg.getData());\n                    break;\n                case MSG_UPDATE_SESSION_STATE:\n                    // TODO add session state\n                    break;\n                case MSG_UPDATE_VOLUME:\n                    pushVolumeUpdate();\n                    break;\n                case MSG_DESTROYED:\n                    pushSessionDestroyed();\n            }\n        }\n\n        public void post(int what) {\n            post(what, null);\n        }\n\n        public void post(int what, Object obj) {\n            obtainMessage(what, obj).sendToTarget();\n        }\n\n        public void post(int what, Object obj, Bundle data) {\n            Message msg = obtainMessage(what, obj);\n            msg.setData(data);\n            msg.sendToTarget();\n        }\n    }\n}\n```",
                        "downstream_file_content": "```java\n/*\n * Copyright (C) 2014 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.server.media;\n\nimport android.Manifest;\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.annotation.RequiresPermission;\nimport android.app.PendingIntent;\nimport android.content.ComponentName;\nimport android.content.ContentProvider;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.pm.PackageManager;\nimport android.content.pm.ParceledListSlice;\nimport android.content.pm.ResolveInfo;\nimport android.media.AudioAttributes;\nimport android.media.AudioManager;\nimport android.media.AudioSystem;\nimport android.media.MediaMetadata;\nimport android.media.MediaRouter2Manager;\nimport android.media.Rating;\nimport android.media.RoutingSessionInfo;\nimport android.media.VolumeProvider;\nimport android.media.session.ISession;\nimport android.media.session.ISessionCallback;\nimport android.media.session.ISessionController;\nimport android.media.session.ISessionControllerCallback;\nimport android.media.session.MediaController;\nimport android.media.session.MediaController.PlaybackInfo;\nimport android.media.session.MediaSession;\nimport android.media.session.MediaSession.QueueItem;\nimport android.media.session.ParcelableListBinder;\nimport android.media.session.PlaybackState;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Bundle;\nimport android.os.DeadObjectException;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Message;\nimport android.os.Process;\nimport android.os.RemoteException;\nimport android.os.ResultReceiver;\nimport android.os.SystemClock;\nimport android.os.UserHandle;\nimport android.text.TextUtils;\nimport android.util.EventLog;\nimport android.util.Log;\nimport android.view.KeyEvent;\n\nimport com.android.server.LocalServices;\nimport com.android.server.uri.UriGrantsManagerInternal;\n\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.concurrent.CopyOnWriteArrayList;\n\n/**\n * This is the system implementation of a Session. Apps will interact with the\n * MediaSession wrapper class instead.\n */\n// TODO(jaewan): Do not call service method directly -- introduce listener instead.\npublic class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionRecordImpl {\n    private static final String TAG = \"MediaSessionRecord\";\n    private static final String[] ART_URIS = new String[] {\n            MediaMetadata.METADATA_KEY_ALBUM_ART_URI,\n            MediaMetadata.METADATA_KEY_ART_URI,\n            MediaMetadata.METADATA_KEY_DISPLAY_ICON_URI};\n    private static final boolean DEBUG = Log.isLoggable(TAG, Log.DEBUG);\n\n    /**\n     * The amount of time we'll send an assumed volume after the last volume\n     * command before reverting to the last reported volume.\n     */\n    private static final int OPTIMISTIC_VOLUME_TIMEOUT = 1000;\n\n    /**\n     * These are states that usually indicate the user took an action and should\n     * bump priority regardless of the old state.\n     */\n    private static final List<Integer> ALWAYS_PRIORITY_STATES = Arrays.asList(\n            PlaybackState.STATE_FAST_FORWARDING,\n            PlaybackState.STATE_REWINDING,\n            PlaybackState.STATE_SKIPPING_TO_PREVIOUS,\n            PlaybackState.STATE_SKIPPING_TO_NEXT);\n    /**\n     * These are states that usually indicate the user took an action if they\n     * were entered from a non-priority state.\n     */\n    private static final List<Integer> TRANSITION_PRIORITY_STATES = Arrays.asList(\n            PlaybackState.STATE_BUFFERING,\n            PlaybackState.STATE_CONNECTING,\n            PlaybackState.STATE_PLAYING);\n\n    private static final AudioAttributes DEFAULT_ATTRIBUTES =\n            new AudioAttributes.Builder().setUsage(AudioAttributes.USAGE_MEDIA).build();\n\n    private static int getVolumeStream(@Nullable AudioAttributes attr) {\n        if (attr == null) {\n            return DEFAULT_ATTRIBUTES.getVolumeControlStream();\n        }\n        final int stream = attr.getVolumeControlStream();\n        if (stream == AudioManager.USE_DEFAULT_STREAM_TYPE) {\n            return DEFAULT_ATTRIBUTES.getVolumeControlStream();\n        }\n        return stream;\n    }\n\n    private final MessageHandler mHandler;\n\n    private final int mOwnerPid;\n    private final int mOwnerUid;\n    private final int mUserId;\n    private final String mPackageName;\n    private final String mTag;\n    private final Bundle mSessionInfo;\n    private final ControllerStub mController;\n    private final MediaSession.Token mSessionToken;\n    private final SessionStub mSession;\n    private final SessionCb mSessionCb;\n    private final MediaSessionService mService;\n    private final UriGrantsManagerInternal mUgmInternal;\n    private final Context mContext;\n    private final boolean mVolumeAdjustmentForRemoteGroupSessions;\n\n    private final Object mLock = new Object();\n    private final CopyOnWriteArrayList<ISessionControllerCallbackHolder>\n            mControllerCallbackHolders = new CopyOnWriteArrayList<>();\n\n    private long mFlags;\n    private MediaButtonReceiverHolder mMediaButtonReceiverHolder;\n    private PendingIntent mLaunchIntent;\n\n    // TransportPerformer fields\n    private Bundle mExtras;\n    // Note: Avoid unparceling the bundle inside MediaMetadata since unparceling in system process\n    // may result in throwing an exception.\n    private MediaMetadata mMetadata;\n    private PlaybackState mPlaybackState;\n    private List<QueueItem> mQueue;\n    private CharSequence mQueueTitle;\n    private int mRatingType;\n    // End TransportPerformer fields\n\n    // Volume handling fields\n    private AudioAttributes mAudioAttrs;\n    private AudioManager mAudioManager;\n    private int mVolumeType = PlaybackInfo.PLAYBACK_TYPE_LOCAL;\n    private int mVolumeControlType = VolumeProvider.VOLUME_CONTROL_ABSOLUTE;\n    private int mMaxVolume = 0;\n    private int mCurrentVolume = 0;\n    private int mOptimisticVolume = -1;\n    private String mVolumeControlId;\n    // End volume handling fields\n\n    private boolean mIsActive = false;\n    private boolean mDestroyed = false;\n\n    private long mDuration = -1;\n    private String mMetadataDescription;\n\n    private int mPolicies;\n\n    public MediaSessionRecord(int ownerPid, int ownerUid, int userId, String ownerPackageName,\n            ISessionCallback cb, String tag, Bundle sessionInfo,\n            MediaSessionService service, Looper handlerLooper, int policies)\n            throws RemoteException {\n        mOwnerPid = ownerPid;\n        mOwnerUid = ownerUid;\n        mUserId = userId;\n        mPackageName = ownerPackageName;\n        mTag = tag;\n        mSessionInfo = sessionInfo;\n        mController = new ControllerStub();\n        mSessionToken = new MediaSession.Token(ownerUid, mController);\n        mSession = new SessionStub();\n        mSessionCb = new SessionCb(cb);\n        mService = service;\n        mContext = mService.getContext();\n        mHandler = new MessageHandler(handlerLooper);\n        mAudioManager = (AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE);\n        mAudioAttrs = DEFAULT_ATTRIBUTES;\n        mPolicies = policies;\n        mUgmInternal = LocalServices.getService(UriGrantsManagerInternal.class);\n        mVolumeAdjustmentForRemoteGroupSessions = mContext.getResources().getBoolean(\n                com.android.internal.R.bool.config_volumeAdjustmentForRemoteGroupSessions);\n\n        // May throw RemoteException if the session app is killed.\n        mSessionCb.mCb.asBinder().linkToDeath(this, 0);\n    }\n\n    /**\n     * Get the session binder for the {@link MediaSession}.\n     *\n     * @return The session binder apps talk to.\n     */\n    public ISession getSessionBinder() {\n        return mSession;\n    }\n\n    /**\n     * Get the session token for creating {@link MediaController}.\n     *\n     * @return The session token.\n     */\n    public MediaSession.Token getSessionToken() {\n        return mSessionToken;\n    }\n\n    /**\n     * Get the info for this session.\n     *\n     * @return Info that identifies this session.\n     */\n    @Override\n    public String getPackageName() {\n        return mPackageName;\n    }\n\n    /**\n     * Get the intent the app set for their media button receiver.\n     *\n     * @return The pending intent set by the app or null.\n     */\n    public MediaButtonReceiverHolder getMediaButtonReceiver() {\n        return mMediaButtonReceiverHolder;\n    }\n\n    /**\n     * Get the UID this session was created for.\n     *\n     * @return The UID for this session.\n     */\n    @Override\n    public int getUid() {\n        return mOwnerUid;\n    }\n\n    /**\n     * Get the user id this session was created for.\n     *\n     * @return The user id for this session.\n     */\n    @Override\n    public int getUserId() {\n        return mUserId;\n    }\n\n    /**\n     * Check if this session has system priorty and should receive media buttons\n     * before any other sessions.\n     *\n     * @return True if this is a system priority session, false otherwise\n     */\n    @Override\n    public boolean isSystemPriority() {\n        return (mFlags & MediaSession.FLAG_EXCLUSIVE_GLOBAL_PRIORITY) != 0;\n    }\n\n    /**\n     * Send a volume adjustment to the session owner. Direction must be one of\n     * {@link AudioManager#ADJUST_LOWER}, {@link AudioManager#ADJUST_RAISE},\n     * {@link AudioManager#ADJUST_SAME}.\n     *\n     * @param packageName The package that made the original volume request.\n     * @param opPackageName The op package that made the original volume request.\n     * @param pid The pid that made the original volume request.\n     * @param uid The uid that made the original volume request.\n     * @param asSystemService {@code true} if the event sent to the session as if it was come from\n     *          the system service instead of the app process. This helps sessions to distinguish\n     *          between the key injection by the app and key events from the hardware devices.\n     *          Should be used only when the volume key events aren't handled by foreground\n     *          activity. {@code false} otherwise to tell session about the real caller.\n     * @param direction The direction to adjust volume in.\n     * @param flags Any of the flags from {@link AudioManager}.\n     * @param useSuggested True to use adjustSuggestedStreamVolumeForUid instead of\n     *          adjustStreamVolumeForUid\n     */\n    public void adjustVolume(String packageName, String opPackageName, int pid, int uid,\n            boolean asSystemService, int direction, int flags, boolean useSuggested) {\n        int previousFlagPlaySound = flags & AudioManager.FLAG_PLAY_SOUND;\n        if (checkPlaybackActiveState(true) || isSystemPriority()) {\n            flags &= ~AudioManager.FLAG_PLAY_SOUND;\n        }\n        if (mVolumeType == PlaybackInfo.PLAYBACK_TYPE_LOCAL) {\n            // Adjust the volume with a handler not to be blocked by other system service.\n            int stream = getVolumeStream(mAudioAttrs);\n            postAdjustLocalVolume(stream, direction, flags, opPackageName, pid, uid,\n                    asSystemService, useSuggested, previousFlagPlaySound);\n        } else {\n            if (mVolumeControlType == VolumeProvider.VOLUME_CONTROL_FIXED) {\n                if (DEBUG) {\n                    Log.d(TAG, \"Session does not support volume adjustment\");\n                }\n            } else if (direction == AudioManager.ADJUST_TOGGLE_MUTE\n                    || direction == AudioManager.ADJUST_MUTE\n                    || direction == AudioManager.ADJUST_UNMUTE) {\n                Log.w(TAG, \"Muting remote playback is not supported\");\n            } else {\n                if (DEBUG) {\n                    Log.w(TAG, \"adjusting volume, pkg=\" + packageName + \", asSystemService=\"\n                            + asSystemService + \", dir=\" + direction);\n                }\n                mSessionCb.adjustVolume(packageName, pid, uid, asSystemService, direction);\n\n                int volumeBefore = (mOptimisticVolume < 0 ? mCurrentVolume : mOptimisticVolume);\n                mOptimisticVolume = volumeBefore + direction;\n                mOptimisticVolume = Math.max(0, Math.min(mOptimisticVolume, mMaxVolume));\n                mHandler.removeCallbacks(mClearOptimisticVolumeRunnable);\n                mHandler.postDelayed(mClearOptimisticVolumeRunnable, OPTIMISTIC_VOLUME_TIMEOUT);\n                if (volumeBefore != mOptimisticVolume) {\n                    pushVolumeUpdate();\n                }\n\n                if (DEBUG) {\n                    Log.d(TAG, \"Adjusted optimistic volume to \" + mOptimisticVolume + \" max is \"\n                            + mMaxVolume);\n                }\n            }\n            // Always notify, even if the volume hasn't changed. This is important to ensure that\n            // System UI receives an event if a hardware volume key is pressed but the session that\n            // handles it does not allow volume adjustment. Without such an event, System UI would\n            // not show volume controls to the user.\n            mService.notifyRemoteVolumeChanged(flags, this);\n        }\n    }\n\n    private void setVolumeTo(String packageName, String opPackageName, int pid, int uid, int value,\n            int flags) {\n        if (mVolumeType == PlaybackInfo.PLAYBACK_TYPE_LOCAL) {\n            int stream = getVolumeStream(mAudioAttrs);\n            final int volumeValue = value;\n            mHandler.post(new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        mAudioManager.setStreamVolumeForUid(stream, volumeValue, flags,\n                                opPackageName, uid, pid,\n                                mContext.getApplicationInfo().targetSdkVersion);\n                    } catch (IllegalArgumentException | SecurityException e) {\n                        Log.e(TAG, \"Cannot set volume: stream=\" + stream + \", value=\" + volumeValue\n                                + \", flags=\" + flags, e);\n                    }\n                }\n            });\n        } else {\n            if (mVolumeControlType != VolumeProvider.VOLUME_CONTROL_ABSOLUTE) {\n                if (DEBUG) {\n                    Log.d(TAG, \"Session does not support setting volume\");\n                }\n            } else {\n                value = Math.max(0, Math.min(value, mMaxVolume));\n                mSessionCb.setVolumeTo(packageName, pid, uid, value);\n\n                int volumeBefore = (mOptimisticVolume < 0 ? mCurrentVolume : mOptimisticVolume);\n                mOptimisticVolume = Math.max(0, Math.min(value, mMaxVolume));\n                mHandler.removeCallbacks(mClearOptimisticVolumeRunnable);\n                mHandler.postDelayed(mClearOptimisticVolumeRunnable, OPTIMISTIC_VOLUME_TIMEOUT);\n                if (volumeBefore != mOptimisticVolume) {\n                    pushVolumeUpdate();\n                }\n\n                if (DEBUG) {\n                    Log.d(TAG, \"Set optimistic volume to \" + mOptimisticVolume + \" max is \"\n                            + mMaxVolume);\n                }\n            }\n            // Always notify, even if the volume hasn't changed.\n            mService.notifyRemoteVolumeChanged(flags, this);\n        }\n    }\n\n    /**\n     * Check if this session has been set to active by the app.\n     * <p>\n     * It's not used to prioritize sessions for dispatching media keys since API 26, but still used\n     * to filter session list in MediaSessionManager#getActiveSessions().\n     *\n     * @return True if the session is active, false otherwise.\n     */\n    @Override\n    public boolean isActive() {\n        return mIsActive && !mDestroyed;\n    }\n\n    /**\n     * Check if the session's playback active state matches with the expectation. This always return\n     * {@code false} if the playback state is {@code null}, where we cannot know the actual playback\n     * state associated with the session.\n     *\n     * @param expected True if playback is expected to be active. false otherwise.\n     * @return True if the session's playback matches with the expectation. false otherwise.\n     */\n    @Override\n    public boolean checkPlaybackActiveState(boolean expected) {\n        if (mPlaybackState == null) {\n            return false;\n        }\n        return mPlaybackState.isActive() == expected;\n    }\n\n    /**\n     * Get whether the playback is local.\n     *\n     * @return {@code true} if the playback is local.\n     */\n    @Override\n    public boolean isPlaybackTypeLocal() {\n        return mVolumeType == PlaybackInfo.PLAYBACK_TYPE_LOCAL;\n    }\n\n    @Override\n    public void binderDied() {\n        mService.onSessionDied(this);\n    }\n\n    /**\n     * Finish cleaning up this session, including disconnecting if connected and\n     * removing the death observer from the callback binder.\n     */\n    @Override\n    public void close() {\n        synchronized (mLock) {\n            if (mDestroyed) {\n                return;\n            }\n            mSessionCb.mCb.asBinder().unlinkToDeath(this, 0);\n            mDestroyed = true;\n            mPlaybackState = null;\n            mHandler.post(MessageHandler.MSG_DESTROYED);\n        }\n    }\n\n    @Override\n    public boolean isClosed() {\n        synchronized (mLock) {\n            return mDestroyed;\n        }\n    }\n\n    /**\n     * Sends media button.\n     *\n     * @param packageName caller package name\n     * @param pid caller pid\n     * @param uid caller uid\n     * @param asSystemService {@code true} if the event sent to the session as if it was come from\n     *          the system service instead of the app process.\n     * @param ke key events\n     * @param sequenceId (optional) sequence id. Use this only when a wake lock is needed.\n     * @param cb (optional) result receiver to receive callback. Use this only when a wake lock is\n     *           needed.\n     * @return {@code true} if the attempt to send media button was successfully.\n     *         {@code false} otherwise.\n     */\n    public boolean sendMediaButton(String packageName, int pid, int uid, boolean asSystemService,\n            KeyEvent ke, int sequenceId, ResultReceiver cb) {\n        return mSessionCb.sendMediaButton(packageName, pid, uid, asSystemService, ke, sequenceId,\n                cb);\n    }\n\n    @Override\n    public boolean canHandleVolumeKey() {\n        if (isPlaybackTypeLocal() || mVolumeAdjustmentForRemoteGroupSessions) {\n            return true;\n        }\n        MediaRouter2Manager mRouter2Manager = MediaRouter2Manager.getInstance(mContext);\n        List<RoutingSessionInfo> sessions =\n                mRouter2Manager.getRoutingSessions(mPackageName);\n        boolean foundNonSystemSession = false;\n        boolean isGroup = false;\n        for (RoutingSessionInfo session : sessions) {\n            if (!session.isSystemSession()) {\n                foundNonSystemSession = true;\n                int selectedRouteCount = session.getSelectedRoutes().size();\n                if (selectedRouteCount > 1) {\n                    isGroup = true;\n                    break;\n                }\n            }\n        }\n        if (!foundNonSystemSession) {\n            Log.d(TAG, \"No routing session for \" + mPackageName);\n            return false;\n        }\n        return !isGroup;\n    }\n\n    @Override\n    public int getSessionPolicies() {\n        synchronized (mLock) {\n            return mPolicies;\n        }\n    }\n\n    @Override\n    public void setSessionPolicies(int policies) {\n        synchronized (mLock) {\n            mPolicies = policies;\n        }\n    }\n\n    @Override\n    public void dump(PrintWriter pw, String prefix) {\n        pw.println(prefix + mTag + \" \" + this);\n\n        final String indent = prefix + \"  \";\n        pw.println(indent + \"ownerPid=\" + mOwnerPid + \", ownerUid=\" + mOwnerUid\n                + \", userId=\" + mUserId);\n        pw.println(indent + \"package=\" + mPackageName);\n        pw.println(indent + \"launchIntent=\" + mLaunchIntent);\n        pw.println(indent + \"mediaButtonReceiver=\" + mMediaButtonReceiverHolder);\n        pw.println(indent + \"active=\" + mIsActive);\n        pw.println(indent + \"flags=\" + mFlags);\n        pw.println(indent + \"rating type=\" + mRatingType);\n        pw.println(indent + \"controllers: \" + mControllerCallbackHolders.size());\n        pw.println(indent + \"state=\" + (mPlaybackState == null ? null : mPlaybackState.toString()));\n        pw.println(indent + \"audioAttrs=\" + mAudioAttrs);\n        pw.println(indent + \"volumeType=\" + mVolumeType + \", controlType=\" + mVolumeControlType\n                + \", max=\" + mMaxVolume + \", current=\" + mCurrentVolume);\n        pw.println(indent + \"metadata: \" + mMetadataDescription);\n        pw.println(indent + \"queueTitle=\" + mQueueTitle + \", size=\"\n                + (mQueue == null ? 0 : mQueue.size()));\n    }\n\n    @Override\n    public String toString() {\n        return mPackageName + \"/\" + mTag + \" (userId=\" + mUserId + \")\";\n    }\n\n    private void postAdjustLocalVolume(final int stream, final int direction, final int flags,\n            final String callingOpPackageName, final int callingPid, final int callingUid,\n            final boolean asSystemService, final boolean useSuggested,\n            final int previousFlagPlaySound) {\n        if (DEBUG) {\n            Log.w(TAG, \"adjusting local volume, stream=\" + stream + \", dir=\" + direction\n                    + \", asSystemService=\" + asSystemService + \", useSuggested=\" + useSuggested);\n        }\n        // Must use opPackageName for adjusting volumes with UID.\n        final String opPackageName;\n        final int uid;\n        final int pid;\n        if (asSystemService) {\n            opPackageName = mContext.getOpPackageName();\n            uid = Process.SYSTEM_UID;\n            pid = Process.myPid();\n        } else {\n            opPackageName = callingOpPackageName;\n            uid = callingUid;\n            pid = callingPid;\n        }\n        mHandler.post(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    if (useSuggested) {\n                        if (AudioSystem.isStreamActive(stream, 0)) {\n                            mAudioManager.adjustSuggestedStreamVolumeForUid(stream,\n                                    direction, flags, opPackageName, uid, pid,\n                                    mContext.getApplicationInfo().targetSdkVersion);\n                        } else {\n                            mAudioManager.adjustSuggestedStreamVolumeForUid(\n                                    AudioManager.USE_DEFAULT_STREAM_TYPE, direction,\n                                    flags | previousFlagPlaySound, opPackageName, uid, pid,\n                                    mContext.getApplicationInfo().targetSdkVersion);\n                        }\n                    } else {\n                        mAudioManager.adjustStreamVolumeForUid(stream, direction, flags,\n                                opPackageName, uid, pid,\n                                mContext.getApplicationInfo().targetSdkVersion);\n                    }\n                } catch (IllegalArgumentException | SecurityException e) {\n                    Log.e(TAG, \"Cannot adjust volume: direction=\" + direction + \", stream=\"\n                            + stream + \", flags=\" + flags + \", opPackageName=\" + opPackageName\n                            + \", uid=\" + uid + \", useSuggested=\" + useSuggested\n                            + \", previousFlagPlaySound=\" + previousFlagPlaySound, e);\n                }\n            }\n        });\n    }\n\n    private void logCallbackException(\n            String msg, ISessionControllerCallbackHolder holder, Exception e) {\n        Log.v(TAG, msg + \", this=\" + this + \", callback package=\" + holder.mPackageName\n                + \", exception=\" + e);\n    }\n\n    private void pushPlaybackStateUpdate() {\n        PlaybackState playbackState;\n        synchronized (mLock) {\n            if (mDestroyed) {\n                return;\n            }\n            playbackState = mPlaybackState;\n        }\n        Collection<ISessionControllerCallbackHolder> deadCallbackHolders = null;\n        for (ISessionControllerCallbackHolder holder : mControllerCallbackHolders) {\n            try {\n                holder.mCallback.onPlaybackStateChanged(playbackState);\n            } catch (DeadObjectException e) {\n                if (deadCallbackHolders == null) {\n                    deadCallbackHolders = new ArrayList<>();\n                }\n                deadCallbackHolders.add(holder);\n                logCallbackException(\"Removing dead callback in pushPlaybackStateUpdate\", holder,\n                        e);\n            } catch (RemoteException e) {\n                logCallbackException(\"unexpected exception in pushPlaybackStateUpdate\", holder, e);\n            }\n        }\n        if (deadCallbackHolders != null) {\n            mControllerCallbackHolders.removeAll(deadCallbackHolders);\n        }\n    }\n\n    private void pushMetadataUpdate() {\n        MediaMetadata metadata;\n        synchronized (mLock) {\n            if (mDestroyed) {\n                return;\n            }\n            metadata = mMetadata;\n        }\n        Collection<ISessionControllerCallbackHolder> deadCallbackHolders = null;\n        for (ISessionControllerCallbackHolder holder : mControllerCallbackHolders) {\n            try {\n                holder.mCallback.onMetadataChanged(metadata);\n            } catch (DeadObjectException e) {\n                if (deadCallbackHolders == null) {\n                    deadCallbackHolders = new ArrayList<>();\n                }\n                deadCallbackHolders.add(holder);\n                logCallbackException(\"Removing dead callback in pushMetadataUpdate\", holder, e);\n            } catch (RemoteException e) {\n                logCallbackException(\"unexpected exception in pushMetadataUpdate\", holder, e);\n            }\n        }\n        if (deadCallbackHolders != null) {\n            mControllerCallbackHolders.removeAll(deadCallbackHolders);\n        }\n    }\n\n    private void pushQueueUpdate() {\n        ParceledListSlice<QueueItem> parcelableQueue;\n        synchronized (mLock) {\n            if (mDestroyed) {\n                return;\n            }\n            if (mQueue == null) {\n                parcelableQueue = null;\n            } else {\n                parcelableQueue = new ParceledListSlice<>(mQueue);\n                // Limit the size of initial Parcel to prevent binder buffer overflow\n                // as onQueueChanged is an async binder call.\n                parcelableQueue.setInlineCountLimit(1);\n            }\n        }\n        Collection<ISessionControllerCallbackHolder> deadCallbackHolders = null;\n        for (ISessionControllerCallbackHolder holder : mControllerCallbackHolders) {\n            try {\n                holder.mCallback.onQueueChanged(parcelableQueue);\n            } catch (DeadObjectException e) {\n                if (deadCallbackHolders == null) {\n                    deadCallbackHolders = new ArrayList<>();\n                }\n                deadCallbackHolders.add(holder);\n                logCallbackException(\"Removing dead callback in pushQueueUpdate\", holder, e);\n            } catch (RemoteException e) {\n                logCallbackException(\"unexpected exception in pushQueueUpdate\", holder, e);\n            }\n        }\n        if (deadCallbackHolders != null) {\n            mControllerCallbackHolders.removeAll(deadCallbackHolders);\n        }\n    }\n\n    private void pushQueueTitleUpdate() {\n        CharSequence queueTitle;\n        synchronized (mLock) {\n            if (mDestroyed) {\n                return;\n            }\n            queueTitle = mQueueTitle;\n        }\n        Collection<ISessionControllerCallbackHolder> deadCallbackHolders = null;\n        for (ISessionControllerCallbackHolder holder : mControllerCallbackHolders) {\n            try {\n                holder.mCallback.onQueueTitleChanged(queueTitle);\n            } catch (DeadObjectException e) {\n                if (deadCallbackHolders == null) {\n                    deadCallbackHolders = new ArrayList<>();\n                }\n                deadCallbackHolders.add(holder);\n                logCallbackException(\"Removing dead callback in pushQueueTitleUpdate\", holder, e);\n            } catch (RemoteException e) {\n                logCallbackException(\"unexpected exception in pushQueueTitleUpdate\", holder, e);\n            }\n        }\n        if (deadCallbackHolders != null) {\n            mControllerCallbackHolders.removeAll(deadCallbackHolders);\n        }\n    }\n\n    private void pushExtrasUpdate() {\n        Bundle extras;\n        synchronized (mLock) {\n            if (mDestroyed) {\n                return;\n            }\n            extras = mExtras;\n        }\n        Collection<ISessionControllerCallbackHolder> deadCallbackHolders = null;\n        for (ISessionControllerCallbackHolder holder : mControllerCallbackHolders) {\n            try {\n                holder.mCallback.onExtrasChanged(extras);\n            } catch (DeadObjectException e) {\n                if (deadCallbackHolders == null) {\n                    deadCallbackHolders = new ArrayList<>();\n                }\n                deadCallbackHolders.add(holder);\n                logCallbackException(\"Removing dead callback in pushExtrasUpdate\", holder, e);\n            } catch (RemoteException e) {\n                logCallbackException(\"unexpected exception in pushExtrasUpdate\", holder, e);\n            }\n        }\n        if (deadCallbackHolders != null) {\n            mControllerCallbackHolders.removeAll(deadCallbackHolders);\n        }\n    }\n\n    private void pushVolumeUpdate() {\n        PlaybackInfo info;\n        synchronized (mLock) {\n            if (mDestroyed) {\n                return;\n            }\n            info = getVolumeAttributes();\n        }\n        Collection<ISessionControllerCallbackHolder> deadCallbackHolders = null;\n        for (ISessionControllerCallbackHolder holder : mControllerCallbackHolders) {\n            try {\n                holder.mCallback.onVolumeInfoChanged(info);\n            } catch (DeadObjectException e) {\n                if (deadCallbackHolders == null) {\n                    deadCallbackHolders = new ArrayList<>();\n                }\n                deadCallbackHolders.add(holder);\n                logCallbackException(\"Removing dead callback in pushVolumeUpdate\", holder, e);\n            } catch (RemoteException e) {\n                logCallbackException(\"unexpected exception in pushVolumeUpdate\", holder, e);\n            }\n        }\n        if (deadCallbackHolders != null) {\n            mControllerCallbackHolders.removeAll(deadCallbackHolders);\n        }\n    }\n\n    private void pushEvent(String event, Bundle data) {\n        synchronized (mLock) {\n            if (mDestroyed) {\n                return;\n            }\n        }\n        Collection<ISessionControllerCallbackHolder> deadCallbackHolders = null;\n        for (ISessionControllerCallbackHolder holder : mControllerCallbackHolders) {\n            try {\n                holder.mCallback.onEvent(event, data);\n            } catch (DeadObjectException e) {\n                if (deadCallbackHolders == null) {\n                    deadCallbackHolders = new ArrayList<>();\n                }\n                deadCallbackHolders.add(holder);\n                logCallbackException(\"Removing dead callback in pushEvent\", holder, e);\n            } catch (RemoteException e) {\n                logCallbackException(\"unexpected exception in pushEvent\", holder, e);\n            }\n        }\n        if (deadCallbackHolders != null) {\n            mControllerCallbackHolders.removeAll(deadCallbackHolders);\n        }\n    }\n\n    private void pushSessionDestroyed() {\n        synchronized (mLock) {\n            // This is the only method that may be (and can only be) called\n            // after the session is destroyed.\n            if (!mDestroyed) {\n                return;\n            }\n        }\n        for (ISessionControllerCallbackHolder holder : mControllerCallbackHolders) {\n            try {\n                holder.mCallback.onSessionDestroyed();\n            } catch (DeadObjectException e) {\n                logCallbackException(\"Removing dead callback in pushSessionDestroyed\", holder, e);\n            } catch (RemoteException e) {\n                logCallbackException(\"unexpected exception in pushSessionDestroyed\", holder, e);\n            }\n        }\n        // After notifying clear all listeners\n        mControllerCallbackHolders.clear();\n    }\n\n    private PlaybackState getStateWithUpdatedPosition() {\n        PlaybackState state;\n        long duration;\n        synchronized (mLock) {\n            if (mDestroyed) {\n                return null;\n            }\n            state = mPlaybackState;\n            duration = mDuration;\n        }\n        PlaybackState result = null;\n        if (state != null) {\n            if (state.getState() == PlaybackState.STATE_PLAYING\n                    || state.getState() == PlaybackState.STATE_FAST_FORWARDING\n                    || state.getState() == PlaybackState.STATE_REWINDING) {\n                long updateTime = state.getLastPositionUpdateTime();\n                long currentTime = SystemClock.elapsedRealtime();\n                if (updateTime > 0) {\n                    long position = (long) (state.getPlaybackSpeed()\n                            * (currentTime - updateTime)) + state.getPosition();\n                    if (duration >= 0 && position > duration) {\n                        position = duration;\n                    } else if (position < 0) {\n                        position = 0;\n                    }\n                    PlaybackState.Builder builder = new PlaybackState.Builder(state);\n                    builder.setState(state.getState(), position, state.getPlaybackSpeed(),\n                            currentTime);\n                    result = builder.build();\n                }\n            }\n        }\n        return result == null ? state : result;\n    }\n\n    private int getControllerHolderIndexForCb(ISessionControllerCallback cb) {\n        IBinder binder = cb.asBinder();\n        for (int i = mControllerCallbackHolders.size() - 1; i >= 0; i--) {\n            if (binder.equals(mControllerCallbackHolders.get(i).mCallback.asBinder())) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    private PlaybackInfo getVolumeAttributes() {\n        int volumeType;\n        AudioAttributes attributes;\n        synchronized (mLock) {\n            if (mVolumeType == PlaybackInfo.PLAYBACK_TYPE_REMOTE) {\n                int current = mOptimisticVolume != -1 ? mOptimisticVolume : mCurrentVolume;\n                return new PlaybackInfo(mVolumeType, mVolumeControlType, mMaxVolume, current,\n                        mAudioAttrs, mVolumeControlId);\n            }\n            volumeType = mVolumeType;\n            attributes = mAudioAttrs;\n        }\n        int stream = getVolumeStream(attributes);\n        int max = mAudioManager.getStreamMaxVolume(stream);\n        int current = mAudioManager.getStreamVolume(stream);\n        return new PlaybackInfo(volumeType, VolumeProvider.VOLUME_CONTROL_ABSOLUTE, max,\n                current, attributes, null);\n    }\n\n    private final Runnable mClearOptimisticVolumeRunnable = new Runnable() {\n        @Override\n        public void run() {\n            boolean needUpdate = (mOptimisticVolume != mCurrentVolume);\n            mOptimisticVolume = -1;\n            if (needUpdate) {\n                pushVolumeUpdate();\n            }\n        }\n    };\n\n    @RequiresPermission(Manifest.permission.INTERACT_ACROSS_USERS)\n    private static boolean componentNameExists(\n            @NonNull ComponentName componentName, @NonNull Context context, int userId) {\n        Intent mediaButtonIntent = new Intent(Intent.ACTION_MEDIA_BUTTON);\n        mediaButtonIntent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);\n        mediaButtonIntent.setComponent(componentName);\n\n        UserHandle userHandle = UserHandle.of(userId);\n        PackageManager pm = context.getPackageManager();\n\n        List<ResolveInfo> resolveInfos =\n                pm.queryBroadcastReceiversAsUser(\n                        mediaButtonIntent, /* flags */ 0, userHandle);\n        return !resolveInfos.isEmpty();\n    }\n\n    private final class SessionStub extends ISession.Stub {\n        @Override\n        public void destroySession() throws RemoteException {\n            final long token = Binder.clearCallingIdentity();\n            try {\n                mService.onSessionDied(MediaSessionRecord.this);\n            } finally {\n                Binder.restoreCallingIdentity(token);\n            }\n        }\n\n        @Override\n        public void sendEvent(String event, Bundle data) throws RemoteException {\n            mHandler.post(MessageHandler.MSG_SEND_EVENT, event,\n                    data == null ? null : new Bundle(data));\n        }\n\n        @Override\n        public ISessionController getController() throws RemoteException {\n            return mController;\n        }\n\n        @Override\n        public void setActive(boolean active) throws RemoteException {\n            mIsActive = active;\n            final long token = Binder.clearCallingIdentity();\n            try {\n                mService.onSessionActiveStateChanged(MediaSessionRecord.this);\n            } finally {\n                Binder.restoreCallingIdentity(token);\n            }\n            mHandler.post(MessageHandler.MSG_UPDATE_SESSION_STATE);\n        }\n\n        @Override\n        public void setFlags(int flags) throws RemoteException {\n            if ((flags & MediaSession.FLAG_EXCLUSIVE_GLOBAL_PRIORITY) != 0) {\n                int pid = Binder.getCallingPid();\n                int uid = Binder.getCallingUid();\n                mService.enforcePhoneStatePermission(pid, uid);\n            }\n            mFlags = flags;\n            if ((flags & MediaSession.FLAG_EXCLUSIVE_GLOBAL_PRIORITY) != 0) {\n                final long token = Binder.clearCallingIdentity();\n                try {\n                    mService.setGlobalPrioritySession(MediaSessionRecord.this);\n                } finally {\n                    Binder.restoreCallingIdentity(token);\n                }\n            }\n            mHandler.post(MessageHandler.MSG_UPDATE_SESSION_STATE);\n        }\n\n        @Override\n        public void setMediaButtonReceiver(@Nullable PendingIntent pi) throws RemoteException {\n            final int uid = Binder.getCallingUid();\n            final long token = Binder.clearCallingIdentity();\n            try {\n                if ((mPolicies & MediaSessionPolicyProvider.SESSION_POLICY_IGNORE_BUTTON_RECEIVER)\n                        != 0) {\n                    return;\n                }\n\n                if (pi != null && pi.isActivity()) {\n                    if (CompatChanges.isChangeEnabled(\n                            THROW_FOR_ACTIVITY_MEDIA_BUTTON_RECEIVER, uid)) {\n                        throw new IllegalArgumentException(\n                                \"The media button receiver cannot be set to an activity.\");\n                    } else {\n                        Log.w(TAG, \"Ignoring invalid media button receiver targeting an activity.\");\n                        return;\n                    }\n                }\n\n                mMediaButtonReceiverHolder =\n                        MediaButtonReceiverHolder.create(mUserId, pi, mPackageName);\n                mService.onMediaButtonReceiverChanged(MediaSessionRecord.this);\n            } finally {\n                Binder.restoreCallingIdentity(token);\n            }\n        }\n\n        @Override\n        @RequiresPermission(Manifest.permission.INTERACT_ACROSS_USERS)\n        public void setMediaButtonBroadcastReceiver(ComponentName receiver) throws RemoteException {\n            final long token = Binder.clearCallingIdentity();\n            try {\n                //mPackageName has been verified in MediaSessionService.enforcePackageName().\n                if (receiver != null && !TextUtils.equals(\n                        mPackageName, receiver.getPackageName())) {\n                    EventLog.writeEvent(0x534e4554, \"238177121\", -1, \"\"); // SafetyNet logging.\n                    throw new IllegalArgumentException(\"receiver does not belong to \"\n                            + \"package name provided to MediaSessionRecord. Pkg = \" + mPackageName\n                            + \", Receiver Pkg = \" + receiver.getPackageName());\n                }\n                if ((mPolicies & MediaSessionPolicyProvider.SESSION_POLICY_IGNORE_BUTTON_RECEIVER)\n                        != 0) {\n                    return;\n                }\n\n                if (!componentNameExists(receiver, mContext, mUserId)) {\n                    Log.w(\n                            TAG,\n                            \"setMediaButtonBroadcastReceiver(): \"\n                                    + \"Ignoring invalid component name=\"\n                                    + receiver);\n                    return;\n                }\n\n                mMediaButtonReceiverHolder = MediaButtonReceiverHolder.create(mUserId, receiver);\n                mService.onMediaButtonReceiverChanged(MediaSessionRecord.this);\n            } finally {\n                Binder.restoreCallingIdentity(token);\n            }\n        }\n\n        @Override\n        public void setLaunchPendingIntent(PendingIntent pi) throws RemoteException {\n            mLaunchIntent = pi;\n        }\n\n        @Override\n        public void setMetadata(MediaMetadata metadata, long duration, String metadataDescription)\n                throws RemoteException {\n            synchronized (mLock) {\n                mDuration = duration;\n                mMetadataDescription = metadataDescription;\n                mMetadata = sanitizeMediaMetadata(metadata);\n            }\n            mHandler.post(MessageHandler.MSG_UPDATE_METADATA);\n        }\n\n        private MediaMetadata sanitizeMediaMetadata(MediaMetadata metadata) {\n            if (metadata == null) {\n                return null;\n            }\n            MediaMetadata.Builder metadataBuilder = new MediaMetadata.Builder(metadata);\n            for (String key: ART_URIS) {\n                String uriString = metadata.getString(key);\n                if (TextUtils.isEmpty(uriString)) {\n                    continue;\n                }\n                Uri uri = Uri.parse(uriString);\n                if (!ContentResolver.SCHEME_CONTENT.equals(uri.getScheme())) {\n                    continue;\n                }\n                try {\n                    mUgmInternal.checkGrantUriPermission(getUid(),\n                            getPackageName(),\n                            ContentProvider.getUriWithoutUserId(uri),\n                            Intent.FLAG_GRANT_READ_URI_PERMISSION,\n                            ContentProvider.getUserIdFromUri(uri, getUserId()));\n                } catch (SecurityException e) {\n                    metadataBuilder.putString(key, null);\n                }\n            }\n            MediaMetadata sanitizedMetadata = metadataBuilder.build();\n            // sanitizedMetadata.size() guarantees that the underlying bundle is unparceled\n            // before we set it to prevent concurrent reads from throwing an\n            // exception\n            sanitizedMetadata.size();\n            return sanitizedMetadata;\n        }\n\n        @Override\n        public void setPlaybackState(PlaybackState state) throws RemoteException {\n            int oldState = mPlaybackState == null\n                    ? PlaybackState.STATE_NONE : mPlaybackState.getState();\n            int newState = state == null\n                    ? PlaybackState.STATE_NONE : state.getState();\n            boolean shouldUpdatePriority = ALWAYS_PRIORITY_STATES.contains(newState)\n                    || (!TRANSITION_PRIORITY_STATES.contains(oldState)\n                    && TRANSITION_PRIORITY_STATES.contains(newState));\n            synchronized (mLock) {\n                mPlaybackState = state;\n            }\n            final long token = Binder.clearCallingIdentity();\n            try {\n                mService.onSessionPlaybackStateChanged(\n                        MediaSessionRecord.this, shouldUpdatePriority);\n            } finally {\n                Binder.restoreCallingIdentity(token);\n            }\n            mHandler.post(MessageHandler.MSG_UPDATE_PLAYBACK_STATE);\n        }\n\n        @Override\n        public void resetQueue() throws RemoteException {\n            synchronized (mLock) {\n                mQueue = null;\n            }\n            mHandler.post(MessageHandler.MSG_UPDATE_QUEUE);\n        }\n\n        @Override\n        public IBinder getBinderForSetQueue() throws RemoteException {\n            return new ParcelableListBinder<QueueItem>(\n                    QueueItem.class,\n                    (list) -> {\n                        synchronized (mLock) {\n                            mQueue = list;\n                        }\n                        mHandler.post(MessageHandler.MSG_UPDATE_QUEUE);\n                    });\n        }\n\n        @Override\n        public void setQueueTitle(CharSequence title) throws RemoteException {\n            mQueueTitle = title;\n            mHandler.post(MessageHandler.MSG_UPDATE_QUEUE_TITLE);\n        }\n\n        @Override\n        public void setExtras(Bundle extras) throws RemoteException {\n            synchronized (mLock) {\n                mExtras = extras == null ? null : new Bundle(extras);\n            }\n            mHandler.post(MessageHandler.MSG_UPDATE_EXTRAS);\n        }\n\n        @Override\n        public void setRatingType(int type) throws RemoteException {\n            mRatingType = type;\n        }\n\n        @Override\n        public void setCurrentVolume(int volume) throws RemoteException {\n            mCurrentVolume = volume;\n            mHandler.post(MessageHandler.MSG_UPDATE_VOLUME);\n        }\n\n        @Override\n        public void setPlaybackToLocal(AudioAttributes attributes) throws RemoteException {\n            boolean typeChanged;\n            synchronized (mLock) {\n                typeChanged = mVolumeType == PlaybackInfo.PLAYBACK_TYPE_REMOTE;\n                mVolumeType = PlaybackInfo.PLAYBACK_TYPE_LOCAL;\n                mVolumeControlId = null;\n                if (attributes != null) {\n                    mAudioAttrs = attributes;\n                } else {\n                    Log.e(TAG, \"Received null audio attributes, using existing attributes\");\n                }\n            }\n            if (typeChanged) {\n                final long token = Binder.clearCallingIdentity();\n                try {\n                    mService.onSessionPlaybackTypeChanged(MediaSessionRecord.this);\n                } finally {\n                    Binder.restoreCallingIdentity(token);\n                }\n                mHandler.post(MessageHandler.MSG_UPDATE_VOLUME);\n            }\n        }\n\n        @Override\n        public void setPlaybackToRemote(int control, int max, String controlId)\n                throws RemoteException {\n            boolean typeChanged;\n            synchronized (mLock) {\n                typeChanged = mVolumeType == PlaybackInfo.PLAYBACK_TYPE_LOCAL;\n                mVolumeType = PlaybackInfo.PLAYBACK_TYPE_REMOTE;\n                mVolumeControlType = control;\n                mMaxVolume = max;\n                mVolumeControlId = controlId;\n            }\n            if (typeChanged) {\n                final long token = Binder.clearCallingIdentity();\n                try {\n                    mService.onSessionPlaybackTypeChanged(MediaSessionRecord.this);\n                } finally {\n                    Binder.restoreCallingIdentity(token);\n                }\n                mHandler.post(MessageHandler.MSG_UPDATE_VOLUME);\n            }\n        }\n    }\n\n    class SessionCb {\n        private final ISessionCallback mCb;\n\n        SessionCb(ISessionCallback cb) {\n            mCb = cb;\n        }\n\n        public boolean sendMediaButton(String packageName, int pid, int uid,\n                boolean asSystemService, KeyEvent keyEvent, int sequenceId, ResultReceiver cb) {\n            try {\n                if (KeyEvent.isMediaSessionKey(keyEvent.getKeyCode())) {\n                    final String reason = \"action=\" + KeyEvent.actionToString(keyEvent.getAction())\n                            + \";code=\" + KeyEvent.keyCodeToString(keyEvent.getKeyCode());\n                    mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),\n                            pid, uid, packageName, reason);\n                }\n                if (asSystemService) {\n                    mCb.onMediaButton(mContext.getPackageName(), Process.myPid(),\n                            Process.SYSTEM_UID, createMediaButtonIntent(keyEvent), sequenceId, cb);\n                } else {\n                    mCb.onMediaButton(packageName, pid, uid,\n                            createMediaButtonIntent(keyEvent), sequenceId, cb);\n                }\n                return true;\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in sendMediaRequest.\", e);\n            }\n            return false;\n        }\n\n        public boolean sendMediaButton(String packageName, int pid, int uid,\n                boolean asSystemService, KeyEvent keyEvent) {\n            try {\n                if (KeyEvent.isMediaSessionKey(keyEvent.getKeyCode())) {\n                    final String reason = \"action=\" + KeyEvent.actionToString(keyEvent.getAction())\n                            + \";code=\" + KeyEvent.keyCodeToString(keyEvent.getKeyCode());\n                    mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),\n                            pid, uid, packageName, reason);\n                }\n                if (asSystemService) {\n                    mCb.onMediaButton(mContext.getPackageName(), Process.myPid(),\n                            Process.SYSTEM_UID, createMediaButtonIntent(keyEvent), 0, null);\n                } else {\n                    mCb.onMediaButtonFromController(packageName, pid, uid,\n                            createMediaButtonIntent(keyEvent));\n                }\n                return true;\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in sendMediaRequest.\", e);\n            }\n            return false;\n        }\n\n        public void sendCommand(String packageName, int pid, int uid, String command, Bundle args,\n                ResultReceiver cb) {\n            try {\n                mCb.onCommand(packageName, pid, uid, command, args, cb);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in sendCommand.\", e);\n            }\n        }\n\n        public void sendCustomAction(String packageName, int pid, int uid, String action,\n                Bundle args) {\n            try {\n                mCb.onCustomAction(packageName, pid, uid, action, args);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in sendCustomAction.\", e);\n            }\n        }\n\n        public void prepare(String packageName, int pid, int uid) {\n            try {\n                mCb.onPrepare(packageName, pid, uid);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in prepare.\", e);\n            }\n        }\n\n        public void prepareFromMediaId(String packageName, int pid, int uid, String mediaId,\n                Bundle extras) {\n            try {\n                mCb.onPrepareFromMediaId(packageName, pid, uid, mediaId, extras);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in prepareFromMediaId.\", e);\n            }\n        }\n\n        public void prepareFromSearch(String packageName, int pid, int uid, String query,\n                Bundle extras) {\n            try {\n                mCb.onPrepareFromSearch(packageName, pid, uid, query, extras);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in prepareFromSearch.\", e);\n            }\n        }\n\n        public void prepareFromUri(String packageName, int pid, int uid, Uri uri, Bundle extras) {\n            try {\n                mCb.onPrepareFromUri(packageName, pid, uid, uri, extras);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in prepareFromUri.\", e);\n            }\n        }\n\n        public void play(String packageName, int pid, int uid) {\n            try {\n                mCb.onPlay(packageName, pid, uid);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in play.\", e);\n            }\n        }\n\n        public void playFromMediaId(String packageName, int pid, int uid, String mediaId,\n                Bundle extras) {\n            try {\n                mCb.onPlayFromMediaId(packageName, pid, uid, mediaId, extras);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in playFromMediaId.\", e);\n            }\n        }\n\n        public void playFromSearch(String packageName, int pid, int uid, String query,\n                Bundle extras) {\n            try {\n                mCb.onPlayFromSearch(packageName, pid, uid, query, extras);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in playFromSearch.\", e);\n            }\n        }\n\n        public void playFromUri(String packageName, int pid, int uid, Uri uri, Bundle extras) {\n            try {\n                mCb.onPlayFromUri(packageName, pid, uid, uri, extras);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in playFromUri.\", e);\n            }\n        }\n\n        public void skipToTrack(String packageName, int pid, int uid, long id) {\n            try {\n                mCb.onSkipToTrack(packageName, pid, uid, id);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in skipToTrack\", e);\n            }\n        }\n\n        public void pause(String packageName, int pid, int uid) {\n            try {\n                mCb.onPause(packageName, pid, uid);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in pause.\", e);\n            }\n        }\n\n        public void stop(String packageName, int pid, int uid) {\n            try {\n                mCb.onStop(packageName, pid, uid);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in stop.\", e);\n            }\n        }\n\n        public void next(String packageName, int pid, int uid) {\n            try {\n                mCb.onNext(packageName, pid, uid);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in next.\", e);\n            }\n        }\n\n        public void previous(String packageName, int pid, int uid) {\n            try {\n                mCb.onPrevious(packageName, pid, uid);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in previous.\", e);\n            }\n        }\n\n        public void fastForward(String packageName, int pid, int uid) {\n            try {\n                mCb.onFastForward(packageName, pid, uid);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in fastForward.\", e);\n            }\n        }\n\n        public void rewind(String packageName, int pid, int uid) {\n            try {\n                mCb.onRewind(packageName, pid, uid);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in rewind.\", e);\n            }\n        }\n\n        public void seekTo(String packageName, int pid, int uid, long pos) {\n            try {\n                mCb.onSeekTo(packageName, pid, uid, pos);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in seekTo.\", e);\n            }\n        }\n\n        public void rate(String packageName, int pid, int uid, Rating rating) {\n            try {\n                mCb.onRate(packageName, pid, uid, rating);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in rate.\", e);\n            }\n        }\n\n        public void setPlaybackSpeed(String packageName, int pid, int uid, float speed) {\n            try {\n                mCb.onSetPlaybackSpeed(packageName, pid, uid, speed);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in setPlaybackSpeed.\", e);\n            }\n        }\n\n        public void adjustVolume(String packageName, int pid, int uid, boolean asSystemService,\n                int direction) {\n            try {\n                if (asSystemService) {\n                    mCb.onAdjustVolume(mContext.getPackageName(), Process.myPid(),\n                            Process.SYSTEM_UID, direction);\n                } else {\n                    mCb.onAdjustVolume(packageName, pid, uid, direction);\n                }\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in adjustVolume.\", e);\n            }\n        }\n\n        public void setVolumeTo(String packageName, int pid, int uid, int value) {\n            try {\n                mCb.onSetVolumeTo(packageName, pid, uid, value);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Remote failure in setVolumeTo.\", e);\n            }\n        }\n\n        private Intent createMediaButtonIntent(KeyEvent keyEvent) {\n            Intent mediaButtonIntent = new Intent(Intent.ACTION_MEDIA_BUTTON);\n            mediaButtonIntent.putExtra(Intent.EXTRA_KEY_EVENT, keyEvent);\n            return mediaButtonIntent;\n        }\n    }\n\n    class ControllerStub extends ISessionController.Stub {\n        @Override\n        public void sendCommand(String packageName, String command, Bundle args,\n                ResultReceiver cb) {\n            mSessionCb.sendCommand(packageName, Binder.getCallingPid(), Binder.getCallingUid(),\n                    command, args, cb);\n        }\n\n        @Override\n        public boolean sendMediaButton(String packageName, KeyEvent keyEvent) {\n            return mSessionCb.sendMediaButton(packageName, Binder.getCallingPid(),\n                    Binder.getCallingUid(), false, keyEvent);\n        }\n\n        @Override\n        public void registerCallback(String packageName, ISessionControllerCallback cb) {\n            synchronized (mLock) {\n                // If this session is already destroyed tell the caller and\n                // don't add them.\n                if (mDestroyed) {\n                    try {\n                        cb.onSessionDestroyed();\n                    } catch (Exception e) {\n                        // ignored\n                    }\n                    return;\n                }\n                if (getControllerHolderIndexForCb(cb) < 0) {\n                    mControllerCallbackHolders.add(new ISessionControllerCallbackHolder(cb,\n                            packageName, Binder.getCallingUid()));\n                    if (DEBUG) {\n                        Log.d(TAG, \"registering controller callback \" + cb + \" from controller\"\n                                + packageName);\n                    }\n                }\n            }\n        }\n\n        @Override\n        public void unregisterCallback(ISessionControllerCallback cb) {\n            synchronized (mLock) {\n                int index = getControllerHolderIndexForCb(cb);\n                if (index != -1) {\n                    mControllerCallbackHolders.remove(index);\n                }\n                if (DEBUG) {\n                    Log.d(TAG, \"unregistering callback \" + cb.asBinder());\n                }\n            }\n        }\n\n        @Override\n        public String getPackageName() {\n            return mPackageName;\n        }\n\n        @Override\n        public String getTag() {\n            return mTag;\n        }\n\n        @Override\n        public Bundle getSessionInfo() {\n            return mSessionInfo;\n        }\n\n        @Override\n        public PendingIntent getLaunchPendingIntent() {\n            return mLaunchIntent;\n        }\n\n        @Override\n        public long getFlags() {\n            return mFlags;\n        }\n\n        @Override\n        public PlaybackInfo getVolumeAttributes() {\n            return MediaSessionRecord.this.getVolumeAttributes();\n        }\n\n        @Override\n        public void adjustVolume(String packageName, String opPackageName, int direction,\n                int flags) {\n            int pid = Binder.getCallingPid();\n            int uid = Binder.getCallingUid();\n            final long token = Binder.clearCallingIdentity();\n            try {\n                MediaSessionRecord.this.adjustVolume(packageName, opPackageName, pid, uid,\n                        false, direction, flags, false /* useSuggested */);\n            } finally {\n                Binder.restoreCallingIdentity(token);\n            }\n        }\n\n        @Override\n        public void setVolumeTo(String packageName, String opPackageName, int value, int flags) {\n            int pid = Binder.getCallingPid();\n            int uid = Binder.getCallingUid();\n            final long token = Binder.clearCallingIdentity();\n            try {\n                MediaSessionRecord.this.setVolumeTo(packageName, opPackageName, pid, uid, value,\n                        flags);\n            } finally {\n                Binder.restoreCallingIdentity(token);\n            }\n        }\n\n        @Override\n        public void prepare(String packageName) {\n            mSessionCb.prepare(packageName, Binder.getCallingPid(), Binder.getCallingUid());\n        }\n\n        @Override\n        public void prepareFromMediaId(String packageName, String mediaId, Bundle extras) {\n            mSessionCb.prepareFromMediaId(packageName, Binder.getCallingPid(),\n                    Binder.getCallingUid(), mediaId, extras);\n        }\n\n        @Override\n        public void prepareFromSearch(String packageName, String query, Bundle extras) {\n            mSessionCb.prepareFromSearch(packageName, Binder.getCallingPid(),\n                    Binder.getCallingUid(), query, extras);\n        }\n\n        @Override\n        public void prepareFromUri(String packageName, Uri uri, Bundle extras) {\n            mSessionCb.prepareFromUri(packageName, Binder.getCallingPid(), Binder.getCallingUid(),\n                    uri, extras);\n        }\n\n        @Override\n        public void play(String packageName) {\n            mSessionCb.play(packageName, Binder.getCallingPid(), Binder.getCallingUid());\n        }\n\n        @Override\n        public void playFromMediaId(String packageName, String mediaId, Bundle extras) {\n            mSessionCb.playFromMediaId(packageName, Binder.getCallingPid(), Binder.getCallingUid(),\n                    mediaId, extras);\n        }\n\n        @Override\n        public void playFromSearch(String packageName, String query, Bundle extras) {\n            mSessionCb.playFromSearch(packageName, Binder.getCallingPid(), Binder.getCallingUid(),\n                     query, extras);\n        }\n\n        @Override\n        public void playFromUri(String packageName, Uri uri, Bundle extras) {\n            mSessionCb.playFromUri(packageName, Binder.getCallingPid(), Binder.getCallingUid(),\n                    uri, extras);\n        }\n\n        @Override\n        public void skipToQueueItem(String packageName, long id) {\n            mSessionCb.skipToTrack(packageName, Binder.getCallingPid(), Binder.getCallingUid(), id);\n        }\n\n        @Override\n        public void pause(String packageName) {\n            mSessionCb.pause(packageName, Binder.getCallingPid(), Binder.getCallingUid());\n        }\n\n        @Override\n        public void stop(String packageName) {\n            mSessionCb.stop(packageName, Binder.getCallingPid(), Binder.getCallingUid());\n        }\n\n        @Override\n        public void next(String packageName) {\n            mSessionCb.next(packageName, Binder.getCallingPid(), Binder.getCallingUid());\n        }\n\n        @Override\n        public void previous(String packageName) {\n            mSessionCb.previous(packageName, Binder.getCallingPid(), Binder.getCallingUid());\n        }\n\n        @Override\n        public void fastForward(String packageName) {\n            mSessionCb.fastForward(packageName, Binder.getCallingPid(), Binder.getCallingUid());\n        }\n\n        @Override\n        public void rewind(String packageName) {\n            mSessionCb.rewind(packageName, Binder.getCallingPid(), Binder.getCallingUid());\n        }\n\n        @Override\n        public void seekTo(String packageName, long pos) {\n            mSessionCb.seekTo(packageName, Binder.getCallingPid(), Binder.getCallingUid(), pos);\n        }\n\n        @Override\n        public void rate(String packageName, Rating rating) {\n            mSessionCb.rate(packageName, Binder.getCallingPid(), Binder.getCallingUid(), rating);\n        }\n\n        @Override\n        public void setPlaybackSpeed(String packageName,\n                float speed) {\n            mSessionCb.setPlaybackSpeed(packageName, Binder.getCallingPid(), Binder.getCallingUid(),\n                    speed);\n        }\n\n        @Override\n        public void sendCustomAction(String packageName, String action, Bundle args) {\n            mSessionCb.sendCustomAction(packageName, Binder.getCallingPid(), Binder.getCallingUid(),\n                    action, args);\n        }\n\n        @Override\n        public MediaMetadata getMetadata() {\n            synchronized (mLock) {\n                return mMetadata;\n            }\n        }\n\n        @Override\n        public PlaybackState getPlaybackState() {\n            return getStateWithUpdatedPosition();\n        }\n\n        @Override\n        public ParceledListSlice getQueue() {\n            synchronized (mLock) {\n                return mQueue == null ? null : new ParceledListSlice<>(mQueue);\n            }\n        }\n\n        @Override\n        public CharSequence getQueueTitle() {\n            return mQueueTitle;\n        }\n\n        @Override\n        public Bundle getExtras() {\n            synchronized (mLock) {\n                return mExtras;\n            }\n        }\n\n        @Override\n        public int getRatingType() {\n            return mRatingType;\n        }\n    }\n\n    private class ISessionControllerCallbackHolder {\n        private final ISessionControllerCallback mCallback;\n        private final String mPackageName;\n        private final int mUid;\n\n        ISessionControllerCallbackHolder(ISessionControllerCallback callback, String packageName,\n                int uid) {\n            mCallback = callback;\n            mPackageName = packageName;\n            mUid = uid;\n        }\n    }\n\n    private class MessageHandler extends Handler {\n        private static final int MSG_UPDATE_METADATA = 1;\n        private static final int MSG_UPDATE_PLAYBACK_STATE = 2;\n        private static final int MSG_UPDATE_QUEUE = 3;\n        private static final int MSG_UPDATE_QUEUE_TITLE = 4;\n        private static final int MSG_UPDATE_EXTRAS = 5;\n        private static final int MSG_SEND_EVENT = 6;\n        private static final int MSG_UPDATE_SESSION_STATE = 7;\n        private static final int MSG_UPDATE_VOLUME = 8;\n        private static final int MSG_DESTROYED = 9;\n\n        public MessageHandler(Looper looper) {\n            super(looper);\n        }\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MSG_UPDATE_METADATA:\n                    pushMetadataUpdate();\n                    break;\n                case MSG_UPDATE_PLAYBACK_STATE:\n                    pushPlaybackStateUpdate();\n                    break;\n                case MSG_UPDATE_QUEUE:\n                    pushQueueUpdate();\n                    break;\n                case MSG_UPDATE_QUEUE_TITLE:\n                    pushQueueTitleUpdate();\n                    break;\n                case MSG_UPDATE_EXTRAS:\n                    pushExtrasUpdate();\n                    break;\n                case MSG_SEND_EVENT:\n                    pushEvent((String) msg.obj, msg.getData());\n                    break;\n                case MSG_UPDATE_SESSION_STATE:\n                    // TODO add session state\n                    break;\n                case MSG_UPDATE_VOLUME:\n                    pushVolumeUpdate();\n                    break;\n                case MSG_DESTROYED:\n                    pushSessionDestroyed();\n            }\n        }\n\n        public void post(int what) {\n            post(what, null);\n        }\n\n        public void post(int what, Object obj) {\n            obtainMessage(what, obj).sendToTarget();\n        }\n\n        public void post(int what, Object obj, Bundle data) {\n            Message msg = obtainMessage(what, obj);\n            msg.setData(data);\n            msg.sendToTarget();\n        }\n    }\n}\n```"
                    }
                ]
            }
        ],
        "upstream_patch_content": "From fda5a94aaf91933f8602e00d78ad9ba4872c72f4 Mon Sep 17 00:00:00 2001\nFrom: =?UTF-8?q?Iv=C3=A1n=20Budnik?= <ivanbuper@google.com>\nDate: Wed, 21 Jun 2023 16:34:37 +0000\nSubject: [PATCH] Prevent media button receivers targeting activities\n\nThis enforcement prevents a bypass of background activity launches.\n\nBug: 272737196\nTest: atest MediaSessionHostTest MediaSessionTest\n(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:edf219ab08fdf5390aac6dd18fcdab76daa3488a)\nChange-Id: I07c2521f3d97f94e245a25bbb6f49f75cf54a808\n---\n .../android/media/session/MediaSession.java   | 28 ++++++++++++-------\n .../server/media/MediaSessionRecord.java      | 25 ++++++++++++++++-\n 2 files changed, 42 insertions(+), 11 deletions(-)\n\ndiff --git a/media/java/android/media/session/MediaSession.java b/media/java/android/media/session/MediaSession.java\nindex af33149867bd..f664fdc949de 100644\n--- a/media/java/android/media/session/MediaSession.java\n+++ b/media/java/android/media/session/MediaSession.java\n@@ -267,25 +267,33 @@ public final class MediaSession {\n     }\n \n     /**\n-     * Set a pending intent for your media button receiver to allow restarting\n-     * playback after the session has been stopped. If your app is started in\n-     * this way an {@link Intent#ACTION_MEDIA_BUTTON} intent will be sent via\n-     * the pending intent.\n-     * <p>\n-     * The pending intent is recommended to be explicit to follow the security recommendation of\n-     * {@link PendingIntent#getActivity}.\n+     * Set a pending intent for your media button receiver to allow restarting playback after the\n+     * session has been stopped.\n      *\n-     * @param mbr The {@link PendingIntent} to send the media button event to.\n-     * @see PendingIntent#getActivity\n+     * <p>If your app is started in this way an {@link Intent#ACTION_MEDIA_BUTTON} intent will be\n+     * sent via the pending intent.\n+     *\n+     * <p>The provided {@link PendingIntent} must not target an activity. On apps targeting Android\n+     * V and above, passing an activity pending intent to this method causes an {@link\n+     * IllegalArgumentException}. On apps targeting Android U and below, passing an activity pending\n+     * intent causes the call to be ignored. Refer to this <a\n+     * href=\"https://developer.android.com/guide/components/activities/background-starts\">guide</a>\n+     * for more information.\n      *\n+     * <p>The pending intent is recommended to be explicit to follow the security recommendation of\n+     * {@link PendingIntent#getService}.\n+     *\n+     * @param mbr The {@link PendingIntent} to send the media button event to.\n      * @deprecated Use {@link #setMediaButtonBroadcastReceiver(ComponentName)} instead.\n+     * @throws IllegalArgumentException if the pending intent targets an activity on apps targeting\n+     * Android V and above.\n      */\n     @Deprecated\n     public void setMediaButtonReceiver(@Nullable PendingIntent mbr) {\n         try {\n             mBinder.setMediaButtonReceiver(mbr);\n         } catch (RemoteException e) {\n-            Log.wtf(TAG, \"Failure in setMediaButtonReceiver.\", e);\n+            e.rethrowFromSystemServer();\n         }\n     }\n \ndiff --git a/services/core/java/com/android/server/media/MediaSessionRecord.java b/services/core/java/com/android/server/media/MediaSessionRecord.java\nindex 9185a00da570..95ca08cc7fe9 100644\n--- a/services/core/java/com/android/server/media/MediaSessionRecord.java\n+++ b/services/core/java/com/android/server/media/MediaSessionRecord.java\n@@ -106,6 +106,16 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR\n     @EnabledSince(targetSdkVersion = Build.VERSION_CODES.UPSIDE_DOWN_CAKE)\n     static final long THROW_FOR_INVALID_BROADCAST_RECEIVER = 270049379L;\n \n+    /**\n+     * {@link MediaSession#setMediaButtonReceiver(PendingIntent)} throws an {@link\n+     * IllegalArgumentException} if the provided {@link PendingIntent} targets an {@link\n+     * android.app.Activity activity} for apps targeting Android V and above. For apps targeting\n+     * Android U and below, the request will be ignored.\n+     */\n+    @ChangeId\n+    @EnabledSince(targetSdkVersion = Build.VERSION_CODES.VANILLA_ICE_CREAM)\n+    static final long THROW_FOR_ACTIVITY_MEDIA_BUTTON_RECEIVER = 272737196L;\n+\n     private static final String TAG = \"MediaSessionRecord\";\n     private static final String[] ART_URIS = new String[] {\n             MediaMetadata.METADATA_KEY_ALBUM_ART_URI,\n@@ -1055,13 +1065,26 @@ public class MediaSessionRecord implements IBinder.DeathRecipient, MediaSessionR\n         }\n \n         @Override\n-        public void setMediaButtonReceiver(PendingIntent pi) throws RemoteException {\n+        public void setMediaButtonReceiver(@Nullable PendingIntent pi) throws RemoteException {\n+            final int uid = Binder.getCallingUid();\n             final long token = Binder.clearCallingIdentity();\n             try {\n                 if ((mPolicies & MediaSessionPolicyProvider.SESSION_POLICY_IGNORE_BUTTON_RECEIVER)\n                         != 0) {\n                     return;\n                 }\n+\n+                if (pi != null && pi.isActivity()) {\n+                    if (CompatChanges.isChangeEnabled(\n+                            THROW_FOR_ACTIVITY_MEDIA_BUTTON_RECEIVER, uid)) {\n+                        throw new IllegalArgumentException(\n+                                \"The media button receiver cannot be set to an activity.\");\n+                    } else {\n+                        Log.w(TAG, \"Ignoring invalid media button receiver targeting an activity.\");\n+                        return;\n+                    }\n+                }\n+\n                 mMediaButtonReceiverHolder =\n                         MediaButtonReceiverHolder.create(mUserId, pi, mPackageName);\n                 mService.onMediaButtonReceiverChanged(MediaSessionRecord.this);\n-- \n2.39.5 (Apple Git-154)\n\n",
        "upstream_commits": [
            "fda5a94aaf91933f8602e00d78ad9ba4872c72f4"
        ]
    }
]